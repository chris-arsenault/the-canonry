[{"id": "apps/canonry/webui/src/storage/useProjectStorage.js::useProjectStorage", "name": "useProjectStorage", "kind": "hook", "filePath": "apps/canonry/webui/src/storage/useProjectStorage.js", "sourceCode": "export function useProjectStorage() {\n  const [projects, setProjects] = useState([]);\n  const [currentProject, setCurrentProject] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Load project list on mount\n  useEffect(() => {\n    async function init() {\n      try {\n        await openDatabase();\n        let list = await listProjects();\n\n        // If no projects exist, load the default seed project\n        if (list.length === 0) {\n          const defaultData = await fetchDefaultProject();\n          if (defaultData?.project) {\n            await saveProject(defaultData.project);\n            list = await listProjects();\n\n            // Store illuminatorConfig in worldStore if present\n            if (defaultData.illuminatorConfig) {\n              const worldStoreData = {\n                activeSlotIndex: 0,\n                ...defaultData.illuminatorConfig,\n              };\n              await saveWorldStore(defaultData.project.id, worldStoreData);\n            }\n          }\n        }\n\n        setProjects(list);\n\n        // Auto-load last opened project if possible, otherwise most recent\n        if (list.length > 0) {\n          const lastProjectId = loadLastProjectId();\n          if (lastProjectId) {\n            const project = await loadProject(lastProjectId);\n            if (project) {\n              setCurrentProject(project);\n              return;\n            }\n          }\n          const project = await loadProject(list[0].id);\n          setCurrentProject(project);\n        }\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n    init();\n  }, []);\n\n  useEffect(() => {\n    if (currentProject?.id) {\n      saveLastProjectId(currentProject.id);\n    } else {\n      saveLastProjectId(null);\n    }\n  }, [currentProject?.id]);\n\n  // Refresh project list\n  const refreshList = useCallback(async () => {\n    try {\n      const list = await listProjects();\n      setProjects(list);\n    } catch (err) {\n      setError(err.message);\n    }\n  }, []);\n\n  // Create new project\n  const createProject = useCallback(\n    async (name) => {\n      try {\n        const project = createEmptyProject(name);\n        await saveProject(project);\n        await refreshList();\n        setCurrentProject(project);\n        return project;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Open existing project\n  const openProject = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      const project = await loadProject(id);\n      if (project) {\n        setCurrentProject(project);\n      } else {\n        throw new Error(`Project ${id} not found`);\n      }\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Save current project (auto-save on changes)\n  // Uses ref to track pending updates and avoid stale closure issues\n  const pendingUpdatesRef = useRef({});\n\n  const save = useCallback(\n    async (updates = {}) => {\n      if (!currentProject) return;\n\n      try {\n        // Merge with any pending updates to handle rapid sequential saves\n        pendingUpdatesRef.current = { ...pendingUpdatesRef.current, ...updates };\n        const allUpdates = pendingUpdatesRef.current;\n\n        const updated = { ...currentProject, ...allUpdates };\n        await saveProject(updated);\n        setCurrentProject(updated);\n\n        // Clear pending updates after successful save\n        pendingUpdatesRef.current = {};\n        await refreshList();\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject, refreshList]\n  );\n\n  // Delete project\n  const removeProject = useCallback(\n    async (id) => {\n      try {\n        await deleteProject(id);\n        await refreshList();\n\n        // If deleted current project, switch to another\n        if (currentProject?.id === id) {\n          const list = await listProjects();\n          if (list.length > 0) {\n            const project = await loadProject(list[0].id);\n            setCurrentProject(project);\n          } else {\n            setCurrentProject(null);\n          }\n        }\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject, refreshList]\n  );\n\n  // Duplicate project\n  const duplicateProject = useCallback(\n    async (id) => {\n      try {\n        const source = await loadProject(id);\n        if (!source) throw new Error(`Project ${id} not found`);\n\n        const duplicate = {\n          ...source,\n          id: `project_${Date.now()}`,\n          name: `${source.name} (copy)`,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        };\n\n        await saveProject(duplicate);\n        await refreshList();\n        return duplicate;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Export project as a zip file (Blob)\n  // Includes Illuminator configuration from worldStore and static pages\n  const exportProject = useCallback(\n    async (project = currentProject) => {\n      if (!project) return null;\n      try {\n        // Load Illuminator config from worldStore\n        let illuminatorConfig = null;\n        const worldStore = await loadWorldStore(project.id);\n        if (worldStore) {\n          // Export entityGuidance and cultureIdentities at top level\n          illuminatorConfig = {\n            worldContext: worldStore.worldContext || null,\n            entityGuidance: worldStore.entityGuidance || null,\n            cultureIdentities: worldStore.cultureIdentities || null,\n            enrichmentConfig: worldStore.enrichmentConfig || null,\n            styleSelection: worldStore.styleSelection || null,\n            historianConfig: worldStore.historianConfig || null,\n          };\n          // Only include if there's actual data\n          const hasData = Object.values(illuminatorConfig).some((v) => v !== null);\n          if (!hasData) {\n            illuminatorConfig = null;\n          }\n        }\n\n        // Load static pages from IndexedDB\n        const staticPages = await getStaticPagesForProject(project.id);\n\n        const zipBlob = await createProjectZip(project, { illuminatorConfig, staticPages });\n        return zipBlob;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [currentProject]\n  );\n\n  // Import project from zip file (Blob or File)\n  // Restores Illuminator configuration to worldStore and imports static pages\n  const importProject = useCallback(\n    async (input) => {\n      try {\n        let extractedData;\n\n        // Check if input is a Blob/File (zip)\n        if (input instanceof Blob) {\n          extractedData = await extractProjectZip(input);\n        } else {\n          throw new Error(\"Invalid import format: expected zip file\");\n        }\n\n        const { project: data, illuminatorConfig, staticPages } = extractedData;\n\n        // Generate new ID to avoid conflicts\n        let project = {\n          ...data,\n          id: `project_${Date.now()}`,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        };\n\n        await saveProject(project);\n\n        // Restore Illuminator configuration to worldStore\n        if (illuminatorConfig) {\n          const worldStoreData = {\n            activeSlotIndex: 0,\n            ...illuminatorConfig,\n          };\n          await saveWorldStore(project.id, worldStoreData);\n        }\n\n        // Import static pages if present\n        if (staticPages && staticPages.length > 0) {\n          await importStaticPages(project.id, staticPages);\n        }\n\n        await refreshList();\n        setCurrentProject(project);\n        return project;\n      } catch (err) {\n        setError(err.message);\n        throw err;\n      }\n    },\n    [refreshList]\n  );\n\n  // Reload current project from default files (merge overwrite)\n  // Only works for the default project\n  const reloadProjectFromDefaults = useCallback(async () => {\n    if (!currentProject) return null;\n    if (currentProject.id !== DEFAULT_PROJECT_ID) {\n      throw new Error(\"Can only reload the default project from defaults\");\n    }\n\n    try {\n      setLoading(true);\n\n      // Fetch fresh default project files\n      const defaultData = await fetchDefaultProject();\n      if (!defaultData?.project) {\n        throw new Error(\"Failed to load default project files\");\n      }\n\n      // Merge: use fresh data but preserve the current project's ID and timestamps\n      const reloaded = {\n        ...defaultData.project,\n        id: currentProject.id,\n        createdAt: currentProject.createdAt,\n        updatedAt: new Date().toISOString(),\n// ... (truncated)", "parameters": [], "returnType": "{ projects: any[]; currentProject: any; loading: boolean; error: any; createProject: (name: any) => Promise<{ id: string; name: string; version: string; createdAt: string; updatedAt: string; entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; axisDefinitions: any[]; uiConfig: { worldIcon: string; prominenceLevels: string[]; prominenceColors: { forgotten: string; marginal: string; recognized: string; renowned: string; mythic: string; }; }; eras: any[]; pressures: any[]; generators: any[]; systems: any[]; actions: any[]; seedEntities: any[]; seedRelationships: any[]; distributionTargets: any; simulation: any; }>; openProject: (id: any) => Promise<void>; save: (updates?: {}) => Promise<void>; removeProject: (id: any) => Promise<void>; duplicateProject: (id: any) => Promise<any>; exportProject: (project?: any) => Promise<Blob>; importProject: (input: any) => Promise<any>; reloadProjectFromDefaults: () => Promise<any>; refreshList: () => Promise<void>; DEFAULT_PROJECT_ID: string; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 9}, {"name": "useRef", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "./db.js", "specifiers": ["openDatabase", "saveProject", "loadProject", "deleteProject", "listProjects", "createEmptyProject"], "category": "internal"}, {"source": "./uiState.js", "specifiers": ["loadLastProjectId", "saveLastProjectId"], "category": "internal"}, {"source": "./worldStore.js", "specifiers": ["loadWorldStore", "saveWorldStore"], "category": "internal"}, {"source": "./staticPageStorage.js", "specifiers": ["getStaticPagesForProject", "importStaticPages", "loadAndImportSeedPages"], "category": "internal"}, {"source": "@canonry/dsl", "specifiers": ["compileCanonProject", "compileCanonStaticPages", "serializeCanonProject", "serializeCanonStaticPages"], "category": "external"}], "storeAccess": []}]