[{"id": "apps/illuminator/webui/src/components/ResultsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ResultsPanel.jsx", "sourceCode": "export default function ResultsPanel({ tasks, entities = [], onRegenerateTask }) {\n  const [selectedEntities, setSelectedEntities] = useState(new Set());\n  const [previewImage, setPreviewImage] = useState(null);\n  const [filterType, setFilterType] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    const values = (entities || [])\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [entities]);\n\n  // Get entities with completed tasks\n  const enrichedEntities = useMemo(() => {\n    const entityMap = new Map();\n\n    // Build entity map from world data\n    for (const entity of entities || []) {\n      entityMap.set(entity.id, { ...entity, tasks: [] });\n    }\n\n    // Add tasks to entities\n    for (const task of tasks) {\n      if (task.status === \"complete\" && entityMap.has(task.entityId)) {\n        entityMap.get(task.entityId).tasks.push(task);\n      }\n    }\n\n    // Filter to only entities with completed tasks\n    return Array.from(entityMap.values()).filter((e) => e.tasks.length > 0);\n  }, [entities, tasks]);\n\n  // Apply filter\n  const filteredEntities = useMemo(() => {\n    if (filterType === \"all\") return enrichedEntities;\n    return enrichedEntities.filter((e) => e.tasks.some((t) => t.type === filterType));\n  }, [enrichedEntities, filterType]);\n\n  const toggleSelect = (entityId) => {\n    setSelectedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const regenerateSelected = () => {\n    const taskIds = [];\n    for (const entityId of selectedEntities) {\n      const entity = enrichedEntities.find((e) => e.id === entityId);\n      if (entity) {\n        for (const task of entity.tasks) {\n          taskIds.push(task.id);\n        }\n      }\n    }\n    if (taskIds.length > 0) {\n      onRegenerateTask(taskIds);\n    }\n  };\n\n  const totalImages = tasks.filter((t) => t.type === \"image\" && t.status === \"complete\").length;\n  const totalDescriptions = tasks.filter(\n    (t) => t.type === \"description\" && t.status === \"complete\"\n  ).length;\n\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Results</h2>\n          <span className=\"rp-autosave-note\">Changes auto-save to current slot</span>\n        </div>\n\n        {enrichedEntities.length === 0 ? (\n          <div className=\"rp-empty-state\">\n            No enrichment results yet. Run some tasks to see results here.\n          </div>\n        ) : (\n          <>\n            {/* Stats */}\n            <div className=\"rp-stats-bar\">\n              <div>\n                <span className=\"rp-stat-value\">{enrichedEntities.length}</span>\n                <span className=\"rp-stat-label\">entities</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalDescriptions}</span>\n                <span className=\"rp-stat-label\">descriptions</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalImages}</span>\n                <span className=\"rp-stat-label\">images</span>\n              </div>\n\n              <div className=\"rp-filter-wrapper\">\n                <select\n                  value={filterType}\n                  onChange={(e) => setFilterType(e.target.value)}\n                  className=\"illuminator-select rp-filter-select\"\n                >\n                  <option value=\"all\">All Types</option>\n                  <option value=\"description\">Descriptions</option>\n                  <option value=\"image\">Images</option>\n                </select>\n              </div>\n            </div>\n\n            {/* Entity cards */}\n            <div>\n              {filteredEntities.map((entity) => (\n                <EntityResultCard\n                  key={entity.id}\n                  entity={entity}\n                  tasks={entity.tasks}\n                  selected={selectedEntities.has(entity.id)}\n                  onToggleSelect={() => toggleSelect(entity.id)}\n                  onRegenerate={onRegenerateTask}\n                  onPreviewImage={setPreviewImage}\n                  prominenceScale={effectiveProminenceScale}\n                />\n              ))}\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Selection actions */}\n      {selectedEntities.size > 0 && (\n        <div className=\"rp-selection-bar\">\n          <span className=\"rp-selection-count\">\n            {selectedEntities.size} entit{selectedEntities.size !== 1 ? \"ies\" : \"y\"} selected\n          </span>\n          <div className=\"rp-selection-actions\">\n            <button\n              onClick={() => setSelectedEntities(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button onClick={regenerateSelected} className=\"illuminator-button\">\n              Regenerate Selected\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Image preview modal */}\n      <ImagePreviewModal imageUrl={previewImage} onClose={() => setPreviewImage(null)} />\n    </div>\n  );\n}", "parameters": [{"name": "{ tasks, entities = [], onRegenerateTask }", "type": "{ tasks: any; entities?: any[]; onRegenerateTask: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./ResultsPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx", "sourceCode": "export default function RevisionFilterModal({\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}) {\n  const [excludeChronicle, setExcludeChronicle] = useState(true);\n\n  if (!isOpen) return null;\n\n  const available = excludeChronicle ? totalEligible - usedInChronicles : totalEligible;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary rfm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={() => onStart(excludeChronicle)}\n        disabled={available === 0}\n        className=\"illuminator-button illuminator-button-primary rfm-footer-btn\"\n      >\n        Start Revision ({available} entities)\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Revise Entity Summaries\" className=\"rfm-dialog\" footer={footer}>\n      <p className=\"rfm-subtitle\">\n        Rewrite summaries and descriptions with full world context.\n      </p>\n\n      {/* Counts */}\n      <div className=\"rfm-counts-grid\">\n        <span className=\"rfm-count-label\">Total eligible entities</span>\n        <span className=\"rfm-count-value\">{totalEligible}</span>\n\n        <span className=\"rfm-count-label\">Used in chronicles</span>\n        <span\n          className={`rfm-count-value ${usedInChronicles > 0 ? \"rfm-count-value-warning\" : \"rfm-count-value-muted\"}`}\n        >\n          {usedInChronicles}\n        </span>\n\n        <span className=\"rfm-count-label rfm-count-label-total\">Available for revision</span>\n        <span className=\"rfm-count-value\">{available}</span>\n      </div>\n\n      {/* Chronicle filter toggle */}\n      {usedInChronicles > 0 && (\n        // eslint-disable-next-line jsx-a11y/label-has-associated-control\n        <label className=\"rfm-filter-toggle\">\n          <input\n            type=\"checkbox\"\n            checked={excludeChronicle}\n            onChange={(e) => setExcludeChronicle(e.target.checked)}\n            className=\"rfm-filter-checkbox\"\n          />\n          <div>\n            <div className=\"rfm-filter-title\">Exclude entities used in chronicles</div>\n            <div className=\"rfm-filter-description\">\n              Recommended. Prevents inconsistency between rewritten descriptions and existing\n              chronicle text.\n            </div>\n          </div>\n        </label>\n      )}\n\n      {available === 0 && (\n        <div className=\"rfm-warning\">\n          No entities available for revision with current filters.\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}", "type": "{ isOpen: any; totalEligible: any; usedInChronicles: any; onStart: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "./RevisionFilterModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StaticPageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPageEditor.jsx", "sourceCode": "export default function StaticPageEditor({ page, projectId, onSave, onDelete, onPublishToggle }) {\n  const [title, setTitle] = useState(page?.title || \"\");\n  const [content, setContent] = useState(page?.content || \"\");\n  const [summary, setSummary] = useState(page?.summary || \"\");\n  const [showEntityPicker, setShowEntityPicker] = useState(false);\n  const [showImagePicker, setShowImagePicker] = useState(false);\n  const [isDirty, setIsDirty] = useState(false);\n  const saveTimeoutRef = useRef(null);\n\n  // Reset state when page changes\n  useEffect(() => {\n    setTitle(page?.title || \"\");\n    setContent(page?.content || \"\");\n    setSummary(page?.summary || \"\");\n    setIsDirty(false);\n  }, [page?.pageId]);\n\n  // Auto-save on changes (debounced)\n  useEffect(() => {\n    if (!isDirty || !page) return;\n\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    saveTimeoutRef.current = setTimeout(() => {\n      onSave({\n        title,\n        content,\n        summary: summary || undefined,\n      });\n      setIsDirty(false);\n    }, 1000);\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, [isDirty, title, content, summary, page, onSave]);\n\n  const handleTitleChange = (e) => {\n    setTitle(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleContentChange = (value) => {\n    setContent(value || \"\");\n    setIsDirty(true);\n  };\n\n  const handleSummaryChange = (e) => {\n    setSummary(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleEntityLinkSelect = useCallback((linkText) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + linkText);\n    setIsDirty(true);\n  }, []);\n\n  const handleImageSelect = useCallback((imageRef) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + \"\\n\\n\" + imageRef + \"\\n\\n\");\n    setIsDirty(true);\n  }, []);\n\n  const handleSaveNow = () => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n    onSave({\n      title,\n      content,\n      summary: summary || undefined,\n    });\n    setIsDirty(false);\n  };\n\n  if (!page) {\n    return (\n      <div className=\"static-page-editor-empty\">\n        <div className=\"static-page-editor-empty-icon\">&#x1F4DD;</div>\n        <div className=\"static-page-editor-empty-title\">Select a page to edit</div>\n        <div className=\"static-page-editor-empty-desc\">\n          Choose a page from the list or create a new one\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-page-editor\">\n      {/* Header with title and actions */}\n      <div className=\"static-page-editor-header\">\n        <input\n          type=\"text\"\n          value={title}\n          onChange={handleTitleChange}\n          placeholder=\"Page title...\"\n          className=\"static-page-title-input\"\n        />\n        <div className=\"static-page-editor-actions\">\n          <span\n            className={`static-page-status-badge ${page.status}`}\n            title={page.status === \"published\" ? \"Visible in Chronicler\" : \"Draft only\"}\n          >\n            {page.status}\n          </span>\n          {isDirty && <span className=\"static-page-dirty-indicator\">Unsaved</span>}\n          <button className=\"static-page-button\" onClick={handleSaveNow} disabled={!isDirty}>\n            Save\n          </button>\n          <button\n            className=\"static-page-button\"\n            onClick={() => onPublishToggle(page.status === \"published\" ? \"draft\" : \"published\")}\n          >\n            {page.status === \"published\" ? \"Unpublish\" : \"Publish\"}\n          </button>\n          <button className=\"static-page-button danger\" onClick={onDelete}>\n            Delete\n          </button>\n        </div>\n      </div>\n\n      {/* Summary input */}\n      <div className=\"static-page-summary-section\">\n        <label className=\"static-page-summary-label\">\n          Summary (shown in page lists):\n          <input\n            type=\"text\"\n            value={summary}\n            onChange={handleSummaryChange}\n            placeholder=\"Brief description of this page...\"\n            className=\"static-page-summary-input\"\n          />\n        </label>\n      </div>\n\n      {/* Custom toolbar */}\n      <div className=\"static-page-toolbar\">\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowEntityPicker(true)}\n          title=\"Insert entity link [[Entity Name]]\"\n        >\n          &#x1F517; Entity Link\n        </button>\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowImagePicker(true)}\n          title=\"Insert image reference\"\n        >\n          &#x1F5BC; Image\n        </button>\n        <span className=\"static-page-toolbar-hint\">\n          Use <code>[[Entity Name]]</code> to link to entities\n        </span>\n      </div>\n\n      {/* Markdown editor */}\n      <div className=\"static-page-editor-container\" data-color-mode=\"dark\">\n        <MDEditor\n          value={content}\n          onChange={handleContentChange}\n          preview=\"live\"\n          height={500}\n          visibleDragbar={false}\n        />\n      </div>\n\n      {/* Word count */}\n      <div className=\"static-page-editor-footer\">\n        <span className=\"static-page-word-count\">\n          {page.wordCount || 0} words \u2022 {page.linkedEntityIds?.length || 0} entity links\n        </span>\n        <span className=\"static-page-updated\">\n          Last updated: {new Date(page.updatedAt).toLocaleString()}\n        </span>\n      </div>\n\n      {/* Modals */}\n      {showEntityPicker && (\n        <EntityLinkPicker\n          onSelect={handleEntityLinkSelect}\n          onClose={() => setShowEntityPicker(false)}\n        />\n      )}\n      {showImagePicker && (\n        <ImageRefPicker\n          projectId={projectId}\n          onSelect={handleImageSelect}\n          onClose={() => setShowImagePicker(false)}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ page, projectId, onSave, onDelete, onPublishToggle }", "type": "{ page: any; projectId: any; onSave: any; onDelete: any; onPublishToggle: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@uiw/react-md-editor", "specifiers": ["MDEditor"], "category": "external"}, {"source": "./EntityLinkPicker", "specifiers": ["EntityLinkPicker"], "category": "internal"}, {"source": "./ImageRefPicker", "specifiers": ["ImageRefPicker"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx", "sourceCode": "export default function StaticPagesPanel({ projectId }) {\n  const [pages, setPages] = useState([]);\n  const [selectedPageId, setSelectedPageId] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // Load pages on mount and when projectId changes\n  useEffect(() => {\n    if (!projectId) {\n      setPages([]);\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    setLoading(true);\n    getStaticPagesForProject(projectId)\n      .then((loadedPages) => {\n        if (cancelled) return;\n        setPages(loadedPages);\n        setLoading(false);\n      })\n      .catch((err) => {\n        console.error(\"Failed to load static pages:\", err);\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId]);\n\n  const selectedPage = pages.find((p) => p.pageId === selectedPageId);\n\n  const handleCreatePage = useCallback(async () => {\n    if (!projectId) return;\n\n    try {\n      const newPage = await createStaticPage({\n        projectId,\n        title: \"Untitled Page\",\n        content: \"# Untitled Page\\n\\nStart writing here...\",\n      });\n      setPages((prev) => [newPage, ...prev]);\n      setSelectedPageId(newPage.pageId);\n    } catch (err) {\n      console.error(\"Failed to create page:\", err);\n    }\n  }, [projectId]);\n\n  const handleSavePage = useCallback(\n    async (updates) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, updates);\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to save page:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  const handleDeletePage = useCallback(async () => {\n    if (!selectedPageId) return;\n    if (!confirm(\"Are you sure you want to delete this page?\")) return;\n\n    try {\n      await deleteStaticPage(selectedPageId);\n      setPages((prev) => prev.filter((p) => p.pageId !== selectedPageId));\n      setSelectedPageId(null);\n    } catch (err) {\n      console.error(\"Failed to delete page:\", err);\n    }\n  }, [selectedPageId]);\n\n  const handlePublishToggle = useCallback(\n    async (newStatus) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, { status: newStatus });\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to update page status:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  if (loading) {\n    return (\n      <div className=\"static-pages-panel\">\n        <div className=\"static-pages-loading\">Loading pages...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-pages-panel\">\n      {/* Left sidebar: page list */}\n      <div className=\"static-pages-sidebar\">\n        <div className=\"static-pages-sidebar-header\">\n          <h3>Static Pages</h3>\n          <button className=\"static-page-button primary\" onClick={() => void handleCreatePage()}>\n            + New Page\n          </button>\n        </div>\n\n        <div className=\"static-pages-list\">\n          {pages.length === 0 ? (\n            <div className=\"static-pages-empty\">\n              <p>No pages yet.</p>\n              <p>Create a page to add custom content like culture overviews or lore articles.</p>\n            </div>\n          ) : (\n            pages.map((page) => (\n              <button\n                key={page.pageId}\n                className={`static-pages-list-item ${selectedPageId === page.pageId ? \"selected\" : \"\"}`}\n                onClick={() => setSelectedPageId(page.pageId)}\n              >\n                <span className=\"static-pages-list-title\">{page.title}</span>\n                <span className=\"static-pages-list-meta\">\n                  <span className={`static-pages-status-dot ${page.status}`} />\n                  {page.wordCount} words\n                </span>\n              </button>\n            ))\n          )}\n        </div>\n      </div>\n\n      {/* Right area: editor */}\n      <div className=\"static-pages-editor-area\">\n        <StaticPageEditor\n          page={selectedPage}\n          projectId={projectId}\n          onSave={handleSavePage}\n          onDelete={() => void handleDeletePage()}\n          onPublishToggle={handlePublishToggle}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./StaticPageEditor", "specifiers": ["StaticPageEditor"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getStaticPagesForProject", "createStaticPage", "updateStaticPage", "deleteStaticPage"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StoragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StoragePanel.jsx", "sourceCode": "export default function StoragePanel({ projectId: _projectId }) {\n  const [images, setImages] = useState([]);\n  const [stats, setStats] = useState({ totalCount: 0, totalSize: 0, byProject: {} });\n  const [loading, setLoading] = useState(true);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [filterProject, setFilterProject] = useState(\"all\");\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [thumbnailUrls, setThumbnailUrls] = useState({});\n  const [downloadingIds, setDownloadingIds] = useState(new Set());\n  const [exportingPrompts, setExportingPrompts] = useState(false);\n  const [pageSize, setPageSize] = useState(DEFAULT_PAGE_SIZE);\n  const [pageIndex, setPageIndex] = useState(0);\n  const thumbnailUrlsRef = useRef({});\n\n  // Load images and stats\n  const loadData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const [allImages, storageStats] = await Promise.all([getAllImages(), getStorageStats()]);\n      setImages(allImages);\n      setStats(storageStats);\n    } catch (err) {\n      console.error(\"Failed to load storage data:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadData();\n  }, [loadData]);\n\n  useEffect(() => {\n    thumbnailUrlsRef.current = thumbnailUrls;\n  }, [thumbnailUrls]);\n\n  useEffect(() => {\n    return () => {\n      for (const url of Object.values(thumbnailUrlsRef.current)) {\n        URL.revokeObjectURL(url);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    setPageIndex(0);\n  }, [filterProject]);\n\n  // Filter images by project\n  const filteredImages = useMemo(() => {\n    if (filterProject === \"all\") return images;\n    return images.filter((img) => img.projectId === filterProject);\n  }, [images, filterProject]);\n\n  // Get unique project IDs\n  const projectIds = useMemo(() => {\n    const ids = new Set();\n    for (const img of images) {\n      if (img.projectId) ids.add(img.projectId);\n    }\n    return Array.from(ids).sort();\n  }, [images]);\n\n  const totalPages = Math.max(1, Math.ceil(filteredImages.length / pageSize));\n  const currentPage = Math.min(pageIndex, totalPages - 1);\n  const pageStart = currentPage * pageSize;\n  const pageEnd = pageStart + pageSize;\n  const visibleImages = useMemo(\n    () => filteredImages.slice(pageStart, pageEnd),\n    [filteredImages, pageStart, pageEnd]\n  );\n\n  useEffect(() => {\n    setPageIndex((prev) => Math.min(prev, Math.max(0, totalPages - 1)));\n  }, [totalPages]);\n\n  useEffect(() => {\n    const visibleIds = new Set(visibleImages.map((img) => img.imageId));\n    setThumbnailUrls((prev) => {\n      let changed = false;\n      const next = {};\n      for (const [imageId, url] of Object.entries(prev)) {\n        if (visibleIds.has(imageId)) {\n          next[imageId] = url;\n        } else {\n          URL.revokeObjectURL(url);\n          changed = true;\n        }\n      }\n      return changed ? next : prev;\n    });\n  }, [visibleImages]);\n\n  // Load thumbnail URLs for visible images only\n  useEffect(() => {\n    let active = true;\n    const loadThumbnails = async () => {\n      const newUrls = {};\n      for (const img of visibleImages) {\n        if (!thumbnailUrls[img.imageId]) {\n          try {\n            const result = await loadImage(img.imageId);\n            if (result?.url) {\n              newUrls[img.imageId] = result.url;\n            }\n          } catch {\n            // Ignore errors\n          }\n        }\n      }\n\n      if (active && Object.keys(newUrls).length > 0) {\n        setThumbnailUrls((prev) => ({ ...prev, ...newUrls }));\n      }\n    };\n\n    if (visibleImages.length > 0) {\n      loadThumbnails();\n    }\n\n    return () => {\n      active = false;\n    };\n  }, [visibleImages, thumbnailUrls]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((imageId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(imageId)) {\n        next.delete(imageId);\n      } else {\n        next.add(imageId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredImages.map((img) => img.imageId)));\n  }, [filteredImages]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  const handlePageSizeChange = useCallback((event) => {\n    setPageSize(Number(event.target.value));\n    setPageIndex(0);\n  }, []);\n\n  const handlePrevPage = useCallback(() => {\n    setPageIndex((prev) => Math.max(prev - 1, 0));\n  }, []);\n\n  const handleNextPage = useCallback(() => {\n    setPageIndex((prev) => Math.min(prev + 1, totalPages - 1));\n  }, [totalPages]);\n\n  // Delete single image\n  const handleDelete = useCallback(\n    async (imageId) => {\n      if (!window.confirm(\"Delete this image? This cannot be undone.\")) return;\n\n      try {\n        // Revoke thumbnail URL\n        if (thumbnailUrls[imageId]) {\n          URL.revokeObjectURL(thumbnailUrls[imageId]);\n          setThumbnailUrls((prev) => {\n            const next = { ...prev };\n            delete next[imageId];\n            return next;\n          });\n        }\n\n        await deleteImage(imageId);\n        setSelectedIds((prev) => {\n          const next = new Set(prev);\n          next.delete(imageId);\n          return next;\n        });\n        await loadData();\n      } catch (err) {\n        console.error(\"Failed to delete image:\", err);\n        alert(\"Failed to delete image\");\n      }\n    },\n    [loadData, thumbnailUrls]\n  );\n\n  // Delete selected images\n  const handleDeleteSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n    if (!window.confirm(`Delete ${selectedIds.size} selected images? This cannot be undone.`))\n      return;\n\n    try {\n      // Revoke thumbnail URLs\n      for (const id of selectedIds) {\n        if (thumbnailUrls[id]) {\n          URL.revokeObjectURL(thumbnailUrls[id]);\n        }\n      }\n      setThumbnailUrls((prev) => {\n        const next = { ...prev };\n        for (const id of selectedIds) {\n          delete next[id];\n        }\n        return next;\n      });\n\n      await deleteImages(Array.from(selectedIds));\n      setSelectedIds(new Set());\n      await loadData();\n    } catch (err) {\n      console.error(\"Failed to delete images:\", err);\n      alert(\"Failed to delete images\");\n    }\n  }, [selectedIds, loadData, thumbnailUrls]);\n\n  // Download single image\n  const handleDownload = useCallback(async (imageId, entityName) => {\n    setDownloadingIds((prev) => new Set(prev).add(imageId));\n    try {\n      const blob = await getImageBlob(imageId);\n      if (!blob) {\n        alert(\"Image not found\");\n        return;\n      }\n\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${entityName || imageId}.png`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download image:\", err);\n      alert(\"Failed to download image\");\n    } finally {\n      setDownloadingIds((prev) => {\n        const next = new Set(prev);\n        next.delete(imageId);\n        return next;\n      });\n    }\n  }, []);\n\n  // Download selected images as zip\n  const handleDownloadSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n\n    // Check if JSZip is available\n    let JSZip;\n    try {\n      JSZip = (await import(\"jszip\")).default;\n    } catch {\n      alert(\"Bulk download requires JSZip library. Please install it: npm install jszip\");\n      return;\n    }\n\n    setDownloadingIds(new Set(selectedIds));\n    try {\n      const zip = new JSZip();\n\n      for (const imageId of selectedIds) {\n        const blob = await getImageBlob(imageId);\n        if (blob) {\n          const img = images.find((i) => i.imageId === imageId);\n          const filename = img?.entityName\n            ? `${img.entityName.replace(/[^a-z0-9]/gi, \"_\")}.png`\n            : `${imageId}.png`;\n          zip.file(filename, blob);\n        }\n      }\n\n      const content = await zip.generateAsync({ type: \"blob\" });\n      const url = URL.createObjectURL(content);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = \"images.zip\";\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download images:\", err);\n      alert(\"Failed to download images\");\n    } finally {\n      setDownloadingIds(new Set());\n    }\n  }, [selectedIds, images]);\n\n  // Export prompt data for analysis\n  const handleExportPrompts = useCallback(async () => {\n    setExportingPrompts(true);\n// ... (truncated)", "parameters": [{"name": "{ projectId: _projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useMemo", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/imageRepository", "specifiers": ["getAllImages", "getStorageStats", "loadImage", "deleteImage", "deleteImages", "getImageBlob", "formatBytes"], "category": "internal"}, {"source": "../lib/db/imageRepository", "specifiers": ["downloadImagePromptExport"], "category": "internal"}, {"source": "./ImageModal", "specifiers": ["ImageModal"], "category": "internal"}, {"source": "./StoragePanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx", "sourceCode": "/**\n * Main StyleLibraryEditor component\n */\nexport default function StyleLibraryEditor({\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}) {\n  const [editingStyle, setEditingStyle] = useState(null);\n  const [editingType, setEditingType] = useState(null); // 'artistic' | 'composition' | 'narrative'\n  const [confirmReset, setConfirmReset] = useState(false);\n  const handleEditArtistic = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"artistic\");\n  }, []);\n  const handleEditComposition = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"composition\");\n  }, []);\n  const handleAddArtistic = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"artistic\");\n  }, []);\n  const handleAddComposition = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"composition\");\n  }, []);\n  const handleEditNarrative = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"narrative\");\n  }, []);\n  const handleAddNarrative = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"narrative\");\n  }, []);\n  const handleSaveStyle = useCallback(async (styleData, isNew) => {\n    if (editingType === \"artistic\") {\n      if (isNew) {\n        await onAddArtisticStyle(styleData);\n      } else {\n        await onUpdateArtisticStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"composition\") {\n      if (isNew) {\n        await onAddCompositionStyle(styleData);\n      } else {\n        await onUpdateCompositionStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"narrative\") {\n      if (isNew) {\n        await onAddNarrativeStyle(styleData);\n      } else {\n        await onUpdateNarrativeStyle(styleData.id, styleData);\n      }\n    }\n    setEditingStyle(null);\n    setEditingType(null);\n  }, [editingType, onAddArtisticStyle, onUpdateArtisticStyle, onAddCompositionStyle, onUpdateCompositionStyle, onAddNarrativeStyle, onUpdateNarrativeStyle]);\n  const handleDeleteArtistic = useCallback(async id => {\n    if (window.confirm(\"Delete this artistic style?\")) {\n      await onDeleteArtisticStyle(id);\n    }\n  }, [onDeleteArtisticStyle]);\n  const handleDeleteComposition = useCallback(async id => {\n    if (window.confirm(\"Delete this composition style?\")) {\n      await onDeleteCompositionStyle(id);\n    }\n  }, [onDeleteCompositionStyle]);\n  const handleDeleteNarrative = useCallback(async id => {\n    if (window.confirm(\"Delete this narrative style?\")) {\n      await onDeleteNarrativeStyle(id);\n    }\n  }, [onDeleteNarrativeStyle]);\n  const handleReset = useCallback(async () => {\n    await onReset();\n    setConfirmReset(false);\n  }, [onReset]);\n  const handleCloseModal = useCallback(() => {\n    setEditingStyle(null);\n    setEditingType(null);\n  }, []);\n  if (loading) {\n    return <div className=\"illuminator-card\">\n        <p className=\"style-editor-loading\">Loading style library...</p>\n      </div>;\n  }\n  return <div>\n      {/* Status bar */}\n      <div className=\"illuminator-card\">\n        <div className=\"style-editor-status-row\">\n          <div>\n            <span className=\"style-editor-status-label\">Style Library</span>\n            <span className=\"style-editor-status-sublabel\">\n              {isCustom ? \"(customized)\" : \"(defaults)\"}\n            </span>\n          </div>\n          <div>\n            {!confirmReset && <button onClick={() => setConfirmReset(true)} className=\"illuminator-btn style-editor-btn-sm\" title={isCustom ? \"Reload defaults and discard custom styles\" : \"Reload default styles\"}>\n                Reload Default Styles\n              </button>}\n            {confirmReset && <span className=\"style-editor-confirm-row\">\n                <span className=\"style-editor-confirm-text\">\n                  {isCustom ? \"Reload defaults and discard custom styles?\" : \"Reload default styles?\"}\n                </span>\n                <button onClick={handleReset} className=\"illuminator-btn illuminator-btn-danger style-editor-btn-sm\">\n                  Yes, Reload\n                </button>\n                <button onClick={() => setConfirmReset(false)} className=\"illuminator-btn style-editor-btn-sm\">\n                  Cancel\n                </button>\n              </span>}\n          </div>\n        </div>\n      </div>\n\n      {/* Artistic Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Artistic Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.artisticStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddArtistic} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Artistic styles define the visual rendering approach (e.g., oil painting, watercolor,\n          digital art).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.artisticStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"artistic\" onEdit={handleEditArtistic} onDelete={handleDeleteArtistic} style={style} />)}\n        </div>\n\n        {styleLibrary.artisticStyles.length === 0 && <p className=\"style-editor-empty\">No artistic styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Composition Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Composition Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.compositionStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddComposition} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Composition styles define framing and visual arrangement (e.g., portrait, establishing\n          shot, action scene).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.compositionStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"composition\" onEdit={handleEditComposition} onDelete={handleDeleteComposition} style={style} />)}\n        </div>\n\n        {styleLibrary.compositionStyles.length === 0 && <p className=\"style-editor-empty\">\n            No composition styles defined. Add one to get started.\n          </p>}\n      </div>\n\n      {/* Narrative Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Narrative Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.narrativeStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddNarrative} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Narrative styles define story structure, character selection, and prose tone for chronicle\n          generation.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.narrativeStyles.map(style => <NarrativeStyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        compositionStyles={styleLibrary.compositionStyles} onEdit={handleEditNarrative} onDelete={handleDeleteNarrative} style={style} />)}\n        </div>\n\n        {styleLibrary.narrativeStyles.length === 0 && <p className=\"style-editor-empty\">No narrative styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Scene Prompt Templates */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Cover Image Scene Prompts\n            <span className=\"style-editor-section-count\">({SCENE_PROMPT_TEMPLATES.length})</span>\n          </h2>\n        </div>\n        <p className=\"style-editor-description\">\n          Scene prompt templates direct the LLM on what kind of cover image scene to describe. Each\n          narrative style maps to one of these templates.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {SCENE_PROMPT_TEMPLATES.map(template => <div key={template.id} className=\"illuminator-style-card\">\n              <div className=\"illuminator-style-card-header\">\n                <div className=\"illuminator-style-card-title\">{template.name}</div>\n              </div>\n              <div className=\"illuminator-style-card-prompt\">\n                <strong>Framing:</strong> {template.framing}\n              </div>\n              <div className=\"illuminator-style-card-prompt style-editor-scene-prompt-instructions\">\n                <strong>Instructions:</strong> {template.instructions}\n              </div>\n            </div>)}\n        </div>\n      </div>\n\n      {/* Edit Modal for Artistic/Composition */}\n      {editingStyle && (editingType === \"artistic\" || editingType === \"composition\") && <StyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    type={editingType} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n\n      {/* Edit Modal for Narrative */}\n      {editingStyle && editingType === \"narrative\" && <NarrativeStyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    compositionStyles={styleLibrary.compositionStyles} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n    </div>;\n}", "parameters": [{"name": "{\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}", "type": "{ styleLibrary: any; loading: any; isCustom: any; onAddArtisticStyle: any; onUpdateArtisticStyle: any; onDeleteArtisticStyle: any; onAddCompositionStyle: any; onUpdateCompositionStyle: any; onDeleteCompositionStyle: any; onAddNarrativeStyle: any; onUpdateNarrativeStyle: any; onDeleteNarrativeStyle: any; onReset: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["LocalTextArea"], "category": "external"}, {"source": "../lib/coverImageStyles", "specifiers": ["SCENE_PROMPT_TEMPLATES", "getCoverImageConfig"], "category": "internal"}, {"source": "./StyleLibraryEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "export default function StyleSelector({\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}) {\n  const compositionId = useId();\n  const artisticStyles = styleLibrary?.artisticStyles || [];\n  const compositionStyles = styleLibrary?.compositionStyles || [];\n  const colorPalettes = styleLibrary?.colorPalettes || [];\n\n  // Filter composition styles based on entity kind (legacy suitableForKinds)\n  const filteredCompositionStyles = useMemo(() => {\n    if (!entityKind) {\n      return compositionStyles;\n    }\n    return compositionStyles.filter(\n      (s) =>\n        !s.suitableForKinds ||\n        s.suitableForKinds.length === 0 ||\n        s.suitableForKinds.includes(entityKind)\n    );\n  }, [compositionStyles, entityKind]);\n\n  // Group compositions by targetCategory for organized display\n  const groupedCompositions = useMemo(() => {\n    return groupCompositionsByCategory(filteredCompositionStyles);\n  }, [filteredCompositionStyles]);\n\n  const selectedArtistic = artisticStyles.find((s) => s.id === selectedArtisticStyleId);\n  const selectedComposition = compositionStyles.find((s) => s.id === selectedCompositionStyleId);\n  const selectedColorPalette = colorPalettes.find((s) => s.id === selectedColorPaletteId);\n\n  if (compact) {\n    return (\n      <div className=\"stsel-compact\">\n        <span className=\"stsel-compact-label\">Style:</span>\n        <select\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedArtistic?.description || \"Select artistic style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n\n        <select\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedComposition?.description || \"Select composition style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n\n        <select\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedColorPalette?.description || \"Select color palette\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"stsel-grid\">\n      {/* Artistic Style */}\n      <div>\n        <label htmlFor=\"artistic-style\" className=\"stsel-label\">Artistic Style</label>\n        <select id=\"artistic-style\"\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n        {selectedArtistic && (\n          <div className=\"stsel-description\">{selectedArtistic.description}</div>\n        )}\n      </div>\n\n      {/* Composition Style */}\n      <div>\n        <label htmlFor={compositionId} className=\"stsel-label\">\n          Composition Style{entityKind && ` (for ${entityKind})`}\n        </label>\n        <select id={compositionId}\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n        {selectedComposition && (\n          <div className=\"stsel-description\">{selectedComposition.description}</div>\n        )}\n      </div>\n\n      {/* Color Palette */}\n      <div>\n        <label htmlFor=\"color-palette\" className=\"stsel-label\">Color Palette</label>\n        <select id=\"color-palette\"\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n        {selectedColorPalette && (\n          <div className=\"stsel-description\">{selectedColorPalette.description}</div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}", "type": "{ styleLibrary: any; selectedArtisticStyleId: any; selectedCompositionStyleId: any; selectedColorPaletteId: any; onArtisticStyleChange: any; onCompositionStyleChange: any; onColorPaletteChange: any; entityKind: any; compact?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useId"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS"], "category": "external"}, {"source": "./StyleSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::resolveStyleSelection", "name": "resolveStyleSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "/**\n * Resolve style selection to actual style definitions\n * Handles culture defaults, random selection, exclusion filtering, and fallbacks\n */\nexport function resolveStyleSelection({\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}) {\n  const result = {\n    artisticStyle: null,\n    compositionStyle: null,\n    colorPalette: null,\n    cultureKeywords: [],\n  };\n\n  if (!styleLibrary) return result;\n\n  const artisticStyles = styleLibrary.artisticStyles || [];\n  const compositionStyles = styleLibrary.compositionStyles || [];\n  const colorPalettes = styleLibrary.colorPalettes || [];\n  const rules = exclusionRules || [];\n\n  // Filter composition styles by entity kind\n  const filteredCompositionStyles = entityKind\n    ? compositionStyles.filter(\n        (s) =>\n          !s.suitableForKinds ||\n          s.suitableForKinds.length === 0 ||\n          s.suitableForKinds.includes(entityKind)\n      )\n    : compositionStyles;\n\n  const styleIsRandom = selection.artisticStyleId === RANDOM_ID || !selection.artisticStyleId;\n  const compIsRandom = selection.compositionStyleId === RANDOM_ID || !selection.compositionStyleId;\n\n  if (\n    styleIsRandom &&\n    compIsRandom &&\n    selection.artisticStyleId !== NONE_ID &&\n    selection.compositionStyleId !== NONE_ID\n  ) {\n    // Both random: pick composition first, then filter styles for that composition\n    result.compositionStyle = pickRandom(filteredCompositionStyles);\n    if (result.compositionStyle && rules.length > 0) {\n      const filteredStyles = filterByExclusion(\n        artisticStyles,\n        result.compositionStyle.id,\n        rules,\n        artisticStyles,\n        compositionStyles,\n        \"style\"\n      );\n      result.artisticStyle = pickRandom(filteredStyles);\n    } else {\n      result.artisticStyle = pickRandom(artisticStyles);\n    }\n  } else {\n    // Resolve artistic style\n    if (selection.artisticStyleId === NONE_ID) {\n      result.artisticStyle = null;\n    } else if (styleIsRandom) {\n      // Style is random, composition is fixed \u2014 filter styles for fixed composition\n      const fixedCompId = selection.compositionStyleId;\n      if (fixedCompId && fixedCompId !== NONE_ID && rules.length > 0) {\n        const filteredStyles = filterByExclusion(\n          artisticStyles,\n          fixedCompId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"style\"\n        );\n        result.artisticStyle = pickRandom(filteredStyles);\n      } else {\n        result.artisticStyle = pickRandom(artisticStyles);\n      }\n    } else {\n      result.artisticStyle = artisticStyles.find((s) => s.id === selection.artisticStyleId);\n    }\n\n    // Resolve composition style\n    if (selection.compositionStyleId === NONE_ID) {\n      result.compositionStyle = null;\n    } else if (compIsRandom) {\n      // Composition is random, style is fixed \u2014 filter compositions for fixed style\n      const fixedStyleId = selection.artisticStyleId;\n      if (fixedStyleId && fixedStyleId !== NONE_ID && rules.length > 0) {\n        const filteredComps = filterByExclusion(\n          filteredCompositionStyles,\n          fixedStyleId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"composition\"\n        );\n        result.compositionStyle = pickRandom(filteredComps);\n      } else {\n        result.compositionStyle = pickRandom(filteredCompositionStyles);\n      }\n    } else {\n      result.compositionStyle = compositionStyles.find(\n        (s) => s.id === selection.compositionStyleId\n      );\n    }\n  }\n\n  // Resolve color palette (no culture default for palettes)\n  if (selection.colorPaletteId === NONE_ID) {\n    result.colorPalette = null;\n  } else if (selection.colorPaletteId === RANDOM_ID || !selection.colorPaletteId) {\n    result.colorPalette = pickRandom(colorPalettes);\n  } else {\n    result.colorPalette = colorPalettes.find((p) => p.id === selection.colorPaletteId);\n  }\n\n  // Get culture style keywords\n  const culture = cultures?.find((c) => c.id === entityCultureId);\n  if (culture?.styleKeywords?.length > 0) {\n    result.cultureKeywords = culture.styleKeywords;\n  }\n\n  return result;\n}", "parameters": [{"name": "{\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}", "type": "{ selection: any; entityCultureId: any; entityKind: any; cultures: any; styleLibrary: any; exclusionRules?: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/styleExclusions\").RandomExclusionRule[]; }", "optional": false}], "returnType": "{ artisticStyle: any; compositionStyle: any; colorPalette: any; cultureKeywords: any[]; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useId"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS"], "category": "external"}, {"source": "./StyleSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function SummaryRevisionModal({\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}) {\n  const scrollRef = useRef(null);\n  const [expandedIds, setExpandedIds] = useState(new Set());\n\n  // Auto-scroll on new content\n  useEffect(() => {\n    scrollRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.batches?.length, run?.currentBatchIndex, run?.status]);\n\n  // Reset expanded state when batch changes\n  useEffect(() => {\n    setExpandedIds(new Set());\n  }, [run?.currentBatchIndex, run?.status]);\n\n  // Build entity lookup from entity contexts\n  const [entityLookup, setEntityLookup] = useState(new Map());\n  useEffect(() => {\n    if (!run || !getEntityContexts) {\n      setEntityLookup(new Map());\n      return;\n    }\n    let cancelled = false;\n    const allIds = run.batches.flatMap((b) => b.entityIds);\n    Promise.resolve(getEntityContexts(allIds)).then((contexts) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const ctx of contexts) {\n        if (ctx) map.set(ctx.id, ctx);\n      }\n      setEntityLookup(map);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [run, getEntityContexts]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isBatchReviewing = run.status === \"batch_reviewing\";\n  const isRunReviewing = run.status === \"run_reviewing\";\n  const isFailed = run.status === \"failed\";\n\n  const currentBatch = run.batches[run.currentBatchIndex];\n  const totalBatches = run.batches.length;\n  const completedBatches = run.batches.filter(\n    (b) => b.status === \"complete\" || b.status === \"failed\"\n  ).length;\n\n  // Collect patches for display\n  const allPatches = isRunReviewing\n    ? run.batches.flatMap((b) => b.patches || [])\n    : currentBatch?.patches || [];\n\n  const acceptedCount = allPatches.filter((p) => run.patchDecisions[p.entityId] !== false).length;\n\n  const toggleExpand = (entityId) => {\n    setExpandedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) next.delete(entityId);\n      else next.add(entityId);\n      return next;\n    });\n  };\n\n  const expandAll = () => {\n    setExpandedIds(new Set(allPatches.map((p) => p.entityId)));\n  };\n\n  const collapseAll = () => {\n    setExpandedIds(new Set());\n  };\n\n  const handleExport = () => {\n    const text = buildExportText(allPatches, entityLookup, run.patchDecisions, descriptionBaseline);\n    const timestamp = Date.now();\n    downloadText(text, `revision-patches-${timestamp}.txt`);\n  };\n\n  return (\n    <div className=\"srm-overlay\">\n      <div className=\"srm-modal\">\n        {/* Header */}\n        <div className=\"srm-modal-header\">\n          <div>\n            <h2 className=\"srm-modal-title\">\n              Batch Revision\n              {currentBatch && !isRunReviewing && (\n                <span className=\"srm-modal-culture\">{currentBatch.culture}</span>\n              )}\n            </h2>\n            <p className=\"srm-modal-subtitle\">\n              {isRunReviewing\n                ? `All ${totalBatches} batches complete. Review and apply patches.`\n                : `Batch ${run.currentBatchIndex + 1} of ${totalBatches}`}\n              {completedBatches > 0 && !isRunReviewing && ` (${completedBatches} complete)`}\n            </p>\n          </div>\n          <div className=\"srm-modal-header-right\">\n            {run.totalActualCost > 0 && (\n              <span className=\"srm-modal-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary srm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"srm-modal-scroll\">\n          {isGenerating && (\n            <div className=\"srm-generating\">\n              <div className=\"srm-generating-label\">\n                Generating revisions for batch {run.currentBatchIndex + 1}...\n              </div>\n              {currentBatch && (\n                <div className=\"srm-generating-detail\">\n                  {currentBatch.culture} ({currentBatch.entityIds.length} entities)\n                </div>\n              )}\n            </div>\n          )}\n\n          {isFailed && currentBatch?.error && <div className=\"srm-error\">{currentBatch.error}</div>}\n\n          {/* Patches */}\n          {allPatches.length > 0 && (\n            <div>\n              <div className=\"srm-patches-toolbar\">\n                <span className=\"srm-patches-count\">\n                  {allPatches.length} entities revised\n                  <span className=\"srm-patches-accepted\">{acceptedCount} accepted</span>\n                </span>\n                <div className=\"srm-patches-actions\">\n                  <button onClick={handleExport} className=\"srm-toolbar-btn\">\n                    Export\n                  </button>\n                  <button onClick={expandAll} className=\"srm-toolbar-btn\">\n                    Expand all\n                  </button>\n                  <button onClick={collapseAll} className=\"srm-toolbar-btn\">\n                    Collapse all\n                  </button>\n                </div>\n              </div>\n              {allPatches.map((patch) => (\n                <PatchCard\n                  key={patch.entityId}\n                  patch={patch}\n                  currentEntity={entityLookup.get(patch.entityId)}\n                  accepted={run.patchDecisions[patch.entityId]}\n                  onToggle={onTogglePatch}\n                  expanded={expandedIds.has(patch.entityId)}\n                  onToggleExpand={() => toggleExpand(patch.entityId)}\n                  onUpdateAnchorPhrase={onUpdateAnchorPhrase}\n                  descriptionBaseline={descriptionBaseline}\n                />\n              ))}\n            </div>\n          )}\n\n          {(isBatchReviewing || isRunReviewing) && allPatches.length === 0 && (\n            <div className=\"srm-no-patches\">No changes suggested for this batch.</div>\n          )}\n\n          <div ref={scrollRef} />\n        </div>\n\n        {/* Footer */}\n        <div className=\"srm-modal-footer\">\n          {isBatchReviewing && (\n            <>\n              <button\n                onClick={onAutoContine}\n                className=\"illuminator-button illuminator-button-secondary srm-footer-btn\"\n              >\n                Auto-Continue All\n              </button>\n              <button\n                onClick={onContinue}\n                className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n              >\n                {run.currentBatchIndex + 1 < totalBatches\n                  ? `Continue to Batch ${run.currentBatchIndex + 2}`\n                  : \"Finish Review\"}\n              </button>\n            </>\n          )}\n          {isRunReviewing && (\n            <button\n              onClick={onAccept}\n              className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n            >\n              Apply Accepted ({acceptedCount})\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}", "type": "{ run: any; isActive: any; onContinue: any; onAutoContine: any; onTogglePatch: any; onAccept: any; onCancel: any; getEntityContexts: any; onUpdateAnchorPhrase: any; descriptionBaseline: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "diff", "specifiers": ["diffWords"], "category": "external"}, {"source": "../lib/fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "./SummaryRevisionModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx", "sourceCode": "export default function ToneAssignmentPreviewModal({\n  preview,\n  onApply,\n  onClose\n}) {\n  const [entries, setEntries] = useState(preview?.entries ?? []);\n  const distribution = useMemo(() => {\n    const counts = Object.fromEntries(ANNOTATION_TONES.map(t => [t, 0]));\n    for (const e of entries) {\n      if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n    }\n    return counts;\n  }, [entries]);\n  if (!preview) return null;\n  const maxCount = Math.max(1, ...Object.values(distribution));\n  const shiftedCount = entries.filter(e => e.wasShifted).length;\n  const handleToneChange = (chronicleId, newTone) => {\n    setEntries(prev => prev.map(e => e.chronicleId === chronicleId ? {\n      ...e,\n      assignedTone: newTone,\n      wasShifted: newTone !== e.ranking[0]\n    } : e));\n  };\n  const footer = <>\n      <button onClick={onClose} className=\"illuminator-button tapm-footer-btn\">\n        Cancel\n      </button>\n      <button onClick={() => onApply(entries)} className=\"illuminator-button illuminator-button-primary tapm-footer-btn\">\n        Apply ({entries.length} assignments)\n      </button>\n    </>;\n  return <ModalShell onClose={onClose} title=\"Tone Assignment\" className=\"tapm-modal\" footer={footer}>\n      <span className=\"tapm-subtitle\">\n        {entries.length} chronicles\n        {shiftedCount > 0 && ` \u00b7 ${shiftedCount} shifted`}\n      </span>\n\n      {/* Distribution chart */}\n      <div className=\"tapm-distribution\">\n        <div className=\"tapm-section-label\">Distribution</div>\n        <div className=\"tapm-chart\">\n          {ANNOTATION_TONES.map(tone => {\n          const count = distribution[tone] || 0;\n          const meta = TONE_META[tone];\n          const pct = maxCount > 0 ? count / maxCount * 100 : 0;\n          return <div key={tone} className=\"tapm-chart-row\">\n                <span className=\"tapm-chart-symbol\"\n            style={{\n              \"--tapm-symbol-color\": TONE_COLORS[tone]\n            }}>\n                  {meta?.symbol || \"?\"}\n                </span>\n                <span className=\"tapm-chart-label\">{meta?.label || tone}</span>\n                <div className=\"tapm-chart-bar-track\">\n                  <div className=\"tapm-chart-bar-fill\"\n              style={{\n                \"--tapm-bar-color\": TONE_COLORS[tone] || \"#888\",\n                \"--tapm-bar-width\": `${pct}%`\n              }} />\n                </div>\n                <span className=\"tapm-chart-count\">{count}</span>\n              </div>;\n        })}\n        </div>\n      </div>\n\n      {/* Chronicle list */}\n      <div className=\"tapm-section-label tapm-section-label-assignments\">Assignments</div>\n      <div className=\"tapm-list\">\n        {entries.map(entry => <div key={entry.chronicleId} className={`tapm-entry ${entry.wasShifted ? \"tapm-entry-shifted\" : \"\"}`}>\n            {/* Title */}\n            <div className=\"tapm-entry-title\">{entry.title}</div>\n\n            {/* Ranking display */}\n            <div className=\"tapm-ranking\">\n              {entry.ranking.map((tone, rank) => {\n            const meta = TONE_META[tone];\n            const isAssigned = tone === entry.assignedTone;\n            return <span key={rank} title={`#${rank + 1}: ${meta?.label || tone}`} className={`tapm-rank-chip ${isAssigned ? \"tapm-rank-chip-assigned\" : \"tapm-rank-chip-unassigned\"} ${rank === 1 ? \"tapm-rank-chip-rank2\" : \"\"} ${rank >= 2 ? \"tapm-rank-chip-rank3\" : \"\"}`}\n            onClick={() => handleToneChange(entry.chronicleId, tone)} role=\"button\" tabIndex={0} onKeyDown={e => {\n              if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n            }} style={{\n              \"--tapm-chip-bg\": isAssigned ? TONE_COLORS[tone] : \"transparent\"\n            }}>\n                    {meta?.symbol || \"?\"}\n                  </span>;\n          })}\n            </div>\n\n            {/* Shifted indicator */}\n            {entry.wasShifted && <span title=\"Shifted from rank 1 for distribution balance\" className=\"tapm-shifted-label\">\n                shifted\n              </span>}\n          </div>)}\n      </div>\n    </ModalShell>;\n}", "parameters": [{"name": "{\n  preview,\n  onApply,\n  onClose\n}", "type": "{ preview: any; onApply: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "./HistorianToneSelector", "specifiers": ["TONE_META"], "category": "internal"}, {"source": "./ToneAssignmentPreviewModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx", "sourceCode": "export default function TraitPaletteSection({\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}: Readonly<TraitPaletteSectionProps>) {\n  // Filter to valid, unique entity kinds\n  const entityKinds = useMemo(\n    () => [...new Set((rawEntityKinds || []).filter((k) => k && typeof k === \"string\"))],\n    // Use joined string as stable key since parent creates new array each render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [(rawEntityKinds || []).join(\",\")]\n  );\n\n  const [palettes, setPalettes] = useState<Record<string, TraitPalette | null>>({});\n  const [loading, setLoading] = useState(true);\n  const [selectedKind, setSelectedKind] = useState<string | null>(null);\n\n  // Stable key for entityKinds to use in dependencies\n  const entityKindsKey = entityKinds.join(\",\");\n\n  // Track which kinds have pending/running tasks\n  const expandingKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const item of queue) {\n      if (\n        item.type === \"paletteExpansion\" &&\n        item.paletteEntityKind &&\n        (item.status === \"queued\" || item.status === \"running\")\n      ) {\n        kinds.add(item.paletteEntityKind);\n      }\n    }\n    return kinds;\n  }, [queue]);\n\n  // Track completed tasks to refresh palettes\n  const completedPaletteTaskIds = useMemo(() => {\n    return queue\n      .filter((item) => item.type === \"paletteExpansion\" && item.status === \"complete\")\n      .map((item) => item.id);\n  }, [queue]);\n\n  // Load all palettes\n  const loadPalettes = useCallback(async () => {\n    setLoading(true);\n    try {\n      const loaded: Record<string, TraitPalette | null> = {};\n      for (const kind of entityKinds) {\n        loaded[kind] = await getPalette(projectId, kind);\n      }\n      setPalettes(loaded);\n    } catch (err) {\n      console.error(\"Failed to load palettes:\", err);\n    } finally {\n      setLoading(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [projectId, entityKindsKey]);\n\n  useEffect(() => {\n    void loadPalettes();\n  }, [loadPalettes]);\n\n  // Refresh palettes when a palette expansion task completes\n  const lastCompletedRef = useMemo(() => ({ ids: new Set<string>() }), []);\n  useEffect(() => {\n    const newCompletions = completedPaletteTaskIds.filter((id) => !lastCompletedRef.ids.has(id));\n    if (newCompletions.length > 0) {\n      for (const id of newCompletions) {\n        lastCompletedRef.ids.add(id);\n      }\n      void loadPalettes();\n    }\n  }, [completedPaletteTaskIds, lastCompletedRef, loadPalettes]);\n\n  // Expand palette for a specific kind via queue\n  const handleExpand = useCallback(\n    (entityKind: string) => {\n      if (!isWorkerReady) {\n        alert(\"Worker not ready. Please wait...\");\n        return;\n      }\n\n      // Create a synthetic entity for the queue (palette expansion is not entity-specific)\n      const syntheticEntity: EnrichedEntity = {\n        id: `palette_${entityKind}`,\n        name: `Palette: ${entityKind}`,\n        kind: entityKind,\n        subtype: \"\",\n        prominence: \"recognized\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      // Filter cultures to those with visual identities (more useful for grounding)\n      const cultureContext = cultures\n        .filter((c) => c.name && (c.visualIdentity || c.description))\n        .map((c) => ({\n          name: c.name,\n          description: c.description,\n          visualIdentity: c.visualIdentity,\n        }));\n\n      // Get subtypes for this kind\n      const subtypes = subtypesByKind[entityKind] || [];\n\n      enqueue([\n        {\n          entity: syntheticEntity,\n          type: \"paletteExpansion\",\n          prompt: \"\", // Not used - worker builds prompt from paletteEntityKind + paletteWorldContext\n          paletteEntityKind: entityKind,\n          paletteWorldContext: worldContext || \"A fantasy world with diverse entities.\",\n          paletteSubtypes: subtypes.length > 0 ? subtypes : undefined,\n          paletteEras: eras.length > 0 ? eras : undefined,\n          paletteCultureContext: cultureContext.length > 0 ? cultureContext : undefined,\n        },\n      ]);\n    },\n    [isWorkerReady, enqueue, worldContext, subtypesByKind, eras, cultures]\n  );\n\n  // Export all palettes\n  const handleExport = useCallback(async () => {\n    try {\n      const allPalettes = await exportPalettes(projectId);\n      const json = JSON.stringify(allPalettes, null, 2);\n      const blob = new Blob([json], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `trait-palettes-${new Date().toISOString().split(\"T\")[0]}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to export palettes:\", err);\n      alert(\"Failed to export palettes\");\n    }\n  }, [projectId]);\n\n  // Count total categories\n  const totalCategories = Object.values(palettes).reduce(\n    (sum, p) => sum + (p?.items.length || 0),\n    0\n  );\n\n  // Find recent errors for palette expansion\n  const recentErrors = useMemo(() => {\n    return queue\n      .filter(\n        (item) =>\n          item.type === \"paletteExpansion\" && item.status === \"error\" && item.paletteEntityKind\n      )\n      .slice(-3); // Show last 3 errors\n  }, [queue]);\n\n  if (loading) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"tps-loading\">\n          Loading trait palettes...\n        </div>\n      </div>\n    );\n  }\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        </div>\n        <div className=\"tps-empty\">\n          No entity kinds available. Load a world with entity kinds defined to use trait palettes.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header\">\n        <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        <div className=\"tps-header-actions\">\n          <button\n            onClick={() => void handleExport()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n            disabled={totalCategories === 0}\n          >\n            Export\n          </button>\n          <button\n            onClick={() => void loadPalettes()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n          >\n            Refresh\n          </button>\n        </div>\n      </div>\n\n      <p className=\"tps-description\">\n        Trait palettes provide diverse visual directions for entity descriptions. Expand palettes to\n        generate new trait categories and reduce repetition.\n      </p>\n\n      {/* Summary stats */}\n      <div className=\"tps-stats-grid\">\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{entityKinds.length}</div>\n          <div className=\"tps-stat-label\">Entity Kinds</div>\n        </div>\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{totalCategories}</div>\n          <div className=\"tps-stat-label\">Total Categories</div>\n        </div>\n      </div>\n\n      {/* Per-kind palettes */}\n      <div className=\"tps-kind-list\">\n        {entityKinds.map((kind) => {\n          const palette = palettes[kind];\n          const isExpanding = expandingKinds.has(kind);\n          const isSelected = selectedKind === kind;\n\n          return (\n            <div\n              key={kind}\n              className=\"tps-kind-card\"\n            >\n              {/* Header row */}\n              <div\n                className=\"tps-kind-header\"\n                onClick={() => setSelectedKind(isSelected ? null : kind)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"tps-kind-header-left\">\n                  <code className=\"tps-kind-badge\">\n                    {kind || \"(unknown)\"}\n                  </code>\n                  <span className=\"tps-category-count\">\n                    {palette?.items.length || 0} categories\n                  </span>\n                </div>\n                <div className=\"tps-kind-header-right\">\n                  <button\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      if (!kind) {\n                        alert(\"Invalid entity kind\");\n                        return;\n                      }\n                      handleExpand(kind);\n                    }}\n                    className=\"illuminator-button illuminator-button-primary tps-expand-btn\"\n                    disabled={isExpanding || !isWorkerReady || !kind}\n                    title={\n                      !isWorkerReady ? \"Worker not ready\" : `Generate trait categories for ${kind}`\n                    }\n                  >\n                    {isExpanding ? \"Expanding...\" : \"Expand\"}\n                  </button>\n                  <span className={`tps-expand-icon ${isSelected ? \"tps-expand-icon-open\" : \"tps-expand-icon-closed\"}`}>\n                    \u25bc\n                  </span>\n                </div>\n              </div>\n\n              {/* Expanded content */}\n              {isSelected && (\n                <div className=\"tps-kind-body\">\n                  {!palette || palette.items.length === 0 ? (\n                    <div className=\"tps-kind-empty\">\n                      No palette categories yet. Click &quot;Expand Palette&quot; to generate some.\n                    </div>\n                  ) : (\n                    <div className=\"tps-palette-list\">\n                      {palette.items.map((item: PaletteItem) => (\n                        <div\n                          key={item.id}\n                          className=\"tps-palette-item\"\n                        >\n                          <div className=\"tps-palette-header\">\n                            <span className=\"tps-palette-category\">\n                              {item.category}\n                            </span>\n                            <span\n                              className={`tps-usage-badge ${item.timesUsed > 0 ? \"tps-usage-badge-used\" : \"tps-usage-badge-unused\"}`}\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}", "type": "Readonly<TraitPaletteSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useMemo"], "category": "framework"}, {"source": "../lib/db/traitRepository", "specifiers": ["getPalette", "exportPalettes", "TraitPalette", "PaletteItem"], "category": "internal"}, {"source": "./TraitPaletteSection.css", "specifiers": [], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["QueueItem", "EnrichmentType"], "category": "internal"}, {"source": "../hooks/useEnrichmentQueue", "specifiers": ["EnrichedEntity"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx", "sourceCode": "export default function VisualIdentityPanel({\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}) {\n  // Collect all visual identity keys\n  const visualKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.visual || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.visual]);\n\n  // Collect all descriptive identity keys\n  const descriptiveKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.descriptive || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.descriptive]);\n\n  // Visual identity handlers\n  const handleVisualIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visual: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleVisualKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visualKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n\n  // Descriptive identity handlers\n  const handleDescriptiveIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptive: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleDescriptiveKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptiveKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  return <div className=\"illuminator-visual-identity-panel\">\n      {/* Visual Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Visual Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe visual traits for image prompts (clothing, species, architecture)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define visual characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.visual} onIdentitiesChange={handleVisualIdentitiesChange} allKeys={visualKeys} keyPlaceholder=\"KEY (e.g., ATTIRE)\" valuePlaceholder=\"e.g., fur parkas with bone jewelry\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which visual traits to include per entity kind\" defaultOpen={visualKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={visualKeys} keysByKind={cultureIdentities.visualKeysByKind} onKeysByKindChange={handleVisualKeysByKindChange} emptyMessage=\"No visual identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n\n      {/* Descriptive Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Descriptive Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe traits for text prompts (customs, speech patterns, values)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define descriptive characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.descriptive} onIdentitiesChange={handleDescriptiveIdentitiesChange} allKeys={descriptiveKeys} keyPlaceholder=\"KEY (e.g., CUSTOMS)\" valuePlaceholder=\"e.g., elaborate greeting rituals involving fish exchange\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which descriptive traits to include per entity kind\" defaultOpen={descriptiveKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={descriptiveKeys} keysByKind={cultureIdentities.descriptiveKeysByKind} onKeysByKindChange={handleDescriptiveKeysByKindChange} emptyMessage=\"No descriptive identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}", "type": "{ cultures: any; entityKinds: any; cultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./VisualIdentityPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/WorldContextEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/WorldContextEditor.jsx", "sourceCode": "export default function WorldContextEditor({\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}) {\n  const updateField = useCallback(\n    (field, value) => {\n      onWorldContextChange({ [field]: value });\n    },\n    [onWorldContextChange]\n  );\n\n  const parseDynamicsFile = useCallback((fileContent) => {\n    try {\n      const parsed = JSON.parse(fileContent);\n      if (!Array.isArray(parsed)) {\n        alert(\"Invalid dynamics file: expected a JSON array.\");\n        return;\n      }\n      const valid = parsed.every(\n        (d) => d && typeof d.id === \"string\" && typeof d.text === \"string\"\n      );\n      if (!valid) {\n        alert(\"Invalid dynamics file: each entry must have id and text strings.\");\n        return;\n      }\n      updateField(\"worldDynamics\", parsed);\n    } catch (err) {\n      alert(`Failed to parse dynamics JSON: ${err.message}`);\n    }\n  }, [updateField]);\n\n  const handleImportDynamicsJson = useCallback(() => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json\";\n    input.onchange = (e) => {\n      const file = e.target.files?.[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) => parseDynamicsFile(ev.target.result);\n      reader.readAsText(file);\n    };\n    input.click();\n  }, [parseDynamicsFile]);\n\n  return (\n    <div>\n      {/* Info Banner */}\n      <div className=\"wce-info-banner\">\n        <div className=\"wce-info-banner-title\">Entity context is built automatically</div>\n        <div className=\"wce-info-banner-desc\">\n          Relationships, cultural peers, faction members, and entity age are extracted from the\n          simulation data. This panel only configures world-level context that applies to all\n          entities.\n        </div>\n      </div>\n\n      {/* World Identity */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">World Identity</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"world-name\" className=\"illuminator-label\">World Name</label>\n          <input id=\"world-name\"\n            type=\"text\"\n            value={worldContext.name || \"\"}\n            onChange={(e) => updateField(\"name\", e.target.value)}\n            placeholder=\"e.g., The Frozen Realms of Aurora Berg\"\n            className=\"illuminator-input\"\n          />\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label className=\"illuminator-label\">World Description\n          <LocalTextArea\n            value={worldContext.description || \"\"}\n            onChange={(value) => updateField(\"description\", value)}\n            placeholder=\"Brief description of your world's setting, themes, and what makes it unique...\"\n            className=\"illuminator-input wce-textarea-description\"\n          />\n          </label>\n        </div>\n      </div>\n\n      {/* Species Constraint */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Species Constraint</h2>\n        </div>\n        <p className=\"wce-description-text\">\n          Rule for what species can appear in generated images. This is added as a SPECIES\n          REQUIREMENT at the top of image prompts to ensure all depicted figures match your world&apos;s\n          inhabitants.\n        </p>\n        <div className=\"illuminator-form-group\">\n          <LocalTextArea\n            value={worldContext.speciesConstraint || \"\"}\n            onChange={(value) => updateField(\"speciesConstraint\", value)}\n            placeholder=\"e.g., All depicted figures must be penguins or orcas. No humans exist in this world.\"\n            className=\"illuminator-input wce-textarea-tone\"\n          />\n        </div>\n      </div>\n\n      {/* World Context Configuration */}\n      <div className=\"wce-section-divider\">\n        <div className=\"wce-section-header\">\n          <h2 className=\"wce-section-title\">Chronicle Generation</h2>\n          <p className=\"wce-section-subtitle\">\n            Tone and facts for chronicle generation. Chronicles use perspective synthesis to create\n            focused, faceted views based on each chronicle&apos;s entity constellation.\n          </p>\n        </div>\n\n        {/* Canon Facts */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Canon Facts</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            World truths and generation constraints. Required facts must appear in perspective\n            facets. Generation constraints are always included verbatim and never faceted.\n          </p>\n          <div className=\"illuminator-form-group wce-form-group-mb16\">\n            <span className=\"illuminator-label\">Facet Range (optional)</span>\n            <div className=\"wce-facet-range-row\">\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.minCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    minCount: parsed,\n                  });\n                }}\n                placeholder=\"min (4)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n              <span className=\"wce-facet-range-separator\">to</span>\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.maxCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    maxCount: parsed,\n                  });\n                }}\n                placeholder=\"max (6)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n            </div>\n            <div className=\"wce-facet-range-hint\">\n              Range of world-truth facts to facet. Required facts count toward this; min is raised\n              to match required count if needed.\n            </div>\n          </div>\n          <FactsEditor\n            facts={worldContext.canonFactsWithMetadata || []}\n            onChange={(facts) => updateField(\"canonFactsWithMetadata\", facts)}\n          />\n        </div>\n\n        {/* World Dynamics */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header wce-dynamics-header\">\n            <h2 className=\"illuminator-card-title\">World Dynamics</h2>\n            <div className=\"wce-dynamics-actions\">\n              <button\n                onClick={handleImportDynamicsJson}\n                className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n              >\n                Import JSON\n              </button>\n              {worldContext.worldDynamics?.length > 0 && (\n                <button\n                  onClick={() => {\n                    const json = JSON.stringify(worldContext.worldDynamics, null, 2);\n                    const blob = new Blob([json], { type: \"application/json\" });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = `dynamics-${new Date().toISOString().slice(0, 10)}.json`;\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(url);\n                  }}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  Export JSON\n                </button>\n              )}\n              {onGenerateDynamics && (\n                <button\n                  onClick={onGenerateDynamics}\n                  disabled={isGeneratingDynamics}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  {isGeneratingDynamics ? \"Generating...\" : \"Generate from Lore\"}\n                </button>\n              )}\n            </div>\n          </div>\n          <p className=\"wce-description-text\">\n            Higher-level narrative context about inter-group forces and behaviors. These statements\n            describe macro-level dynamics that individual relationships are expressions of.\n            Optionally filter by culture or entity kind so they only appear in relevant chronicles.\n          </p>\n          <WorldDynamicsEditor\n            dynamics={worldContext.worldDynamics || []}\n            onChange={(dynamics) => updateField(\"worldDynamics\", dynamics)}\n            eras={eras}\n          />\n        </div>\n\n\n        {/* Tone Fragments */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Tone Fragments</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            Composable tone guidance. Core is always included; culture and kind overlays are added\n            based on the chronicle&apos;s entity constellation.\n          </p>\n          <ToneFragmentsEditor\n            fragments={worldContext.toneFragments || {}}\n            onChange={(fragments) => updateField(\"toneFragments\", fragments)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}", "type": "{ worldContext: any; onWorldContextChange: any; eras: any; onGenerateDynamics: any; isGeneratingDynamics: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["LocalTextArea"], "category": "external"}, {"source": "./WorldContextEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useApiKeys.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useApiKeys.js", "sourceCode": "export default function useApiKeys() {\n  const [persistApiKeys, setPersistApiKeys] = useState(() =>\n    readPersistedFlag(\"illuminator:persistApiKeys\")\n  );\n  const [anthropicApiKey, setAnthropicApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:anthropicApiKey\")\n  );\n  const [openaiApiKey, setOpenaiApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:openaiApiKey\")\n  );\n  const [showApiKeyInput, setShowApiKeyInput] = useState(false);\n\n  // Persist API keys when enabled\n  useEffect(() => {\n    try {\n      localStorage.setItem(\"illuminator:persistApiKeys\", persistApiKeys ? \"true\" : \"false\");\n      if (persistApiKeys) {\n        localStorage.setItem(\"illuminator:anthropicApiKey\", anthropicApiKey);\n        localStorage.setItem(\"illuminator:openaiApiKey\", openaiApiKey);\n      } else {\n        localStorage.removeItem(\"illuminator:anthropicApiKey\");\n        localStorage.removeItem(\"illuminator:openaiApiKey\");\n      }\n    } catch {\n      /* ignored */\n    }\n  }, [persistApiKeys, anthropicApiKey, openaiApiKey]);\n\n  const hasAnthropicKey = anthropicApiKey.length > 0;\n  const hasRequiredKeys = hasAnthropicKey;\n\n  return {\n    persistApiKeys,\n    setPersistApiKeys,\n    anthropicApiKey,\n    setAnthropicApiKey,\n    openaiApiKey,\n    setOpenaiApiKey,\n    showApiKeyInput,\n    setShowApiKeyInput,\n    hasAnthropicKey,\n    hasRequiredKeys,\n  };\n}", "parameters": [], "returnType": "{ persistApiKeys: boolean; setPersistApiKeys: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; anthropicApiKey: string; setAnthropicApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; openaiApiKey: string; setOpenaiApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; showApiKeyInput: boolean; setShowApiKeyInput: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; hasAnthropicKey: boolean; hasRequiredKeys: boolean; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useEffect"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts::deriveStatus", "name": "deriveStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts", "sourceCode": "/**\n * Derive status from what's present in the record.\n * This eliminates status synchronization issues.\n */\nexport function deriveStatus(record: ChronicleRecord | undefined): string {\n  if (!record) return \"not_started\";\n\n  if (record.status === \"failed\") return \"failed\";\n\n  // Check for in-progress states (worker is running)\n  if (record.status === \"generating\") {\n    return record.status;\n  }\n\n  // Derive from data presence (completed states)\n  if (record.finalContent || record.status === \"complete\") return \"complete\";\n  if (record.assembledContent) return \"assembly_ready\";\n\n  return \"not_started\";\n}", "parameters": [{"name": "record", "type": "ChronicleRecord | undefined", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useConfigSync.js", "sourceCode": "export default function useConfigSync({ externalEnrichmentConfig, onEnrichmentConfigChange }) {\n  const [localConfig, setLocalConfig] = useState(() =>\n    initializeEnrichmentConfig(externalEnrichmentConfig)\n  );\n  const pendingConfigSyncRef = useRef(null);\n  const skipConfigSyncRef = useRef(false);\n\n  // Detect external config changes during render (no ref access)\n  const [prevExternalConfig, setPrevExternalConfig] = useState(externalEnrichmentConfig);\n  if (externalEnrichmentConfig !== prevExternalConfig) {\n    setPrevExternalConfig(externalEnrichmentConfig);\n    if (externalEnrichmentConfig) {\n      setLocalConfig(normalizeEnrichmentConfig(externalEnrichmentConfig) || DEFAULT_CONFIG);\n    }\n  }\n\n  // Mark skip flag in effect (runs before sync effect due to declaration order)\n  useEffect(() => {\n    if (externalEnrichmentConfig) {\n      skipConfigSyncRef.current = true;\n      pendingConfigSyncRef.current = null;\n    }\n  }, [externalEnrichmentConfig]);\n\n  const config = localConfig;\n\n  const setConfig = useCallback((updater) => {\n    setLocalConfig((prev) => {\n      const next = typeof updater === \"function\" ? updater(prev) : updater;\n      pendingConfigSyncRef.current = next;\n      return next;\n    });\n  }, []);\n\n  // Sync local changes to parent (or localStorage)\n  useEffect(() => {\n    if (skipConfigSyncRef.current) {\n      skipConfigSyncRef.current = false;\n      pendingConfigSyncRef.current = null;\n      return;\n    }\n    const pending = pendingConfigSyncRef.current;\n    if (!pending) return;\n    pendingConfigSyncRef.current = null;\n    if (onEnrichmentConfigChange) {\n      onEnrichmentConfigChange(pending);\n    } else {\n      try {\n        localStorage.setItem(\"illuminator:config\", JSON.stringify(pending));\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [localConfig, onEnrichmentConfigChange]);\n\n  const updateConfig = useCallback(\n    (updates) => {\n      setConfig((prev) => ({ ...prev, ...updates }));\n    },\n    [setConfig]\n  );\n\n  return { config, setConfig, updateConfig };\n}", "parameters": [{"name": "{ externalEnrichmentConfig, onEnrichmentConfigChange }", "type": "{ externalEnrichmentConfig: any; onEnrichmentConfigChange: any; }", "optional": false}], "returnType": "{ config: { imageModel: string; minProminenceForImage: string; numWorkers: number; requireDescription: boolean; useClaudeForImagePrompt: boolean; claudeImagePromptTemplate: string; globalImageRules: string; minEventSignificance: number; }; setConfig: (updater: any) => void; updateConfig: (updates: any) => void; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/hooks/useEntityCrud.ts::reloadEntities", "name": "reloadEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityCrud.ts", "sourceCode": "// ============================================================================\n// Module-level helper \u2014 reusable by other hooks without prop threading\n// ============================================================================\n\n/**\n * Refresh entity store and notify the host shell.\n * Reads simulationRunId imperatively from the entity store.\n */\nexport async function reloadEntities(invalidateIds?: string[]): Promise<void> {\n  const store = useEntityStore.getState();\n  const { simulationRunId } = store;\n  if (!simulationRunId) return;\n\n  if (invalidateIds?.length) {\n    await store.refreshEntities(invalidateIds);\n  } else {\n    await store.refreshAll();\n  }\n\n  window.dispatchEvent(\n    new CustomEvent(\"illuminator:worlddata-changed\", {\n      detail: { simulationRunId, scope: \"entities\" },\n    })\n  );\n}", "parameters": [{"name": "invalidateIds", "type": "string[]", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js", "sourceCode": "export default function useEntityGuidanceSync({\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}) {\n  const [localEntityGuidance, setLocalEntityGuidance] = useState(createDefaultEntityGuidance);\n  const [localCultureIdentities, setLocalCultureIdentities] = useState(\n    createDefaultCultureIdentities\n  );\n  const pendingEntityGuidanceRef = useRef(localEntityGuidance);\n  const pendingCultureIdentitiesRef = useRef(localCultureIdentities);\n\n  // Detect external changes during render (no ref access)\n  const [prevGuidance, setPrevGuidance] = useState(externalEntityGuidance);\n  if (externalEntityGuidance !== prevGuidance) {\n    setPrevGuidance(externalEntityGuidance);\n    if (externalEntityGuidance !== undefined) {\n      setLocalEntityGuidance(externalEntityGuidance || createDefaultEntityGuidance());\n    }\n  }\n  const [prevIdentities, setPrevIdentities] = useState(externalCultureIdentities);\n  if (externalCultureIdentities !== prevIdentities) {\n    setPrevIdentities(externalCultureIdentities);\n    if (externalCultureIdentities !== undefined) {\n      setLocalCultureIdentities(externalCultureIdentities || createDefaultCultureIdentities());\n    }\n  }\n\n  // Sync refs in effects\n  useEffect(() => {\n    if (externalEntityGuidance !== undefined) {\n      pendingEntityGuidanceRef.current = externalEntityGuidance || createDefaultEntityGuidance();\n    }\n  }, [externalEntityGuidance]);\n  useEffect(() => {\n    if (externalCultureIdentities !== undefined) {\n      pendingCultureIdentitiesRef.current =\n        externalCultureIdentities || createDefaultCultureIdentities();\n    }\n  }, [externalCultureIdentities]);\n\n  const entityGuidanceSyncTimeoutRef = useRef(null);\n  const updateEntityGuidance = useCallback(\n    (nextGuidance) => {\n      setLocalEntityGuidance(nextGuidance);\n      pendingEntityGuidanceRef.current = nextGuidance;\n      if (!onEntityGuidanceChange) return;\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      entityGuidanceSyncTimeoutRef.current = setTimeout(() => {\n        onEntityGuidanceChange(pendingEntityGuidanceRef.current);\n        entityGuidanceSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onEntityGuidanceChange]\n  );\n\n  const cultureIdentitiesSyncTimeoutRef = useRef(null);\n  const updateCultureIdentities = useCallback(\n    (nextIdentities) => {\n      setLocalCultureIdentities(nextIdentities);\n      pendingCultureIdentitiesRef.current = nextIdentities;\n      if (!onCultureIdentitiesChange) return;\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n      cultureIdentitiesSyncTimeoutRef.current = setTimeout(() => {\n        onCultureIdentitiesChange(pendingCultureIdentitiesRef.current);\n        cultureIdentitiesSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onCultureIdentitiesChange]\n  );\n\n  useEffect(\n    () => () => {\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n    },\n    []\n  );\n\n  return {\n    entityGuidance: localEntityGuidance,\n    updateEntityGuidance,\n    cultureIdentities: localCultureIdentities,\n    updateCultureIdentities,\n  };\n}", "parameters": [{"name": "{\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}", "type": "{ externalEntityGuidance: any; onEntityGuidanceChange: any; externalCultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "{ entityGuidance: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").EntityGuidance; updateEntityGuidance: (nextGuidance: any) => void; cultureIdentities: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").CultureIdentities; updateCultureIdentities: (nextIdentities: any) => void; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "../lib/promptBuilders", "specifiers": ["createDefaultEntityGuidance", "createDefaultCultureIdentities"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianActions.ts::registerHistorianStarters", "name": "registerHistorianStarters", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianActions.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the primitive hook start functions.\n * The isActive flags are synced to useIlluminatorConfigStore instead.\n */\nexport function registerHistorianStarters(starters: HistorianStarters): void {\n  _starters = starters;\n}", "parameters": [{"name": "starters", "type": "HistorianStarters", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback"], "category": "framework"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/historianContextBuilders", "specifiers": ["buildHistorianEditionContext", "buildHistorianReviewContext"], "category": "internal"}, {"source": "../lib/descriptionHistoryCompression", "specifiers": ["compressDescriptionHistory", "COMPRESSION_FLOOR"], "category": "internal"}, {"source": "./useEntityCrud", "specifiers": ["reloadEntities"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "updateChronicleHistorianNotes"], "category": "internal"}, {"source": "./useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js", "sourceCode": "export default function useHistorianConfigSync({\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}) {\n  const [localHistorianConfig, setLocalHistorianConfig] = useState(() =>\n    resolveInitialHistorianConfig(externalHistorianConfig)\n  );\n  const [hasMigrated, setHasMigrated] = useState(false);\n  const pendingHistorianConfigRef = useRef(localHistorianConfig);\n\n  // Detect external changes during render (no ref access)\n  const [prevExternal, setPrevExternal] = useState(externalHistorianConfig);\n  if (externalHistorianConfig !== prevExternal) {\n    setPrevExternal(externalHistorianConfig);\n    if (externalHistorianConfig !== undefined) {\n      const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n      setLocalHistorianConfig(resolved.config);\n      if (resolved.migrated !== hasMigrated) setHasMigrated(resolved.migrated);\n    }\n  }\n\n  // Ref + side effects in effect (legacy migration, cleanup)\n  useEffect(() => {\n    if (externalHistorianConfig === undefined) return;\n    const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n    pendingHistorianConfigRef.current = resolved.config;\n    if (resolved.migrated && !externalHistorianConfig) {\n      if (onHistorianConfigChange) onHistorianConfigChange(resolved.config);\n      try {\n        localStorage.removeItem(LEGACY_HISTORIAN_CONFIG_KEY);\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [externalHistorianConfig, onHistorianConfigChange, hasMigrated]);\n\n  const historianConfigSyncTimeoutRef = useRef(null);\n  const updateHistorianConfig = useCallback(\n    (next) => {\n      setLocalHistorianConfig(next);\n      pendingHistorianConfigRef.current = next;\n      if (!onHistorianConfigChange) return;\n      if (historianConfigSyncTimeoutRef.current)\n        clearTimeout(historianConfigSyncTimeoutRef.current);\n      historianConfigSyncTimeoutRef.current = setTimeout(() => {\n        onHistorianConfigChange(pendingHistorianConfigRef.current);\n        historianConfigSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onHistorianConfigChange]\n  );\n\n  return { historianConfig: localHistorianConfig, updateHistorianConfig };\n}", "parameters": [{"name": "{\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}", "type": "{ externalHistorianConfig: any; onHistorianConfigChange: any; }", "optional": false}], "returnType": "{ historianConfig: any; updateHistorianConfig: (next: any) => void; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "../lib/historianTypes", "specifiers": ["DEFAULT_HISTORIAN_CONFIG", "isHistorianConfigured"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useSlotManagement.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useSlotManagement.js", "sourceCode": "export default function useSlotManagement({ projectId, activeSlotIndex, navEntities }) {\n  const [slotRecord, setSlotRecord] = useState(null);\n\n  // Adjust state during render when projectId changes (avoids setState-in-effect)\n  const [prevProjectSlot, setPrevProjectSlot] = useState({ projectId, activeSlotIndex });\n  const projectSlotChange = resolveProjectSlotChange(projectId, prevProjectSlot, activeSlotIndex);\n  if (projectSlotChange.changed) {\n    setPrevProjectSlot({ projectId, activeSlotIndex });\n    if (projectSlotChange.clearSlot) setSlotRecord(null);\n  }\n\n  // Load slot metadata from Dexie (async work stays in effect)\n  useEffect(() => {\n    if (!projectId) return;\n    let cancelled = false;\n\n    (async () => {\n      const slot = await slotRepo.getSlot(projectId, activeSlotIndex);\n      if (cancelled) return;\n      setSlotRecord(slot || null);\n      useEntityStore.getState().reset();\n      useIndexStore.getState().reset();\n      useNarrativeEventStore.getState().reset();\n      useRelationshipStore.getState().reset();\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, activeSlotIndex]);\n\n  const [currentEra, setCurrentEra] = useState(null);\n\n  // Adjust current era during render for synchronous cases\n  const [prevEraKey, setPrevEraKey] = useState(slotRecord?.finalEraId);\n  const currentEraId = slotRecord?.finalEraId;\n  if (currentEraId !== prevEraKey) {\n    setPrevEraKey(currentEraId);\n    const result = resolveEraRenderAdjustment(slotRecord, navEntities);\n    if (result.changed) setCurrentEra(result.era);\n  }\n\n  // Async full-entity load for era (when we have a nav match but need description)\n  useEffect(() => {\n    const resolved = resolveCurrentEra(slotRecord, navEntities);\n    if (!resolved.needsFullLoad) return;\n    useEntityStore\n      .getState()\n      .loadEntity(resolved.needsFullLoad)\n      .then((full) => {\n        setCurrentEra(buildEraFromLoadedEntity(full, resolved.needsFullLoad));\n      });\n  }, [slotRecord, navEntities]);\n\n  const eraTemporalInfo = useEraTemporalInfo();\n  const eraTemporalInfoByKey = useEraTemporalInfoByKey();\n  const prominentByCulture = useProminentByCulture();\n\n  // Extract simulationRunId from slot metadata for content association\n  const simulationRunId = slotRecord?.simulationRunId;\n\n  return {\n    slotRecord,\n    setSlotRecord,\n    simulationRunId,\n    currentEra,\n    eraTemporalInfo,\n    eraTemporalInfoByKey,\n    prominentByCulture,\n  };\n}", "parameters": [{"name": "{ projectId, activeSlotIndex, navEntities }", "type": "{ projectId: any; activeSlotIndex: any; navEntities: any; }", "optional": false}], "returnType": "{ slotRecord: any; setSlotRecord: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<any>; simulationRunId: any; currentEra: any; eraTemporalInfo: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry[]; eraTemporalInfoByKey: Map<string, import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry>; prominentByCulture: Record<string, { id: string; name: string; }[]>; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useEffect"], "category": "framework"}, {"source": "../lib/db/slotRepository", "specifiers": ["* as slotRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "../lib/db/narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}, {"source": "../lib/db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useEraTemporalInfo", "useEraTemporalInfoByKey", "useProminentByCulture"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::assignCorpusTones", "name": "assignCorpusTones", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "/**\n * Assign tones to chronicles with strong rank-1 preference but distribution balancing.\n * Chronicles only shift from rank-1 if their preferred tone is heavily overrepresented\n * AND they have a good alternative that fills an underrepresented slot.\n */\nexport function assignCorpusTones(\n  chronicles: Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>\n): ToneAssignmentEntry[] {\n  const entries: ToneAssignmentEntry[] = chronicles.map((c) => ({\n    chronicleId: c.chronicleId,\n    title: c.title,\n    ranking: c.ranking,\n    assignedTone: c.ranking[0],\n    wasShifted: false,\n  }));\n\n  const target = entries.length / ANNOTATION_TONES.length;\n  const ceiling = Math.ceil(target * 1.2);\n\n  for (let round = 0; round < 50; round++) {\n    const counts = countDistribution(entries);\n\n    let overTone: HistorianTone | null = null;\n    let overCount = ceiling;\n    for (const t of ANNOTATION_TONES) {\n      if (counts[t] > overCount) {\n        overTone = t;\n        overCount = counts[t];\n      }\n    }\n    if (!overTone) break;\n\n    let shifted = false;\n    const candidates = entries\n      .filter((e) => e.assignedTone === overTone)\n      .map((e) => {\n        for (const altRank of [1, 2] as const) {\n          const alt = e.ranking[altRank];\n          if (alt && counts[alt] < counts[overTone]) {\n            return { entry: e, alt, priority: altRank * 100 + counts[alt] };\n          }\n        }\n        return null;\n      })\n      .filter(\n        (c): c is { entry: ToneAssignmentEntry; alt: HistorianTone; priority: number } => c !== null\n      )\n      .sort((a, b) => a.priority - b.priority);\n\n    if (candidates.length > 0) {\n      const best = candidates[0];\n      best.entry.assignedTone = best.alt;\n      best.entry.wasShifted = true;\n      shifted = true;\n    }\n\n    if (!shifted) break;\n  }\n\n  return entries;\n}", "parameters": [{"name": "chronicles", "type": "Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>", "optional": false}], "returnType": "ToneAssignmentEntry[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/db/toneRankingStore", "specifiers": ["useToneRankingStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::countDistribution", "name": "countDistribution", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "export function countDistribution(entries: ToneAssignmentEntry[]): Record<HistorianTone, number> {\n  const counts = Object.fromEntries(ANNOTATION_TONES.map((t) => [t, 0])) as Record<\n    HistorianTone,\n    number\n  >;\n  for (const e of entries) {\n    if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n  }\n  return counts;\n}", "parameters": [{"name": "entries", "type": "ToneAssignmentEntry[]", "optional": false}], "returnType": "Record<HistorianTone, number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/db/toneRankingStore", "specifiers": ["useToneRankingStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useWorldContextSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useWorldContextSync.js", "sourceCode": "export default function useWorldContextSync({ externalWorldContext, onWorldContextChange }) {\n  const [localWorldContext, setLocalWorldContext] = useState(DEFAULT_WORLD_CONTEXT);\n  const worldContext = localWorldContext;\n  const worldContextSyncTimeoutRef = useRef(null);\n  const worldContextDirtyRef = useRef(false);\n  const pendingWorldContextRef = useRef(localWorldContext);\n\n  // Detect external context changes during render (no ref access)\n  const [prevExternalContext, setPrevExternalContext] = useState(externalWorldContext);\n  if (externalWorldContext !== prevExternalContext) {\n    setPrevExternalContext(externalWorldContext);\n    if (externalWorldContext !== undefined) {\n      const nextContext = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n      setLocalWorldContext(nextContext);\n    }\n  }\n\n  // Ref side effects when external changes (clear timeout, update refs)\n  useEffect(() => {\n    if (externalWorldContext === undefined) return;\n    if (worldContextSyncTimeoutRef.current) {\n      clearTimeout(worldContextSyncTimeoutRef.current);\n      worldContextSyncTimeoutRef.current = null;\n    }\n    worldContextDirtyRef.current = false;\n    pendingWorldContextRef.current = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n  }, [externalWorldContext]);\n\n  const updateWorldContext = useCallback(\n    (updates) => {\n      setLocalWorldContext((prev) => {\n        const merged = { ...prev, ...updates };\n        pendingWorldContextRef.current = merged;\n        if (onWorldContextChange) {\n          worldContextDirtyRef.current = true;\n          if (worldContextSyncTimeoutRef.current) {\n            clearTimeout(worldContextSyncTimeoutRef.current);\n          }\n          worldContextSyncTimeoutRef.current = setTimeout(() => {\n            if (!worldContextDirtyRef.current) return;\n            worldContextDirtyRef.current = false;\n            onWorldContextChange(pendingWorldContextRef.current);\n            worldContextSyncTimeoutRef.current = null;\n          }, 300);\n        }\n        return merged;\n      });\n    },\n    [onWorldContextChange]\n  );\n\n  useEffect(() => {\n    return () => {\n      if (worldContextSyncTimeoutRef.current) {\n        clearTimeout(worldContextSyncTimeoutRef.current);\n        worldContextSyncTimeoutRef.current = null;\n      }\n      if (worldContextDirtyRef.current && onWorldContextChange) {\n        onWorldContextChange(pendingWorldContextRef.current);\n      }\n    };\n  }, [onWorldContextChange]);\n\n  return { worldContext, updateWorldContext };\n}", "parameters": [{"name": "{ externalWorldContext, onWorldContextChange }", "type": "{ externalWorldContext: any; onWorldContextChange: any; }", "optional": false}], "returnType": "{ worldContext: { name: string; description: string; toneFragments: { core: string; }; canonFactsWithMetadata: any[]; factSelection: {}; worldDynamics: any[]; }; updateWorldContext: (updates: any) => void; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/lib/annotateEntityNames.ts::annotateEntityNames", "name": "annotateEntityNames", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/annotateEntityNames.ts", "sourceCode": "export function annotateEntityNames(text: string, navItems: Map<string, EntityNavItem>): string {\n  const candidates = buildCandidates(navItems);\n\n  // Track annotated regions in the mutated string's coordinates.\n  // After each replacement the ranges shift -- we adjust all existing ranges\n  // so overlap checks always work against current positions.\n  const annotatedRanges: Array<[number, number]> = [];\n  const overlaps = (start: number, end: number): boolean =>\n    annotatedRanges.some(([rs, re]) => start < re && end > rs);\n\n  let result = text;\n\n  for (const { name, annotation } of candidates) {\n    const idx = result.indexOf(name);\n    if (idx === -1) continue;\n\n    const afterName = idx + name.length;\n    if (isAlreadyAnnotated(result, afterName)) continue;\n    if (overlaps(idx, afterName)) continue;\n\n    result = result.slice(0, idx) + annotation + result.slice(afterName);\n    const delta = annotation.length - name.length;\n    shiftRanges(annotatedRanges, afterName, delta);\n    annotatedRanges.push([idx, idx + annotation.length]);\n  }\n\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "navItems", "type": "Map<string, EntityNavItem>", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts::executeBrowserTask", "name": "executeBrowserTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts", "sourceCode": "/**\n * Execute an enrichment task in the main browser thread.\n *\n * Returns the same TaskResult shape as the service worker path.\n */\nexport async function executeBrowserTask(\n  task: WorkerTask,\n  config: WorkerConfig,\n  callbacks?: BrowserTaskCallbacks\n): Promise<TaskResult> {\n  // Merge task-level llmCallSettings with global config\n  const taskConfig = task.llmCallSettings\n    ? { ...config, llmCallSettings: task.llmCallSettings }\n    : config;\n\n  const { llmClient, imageClient } = createClients(taskConfig);\n\n  console.log(\"[BrowserTask] Started\", { taskId: task.id, type: task.type });\n\n  try {\n    const result = await executeTask(task, {\n      config: taskConfig,\n      llmClient,\n      imageClient,\n      isAborted: () => false,\n      onThinkingDelta: callbacks?.onThinkingDelta\n        ? (delta) => callbacks.onThinkingDelta(task.id, delta)\n        : undefined,\n      onTextDelta: callbacks?.onTextDelta\n        ? (delta) => callbacks.onTextDelta(task.id, delta)\n        : undefined,\n    });\n\n    if (result.success) {\n      await persistResult(task, result.result);\n      console.log(\"[BrowserTask] Complete\", { taskId: task.id, type: task.type });\n    } else {\n      console.warn(\"[BrowserTask] Failed\", { taskId: task.id, error: result.error });\n    }\n\n    return result;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    console.error(\"[BrowserTask] Threw\", { taskId: task.id, error: message });\n    return { success: false, error: message };\n  }\n}", "parameters": [{"name": "task", "type": "WorkerTask", "optional": false}, {"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callbacks", "type": "BrowserTaskCallbacks", "optional": true}], "returnType": "Promise<TaskResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./enrichmentTypes", "specifiers": ["WorkerTask", "EnrichmentResult"], "category": "internal"}, {"source": "../workers/types", "specifiers": ["WorkerConfig", "TaskResult"], "category": "internal"}, {"source": "../workers/clients", "specifiers": ["createClients"], "category": "internal"}, {"source": "../workers/tasks", "specifiers": ["executeTask"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildEventHeadline", "name": "buildEventHeadline", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build a stable event headline from subject + action, including description.\n */\nexport function buildEventHeadline(event: {\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}): string {\n  const subjectName = event.subject?.name || event.subject?.id || \"\";\n  const action = event.action || \"\";\n  const base = [subjectName, action].filter(Boolean).join(\" \").trim();\n  if (event.description) {\n    return base ? `${base} - ${event.description}` : event.description;\n  }\n  return base || \"(event)\";\n}", "parameters": [{"name": "event", "type": "{\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceThresholdFromScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}, {"source": "./chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleRoleAssignment", "NarrativeLens", "ChronicleFocus", "ChronicleFocusType", "EntityContext", "RelationshipContext", "EraContext", "NarrativeEventContext", "ChronicleTemporalContext", "ToneFragments", "CanonFactWithMetadata", "FactSelectionConfig", "WorldDynamic"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildChronicleContext", "name": "buildChronicleContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build generation context from chronicle selections (chronicle-first architecture)\n *\n * This is the primary entry point for building generation context.\n * Role assignments define the chronicle's identity, not a single entity.\n *\n * @param selections - Chronicle selections from wizard\n * @param worldData - World simulation data\n * @param worldContext - World context (name, description, etc.)\n * @param narrativeStyle - Narrative style selected for this chronicle\n * @param nameBank - Optional pre-generated names by culture for invented characters\n * @param proseHints - Optional per-kind prose hints for narrative guidance\n * @param culturalIdentities - Optional cultural identity data (VALUES, SPEECH, FEARS, TABOOS etc.)\n * @param temporalContext - Optional temporal context computed from selected events and eras\n * @param narrativeDirection - Optional free-text narrative direction from wizard\n */\nexport function buildChronicleContext(\n  selections: ChronicleSelections,\n  worldData: WorldData,\n  worldContext: WorldContext,\n  narrativeStyle: NarrativeStyle,\n  nameBank?: Record<string, string[]>,\n  proseHints?: Record<string, string>,\n  culturalIdentities?: Record<string, Record<string, string>>,\n  temporalContext?: ChronicleTemporalContext | null,\n  narrativeDirection?: string\n): ChronicleGenerationContext {\n  const entityMap = new Map(worldData.entities.map((e) => [e.id, e]));\n\n  // Build focus from role assignments\n  const focus = buildFocus(\n    selections.roleAssignments,\n    selections.selectedEventIds,\n    selections.selectedRelationshipIds,\n    selections.lens\n  );\n\n  // Get entities from role assignments\n  const entities = worldData.entities\n    .filter((e) => focus.selectedEntityIds.includes(e.id))\n    .map(buildEntityContext);\n\n  // Parse relationship IDs (format: src:dst:kind) and get selected relationships\n  const relationships = selections.selectedRelationshipIds\n    .map((id) => {\n      const [src, dst, kind] = id.split(\":\");\n      return worldData.relationships.find((r) => r.src === src && r.dst === dst && r.kind === kind);\n    })\n    .filter((r): r is NonNullable<typeof r> => r !== undefined)\n    .map((r) => buildRelationshipContext(r, entityMap));\n\n  // Get selected events\n  const eventIdSet = new Set(selections.selectedEventIds);\n  const events = (worldData.narrativeHistory || [])\n    .filter((e) => eventIdSet.has(e.id))\n    .sort((a, b) => b.significance - a.significance)\n    .map(buildEventContext);\n\n  // Resolve lens entity from world data\n  const lensRaw = selections.lens ? entityMap.get(selections.lens.entityId) : undefined;\n  const lensEntity = lensRaw ? buildEntityContext(lensRaw) : undefined;\n\n  // Resolve era: prefer temporalContext.focalEra (user-selected), fall back to primary entity's era\n  let eraContext: EraContext | undefined;\n  if (temporalContext?.focalEra) {\n    // Use the user-selected focal era from temporal context\n    eraContext = {\n      id: temporalContext.focalEra.id,\n      name: temporalContext.focalEra.name,\n      description: temporalContext.focalEra.summary,\n    };\n  } else {\n    // Fall back to deriving from primary entity's eraId\n    const eraLookup = buildEraLookup(worldData.entities);\n    const primaryEntityId = focus.primaryEntityIds[0];\n    const primaryEntity = primaryEntityId ? entityMap.get(primaryEntityId) : undefined;\n    const primaryEraId = resolveEntityEraId(primaryEntity);\n    const era = primaryEraId ? eraLookup.get(primaryEraId) : undefined;\n    eraContext = era ? buildEraContext(era) : undefined;\n  }\n\n  return {\n    worldName: worldContext.name || \"The World\",\n    worldDescription: worldContext.description || \"\",\n    // These will be populated by perspective synthesis\n    canonFacts: [],\n    tone: \"\",\n    narrativeStyle,\n\n    // Input for perspective synthesis (required)\n    toneFragments: worldContext.toneFragments,\n    canonFactsWithMetadata: worldContext.canonFactsWithMetadata,\n    factSelection: worldContext.factSelection,\n\n    // Chronicle focus (primary)\n    focus,\n\n    // Narrative lens entity (contextual frame)\n    lensEntity,\n\n    era: eraContext,\n    // Full temporal context with all eras and chronicle timeline\n    temporalContext: temporalContext || undefined,\n    entities,\n    relationships,\n    events,\n\n    // Name bank for invented characters\n    nameBank,\n\n    // Prose hints for entity kinds (e.g., how to write about NPCs vs locations)\n    proseHints,\n\n    // Cultural identities for cultures (VALUES, SPEECH, FEARS, TABOOS, etc.)\n    culturalIdentities,\n\n    // World dynamics (narrative context statements)\n    worldDynamics: worldContext.worldDynamics,\n\n    // Narrative direction (optional, from wizard)\n    narrativeDirection: narrativeDirection || undefined,\n  };\n}", "parameters": [{"name": "selections", "type": "ChronicleSelections", "optional": false}, {"name": "worldData", "type": "WorldData", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "narrativeStyle", "type": "NarrativeStyle", "optional": false}, {"name": "nameBank", "type": "Record<string, string[]>", "optional": true}, {"name": "proseHints", "type": "Record<string, string>", "optional": true}, {"name": "culturalIdentities", "type": "Record<string, Record<string, string>>", "optional": true}, {"name": "temporalContext", "type": "ChronicleTemporalContext | null", "optional": true}, {"name": "narrativeDirection", "type": "string", "optional": true}], "returnType": "ChronicleGenerationContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceThresholdFromScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}, {"source": "./chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleRoleAssignment", "NarrativeLens", "ChronicleFocus", "ChronicleFocusType", "EntityContext", "RelationshipContext", "EraContext", "NarrativeEventContext", "ChronicleTemporalContext", "ToneFragments", "CanonFactWithMetadata", "FactSelectionConfig", "WorldDynamic"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::checkPrerequisites", "name": "checkPrerequisites", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "export function checkPrerequisites(context: ChronicleGenerationContext): PrerequisiteCheck {\n  const missing: PrerequisiteCheck[\"missing\"] = [];\n\n  if (!context.focus?.roleAssignments) {\n    return { ready: false, missing };\n  }\n\n  // Check that primary entities have descriptions\n  for (const role of context.focus.roleAssignments.filter((r) => r.isPrimary)) {\n    const entity = context.entities.find((e) => e.id === role.entityId);\n    if (entity && !(entity.summary && entity.description)) {\n      missing.push({\n        type: \"entityDescription\",\n        id: entity.id,\n        name: entity.name,\n      });\n    }\n  }\n\n  return {\n    ready: missing.length === 0,\n    missing,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "PrerequisiteCheck", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceThresholdFromScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}, {"source": "./chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleRoleAssignment", "NarrativeLens", "ChronicleFocus", "ChronicleFocusType", "EntityContext", "RelationshipContext", "EraContext", "NarrativeEventContext", "ChronicleTemporalContext", "ToneFragments", "CanonFactWithMetadata", "FactSelectionConfig", "WorldDynamic"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::summarizeContext", "name": "summarizeContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Get a summary of context for display\n */\nexport function summarizeContext(context: ChronicleGenerationContext): {\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n} {\n  const prominenceScale = buildProminenceScale(\n    context.entities\n      .map((entity) => Number(entity.prominence))\n      .filter((value) => Number.isFinite(value)),\n    { distribution: DEFAULT_PROMINENCE_DISTRIBUTION }\n  );\n  const prominentThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  const prominentEntities = context.entities\n    .filter((e) => Number(e.prominence) >= prominentThreshold)\n    .map((e) => e.name)\n    .slice(0, 10);\n\n  const highSignificanceEvents = context.events\n    .filter((e) => e.significance >= 0.7)\n    .map((e) => e.headline)\n    .slice(0, 5);\n\n  return {\n    entityCount: context.entities.length,\n    relationshipCount: context.relationships.length,\n    eventCount: context.events.length,\n    prominentEntities,\n    highSignificanceEvents,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "{\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceThresholdFromScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}, {"source": "./chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleRoleAssignment", "NarrativeLens", "ChronicleFocus", "ChronicleFocusType", "EntityContext", "RelationshipContext", "EraContext", "NarrativeEventContext", "ChronicleTemporalContext", "ToneFragments", "CanonFactWithMetadata", "FactSelectionConfig", "WorldDynamic"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildChronicleExport", "name": "buildChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Build the full chronicle export from STORED data only.\n *\n * This function uses only what is stored in the ChronicleRecord.\n * No reconstruction, no parameter passing of generation context.\n */\nexport function buildChronicleExport(chronicle: ChronicleRecord): ChronicleExport {\n  const versions = [...(chronicle.generationHistory || [])].sort(\n    (a, b) => a.generatedAt - b.generatedAt\n  );\n  const latestVersion = versions.reduce(\n    (acc, v) => (acc && acc.generatedAt > v.generatedAt ? acc : v),\n    versions[0]\n  );\n  const activeVersionId = chronicle.activeVersionId || latestVersion?.versionId;\n  const isAccepted = Boolean(chronicle.acceptedAt && chronicle.finalContent);\n  const acceptedVersionId =\n    chronicle.acceptedVersionId || (isAccepted ? activeVersionId : undefined);\n  const effectiveVersionId = isAccepted ? acceptedVersionId || activeVersionId : activeVersionId;\n\n  const currentContent = chronicle.assembledContent || chronicle.finalContent || \"\";\n  const historyMatch = versions.find((version) => version.versionId === effectiveVersionId);\n  const effectiveVersion = historyMatch\n    ? {\n        id: historyMatch.versionId,\n        content: historyMatch.content,\n        wordCount: historyMatch.wordCount,\n        systemPrompt: historyMatch.systemPrompt,\n        userPrompt: historyMatch.userPrompt,\n        model: historyMatch.model,\n      }\n    : {\n        id: effectiveVersionId || \"unknown\",\n        content: currentContent,\n        wordCount: currentContent.split(/\\s+/).filter(Boolean).length,\n        systemPrompt:\n          chronicle.generationSystemPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        userPrompt:\n          chronicle.generationUserPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        model: chronicle.model,\n      };\n\n  const content =\n    isAccepted && chronicle.finalContent ? chronicle.finalContent : effectiveVersion.content;\n  const wordCount =\n    isAccepted && chronicle.finalContent\n      ? chronicle.finalContent.split(/\\s+/).filter(Boolean).length\n      : effectiveVersion.wordCount;\n  const systemPrompt = effectiveVersion.systemPrompt;\n  const userPrompt = effectiveVersion.userPrompt;\n  const exportData: ChronicleExport = {\n    exportVersion: \"1.3\",\n    exportedAt: new Date().toISOString(),\n    activeVersionId,\n    acceptedVersionId,\n\n    chronicle: {\n      id: chronicle.chronicleId,\n      title: chronicle.title,\n      format: chronicle.format,\n      focusType: chronicle.focusType,\n      narrativeStyleId: chronicle.narrativeStyleId,\n      narrativeStyleName: chronicle.narrativeStyle?.name,\n      craftPosture: chronicle.narrativeStyle?.craftPosture,\n      lens: chronicle.lens\n        ? {\n            entityId: chronicle.lens.entityId,\n            entityName: chronicle.lens.entityName,\n            entityKind: chronicle.lens.entityKind,\n          }\n        : undefined,\n      narrativeDirection: chronicle.narrativeDirection,\n      createdAt: new Date(chronicle.createdAt).toISOString(),\n      acceptedAt: chronicle.acceptedAt ? new Date(chronicle.acceptedAt).toISOString() : undefined,\n      model: chronicle.model,\n    },\n\n    content,\n    wordCount,\n\n    generationLLMCall: {\n      systemPrompt,\n      userPrompt,\n      model: effectiveVersion.model,\n    },\n  };\n\n  exportData.versions = versions.map((version) => ({\n    versionId: version.versionId,\n    generatedAt: new Date(version.generatedAt).toISOString(),\n    sampling: version.sampling,\n    step: version.step,\n    model: version.model,\n    wordCount: version.wordCount,\n    content: version.content,\n    systemPrompt: version.systemPrompt,\n    userPrompt: version.userPrompt,\n    cost: version.cost,\n  }));\n\n  attachOptionalExportFields(exportData, chronicle);\n\n  return exportData;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleExport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadChronicleExport", "name": "downloadChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Export chronicle to JSON file download.\n *\n * Uses ONLY data stored in the chronicle record - no external parameters.\n */\nexport function downloadChronicleExport(chronicle: ChronicleRecord): void {\n  const exportData = buildChronicleExport(chronicle);\n\n  // Create filename from chronicle title\n  const safeTitle = chronicle.title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `chronicle-export-${safeTitle}-${Date.now()}.json`;\n\n  // Create blob and download\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkAnnotationReviewExport", "name": "downloadBulkAnnotationReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Annotation Review Export\n// =============================================================================\n\nexport async function downloadBulkAnnotationReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n\n  const annotated = chronicles\n    .filter((c) => c.historianNotes && c.historianNotes.filter(isNoteActive).length > 0)\n    .sort((a, b) => (a.title || \"\").localeCompare(b.title || \"\"));\n\n  const rows = annotated.map((c) => {\n    const notes = (c.historianNotes || []).filter(isNoteActive);\n    return {\n      title: c.title || \"Untitled\",\n      format: c.format || \"story\",\n      narrativeStyleName: c.narrativeStyle?.name || c.narrativeStyleId || null,\n      assignedTone: c.assignedTone || null,\n      noteCount: notes.length,\n      annotations: notes.map((n) => ({\n        type: n.type,\n        display: n.display,\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      })),\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    totalAnnotations: rows.reduce((sum, r) => sum + r.noteCount, 0),\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-annotation-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkToneReviewExport", "name": "downloadBulkToneReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Tone Review Export\n// =============================================================================\n\nexport async function downloadBulkToneReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const corpusStrength = await computeCorpusFactStrength(simulationRunId);\n\n  const complete = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n\n  const rows = complete.map((c) => {\n    const wordCount = c.finalContent?.split(/\\s+/).length || c.wordCount || 0;\n    const noteRange = computeNoteRange(\"chronicle\", wordCount);\n\n    // Compute fact coverage guidance using the same logic as the annotation prompt\n    const guidance = c.factCoverageReport\n      ? buildFactCoverageGuidance(c.factCoverageReport, corpusStrength)\n      : null;\n\n    const maxRequired = noteRange.max <= 4 ? 1 : (guidance?.length ?? 0);\n    const required = guidance?.slice(0, maxRequired) ?? [];\n    const optional = guidance?.slice(maxRequired) ?? [];\n\n    return {\n      title: c.title || \"Untitled\",\n      summary: c.summary || null,\n      brief: c.perspectiveSynthesis?.brief || null,\n      wordCount,\n      noteRange,\n      assignedTone: c.assignedTone || null,\n      toneRanking: c.toneRanking\n        ? {\n            ranking: c.toneRanking.ranking,\n            rationales: c.toneRanking.rationales || { _legacy: c.toneRanking.rationale },\n          }\n        : null,\n      factCoverage:\n        c.factCoverageReport?.entries?.map((e) => ({\n          factId: e.factId,\n          rating: e.rating,\n          wasFaceted: e.wasFaceted,\n        })) || null,\n      annotationGuidance: {\n        required: required.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n        optional: optional.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n      },\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-tone-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildEraNarrativeExport", "name": "buildEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function buildEraNarrativeExport(record: EraNarrativeRecord): EraNarrativeExport {\n  const exportData: EraNarrativeExport = {\n    exportVersion: \"1.0\",\n    exportedAt: new Date().toISOString(),\n\n    narrative: {\n      narrativeId: record.narrativeId,\n      eraId: record.eraId,\n      eraName: record.eraName,\n      tone: record.tone,\n      ...(record.arcDirection ? { arcDirection: record.arcDirection } : {}),\n      status: record.status,\n      createdAt: new Date(record.createdAt).toISOString(),\n    },\n\n    sourceBriefs: record.prepBriefs.map((b) => ({\n      chronicleId: b.chronicleId,\n      chronicleTitle: b.chronicleTitle,\n      eraYear: b.eraYear,\n      ...(b.weight ? { weight: b.weight } : {}),\n      prep: b.prep,\n    })),\n\n    cost: {\n      totalInputTokens: record.totalInputTokens,\n      totalOutputTokens: record.totalOutputTokens,\n      totalActualCost: record.totalActualCost,\n    },\n  };\n\n  if (record.threadSynthesis) {\n    exportData.threadSynthesis = exportThreadSynthesis(record.threadSynthesis);\n  }\n\n  exportNarrativeContent(exportData, record);\n\n  return exportData;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "EraNarrativeExport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadEraNarrativeExport", "name": "downloadEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function downloadEraNarrativeExport(record: EraNarrativeRecord): void {\n  const exportData = buildEraNarrativeExport(record);\n\n  const safeTitle = (record.eraName || \"era-narrative\")\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `era-narrative-export-${safeTitle}-${Date.now()}.json`;\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "computeCorpusFactStrength"], "category": "internal"}, {"source": "./eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["PerspectiveSynthesisRecord", "ChronicleImageRefs", "FactCoverageReport"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["isNoteActive", "computeNoteRange"], "category": "internal"}, {"source": "./historianContextBuilders", "specifiers": ["buildFactCoverageGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicleTypes.ts::computeBackportProgress", "name": "computeBackportProgress", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleTypes.ts", "sourceCode": "/**\n * Compute backport progress for a chronicle.\n * Total = roleAssignments + lens + accepted tertiary.\n * Done = entities present in entityBackportStatus.\n */\nexport function computeBackportProgress(record: {\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}): { done: number; total: number } {\n  const eligibleIds = new Set<string>();\n  for (const r of record.roleAssignments || []) {\n    eligibleIds.add(r.entityId);\n  }\n  if (record.lens) {\n    eligibleIds.add(record.lens.entityId);\n  }\n  for (const t of record.tertiaryCast || []) {\n    if (t.accepted) {\n      eligibleIds.add(t.entityId);\n    }\n  }\n  const statusMap = record.entityBackportStatus || {};\n  let done = 0;\n  for (const id of eligibleIds) {\n    if (statusMap[id]) done++;\n  }\n  return { done, total: eligibleIds.size };\n}", "parameters": [{"name": "record", "type": "{\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}", "optional": false}], "returnType": "{ done: number; total: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}, {"source": "./enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote", "HistorianTone"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts::analyzeConstellation", "name": "analyzeConstellation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts", "sourceCode": "export function analyzeConstellation(input: ConstellationInput): EntityConstellation {\n  const { entities, relationships, events, focalEra } = input;\n\n  const { cultures, topCulture, cultureBalance } = analyzeCultures(entities);\n  const { kinds, topKind, kindFocus } = analyzeKinds(entities);\n  const { tagFrequency, prominentTags } = aggregateTags(entities);\n  const relationshipKinds = countRelationshipKinds(relationships);\n\n  const focalEraId = focalEra?.id || null;\n  const eraIds = new Set(events.map((e) => e.era).filter(Boolean));\n  const eraSpan: EraSpan = eraIds.size > 1 ? \"multiple\" : \"single\";\n\n  // ==========================================================================\n  // Spatial Analysis\n  // ==========================================================================\n\n  const coordinateCentroid = computeCentroid(entities);\n  const spatialSpread = computeSpatialSpread(entities);\n\n  // ==========================================================================\n  // Focus Summary\n  // ==========================================================================\n\n  const focusSummary = buildFocusSummary(\n    cultureBalance,\n    topCulture,\n    kindFocus,\n    prominentTags,\n    relationshipKinds\n  );\n\n  // ==========================================================================\n  // Return\n  // ==========================================================================\n\n  return {\n    cultures,\n    dominantCulture: cultureBalance !== \"mixed\" ? topCulture : null,\n    cultureBalance,\n    kinds,\n    dominantKind: topKind || null,\n    kindFocus,\n    tagFrequency,\n    prominentTags,\n    relationshipKinds,\n    focalEraId,\n    eraSpan,\n    coordinateCentroid,\n    spatialSpread,\n    focusSummary,\n  };\n}", "parameters": [{"name": "input", "type": "ConstellationInput", "optional": false}], "returnType": "EntityConstellation", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext", "EraContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTokens", "name": "estimateTokens", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate tokens from text (word count based)\n */\nexport function estimateTokens(text: string): number {\n  const words = text.trim().split(/\\s+/).filter(Boolean).length;\n  return Math.ceil(words * TOKENS_PER_WORD);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCost", "name": "estimateTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for a text enrichment task\n */\nexport function estimateTextCost(\n  prompt: string,\n  type: \"description\",\n  model: string\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = EXPECTED_OUTPUT_TOKENS[type] || 300;\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "type", "type": "\"description\"", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCostForCall", "name": "estimateTextCostForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "export function estimateTextCostForCall(\n  prompt: string,\n  callType: LLMCallType,\n  model: string,\n  outputTokensOverride?: number\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = resolveOutputTokensForCall(callType, outputTokensOverride);\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "outputTokensOverride", "type": "number", "optional": true}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateImageCost", "name": "estimateImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for an image generation task\n */\nexport function estimateImageCost(model: string, size: string, quality: string): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\") {\n    // GPT Image models use token-based pricing\n    const estimatedInputTokens = 300; // Typical prompt size\n    const estimatedOutputTokens =\n      rates.estimatedOutputTokens[quality] || rates.estimatedOutputTokens[\"auto\"] || 6500;\n\n    const inputCost = (estimatedInputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (estimatedOutputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else {\n    // DALL-E models use per-image pricing\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualTextCost", "name": "calculateActualTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost from API response usage\n */\nexport function calculateActualTextCost(\n  inputTokens: number,\n  outputTokens: number,\n  model: string\n): number {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n  return inputCost + outputCost;\n}", "parameters": [{"name": "inputTokens", "type": "number", "optional": false}, {"name": "outputTokens", "type": "number", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualImageCost", "name": "calculateActualImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost for image generation from API response usage\n * GPT Image models return token usage; DALL-E models use per-image pricing\n */\nexport function calculateActualImageCost(\n  model: string,\n  size: string,\n  quality: string,\n  usage?: { inputTokens: number; outputTokens: number }\n): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\" && usage) {\n    // GPT Image models: use actual token counts from API response\n    const inputCost = (usage.inputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (usage.outputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else if (rates.type === \"token-based\") {\n    // GPT Image models without usage data: fall back to estimate\n    return estimateImageCost(model, size, quality);\n  } else {\n    // DALL-E models: per-image pricing (no token usage)\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}, {"name": "usage", "type": "{ inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::createEmptyCostSummary", "name": "createEmptyCostSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Create empty cost summary\n */\nexport function createEmptyCostSummary(): CostSummary {\n  return {\n    totalEstimated: 0,\n    totalActual: 0,\n    textCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    imageCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    byModel: {},\n  };\n}", "parameters": [], "returnType": "CostSummary", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatCost", "name": "formatCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost for display\n */\nexport function formatCost(cost: number): string {\n  if (cost < 0.001) return \"<$0.001\";\n  if (cost < 0.01) return `$${cost.toFixed(4)}`;\n  if (cost < 1) return `$${cost.toFixed(3)}`;\n  return `$${cost.toFixed(2)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatEstimatedCost", "name": "formatEstimatedCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost with estimate indicator\n */\nexport function formatEstimatedCost(cost: number): string {\n  return `~${formatCost(cost)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getCoverImageConfig", "name": "getCoverImageConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getCoverImageConfig(narrativeStyleId: string): CoverImageConfig {\n  return COVER_IMAGE_CONFIG[narrativeStyleId] || DEFAULT_CONFIG;\n}", "parameters": [{"name": "narrativeStyleId", "type": "string", "optional": false}], "returnType": "CoverImageConfig", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getScenePromptTemplate", "name": "getScenePromptTemplate", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getScenePromptTemplate(id: string): ScenePromptTemplate {\n  return templateMap.get(id) || templateMap.get(\"montage\");\n}", "parameters": [{"name": "id", "type": "string", "optional": false}], "returnType": "ScenePromptTemplate", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::wordSimilarity", "name": "wordSimilarity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function wordSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/));\n  let intersection = 0;\n  for (const w of wordsA) if (wordsB.has(w)) intersection++;\n  const union = wordsA.size + wordsB.size - intersection;\n  return union === 0 ? 1 : intersection / union;\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::compressDescriptionHistory", "name": "compressDescriptionHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function compressDescriptionHistory(\n  history: DescriptionHistoryEntry[]\n): CompressedHistoryEntry[] {\n  if (history.length <= COMPRESSION_FLOOR) {\n    return history;\n  }\n\n  const result: CompressedHistoryEntry[] = [];\n  let currentGroup: DescriptionHistoryEntry[] = [history[0]];\n\n  for (let i = 1; i < history.length; i++) {\n    const anchor = currentGroup[0]; // compare to group anchor, not last entry\n    const curr = history[i];\n    const sameSource = anchor.source === curr.source;\n    const similar = wordSimilarity(anchor.description, curr.description) > SIMILARITY_THRESHOLD;\n\n    if (sameSource && similar) {\n      currentGroup.push(curr);\n    } else {\n      flushGroup(currentGroup, result);\n      currentGroup = [curr];\n    }\n  }\n  flushGroup(currentGroup, result);\n\n  return result;\n}", "parameters": [{"name": "history", "type": "DescriptionHistoryEntry[]", "optional": false}], "returnType": "CompressedHistoryEntry[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::getEnrichmentStatus", "name": "getEnrichmentStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Get enrichment status for an entity and type\n */\nexport function getEnrichmentStatus(\n  entity: { id: string; summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  queueItems: QueueItem[]\n): EnrichmentStatus {\n  // Check queue first\n  const queueItem = queueItems.find((item) => item.entityId === entity.id && item.type === type);\n  if (queueItem) {\n    if (queueItem.status === \"running\") return \"running\";\n    if (queueItem.status === \"queued\") return \"queued\";\n    if (queueItem.status === \"error\") return \"error\";\n  }\n\n  // Check entity fields directly (summary/description are on entity, not nested)\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment is complete when entity has summary and description\n    return entity.summary && entity.description ? \"complete\" : \"missing\";\n  }\n  if (type === \"image\" && enrichment?.image?.imageId) return \"complete\";\n  if (type === \"entityChronicle\" && enrichment?.entityChronicle?.chronicleId) return \"complete\";\n\n  return \"missing\";\n}", "parameters": [{"name": "entity", "type": "{ id: string; summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "queueItems", "type": "QueueItem[]", "optional": false}], "returnType": "EnrichmentStatus", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleFormat", "ChronicleGenerationContext", "ChronicleImageRefs", "EraTemporalInfo"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallSettings"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::needsEnrichment", "name": "needsEnrichment", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Check if entity needs enrichment of a given type\n */\nexport function needsEnrichment(\n  entity: { summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType\n): boolean {\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment needed when entity lacks summary or description\n    return !(entity.summary && entity.description);\n  }\n  if (type === \"image\") return !enrichment?.image?.imageId;\n  if (type === \"entityChronicle\") return !enrichment?.entityChronicle?.chronicleId;\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "{ summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleFormat", "ChronicleGenerationContext", "ChronicleImageRefs", "EraTemporalInfo"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallSettings"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::applyEnrichmentResult", "name": "applyEnrichmentResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Apply enrichment result to entity\n *\n * Returns both the enrichment metadata and entity field updates.\n * Callers should apply both: { ...entity, ...output.entityFields, enrichment: output.enrichment }\n *\n * @param lockedSummary - If true, skip setting the summary field (preserves user-defined summary)\n */\nexport function applyEnrichmentResult(\n  entity: { enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  result: EnrichmentResult,\n  lockedSummary?: boolean\n): ApplyEnrichmentOutput {\n  const existing = entity.enrichment || {};\n\n  if (type === \"description\" && result.description) {\n    // For lockedSummary entities, skip the summary (user-defined takes precedence)\n    // For normal entities, require both summary and description\n    if (!lockedSummary && !result.summary) {\n      return { enrichment: existing };\n    }\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          aliases: result.aliases || [],\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          debug: result.debug,\n          chainDebug: result.chainDebug,\n        },\n      },\n      // Entity field updates - summary/description go directly on entity\n      summary: lockedSummary ? undefined : result.summary,\n      description: result.description,\n    };\n  }\n\n  if (type === \"visualThesis\" && result.visualThesis) {\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          ...(existing.text || { aliases: [], visualTraits: [], generatedAt: 0, model: \"\" }),\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || existing.text?.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          chainDebug: result.chainDebug,\n        },\n      },\n    };\n  }\n\n  if (type === \"image\" && result.imageId) {\n    return {\n      enrichment: {\n        ...existing,\n        image: {\n          imageId: result.imageId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          revisedPrompt: result.revisedPrompt,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          // Image dimensions for aspect-aware display\n          width: result.width,\n          height: result.height,\n          aspect: result.aspect,\n        },\n      },\n    };\n  }\n\n  if (type === \"entityChronicle\" && result.chronicleId) {\n    return {\n      enrichment: {\n        ...existing,\n        entityChronicle: {\n          chronicleId: result.chronicleId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n        },\n      },\n    };\n  }\n\n  return { enrichment: existing };\n}", "parameters": [{"name": "entity", "type": "{ enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "result", "type": "EnrichmentResult", "optional": false}, {"name": "lockedSummary", "type": "boolean", "optional": true}], "returnType": "ApplyEnrichmentOutput", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleFormat", "ChronicleGenerationContext", "ChronicleImageRefs", "EraTemporalInfo"], "category": "internal"}, {"source": "./historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallSettings"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::scanForReferences", "name": "scanForReferences", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Scan all entities and chronicles for references to the given entity name.\n * Also surfaces all foreign-key references to the entity ID (relationships,\n * chronicle selectedEntityIds, etc.) so the user can verify completeness.\n */\nexport function scanForReferences(\n  entityId: string,\n  oldName: string,\n  entities: ScanEntity[],\n  chronicles: ChronicleRecord[],\n  relationships?: ScanRelationship[],\n  narrativeEvents?: ScanNarrativeEvent[]\n): RenameScanResult {\n  matchIdCounter = 0;\n\n  const ctx: ScanContext = {\n    entityId,\n    fullSlug: normalizeSlug(oldName),\n    partialSlugs: generatePartials(oldName),\n    matches: [],\n    coveredPositions: new Map(),\n    currentTier: \"general\",\n  };\n\n  const fullAndPartial: ScanFn = (st, si, sn, f, t) => scanTextField(ctx, st, si, sn, f, t);\n  const fullOnly: ScanFn = (st, si, sn, f, t) => scanTextFieldFullNameOnly(ctx, st, si, sn, f, t);\n\n  const entityById = new Map(entities.map((e) => [e.id, e]));\n\n  // Build related entity set from relationships\n  const relatedEntityIds = new Set<string>();\n  if (relationships) {\n    for (const rel of relationships) {\n      if (rel.src === entityId) relatedEntityIds.add(rel.dst);\n      if (rel.dst === entityId) relatedEntityIds.add(rel.src);\n    }\n  }\n\n  // Build cast chronicle set\n  const castChronicleIds = new Set<string>();\n  for (const chronicle of chronicles) {\n    if (chronicle.selectedEntityIds?.includes(entityId)) {\n      castChronicleIds.add(chronicle.chronicleId);\n    }\n  }\n\n  // 1. SELF\n  ctx.currentTier = \"self\";\n  const selfEntity = entityById.get(entityId);\n  if (selfEntity) scanEntityTextFields(selfEntity, ctx, fullAndPartial);\n\n  // 2. RELATED\n  ctx.currentTier = \"related\";\n  for (const relEntityId of relatedEntityIds) {\n    const relEntity = entityById.get(relEntityId);\n    if (relEntity) scanEntityTextFields(relEntity, ctx, fullAndPartial);\n  }\n\n  // 3. CAST CHRONICLES\n  ctx.currentTier = \"cast\";\n  for (const chronicle of chronicles) {\n    if (!castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullAndPartial);\n  }\n\n  // 4. GENERAL SWEEP\n  ctx.currentTier = \"general\";\n  const scannedEntityIds = new Set([entityId, ...relatedEntityIds]);\n  for (const entity of entities) {\n    if (scannedEntityIds.has(entity.id)) continue;\n    scanEntityTextFields(entity, ctx, fullOnly);\n  }\n\n  for (const chronicle of chronicles) {\n    if (castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullOnly);\n  }\n\n  // 5. NARRATIVE EVENTS\n  if (narrativeEvents) {\n    scanNarrativeEvents(narrativeEvents, entityId, ctx);\n  }\n\n  // FK references\n  scanFkReferences(entityId, entityById, relationships, chronicles, ctx);\n\n  return { entityId, oldName, matches: ctx.matches };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "entities", "type": "ScanEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "relationships", "type": "ScanRelationship[]", "optional": true}, {"name": "narrativeEvents", "type": "ScanNarrativeEvent[]", "optional": true}], "returnType": "RenameScanResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::adjustReplacementForGrammar", "name": "adjustReplacementForGrammar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function adjustReplacementForGrammar(\n  contextBefore: string,\n  contextAfter: string,\n  matchPosition: number,\n  matchedText: string,\n  replacement: string\n): AdjustedReplacement {\n  const state: GrammarState = {\n    position: matchPosition,\n    originalLength: matchedText.length,\n    replacement,\n  };\n\n  const rawBefore = rawCtxBefore(contextBefore);\n  const rawAfter = rawCtxAfter(contextAfter);\n  const sentenceStart = isAtSentenceStart(rawBefore);\n  const casePattern = detectCasePattern(matchedText);\n\n  applyCaseEcho(state, casePattern);\n\n  const precedingArticle = findPrecedingArticle(rawBefore);\n  const replacementStartsWithThe = /^the\\s/i.test(state.replacement);\n  const articleAbsorbed = applyArticleDeduplication(state, matchPosition, matchedText.length, precedingArticle);\n\n  if (!sentenceStart && casePattern !== \"allCaps\" && !articleAbsorbed) {\n    applyMidSentenceArticleLowercasing(state);\n  }\n\n  if (\n    precedingArticle &&\n    !replacementStartsWithThe &&\n    !articleAbsorbed &&\n    (precedingArticle.normalized === \"a\" || precedingArticle.normalized === \"an\")\n  ) {\n    applyAAnAgreement(state, matchPosition, matchedText.length, precedingArticle);\n  }\n\n  applyPossessiveTransfer(state, rawAfter);\n\n  return { position: state.position, originalLength: state.originalLength, replacement: state.replacement };\n}", "parameters": [{"name": "contextBefore", "type": "string", "optional": false}, {"name": "contextAfter", "type": "string", "optional": false}, {"name": "matchPosition", "type": "number", "optional": false}, {"name": "matchedText", "type": "string", "optional": false}, {"name": "replacement", "type": "string", "optional": false}], "returnType": "AdjustedReplacement", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyReplacements", "name": "applyReplacements", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply a set of replacements to a text string. Replacements must not overlap\n * and are applied in reverse order to preserve positions.\n */\nexport function applyReplacements(text: string, replacements: FieldReplacement[]): string {\n  // Sort by position descending so earlier positions aren't shifted\n  const sorted = [...replacements].sort((a, b) => b.position - a.position);\n  let result = text;\n  for (const r of sorted) {\n    result =\n      result.slice(0, r.position) + r.replacement + result.slice(r.position + r.originalLength);\n  }\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "replacements", "type": "FieldReplacement[]", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::buildRenamePatches", "name": "buildRenamePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function buildRenamePatches(\n  scanResult: RenameScanResult,\n  newName: string,\n  decisions: MatchDecision[]\n): RenamePatches {\n  const decisionMap = new Map(decisions.map((d) => [d.matchId, d]));\n\n  const entityPatchMap = new Map<string, Record<string, any>>();\n  const chroniclePatchMap = new Map<string, Record<string, any>>();\n  const eventPatchMap = new Map<string, Record<string, any>>();\n  const chronicleMetaUpdates = new Map<string, Partial<ChronicleRecord>>();\n  const eventMetaUpdates = new Map<string, Record<string, string>>();\n\n  for (const match of scanResult.matches) {\n    const decision = decisionMap.get(match.id);\n    if (!decision || decision.action === \"reject\") continue;\n\n    const replacementText = decision.action === \"edit\" ? (decision.editText ?? newName) : newName;\n\n    if (match.matchType === \"metadata\") {\n      if (match.sourceType === \"event\") {\n        const meta = eventMetaUpdates.get(match.sourceId) || {};\n        meta[match.field] = replacementText;\n        eventMetaUpdates.set(match.sourceId, meta);\n      } else {\n        const meta = chronicleMetaUpdates.get(match.sourceId) || {};\n        processChronicleMetadataMatch(meta, match.field, replacementText);\n        chronicleMetaUpdates.set(match.sourceId, meta);\n      }\n    } else {\n      const replacement = computeReplacement(match, decision, newName);\n\n      if (match.sourceType === \"entity\") {\n        appendReplacementToMap(entityPatchMap, match.sourceId, match.field, replacement, true);\n      } else if (match.sourceType === \"chronicle\") {\n        appendReplacementToMap(chroniclePatchMap, match.sourceId, match.field, replacement, false);\n      } else if (match.sourceType === \"event\") {\n        appendReplacementToMap(eventPatchMap, match.sourceId, match.field, replacement, true);\n      }\n    }\n  }\n\n  // Merge metadata updates into chronicle patches\n  for (const [chronicleId, meta] of chronicleMetaUpdates) {\n    const existing = chroniclePatchMap.get(chronicleId) || {};\n    Object.assign(existing, meta);\n    chroniclePatchMap.set(chronicleId, existing);\n  }\n\n  for (const [eventId, meta] of eventMetaUpdates) {\n    const existing = eventPatchMap.get(eventId) || {};\n    Object.assign(existing, meta);\n    eventPatchMap.set(eventId, existing);\n  }\n\n  return {\n    entityPatches: [...entityPatchMap].map(([entityId, changes]) => ({ entityId, changes })),\n    chroniclePatches: [...chroniclePatchMap].map(([chronicleId, fieldUpdates]) => ({\n      chronicleId,\n      fieldUpdates,\n    })),\n    eventPatches: [...eventPatchMap].map(([eventId, changes]) => ({ eventId, changes })),\n  };\n}", "parameters": [{"name": "scanResult", "type": "RenameScanResult", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "decisions", "type": "MatchDecision[]", "optional": false}], "returnType": "RenamePatches", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyEntityPatches", "name": "applyEntityPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Apply helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Apply entity patches to an entity array. Returns a new array with patches applied.\n * Handles summary, description, and enrichment.descriptionHistory text replacements.\n */\nexport function applyEntityPatches<T extends ScanEntity>(\n  entities: T[],\n  patches: EntityPatch[],\n  targetEntityId: string | null,\n  newName: string\n): T[] {\n  const patchMap = new Map(patches.map((p) => [p.entityId, p]));\n\n  return entities.map((entity) => {\n    // The target entity always gets its name updated, even without a text patch\n    const isTarget = entity.id === targetEntityId;\n    const patch = patchMap.get(entity.id);\n    if (!patch && !isTarget) return entity;\n\n    const updated = { ...entity };\n\n    if (isTarget) {\n      updated.name = newName;\n      // Store the entity ID as a slug alias so deep links using the old\n      // ID-based slug still resolve after the name changes. The chronicler's\n      // bySlug map indexes these for URL resolution.\n      const existingAliases = (entity as any).enrichment?.slugAliases || [];\n      if (!existingAliases.includes(entity.id)) {\n        if (!updated.enrichment) updated.enrichment = { ...(entity as any).enrichment };\n        (updated as any).enrichment.slugAliases = [...existingAliases, entity.id];\n      }\n    }\n\n    if (!patch) return updated;\n\n    // Apply text replacements\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (!key.startsWith(\"__replacements_\")) continue;\n      const field = key.replace(\"__replacements_\", \"\");\n      const replacements: FieldReplacement[] = JSON.parse(value);\n\n      if (field === \"summary\" || field === \"description\" || field === \"narrativeHint\") {\n        const originalText = (entity as any)[field];\n        if (typeof originalText === \"string\") {\n          (updated as any)[field] = applyReplacements(originalText, replacements);\n        }\n      } else if (field.startsWith(\"enrichment.descriptionHistory[\")) {\n        // Parse index from: enrichment.descriptionHistory[N].description\n        const idxMatch = field.match(/\\[(\\d+)\\]/);\n        if (idxMatch && entity.enrichment?.descriptionHistory) {\n          const idx = parseInt(idxMatch[1], 10);\n          // Shallow-copy enrichment chain on first write\n          if (!updated.enrichment || updated.enrichment === entity.enrichment) {\n            updated.enrichment = { ...entity.enrichment };\n          }\n          if (\n            !updated.enrichment.descriptionHistory ||\n            updated.enrichment.descriptionHistory === entity.enrichment.descriptionHistory\n          ) {\n            updated.enrichment.descriptionHistory = [...entity.enrichment.descriptionHistory];\n          }\n          const entry = updated.enrichment.descriptionHistory[idx];\n          if (entry) {\n            updated.enrichment.descriptionHistory[idx] = {\n              ...entry,\n              description: applyReplacements(entry.description, replacements),\n            };\n          }\n        }\n      }\n    }\n\n    return updated;\n  });\n}", "parameters": [{"name": "entities", "type": "T[]", "optional": false}, {"name": "patches", "type": "EntityPatch[]", "optional": false}, {"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "T[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyChroniclePatches", "name": "applyChroniclePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply chronicle patches. Reads each chronicle from IDB, applies changes, writes back.\n * Returns the number of successfully updated chronicles.\n */\nexport async function applyChroniclePatches(\n  patches: ChroniclePatch[],\n  getChronicle: (id: string) => Promise<ChronicleRecord | undefined>,\n  putChronicle: (record: ChronicleRecord) => Promise<void>\n): Promise<number> {\n  let successCount = 0;\n\n  for (const patch of patches) {\n    try {\n      const chronicle = await getChronicle(patch.chronicleId);\n      if (!chronicle) {\n        console.warn(`[EntityRename] Chronicle not found: ${patch.chronicleId}`);\n        continue;\n      }\n\n      const updated = { ...chronicle };\n\n      // Apply metadata updates\n      if ((patch.fieldUpdates as any)._roleAssignmentUpdates) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._roleAssignmentUpdates;\n        updated.roleAssignments = [...chronicle.roleAssignments];\n        for (const u of updates) {\n          if (updated.roleAssignments[u.index]) {\n            updated.roleAssignments[u.index] = {\n              ...updated.roleAssignments[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      if ((patch.fieldUpdates as any)._lensNameUpdate && chronicle.lens) {\n        updated.lens = {\n          ...chronicle.lens,\n          entityName: (patch.fieldUpdates as any)._lensNameUpdate,\n        };\n      }\n\n      if (\n        (patch.fieldUpdates as any)._directiveUpdates &&\n        chronicle.generationContext?.entityDirectives\n      ) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._directiveUpdates;\n        updated.generationContext = {\n          ...chronicle.generationContext,\n          entityDirectives: [...chronicle.generationContext.entityDirectives],\n        };\n        for (const u of updates) {\n          if (updated.generationContext.entityDirectives[u.index]) {\n            updated.generationContext.entityDirectives[u.index] = {\n              ...updated.generationContext.entityDirectives[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      // Apply text field replacements\n      for (const [key, value] of Object.entries(patch.fieldUpdates)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements = value as FieldReplacement[];\n\n        if (field.startsWith(\"generationHistory.\")) {\n          // Handle generation history versions\n          const versionId = field.replace(\"generationHistory.\", \"\");\n          if (updated.generationHistory) {\n            updated.generationHistory = updated.generationHistory.map((v) => {\n              if (v.versionId === versionId) {\n                return { ...v, content: applyReplacements(v.content, replacements) };\n              }\n              return v;\n            });\n          }\n        } else if (field === \"assembledContent\" && typeof updated.assembledContent === \"string\") {\n          updated.assembledContent = applyReplacements(updated.assembledContent, replacements);\n        } else if (field === \"finalContent\" && typeof updated.finalContent === \"string\") {\n          updated.finalContent = applyReplacements(updated.finalContent, replacements);\n        } else if (field === \"summary\" && typeof updated.summary === \"string\") {\n          updated.summary = applyReplacements(updated.summary, replacements);\n        }\n      }\n\n      updated.updatedAt = Date.now();\n      await putChronicle(updated);\n      successCount++;\n    } catch (err) {\n      console.error(`[EntityRename] Failed to update chronicle ${patch.chronicleId}:`, err);\n    }\n  }\n\n  return successCount;\n}", "parameters": [{"name": "patches", "type": "ChroniclePatch[]", "optional": false}, {"name": "getChronicle", "type": "(id: string) => Promise<ChronicleRecord | undefined>", "optional": false}, {"name": "putChronicle", "type": "(record: ChronicleRecord) => Promise<void>", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyNarrativeEventPatches", "name": "applyNarrativeEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply narrative event patches to an event array. Returns a new array with patches applied.\n * Handles both structured name fields (metadata) and text replacements.\n */\nexport function applyNarrativeEventPatches<T extends ScanNarrativeEvent>(\n  events: T[],\n  patches: EventPatch[]\n): T[] {\n  if (patches.length === 0) return events;\n\n  const patchMap = new Map(patches.map((p) => [p.eventId, p]));\n\n  return events.map((event) => {\n    const patch = patchMap.get(event.id);\n    if (!patch) return event;\n\n    const updated: any = { ...event };\n\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (key.startsWith(\"__replacements_\")) {\n        // Text field replacements\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n\n        if (field === \"description\" && typeof updated.description === \"string\") {\n          updated.description = applyReplacements(updated.description, replacements);\n        } else if (field === \"action\" && typeof updated.action === \"string\") {\n          updated.action = applyReplacements(updated.action, replacements);\n        } else if (field.startsWith(\"participantEffects[\")) {\n          // Parse: participantEffects[N].effects[M].description\n          const idxMatch = field.match(\n            /participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.description/\n          );\n          if (idxMatch) {\n            const pi = parseInt(idxMatch[1], 10);\n            const ei = parseInt(idxMatch[2], 10);\n            if (\n              !updated.participantEffects ||\n              updated.participantEffects === event.participantEffects\n            ) {\n              updated.participantEffects = [...event.participantEffects];\n            }\n            if (updated.participantEffects[pi]) {\n              const pe = { ...updated.participantEffects[pi] };\n              if (pe.effects === event.participantEffects[pi].effects) {\n                pe.effects = [...event.participantEffects[pi].effects];\n              }\n              if (pe.effects[ei]) {\n                pe.effects[ei] = {\n                  ...pe.effects[ei],\n                  description: applyReplacements(pe.effects[ei].description, replacements),\n                };\n              }\n              updated.participantEffects[pi] = pe;\n            }\n          }\n        }\n      } else if (key === \"subject.name\") {\n        // Structured name field: subject.name\n        updated.subject = { ...event.subject, name: value };\n      } else if (key.startsWith(\"participantEffects[\")) {\n        // Structured name: participantEffects[N].entity.name or participantEffects[N].effects[M].relatedEntity.name\n        if (\n          !updated.participantEffects ||\n          updated.participantEffects === event.participantEffects\n        ) {\n          updated.participantEffects = [...event.participantEffects];\n        }\n\n        const entityNameMatch = key.match(/^participantEffects\\[(\\d+)\\]\\.entity\\.name$/);\n        if (entityNameMatch) {\n          const pi = parseInt(entityNameMatch[1], 10);\n          if (updated.participantEffects[pi]) {\n            updated.participantEffects[pi] = {\n              ...updated.participantEffects[pi],\n              entity: { ...updated.participantEffects[pi].entity, name: value },\n            };\n          }\n        }\n\n        const relatedMatch = key.match(\n          /^participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.relatedEntity\\.name$/\n        );\n        if (relatedMatch) {\n          const pi = parseInt(relatedMatch[1], 10);\n          const ei = parseInt(relatedMatch[2], 10);\n          if (updated.participantEffects[pi]) {\n            const pe = { ...updated.participantEffects[pi] };\n            if (pe.effects === event.participantEffects[pi]?.effects) {\n              pe.effects = [...event.participantEffects[pi].effects];\n            }\n            if (pe.effects[ei]?.relatedEntity) {\n              pe.effects[ei] = {\n                ...pe.effects[ei],\n                relatedEntity: { ...pe.effects[ei].relatedEntity!, name: value },\n              };\n            }\n            updated.participantEffects[pi] = pe;\n          }\n        }\n      }\n    }\n\n    return updated as T;\n  });\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "patches", "type": "EventPatch[]", "optional": false}], "returnType": "T[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::patchNarrativeHistory", "name": "patchNarrativeHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Brute-force patch of all narrative events for a single entity rename.\n *\n * Unlike the scan-based approach (which uses position-based replacements and\n * per-match decisions), this function does a simple find-and-replace across\n * ALL name fields and text fields in every event where the entity appears.\n *\n * Use this to repair data that was missed by a previous rename, or as a\n * one-shot fix when you don't need per-match granularity.\n *\n * @returns { events: patched array, patchCount: number of events modified }\n */\nexport function patchNarrativeHistory<T extends ScanNarrativeEvent>(\n  events: T[],\n  entityId: string,\n  oldName: string,\n  newName: string\n): { events: T[]; patchCount: number } {\n  let patchCount = 0;\n\n  const patched = events.map((event) => {\n    // Quick check: is this entity involved at all?\n    const isSubject = event.subject.id === entityId;\n    const participantIdx = event.participantEffects.findIndex((pe) => pe.entity.id === entityId);\n    // Also check if old name appears anywhere in the event text\n    const hasTextMatch =\n      event.description.toLowerCase().includes(oldName.toLowerCase()) ||\n      event.action.toLowerCase().includes(oldName.toLowerCase());\n\n    const hasRelatedRef = event.participantEffects.some((pe) =>\n      pe.effects.some((eff) => eff.relatedEntity?.id === entityId)\n    );\n\n    if (!isSubject && participantIdx === -1 && !hasTextMatch && !hasRelatedRef) {\n      return event;\n    }\n\n    let didChange = false;\n    const updated: any = { ...event };\n\n    // Patch subject.name\n    if (isSubject && event.subject.name !== newName) {\n      updated.subject = { ...event.subject, name: newName };\n      didChange = true;\n    }\n\n    // Patch participantEffects\n    const newPE = [...event.participantEffects];\n    for (let pi = 0; pi < newPE.length; pi++) {\n      const pe = newPE[pi];\n      let peChanged = false;\n      let updatedPE: any = pe;\n\n      // Participant entity.name\n      if (pe.entity.id === entityId && pe.entity.name !== newName) {\n        updatedPE = { ...pe, entity: { ...pe.entity, name: newName } };\n        peChanged = true;\n      }\n\n      // Effects\n      const newEffects = [...(updatedPE.effects || pe.effects)];\n      for (let ei = 0; ei < newEffects.length; ei++) {\n        const eff = newEffects[ei];\n        let effChanged = false;\n        let updatedEff: any = eff;\n\n        // relatedEntity.name\n        if (eff.relatedEntity?.id === entityId && eff.relatedEntity.name !== newName) {\n          updatedEff = { ...eff, relatedEntity: { ...eff.relatedEntity, name: newName } };\n          effChanged = true;\n        }\n\n        // effect.description (free text)\n        const patchedDesc = replaceAllCaseInsensitive(updatedEff.description, oldName, newName);\n        if (patchedDesc !== updatedEff.description) {\n          updatedEff = { ...(effChanged ? updatedEff : eff), description: patchedDesc };\n          effChanged = true;\n        }\n\n        if (effChanged) {\n          newEffects[ei] = updatedEff;\n          peChanged = true;\n        }\n      }\n\n      if (peChanged) {\n        updatedPE = { ...(updatedPE === pe ? pe : updatedPE), effects: newEffects };\n        newPE[pi] = updatedPE;\n        didChange = true;\n      }\n    }\n\n    if (didChange) {\n      updated.participantEffects = newPE;\n    }\n\n    // Patch top-level text fields\n    const patchedDesc = replaceAllCaseInsensitive(\n      updated.description || event.description,\n      oldName,\n      newName\n    );\n    if (patchedDesc !== (updated.description || event.description)) {\n      updated.description = patchedDesc;\n      didChange = true;\n    }\n\n    const patchedAction = replaceAllCaseInsensitive(\n      updated.action || event.action,\n      oldName,\n      newName\n    );\n    if (patchedAction !== (updated.action || event.action)) {\n      updated.action = patchedAction;\n      didChange = true;\n    }\n\n    if (didChange) {\n      patchCount++;\n      return updated as T;\n    }\n    return event;\n  });\n\n  return { events: patched, patchCount };\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "{ events: T[]; patchCount: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::resolveAnchorPhrase", "name": "resolveAnchorPhrase", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "export function resolveAnchorPhrase(anchorPhrase: string, text: string): FuzzyAnchorResult | null {\n  if (!anchorPhrase || !text) return null;\n\n  const exact = tryExactMatch(anchorPhrase, text);\n  if (exact) return exact;\n\n  const phraseContentWords = contentWords(anchorPhrase);\n  if (phraseContentWords.length === 0) return null;\n\n  const phraseWordSet = new Set(phraseContentWords);\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  const anchorWordCount = anchorPhrase.split(/\\s+/).length;\n  const halfWindow = Math.floor(Math.max(anchorWordCount, 4) / 2);\n\n  const { bestScore, bestCenter } = findBestCenter(words, phraseWordSet, halfWindow);\n\n  if (bestScore < Math.max(1, Math.ceil(phraseContentWords.length * 0.4))) return null;\n\n  const spanStart = Math.max(0, bestCenter - halfWindow);\n  const spanEnd = Math.min(words.length - 1, bestCenter + halfWindow);\n  const charStart = words[spanStart].start;\n  const charEnd = words[spanEnd].end;\n\n  let candidate = text.slice(charStart, charEnd);\n  const centerCharStart = words[bestCenter].start;\n  const centerCharEnd = words[bestCenter].end;\n\n  candidate = snapToSentence(text, candidate, charStart, charEnd, centerCharStart, centerCharEnd);\n  candidate = ensureUnique(text, candidate, centerCharStart, anchorWordCount);\n\n  if (!candidate || candidate.length < 3) return null;\n\n  const finalIdx = text.indexOf(candidate);\n  if (finalIdx < 0) return null;\n\n  return { phrase: candidate, index: finalIdx, method: \"fuzzy\" };\n}", "parameters": [{"name": "anchorPhrase", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "FuzzyAnchorResult | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::extractWordsAroundIndex", "name": "extractWordsAroundIndex", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "/**\n * Extract ~wordCount words centered around a character index, snapped to word\n * boundaries. Used as a proportional-index fallback when fuzzy anchor matching\n * fails after a copy edit.\n */\nexport function extractWordsAroundIndex(\n  text: string,\n  index: number,\n  wordCount: number\n): string | null {\n  if (!text || index < 0 || index >= text.length) return null;\n\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  // Find the word closest to the target index\n  let centerIdx = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].start <= index && words[i].end >= index) {\n      centerIdx = i;\n      break;\n    }\n    if (words[i].start > index) {\n      centerIdx = Math.max(0, i - 1);\n      break;\n    }\n    centerIdx = i; // last word if index is past end\n  }\n\n  const half = Math.floor(wordCount / 2);\n  const start = Math.max(0, centerIdx - half);\n  const end = Math.min(words.length - 1, start + wordCount - 1);\n  const candidate = text.slice(words[start].start, words[end].end);\n\n  return candidate && candidate.length >= 3 ? candidate : null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "string | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::collectPreviousNotes", "name": "collectPreviousNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function collectPreviousNotes(\n  options: {\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  } = {}\n): Promise<PreviousNoteSummary[]> {\n  const { maxPerTarget, relatedRatio } = HISTORIAN_SAMPLING;\n  const maxTotal = options.maxOverride ?? HISTORIAN_SAMPLING.maxTotal;\n  if (maxTotal <= 0) return [];\n  const relatedEntityIds = new Set(options.relatedEntityIds || []);\n  const relatedChronicleIds = new Set(options.relatedChronicleIds || []);\n  const { simulationRunId } = useEntityStore.getState();\n\n  const byTarget = new Map<string, NoteEntry[]>();\n\n  const addNotesForTarget = (\n    targetKey: string,\n    targetMeta: { type: string; id: string; name: string },\n    notes: Array<{ noteId?: string; anchorPhrase: string; text: string; type: string }>\n  ) => {\n    if (!notes.length) return;\n    const mapped: NoteEntry[] = notes.map((note, index) => ({\n      noteKey: note.noteId || `${targetKey}:${index}`,\n      targetKey,\n      targetType: targetMeta.type,\n      targetId: targetMeta.id,\n      targetName: targetMeta.name,\n      anchorPhrase: note.anchorPhrase,\n      text: note.text,\n      type: note.type,\n    }));\n    byTarget.set(targetKey, mapped);\n  };\n\n  // Entity notes\n  if (simulationRunId) {\n    const allEntities = await entityRepo.getEntitiesForRun(simulationRunId);\n    for (const entity of allEntities) {\n      const notes = (entity.enrichment?.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `entity:${entity.id}`,\n        {\n          type: \"entity\",\n          id: entity.id,\n          name: entity.name,\n        },\n        notes\n      );\n    }\n  }\n\n  // Chronicle notes\n  if (simulationRunId) {\n    const chronicleRecords = await getChroniclesForSimulation(simulationRunId);\n    for (const chronicle of chronicleRecords) {\n      const notes = (chronicle.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `chronicle:${chronicle.chronicleId}`,\n        {\n          type: \"chronicle\",\n          id: chronicle.chronicleId,\n          name: chronicle.title || chronicle.chronicleId,\n        },\n        notes\n      );\n    }\n  }\n\n  // Cap each target\n  const cappedNotes: NoteEntry[] = [];\n  for (const notes of byTarget.values()) {\n    const selected =\n      notes.length > maxPerTarget ? takeRandomSample(notes, maxPerTarget) : notes.slice();\n    cappedNotes.push(...selected);\n  }\n\n  if (cappedNotes.length === 0) return [];\n\n  const total = Math.min(maxTotal, cappedNotes.length);\n  const relatedNotes = cappedNotes.filter((note) => {\n    if (note.targetType === \"entity\") return relatedEntityIds.has(note.targetId);\n    if (note.targetType === \"chronicle\") return relatedChronicleIds.has(note.targetId);\n    return false;\n  });\n\n  const relatedQuota = Math.min(relatedNotes.length, Math.round(total * relatedRatio));\n  const relatedSample = takeRandomSample(relatedNotes, relatedQuota);\n  const relatedKeys = new Set(relatedSample.map((note) => note.noteKey));\n  const remainingPool = cappedNotes.filter((note) => !relatedKeys.has(note.noteKey));\n  const remainingSample = takeRandomSample(remainingPool, total - relatedSample.length);\n\n  const finalSample = [...relatedSample, ...remainingSample];\n  shuffleInPlace(finalSample);\n\n  return finalSample.map((note) => ({\n    targetName: note.targetName,\n    anchorPhrase: note.anchorPhrase,\n    text: note.text,\n    type: note.type,\n  }));\n}", "parameters": [{"name": "options", "type": "{\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  }", "optional": true}], "returnType": "Promise<PreviousNoteSummary[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianEditionContext", "name": "buildHistorianEditionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "// ============================================================================\n// Context builders\n// ============================================================================\n\n/**\n * Build the full context for a historian edition (description rewrite) session.\n * Returns null if preconditions aren't met (missing config, entity, etc.).\n */\nexport async function buildHistorianEditionContext(\n  entityId: string,\n  tone?: string,\n  reEdition?: boolean\n): Promise<HistorianEditionConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  // If prior historian editions exist (active or legacy), use the pre-historian baseline\n  // as the input description instead of entity.description (which may be an inflated historian\n  // output). The first historian-edition or legacy-copy-edit entry is always the pre-historian\n  // text that was replaced by the first edition. Filter edition entries from the archive so\n  // the LLM works from the original source material, not prior historian rewrites.\n  const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n  let description = entity.description;\n  let filteredHistory = entity.enrichment?.descriptionHistory || [];\n  const firstEdition = filteredHistory.find((h: { source?: string }) =>\n    editionSources.has(h.source || \"\")\n  );\n  if (firstEdition) {\n    description = firstEdition.description;\n    filteredHistory = filteredHistory.filter(\n      (h: { source?: string }) => !editionSources.has(h.source || \"\")\n    );\n  } else if (reEdition) {\n    return null; // re-edition requested but no prior edition exists\n  }\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Gather chronicle summaries from backrefs\n  const chronicleSummaries: Array<{\n    chronicleId: string;\n    title: string;\n    format: string;\n    summary: string;\n  }> = [];\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  for (const ref of backrefs) {\n    if (!ref.chronicleId) continue;\n    try {\n      const chronicle = await getChronicle(ref.chronicleId);\n      if (chronicle && chronicle.title) {\n        chronicleSummaries.push({\n          chronicleId: chronicle.chronicleId,\n          title: chronicle.title,\n          format: chronicle.format || \"\",\n          summary: chronicle.summary || chronicle.finalContent?.slice(0, 500) || \"\",\n        });\n      }\n    } catch {\n      // Skip if chronicle not found\n    }\n  }\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    description,\n    summary: entity.summary || \"\",\n    descriptionHistory: filteredHistory,\n    chronicleSummaries,\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    previousNotes,\n    historianConfig,\n    tone: (tone || \"scholarly\") as HistorianEditionConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "reEdition", "type": "boolean", "optional": true}], "returnType": "Promise<HistorianEditionConfig | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianReviewContext", "name": "buildHistorianReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build the full context for a historian review (annotation) session on an entity.\n * Returns null if preconditions aren't met.\n */\nexport async function buildHistorianReviewContext(\n  entityId: string,\n  tone?: string,\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    summary: entity.summary || \"\",\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n  });\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"entity\",\n    targetId: entity.id,\n    targetName: entity.name,\n    sourceText: entity.description,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildChronicleReviewContext", "name": "buildChronicleReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildChronicleReviewContext(\n  chronicleId: string,\n  tone?: string,\n  corpusStrengthCache?: { runId: string | null; strength: Map<string, number> | null },\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  reinforcementCache?: ReinforcementCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !chronicleId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const chronicle = await getChronicle(chronicleId);\n  if (!chronicle) return null;\n  if (chronicle.status !== \"complete\" || !chronicle.finalContent) return null;\n\n  const content = chronicle.finalContent;\n\n  // Build cast summaries\n  const castEntityIds = (chronicle.roleAssignments || [])\n    .map((ra: { entityId: string }) => ra.entityId)\n    .filter(Boolean);\n  const castFull = await useEntityStore.getState().loadEntities(castEntityIds);\n  const castMap = new Map(castFull.map((e: { id: string }) => [e.id, e]));\n\n  const castSummaries = (chronicle.roleAssignments || [])\n    .slice(0, 10)\n    .map((ra: { entityId: string }) => {\n      const entity = castMap.get(ra.entityId);\n      if (!entity) return null;\n      return {\n        name: entity.name,\n        kind: entity.kind,\n        summary: entity.summary || entity.description?.slice(0, 200) || \"\",\n      };\n    })\n    .filter(Boolean);\n\n  const cast = (chronicle.roleAssignments || []).map((ra: { entityId: string; role: string }) => {\n    const entity = castMap.get(ra.entityId);\n    return {\n      entityName: entity?.name || ra.entityId,\n      role: ra.role,\n      kind: entity?.kind || \"unknown\",\n    };\n  });\n\n  const factCoverageGuidance = chronicle.factCoverageReport?.entries?.length\n    ? await resolveFactCoverageGuidance(\n        chronicle.factCoverageReport, simulationRunId, worldContext,\n        corpusStrengthCache, reinforcementCache\n      )\n    : undefined;\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    chronicleId: chronicle.chronicleId,\n    title: chronicle.title || \"Untitled\",\n    format: chronicle.format,\n    narrativeStyleId: chronicle.narrativeStyleId || \"\",\n    cast,\n    castSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    factCoverageGuidance,\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n    temporalNarrative: chronicle.perspectiveSynthesis?.temporalNarrative || undefined,\n    focalEra: chronicle.temporalContext?.focalEra\n      ? {\n          name: chronicle.temporalContext.focalEra.name,\n          description: chronicle.temporalContext.focalEra.description,\n        }\n      : undefined,\n    temporalCheckReport: chronicle.temporalCheckReport || undefined,\n  });\n\n  const relatedEntityIds = new Set(\n    (chronicle.roleAssignments || []).map((ra: { entityId: string }) => ra.entityId).filter(Boolean)\n  );\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: Array.from(relatedEntityIds),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"chronicle\",\n    targetId: chronicleId,\n    targetName: chronicle.title || \"Untitled Chronicle\",\n    sourceText: content,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || chronicle.assignedTone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "corpusStrengthCache", "type": "{ runId: string | null; strength: Map<string, number> | null }", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "reinforcementCache", "type": "ReinforcementCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildCorpusVoiceDigest", "name": "buildCorpusVoiceDigest", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildCorpusVoiceDigest(\n  cache?: CorpusVoiceDigestCache\n): Promise<CorpusVoiceDigest> {\n  const { simulationRunId } = useEntityStore.getState();\n\n  if (cache && cache.runId === simulationRunId && cache.digest) {\n    return cache.digest;\n  }\n\n  const allTexts = simulationRunId ? await collectCorpusNotes(simulationRunId) : [];\n\n  const digest: CorpusVoiceDigest = {\n    superlativeClaims: extractSuperlativeClaims(allTexts),\n    overusedOpenings: findOverusedOpenings(allTexts),\n    lengthHistogram: computeLengthHistogram(allTexts),\n    tangentCount: allTexts.filter((n) => n.type === \"tangent\").length,\n    totalNotes: allTexts.length,\n    targetCount: new Set(allTexts.map((n) => n.targetName)).size,\n  };\n\n  if (cache) {\n    cache.runId = simulationRunId || null;\n    cache.digest = digest;\n  }\n\n  return digest;\n}", "parameters": [{"name": "cache", "type": "CorpusVoiceDigestCache", "optional": true}], "returnType": "Promise<CorpusVoiceDigest>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildFactCoverageGuidance", "name": "buildFactCoverageGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build a prioritized list of facts the historian should pay attention to.\n * Returns null if no guidance is needed (all facts are well-represented).\n *\n * \"surface\" targets: facts rated \"mentioned\" \u2014 material exists, historian should draw attention\n * \"connect\" targets: facts rated \"missing\" \u2014 historian should find natural openings for tangent\n *\n * Dynamic dampening: facts that have already been reinforced more than their fair share\n * (relative to total annotations with guidance and total eligible facts) get their score\n * reduced proportionally, preventing any single fact from dominating annotation guidance.\n */\nexport function buildFactCoverageGuidance(\n  report: FactCoverageReport,\n  corpusStrength: Map<string, number>,\n  excludeFactIds?: Set<string>,\n  reinforcement?: ReinforcementCounts\n): FactGuidanceTarget[] | null {\n  const eligible = report.entries\n    .filter((e) => e.rating !== \"integral\" && e.rating !== \"prevalent\")\n    .filter((e) => !excludeFactIds || !excludeFactIds.has(e.factId));\n\n  // Fair share: if each annotation picks 2 targets from F eligible facts across T annotations,\n  // each fact's expected reinforcement count is 2T / F.\n  const eligibleFactCount = eligible.length;\n  const fairShare =\n    reinforcement && eligibleFactCount > 0 && reinforcement.totalAnnotationsWithGuidance > 0\n      ? (2 * reinforcement.totalAnnotationsWithGuidance) / eligibleFactCount\n      : 0;\n\n  const scored = eligible\n    .map((e) => {\n      let score = 0;\n      if (e.rating === \"mentioned\") score += 3;\n      if (e.rating === \"missing\") score += 1;\n      const strength = corpusStrength.get(e.factId) ?? 50;\n      if (strength < 25) score += 3;\n      else if (strength < 50) score += 1;\n      if (e.wasFaceted) score += 1;\n\n      // Dynamic dampening: penalize facts that have consumed more than their fair share\n      if (reinforcement && fairShare > 0) {\n        const count = reinforcement.counts.get(e.factId) ?? 0;\n        const ratio = count / fairShare;\n        if (ratio > 1) {\n          score -= Math.floor((ratio - 1) * 3);\n        }\n      }\n\n      return { entry: e, score, strength };\n    })\n    .filter((s) => s.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 2);\n\n  if (scored.length === 0) return null;\n\n  return scored.map((s) => ({\n    factId: s.entry.factId,\n    factText: s.entry.factText,\n    action: s.entry.rating === \"mentioned\" ? (\"surface\" as const) : (\"connect\" as const),\n    evidence: s.entry.rating === \"mentioned\" ? s.entry.evidence : undefined,\n    corpusStrength: s.strength,\n  }));\n}", "parameters": [{"name": "report", "type": "FactCoverageReport", "optional": false}, {"name": "corpusStrength", "type": "Map<string, number>", "optional": false}, {"name": "excludeFactIds", "type": "Set<string>", "optional": true}, {"name": "reinforcement", "type": "ReinforcementCounts", "optional": true}], "returnType": "FactGuidanceTarget[] | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./historianTypes", "specifiers": ["isHistorianConfigured", "isNoteActive"], "category": "internal"}, {"source": "../hooks/useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../hooks/useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "computeCorpusFactStrength", "computeAnnotationReinforcementCounts"], "category": "internal"}, {"source": "./db/chronicleRepository", "specifiers": ["ReinforcementCounts"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["FactCoverageReport"], "category": "internal"}, {"source": "./db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::noteDisplay", "name": "noteDisplay", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Resolve effective display mode, handling legacy `enabled` field */\nexport function noteDisplay(\n  note: Pick<HistorianNote, \"display\" | \"enabled\">\n): HistorianNoteDisplay {\n  if (note.display) return note.display;\n  if (note.enabled === false) return \"disabled\";\n  return \"full\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "HistorianNoteDisplay", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isNoteActive", "name": "isNoteActive", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Whether a note is functionally active (not disabled) */\nexport function isNoteActive(note: Pick<HistorianNote, \"display\" | \"enabled\">): boolean {\n  return noteDisplay(note) !== \"disabled\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isHistorianConfigured", "name": "isHistorianConfigured", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Check whether a historian config has been meaningfully configured */\nexport function isHistorianConfigured(config: HistorianConfig): boolean {\n  return config.name.trim().length > 0 && config.background.trim().length > 0;\n}", "parameters": [{"name": "config", "type": "HistorianConfig", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::computeNoteRange", "name": "computeNoteRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "export function computeNoteRange(\n  targetType: HistorianTargetType,\n  wordCount: number\n): { min: number; max: number } {\n  if (targetType === \"entity\") {\n    if (wordCount < 150) return { min: 1, max: 1 };\n    if (wordCount < 300) return { min: 1, max: 3 };\n    if (wordCount < 600) return { min: 2, max: 4 };\n    if (wordCount < 1200) return { min: 3, max: 6 };\n    return { min: 4, max: 8 };\n  }\n  // chronicle \u2014 calibrated for ~75w/note targeting ~25% annotation ratio\n  if (wordCount < 300) return { min: 1, max: 2 };\n  if (wordCount < 800) return { min: 2, max: 3 };\n  if (wordCount < 1500) return { min: 3, max: 5 };\n  if (wordCount < 3000) return { min: 5, max: 8 };\n  return { min: 8, max: 13 };\n}", "parameters": [{"name": "targetType", "type": "HistorianTargetType", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "{ min: number; max: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::analyzeImageRefCompatibility", "name": "analyzeImageRefCompatibility", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Analyze all image refs for compatibility with new content.\n */\nexport function analyzeImageRefCompatibility(\n  imageRefs: ChronicleImageRefs,\n  oldContent: string,\n  newContent: string,\n  sourceVersionId: string,\n  targetVersionId: string\n): ImageRefCompatibilityAnalysis {\n  const refResults = imageRefs.refs.map((ref) => analyzeImageRef(ref, oldContent, newContent));\n\n  const summary = {\n    reusable: refResults.filter((r) => r.recommendation === \"reuse\").length,\n    needsRegeneration: refResults.filter((r) => r.recommendation === \"regenerate\").length,\n    needsReview: refResults.filter((r) => r.recommendation === \"manual_review\").length,\n  };\n\n  return {\n    sourceVersionId,\n    targetVersionId,\n    refs: refResults,\n    summary,\n  };\n}", "parameters": [{"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "oldContent", "type": "string", "optional": false}, {"name": "newContent", "type": "string", "optional": false}, {"name": "sourceVersionId", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": false}], "returnType": "ImageRefCompatibilityAnalysis", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleImageRefs", "ImageRefCompatibility", "ImageRefCompatibilityAnalysis", "ImageRefSelection"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::createDefaultSelections", "name": "createDefaultSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Create default selections based on compatibility analysis.\n */\nexport function createDefaultSelections(\n  analysis: ImageRefCompatibilityAnalysis\n): ImageRefSelection[] {\n  return analysis.refs.map((ref) => ({\n    refId: ref.refId,\n    action: ref.recommendation === \"regenerate\" ? \"regenerate\" : \"reuse\",\n  }));\n}", "parameters": [{"name": "analysis", "type": "ImageRefCompatibilityAnalysis", "optional": false}], "returnType": "ImageRefSelection[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleImageRefs", "ImageRefCompatibility", "ImageRefCompatibilityAnalysis", "ImageRefSelection"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getSizeOptions", "name": "getSizeOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get size options for a given model\n */\nexport function getSizeOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_SIZES_BY_MODEL[model] || IMAGE_SIZES_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getQualityOptions", "name": "getQualityOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get quality options for a given model\n */\nexport function getQualityOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_QUALITY_BY_MODEL[model] || IMAGE_QUALITY_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultSize", "name": "getDefaultSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default size for a model\n */\nexport function getDefaultSize(model: string): string {\n  const options = getSizeOptions(model);\n  return options[0]?.value || \"1024x1024\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultQuality", "name": "getDefaultQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default quality for a model\n */\nexport function getDefaultQuality(model: string): string {\n  const options = getQualityOptions(model);\n  return options[0]?.value || \"standard\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidSize", "name": "isValidSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a size is valid for a model\n */\nexport function isValidSize(model: string, size: string): boolean {\n  const options = getSizeOptions(model);\n  return options.some((opt) => opt.value === size);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidQuality", "name": "isValidQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a quality is valid for a model\n */\nexport function isValidQuality(model: string, quality: string): boolean {\n  const options = getQualityOptions(model);\n  return options.some((opt) => opt.value === quality);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/llmBudget.ts::calcTokenBudget", "name": "calcTokenBudget", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmBudget.ts", "sourceCode": "export function calcTokenBudget(\n  callType: LLMCallType,\n  callConfig: ResolvedLLMCallConfig,\n  options: TokenBudgetOptions = {}\n): TokenBudget {\n  const defaultMaxTokens = LLM_CALL_METADATA[callType]?.defaults.maxTokens ?? 0;\n  const fallbackMaxTokens =\n    defaultMaxTokens > 0 ? defaultMaxTokens : (options.autoMaxTokens ?? DEFAULT_AUTO_MAX_TOKENS);\n  const responseBudget = callConfig.maxTokens > 0 ? callConfig.maxTokens : fallbackMaxTokens;\n  const safeResponseBudget = responseBudget > 0 ? responseBudget : DEFAULT_AUTO_MAX_TOKENS;\n  const thinkingBudget = callConfig.thinkingBudget > 0 ? callConfig.thinkingBudget : undefined;\n  const totalMaxTokens = thinkingBudget ? thinkingBudget + safeResponseBudget : safeResponseBudget;\n  return { responseBudget: safeResponseBudget, thinkingBudget, totalMaxTokens };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}, {"name": "options", "type": "TokenBudgetOptions", "optional": true}], "returnType": "TokenBudget", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallConfig"], "category": "internal"}, {"source": "./llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "LLMCallType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmCallTypes.ts::getCallTypesByCategory", "name": "getCallTypesByCategory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmCallTypes.ts", "sourceCode": "// Group call types by category\nexport function getCallTypesByCategory(): Record<LLMCallCategory, LLMCallType[]> {\n  return {\n    description: [\"description.narrative\", \"description.visualThesis\", \"description.visualTraits\"],\n    image: [\"image.promptFormatting\", \"image.chronicleFormatting\"],\n    perspective: [\"perspective.synthesis\"],\n    chronicle: [\n      \"chronicle.generation\",\n      \"chronicle.compare\",\n      \"chronicle.combine\",\n      \"chronicle.copyEdit\",\n      \"chronicle.quickCheck\",\n      \"chronicle.summary\",\n      \"chronicle.title\",\n      \"chronicle.imageRefs\",\n      \"chronicle.coverImageScene\",\n      \"chronicle.toneRanking\",\n      \"chronicle.bulkToneRanking\",\n    ],\n    palette: [\"palette.expansion\"],\n    dynamics: [\"dynamics.generation\"],\n    revision: [\"revision.summary\", \"revision.loreBackport\"],\n    historian: [\n      \"historian.entityReview\",\n      \"historian.chronicleReview\",\n      \"historian.edition\",\n      \"historian.chronology\",\n      \"historian.prep\",\n      \"historian.eraNarrative.threads\",\n      \"historian.eraNarrative.generate\",\n      \"historian.eraNarrative.edit\",\n      \"historian.eraNarrative.coverImageScene\",\n      \"historian.eraNarrative.imageRefs\",\n      \"historian.motifVariation\",\n    ],\n  };\n}", "parameters": [], "returnType": "Record<LLMCallCategory, LLMCallType[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getLLMModelSettings", "name": "getLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Load settings from localStorage\n */\nexport function getLLMModelSettings(): LLMModelSettings {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      const parsed = JSON.parse(stored);\n      return migrateSettings(parsed);\n    }\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to load settings:\", err);\n  }\n  return { callOverrides: {}, version: CURRENT_VERSION };\n}", "parameters": [], "returnType": "LLMModelSettings", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::saveLLMModelSettings", "name": "saveLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "export function saveLLMModelSettings(settings: LLMModelSettings): void {\n  try {\n    const cleanOverrides: LLMModelSettings[\"callOverrides\"] = {};\n    for (const [callType, config] of Object.entries(settings.callOverrides)) {\n      if (!config) continue;\n      const metadata = LLM_CALL_METADATA[callType as LLMCallType];\n      if (!metadata) continue;\n\n      const overrides = extractNonDefaultOverrides(config, metadata.defaults);\n      if (overrides) {\n        cleanOverrides[callType as LLMCallType] = overrides;\n      }\n    }\n\n    localStorage.setItem(\n      STORAGE_KEY,\n      JSON.stringify({\n        callOverrides: cleanOverrides,\n        version: settings.version,\n      })\n    );\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to save settings:\", err);\n  }\n}", "parameters": [{"name": "settings", "type": "LLMModelSettings", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getModelForCall", "name": "getModelForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the model for a specific call type\n */\nexport function getModelForCall(callType: LLMCallType): string {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.model ?? LLM_CALL_METADATA[callType].defaults.model;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getThinkingBudgetForCall", "name": "getThinkingBudgetForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the thinking budget for a specific call type\n */\nexport function getThinkingBudgetForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.thinkingBudget ?? LLM_CALL_METADATA[callType].defaults.thinkingBudget;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getMaxTokensForCall", "name": "getMaxTokensForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the max tokens (pre-reasoning budget) for a specific call type\n */\nexport function getMaxTokensForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.maxTokens ?? LLM_CALL_METADATA[callType].defaults.maxTokens;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get complete resolved config for a call\n */\nexport function getCallConfig(callType: LLMCallType): ResolvedLLMCallConfig {\n  const model = getModelForCall(callType);\n  let thinkingBudget = getThinkingBudgetForCall(callType);\n  const maxTokens = getMaxTokensForCall(callType);\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  const defaults = LLM_CALL_METADATA[callType].defaults;\n  const temperature = override?.temperature ?? defaults.temperature;\n  const topP = override?.topP ?? defaults.topP;\n\n  // Ensure thinking is disabled for models that don't support it\n  if (!THINKING_CAPABLE_MODELS.includes(model)) {\n    thinkingBudget = 0;\n  }\n\n  const streamTimeout = override?.streamTimeout ?? defaults.streamTimeout ?? 0;\n  const disableStreaming = override?.disableStreaming ?? defaults.disableStreaming ?? false;\n  const runInBrowser = override?.runInBrowser ?? defaults.runInBrowser ?? false;\n\n  return {\n    model,\n    thinkingBudget,\n    maxTokens,\n    temperature,\n    topP,\n    streamTimeout,\n    disableStreaming,\n    runInBrowser,\n  };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getResolvedLLMCallSettings", "name": "getResolvedLLMCallSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get all resolved settings for passing to worker\n */\nexport function getResolvedLLMCallSettings(): ResolvedLLMCallSettings {\n  const result = {} as ResolvedLLMCallSettings;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    result[callType] = getCallConfig(callType);\n  }\n  return result;\n}", "parameters": [], "returnType": "ResolvedLLMCallSettings", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::updateCallConfig", "name": "updateCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Update configuration for a specific call type\n */\nexport function updateCallConfig(callType: LLMCallType, config: LLMCallConfigStored): void {\n  const settings = getLLMModelSettings();\n  settings.callOverrides[callType] = config;\n  saveLLMModelSettings(settings);\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "config", "type": "LLMCallConfigStored", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::resetToDefaults", "name": "resetToDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Reset all settings to defaults\n */\nexport function resetToDefaults(): void {\n  saveLLMModelSettings({ callOverrides: {}, version: CURRENT_VERSION });\n}", "parameters": [], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::hasOverrides", "name": "hasOverrides", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Check if a call type has any overrides from default\n */\nexport function hasOverrides(callType: LLMCallType): boolean {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  if (!override) return false;\n\n  const metadata = LLM_CALL_METADATA[callType];\n  return (\n    (override.model !== undefined && override.model !== metadata.defaults.model) ||\n    (override.thinkingBudget !== undefined &&\n      override.thinkingBudget !== metadata.defaults.thinkingBudget) ||\n    (override.maxTokens !== undefined && override.maxTokens !== metadata.defaults.maxTokens) ||\n    (override.temperature !== undefined &&\n      override.temperature !== metadata.defaults.temperature) ||\n    (override.topP !== undefined && override.topP !== metadata.defaults.topP) ||\n    (override.streamTimeout !== undefined &&\n      override.streamTimeout !== (metadata.defaults.streamTimeout ?? 0)) ||\n    (override.disableStreaming !== undefined &&\n      override.disableStreaming !== (metadata.defaults.disableStreaming ?? false)) ||\n    (override.runInBrowser !== undefined &&\n      override.runInBrowser !== (metadata.defaults.runInBrowser ?? false))\n  );\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getOverrideCount", "name": "getOverrideCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get count of call types with overrides\n */\nexport function getOverrideCount(): number {\n  let count = 0;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    if (hasOverrides(callType)) count++;\n  }\n  return count;\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmCallTypes", "specifiers": ["LLMCallType", "LLMCallConfig", "LLM_CALL_METADATA", "ALL_LLM_CALL_TYPES", "THINKING_CAPABLE_MODELS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/llmTextCall.ts::runTextCall", "name": "runTextCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmTextCall.ts", "sourceCode": "export async function runTextCall(options: LLMTextCallOptions): Promise<LLMTextCallResult> {\n  const budget = calcTokenBudget(options.callType, options.callConfig, {\n    autoMaxTokens: options.autoMaxTokens,\n  });\n  const estimate = estimateTextCostForCall(\n    options.prompt,\n    options.callType,\n    options.callConfig.model,\n    budget.responseBudget\n  );\n\n  const result = await options.llmClient.complete({\n    systemPrompt: options.systemPrompt,\n    prompt: options.prompt,\n    model: options.callConfig.model,\n    maxTokens: budget.totalMaxTokens,\n    temperature: options.temperature,\n    topP: options.topP,\n    thinkingBudget: budget.thinkingBudget,\n    streamTimeout: options.callConfig.streamTimeout,\n    disableStreaming: options.callConfig.disableStreaming,\n  });\n\n  const usage = result.usage\n    ? {\n        inputTokens: result.usage.inputTokens,\n        outputTokens: result.usage.outputTokens,\n        actualCost: calculateActualTextCost(\n          result.usage.inputTokens,\n          result.usage.outputTokens,\n          options.callConfig.model\n        ),\n      }\n    : {\n        inputTokens: estimate.inputTokens,\n        outputTokens: estimate.outputTokens,\n        actualCost: estimate.estimatedCost,\n      };\n\n  return { result, budget, estimate, usage };\n}", "parameters": [{"name": "options", "type": "LLMTextCallOptions", "optional": false}], "returnType": "Promise<LLMTextCallResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmClient", "specifiers": ["LLMClient", "LLMResult"], "category": "internal"}, {"source": "./llmCallTypes", "specifiers": ["LLMCallType"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallConfig"], "category": "internal"}, {"source": "./llmBudget", "specifiers": ["calcTokenBudget", "TokenBudget"], "category": "internal"}, {"source": "./costEstimation", "specifiers": ["estimateTextCostForCall", "calculateActualTextCost"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts::synthesizePerspective", "name": "synthesizePerspective", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts", "sourceCode": "/**\n * Synthesize perspective using LLM\n */\nexport async function synthesizePerspective(\n  input: PerspectiveSynthesisInput,\n  llmClient: LLMClient,\n  callConfig: ResolvedLLMCallConfig\n): Promise<PerspectiveSynthesisResult> {\n  const { factsWithMetadata, toneFragments } = input;\n\n  // Separate generation constraints (always included verbatim, not sent to LLM)\n  const generationConstraints = (factsWithMetadata || []).filter(\n    (f) => f.type === \"generation_constraint\" && !f.disabled\n  );\n\n  // Build prompt with ALL baseline material - let LLM do the refinement\n  const { prompt: userPrompt, resolvedWorldDynamics } = buildUserPrompt(input);\n\n  // Assembled tone is the core tone fragment\n  const assembledTone = toneFragments.core;\n\n  // Make LLM call\n  const callResult = await runTextCall({\n    llmClient,\n    callType: \"perspective.synthesis\",\n    callConfig,\n    systemPrompt: SYSTEM_PROMPT,\n    prompt: userPrompt,\n    temperature: 0.7, // Allow variation\n  });\n\n  // Parse response\n  const synthesis = parseSynthesisResponse(callResult.result.text);\n\n  // Enforce required facts and finalize\n  const enforcedSynthesis = enforceFacetRequirements(synthesis, input);\n\n  // Build faceted facts for generation\n  const facetedFacts = buildFacetedFacts(enforcedSynthesis, factsWithMetadata, generationConstraints);\n\n  return {\n    synthesis: enforcedSynthesis,\n    assembledTone,\n    facetedFacts,\n    resolvedWorldDynamics,\n    usage: callResult.usage,\n  };\n}", "parameters": [{"name": "input", "type": "PerspectiveSynthesisInput", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}], "returnType": "Promise<PerspectiveSynthesisResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmClient", "specifiers": ["LLMClient"], "category": "internal"}, {"source": "./chronicleTypes", "specifiers": ["EntityContext", "EraContext", "ChronicleRoleAssignment"], "category": "internal"}, {"source": "./constellationAnalyzer", "specifiers": ["EntityConstellation"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["ResolvedLLMCallConfig"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./llmTextCall", "specifiers": ["runTextCall"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getTone", "name": "getTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat tone string from structured context\n */\nexport function getTone(ctx: WorldContext): string {\n  return ctx.toneFragments?.core || \"\";\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getCanonFacts", "name": "getCanonFacts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat canon facts array from structured context\n */\nexport function getCanonFacts(ctx: WorldContext): string[] {\n  return (ctx.canonFactsWithMetadata || []).map((f) => f.text);\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getKindGuidance", "name": "getKindGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// NEW: Helper Functions for Entity Guidance\n// =============================================================================\n\n/**\n * Get guidance for a specific entity kind\n * Returns undefined if kind not found (caller should handle gracefully)\n */\nexport function getKindGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): KindGuidance | undefined {\n  return entityGuidance[kind];\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "KindGuidance | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredVisualIdentity", "name": "getFilteredVisualIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual identity for a culture, filtered by entity kind\n */\nexport function getFilteredVisualIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureVisual = cultureIdentities.visual[culture];\n  if (!cultureVisual) return {};\n\n  const allowedKeys = cultureIdentities.visualKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureVisual;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureVisual[key]) {\n      filtered[key] = cultureVisual[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredDescriptiveIdentity", "name": "getFilteredDescriptiveIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get descriptive identity for a culture, filtered by entity kind\n */\nexport function getFilteredDescriptiveIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureDescriptive = cultureIdentities.descriptive[culture];\n  if (!cultureDescriptive) return {};\n\n  const allowedKeys = cultureIdentities.descriptiveKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureDescriptive;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureDescriptive[key]) {\n      filtered[key] = cultureDescriptive[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildProseHints", "name": "buildProseHints", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build prose hints for chronicle generation\n * Aggregates proseHint from all involved entity kinds\n */\nexport function buildProseHints(entityGuidance: EntityGuidance, involvedKinds: string[]): string {\n  const uniqueKinds = [...new Set(involvedKinds)];\n  const hints: string[] = [];\n\n  for (const kind of uniqueKinds) {\n    const guidance = entityGuidance[kind];\n    if (guidance?.proseHint) {\n      hints.push(`${kind.toUpperCase()}: ${guidance.proseHint}`);\n    }\n  }\n\n  return hints.length > 0 ? hints.join(\"\\n\") : \"\";\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "involvedKinds", "type": "string[]", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildDescriptionPromptFromGuidance", "name": "buildDescriptionPromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// Prompt Builders (using EntityGuidance directly)\n// =============================================================================\n\n/**\n * Build a description prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildDescriptionPromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Get filtered cultural identities\n  const descriptiveIdentity = getFilteredDescriptiveIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n\n  // Format sections\n  const tagsSection =\n    e.tags && Object.keys(e.tags).length > 0\n      ? `TAGS:\\n${Object.entries(e.tags)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const descriptiveSection =\n    Object.keys(descriptiveIdentity).length > 0\n      ? `CULTURAL IDENTITY (${e.culture}):\\n${Object.entries(descriptiveIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const visualSection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const relationshipsSection =\n    entityContext.relationships.length > 0\n      ? entityContext.relationships\n          .slice(0, 8)\n          .map((r) => {\n            let line = `- ${r.kind}: ${r.targetName} (${r.targetKind}`;\n            if (r.targetSubtype) line += `/${r.targetSubtype}`;\n            line += \")\";\n            const strength = r.strength ?? 0.5;\n            let label: string;\n            if (strength >= 0.7) label = \"strong\";\n            else if (strength >= 0.4) label = \"moderate\";\n            else label = \"weak\";\n            line += ` [${label}]`;\n            return line;\n          })\n          .join(\"\\n\")\n      : \"(No established relationships)\";\n\n  const parts = [\n    `Write a description for ${e.name}, a ${e.subtype} ${kind} in ${worldContext.name}.`,\n    \"\",\n    `WORLD: ${worldContext.description}`,\n    \"\",\n    \"TONE & STYLE:\",\n    getTone(worldContext),\n    \"\",\n    \"CANON FACTS (never contradict):\",\n    getCanonFacts(worldContext)\n      .map((f) => `- ${f}`)\n      .join(\"\\n\"),\n    \"\",\n    \"---\",\n    \"\",\n    \"ENTITY:\",\n    `- Kind: ${kind}`,\n    `- Subtype: ${e.subtype}`,\n    `- Prominence: ${e.prominence}`,\n    `- Status: ${e.status}`,\n    `- Culture: ${e.culture || \"unaffiliated\"}`,\n    `- Age in world: ${entityContext.entityAge}`,\n    \"\",\n    tagsSection,\n    descriptiveSection,\n    visualSection,\n    \"\",\n    \"RELATIONSHIPS:\",\n    relationshipsSection,\n    \"\",\n    entityContext.culturalPeers?.length\n      ? `CULTURAL PEERS: ${entityContext.culturalPeers.join(\", \")}`\n      : \"\",\n    entityContext.factionMembers?.length\n      ? `FACTION MEMBERS: ${entityContext.factionMembers.join(\", \")}`\n      : \"\",\n    \"\",\n    // Add events section if entity has narrative history\n    entityContext.events?.length\n      ? `HISTORY FRAGMENTS (mine for flavor, don't enumerate):\\n${entityContext.events\n          .map((ev) => `- [${ev.era}] ${ev.description}`)\n          .join(\"\\n\")}`\n      : \"\",\n    \"\",\n    `ERA: ${entityContext.era.name}${entityContext.era.description ? \" - \" + entityContext.era.description : \"\"}`,\n    \"\",\n    \"---\",\n    \"\",\n    `FOCUS FOR ${kind.toUpperCase()}:`,\n    guidance.focus,\n    \"\",\n    \"RELATIONSHIP GUIDANCE:\",\n    guidance.relationshipUse,\n    \"\",\n    \"---\",\n    \"\",\n    \"OUTPUT: Return JSON with keys: summary, description, aliases\",\n    \"- description: 2-4 sentences, vivid and specific\",\n    \"- summary: 1-2 sentences, compressed and faithful to description\",\n    \"- aliases: array of alternate names (can be empty)\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildImagePromptFromGuidance", "name": "buildImagePromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildImagePromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext,\n  styleInfo?: StyleInfo\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Use summary for image prompts (concise text for visual generation)\n  const summaryText = e.summary || \"\";\n\n  // Visual thesis - THE primary visual signal\n  const visualThesisSection = e.visualThesis\n    ? `VISUAL THESIS (PRIMARY - this is the dominant visual signal):\\n${e.visualThesis}`\n    : \"\";\n\n  // Supporting traits\n  const traitsBody = e.visualTraits?.length\n    ? e.visualTraits.map((t) => `- ${t}`).join(\"\\n\")\n    : \"\";\n  const supportingTraitsSection = traitsBody\n    ? `SUPPORTING TRAITS (reinforce the thesis):\\n${traitsBody}`\n    : \"\";\n\n  // Cultural visual identity\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentitySection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  // Style sections\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : \"\";\n\n  // Species constraint section - placed prominently after IMAGE INSTRUCTIONS\n  const speciesSection = worldContext.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${worldContext.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    `IMAGE INSTRUCTIONS: ${guidance.imageInstructions}`,\n    speciesSection,\n    \"\",\n    `SUBJECT: ${e.name}, a ${e.subtype} ${kind}`,\n    summaryText ? `CONTEXT: ${summaryText}` : \"\",\n    \"\",\n    visualThesisSection,\n    supportingTraitsSection,\n    visualIdentitySection,\n    \"\",\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    \"RENDER: Favor stylized exaggeration over anatomical realism. Push proportions to emphasize the thesis.\",\n    \"\",\n    `SETTING: ${worldContext.name}`,\n    \"\",\n    `AVOID: ${guidance.imageAvoid}`,\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getVisualConfigFromGuidance", "name": "getVisualConfigFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual config for an entity from EntityGuidance\n */\nexport function getVisualConfigFromGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): {\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n} {\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n  return {\n    visualAvoid: guidance.imageAvoid,\n    visualThesisInstructions: `${guidance.visualThesis.domain}\\n\\n${guidance.visualThesis.focus}`,\n    visualThesisFraming: guidance.visualThesis.framing,\n    visualTraitsInstructions: `${guidance.visualTraits.domain}\\n\\n${guidance.visualTraits.focus}`,\n    visualTraitsFraming: guidance.visualTraits.framing,\n  };\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "{\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultEntityGuidance", "name": "createDefaultEntityGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default entity guidance (fallback when none provided)\n */\nexport function createDefaultEntityGuidance(): EntityGuidance {\n  return {};\n}", "parameters": [], "returnType": "EntityGuidance", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultCultureIdentities", "name": "createDefaultCultureIdentities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default culture identities (fallback when none provided)\n */\nexport function createDefaultCultureIdentities(): CultureIdentities {\n  return {\n    visual: {},\n    descriptive: {},\n    visualKeysByKind: {},\n    descriptiveKeysByKind: {},\n  };\n}", "parameters": [], "returnType": "CultureIdentities", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildChronicleScenePrompt", "name": "buildChronicleScenePrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt for chronicle scene/montage images.\n * Rendering directives (STYLE/PALETTE/COMPOSITION) come first as primary authority.\n * No entity lookups \u2014 visual identity is baked into the scene description by the scene LLM.\n */\nexport function buildChronicleScenePrompt(\n  context: ChronicleSceneContext,\n  styleInfo?: StyleInfo\n): string {\n  const { sceneDescription, size, chronicleTitle, world } = context;\n\n  // Rendering directives first \u2014 these are the primary visual authority\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionHint = SIZE_COMPOSITION_HINTS[size] || SIZE_COMPOSITION_HINTS.medium;\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : `COMPOSITION: ${compositionHint}`;\n\n  const sizeHint = `SIZE HINT: ${compositionHint}`;\n\n  // Scene content\n  const worldDescSuffix = world?.description ? ` - ${world.description}` : \"\";\n  const worldSection = world\n    ? `WORLD: ${world.name}${worldDescSuffix}`\n    : \"\";\n\n  const speciesSection = world?.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${world.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    sizeHint,\n    \"\",\n    `SCENE: ${sceneDescription}`,\n    chronicleTitle ? `FROM: \"${chronicleTitle}\"` : \"\",\n    \"\",\n    worldSection,\n    speciesSection,\n    \"\",\n    \"AVOID: Human figures, humanoid hands or fingers, human body proportions. Modern elements, anachronistic technology, text overlays, watermarks\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "context", "type": "ChronicleSceneContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/traitPalette.ts::expandPalette", "name": "expandPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/traitPalette.ts", "sourceCode": "// ============================================================================\n// Expansion Execution\n// ============================================================================\n\nexport async function expandPalette(\n  request: PaletteExpansionRequest,\n  llmClient: LLMClient\n): Promise<PaletteExpansionResult> {\n  const { projectId, entityKind, worldContext } = request;\n\n  if (!llmClient.isEnabled()) {\n    return { success: false, error: \"LLM client not configured\" };\n  }\n\n  // Get model settings for palette expansion\n  const callConfig = getCallConfig(\"palette.expansion\");\n  const { model } = callConfig;\n\n  // Gather current state\n  const currentPalette = await getPalette(projectId, entityKind);\n  const historicalTraits = await getHistoricalTraits(projectId, entityKind);\n\n  const prompt = buildExpansionPrompt(\n    entityKind,\n    worldContext,\n    currentPalette?.items || [],\n    historicalTraits\n  );\n\n  const expansionCall = await runTextCall({\n    llmClient,\n    callType: \"palette.expansion\",\n    callConfig,\n    systemPrompt: EXPANSION_SYSTEM_PROMPT,\n    prompt,\n    temperature: 0.9,\n  });\n  const result = expansionCall.result;\n\n  if (result.error || !result.text) {\n    return {\n      success: false,\n      error: result.error || \"Empty response from LLM\",\n    };\n  }\n\n  // Parse response\n  let expansion: ExpansionResponse;\n  try {\n    expansion = parseExpansionResponse(result.text);\n  } catch (err) {\n    return {\n      success: false,\n      error: `Failed to parse expansion response: ${err instanceof Error ? err.message : \"Unknown error\"}`,\n    };\n  }\n\n  // Apply updates\n  const updatedPalette = await updatePaletteItems(projectId, entityKind, {\n    removeIds: expansion.removedCategories,\n    merges: expansion.mergedCategories,\n    newItems: expansion.newCategories,\n  });\n\n  // Calculate costs\n  const cost = {\n    estimated: expansionCall.estimate.estimatedCost,\n    actual: expansionCall.usage.actualCost,\n    inputTokens: expansionCall.usage.inputTokens,\n    outputTokens: expansionCall.usage.outputTokens,\n  };\n\n  // Save cost record\n  await saveCostRecordWithDefaults({\n    projectId,\n    simulationRunId: request.simulationRunId,\n    type: \"paletteExpansion\",\n    model,\n    estimatedCost: cost.estimated,\n    actualCost: cost.actual,\n    inputTokens: cost.inputTokens,\n    outputTokens: cost.outputTokens,\n  });\n\n  return {\n    success: true,\n    palette: updatedPalette,\n    stats: {\n      removed: expansion.removedCategories?.length || 0,\n      merged: expansion.mergedCategories?.length || 0,\n      added: expansion.newCategories?.length || 0,\n    },\n    cost,\n  };\n}", "parameters": [{"name": "request", "type": "PaletteExpansionRequest", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}], "returnType": "Promise<PaletteExpansionResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./llmClient", "specifiers": ["LLMClient"], "category": "internal"}, {"source": "./db/traitRepository", "specifiers": ["getPalette", "updatePaletteItems", "getHistoricalTraits", "TraitPalette", "PaletteItem"], "category": "internal"}, {"source": "./db/costRepository", "specifiers": ["saveCostRecordWithDefaults"], "category": "internal"}, {"source": "./llmTextCall", "specifiers": ["runTextCall"], "category": "internal"}, {"source": "./jsonParsing", "specifiers": ["parseJsonObject"], "category": "internal"}, {"source": "./llmModelSettings", "specifiers": ["getCallConfig"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::findEntityMentions", "name": "findEntityMentions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "/**\n * Find entity mentions in text using Aho-Corasick matching.\n * Returns one match per entity (first occurrence), no overlap filtering.\n * Use this for detection (e.g. tertiary cast) where we need to know\n * which entities are mentioned regardless of overlapping spans.\n */\nexport function findEntityMentions(content: string, entities: WikiLinkEntity[]): WikiLinkMatch[] {\n  if (!content || entities.length === 0) return [];\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  return Array.from(matchesByEntity.values());\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkMatch[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "export function applyWikiLinks(content: string, entities: WikiLinkEntity[]): WikiLinkResult {\n  if (!content || entities.length === 0) {\n    return { content, links: [], collisions: [] };\n  }\n\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  const matches = filterOverlaps(Array.from(matchesByEntity.values()));\n\n  if (matches.length === 0) {\n    return { content, links: [], collisions: automaton.collisions };\n  }\n\n  let cursor = 0;\n  const output: string[] = [];\n\n  for (const match of matches) {\n    if (match.start > cursor) {\n      output.push(content.slice(cursor, match.start));\n    }\n    const rawSegment = content.slice(match.start, match.end);\n    output.push(`[[${rawSegment}]]`);\n    cursor = match.end;\n  }\n\n  if (cursor < content.length) {\n    output.push(content.slice(cursor));\n  }\n\n  return {\n    content: output.join(\"\"),\n    links: matches,\n    collisions: automaton.collisions,\n  };\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isSharedWorkerSupported", "name": "isSharedWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Check if SharedWorker is supported\n */\nexport function isSharedWorkerSupported(): boolean {\n  return typeof SharedWorker !== \"undefined\";\n}", "parameters": [], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isServiceWorkerSupported", "name": "isServiceWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function isServiceWorkerSupported(): boolean {\n  return (\n    typeof navigator !== \"undefined\" &&\n    \"serviceWorker\" in navigator &&\n    typeof window !== \"undefined\" &&\n    window.isSecureContext\n  );\n}", "parameters": [], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorker", "name": "createWorker", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Create a worker handle that abstracts SharedWorker vs regular Worker\n */\nexport function createWorker(config: WorkerConfig): WorkerHandle {\n  if (isServiceWorkerSupported()) {\n    const handle = createServiceWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    return handle;\n  }\n\n  // Try SharedWorker first\n  if (isSharedWorkerSupported()) {\n    try {\n      const handle = createSharedWorkerHandle();\n      handle.postMessage({ type: \"init\", config });\n      return handle;\n    } catch (err) {\n      console.warn(\"[WorkerFactory] SharedWorker failed, falling back to dedicated Worker:\", err);\n    }\n  }\n\n  // Fallback to regular Worker\n  const handle = createDedicatedWorkerHandle();\n  handle.postMessage({ type: \"init\", config });\n  return handle;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "WorkerHandle", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorkerPool", "name": "createWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function createWorkerPool(config: WorkerConfig, count: number): WorkerHandle[] {\n  if (isServiceWorkerSupported()) {\n    const handles = fillFromPool(getServiceWorkerPool(), count, createServiceWorkerHandle, \"ServiceWorker handle\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  if (isSharedWorkerSupported()) {\n    const handles = fillFromPool(getSharedWorkerPool(), count, createSharedWorkerHandle, \"SharedWorker port\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  const handles: WorkerHandle[] = [];\n  for (let i = 0; i < count; i++) {\n    const handle = createDedicatedWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    handles.push(handle);\n  }\n  return handles;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "WorkerHandle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::resetWorkerPool", "name": "resetWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function resetWorkerPool(): void {\n  const sharedPool = getSharedWorkerPool();\n  for (const handle of sharedPool) {\n    handle?.terminate();\n  }\n  sharedPool.length = 0;\n\n  const servicePool = getServiceWorkerPool();\n  for (const handle of servicePool) {\n    handle?.terminate();\n  }\n  servicePool.length = 0;\n\n  const globalScope = globalThis as GlobalServiceWorkerState;\n  if (globalScope.__illuminatorServiceWorkerHandleMap) {\n    globalScope.__illuminatorServiceWorkerHandleMap.clear();\n  }\n}", "parameters": [], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/workers/clients.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/clients.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../lib/llmClient", "specifiers": ["LLMClient"], "category": "internal"}, {"source": "../lib/imageClient", "specifiers": ["ImageClient"], "category": "internal"}, {"source": "./types", "specifiers": ["WorkerConfig"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/CoverageMatrix/CoverageMatrix.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/CoverageMatrix/CoverageMatrix.jsx", "sourceCode": "export default function CoverageMatrix({\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}) {\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n  const [activeFilter, setActiveFilter] = useState(null);\r\n\r\n  // Normalize columns to { id, label } format\r\n  const normalizedColumns = useMemo(() => {\r\n    return columns.map((col) =>\r\n      typeof col === 'string' ? { id: col, label: col } : col\r\n    );\r\n  }, [columns]);\r\n\r\n  // Filter rows by search\r\n  const filteredRows = useMemo(() => {\r\n    let result = rows;\r\n\r\n    if (searchQuery) {\r\n      const query = searchQuery.toLowerCase();\r\n      result = result.filter(\r\n        (row) =>\r\n          row.id.toLowerCase().includes(query) ||\r\n          row.label.toLowerCase().includes(query) ||\r\n          (row.groupLabel && row.groupLabel.toLowerCase().includes(query))\r\n      );\r\n    }\r\n\r\n    if (activeFilter && filterOptions.length > 0) {\r\n      const filterDef = filterOptions.find((f) => f.id === activeFilter);\r\n      if (filterDef?.filter) {\r\n        result = result.filter(filterDef.filter);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }, [rows, searchQuery, activeFilter, filterOptions]);\r\n\r\n  // Group rows if groupByField is specified\r\n  const groupedRows = useMemo(() => {\r\n    if (!groupByField) {\r\n      return { _ungrouped: { label: '', rows: filteredRows } };\r\n    }\r\n\r\n    const groups = {};\r\n    filteredRows.forEach((row) => {\r\n      const groupId = row[groupByField] || '_ungrouped';\r\n      const groupLabel = row.groupLabel || groupId;\r\n      if (!groups[groupId]) {\r\n        groups[groupId] = { label: groupLabel, rows: [] };\r\n      }\r\n      groups[groupId].rows.push(row);\r\n    });\r\n    return groups;\r\n  }, [filteredRows, groupByField]);\r\n\r\n  // Default cell display function\r\n  const defaultGetCellDisplay = (value) => {\r\n    switch (value) {\r\n      case 'primary':\r\n        return { icon: '\u2713', className: 'primary', title: 'Primary' };\r\n      case 'secondary':\r\n        return { icon: '\u25cb', className: 'secondary', title: 'Secondary' };\r\n      case 'both':\r\n        return { icon: '\u25c9', className: 'both', title: 'Both' };\r\n      case 'none':\r\n      default:\r\n        return { icon: '-', className: 'none', title: 'None' };\r\n    }\r\n  };\r\n\r\n  const displayFn = getCellDisplay || defaultGetCellDisplay;\r\n\r\n  return (\r\n    <div className=\"coverage-matrix\">\r\n      {/* Header */}\r\n      <div className=\"cm-header\">\r\n        <h2 className=\"cm-title\">{title}</h2>\r\n        {subtitle && <p className=\"cm-subtitle\">{subtitle}</p>}\r\n      </div>\r\n\r\n      {/* Stats Bar */}\r\n      {stats.length > 0 && (\r\n        <div className=\"cm-stats\">\r\n          {stats.map((stat, idx) => (\r\n            <div key={idx} className={`cm-stat ${stat.variant || ''}`}>\r\n              <span className=\"cm-stat-value\">{stat.value}</span>\r\n              <span className=\"cm-stat-label\">{stat.label}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Toolbar */}\r\n      <div className=\"cm-toolbar\">\r\n        <input\r\n          type=\"text\"\r\n          className=\"cm-search\"\r\n          placeholder={searchPlaceholder}\r\n          value={searchQuery}\r\n          onChange={(e) => setSearchQuery(e.target.value)}\r\n        />\r\n        {filterOptions.length > 0 && (\r\n          <div className=\"cm-filters\">\r\n            {filterOptions.map((filter) => (\r\n              <button\r\n                key={filter.id}\r\n                className={`cm-filter-btn ${activeFilter === filter.id ? 'active' : ''}`}\r\n                onClick={() =>\r\n                  setActiveFilter(activeFilter === filter.id ? null : filter.id)\r\n                }\r\n              >\r\n                {filter.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Matrix Grid */}\r\n      <div className=\"cm-container\">\r\n        {(normalizedColumns.length === 0 || rows.length === 0) && (\r\n          <div className=\"cm-empty\">{emptyMessage}</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length === 0 && (\r\n          <div className=\"cm-empty\">No items match the current filters.</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length > 0 && (\r\n          <table className=\"cm-table\">\r\n            <thead>\r\n              <tr>\r\n                <th className=\"cm-group-col\">Group</th>\r\n                <th className=\"cm-label-col\">Name</th>\r\n                <th className=\"cm-status-col\">Status</th>\r\n                {normalizedColumns.map((col) => (\r\n                  <th\r\n                    key={col.id}\r\n                    className={`cm-data-col ${columnHeaderClass?.(col.id) || ''}`}\r\n                    title={col.label}\r\n                  >\r\n                    {col.label}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {Object.entries(groupedRows).map(([groupId, { label: groupLabel, rows: groupRows }]) =>\r\n                groupRows.map((row, idx) => (\r\n                  <MatrixRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    idx={idx}\r\n                    groupId={groupId}\r\n                    groupLabel={groupLabel}\r\n                    columns={normalizedColumns}\r\n                    getCellValue={getCellValue}\r\n                    displayFn={displayFn}\r\n                    onRowClick={onRowClick}\r\n                    onCellClick={onCellClick}\r\n                  />\r\n                ))\r\n              )}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      {legend.length > 0 && (\r\n        <div className=\"cm-legend\">\r\n          {legend.map((item, idx) => (\r\n            <span key={idx} className=\"cm-legend-item\">\r\n              <span className={`cm-cell-icon sample ${item.className || ''}`}>\r\n                {item.icon}\r\n              </span>\r\n              {item.label}\r\n            </span>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}", "type": "{ rows?: any[]; columns?: any[]; getCellValue: any; getCellDisplay: any; onRowClick: any; onCellClick: any; title?: string; subtitle?: string; stats?: any[]; legend?: any[]; searchPlaceholder?: string; groupByField?: string; columnHeaderClass: any; emptyMessage?: string; filterOptions?: any[]; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CoverageMatrix.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx", "sourceCode": "export default function ChronicleVersionSelector({\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}) {\n  const isActive = selectedVersionId === activeVersionId;\n  const canDelete = versions.length > 1 && onDeleteVersion;\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const confirmingDelete = confirmingDeleteId === selectedVersionId;\n\n  useEffect(() => {\n    if (!confirmingDeleteId) return;\n    const stillExists = versions.some((v) => v.id === confirmingDeleteId);\n    if (!stillExists || confirmingDeleteId !== selectedVersionId || disabled) {\n      setConfirmingDeleteId(null);\n    }\n  }, [confirmingDeleteId, selectedVersionId, versions, disabled]);\n\n  const handleDeleteClick = () => {\n    if (confirmingDelete) {\n      onDeleteVersion(selectedVersionId);\n      setConfirmingDeleteId(null);\n    } else {\n      setConfirmingDeleteId(selectedVersionId);\n    }\n  };\n\n  return (\n    <div className=\"cvs-container\">\n      <select\n        value={selectedVersionId}\n        onChange={(e) => {\n          onSelectVersion(e.target.value);\n          setConfirmingDeleteId(null);\n        }}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-version\"\n      >\n        {versions.map((version) => (\n          <option key={version.id} value={version.id}>\n            {version.label}\n          </option>\n        ))}\n      </select>\n      <select\n        value={compareToVersionId}\n        onChange={(e) => onSelectCompareVersion(e.target.value)}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-compare\"\n        title=\"Select a version to diff against\"\n      >\n        <option value=\"\">Compare to...</option>\n        {versions\n          .filter((v) => v.id !== selectedVersionId)\n          .map((version) => (\n            <option key={version.id} value={version.id}>\n              {version.shortLabel || version.label}\n            </option>\n          ))}\n      </select>\n      {isActive ? (\n        <span className=\"cvs-active-badge\">Active</span>\n      ) : (\n        <button\n          onClick={() => onSetActiveVersion?.(selectedVersionId)}\n          disabled={disabled || !onSetActiveVersion}\n          className=\"cvs-btn-make-active\"\n        >\n          Make Active\n        </button>\n      )}\n      {canDelete && (\n        <button\n          onClick={handleDeleteClick}\n          onBlur={() => setConfirmingDeleteId(null)}\n          disabled={disabled}\n          title={confirmingDelete ? \"Click again to confirm deletion\" : \"Delete this version\"}\n          className={`cvs-btn-delete${confirmingDelete ? \" cvs-btn-delete-confirming\" : \"\"}`}\n        >\n          {confirmingDelete ? \"Confirm Delete\" : \"Delete\"}\n        </button>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}", "type": "{ versions: any; selectedVersionId: any; activeVersionId: any; compareToVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; disabled: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleVersionSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx", "sourceCode": "export default function ChronicleWorkspace({\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  const isComplete = item.status === \"complete\";\n\n  // ---------------------------------------------------------------------------\n  // Entity map\n  // ---------------------------------------------------------------------------\n  const entityMap = useMemo(() => {\n    if (!entities) return new Map();\n    return new Map(entities.map((e) => [e.id, e]));\n  }, [entities]);\n\n  // ---------------------------------------------------------------------------\n  // Version state & memos\n  // ---------------------------------------------------------------------------\n  const versions = useMemo(() => {\n    const stepLabel = (step) => {\n      if (!step) return null;\n      const labels = {\n        generate: \"initial\",\n        regenerate: \"regenerate\",\n        creative: \"creative\",\n        combine: \"combine\",\n        copy_edit: \"copy-edit\",\n      };\n      return labels[step] || step;\n    };\n\n    const sorted = [...(item.generationHistory || [])].sort(\n      (a, b) => a.generatedAt - b.generatedAt\n    );\n    const seen = new Set();\n    const unique = [];\n    for (const version of sorted) {\n      if (seen.has(version.versionId)) continue;\n      seen.add(version.versionId);\n      unique.push(version);\n    }\n    return unique.map((version, index) => {\n      const samplingLabel = version.sampling ?? \"unspecified\";\n      const step = stepLabel(version.step);\n      const stepDisplay = step || `sampling ${samplingLabel}`;\n      return {\n        id: version.versionId,\n        content: version.content,\n        wordCount: version.wordCount,\n        shortLabel: `V${index + 1}`,\n        label: `Version ${index + 1} \\u2022 ${new Date(version.generatedAt).toLocaleString()} \\u2022 ${stepDisplay}`,\n      };\n    });\n  }, [item.generationHistory]);\n\n  const activeVersionId = item.activeVersionId || versions[versions.length - 1]?.id;\n\n  const [selectedVersionId, setSelectedVersionId] = useState(activeVersionId);\n  const [compareToVersionId, setCompareToVersionId] = useState(\"\");\n\n  useEffect(() => {\n    setSelectedVersionId(activeVersionId);\n    setCompareToVersionId(\"\");\n  }, [activeVersionId, item.chronicleId]);\n\n  useEffect(() => {\n    if (versions.length === 0) return;\n\n    const hasSelected = versions.some((v) => v.id === selectedVersionId);\n    let nextSelected = selectedVersionId;\n    if (!hasSelected) {\n      const hasActive = versions.some((v) => v.id === activeVersionId);\n      nextSelected = hasActive ? activeVersionId : versions[versions.length - 1].id;\n      setSelectedVersionId(nextSelected);\n    }\n\n    if (compareToVersionId) {\n      const hasCompare = versions.some((v) => v.id === compareToVersionId);\n      if (!hasCompare || compareToVersionId === nextSelected) {\n        setCompareToVersionId(\"\");\n      }\n    }\n  }, [versions, selectedVersionId, compareToVersionId, activeVersionId]);\n\n  const selectedVersion = useMemo(\n    () => versions.find((v) => v.id === selectedVersionId) || versions[versions.length - 1],\n    [versions, selectedVersionId]\n  );\n\n  const compareToVersion = useMemo(\n    () => (compareToVersionId ? versions.find((v) => v.id === compareToVersionId) : null),\n    [versions, compareToVersionId]\n  );\n\n  const versionLabelMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.shortLabel);\n    return map;\n  }, [versions]);\n\n  const versionContentMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.content);\n    return map;\n  }, [versions]);\n\n  const getVersionLabel = (versionId) => versionLabelMap.get(versionId) || \"Unknown\";\n\n  const formatTargetIndicator = (targetVersionId) => {\n    if (!targetVersionId) return null;\n    const targetLabel = getVersionLabel(targetVersionId);\n    const activeLabel = getVersionLabel(activeVersionId);\n    if (targetVersionId === activeVersionId) return null;\n    return `Targets ${targetLabel} \\u2022 Active ${activeLabel}`;\n  };\n\n  const summaryIndicator = formatTargetIndicator(item.summaryTargetVersionId);\n  const imageRefsIndicator = formatTargetIndicator(item.imageRefsTargetVersionId);\n  const imageRefsTargetContent =\n    versionContentMap.get(item.imageRefsTargetVersionId || activeVersionId) ||\n    item.assembledContent;\n\n  const compareRunning = refinements?.compare?.running || false;\n  const combineRunning = refinements?.combine?.running || false;\n  const copyEditRunning = refinements?.copyEdit?.running || false;\n  const temporalCheckRunning = refinements?.temporalCheck?.running || false;\n  const quickCheckRunning = refinements?.quickCheck?.running || false;\n\n  // ---------------------------------------------------------------------------\n  // Tertiary cast \u2014 manual detect + persisted on ChronicleRecord\n  // ---------------------------------------------------------------------------\n  const detectTertiaryCast = useCallback(async () => {\n    if (!simulationRunId) return;\n    const content = isComplete\n      ? item.finalContent\n      : selectedVersion?.content || item.assembledContent;\n    if (!content) return;\n\n    // Read fresh entities from Dexie so newly added/edited entities are included\n    const freshEntities = await getEntitiesForRun(simulationRunId);\n    const freshEntityMap = new Map(freshEntities.map((e) => [e.id, e]));\n\n    // Build name/alias dictionary for Aho-Corasick (exclude eras \u2014 too generic)\n    const wikiEntities = [];\n    for (const entity of freshEntities) {\n      if (entity.kind === \"era\") continue;\n      wikiEntities.push({ id: entity.id, name: entity.name });\n      const aliases = entity.enrichment?.text?.aliases;\n      if (Array.isArray(aliases)) {\n        for (const alias of aliases) {\n          if (typeof alias === \"string\" && alias.length >= 3) {\n            wikiEntities.push({ id: entity.id, name: alias });\n          }\n        }\n      }\n    }\n\n    const mentions = findEntityMentions(content, wikiEntities);\n\n    const declaredIds = new Set(item.selectedEntityIds || []);\n\n    // Preserve existing accepted/rejected decisions for entities still detected\n    const prevDecisions = new Map((item.tertiaryCast || []).map((e) => [e.entityId, e.accepted]));\n\n    const seen = new Set();\n    const entries = [];\n    for (const m of mentions) {\n      if (declaredIds.has(m.entityId) || seen.has(m.entityId)) continue;\n      seen.add(m.entityId);\n      const entity = freshEntityMap.get(m.entityId);\n      if (entity) {\n        entries.push({\n          entityId: entity.id,\n          name: entity.name,\n          kind: entity.kind,\n          matchedAs: content.slice(m.start, m.end),\n          matchStart: m.start,\n          matchEnd: m.end,\n          accepted: prevDecisions.get(entity.id) ?? true,\n        });\n      }\n    }\n\n    const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n    await updateChronicleTertiaryCast(item.chronicleId, entries);\n    await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n  }, [\n    simulationRunId,\n    isComplete,\n    item.finalContent,\n    item.assembledContent,\n    item.selectedEntityIds,\n    item.chronicleId,\n    item.tertiaryCast,\n    selectedVersion,\n  ]);\n\n  const toggleTertiaryCast = useCallback(\n    async (entityId) => {\n      const current = item.tertiaryCast || [];\n      const updated = current.map((e) =>\n        e.entityId === entityId ? { ...e, accepted: !e.accepted } : e\n      );\n      const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n      await updateChronicleTertiaryCast(item.chronicleId, updated);\n      await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n    },\n    [item.chronicleId, item.tertiaryCast]\n  );\n\n  // ---------------------------------------------------------------------------\n  // Seed data\n  // ---------------------------------------------------------------------------\n  const seedData = useMemo(\n    () => ({\n      narrativeStyleId: item.narrativeStyleId || \"\",\n      narrativeStyleName:\n        item.narrativeStyle?.name ||\n        styleLibrary?.narrativeStyles?.find((s) => s.id === item.narrativeStyleId)?.name,\n      entrypointId: item.entrypointId,\n      entrypointName: item.entrypointId\n        ? entities?.find((e) => e.id === item.entrypointId)?.name\n// ... (truncated)", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: an...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useCallback", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../ImageModal", "specifiers": ["ImageModal"], "category": "internal"}, {"source": "../QuickCheckModal", "specifiers": ["QuickCheckModal"], "category": "internal"}, {"source": "./WorkspaceHeader", "specifiers": ["WorkspaceHeader"], "category": "internal"}, {"source": "./WorkspaceTabBar", "specifiers": ["WorkspaceTabBar"], "category": "internal"}, {"source": "./PipelineTab", "specifiers": ["PipelineTab"], "category": "internal"}, {"source": "./VersionsTab", "specifiers": ["VersionsTab"], "category": "internal"}, {"source": "./ImagesTab", "specifiers": ["ImagesTab"], "category": "internal"}, {"source": "./ReferenceTab", "specifiers": ["ReferenceTab"], "category": "internal"}, {"source": "./ContentTab", "specifiers": ["ContentTab"], "category": "internal"}, {"source": "./HistorianTab", "specifiers": ["HistorianTab"], "category": "internal"}, {"source": "./EnrichmentTab", "specifiers": ["EnrichmentTab"], "category": "internal"}, {"source": "../../lib/wikiLinkService", "specifiers": ["findEntityMentions"], "category": "internal"}, {"source": "../../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../../lib/db/entityRepository", "specifiers": ["getEntitiesForRun", "createEntity"], "category": "internal"}, {"source": "../CreateEntityModal", "specifiers": ["CreateEntityModal"], "category": "internal"}, {"source": "./ChronicleWorkspace.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx", "sourceCode": "// ============================================================================\n// Content Tab\n// ============================================================================\n\nexport default function ContentTab({\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}) {\n  const content = isComplete\n    ? item.finalContent\n    : selectedVersion?.content || item.assembledContent;\n\n  const wc = isComplete\n    ? item.finalContent?.split(/\\s+/).filter(Boolean).length || 0\n    : (selectedVersion?.wordCount ??\n      (item.assembledContent?.split(/\\s+/).filter(Boolean).length || 0));\n\n  const copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\n  const [summaryExpanded, setSummaryExpanded] = useState(false);\n  const [tertiaryCastExpanded, setTertiaryCastExpanded] = useState(false);\n  const [hoveredTertiaryId, setHoveredTertiaryId] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n\n  const handleTertiaryMouseEnter = useCallback((entityId) => {\n    clearTimeout(hoverTimeoutRef.current);\n    setHoveredTertiaryId(entityId);\n  }, []);\n  const handleTertiaryMouseLeave = useCallback(() => {\n    hoverTimeoutRef.current = setTimeout(() => setHoveredTertiaryId(null), 150);\n  }, []);\n\n  const hasTertiaryCast = item.tertiaryCast?.length > 0;\n  const tertiaryExpanded = tertiaryCastExpanded && hasTertiaryCast;\n\n  return (\n    <div>\n      {/* Summary (collapsible) */}\n      {item.summary && (\n        <div className=\"ctab-summary-section\">\n          <div\n            onClick={() => setSummaryExpanded((v) => !v)}\n            className={`ctab-summary-header ${summaryExpanded ? \"ctab-summary-header-expanded\" : \"\"}`}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            <span className=\"ctab-summary-label\">\n              <span className=\"ctab-collapse-icon\">{summaryExpanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n              Summary\n            </span>\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                navigator.clipboard.writeText(item.summary);\n              }}\n              className=\"ctab-copy-btn\"\n            >\n              Copy\n            </button>\n          </div>\n          {summaryExpanded && <div className=\"ctab-summary-body\">{item.summary}</div>}\n        </div>\n      )}\n\n      {/* Tertiary cast -- entities mentioned but not in declared cast (persisted) */}\n      <div className=\"ctab-tertiary-section\">\n        <div\n          onClick={() => hasTertiaryCast && setTertiaryCastExpanded((v) => !v)}\n          className={`ctab-tertiary-header ${hasTertiaryCast ? \"ctab-tertiary-header-expandable\" : \"ctab-tertiary-header-default\"} ${tertiaryExpanded ? \"ctab-tertiary-header-expanded\" : \"ctab-tertiary-header-collapsed\"}`}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"ctab-tertiary-label\">\n            {hasTertiaryCast && (\n              <span className=\"ctab-collapse-icon\">\n                {tertiaryCastExpanded ? \"\\u25BC\" : \"\\u25B6\"}\n              </span>\n            )}\n            Tertiary Cast\n            {hasTertiaryCast && (\n              <span className=\"ctab-tertiary-count\">\n                {item.tertiaryCast.filter((e) => e.accepted).length}/{item.tertiaryCast.length}\n              </span>\n            )}\n          </span>\n          <button\n            onClick={(e) => {\n              e.stopPropagation();\n              onDetectTertiaryCast?.();\n            }}\n            disabled={!content}\n            className={`ctab-detect-btn ${content ? \"ctab-detect-btn-enabled\" : \"ctab-detect-btn-disabled\"}`}\n          >\n            {item.tertiaryCast ? \"Re-detect\" : \"Detect\"}\n          </button>\n        </div>\n        {tertiaryExpanded && (\n          <div className=\"ctab-tertiary-body\">\n            <div className=\"ctab-tertiary-chips\">\n              {item.tertiaryCast.map((entry) => {\n                const isHovered = hoveredTertiaryId === entry.entityId;\n                // Build context snippet from content if we have match positions\n                let contextSnippet = null;\n                if (isHovered && content && entry.matchStart != null && entry.matchEnd != null) {\n                  const radius = 80;\n                  const snippetStart = Math.max(0, entry.matchStart - radius);\n                  const snippetEnd = Math.min(content.length, entry.matchEnd + radius);\n                  const before =\n                    (snippetStart > 0 ? \"\\u2026\" : \"\") +\n                    content.slice(snippetStart, entry.matchStart);\n                  const matched = content.slice(entry.matchStart, entry.matchEnd);\n                  const after =\n                    content.slice(entry.matchEnd, snippetEnd) +\n                    (snippetEnd < content.length ? \"\\u2026\" : \"\");\n                  contextSnippet = { before, matched, after };\n                }\n                return (\n                  <span\n                    key={entry.entityId}\n                    className=\"ctab-tertiary-chip-wrapper\"\n                    onMouseEnter={() => handleTertiaryMouseEnter(entry.entityId)}\n                    onMouseLeave={handleTertiaryMouseLeave}\n                  >\n                    <span\n                      onClick={() => onToggleTertiaryCast?.(entry.entityId)}\n                      className={`ctab-tertiary-chip ${entry.accepted ? \"ctab-tertiary-chip-accepted\" : \"ctab-tertiary-chip-rejected\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {entry.name}\n                      <span className=\"ctab-tertiary-chip-kind\">{entry.kind}</span>\n                    </span>\n                    {isHovered && (\n                      <div className=\"ctab-tertiary-tooltip\">\n                        <div className=\"ctab-tooltip-header\">\n                          <span>{entry.kind}</span>\n                          <span>click to {entry.accepted ? \"reject\" : \"accept\"}</span>\n                        </div>\n                        {contextSnippet && (\n                          <div className=\"ctab-tooltip-context\">\n                            {contextSnippet.before}\n                            <span className=\"ctab-tooltip-match-highlight\">\n                              {contextSnippet.matched}\n                            </span>\n                            {contextSnippet.after}\n                          </div>\n                        )}\n                        {!contextSnippet && entry.matchedAs !== entry.name && (\n                          <div className=\"ctab-tooltip-matched-as\">\n                            matched as &ldquo;\n                            <span className=\"ctab-tooltip-matched-name\">{entry.matchedAs}</span>\n                            &rdquo;\n                          </div>\n                        )}\n                        <div className=\"ctab-tooltip-arrow\" />\n                      </div>\n                    )}\n                  </span>\n                );\n              })}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Version selector for assembly mode */}\n      {!isComplete && versions && versions.length > 1 && (\n        <div className=\"ctab-version-selector\">\n          <ChronicleVersionSelector\n            versions={versions}\n            selectedVersionId={selectedVersionId}\n            activeVersionId={activeVersionId}\n            compareToVersionId={compareToVersionId}\n            onSelectVersion={onSelectVersion}\n            onSelectCompareVersion={onSelectCompareVersion}\n            onSetActiveVersion={onSetActiveVersion}\n            onDeleteVersion={onDeleteVersion}\n            disabled={isGenerating}\n          />\n        </div>\n      )}\n\n      <AssembledContentViewer\n        content={content}\n        wordCount={wc}\n        onCopy={() => copyToClipboard(content)}\n        compareContent={!isComplete ? compareToVersion?.content : undefined}\n        compareLabel={!isComplete ? compareToVersion?.shortLabel : undefined}\n        onQuickCheck={onQuickCheck}\n        quickCheckRunning={quickCheckRunning}\n        quickCheckReport={item.quickCheckReport}\n        onShowQuickCheck={onShowQuickCheck}\n        onFindReplace={onFindReplace}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}", "type": "{ item: any; isComplete: any; versions: any; selectedVersion: any; compareToVersion: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; isGenerating: any; onQuickCheck: any; quickCheckRunning: any; onShowQuickCheck: any; onFindReplace: any; onDetectTertiaryCast: any; onToggleTertiaryCast: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useRef", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "diff", "specifiers": ["diffWords"], "category": "external"}, {"source": "./ChronicleVersionSelector", "specifiers": ["ChronicleVersionSelector"], "category": "internal"}, {"source": "./ContentTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx", "sourceCode": "export default function EnrichmentTab({\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}) {\n  const titleState = refinements?.title || {};\n  const summaryState = refinements?.summary || {};\n  const formatTimestamp = (ts) => new Date(ts).toLocaleString();\n\n  const titleDisabled = isGenerating || titleState.running;\n  const summaryDisabled = isGenerating || summaryState.running;\n\n  return (\n    <div>\n      <div className=\"enrtab-container\">\n        <div className=\"enrtab-heading\">Post-Publish Enrichment</div>\n        <div className=\"enrtab-sections\">\n          {/* Title */}\n          {onGenerateTitle && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Title</div>\n                <div className=\"enrtab-hint\">\n                  Two-phase title generation: extract fragments, then shape candidates.\n                </div>\n                {item.titleGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.titleGeneratedAt)}\n                  </div>\n                )}\n                {item.titleCandidates?.length > 0 && (\n                  <div className=\"enrtab-candidates\">\n                    <span className=\"enrtab-candidate-selected\">&#x25C6; {item.title}</span>\n                    <br />\n                    {item.titleCandidates.map((c, i) => (\n                      <span key={i}>\n                        <span className=\"enrtab-candidate-alt\">&#x25C7;</span> {c}\n                        {i < item.titleCandidates.length - 1 ? <br /> : null}\n                      </span>\n                    ))}\n                  </div>\n                )}\n                {item.titleFragments?.length > 0 && (\n                  <div className=\"enrtab-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateTitle}\n                disabled={titleDisabled}\n                className={`enrtab-button ${titleDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {titleState.running ? \"Generating...\" : \"Regenerate Title\"}\n              </button>\n            </div>\n          )}\n\n          {/* Summary */}\n          {onGenerateSummary && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Summary</div>\n                <div className=\"enrtab-hint\">\n                  Regenerate the short summary for chronicle listings.\n                </div>\n                {item.summaryGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.summaryGeneratedAt)}\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateSummary}\n                disabled={summaryDisabled}\n                className={`enrtab-button ${summaryDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {summaryState.running ? \"Generating...\" : \"Regenerate Summary\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onGenerateTitle: any; onGenerateSummary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./EnrichmentTab.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx", "sourceCode": "export default function HistorianTab({\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}) {\n  return <div>\n      {/* Tone Assignment */}\n      {onSetAssignedTone && <div className=\"htab-section\">\n          <div className=\"htab-tone-header\">\n            <div className=\"htab-section-title\">Tone</div>\n            {item.toneRanking?.ranking && <div className=\"htab-tone-ranking\">\n                Ranked:{\" \"}\n                {item.toneRanking.ranking.map((tone, i) => {\n            const meta = TONE_META[tone];\n            const perTone = item.toneRanking.rationales?.[tone];\n            return <span key={i}\n            className=\"htab-tone-rank-item\"\n            title={perTone || item.toneRanking.rationale || undefined} style={{\n              // eslint-disable-next-line local/no-inline-styles -- dynamic opacity based on rank index\n              \"--htab-rank-opacity\": i === 0 ? 1 : i === 1 ? 0.6 : 0.4\n            }}>\n                      {i > 0 ? \" > \" : \"\"}\n                      {meta?.label || tone}\n                    </span>;\n          })}\n              </div>}\n            {onDetectTone && <button onClick={onDetectTone} disabled={isGenerating} className=\"htab-tone-detect-btn\" title=\"Run LLM tone detection for this chronicle\">\n                Detect\n              </button>}\n          </div>\n          <div className=\"htab-tone-buttons\">\n            {ANNOTATION_TONES.map(tone => {\n          const meta = TONE_META[tone];\n          const isAssigned = item.assignedTone === tone;\n          const perTone = item.toneRanking?.rationales?.[tone];\n          return <button key={tone} onClick={() => onSetAssignedTone(tone)} className={`htab-tone-btn ${isAssigned ? \"htab-tone-btn-active\" : \"\"}`} title={perTone || meta?.description || tone}>\n                  {meta?.symbol} {meta?.label || tone}\n                </button>;\n        })}\n          </div>\n        </div>}\n\n      {/* Historian Review */}\n      {onHistorianReview && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb12\">Annotate</div>\n          <div className=\"htab-annotate-row\">\n            {item.assignedTone && (() => {\n          const meta = TONE_META[item.assignedTone];\n          return <button onClick={() => onHistorianReview(item.assignedTone)} disabled={isGenerating || isHistorianActive} className=\"htab-annotate-btn\" title={`Run historian review with assigned tone: ${meta?.label || item.assignedTone}`}>\n                    <span className=\"htab-annotate-btn-symbol\">{meta?.symbol || \"?\"}</span>\n                    {item.historianNotes?.length > 0 ? \"Re-annotate\" : \"Annotate\"} (\n                    {meta?.label || item.assignedTone})\n                  </button>;\n        })()}\n            <HistorianToneSelector onSelect={tone => onHistorianReview(tone)} disabled={isGenerating || isHistorianActive} hasNotes={item.historianNotes?.length > 0} label={item.assignedTone ? \"Override\" : undefined} />\n            {!item.assignedTone && <div className=\"htab-annotate-hint\">\n                Select a tone to generate historian margin notes.\n              </div>}\n          </div>\n        </div>}\n\n      {/* Margin Notes */}\n      {item.historianNotes?.length > 0 && <div className=\"htab-margin-notes\">\n          <HistorianMarginNotes notes={item.historianNotes} sourceText={item.finalContent} onUpdateNote={onUpdateHistorianNote ? (noteId, updates) => onUpdateHistorianNote(\"chronicle\", item.chronicleId, noteId, updates) : undefined} />\n        </div>}\n\n      {/* Historian Prep */}\n      {onGeneratePrep && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb8\">Historian Prep</div>\n          <div className=\"htab-prep-description\">\n            Private reading notes in the historian&apos;s voice \u2014 observations and thematic threads for\n            era narrative input.\n          </div>\n          <div className=\"htab-prep-actions\">\n            <button onClick={onGeneratePrep} disabled={isGenerating} className=\"htab-prep-btn\" title={item.historianPrep ? \"Regenerate historian reading notes for this chronicle\" : \"Generate historian reading notes for this chronicle\"}>\n              {item.historianPrep ? \"Regenerate Prep Brief\" : \"Generate Prep Brief\"}\n            </button>\n            {item.historianPrepGeneratedAt && <span className=\"htab-prep-date\" title={`Generated ${new Date(item.historianPrepGeneratedAt).toLocaleString()}`}>\n                Generated {new Date(item.historianPrepGeneratedAt).toLocaleDateString()}\n              </span>}\n          </div>\n          {item.historianPrep && <div className=\"htab-prep-content\">{item.historianPrep}</div>}\n        </div>}\n\n      {/* Lore Backport */}\n      {onBackportLore && <div className=\"htab-section\">\n          <div className=\"htab-lore-title\">Lore Integration</div>\n          <BackportLoreButton item={item} onBackportLore={onBackportLore} isGenerating={isGenerating} />\n        </div>}\n\n      {!onHistorianReview && !onBackportLore && !onGeneratePrep && (item.historianNotes?.length ?? 0) <= 0 && <div className=\"htab-empty\">No historian tools available for this chronicle.</div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}", "type": "{ item: any; isGenerating: any; isHistorianActive: any; onHistorianReview: any; onSetAssignedTone: any; onDetectTone: any; onUpdateHistorianNote: any; onBackportLore: any; onGeneratePrep: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../HistorianMarginNotes", "specifiers": ["HistorianMarginNotes"], "category": "internal"}, {"source": "../HistorianToneSelector", "specifiers": ["HistorianToneSelector", "TONE_META"], "category": "internal"}, {"source": "../../lib/chronicleTypes", "specifiers": ["computeBackportProgress"], "category": "internal"}, {"source": "./HistorianTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx", "sourceCode": "// ============================================================================\n// Images Tab\n// ============================================================================\n\nexport default function ImagesTab({\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}) {\n  // Compatibility analysis state\n  const [compatibilityAnalysis, setCompatibilityAnalysis] = useState(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [isApplying, setIsApplying] = useState(false);\n  const [imageRefSelections, setImageRefSelections] = useState([]);\n\n  // Cover image picker state\n  const [showCoverImagePicker, setShowCoverImagePicker] = useState(false);\n\n  // Check if image refs are for a different version\n  const hasVersionMismatch = useMemo(() => {\n    if (!item.imageRefs || !item.imageRefsTargetVersionId || !activeVersionId) return false;\n    return item.imageRefsTargetVersionId !== activeVersionId;\n  }, [item.imageRefs, item.imageRefsTargetVersionId, activeVersionId]);\n\n  // Handle analyze compatibility\n  const handleAnalyzeCompatibility = useCallback(() => {\n    if (!item.imageRefs || !versions || !activeVersionId || !item.imageRefsTargetVersionId) return;\n    setIsAnalyzing(true);\n\n    // Find the content for source and target versions\n    const sourceVersion = versions.find(v => v.id === item.imageRefsTargetVersionId);\n    const targetVersion = versions.find(v => v.id === activeVersionId);\n    const sourceContent = sourceVersion?.content || \"\";\n    const targetContent = targetVersion?.content || chronicleText || \"\";\n    if (!sourceContent || !targetContent) {\n      console.warn(\"[ImagesTab] Missing content for compatibility analysis\");\n      setIsAnalyzing(false);\n      return;\n    }\n    try {\n      const analysis = analyzeImageRefCompatibility(item.imageRefs, sourceContent, targetContent, item.imageRefsTargetVersionId, activeVersionId);\n      setCompatibilityAnalysis(analysis);\n      setImageRefSelections(createDefaultSelections(analysis));\n    } catch (err) {\n      console.error(\"[ImagesTab] Compatibility analysis failed:\", err);\n    }\n    setIsAnalyzing(false);\n  }, [item.imageRefs, item.imageRefsTargetVersionId, versions, activeVersionId, chronicleText]);\n\n  // Handle selection change\n  const handleSelectionChange = useCallback((refId, action) => {\n    setImageRefSelections(prev => prev.map(s => s.refId === refId ? {\n      ...s,\n      action\n    } : s));\n  }, []);\n\n  // Handle apply selections\n  const handleApplySelections = useCallback(async () => {\n    if (!onApplyImageRefSelections || !activeVersionId || imageRefSelections.length === 0) return;\n    setIsApplying(true);\n    try {\n      await onApplyImageRefSelections(imageRefSelections, activeVersionId);\n      // Clear analysis state after successful apply\n      setCompatibilityAnalysis(null);\n      setImageRefSelections([]);\n    } catch (err) {\n      console.error(\"[ImagesTab] Failed to apply selections:\", err);\n    }\n    setIsApplying(false);\n  }, [onApplyImageRefSelections, activeVersionId, imageRefSelections]);\n  return <div>\n      {/* Cover Image */}\n      {(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-cover-section\">\n          <div className=\"itab-cover-heading\">Cover Image</div>\n          <div className=\"itab-cover-layout\">\n            <div className=\"itab-cover-info\">\n              <div className=\"itab-cover-desc\">\n                Generate a montage-style cover image for this chronicle.\n              </div>\n              {!item.coverImage && <div className=\"itab-cover-status itab-cover-status-default\">Not run yet</div>}\n              {item.coverImage && item.coverImage.status === \"pending\" && <div className=\"itab-cover-status itab-cover-status-pending\">\n                  Scene ready - click Generate Image to create\n                </div>}\n              {item.coverImage && item.coverImage.status === \"generating\" && <div className=\"itab-cover-status itab-cover-status-generating\">\n                  Generating image...\n                </div>}\n              {item.coverImage && item.coverImage.status === \"complete\" && <div className=\"itab-cover-status itab-cover-status-complete\">Complete</div>}\n              {item.coverImage && item.coverImage.status === \"failed\" && <div className=\"itab-cover-status itab-cover-status-failed\">\n                  Failed{item.coverImage.error ? `: ${item.coverImage.error}` : \"\"}\n                </div>}\n              {item.coverImage?.sceneDescription && <div className=\"itab-scene-desc\">{item.coverImage.sceneDescription}</div>}\n              <CoverImagePreview imageId={item.coverImage?.generatedImageId} onImageClick={onImageClick} />\n            </div>\n            <div className=\"itab-cover-actions\">\n              <div className=\"itab-cover-btn-row\">\n                {onGenerateCoverImageScene && <button onClick={onGenerateCoverImageScene} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                    {item.coverImage ? \"Regen Scene\" : \"Gen Scene\"}\n                  </button>}\n                {onGenerateCoverImage && item.coverImage && (item.coverImage.status === \"pending\" || item.coverImage.status === \"complete\" || item.coverImage.status === \"failed\") && <button onClick={onGenerateCoverImage} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                      {item.coverImage.status === \"complete\" ? \"Regen Image\" : \"Gen Image\"}\n                    </button>}\n                {onSelectExistingCoverImage && item.coverImage && !isGenerating && <button onClick={() => setShowCoverImagePicker(true)} className=\"itab-cover-btn itab-cover-btn-enabled\">\n                    Select Existing\n                  </button>}\n              </div>\n            </div>\n          </div>\n        </div>}\n\n      {/* Cover Image Picker */}\n      {item.projectId && <ChronicleImagePicker isOpen={showCoverImagePicker} onClose={() => setShowCoverImagePicker(false)} onSelect={imageId => {\n      if (onSelectExistingCoverImage) {\n        onSelectExistingCoverImage(imageId);\n      }\n      setShowCoverImagePicker(false);\n    }} projectId={item.projectId} chronicleId={item.chronicleId} currentImageId={item.coverImage?.generatedImageId} />}\n\n      {/* Version Mismatch Warning */}\n      {hasVersionMismatch && item.imageRefs && <ImageRefVersionWarning item={item} versions={versions} activeVersionId={activeVersionId} chronicleText={chronicleText} onAnalyzeCompatibility={handleAnalyzeCompatibility} isAnalyzing={isAnalyzing} />}\n\n      {/* Compatibility Analysis Results */}\n      {compatibilityAnalysis && item.imageRefs && <ImageRefCompatibilityResults analysis={compatibilityAnalysis} imageRefs={item.imageRefs} entityMap={entityMap} onSelectionChange={handleSelectionChange} selections={imageRefSelections} onApply={handleApplySelections} isApplying={isApplying} />}\n\n      {/* Image Anchors */}\n      {item.imageRefs && entityMap && <div>\n          <div className=\"itab-anchors-heading\">\n            Image Anchors\n            <span className=\"itab-anchors-count\">({item.imageRefs.refs?.length || 0} placed)</span>\n          </div>\n          <ChronicleImagePanel imageRefs={item.imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onRegenerateDescription={onRegenerateDescription} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} onSelectExistingImage={onSelectExistingImage} projectId={item.projectId} chronicleId={item.chronicleId} chronicleText={chronicleText} isGenerating={isGenerating} styleLibrary={styleLibrary} styleSelection={styleSelection} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={item.title || item.name} imageSize={imageSize} imageQuality={imageQuality} imageModel={imageModel} imageGenSettings={imageGenSettings} onOpenImageSettings={onOpenImageSettings} />\n        </div>}\n\n      {!item.imageRefs && !(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-empty\">\n          No images generated yet. Use the Pipeline tab to generate image refs and cover images.\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}", "type": "{ item: any; isGenerating: any; entityMap: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: any; onUpdateChronicleImageSize: any; onUpdateChronicleImageJustification: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; imageSize: any; imageQuality: any; imageModel: any; imageGenSettings: any; ...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../ChronicleImagePanel", "specifiers": ["ChronicleImagePanel"], "category": "internal"}, {"source": "../ChronicleImagePicker", "specifiers": ["ChronicleImagePicker"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "../../lib/imageRefCompatibility", "specifiers": ["analyzeImageRefCompatibility", "createDefaultSelections"], "category": "internal"}, {"source": "./ImagesTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx", "sourceCode": "// ============================================================================\n// Pipeline Tab\n// ============================================================================\n\nexport default function PipelineTab({\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}) {\n  const summaryState = refinements?.summary || {};\n  const titleState = refinements?.title || {};\n  const imageRefsState = refinements?.imageRefs || {};\n\n  const completedCount = [\n    summaryState.generatedAt,\n    titleState.generatedAt,\n    item.coverImage?.status === \"complete\",\n    imageRefsState.generatedAt,\n    item.cohesionReport,\n  ].filter(Boolean).length;\n\n  return (\n    <div>\n      {/* Refinement Checklist */}\n      <div className=\"pt-checklist\">\n        <div className=\"pt-checklist-header\">\n          <span>Refinements</span>\n          <span className=\"pt-checklist-count\">{completedCount}/5 complete</span>\n        </div>\n        <div className=\"pt-checklist-items\">\n          <RefinementRow\n            label=\"Summary\"\n            description=\"Generate a short summary for chronicle listings.\"\n            state={summaryState}\n            indicator={summaryIndicator}\n            onAction={onGenerateSummary}\n            isGenerating={isGenerating}\n          />\n\n          {/* Title - with candidates display */}\n          <div className=\"pt-refrow\">\n            <div className=\"pt-refrow-content\">\n              <div className=\"pt-refrow-title\">\n                <span\n                  className={`pt-refrow-checkbox ${titleState.generatedAt ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                >\n                  {titleState.generatedAt ? \"\\u2611\" : \"\\u2610\"}\n                </span>\n                Title\n              </div>\n              <div className=\"pt-refrow-description\">\n                Generate an evocative title using single-pass candidate generation.\n              </div>\n              {titleState.generatedAt && (\n                <div className=\"pt-refrow-meta\">\n                  Done - {new Date(titleState.generatedAt).toLocaleString()}\n                  {titleState.model ? ` - ${titleState.model}` : \"\"}\n                </div>\n              )}\n              {item.titleCandidates?.length > 0 && (\n                <div className=\"pt-title-candidates\">\n                  <span className=\"pt-title-selected\">&#x25C6; {item.title}</span>\n                  <br />\n                  {item.titleCandidates.map((c, i) => (\n                    <span key={i}>\n                      <span className=\"pt-title-candidate-icon\">&#x25C7;</span> {c}\n                      {i < item.titleCandidates.length - 1 ? <br /> : null}\n                    </span>\n                  ))}\n                </div>\n              )}\n              {item.titleFragments?.length > 0 && (\n                <div className=\"pt-title-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n              )}\n              {!titleState.generatedAt && !titleState.running && (\n                <div className=\"pt-refrow-meta\">Not run yet</div>\n              )}\n              {titleState.running && <div className=\"pt-refrow-meta\">Running...</div>}\n            </div>\n            {onGenerateTitle && (\n              <button\n                onClick={onGenerateTitle}\n                disabled={isGenerating || titleState.running}\n                className={`pt-refrow-btn ${isGenerating || titleState.running ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {titleState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>\n            )}\n          </div>\n\n          <CoverImageControls\n            item={item}\n            onGenerateCoverImageScene={onGenerateCoverImageScene}\n            onGenerateCoverImage={onGenerateCoverImage}\n            isGenerating={isGenerating}\n            onImageClick={onImageClick}\n          />\n\n          <RefinementRow\n            label=\"Image Refs\"\n            description=\"Generate image placement suggestions for this chronicle.\"\n            state={imageRefsState}\n            indicator={imageRefsIndicator}\n            onAction={onGenerateImageRefs}\n            isGenerating={isGenerating}\n          />\n\n          {onValidate && (\n            <div className=\"pt-refrow\">\n              <div>\n                <div className=\"pt-refrow-title\">\n                  <span\n                    className={`pt-refrow-checkbox ${item.cohesionReport ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                  >\n                    {item.cohesionReport ? \"\\u2611\" : \"\\u2610\"}\n                  </span>\n                  Validate\n                </div>\n                <div className=\"pt-refrow-description\">\n                  Run quality validation to check narrative coherence.\n                </div>\n                {item.cohesionReport && (\n                  <div className=\"pt-refrow-meta\">\n                    Done - Score: {item.cohesionReport.overallScore}/100\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onValidate}\n                disabled={isGenerating}\n                className={`pt-refrow-btn ${isGenerating ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {item.cohesionReport ? \"Revalidate\" : \"Validate\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onGenerateImageRefs: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onRegenerateWithSampling: any; entityMap: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; summaryIndicator: any; imageRefsIndicator: any; imageRefsTargetContent: any; imageSize: any; imageQuality: any; imageModel: any; imageG...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../CoverImageControls", "specifiers": ["CoverImageControls"], "category": "internal"}, {"source": "./PipelineTab.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx", "sourceCode": "// ============================================================================\n// Reference Tab\n// ============================================================================\n\nexport default function ReferenceTab({\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}) {\n  return (\n    <div>\n      {item.perspectiveSynthesis && (\n        <PerspectiveSynthesisViewer synthesis={item.perspectiveSynthesis} />\n      )}\n\n      <ExpandableSeedSection seed={seedData} defaultExpanded={false} />\n\n      {item.factCoverageReport && (\n        <>\n          <FactCoverageGrid report={item.factCoverageReport} />\n          <FactCoverageViewer\n            report={item.factCoverageReport}\n            generatedAt={item.factCoverageReportGeneratedAt}\n          />\n        </>\n      )}\n\n      <TemporalContextEditor\n        item={item}\n        eras={eras}\n        events={events}\n        entities={entities}\n        onUpdateTemporalContext={onUpdateTemporalContext}\n        onTemporalCheck={onTemporalCheck}\n        temporalCheckRunning={temporalCheckRunning}\n        isGenerating={isGenerating}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}", "type": "{ item: any; eras: any; events: any; entities: any; isGenerating: any; onUpdateTemporalContext: any; onTemporalCheck: any; temporalCheckRunning: any; seedData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableSeedSection"], "category": "external"}, {"source": "../ChronicleWizard/visualizations/NarrativeTimeline", "specifiers": ["NarrativeTimeline"], "category": "internal"}, {"source": "../../lib/chronicle/timelineUtils", "specifiers": ["getEraRanges", "prepareTimelineEvents", "prepareCastMarkers", "getTimelineExtent"], "category": "internal"}, {"source": "./ReferenceTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx", "sourceCode": "export default function VersionsTab({\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}) {\n  const [editingCombineInstructions, setEditingCombineInstructions] = useState(false);\n  const [combineInstructionsDraft, setCombineInstructionsDraft] = useState(\"\");\n\n  // Get current LLM settings for display\n  const llmConfigDisplay = useMemo(() => {\n    const perspectiveConfig = getCallConfig(\"perspective.synthesis\");\n    const generationConfig = getCallConfig(\"chronicle.generation\");\n    return {\n      perspective: formatLLMConfig(perspectiveConfig),\n      generation: formatLLMConfig(generationConfig)\n    };\n  }, []);\n  return <div>\n      {/* Version Selector */}\n      <div className=\"vtab-selector-wrap\">\n        <ChronicleVersionSelector versions={versions} selectedVersionId={selectedVersionId} activeVersionId={activeVersionId} compareToVersionId={compareToVersionId} onSelectVersion={onSelectVersion} onSelectCompareVersion={onSelectCompareVersion} onSetActiveVersion={onSetActiveVersion} onDeleteVersion={onDeleteVersion} disabled={isGenerating} />\n      </div>\n\n      {/* Compare & Combine */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">\n          Version Analysis\n          <span className=\"vtab-section-title-count\">\n            ({versions.length} version{versions.length !== 1 ? \"s\" : \"\"} available)\n          </span>\n        </div>\n        <div className=\"vtab-button-row\">\n          <button onClick={onCompareVersions} disabled={isGenerating || compareRunning || combineRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {compareRunning ? \"Comparing...\" : \"Compare Versions\"}\n          </button>\n          <button onClick={onCombineVersions} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {combineRunning ? \"Combining...\" : \"Combine Versions\"}\n          </button>\n          <button onClick={onCopyEdit} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || !item.assembledContent} title=\"Polish pass \u2014 smooths voice, trims to word count target, tightens prose. Produces a new version.\" className=\"vtab-action-btn\">\n            {copyEditRunning ? \"Copy-editing...\" : \"Copy-edit\"}\n          </button>\n          <button onClick={() => {\n          const list = item.generationHistory || [];\n          const byId = new Map();\n          for (const v of list) {\n            const arr = byId.get(v.versionId) || [];\n            arr.push(v);\n            byId.set(v.versionId, arr);\n          }\n          const duplicates = Array.from(byId.entries()).filter(([, arr]) => arr.length > 1).map(([id, arr]) => ({\n            id,\n            count: arr.length\n          }));\n          console.warn(\"[Chronicle][Debug] Version dump\", {\n            chronicleId: item.chronicleId,\n            activeVersionId: item.activeVersionId,\n            acceptedVersionId: item.acceptedVersionId,\n            assembledAt: item.assembledAt,\n            assembledContentLength: item.assembledContent?.length || 0,\n            versionCount: list.length,\n            duplicates,\n            versions: list.map((v, i) => ({\n              index: i,\n              versionId: v.versionId,\n              generatedAt: v.generatedAt,\n              step: v.step,\n              sampling: v.sampling,\n              model: v.model,\n              wordCount: v.wordCount,\n              contentLength: v.content?.length || 0\n            }))\n          });\n        }} disabled={isGenerating} title=\"Dump generationHistory to console\" className=\"vtab-action-btn\">\n            Dump Versions\n          </button>\n        </div>\n        <div className=\"vtab-hint-text\">\n          {versions.length < 2 ? \"Create a new version first to enable comparison and combination.\" : \"Compare produces an analysis report. Combine synthesizes all drafts into a new version. Copy-edit polishes the active version.\"}\n          {item.comparisonReport && !item.combineInstructions && <span className=\"vtab-warning-text\">\n              {\" \"}\n              Combine instructions missing \u2014 combine will use generic criteria.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(\"\");\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Set manually\n                </button>}\n            </span>}\n          {item.combineInstructions && <span className=\"vtab-success-text\">\n              {\" \"}\n              Combine instructions ready.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(item.combineInstructions);\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Edit\n                </button>}\n            </span>}\n        </div>\n\n        {/* Combine Instructions Editor */}\n        {editingCombineInstructions && <div className=\"vtab-instructions-editor\">\n            <textarea value={combineInstructionsDraft} onChange={e => setCombineInstructionsDraft(e.target.value)} placeholder=\"Enter combine instructions \u2014 editorial direction for how to merge versions...\" className=\"vtab-textarea\" />\n            <div className=\"vtab-editor-actions\">\n              <button onClick={() => {\n            onUpdateCombineInstructions(combineInstructionsDraft.trim());\n            setEditingCombineInstructions(false);\n          }} disabled={!combineInstructionsDraft.trim()} className=\"vtab-save-btn\"\n          // eslint-disable-next-line local/no-inline-styles -- dynamic save button appearance from draft state\n          style={{\n            \"--vtab-save-bg\": combineInstructionsDraft.trim() ? \"var(--accent-color, #6366f1)\" : \"var(--bg-tertiary)\",\n            \"--vtab-save-color\": combineInstructionsDraft.trim() ? \"#fff\" : \"var(--text-muted)\",\n            \"--vtab-save-cursor\": combineInstructionsDraft.trim() ? \"pointer\" : \"not-allowed\"\n          }}>\n                Save\n              </button>\n              <button onClick={() => setEditingCombineInstructions(false)} className=\"vtab-cancel-btn\">\n                Cancel\n              </button>\n              {item.combineInstructions && <button onClick={() => {\n            onUpdateCombineInstructions(\"\");\n            setEditingCombineInstructions(false);\n          }} className=\"vtab-clear-btn\">\n                  Clear\n                </button>}\n            </div>\n          </div>}\n      </div>\n\n      {/* Create New Version */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">Create New Version</div>\n\n        <div className=\"vtab-button-row-mb\">\n          {/* Regenerate with existing perspective */}\n          <button onClick={() => onRegenerateWithSampling?.()} disabled={isGenerating || compareRunning || combineRunning || !item.generationSystemPrompt || !item.generationUserPrompt} title=\"Reuse stored prompts with current LLM sampling settings (fast, same perspective)\" className=\"vtab-regen-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with existing perspective\"}\n          </button>\n\n          {/* Regenerate with new perspective */}\n          <button onClick={() => onRegenerateFull?.()} disabled={isGenerating || compareRunning || combineRunning || !onRegenerateFull} title=\"Run fresh perspective synthesis with current world facts & tone (slower, may differ significantly)\" className=\"vtab-regen-primary-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with new perspective\"}\n          </button>\n\n          {/* Regenerate with creative freedom (story format only) */}\n          {onRegenerateCreative && <button onClick={() => onRegenerateCreative?.()} disabled={isGenerating || compareRunning || combineRunning} title=\"Same PS, different generation prompt \u2014 neutral framing, softened structure, no craft posture. Reuses existing perspective synthesis.\" className=\"vtab-regen-creative-btn\">\n              {isGenerating ? \"Generating...\" : \"Creative freedom\"}\n            </button>}\n        </div>\n\n        <div className=\"vtab-llm-config\">\n          <span className=\"vtab-llm-config-label\">LLM Config:</span>{\" \"}\n          <span title=\"perspective.synthesis\">perspective: {llmConfigDisplay.perspective}</span>\n          {\" \u00b7 \"}\n          <span title=\"chronicle.generation\">generation: {llmConfigDisplay.generation}</span>\n          {(!item.generationSystemPrompt || !item.generationUserPrompt) && <span className=\"vtab-warning-inline\">\n              Existing perspective unavailable (legacy chronicle).\n            </span>}\n          {!onRegenerateFull && <span className=\"vtab-warning-inline\">\n              New perspective requires toneFragments and canonFactsWithMetadata.\n            </span>}\n        </div>\n      </div>\n\n      {/* Comparison Report */}\n      {item.comparisonReport && <div className=\"vtab-report-section\">\n          <div className=\"vtab-report-header\">\n            <span className=\"vtab-report-title\">Comparison Report</span>\n            <div className=\"vtab-report-actions\">\n              {item.comparisonReportGeneratedAt && <span className=\"vtab-report-timestamp\">\n                  {new Date(item.comparisonReportGeneratedAt).toLocaleString()}\n                </span>}\n              <button onClick={() => {\n            const blob = new Blob([item.comparisonReport], {\n              type: \"text/markdown\"\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = `comparison-report-${item.chronicleId.slice(0, 20)}-${Date.now()}.md`;\n            a.click();\n            URL.revokeObjectURL(url);\n          }} className=\"vtab-export-btn\">\n                Export\n              </button>\n            </div>\n          </div>\n          <div className=\"vtab-report-body\">{item.comparisonReport}</div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}", "type": "{ item: any; versions: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; isGenerating: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; onCompareVersions: any; onCombineVersions: any; onRegenerateFull: any; onRegenerateCreative: any; onRegenerateWithSampling: any; onUpdateCombineInstructions: any; onCopyEdit: any; compareRunning: any; combineRunning: any; copyEditRunning: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleVersionSelector", "specifiers": ["ChronicleVersionSelector"], "category": "internal"}, {"source": "../../lib/llmModelSettings", "specifiers": ["getCallConfig"], "category": "internal"}, {"source": "./VersionsTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx", "sourceCode": "export default function WorkspaceHeader({\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}) {\n  const [menuOpen, setMenuOpen] = useState(false);\n  const menuRef = useRef(null);\n\n  useEffect(() => {\n    if (!menuOpen) return;\n    const handleClick = (e) => {\n      if (menuRef.current && !menuRef.current.contains(e.target)) setMenuOpen(false);\n    };\n    document.addEventListener(\"mousedown\", handleClick);\n    return () => document.removeEventListener(\"mousedown\", handleClick);\n  }, [menuOpen]);\n\n  return (\n    <div className=\"chronicle-workspace-header\">\n      <div className=\"chronicle-workspace-header-info\">\n        <h3>{item.title || item.name || \"Untitled Chronicle\"}</h3>\n        <div className=\"chronicle-workspace-header-stats\">\n          {wordCount.toLocaleString()} words\n          {item.selectionSummary && (\n            <span>\n              {\" \"}\n              &middot; {item.selectionSummary.entityCount} entities,{\" \"}\n              {item.selectionSummary.eventCount} events\n            </span>\n          )}\n          {item.focusType && (\n            <span> &middot; {item.focusType === \"single\" ? \"Single focus\" : \"Ensemble\"}</span>\n          )}\n          <span> &middot; sampling {item.generationSampling ?? \"unspecified\"}</span>\n        </div>\n      </div>\n      <div className=\"chronicle-workspace-header-actions\">\n        {!isComplete && onAccept && (\n          <button onClick={onAccept} disabled={isGenerating} className=\"wsh-btn-accept\">\n            Accept &#x2713;\n          </button>\n        )}\n        {isComplete && onUnpublish && (\n          <button\n            onClick={onUnpublish}\n            className=\"wsh-btn-unpublish\"\n            title=\"Revert to assembly review without discarding content\"\n          >\n            Unpublish\n          </button>\n        )}\n        <button onClick={onRegenerate} disabled={isGenerating} className=\"wsh-btn-regenerate\">\n          &#x27F3; {isComplete ? \"Restart\" : \"Regenerate\"}\n        </button>\n        <div className=\"workspace-overflow-menu\" ref={menuRef}>\n          <button onClick={() => setMenuOpen(!menuOpen)} className=\"wsh-btn-overflow\">\n            &hellip;\n          </button>\n          {menuOpen && (\n            <div className=\"workspace-overflow-dropdown\">\n              {onExport && (\n                <button\n                  className=\"workspace-overflow-item\"\n                  onClick={() => {\n                    onExport();\n                    setMenuOpen(false);\n                  }}\n                  title=\"Export chronicle with full generation context as JSON\"\n                >\n                  Export\n                </button>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}", "type": "{ item: any; wordCount: any; isGenerating: any; isComplete: any; onAccept: any; onRegenerate: any; onExport: any; onUnpublish: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./WorkspaceHeader.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx", "sourceCode": "export default function WorkspaceTabBar({ tabs, activeTab, onTabChange }) {\n  return (\n    <div className=\"workspace-subtabs\">\n      {tabs.map((tab) => (\n        <button\n          key={tab.id}\n          className={\n            \"workspace-subtab\" +\n            (activeTab === tab.id ? \" active\" : \"\") +\n            (tab.align === \"right\" ? \" right-aligned\" : \"\")\n          }\n          onClick={() => onTabChange(tab.id)}\n        >\n          {tab.label}\n          {tab.indicator ? ` ${tab.indicator}` : \"\"}\n        </button>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ tabs, activeTab, onTabChange }", "type": "{ tabs: any; activeTab: any; onTabChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx", "sourceCode": "// =============================================================================\n// Main Component (wraps with provider)\n// =============================================================================\n\nexport default function ChronicleWizard(props: Readonly<ChronicleWizardProps>) {\n  if (!props.isOpen) return null;\n\n  return (\n    <WizardProvider\n      entityKinds={props.entityKinds}\n      eras={props.eras ?? []}\n      simulationRunId={props.simulationRunId}\n    >\n      <InnerWizard {...props} />\n    </WizardProvider>\n  );\n}", "parameters": [{"name": "props", "type": "Readonly<ChronicleWizardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useCallback", "useMemo", "useRef"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "EntityKindDefinition"], "category": "external"}, {"source": "../../lib/chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "NarrativeLens"], "category": "internal"}, {"source": "./WizardContext", "specifiers": ["WizardProvider", "useWizard", "WizardStep", "ChronicleSeed"], "category": "internal"}, {"source": "./steps/StyleStep", "specifiers": ["StyleStep"], "category": "internal"}, {"source": "./steps/EntryPointStep", "specifiers": ["EntryPointStep"], "category": "internal"}, {"source": "./steps/RoleAssignmentStep", "specifiers": ["RoleAssignmentStep"], "category": "internal"}, {"source": "./steps/EventResolutionStep", "specifiers": ["EventResolutionStep"], "category": "internal"}, {"source": "./steps/GenerateStep", "specifiers": ["GenerateStep"], "category": "internal"}, {"source": "./ChronicleWizard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx", "sourceCode": "export default function ContentPalette({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}: Readonly<ContentPaletteProps>) {\n  const [filter, setFilter] = useState(\"\");\n  const [typeFilter, setTypeFilter] = useState<TypeFilter>(\"all\");\n  const [sortBy, setSortBy] = useState<SortBy>(\"type\");\n\n  const allItems = useMemo<PaletteItem[]>(() => {\n    const items: PaletteItem[] = [];\n\n    for (const e of entities) {\n      if (!e.description || usedIds.has(e.id) || e.kind === \"era\") continue;\n      items.push({\n        type: \"entity\",\n        contentId: e.id,\n        name: e.name,\n        subtitle: `${e.kind}${e.subtype ? \" / \" + e.subtype : \"\"}`,\n        wordCount: countWords(e.description || \"\"),\n      });\n    }\n\n    for (const c of chronicles) {\n      if (c.status !== \"complete\" && c.status !== \"assembly_ready\") continue;\n      if (usedIds.has(c.chronicleId)) continue;\n      const content = c.finalContent || c.assembledContent || \"\";\n      items.push({\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n        name: c.title || \"Untitled Chronicle\",\n        subtitle: `${c.format} \\u2022 ${c.focusType}`,\n        wordCount: countWords(content),\n      });\n    }\n\n    for (const n of eraNarratives) {\n      if (n.status !== \"complete\" && n.status !== \"step_complete\") continue;\n      if (usedIds.has(n.narrativeId)) continue;\n      const { content } = resolveActiveContent(n);\n      items.push({\n        type: \"era_narrative\",\n        contentId: n.narrativeId,\n        name: n.eraName,\n        subtitle: `${n.tone} \\u2022 era narrative`,\n        wordCount: countWords(content || \"\"),\n      });\n    }\n\n    for (const p of staticPages) {\n      if (p.status !== \"published\" || usedIds.has(p.pageId)) continue;\n      items.push({\n        type: \"static_page\",\n        contentId: p.pageId,\n        name: p.title,\n        subtitle: `${p.wordCount.toLocaleString()} words`,\n        wordCount: p.wordCount,\n      });\n    }\n\n    return items;\n  }, [entities, chronicles, eraNarratives, staticPages, usedIds]);\n\n  const filteredItems = useMemo(() => {\n    let items = allItems;\n\n    // Type filter\n    if (typeFilter !== \"all\") {\n      items = items.filter((i) => i.type === typeFilter);\n    }\n\n    // Text filter\n    if (filter) {\n      const lower = filter.toLowerCase();\n      items = items.filter(\n        (i) => i.name.toLowerCase().includes(lower) || i.subtitle.toLowerCase().includes(lower)\n      );\n    }\n\n    // Sort\n    items = [...items].sort((a, b) => {\n      if (sortBy === \"name\") return a.name.localeCompare(b.name);\n      if (sortBy === \"words\") return b.wordCount - a.wordCount;\n      // 'type': group by type, then name\n      if (a.type !== b.type) return a.type.localeCompare(b.type);\n      return a.name.localeCompare(b.name);\n    });\n\n    return items;\n  }, [allItems, typeFilter, filter, sortBy]);\n\n  const handleClick = (item: PaletteItem) => {\n    if (!selectedFolderId) return;\n    onAddContent({ type: item.type, contentId: item.contentId, name: item.name });\n  };\n\n  return (\n    <div className=\"preprint-palette\">\n      <div className=\"preprint-palette-controls\">\n        <input\n          type=\"text\"\n          className=\"preprint-input preprint-palette-search\"\n          placeholder=\"Search content...\"\n          value={filter}\n          onChange={(e) => setFilter(e.target.value)}\n        />\n        <div className=\"preprint-palette-filters\">\n          {TYPE_FILTER_LABELS.map((tf) => (\n            <button\n              key={tf.value}\n              className={`preprint-palette-chip ${typeFilter === tf.value ? \"active\" : \"\"}`}\n              onClick={() => setTypeFilter(tf.value)}\n            >\n              {tf.label}\n            </button>\n          ))}\n          <select\n            className=\"preprint-palette-sort\"\n            value={sortBy}\n            onChange={(e) => setSortBy(e.target.value as SortBy)}\n            title=\"Sort order\"\n          >\n            {SORT_OPTIONS.map((s) => (\n              <option key={s.value} value={s.value}>\n                {s.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n\n      <div className=\"preprint-palette-list\">\n        {filteredItems.length === 0 && (\n          <div className=\"preprint-palette-empty\">\n            {allItems.length === 0\n              ? \"All content has been placed in the tree.\"\n              : \"No items match the current filters.\"}\n          </div>\n        )}\n        {filteredItems.map((item) => (\n          <PaletteItemRow\n            key={`${item.type}-${item.contentId}`}\n            item={item}\n            disabled={!selectedFolderId}\n            onClick={() => handleClick(item)}\n          />\n        ))}\n      </div>\n\n      <div className=\"preprint-palette-footer\">\n        {filteredItems.length} of {allItems.length} items\n        {!selectedFolderId && allItems.length > 0 && (\n          <span className=\"preprint-palette-hint\"> \u2014 select a folder to add</span>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}", "type": "Readonly<ContentPaletteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "react-dnd", "specifiers": ["useDrag"], "category": "external"}, {"source": "../../lib/db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../../lib/staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["ContentNodeType"], "category": "internal"}, {"source": "../../lib/db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "../../lib/db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx", "sourceCode": "// \u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ContentTreeView({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}: Readonly<ContentTreeViewProps>) {\n  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);\n  const [newFolderParent, setNewFolderParent] = useState<string | null>(null);\n  const [newFolderName, setNewFolderName] = useState(\"\");\n  const treeRef = useRef<any>(null);\n\n  // Build set of used content IDs\n  const usedIds = useMemo(\n    () => (treeState ? getAllContentIds(treeState) : new Set<string>()),\n    [treeState]\n  );\n\n  // Enrich tree nodes with metadata for display\n  const enrichedData = useMemo<TreeNodeData[]>(() => {\n    if (!treeState) return [];\n\n    const entityMap = new Map(entities.map((e) => [e.id, e]));\n    const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n    const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n    const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n\n    function enrich(nodes: ContentTreeNode[]): TreeNodeData[] {\n      return nodes.map((node) => {\n        const enriched: TreeNodeData = { ...node };\n\n        if (node.type === \"entity\" && node.contentId) {\n          const ent = entityMap.get(node.contentId);\n          if (ent) {\n            enriched.meta = {\n              wordCount: countWords(ent.description || \"\"),\n              imageCount: ent.enrichment?.image?.imageId ? 1 : 0,\n              hasDescription: !!ent.description,\n              hasImage: !!ent.enrichment?.image?.imageId,\n            };\n          }\n        } else if (node.type === \"chronicle\" && node.contentId) {\n          const chr = chronicleMap.get(node.contentId);\n          if (chr) {\n            const content = chr.finalContent || chr.assembledContent || \"\";\n            const imgCount = countCompletedPromptImages(chr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content),\n              imageCount: imgCount + (chr.coverImage?.generatedImageId ? 1 : 0),\n              hasDescription: !!content,\n              hasImage: imgCount > 0,\n            };\n          }\n        } else if (node.type === \"static_page\" && node.contentId) {\n          const page = pageMap.get(node.contentId);\n          if (page) {\n            enriched.meta = {\n              wordCount: page.wordCount,\n              imageCount: 0,\n              hasDescription: !!page.content,\n              hasImage: true, // Pages don't require images\n            };\n          }\n        } else if (node.type === \"era_narrative\" && node.contentId) {\n          const narr = narrativeMap.get(node.contentId);\n          if (narr) {\n            const { content } = resolveActiveContent(narr);\n            const imgCount =\n              (narr.coverImage?.generatedImageId ? 1 : 0) +\n              countNarrativeImageRefs(narr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content || \"\"),\n              imageCount: imgCount,\n              hasDescription: !!content,\n              hasImage: !!narr.coverImage?.generatedImageId,\n            };\n          }\n        }\n\n        if (node.children) {\n          enriched.children = enrich(node.children);\n        }\n\n        return enriched;\n      });\n    }\n\n    return enrich(toArboristData(treeState.nodes));\n  }, [treeState, entities, chronicles, staticPages, eraNarratives]);\n\n  // Handlers\n  const handleCreateScaffold = useCallback(() => {\n    const scaffold = createScaffold(projectId, simulationRunId);\n    onTreeChange(scaffold);\n  }, [projectId, simulationRunId, onTreeChange]);\n\n  const handleMove: MoveHandler<TreeNodeData> = useCallback(\n    ({ dragIds, parentId, index }) => {\n      if (!treeState || dragIds.length === 0) return;\n      const api = treeRef.current;\n      if (!api) return;\n\n      let newState = treeState;\n      for (const dragId of dragIds) {\n        const node = findNode(newState, dragId);\n        if (!node) continue;\n        const { nodes: withoutNode } = {\n          ...newState,\n          nodes: removeNodeFromTree(newState.nodes, dragId),\n        };\n        if (parentId) {\n          newState = {\n            ...newState,\n            nodes: insertNodeInTree(withoutNode, parentId, { ...node }, index),\n            updatedAt: Date.now(),\n          };\n        } else {\n          const rootNodes = [...withoutNode];\n          rootNodes.splice(index, 0, { ...node });\n          newState = { ...newState, nodes: rootNodes, updatedAt: Date.now() };\n        }\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleRename: RenameHandler<TreeNodeData> = useCallback(\n    ({ id, name }) => {\n      if (!treeState) return;\n      onTreeChange(renameNode(treeState, id, name));\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleDelete: DeleteHandler<TreeNodeData> = useCallback(\n    ({ ids }) => {\n      if (!treeState) return;\n      let newState = treeState;\n      for (const id of ids) {\n        newState = deleteNode(newState, id);\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleAddFolder = useCallback(() => {\n    if (!treeState || !newFolderParent || !newFolderName.trim()) return;\n    onTreeChange(addFolder(treeState, newFolderParent, newFolderName.trim()));\n    setNewFolderName(\"\");\n    setNewFolderParent(null);\n  }, [treeState, newFolderParent, newFolderName, onTreeChange]);\n\n  const handleAddContent = useCallback(\n    (item: { type: ContentNodeType; contentId: string; name: string }) => {\n      if (!treeState || !selectedNodeId) return;\n      const target = findNode(treeState, selectedNodeId);\n      if (!target || target.type !== \"folder\") return;\n      onTreeChange(addContentItem(treeState, selectedNodeId, item));\n    },\n    [treeState, selectedNodeId, onTreeChange]\n  );\n\n  // Auto-populate\n  const handleAutoPopulate = useCallback(() => {\n    if (!treeState) return;\n\n    const bodyNode = treeState.nodes.find((n) => n.name === \"Body\" && n.type === \"folder\");\n    const backMatterNode = treeState.nodes.find(\n      (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n    );\n    const hasExistingContent =\n      (bodyNode?.children?.length ?? 0) > 0 ||\n      (backMatterNode?.children?.some((c) => c.name === \"Encyclopedia\") ?? false);\n\n    if (hasExistingContent) {\n      if (\n        !confirm(\n          \"Body and Back Matter already have content. Replace with auto-populated structure?\"\n        )\n      )\n        return;\n    }\n\n    const chronicleInput = chronicles\n      .filter((c) => c.status === \"complete\" || c.status === \"assembly_ready\")\n      .map((c) => ({\n        chronicleId: c.chronicleId,\n        title: c.title || \"Untitled Chronicle\",\n        status: c.status,\n        focalEraId: c.temporalContext?.focalEra?.id || (c as any).focalEra?.id,\n        focalEraName: c.temporalContext?.focalEra?.name || (c as any).focalEra?.name,\n        eraYear: c.eraYear,\n      }));\n\n    const narrativeInput = eraNarratives.map((n) => ({\n      narrativeId: n.narrativeId,\n      eraId: n.eraId,\n      eraName: n.eraName,\n      status: n.status,\n    }));\n\n    const entityInput = entities.map((e) => ({\n      id: e.id,\n      name: e.name,\n      kind: e.kind,\n      subtype: e.subtype,\n      culture: e.culture,\n      description: e.description,\n    }));\n\n    const pageInput = staticPages.map((p) => ({\n      pageId: p.pageId,\n      title: p.title,\n      status: p.status,\n    }));\n\n    const newTree = autoPopulateBody(treeState, {\n      chronicles: chronicleInput,\n      eraNarratives: narrativeInput,\n      entities: entityInput,\n      staticPages: pageInput,\n      eraOrder: eraOrderMap,\n    });\n\n    onTreeChange(newTree);\n  }, [treeState, chronicles, eraNarratives, entities, staticPages, eraOrderMap, onTreeChange]);\n\n  // No tree yet: show scaffold button\n  if (!treeState) {\n    return (\n      <div className=\"preprint-tree-empty\">\n        <p className=\"ctv-empty-msg\">\n          Create a book structure to organize content for print. The scaffold includes standard\n          Front Matter, Body, and Back Matter sections.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCreateScaffold}>\n          Create Book Scaffold\n        </button>\n      </div>\n    );\n  }\n\n  const selectedNode = selectedNodeId ? findNode(treeState, selectedNodeId) : null;\n  const isSelectedFolder = selectedNode?.type === \"folder\";\n\n  return (\n    <div className=\"preprint-tree-layout\">\n      <div className=\"preprint-tree-toolbar\">\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleAutoPopulate}\n          title=\"Auto-populate Body and Encyclopedia from Chronicler's era ordering\"\n        >\n          Auto-Populate\n        </button>\n        <button\n          className=\"preprint-action-button small\"\n          disabled={!isSelectedFolder}\n          onClick={() => {\n            if (selectedNodeId) setNewFolderParent(selectedNodeId);\n          }}\n          title=\"Add folder to selected folder\"\n        >\n          + Folder\n        </button>\n        <button\n          className=\"preprint-action-button small danger\"\n          disabled={!selectedNodeId}\n          onClick={() => {\n            if (selectedNodeId && confirm(\"Delete this node and all children?\")) {\n              onTreeChange(deleteNode(treeState, selectedNodeId));\n              setSelectedNodeId(null);\n            }\n          }}\n          title=\"Delete selected node\"\n        >\n          Delete\n        </button>\n        <div className=\"ctv-toolbar-spacer\" />\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCreateScaffold}\n          title=\"Reset to default scaffold (replaces current tree)\"\n        >\n          Reset Scaffold\n        </button>\n      </div>\n\n      <DndProvider backend={HTML5Backend}>\n        <div className=\"preprint-tree-split\">\n          <div className=\"preprint-tree-left\">\n            <TreePane\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}", "type": "Readonly<ContentTreeViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "react-dnd", "specifiers": ["DndProvider", "useDragDropManager", "useDrop"], "category": "external"}, {"source": "react-dnd-html5-backend", "specifiers": ["HTML5Backend"], "category": "external"}, {"source": "react-arborist", "specifiers": ["Tree"], "category": "external"}, {"source": "react-arborist", "specifiers": ["MoveHandler", "RenameHandler", "DeleteHandler"], "category": "external"}, {"source": "../../lib/db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../../lib/staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["ContentTreeState", "ContentTreeNode", "ContentNodeType"], "category": "internal"}, {"source": "./TreeNodeRenderer", "specifiers": ["TreeNodeData"], "category": "internal"}, {"source": "./TreeNodeRenderer", "specifiers": ["TreeNodeRenderer"], "category": "internal"}, {"source": "./ContentPalette", "specifiers": ["ContentPalette", "PALETTE_ITEM_TYPE"], "category": "internal"}, {"source": "./ContentPalette", "specifiers": ["PaletteItemDragPayload"], "category": "internal"}, {"source": "./PageLayoutEditor", "specifiers": ["PageLayoutEditor"], "category": "internal"}, {"source": "../../lib/preprint/contentTree", "specifiers": ["createScaffold", "addFolder", "deleteNode", "renameNode", "addContentItem", "getAllContentIds", "toArboristData", "findNode", "autoPopulateBody"], "category": "internal"}, {"source": "../../lib/db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "../../lib/db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}, {"source": "./ContentTreeView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/ExportView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ExportView.tsx", "sourceCode": "export default function ExportView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}: Readonly<ExportViewProps>) {\n  const [exporting, setExporting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [exportFormat, setExportFormat] = useState<ExportFormat>(\"markdown\");\n  const [idmlLayout, setIdmlLayout] = useState<IdmlLayoutOptions>({ ...DEFAULT_IDML_LAYOUT });\n  const [customFont, setCustomFont] = useState(\"\");\n\n  // Read S3 config from localStorage (set by Canonry AWS panel)\n  const s3Config = useMemo<S3ExportConfig | null>(() => {\n    try {\n      const raw = localStorage.getItem(\"canonry.aws.config\");\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      if (!parsed.imageBucket) return null;\n      return {\n        bucket: parsed.imageBucket,\n        basePrefix: parsed.imagePrefix || \"\",\n        rawPrefix: parsed.rawPrefix || \"raw\",\n        region: parsed.region || \"us-east-1\",\n      };\n    } catch {\n      return null;\n    }\n  }, []);\n\n  const handleExport = useCallback(async () => {\n    if (!treeState) return;\n\n    setExporting(true);\n    setError(null);\n\n    try {\n      const exportOptions = {\n        treeState,\n        entities,\n        chronicles,\n        images,\n        staticPages,\n        eraNarratives,\n        projectId,\n        simulationRunId,\n        s3Config,\n        idmlLayout,\n      };\n\n      const blob =\n        exportFormat === \"indesign\"\n          ? await buildInDesignExportZip(exportOptions)\n          : await buildExportZip(exportOptions);\n\n      const timestamp = new Date().toISOString().slice(0, 10);\n      const filename =\n        exportFormat === \"indesign\"\n          ? `preprint-${timestamp}.idml`\n          : `preprint-markdown-${timestamp}.zip`;\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err: any) {\n      setError(err.message || \"Export failed\");\n    } finally {\n      setExporting(false);\n    }\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n    exportFormat,\n    idmlLayout,\n  ]);\n\n  const handleDownloadScript = useCallback(() => {\n    const script = buildIdmlImageScript({\n      treeState: treeState,\n      entities,\n      chronicles,\n      images,\n      staticPages,\n      eraNarratives,\n      projectId,\n      simulationRunId,\n      s3Config,\n    });\n    if (!script) return;\n\n    const blob = new Blob([script], { type: \"text/x-shellscript\" });\n    const timestamp = new Date().toISOString().slice(0, 10);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = `download-images-${timestamp}.sh`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  ]);\n\n  if (!treeState) {\n    return (\n      <div className=\"ev-empty-msg\">\n        Create a content tree first (Content Tree tab) before exporting.\n      </div>\n    );\n  }\n\n  const s3Contents = s3Config\n    ? [\n        { label: \"s3-config.json\", description: \"S3 bucket and prefix configuration\" },\n        {\n          label: \"download-images.sh\",\n          description: \"Bash script to pull images from S3 (requires aws CLI + jq)\",\n        },\n      ]\n    : [];\n\n  return (\n    <div className=\"preprint-export\">\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Export Format</h2>\n        </div>\n\n        <div className=\"preprint-export-format-selector\">\n          <label\n            className={`preprint-export-format-option${exportFormat === \"markdown\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"markdown\"\n              checked={exportFormat === \"markdown\"}\n              onChange={() => setExportFormat(\"markdown\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>Markdown ZIP</strong>\n              <span>Folder hierarchy of .md files with YAML frontmatter</span>\n            </div>\n          </label>\n          <label\n            className={`preprint-export-format-option${exportFormat === \"indesign\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"indesign\"\n              checked={exportFormat === \"indesign\"}\n              onChange={() => setExportFormat(\"indesign\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>InDesign IDML</strong>\n              <span>Native InDesign document with pages and styles</span>\n            </div>\n          </label>\n        </div>\n\n        <p className=\"ev-format-desc\">\n          {FORMAT_DESCRIPTIONS[exportFormat]}\n        </p>\n\n        {exportFormat === \"indesign\" && (\n          <div className=\"preprint-export-config\">\n            <div className=\"preprint-stats-subsection\">Layout Options</div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Page Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.pagePreset}\n                onChange={(e) => setIdmlLayout((prev) => ({ ...prev, pagePreset: e.target.value }))}\n              >\n                {Object.entries(IDML_PAGE_PRESETS).map(([key, preset]) => (\n                  <option key={key} value={key}>\n                    {preset.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Font</span>\n              <select\n                className=\"preprint-export-select\"\n                value={\n                  IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any)\n                    ? idmlLayout.fontFamily\n                    : \"__custom__\"\n                }\n                onChange={(e) => {\n                  if (e.target.value === \"__custom__\") {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: customFont || \"Junicode\" }));\n                  } else {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                  }\n                }}\n              >\n                {IDML_FONT_PRESETS.map((f) => (\n                  <option key={f} value={f}>\n                    {f}\n                  </option>\n                ))}\n                <option value=\"__custom__\">Custom...</option>\n              </select>\n            </div>\n\n            {!IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any) && (\n              <div className=\"preprint-stats-row\">\n                <span>Custom Font</span>\n                <input\n                  type=\"text\"\n                  className=\"preprint-export-input\"\n                  value={customFont}\n                  placeholder=\"Font family name\"\n                  onChange={(e) => {\n                    setCustomFont(e.target.value);\n                    if (e.target.value) {\n                      setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                    }\n                  }}\n                />\n              </div>\n            )}\n\n            <div className=\"preprint-stats-row\">\n              <span>Body Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodySize}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodySize: Number(e.target.value) }))\n                }\n              >\n                {[9, 10, 11, 12, 13, 14].map((s) => (\n                  <option key={s} value={s}>\n                    {s}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Leading</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodyLeading}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodyLeading: Number(e.target.value) }))\n                }\n              >\n                {[11, 12, 13, 14, 15, 16, 18].map((l) => (\n                  <option key={l} value={l}>\n                    {l}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Columns</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.columnCount}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, columnCount: Number(e.target.value) }))\n                }\n              >\n                <option value={1}>1</option>\n                <option value={2}>2</option>\n              </select>\n            </div>\n\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}", "type": "Readonly<ExportViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo"], "category": "framework"}, {"source": "../../lib/db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../../lib/preprint/prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../../lib/staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["ContentTreeState", "S3ExportConfig", "ExportFormat", "IdmlLayoutOptions"], "category": "internal"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["IDML_PAGE_PRESETS", "IDML_FONT_PRESETS", "DEFAULT_IDML_LAYOUT"], "category": "internal"}, {"source": "../../lib/preprint/markdownExport", "specifiers": ["buildExportZip", "buildInDesignExportZip", "buildIdmlImageScript"], "category": "internal"}, {"source": "./ExportView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx", "sourceCode": "export default function PageLayoutEditor({\n  pageId,\n  pageName,\n  simulationRunId,\n}: Readonly<PageLayoutEditorProps>) {\n  const [override, setOverride] = useState<PageLayoutOverride | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [dirty, setDirty] = useState(false);\n\n  // Load existing override\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getPageLayout(simulationRunId, pageId).then((result) => {\n      if (!cancelled) {\n        setOverride(result);\n        setLoading(false);\n        setDirty(false);\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId, pageId]);\n\n  const update = useCallback(\n    <K extends OverrideField>(field: K, value: PageLayoutOverride[K] | undefined) => {\n      setOverride((prev) => {\n        const base = prev ?? { pageId, simulationRunId, updatedAt: Date.now() };\n        const next = { ...base, [field]: value === \"\" ? undefined : value, updatedAt: Date.now() };\n        return next;\n      });\n      setDirty(true);\n    },\n    [pageId, simulationRunId]\n  );\n\n  const handleSave = useCallback(async () => {\n    if (!override) return;\n    await putPageLayout(override);\n    setDirty(false);\n  }, [override]);\n\n  const handleClear = useCallback(async () => {\n    await deletePageLayout(simulationRunId, pageId);\n    setOverride(null);\n    setDirty(false);\n  }, [simulationRunId, pageId]);\n\n  if (loading) {\n    return (\n      <div className=\"preprint-layout-editor\">\n        <div className=\"preprint-layout-loading\">Loading...</div>\n      </div>\n    );\n  }\n\n  const hasOverride =\n    override &&\n    Object.keys(override).some(\n      (k) =>\n        ![\"pageId\", \"simulationRunId\", \"updatedAt\"].includes(k) &&\n        (override as any)[k] !== undefined\n    );\n\n  return (\n    <div className=\"preprint-layout-editor\">\n      <div className=\"preprint-layout-header\">\n        <span className=\"preprint-layout-title\" title={pageName}>\n          Layout: {pageName}\n        </span>\n        {hasOverride && (\n          <button\n            className=\"preprint-layout-clear\"\n            onClick={() => void handleClear()}\n            title=\"Reset to engine defaults\"\n          >\n            Clear\n          </button>\n        )}\n      </div>\n\n      <div className=\"preprint-layout-fields\">\n        <SelectField\n          label=\"Layout Mode\"\n          value={override?.layoutMode ?? \"\"}\n          options={LAYOUT_MODES}\n          onChange={(v) => update(\"layoutMode\", (v as LayoutMode) || undefined)}\n        />\n\n        <SelectField\n          label=\"Annotations\"\n          value={override?.annotationDisplay ?? \"\"}\n          options={ANNOTATION_DISPLAY}\n          onChange={(v) => update(\"annotationDisplay\", (v as AnnotationDisplay) || undefined)}\n        />\n\n        <SelectField\n          label=\"Note Position\"\n          value={override?.annotationPosition ?? \"\"}\n          options={ANNOTATION_POSITION}\n          onChange={(v) => update(\"annotationPosition\", (v as AnnotationPosition) || undefined)}\n        />\n\n        <SelectField\n          label=\"Image Layout\"\n          value={override?.imageLayout ?? \"\"}\n          options={IMAGE_LAYOUT}\n          onChange={(v) => update(\"imageLayout\", (v as ImageLayout) || undefined)}\n        />\n\n        <SelectField\n          label=\"Content Width\"\n          value={override?.contentWidth ?? \"\"}\n          options={CONTENT_WIDTH}\n          onChange={(v) => update(\"contentWidth\", (v as ContentWidth) || undefined)}\n        />\n\n        <SelectField\n          label=\"Text Align\"\n          value={override?.textAlign ?? \"\"}\n          options={TEXT_ALIGN}\n          onChange={(v) => update(\"textAlign\", (v as TextAlign) || undefined)}\n        />\n\n        <div className=\"preprint-layout-row\">\n          <label className=\"preprint-layout-label\">\n            <input\n              type=\"checkbox\"\n              checked={override?.dropcap ?? false}\n              onChange={(e) => update(\"dropcap\", e.target.checked || undefined)}\n            />\n            Drop cap\n          </label>\n        </div>\n\n        <div className=\"preprint-layout-row\">\n          <label htmlFor=\"custom-css-class\" className=\"preprint-layout-label-block\">Custom CSS class</label>\n          <input id=\"custom-css-class\"\n            type=\"text\"\n            className=\"preprint-input preprint-layout-text\"\n            value={override?.customClass ?? \"\"}\n            onChange={(e) => update(\"customClass\", e.target.value || undefined)}\n            placeholder=\"e.g. my-custom-layout\"\n          />\n        </div>\n      </div>\n\n      {dirty && (\n        <div className=\"preprint-layout-actions\">\n          <button className=\"preprint-layout-save\" onClick={() => void handleSave()}>\n            Save\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  pageId,\n  pageName,\n  simulationRunId,\n}", "type": "Readonly<PageLayoutEditorProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["PageLayoutOverride", "LayoutMode", "AnnotationDisplay", "AnnotationPosition", "ImageLayout", "ContentWidth", "TextAlign"], "category": "internal"}, {"source": "../../lib/db/pageLayoutRepository", "specifiers": ["getPageLayout", "putPageLayout", "deletePageLayout"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/StatsView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/StatsView.tsx", "sourceCode": "export default function StatsView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}: Readonly<StatsViewProps>) {\n  const [stats, setStats] = useState<PrePrintStats | null>(null);\n  const [calculating, setCalculating] = useState(false);\n\n  const handleCalculate = useCallback(() => {\n    setCalculating(true);\n    // Use setTimeout to allow UI to show spinner before computation blocks\n    setTimeout(() => {\n      const result = computePrePrintStats(entities, chronicles, images, staticPages, eraNarratives);\n      setStats(result);\n      setCalculating(false);\n    }, 50);\n  }, [entities, chronicles, images, staticPages, eraNarratives]);\n\n  if (!stats) {\n    return (\n      <div className=\"preprint-stats-empty\">\n        <p className=\"sv-empty-msg\">\n          Calculate statistics for print preparation. This scans all entities, chronicles, era\n          narratives, images, and static pages to produce word counts, image inventory, and\n          completeness checks.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCalculate} disabled={calculating}>\n          {calculating ? \"Calculating...\" : \"Calculate Stats\"}\n        </button>\n      </div>\n    );\n  }\n\n  const wb = stats.wordBreakdown;\n  const cb = stats.charBreakdown;\n  const img = stats.images;\n  const comp = stats.completeness;\n  const hn = stats.historianNotes;\n\n  return (\n    <div className=\"preprint-stats\">\n      <div className=\"preprint-stats-header\">\n        <span className=\"sv-calc-meta\">\n          Calculated {new Date(stats.calculatedAt).toLocaleString()}\n        </span>\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCalculate}\n          disabled={calculating}\n        >\n          {calculating ? \"Recalculating...\" : \"Recalculate\"}\n        </button>\n      </div>\n\n      {/* Page Estimate */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Page Estimate</h2>\n        </div>\n        <div className=\"preprint-stats-hero\">\n          <div className=\"preprint-stats-hero-number\">{stats.estimatedPages.toLocaleString()}</div>\n          <div className=\"preprint-stats-hero-label\">estimated pages (250 words/page)</div>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total words</span>\n          <span className=\"preprint-stats-value\">{stats.totalWords.toLocaleString()}</span>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total characters</span>\n          <span className=\"preprint-stats-value\">{stats.totalChars.toLocaleString()}</span>\n        </div>\n      </div>\n\n      {/* Word Count Breakdown */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Word & Character Counts</h2>\n        </div>\n        <div className=\"preprint-stats-table\">\n          <div className=\"preprint-stats-table-header\">\n            <span>Content Type</span>\n            <span>Words</span>\n            <span>Chars</span>\n            <span>% of Total</span>\n          </div>\n          <WordRow\n            label=\"Chronicle body text\"\n            words={wb.chronicleBody}\n            chars={cb.chronicleBody}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Chronicle summaries\"\n            words={wb.chronicleSummaries}\n            chars={cb.chronicleSummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Era narrative content\"\n            words={wb.eraNarrativeContent}\n            chars={cb.eraNarrativeContent}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity descriptions\"\n            words={wb.entityDescriptions}\n            chars={cb.entityDescriptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity summaries\"\n            words={wb.entitySummaries}\n            chars={cb.entitySummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Image captions\"\n            words={wb.imageCaptions}\n            chars={cb.imageCaptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (entity)\"\n            words={wb.historianNotesEntity}\n            chars={cb.historianNotesEntity}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (chronicle)\"\n            words={wb.historianNotesChronicle}\n            chars={cb.historianNotesChronicle}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Static page content\"\n            words={wb.staticPageContent}\n            chars={cb.staticPageContent}\n            total={stats.totalWords}\n          />\n        </div>\n      </div>\n\n      {/* Image Inventory */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Inventory</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total images</span>\n          <span className=\"preprint-stats-value\">{img.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Total storage</span>\n          <span className=\"preprint-stats-value\">{formatBytes(img.totalStorageBytes)}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Orientation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Portrait</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.portrait} ({pct(img.byAspect.portrait, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Landscape</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.landscape} ({pct(img.byAspect.landscape, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Square</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.square} ({pct(img.byAspect.square, img.total)})\n          </span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n        <div className=\"preprint-stats-row\">\n          <span>Entity portraits</span>\n          <span className=\"preprint-stats-value\">{img.byType.entity}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Chronicle scenes</span>\n          <span className=\"preprint-stats-value\">{img.byType.chronicle}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Cover images</span>\n          <span className=\"preprint-stats-value\">{img.byType.cover}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Size Designation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Small (inline)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.small}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Medium (half-page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.medium}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Large (3/4 page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.large}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Full-width</span>\n          <span className=\"preprint-stats-value\">{img.bySize[\"full-width\"]}</span>\n        </div>\n\n        {img.dimensionRange && (\n          <>\n            <div className=\"preprint-stats-subsection\">Dimensions (pixels)</div>\n            <div className=\"preprint-stats-row\">\n              <span>Width range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minWidth} \u2013 {img.dimensionRange.maxWidth}px\n              </span>\n            </div>\n            <div className=\"preprint-stats-row\">\n              <span>Height range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minHeight} \u2013 {img.dimensionRange.maxHeight}px\n              </span>\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Completeness */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Completeness</h2>\n        </div>\n        <CompletenessRow\n          label=\"Entities with description\"\n          count={comp.entitiesWithDescription}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with image\"\n          count={comp.entitiesWithImage}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with summary\"\n          count={comp.entitiesWithSummary}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles published\"\n          count={comp.chroniclesPublished}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with historian notes\"\n          count={comp.chroniclesWithHistorianNotes}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with scene images\"\n          count={comp.chroniclesWithSceneImages}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives complete\"\n          count={comp.eraNarrativesComplete}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives with cover image\"\n          count={comp.eraNarrativesWithCoverImage}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Static pages published\"\n          count={comp.staticPagesPublished}\n          total={comp.staticPagesTotal}\n        />\n      </div>\n\n      {/* Historian Notes */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Historian Notes</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total notes</span>\n          <span className=\"preprint-stats-value\">{hn.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On entities</span>\n          <span className=\"preprint-stats-value\">{hn.onEntities}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On chronicles</span>\n          <span className=\"preprint-stats-value\">{hn.onChronicles}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}", "type": "Readonly<StatsViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["PrePrintStats"], "category": "internal"}, {"source": "../../lib/db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../../lib/staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../../lib/preprint/prePrintStats", "specifiers": ["computePrePrintStats", "ImageMetadataRecord"], "category": "internal"}, {"source": "./StatsView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx", "sourceCode": "export default function TreeNodeRenderer({\n  node,\n  style,\n  dragHandle\n}: Readonly<NodeRendererProps<TreeNodeData>>) {\n  const data = node.data;\n  const meta = data.meta;\n  const isFolder = data.type === \"folder\";\n  return <div className={`preprint-tree-node ${node.isSelected ? \"selected\" : \"\"} ${isFolder ? \"folder\" : \"content\"}`} ref={dragHandle} onClick={() => node.isInternal && node.toggle()} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }} style={style}>\n      <span className=\"preprint-tree-node-icon\" title={TYPE_LABELS[data.type] || data.type}>\n        {(() => {\n        if (isFolder) return node.isOpen ? \"\\u{1F4C2}\" : \"\\u{1F4C1}\";\n        return TYPE_ICONS[data.type] || \"?\";\n      })()}\n      </span>\n\n      {node.isEditing ? <input type=\"text\" className=\"preprint-tree-node-edit\" defaultValue={data.name}\n    // eslint-disable-next-line jsx-a11y/no-autofocus\n    autoFocus onBlur={() => node.reset()} onKeyDown={e => {\n      if (e.key === \"Enter\") node.submit((e.target as HTMLInputElement).value);\n      if (e.key === \"Escape\") node.reset();\n    }} /> : <span className=\"preprint-tree-node-name\" title={data.name}>\n          {data.name}\n        </span>}\n\n      {!isFolder && meta && <span className=\"preprint-tree-node-meta\">\n          {meta.wordCount !== undefined && <span className=\"preprint-tree-node-wc\" title=\"Word count\">\n              {meta.wordCount.toLocaleString()}w\n            </span>}\n          {meta.imageCount !== undefined && meta.imageCount > 0 && <span className=\"preprint-tree-node-ic\" title=\"Images\">\n              \\u25A3 {meta.imageCount}\n            </span>}\n          <span className=\"preprint-tree-node-status\" title={(() => {\n        if (meta.hasDescription && meta.hasImage) return \"Complete\";\n        if (meta.hasDescription) return \"Missing image\";\n        return \"Missing content\";\n      })()} style={{\n        '--tree-status-color': (() => {\n          if (meta.hasDescription && meta.hasImage) return \"#22c55e\";\n          if (meta.hasDescription) return \"#f59e0b\";\n          return \"#ef4444\";\n        })()\n      } as React.CSSProperties}>\n            {(() => {\n          if (meta.hasDescription && meta.hasImage) return \"\\u25CF\";\n          if (meta.hasDescription) return \"\\u25D2\";\n          return \"\\u25CB\";\n        })()}\n          </span>\n        </span>}\n    </div>;\n}", "parameters": [{"name": "{\n  node,\n  style,\n  dragHandle\n}", "type": "Readonly<NodeRendererProps<TreeNodeData>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react-arborist", "specifiers": ["NodeRendererProps"], "category": "external"}, {"source": "../../lib/preprint/prePrintTypes", "specifiers": ["ContentTreeNode"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/focus.ts::applyFocusToContext", "name": "applyFocusToContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/focus.ts", "sourceCode": "export function applyFocusToContext(\n  context: ChronicleGenerationContext,\n  focus: NarrativeFocus\n): ChronicleGenerationContext {\n  const entitySet = new Set(focus.selectedEntityIds);\n  const eventSet = new Set(focus.selectedEventIds);\n\n  const filteredEntities = context.entities.filter((e) => entitySet.has(e.id));\n  const filteredEvents = context.events.filter((e) => eventSet.has(e.id));\n  const filteredRelationships = context.relationships.filter(\n    (r) => entitySet.has(r.src) && entitySet.has(r.dst)\n  );\n\n  return {\n    ...context,\n    entities: filteredEntities,\n    events: filteredEvents,\n    relationships: filteredRelationships,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "focus", "type": "NarrativeFocus", "optional": false}], "returnType": "ChronicleGenerationContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleTypes", "specifiers": ["ChronicleGenerationContext", "NarrativeFocus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::toCulture", "name": "toCulture", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Convert CultureDefinition (Canonry) to Culture (name-forge)\n */\nexport function toCulture(def: CultureDefinition): Culture | null {\n  if (!def.naming) return null;\n\n  return {\n    id: def.id,\n    name: def.name,\n    description: def.description,\n    domains: def.naming.domains || [],\n    lexemeLists: def.naming.lexemeLists || {},\n    grammars: def.naming.grammars || [],\n    profiles: def.naming.profiles || [],\n  };\n}", "parameters": [{"name": "def", "type": "CultureDefinition", "optional": false}], "returnType": "Culture | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "name-forge", "specifiers": ["generate"], "category": "external"}, {"source": "name-forge", "specifiers": ["Culture"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["CultureDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::generateNameBank", "name": "generateNameBank", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Generate a name bank for the given cultures.\n *\n * @param cultures - All culture definitions from the project\n * @param cultureIds - Culture IDs to generate names for\n * @returns Map of culture ID -> array of generated names\n */\nexport async function generateNameBank(\n  cultures: CultureDefinition[],\n  cultureIds: string[]\n): Promise<Record<string, string[]>> {\n  const nameBank: Record<string, string[]> = {};\n  const uniqueCultureIds = [...new Set(cultureIds)];\n\n  for (const cultureId of uniqueCultureIds) {\n    const cultureDef = cultures.find((c) => c.id === cultureId);\n    if (!cultureDef) continue;\n\n    const culture = toCulture(cultureDef);\n    if (!culture) continue;\n\n    try {\n      const result = await generate(culture, {\n        kind: \"npc\",\n        count: NAMES_PER_CULTURE,\n        seed: `namebank-${cultureId}-${Date.now()}`,\n      });\n      nameBank[cultureId] = result.names;\n    } catch (e) {\n      console.warn(`[NameBank] Failed to generate names for culture ${cultureId}:`, e);\n      // Continue without names for this culture\n    }\n  }\n\n  return nameBank;\n}", "parameters": [{"name": "cultures", "type": "CultureDefinition[]", "optional": false}, {"name": "cultureIds", "type": "string[]", "optional": false}], "returnType": "Promise<Record<string, string[]>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "name-forge", "specifiers": ["generate"], "category": "external"}, {"source": "name-forge", "specifiers": ["Culture"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["CultureDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::extractCultureIds", "name": "extractCultureIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Extract unique culture IDs from a list of entities.\n */\nexport function extractCultureIds(entities: Array<{ culture?: string }>): string[] {\n  const cultureIds = entities\n    .map((e) => e.culture)\n    .filter((c): c is string => c !== undefined && c !== null && c !== \"\");\n  return [...new Set(cultureIds)];\n}", "parameters": [{"name": "entities", "type": "Array<{ culture?: string }>", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "name-forge", "specifiers": ["generate"], "category": "external"}, {"source": "name-forge", "specifiers": ["Culture"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["CultureDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildEntityLookup", "name": "buildEntityLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildEntityLookup(\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): Map<string, { name: string; kind?: string }> {\n  const lookup = new Map<string, { name: string; kind?: string }>();\n\n  for (const entity of entities) {\n    lookup.set(entity.id, { name: entity.name, kind: entity.kind });\n  }\n\n  for (const rel of relationships) {\n    if (!lookup.has(rel.src)) {\n      lookup.set(rel.src, { name: rel.sourceName, kind: rel.sourceKind });\n    }\n    if (!lookup.has(rel.dst)) {\n      lookup.set(rel.dst, { name: rel.targetName, kind: rel.targetKind });\n    }\n  }\n\n  return lookup;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "Map<string, { name: string; kind?: string }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildRelationshipPairSummaries", "name": "buildRelationshipPairSummaries", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildRelationshipPairSummaries(\n  entityIds: string[],\n  relationships: RelationshipContext[]\n): RelationshipPairSummary[] {\n  const uniqueIds = Array.from(new Set(entityIds));\n  const adjacency = buildAdjacency(relationships);\n  const summaries: RelationshipPairSummary[] = [];\n\n  for (let i = 0; i < uniqueIds.length; i += 1) {\n    const entityAId = uniqueIds[i];\n    const neighborsA = collectNeighborLinks(adjacency, entityAId);\n\n    for (let j = i + 1; j < uniqueIds.length; j += 1) {\n      const entityBId = uniqueIds[j];\n      const neighborsB = collectNeighborLinks(adjacency, entityBId);\n\n      const direct = (adjacency.get(entityAId) || []).filter(\n        (rel) => rel.src === entityBId || rel.dst === entityBId\n      );\n\n      const sharedNeighbors: SharedNeighborLink[] = [];\n      for (const [neighborId, linksFromA] of neighborsA.entries()) {\n        const linksFromB = neighborsB.get(neighborId);\n        if (!linksFromB) continue;\n        sharedNeighbors.push({ neighborId, linksFromA, linksFromB });\n      }\n\n      sharedNeighbors.sort((a, b) => a.neighborId.localeCompare(b.neighborId));\n\n      summaries.push({\n        entityAId,\n        entityBId,\n        direct,\n        sharedNeighbors,\n      });\n    }\n  }\n\n  return summaries;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "RelationshipPairSummary[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildKindToCategoryMap", "name": "buildKindToCategoryMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Category Resolution\n// =============================================================================\n\n/**\n * Build a mapping from entity kind to its category.\n * Used to resolve domain-agnostic categories to domain-specific kinds at runtime.\n */\nexport function buildKindToCategoryMap(\n  entityKinds: EntityKindDefinition[]\n): Map<string, EntityCategory> {\n  const map = new Map<string, EntityCategory>();\n  for (const kind of entityKinds) {\n    if (kind.category) {\n      map.set(kind.kind, kind.category);\n    }\n  }\n  return map;\n}", "parameters": [{"name": "entityKinds", "type": "EntityKindDefinition[]", "optional": false}], "returnType": "Map<string, EntityCategory>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildNeighborGraph", "name": "buildNeighborGraph", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build a graph of entities reachable within maxDepth hops from entrypoint.\n */\nexport function buildNeighborGraph(\n  relationships: RelationshipContext[],\n  entrypointId: string,\n  maxDepth: number = 2\n): NeighborGraph {\n  const adjacency = new Map<string, Set<string>>();\n  for (const rel of relationships) {\n    if (!adjacency.has(rel.src)) adjacency.set(rel.src, new Set());\n    if (!adjacency.has(rel.dst)) adjacency.set(rel.dst, new Set());\n    adjacency.get(rel.src).add(rel.dst);\n    adjacency.get(rel.dst).add(rel.src);\n  }\n\n  const distances = new Map<string, number>();\n  const queue: Array<{ id: string; depth: number }> = [{ id: entrypointId, depth: 0 }];\n  distances.set(entrypointId, 0);\n\n  while (queue.length > 0) {\n    const { id, depth } = queue.shift();\n    if (depth >= maxDepth) continue;\n    const neighbors = adjacency.get(id);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (distances.has(neighbor)) continue;\n      distances.set(neighbor, depth + 1);\n      queue.push({ id: neighbor, depth: depth + 1 });\n    }\n  }\n\n  return { ids: new Set(distances.keys()), distances };\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "entrypointId", "type": "string", "optional": false}, {"name": "maxDepth", "type": "number", "optional": true}], "returnType": "NeighborGraph", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEntityMetrics", "name": "computeEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single entity.\n */\nexport function computeEntityMetrics(\n  entity: EntityContext,\n  ctx: MetricsContext\n): EntitySelectionMetrics {\n  const {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  } = ctx;\n\n  // Distance\n  const distance = distances.get(entity.id) ?? 99;\n\n  // Average relationship strength to entry point\n  const relsToEntry = relationships.filter(\n    (r) =>\n      (r.src === entity.id && r.dst === entryPointId) ||\n      (r.dst === entity.id && r.src === entryPointId)\n  );\n  const avgStrength =\n    relsToEntry.length > 0\n      ? relsToEntry.reduce((sum, r) => sum + (r.strength ?? 0.5), 0) / relsToEntry.length\n      : 0;\n\n  // Usage count\n  const usage = usageStats.get(entity.id);\n  const usageCount = usage?.usageCount ?? 0;\n\n  // Era alignment - check if entity shares any era with entry point\n  const entityEraId = resolveEntityEraId(entity);\n  const eraAligned =\n    entryPointEras.size === 0 || (entityEraId !== undefined && entryPointEras.has(entityEraId));\n\n  // Category novelty\n  const entityCategory = kindToCategory.get(entity.kind);\n  const addsNewCategory =\n    entityCategory !== undefined && !currentCastCategories.has(entityCategory);\n\n  // Relationship type diversity\n  const entityRelTypes = new Set(\n    relationships.filter((r) => r.src === entity.id || r.dst === entity.id).map((r) => r.kind)\n  );\n  const newRelTypes = [...entityRelTypes].filter((t) => !currentCastRelTypes.has(t)).length;\n\n  return {\n    entityId: entity.id,\n    distance,\n    avgStrength,\n    usageCount,\n    eraAligned,\n    addsNewCategory,\n    newRelTypes,\n  };\n}", "parameters": [{"name": "entity", "type": "EntityContext", "optional": false}, {"name": "ctx", "type": "MetricsContext", "optional": false}], "returnType": "EntitySelectionMetrics", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEntityMetrics", "name": "computeAllEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate entities.\n */\nexport function computeAllEntityMetrics(\n  candidates: EntityContext[],\n  entryPointId: string,\n  relationships: RelationshipContext[],\n  distances: Map<string, number>,\n  usageStats: Map<string, { usageCount: number }>,\n  currentAssignments: ChronicleRoleAssignment[],\n  kindToCategory: Map<string, EntityCategory>\n): Map<string, EntitySelectionMetrics> {\n  const entryPointEraId = resolveEntityEraId(candidates.find((e) => e.id === entryPointId));\n  const entryPointEras = new Set(entryPointEraId ? [entryPointEraId] : []);\n\n  // Get current cast's categories and relationship types\n  const assignedIds = new Set(currentAssignments.map((a) => a.entityId));\n  const currentCastCategories = new Set<EntityCategory>();\n  const currentCastRelTypes = new Set<string>();\n\n  for (const assignment of currentAssignments) {\n    const entity = candidates.find((e) => e.id === assignment.entityId);\n    if (entity) {\n      const cat = kindToCategory.get(entity.kind);\n      if (cat) currentCastCategories.add(cat);\n    }\n  }\n\n  for (const rel of relationships) {\n    if (assignedIds.has(rel.src) || assignedIds.has(rel.dst)) {\n      currentCastRelTypes.add(rel.kind);\n    }\n  }\n\n  const ctx: MetricsContext = {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  };\n\n  const metricsMap = new Map<string, EntitySelectionMetrics>();\n  for (const entity of candidates) {\n    metricsMap.set(entity.id, computeEntityMetrics(entity, ctx));\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "distances", "type": "Map<string, number>", "optional": false}, {"name": "usageStats", "type": "Map<string, { usageCount: number }>", "optional": false}, {"name": "currentAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}], "returnType": "Map<string, EntitySelectionMetrics>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalScope", "name": "computeTemporalScope", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Temporal Utilities\n// =============================================================================\n\n/**\n * Compute temporal scope from tick range.\n */\nexport function computeTemporalScope(\n  tickRange: [number, number],\n  isMultiEra: boolean\n): TemporalScope {\n  const duration = tickRange[1] - tickRange[0];\n\n  if (isMultiEra) return \"saga\";\n  if (duration >= 50) return \"saga\";\n  if (duration >= 20) return \"arc\";\n  if (duration >= 5) return \"episode\";\n  return \"moment\";\n}", "parameters": [{"name": "tickRange", "type": "[number, number]", "optional": false}, {"name": "isMultiEra", "type": "boolean", "optional": false}], "returnType": "TemporalScope", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::findEraForEvent", "name": "findEraForEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Find era for an event - by direct ID match.\n */\nexport function findEraForEvent(\n  event: { tick: number; era?: string },\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  // Direct ID match (event.era should match era.id)\n  if (event.era) {\n    const byId = eras.find((e) => e.id === event.era);\n    if (byId) return byId;\n  }\n  return undefined;\n}", "parameters": [{"name": "event", "type": "{ tick: number; era?: string }", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeFocalEra", "name": "computeFocalEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the focal era from a set of events.\n * Returns the era that contains the most events.\n */\nexport function computeFocalEra(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  if (events.length === 0 || eras.length === 0) {\n    return eras[0]; // Default to first era\n  }\n\n  // Count events per era\n  const eraCounts = new Map<string, number>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) {\n      eraCounts.set(era.id, (eraCounts.get(era.id) || 0) + 1);\n    }\n  }\n\n  // Find era with most events\n  let maxCount = 0;\n  let focalEraId: string | undefined;\n  for (const [eraId, count] of eraCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      focalEraId = eraId;\n    }\n  }\n\n  return eras.find((e) => e.id === focalEraId) || eras[0];\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalContext", "name": "computeTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the complete temporal context for a chronicle.\n */\nexport function computeTemporalContext(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[],\n  entryPoint?: EntityContext,\n  focalEraOverrideId?: string | null\n): ChronicleTemporalContext {\n  // Compute tick range from events\n  let minTick = Infinity;\n  let maxTick = -Infinity;\n\n  for (const event of events) {\n    minTick = Math.min(minTick, event.tick);\n    maxTick = Math.max(maxTick, event.tick);\n  }\n\n  // Include entry point creation tick if available\n  if (entryPoint) {\n    minTick = Math.min(minTick, entryPoint.createdAt);\n  }\n\n  // Handle edge case of no events\n  if (minTick === Infinity) {\n    minTick = entryPoint?.createdAt ?? 0;\n    maxTick = minTick;\n  }\n\n  const chronicleTickRange: [number, number] = [minTick, maxTick];\n\n  // Find touched eras by event era IDs\n  const touchedEraIds = new Set<string>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) touchedEraIds.add(era.id);\n  }\n\n  const isMultiEra = touchedEraIds.size > 1;\n  const temporalScope = computeTemporalScope(chronicleTickRange, isMultiEra);\n\n  // Compute focal era (use override if provided)\n  const overrideEra = focalEraOverrideId\n    ? eras.find((e) => e.id === focalEraOverrideId)\n    : undefined;\n  const focalEra = overrideEra || computeFocalEra(events, eras) || eras[0];\n\n  // Build temporal description\n  const temporalDescription = buildTemporalDescription(\n    focalEra,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds.size\n  );\n\n  return {\n    focalEra,\n    allEras: eras,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds: Array.from(touchedEraIds),\n    temporalDescription,\n  };\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "entryPoint", "type": "EntityContext", "optional": true}, {"name": "focalEraOverrideId", "type": "string | null", "optional": true}], "returnType": "ChronicleTemporalContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEventMetrics", "name": "computeEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single event.\n */\nexport function computeEventMetrics(\n  event: NarrativeEventContext,\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): EventSelectionMetrics {\n  // Use event era ID and resolve name from eras when possible\n  const eventEra = findEraForEvent(event, eras);\n  const eraId = eventEra?.id || event.era;\n  const eraName = eventEra?.name || event.era;\n\n  // Count how many assigned entities are involved\n  let assignedCount = 0;\n  if (event.subjectId && assignedEntityIds.has(event.subjectId)) assignedCount++;\n  if (event.objectId && assignedEntityIds.has(event.objectId)) assignedCount++;\n\n  // Check if event involves entry point\n  const involvesEntryPoint = event.subjectId === entryPointId || event.objectId === entryPointId;\n\n  return {\n    eventId: event.id,\n    tick: event.tick,\n    eraId,\n    eraName,\n    inFocalEra: eraId === focalEraId,\n    tickDistance: Math.abs(event.tick - entryPointTick),\n    involvesEntryPoint,\n    assignedEntityCount: assignedCount,\n    significance: event.significance,\n  };\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "EventSelectionMetrics", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEventMetrics", "name": "computeAllEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate events.\n */\nexport function computeAllEventMetrics(\n  events: NarrativeEventContext[],\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): Map<string, EventSelectionMetrics> {\n  const metricsMap = new Map<string, EventSelectionMetrics>();\n\n  for (const event of events) {\n    metricsMap.set(\n      event.id,\n      computeEventMetrics(event, entryPointId, entryPointTick, focalEraId, eras, assignedEntityIds)\n    );\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "Map<string, EventSelectionMetrics>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::scoreEventForSelection", "name": "scoreEventForSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Score an event for selection based on temporal alignment and relevance.\n */\nexport function scoreEventForSelection(\n  event: NarrativeEventContext,\n  metrics: EventSelectionMetrics,\n  preferFocalEra: boolean = true\n): number {\n  let score = 0;\n\n  // Base score from significance\n  score += metrics.significance * 30;\n\n  // Bonus for involving entry point\n  if (metrics.involvesEntryPoint) {\n    score += 20;\n  }\n\n  // Bonus for involving multiple assigned entities\n  score += metrics.assignedEntityCount * 10;\n\n  // Era alignment bonus/penalty\n  if (preferFocalEra) {\n    if (metrics.inFocalEra) {\n      score += 15;\n    } else {\n      score -= 10; // Soft penalty for cross-era events\n    }\n  }\n\n  // Temporal proximity bonus (closer to entry point creation = more relevant)\n  // Diminishing returns: 0-10 ticks = 10pts, 10-50 ticks = 5pts, 50+ ticks = 0pts\n  if (metrics.tickDistance <= 10) {\n    score += 10;\n  } else if (metrics.tickDistance <= 50) {\n    score += 5;\n  }\n\n  // Small randomization to break ties\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security tie-breaking jitter\n  score += Math.random() * 3;\n\n  return score;\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "metrics", "type": "EventSelectionMetrics", "optional": false}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestEventSelection", "name": "suggestEventSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Auto-select events based on temporal alignment and relevance.\n * Returns event IDs sorted by score.\n */\nexport function suggestEventSelection(\n  events: NarrativeEventContext[],\n  metricsMap: Map<string, EventSelectionMetrics>,\n  maxEvents: number = 8,\n  preferFocalEra: boolean = true\n): string[] {\n  const scored = events.map((event) => {\n    const metrics = metricsMap.get(event.id);\n    if (!metrics) return { id: event.id, score: 0 };\n    return {\n      id: event.id,\n      score: scoreEventForSelection(event, metrics, preferFocalEra),\n    };\n  });\n\n  scored.sort((a, b) => b.score - a.score);\n\n  return scored.slice(0, maxEvents).map((s) => s.id);\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "metricsMap", "type": "Map<string, EventSelectionMetrics>", "optional": false}, {"name": "maxEvents", "type": "number", "optional": true}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestRoleAssignments", "name": "suggestRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "export function suggestRoleAssignments(\n  candidates: EntityContext[],\n  roles: RoleDefinition[],\n  entryPointId: string,\n  _rules: unknown, // Deprecated - entity selection rules removed\n  relationships: RelationshipContext[],\n  _kindToCategory: Map<string, EntityCategory>,\n  metricsMap?: Map<string, EntitySelectionMetrics>\n): ChronicleRoleAssignment[] {\n  const assignments: ChronicleRoleAssignment[] = [];\n  const usedEntityIds = new Set<string>();\n\n  const entryPoint = candidates.find((e) => e.id === entryPointId);\n  const roleScores = buildRoleScores(candidates, roles, relationships, metricsMap);\n\n  if (entryPoint) {\n    assignEntryPoint(entryPoint, roles, assignments, usedEntityIds);\n  }\n\n  assignRemainingRoles(roles, roleScores, assignments, usedEntityIds);\n\n  return assignments;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "_rules", "type": "unknown", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "_kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}, {"name": "metricsMap", "type": "Map<string, EntitySelectionMetrics>", "optional": true}], "returnType": "ChronicleRoleAssignment[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::validateRoleAssignments", "name": "validateRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Role Assignment Validation\n// =============================================================================\n\n/**\n * Validate role assignments against style constraints.\n */\nexport function validateRoleAssignments(\n  assignments: ChronicleRoleAssignment[],\n  roles: RoleDefinition[],\n  maxCastSize: number\n): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check total cast size\n  if (assignments.length > maxCastSize) {\n    errors.push(`Too many entities assigned (${assignments.length}/${maxCastSize} max)`);\n  }\n\n  // Check each role's min/max constraints\n  for (const roleDef of roles) {\n    const roleCount = assignments.filter((a) => a.role === roleDef.role).length;\n\n    if (roleCount < roleDef.count.min) {\n      if (roleDef.count.min === 1) {\n        errors.push(`Role \"${roleDef.role}\" requires at least 1 entity`);\n      } else {\n        errors.push(\n          `Role \"${roleDef.role}\" requires at least ${roleDef.count.min} entities (has ${roleCount})`\n        );\n      }\n    }\n\n    if (roleCount > roleDef.count.max) {\n      warnings.push(`Role \"${roleDef.role}\" has ${roleCount} entities (max ${roleDef.count.max})`);\n    }\n  }\n\n  // Check for duplicate entity assignments\n  const entityCounts = new Map<string, number>();\n  for (const assignment of assignments) {\n    const count = entityCounts.get(assignment.entityId) || 0;\n    entityCounts.set(assignment.entityId, count + 1);\n  }\n  for (const [entityId, count] of entityCounts) {\n    if (count > 1) {\n      const entity = assignments.find((a) => a.entityId === entityId);\n      warnings.push(`Entity \"${entity?.entityName}\" is assigned to ${count} roles`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "maxCastSize", "type": "number", "optional": false}], "returnType": "ValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantRelationships", "name": "getRelevantRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Relationship & Event Selection\n// =============================================================================\n\n/**\n * Get relationships between assigned entities.\n */\nexport function getRelevantRelationships(\n  assignments: ChronicleRoleAssignment[],\n  allRelationships: RelationshipContext[],\n  extraEntityIds?: Iterable<string>\n): RelationshipContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n  if (extraEntityIds) {\n    for (const id of extraEntityIds) assignedIds.add(id);\n  }\n  return allRelationships.filter((r) => assignedIds.has(r.src) && assignedIds.has(r.dst));\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "extraEntityIds", "type": "Iterable<string>", "optional": true}], "returnType": "RelationshipContext[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::makeRelationshipId", "name": "makeRelationshipId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Create relationship ID from components.\n */\nexport function makeRelationshipId(src: string, dst: string, kind: string): string {\n  return `${src}:${dst}:${kind}`;\n}", "parameters": [{"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::collapseBidirectionalRelationships", "name": "collapseBidirectionalRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Collapse bidirectional relationships into single entries.\n * A\u2194B shown once instead of A\u2192B and B\u2192A separately.\n */\nexport function collapseBidirectionalRelationships(\n  relationships: RelationshipContext[]\n): CollapsedRelationship[] {\n  const result: CollapsedRelationship[] = [];\n  const processed = new Set<string>();\n\n  // Index relationships by normalized key (sorted src/dst + kind)\n  const byNormalizedKey = new Map<string, RelationshipContext[]>();\n  for (const rel of relationships) {\n    const normalizedKey = [rel.src, rel.dst].sort((a, b) => a.localeCompare(b)).join(\":\") + \":\" + rel.kind;\n    const existing = byNormalizedKey.get(normalizedKey) || [];\n    existing.push(rel);\n    byNormalizedKey.set(normalizedKey, existing);\n  }\n\n  for (const rel of relationships) {\n    const relId = makeRelationshipId(rel.src, rel.dst, rel.kind);\n    if (processed.has(relId)) continue;\n    processed.add(relId);\n\n    // Check for reverse relationship\n    const reverseId = makeRelationshipId(rel.dst, rel.src, rel.kind);\n    const reverseRel = relationships.find(\n      (r) => r.src === rel.dst && r.dst === rel.src && r.kind === rel.kind\n    );\n\n    if (reverseRel && !processed.has(reverseId)) {\n      // Bidirectional - collapse into one entry\n      processed.add(reverseId);\n      const avgStrength = ((rel.strength ?? 0.5) + (reverseRel.strength ?? 0.5)) / 2;\n      result.push({\n        primary: rel,\n        reverse: reverseRel,\n        isBidirectional: true,\n        relationshipIds: [relId, reverseId],\n        strength: avgStrength,\n      });\n    } else {\n      // Unidirectional\n      result.push({\n        primary: rel,\n        reverse: undefined,\n        isBidirectional: false,\n        relationshipIds: [relId],\n        strength: rel.strength ?? 0.5,\n      });\n    }\n  }\n\n  return result;\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "CollapsedRelationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantEvents", "name": "getRelevantEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Get events involving assigned entities.\n * Returns ALL matching events - UI is responsible for limiting final selection.\n */\nexport function getRelevantEvents(\n  assignments: ChronicleRoleAssignment[],\n  allEvents: NarrativeEventContext[]\n): NarrativeEventContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n\n  // Return all events involving assigned entities - no artificial limit\n  // Final selection is limited to MAX_CHRONICLE_EVENTS in the UI\n  return allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && assignedIds.has(e.subjectId)) ||\n      (e.objectId && assignedIds.has(e.objectId))\n  );\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "NarrativeEventContext[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::isProminenceOnlyChronicleEvent", "name": "isProminenceOnlyChronicleEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Check if an event is prominence-only based on its stateChanges.\n * An event is \"prominence-only\" if ALL of its state changes are\n * field === 'prominence' changes. These events are typically noise\n * (gradual prominence shifts) rather than narratively interesting.\n */\nexport function isProminenceOnlyChronicleEvent(\n  event: NarrativeEventContext,\n  assignedEntityIds: Set<string>\n): boolean {\n  // Events with no stateChanges are NOT prominence-only (they might be actions, relationships, etc.)\n  if (!event.stateChanges || event.stateChanges.length === 0) {\n    return false;\n  }\n\n  // Only consider stateChanges for assigned entities\n  const relevantChanges = event.stateChanges.filter((sc) => assignedEntityIds.has(sc.entityId));\n\n  // If no relevant changes, not prominence-only\n  if (relevantChanges.length === 0) {\n    return false;\n  }\n\n  // Check if ALL relevant changes are prominence changes\n  return relevantChanges.every((sc) => sc.field === \"prominence\");\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::filterChronicleEvents", "name": "filterChronicleEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Filter chronicle events by quality criteria.\n * Applies significance threshold and prominence-only exclusion.\n *\n * @param events - Events to filter (typically from getRelevantEvents)\n * @param assignedEntityIds - Set of assigned entity IDs for prominence check\n * @param options - Filter options\n * @returns Filtered events\n */\nexport function filterChronicleEvents(\n  events: NarrativeEventContext[],\n  assignedEntityIds: Set<string>,\n  options: ChronicleEventFilterOptions = {}\n): NarrativeEventContext[] {\n  const { minSignificance = 0, excludeProminenceOnly = true } = options;\n\n  return events.filter((event) => {\n    // Filter by significance threshold\n    if (event.significance < minSignificance) {\n      return false;\n    }\n\n    // Exclude prominence-only events if configured\n    if (excludeProminenceOnly && isProminenceOnlyChronicleEvent(event, assignedEntityIds)) {\n      return false;\n    }\n\n    return true;\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "options", "type": "ChronicleEventFilterOptions", "optional": true}], "returnType": "NarrativeEventContext[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildWizardSelectionContext", "name": "buildWizardSelectionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build the selection context for the wizard given an entry point.\n * Returns candidates within 2-hop neighborhood.\n */\nexport function buildWizardSelectionContext(\n  entryPoint: EntityContext,\n  allEntities: EntityContext[],\n  allRelationships: RelationshipContext[],\n  allEvents: NarrativeEventContext[],\n  style: NarrativeStyle,\n  options: SelectionContextOptions = {}\n): WizardSelectionContext {\n  const { includeErasInNeighborhood = false } = options;\n\n  // Build set of era entity IDs for filtering\n  const eraEntityIds = new Set(allEntities.filter((e) => e.kind === \"era\").map((e) => e.id));\n\n  // Filter relationships for graph traversal - exclude those involving era nodes\n  const graphRelationships = includeErasInNeighborhood\n    ? allRelationships\n    : allRelationships.filter((r) => !eraEntityIds.has(r.src) && !eraEntityIds.has(r.dst));\n\n  // Build 2-hop neighborhood\n  const neighborGraph = buildNeighborGraph(graphRelationships, entryPoint.id, 2);\n\n  // Filter entities to those in the neighborhood\n  const neighborEntities = allEntities.filter((e) => neighborGraph.ids.has(e.id));\n\n  // Filter out era entities \u2014 they're time periods, not cast members\n  const filteredCandidates = neighborEntities.filter((e) => e.kind !== \"era\");\n\n  // Ensure entry point is included\n  const candidates = filteredCandidates.some((e) => e.id === entryPoint.id)\n    ? filteredCandidates\n    : [entryPoint, ...filteredCandidates];\n\n  // Get relationships between candidates\n  const candidateIds = new Set(candidates.map((e) => e.id));\n  const candidateRelationships = allRelationships.filter(\n    (r) => candidateIds.has(r.src) && candidateIds.has(r.dst)\n  );\n\n  // Get events involving candidates + world-structuring events (always available)\n  const candidateEvents = allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && candidateIds.has(e.subjectId)) ||\n      (e.objectId && candidateIds.has(e.objectId))\n  );\n\n  return {\n    entryPoint,\n    candidates,\n    candidateRelationships,\n    candidateEvents,\n    distances: neighborGraph.distances,\n  };\n}", "parameters": [{"name": "entryPoint", "type": "EntityContext", "optional": false}, {"name": "allEntities", "type": "EntityContext[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "options", "type": "SelectionContextOptions", "optional": true}], "returnType": "WizardSelectionContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext", "TemporalScope"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition", "EntityCategory", "EntityKindDefinition"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeStoryPotential", "name": "computeStoryPotential", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Compute story potential for a single entity\n */\nexport function computeStoryPotential(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[],\n  maxValues: {\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }\n): StoryPotential {\n  const entity = entities.find((e) => e.id === entityId);\n  if (!entity) {\n    return {\n      connections: 0,\n      temporalSpan: 0,\n      roleDiversity: 0,\n      eventInvolvement: 0,\n      prominence: 0,\n      overallScore: 0,\n    };\n  }\n\n  // Count connections\n  const entityRels = relationships.filter((r) => r.src === entityId || r.dst === entityId);\n  const connectionCount = entityRels.length;\n\n  // Get connected entity kinds\n  const connectedIds = new Set<string>();\n  for (const rel of entityRels) {\n    connectedIds.add(rel.src === entityId ? rel.dst : rel.src);\n  }\n  const connectedKinds = new Set<string>();\n  for (const id of connectedIds) {\n    const connected = entities.find((e) => e.id === id);\n    if (connected) connectedKinds.add(connected.kind);\n  }\n\n  // Count events and get eras\n  const entityEvents = events.filter(\n    (e) =>\n      e.subjectId === entityId ||\n      e.objectId === entityId ||\n      e.participants?.some((p) => p.id === entityId)\n  );\n  const eventCount = entityEvents.length;\n  const eraIds = new Set(entityEvents.map((e) => e.era));\n\n  // Normalize values\n  const connections =\n    maxValues.maxConnections > 0 ? Math.min(connectionCount / maxValues.maxConnections, 1) : 0;\n\n  const temporalSpan = maxValues.maxEras > 0 ? Math.min(eraIds.size / maxValues.maxEras, 1) : 0;\n\n  const roleDiversity =\n    maxValues.maxKinds > 0 ? Math.min(connectedKinds.size / maxValues.maxKinds, 1) : 0;\n\n  const eventInvolvement =\n    maxValues.maxEvents > 0 ? Math.min(eventCount / maxValues.maxEvents, 1) : 0;\n\n  const prominence = normalizeProminence(entity.prominence);\n\n  // Compute weighted score\n  const overallScore =\n    WEIGHTS.connections * connections +\n    WEIGHTS.temporalSpan * temporalSpan +\n    WEIGHTS.roleDiversity * roleDiversity +\n    WEIGHTS.eventInvolvement * eventInvolvement +\n    WEIGHTS.prominence * prominence;\n\n  return {\n    connections,\n    temporalSpan,\n    roleDiversity,\n    eventInvolvement,\n    prominence,\n    overallScore,\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "maxValues", "type": "{\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }", "optional": false}], "returnType": "StoryPotential", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeAllStoryPotentials", "name": "computeAllStoryPotentials", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "export function computeAllStoryPotentials(\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[]\n): Map<string, EntityWithPotential> {\n  const rawStats = new Map<string, RawEntityStats>();\n  let maxConnections = 0;\n  let maxEvents = 0;\n  let maxKinds = 0;\n  let maxEras = 0;\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = computeEntityRawStats(entity, entities, relationships, events);\n    rawStats.set(entity.id, stats);\n    maxConnections = Math.max(maxConnections, stats.connectionCount);\n    maxEvents = Math.max(maxEvents, stats.eventCount);\n    maxKinds = Math.max(maxKinds, stats.connectedKinds.length);\n    maxEras = Math.max(maxEras, stats.eraIds.length);\n  }\n\n  const result = new Map<string, EntityWithPotential>();\n  const maxValues = { maxConnections, maxEvents, maxKinds, maxEras };\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = rawStats.get(entity.id);\n    if (!stats) continue;\n\n    const potential = computeStoryPotential(entity.id, entities, relationships, events, maxValues);\n    result.set(entity.id, { ...entity, potential, ...stats });\n  }\n\n  return result;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "Map<string, EntityWithPotential>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getConnectedEntities", "name": "getConnectedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get 1-hop connected entities for mini constellation\n */\nexport function getConnectedEntities(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): ConnectedEntity[] {\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const connected: ConnectedEntity[] = [];\n\n  for (const rel of relationships) {\n    let connectedId: string | null = null;\n\n    if (rel.src === entityId) {\n      connectedId = rel.dst;\n    } else if (rel.dst === entityId) {\n      connectedId = rel.src;\n    }\n\n    if (connectedId) {\n      const entity = entityMap.get(connectedId);\n      if (entity && entity.kind !== \"era\") {\n        // Avoid duplicates but track all relationship kinds\n        const existing = connected.find((c) => c.id === connectedId);\n        if (!existing) {\n          connected.push({\n            id: connectedId,\n            name: entity.name,\n            kind: entity.kind,\n            relationshipKind: rel.kind,\n            strength: rel.strength,\n          });\n        }\n      }\n    }\n  }\n\n  return connected;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "ConnectedEntity[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getUniqueKinds", "name": "getUniqueKinds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get unique entity kinds from a list\n */\nexport function getUniqueKinds(entities: EntityContext[]): string[] {\n  const kinds = new Set<string>();\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") {\n      kinds.add(entity.kind);\n    }\n  }\n  return [...kinds].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::scoreToRating", "name": "scoreToRating", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Convert story score to visual rating (1-5 dots)\n */\nexport function scoreToRating(score: number): number {\n  return Math.max(1, Math.min(5, Math.round(score * 5)));\n}", "parameters": [{"name": "score", "type": "number", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEraRanges", "name": "getEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Convert eras to era ranges for timeline display.\n * Uses the actual era boundaries - no computation.\n */\nexport function getEraRanges(\n  eras: Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n): EraRange[] {\n  return eras.map((era, i) => ({\n    id: era.id,\n    name: era.name,\n    startTick: era.startTick,\n    endTick: era.endTick ?? era.startTick + 100, // fallback for ongoing era\n    color: ERA_COLORS[i % ERA_COLORS.length],\n  }));\n}", "parameters": [{"name": "eras", "type": "Array<{ id: string; name: string; startTick: number; endTick: number | null }>", "optional": false}], "returnType": "EraRange[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareTimelineEvents", "name": "prepareTimelineEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Transform events into timeline format\n */\nexport function prepareTimelineEvents(\n  events: NarrativeEventContext[],\n  entryPointId: string | null,\n  assignedEntityIds: Set<string>,\n  selectedEventIds: Set<string>\n): TimelineEvent[] {\n  return events.map((event) => {\n    const participants = event.participants || [];\n    const participantIds = new Set(participants.map((p) => p.id));\n\n    // Check if entry point or subject/object\n    const involvesEntryPoint =\n      entryPointId !== null &&\n      (event.subjectId === entryPointId ||\n        event.objectId === entryPointId ||\n        participantIds.has(entryPointId));\n\n    // Check if any cast member is involved\n    const involvesCastMember = [...assignedEntityIds].some(\n      (id) => event.subjectId === id || event.objectId === id || participantIds.has(id)\n    );\n\n    return {\n      id: event.id,\n      tick: event.tick,\n      eraId: event.era,\n      headline: event.headline,\n      description: event.description,\n      significance: event.significance,\n      involvesEntryPoint,\n      involvesCastMember,\n      participantCount: participants.length + (event.subjectId ? 1 : 0) + (event.objectId ? 1 : 0),\n      eventKind: event.eventKind,\n      selected: selectedEventIds.has(event.id),\n    };\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string | null", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "selectedEventIds", "type": "Set<string>", "optional": false}], "returnType": "TimelineEvent[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeIntensityCurve", "name": "computeIntensityCurve", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Compute intensity curve for sparkline\n * Uses a rolling window to smooth the data\n */\nexport function computeIntensityCurve(\n  events: NarrativeEventContext[],\n  windowSize: number = 10\n): IntensityPoint[] {\n  if (events.length === 0) return [];\n\n  // Sort by tick\n  const sorted = [...events].sort((a, b) => a.tick - b.tick);\n  const minTick = sorted[0].tick;\n  const maxTick = sorted[sorted.length - 1].tick;\n\n  // Create intensity map\n  const tickSignificance = new Map<number, number>();\n  for (const event of sorted) {\n    const current = tickSignificance.get(event.tick) || 0;\n    tickSignificance.set(event.tick, current + event.significance);\n  }\n\n  // Generate points at regular intervals\n  const numPoints = Math.min(50, maxTick - minTick + 1);\n  const step = Math.max(1, Math.floor((maxTick - minTick) / numPoints));\n  const points: IntensityPoint[] = [];\n\n  for (let tick = minTick; tick <= maxTick; tick += step) {\n    // Sum significance in window around this tick\n    let intensity = 0;\n    const halfWindow = Math.floor(windowSize / 2);\n\n    for (const [t, sig] of tickSignificance) {\n      if (t >= tick - halfWindow && t <= tick + halfWindow) {\n        // Weight by distance from center\n        const distance = Math.abs(t - tick);\n        const weight = 1 - distance / (halfWindow + 1);\n        intensity += sig * weight;\n      }\n    }\n\n    points.push({ tick, intensity });\n  }\n\n  // Normalize to 0-1\n  const maxIntensity = Math.max(...points.map((p) => p.intensity), 0.001);\n  return points.map((p) => ({\n    tick: p.tick,\n    intensity: p.intensity / maxIntensity,\n  }));\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "windowSize", "type": "number", "optional": true}], "returnType": "IntensityPoint[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventsInRange", "name": "getEventsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get events within a tick range\n */\nexport function getEventsInRange(\n  events: TimelineEvent[],\n  startTick: number,\n  endTick: number\n): TimelineEvent[] {\n  return events.filter((e) => e.tick >= startTick && e.tick <= endTick);\n}", "parameters": [{"name": "events", "type": "TimelineEvent[]", "optional": false}, {"name": "startTick", "type": "number", "optional": false}, {"name": "endTick", "type": "number", "optional": false}], "returnType": "TimelineEvent[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getTimelineExtent", "name": "getTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get timeline extent from era boundaries.\n * Returns [0, maxEndTick] - the full simulation range.\n */\nexport function getTimelineExtent(\n  eras: Array<{ startTick: number; endTick: number | null }>\n): [number, number] {\n  if (eras.length === 0) return [0, 100];\n\n  const maxTick = Math.max(...eras.map((e) => e.endTick ?? e.startTick + 100));\n\n  return [0, maxTick];\n}", "parameters": [{"name": "eras", "type": "Array<{ startTick: number; endTick: number | null }>", "optional": false}], "returnType": "[number, number]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::tickToX", "name": "tickToX", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale a tick value to SVG x coordinate\n */\nexport function tickToX(\n  tick: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  return padding + ((tick - minTick) / range) * usableWidth;\n}", "parameters": [{"name": "tick", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::xToTick", "name": "xToTick", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale SVG x coordinate back to tick value\n */\nexport function xToTick(\n  x: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  const normalized = (x - padding) / usableWidth;\n  return Math.round(minTick + normalized * range);\n}", "parameters": [{"name": "x", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventFill", "name": "getEventFill", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get fill pattern based on involvement level\n */\nexport function getEventFill(event: TimelineEvent): string {\n  if (event.involvesEntryPoint) return \"var(--accent-color)\";\n  if (event.involvesCastMember) return \"var(--accent-color-muted, rgba(99, 102, 241, 0.6))\";\n  return \"var(--text-muted)\";\n}", "parameters": [{"name": "event", "type": "TimelineEvent", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventHeight", "name": "getEventHeight", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get event height based on significance (for visual weight)\n */\nexport function getEventHeight(\n  significance: number,\n  maxHeight: number = 40,\n  minHeight: number = 16\n): number {\n  return minHeight + significance * (maxHeight - minHeight);\n}", "parameters": [{"name": "significance", "type": "number", "optional": false}, {"name": "maxHeight", "type": "number", "optional": true}, {"name": "minHeight", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerShape", "name": "getCastMarkerShape", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get SVG path data for a cast marker based on entity kind.\n * Paths are centered at (0,0) \u2014 use transform to position.\n */\nexport function getCastMarkerShape(kind: string): { path: string; size: number } {\n  switch (kind) {\n    case \"person\":\n      // Diamond\n      return { path: \"M 0 -4 L 4 0 L 0 4 L -4 0 Z\", size: 8 };\n    case \"faction\":\n      // Circle\n      return { path: \"M 0 -3.5 A 3.5 3.5 0 1 1 0 3.5 A 3.5 3.5 0 1 1 0 -3.5 Z\", size: 7 };\n    case \"location\":\n      // Square\n      return { path: \"M -3 -3 L 3 -3 L 3 3 L -3 3 Z\", size: 6 };\n    case \"occurrence\":\n      // 6-pointed star (outer=4, inner=2)\n      return {\n        path: \"M 0 -4 L 1 -1.7 L 3.5 -2 L 2 0 L 3.5 2 L 1 1.7 L 0 4 L -1 1.7 L -3.5 2 L -2 0 L -3.5 -2 L -1 -1.7 Z\",\n        size: 8,\n      };\n    default:\n      // Triangle\n      return { path: \"M 0 -3.5 L 3.5 3 L -3.5 3 Z\", size: 7 };\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "{ path: string; size: number }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerColor", "name": "getCastMarkerColor", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get color for a cast marker based on entity kind.\n * Uses a pastel palette distinct from event card fills.\n */\nexport function getCastMarkerColor(kind: string): string {\n  switch (kind) {\n    case \"person\":\n      return \"#818cf8\";\n    case \"faction\":\n      return \"#a78bfa\";\n    case \"location\":\n      return \"#34d399\";\n    case \"occurrence\":\n      return \"#fbbf24\";\n    case \"ability\":\n      return \"#f472b6\";\n    case \"rule\":\n      return \"#22d3ee\";\n    default:\n      return \"#9ca3af\";\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareCastMarkers", "name": "prepareCastMarkers", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Build cast markers from role assignments, lens, and entity data.\n * Includes the entry point and lens (if provided) and dedupes by entity ID.\n */\nexport function prepareCastMarkers(\n  roleAssignments: ChronicleRoleAssignment[],\n  entityMap: Map<string, EntityContext>,\n  entryPoint?: EntityContext | null,\n  lens?: NarrativeLens | null\n): CastMarker[] {\n  const seen = new Set<string>();\n  const markers: CastMarker[] = [];\n\n  if (entryPoint) {\n    seen.add(entryPoint.id);\n    markers.push({\n      entityId: entryPoint.id,\n      entityName: entryPoint.name,\n      entityKind: entryPoint.kind,\n      subtype: entryPoint.subtype,\n      createdAt: entryPoint.createdAt,\n      isPrimary: true,\n      isEntryPoint: true,\n      isLens: false,\n    });\n  }\n\n  if (lens && !seen.has(lens.entityId)) {\n    seen.add(lens.entityId);\n    const lensEntity = entityMap.get(lens.entityId);\n    if (lensEntity) {\n      markers.push({\n        entityId: lens.entityId,\n        entityName: lens.entityName,\n        entityKind: lens.entityKind,\n        subtype: lensEntity.subtype,\n        createdAt: lensEntity.createdAt,\n        isPrimary: false,\n        isEntryPoint: false,\n        isLens: true,\n      });\n    }\n  }\n\n  for (const assignment of roleAssignments) {\n    if (seen.has(assignment.entityId)) continue;\n    seen.add(assignment.entityId);\n\n    const entity = entityMap.get(assignment.entityId);\n    if (!entity) continue;\n\n    markers.push({\n      entityId: assignment.entityId,\n      entityName: assignment.entityName,\n      entityKind: assignment.entityKind,\n      subtype: entity.subtype,\n      createdAt: entity.createdAt,\n      role: assignment.role,\n      isPrimary: assignment.isPrimary,\n      isEntryPoint: false,\n      isLens: false,\n    });\n  }\n\n  markers.sort((a, b) => a.createdAt - b.createdAt);\n  return markers;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "entityMap", "type": "Map<string, EntityContext>", "optional": false}, {"name": "entryPoint", "type": "EntityContext | null", "optional": true}, {"name": "lens", "type": "NarrativeLens | null", "optional": true}], "returnType": "CastMarker[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeEraRanges", "name": "computeEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeEraRanges = (\n  _events: NarrativeEventContext[],\n  eras: Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>\n) =>\n  getEraRanges(\n    eras as Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n  )", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>", "optional": false}], "returnType": "EraRange[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeTimelineExtent", "name": "computeTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeTimelineExtent = (\n  _events: NarrativeEventContext[],\n  eras?: Array<{ endTick?: number | null; startTick?: number }>\n): [number, number] => {\n  if (!eras || eras.length === 0) return [0, 100];\n  return getTimelineExtent(eras as Array<{ startTick: number; endTick: number | null }>);\n}", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ endTick?: number | null; startTick?: number }>", "optional": true}], "returnType": "[number, number]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["NarrativeEventContext", "EntityContext", "ChronicleRoleAssignment", "NarrativeLens"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleNav.ts::buildNavItem", "name": "buildNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleNav.ts", "sourceCode": "export function buildNavItem(record: ChronicleRecord): ChronicleNavItem {\n  const primaryCount = record.roleAssignments?.filter((r) => r.isPrimary).length || 0;\n  const supportingCount = (record.roleAssignments?.length || 0) - primaryCount;\n  const historianNoteCount = (record.historianNotes || []).filter(isNoteActive).length;\n  const displayName =\n    record.title ||\n    (record.roleAssignments?.length > 0\n      ? record.roleAssignments\n          .filter((r) => r.isPrimary)\n          .map((r) => r.entityName)\n          .join(\" & \") || record.roleAssignments[0]?.entityName\n      : \"\") ||\n    \"Untitled Chronicle\";\n\n  const backportProgress = computeBackportProgress(record);\n\n  let focalEraOrder: number | undefined;\n  if (typeof record.temporalContext?.focalEra?.order === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.order;\n  } else if (typeof record.temporalContext?.focalEra?.startTick === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.startTick;\n  }\n\n  return {\n    id: record.chronicleId,\n    chronicleId: record.chronicleId,\n    name: displayName,\n    status: deriveStatus(record),\n    title: record.title,\n    format: record.format,\n    focusType: record.focusType,\n    primaryCount,\n    supportingCount,\n    narrativeStyleId: record.narrativeStyleId,\n    narrativeStyleName: record.narrativeStyle?.name,\n    perspectiveSynthesis: !!record.perspectiveSynthesis,\n    combineInstructions: !!record.combineInstructions,\n    coverImageComplete: record.coverImage?.status === \"complete\",\n    backportDone: backportProgress.done,\n    backportTotal: backportProgress.total,\n    historianNoteCount,\n    lens: record.lens ? { entityName: record.lens.entityName } : undefined,\n    imageRefCompleteCount:\n      record.imageRefs?.refs?.filter(\n        (r: { type: string; status?: string }) =>\n          r.type === \"prompt_request\" && r.status === \"complete\"\n      ).length || 0,\n    failureStep: record.failureStep,\n    createdAt: record.createdAt || 0,\n    updatedAt: record.updatedAt || 0,\n    selectedEntityIds: record.selectedEntityIds,\n    roleAssignments: record.roleAssignments,\n    wordCount: (record.finalContent || record.assembledContent || \"\")\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean).length,\n    focalEraName: record.temporalContext?.focalEra?.name,\n    focalEraOrder,\n    focalEraStartTick: record.temporalContext?.focalEra?.startTick,\n    eraYear: record.eraYear,\n    hasTemporalNarrative: !!record.perspectiveSynthesis?.temporalNarrative,\n    hasTemporalCheck: !!record.temporalCheckReport,\n    hasHistorianPrep: !!record.historianPrep,\n    hasSummary: !!record.summary,\n    toneRanking: record.toneRanking?.ranking,\n    assignedTone: record.assignedTone,\n    eraNarrativeWeight: record.narrativeStyle?.eraNarrativeWeight,\n  };\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleNavItem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive"], "category": "internal"}, {"source": "../../hooks/useChronicleGeneration", "specifiers": ["deriveStatus"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["computeBackportProgress"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::generateChronicleId", "name": "generateChronicleId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Pure functions (no DB access)\n// ============================================================================\n\n/**\n * Generate a unique chronicle ID\n */\nexport function generateChronicleId(): string {\n  return `chronicle_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveTitleFromRoles", "name": "deriveTitleFromRoles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Derive a title from role assignments\n */\nexport function deriveTitleFromRoles(roleAssignments: ChronicleRoleAssignment[]): string {\n  const primary = roleAssignments.filter((r) => r.isPrimary);\n  if (primary.length === 0) {\n    const first = roleAssignments[0];\n    return first ? `Chronicle of ${first.entityName}` : \"Untitled Chronicle\";\n  }\n  if (primary.length === 1) {\n    return `Chronicle of ${primary[0].entityName}`;\n  }\n  if (primary.length === 2) {\n    return `${primary[0].entityName} and ${primary[1].entityName}`;\n  }\n  return `${primary[0].entityName} and ${primary.length - 1} others`;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveFocusType", "name": "deriveFocusType", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Determine focus type from role assignments\n */\nexport function deriveFocusType(roleAssignments: ChronicleRoleAssignment[]): ChronicleFocusType {\n  const primaryCount = roleAssignments.filter((r) => r.isPrimary).length;\n  if (primaryCount <= 1) return \"single\";\n  return \"ensemble\";\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "ChronicleFocusType", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicleShell", "name": "createChronicleShell", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Create operations\n// ============================================================================\n\n/**\n * Create a shell chronicle record before generation starts.\n * This provides immediate UI feedback while generation is in progress.\n */\nexport async function createChronicleShell(\n  chronicleId: string,\n  metadata: ChronicleShellMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    generationSampling: metadata.generationSampling,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation state - starts as 'generating'\n    status: \"generating\",\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: 0,\n    totalActualCost: 0,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleShellMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicle", "name": "createChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Create a chronicle record (single-shot generation, goes directly to assembly_ready)\n */\nexport async function createChronicle(\n  chronicleId: string,\n  metadata: ChronicleMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const assembledAt = Date.now();\n  const activeVersionId = createUniqueVersionId(new Set(), assembledAt);\n  const initialVersion: ChronicleGenerationVersion = {\n    versionId: activeVersionId,\n    generatedAt: assembledAt,\n    content: metadata.assembledContent,\n    wordCount: countWords(metadata.assembledContent),\n    model: metadata.model,\n    sampling: metadata.generationSampling,\n    systemPrompt: metadata.generationSystemPrompt,\n    userPrompt: metadata.generationUserPrompt,\n    step: \"generate\",\n  };\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation result\n    selectionSummary: metadata.selectionSummary,\n    perspectiveSynthesis: metadata.perspectiveSynthesis,\n    generationSystemPrompt: metadata.generationSystemPrompt,\n    generationUserPrompt: metadata.generationUserPrompt,\n    generationSampling: metadata.generationSampling,\n    generationStep: \"generate\",\n    generationHistory: [initialVersion],\n    activeVersionId,\n    status: \"assembly_ready\",\n    assembledContent: metadata.assembledContent,\n    assembledAt,\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: metadata.cost.estimated,\n    totalActualCost: metadata.cost.actual,\n    totalInputTokens: metadata.cost.inputTokens,\n    totalOutputTokens: metadata.cost.outputTokens,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssembly", "name": "updateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read-modify-write operations\n// ============================================================================\n\n/**\n * Update chronicle with assembled content (regeneration)\n */\nexport async function updateChronicleAssembly(\n  chronicleId: string,\n  assembledContent: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.updatedAt = Date.now();\n  record.activeVersionId = nextVersion.versionId;\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::regenerateChronicleAssembly", "name": "regenerateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Replace chronicle assembled content via sampling regeneration.\n * Appends a new version to generationHistory and clears refinements.\n */\nexport async function regenerateChronicleAssembly(\n  chronicleId: string,\n  updates: {\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is already accepted`);\n  }\n  if (!updates.sampling) {\n    throw new Error(`Chronicle ${chronicleId} missing sampling for regeneration`);\n  }\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: updates.assembledContent,\n    wordCount: countWords(updates.assembledContent),\n    model: updates.model,\n    sampling: updates.sampling,\n    systemPrompt: updates.systemPrompt,\n    userPrompt: updates.userPrompt,\n    step: updates.step,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = updates.assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.generationSystemPrompt = updates.systemPrompt;\n  record.generationUserPrompt = updates.userPrompt;\n  record.generationSampling = updates.sampling;\n  record.generationStep = updates.step;\n  record.activeVersionId = nextVersion.versionId;\n\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.editVersion = 0;\n  record.editedAt = undefined;\n\n  record.totalEstimatedCost += updates.cost.estimated;\n  record.totalActualCost += updates.cost.actual;\n  record.totalInputTokens += updates.cost.inputTokens;\n  record.totalOutputTokens += updates.cost.outputTokens;\n  record.model = updates.model;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEdit", "name": "updateChronicleEdit", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with revised content (post-validation edits)\n */\nexport async function updateChronicleEdit(\n  chronicleId: string,\n  assembledContent: string,\n  cost?: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.editedAt = generatedAt;\n  record.editVersion = (record.editVersion || 0) + 1;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.status = \"editing\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  if (cost) {\n    record.totalEstimatedCost += cost.estimated;\n    record.totalActualCost += cost.actual;\n    record.totalInputTokens += cost.inputTokens;\n    record.totalOutputTokens += cost.outputTokens;\n  }\n  record.activeVersionId = nextVersion.versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFailure", "name": "updateChronicleFailure", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as failed (worker error)\n */\nexport async function updateChronicleFailure(\n  chronicleId: string,\n  step: ChronicleStep,\n  reason: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"failed\";\n  record.failureStep = step;\n  record.failureReason = reason;\n  record.failedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "step", "type": "ChronicleStep", "optional": false}, {"name": "reason", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCohesion", "name": "updateChronicleCohesion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cohesion report (validation complete)\n */\nexport async function updateChronicleCohesion(\n  chronicleId: string,\n  cohesionReport: CohesionReport,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.cohesionReport = cohesionReport;\n  record.validatedAt = Date.now();\n  record.status = \"validation_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.validationStale = false;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "cohesionReport", "type": "CohesionReport", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}]