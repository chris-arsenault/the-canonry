[{"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleComparisonReport", "name": "updateChronicleComparisonReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Store a version comparison report (text analysis, no new draft).\n */\nexport async function updateChronicleComparisonReport(\n  chronicleId: string,\n  report: string,\n  combineInstructions?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.comparisonReport = report;\n  record.comparisonReportGeneratedAt = Date.now();\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalCheckReport", "name": "updateChronicleTemporalCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleTemporalCheckReport(\n  chronicleId: string,\n  report: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.temporalCheckReport = report;\n  record.temporalCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleQuickCheckReport", "name": "updateChronicleQuickCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleQuickCheckReport(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").QuickCheckReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.quickCheckReport = report;\n  record.quickCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").QuickCheckReport", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFactCoverage", "name": "updateChronicleFactCoverage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle fact coverage analysis report\n */\nexport async function updateChronicleFactCoverage(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").FactCoverageReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.factCoverageReport = report;\n  record.factCoverageReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").FactCoverageReport", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::repairFactCoverageWasFaceted", "name": "repairFactCoverageWasFaceted", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * One-shot fixup: recompute wasFaceted on all stored factCoverageReports\n * using perspectiveSynthesis.facets[].factId instead of fuzzy text matching.\n */\nexport async function repairFactCoverageWasFaceted(): Promise<number> {\n  const all = await db.chronicles.toArray();\n  let patched = 0;\n  for (const record of all) {\n    if (!record.factCoverageReport?.entries?.length) continue;\n    const facetedIds = new Set(\n      (record.perspectiveSynthesis?.facets ?? []).map((f: { factId: string }) => f.factId)\n    );\n    let changed = false;\n    for (const entry of record.factCoverageReport.entries) {\n      const correct = facetedIds.has(entry.factId);\n      if (entry.wasFaceted !== correct) {\n        entry.wasFaceted = correct;\n        changed = true;\n      }\n    }\n    if (changed) {\n      record.updatedAt = Date.now();\n      await db.chronicles.put(record);\n      patched++;\n    }\n  }\n  console.log(`[repairFactCoverageWasFaceted] Patched ${patched} chronicles`);\n  return patched;\n}", "parameters": [], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeCorpusFactStrength", "name": "computeCorpusFactStrength", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute corpus-wide fact strength scores from all chronicles with coverage reports.\n * Returns a Map of factId \u2192 strength percentage (0-100).\n * Weighted: integral=3, prevalent=2, mentioned=1, missing=0, divided by max possible.\n */\nexport async function computeCorpusFactStrength(\n  simulationRunId: string\n): Promise<Map<string, number>> {\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const totals = new Map<string, { weighted: number; count: number }>();\n\n  const ratingWeight: Record<string, number> = {\n    integral: 3,\n    prevalent: 2,\n    mentioned: 1,\n    missing: 0,\n  };\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.factCoverageReport?.entries?.length) continue;\n    for (const entry of chronicle.factCoverageReport.entries) {\n      const agg = totals.get(entry.factId) || { weighted: 0, count: 0 };\n      agg.weighted += ratingWeight[entry.rating] ?? 0;\n      agg.count += 1;\n      totals.set(entry.factId, agg);\n    }\n  }\n\n  const result = new Map<string, number>();\n  for (const [factId, agg] of totals) {\n    result.set(factId, agg.count > 0 ? Math.round((agg.weighted / (agg.count * 3)) * 100) : 0);\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, number>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeAnnotationReinforcementCounts", "name": "computeAnnotationReinforcementCounts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Count how many annotations have reinforced each canon fact.\n * Scans both chronicle.reinforcedFacts and entity.enrichment.reinforcedFacts.\n */\nexport async function computeAnnotationReinforcementCounts(\n  simulationRunId: string\n): Promise<ReinforcementCounts> {\n  const counts = new Map<string, number>();\n  let totalAnnotationsWithGuidance = 0;\n\n  // Chronicle reinforcements\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const c of chronicles) {\n    if (!c.reinforcedFacts?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of c.reinforcedFacts) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  // Entity reinforcements\n  const entities = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const e of entities) {\n    const rf = e.enrichment?.reinforcedFacts;\n    if (!rf?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of rf) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  return { counts, totalAnnotationsWithGuidance };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ReinforcementCounts>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTertiaryCast", "name": "updateChronicleTertiaryCast", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle tertiary cast (detected entity mentions not in declared cast)\n */\nexport async function updateChronicleTertiaryCast(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").TertiaryCastEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.tertiaryCast = entries;\n  record.tertiaryCastDetectedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").TertiaryCastEntry[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianPrep", "name": "updateChronicleHistorianPrep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with historian prep brief\n */\nexport async function updateChronicleHistorianPrep(\n  chronicleId: string,\n  historianPrep: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianPrep = historianPrep;\n  record.historianPrepGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianPrep", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleSummary", "name": "updateChronicleSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with summary and title refinement\n */\nexport async function updateChronicleSummary(\n  chronicleId: string,\n  summary: string,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.summary = summary;\n  record.summaryGeneratedAt = Date.now();\n  record.summaryModel = model;\n  record.summaryTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTitle", "name": "updateChronicleTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with title generation results.\n * Always writes to pending fields \u2014 user must accept via modal.\n */\nexport async function updateChronicleTitle(\n  chronicleId: string,\n  title: string,\n  candidates: string[],\n  fragments: string[],\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = title;\n  record.pendingTitleCandidates = candidates;\n  record.pendingTitleFragments = fragments;\n  record.titleFragments = fragments;\n  record.titleGeneratedAt = Date.now();\n  record.titleModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "title", "type": "string", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "fragments", "type": "string[]", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptPendingTitle", "name": "acceptPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Accept a pending title\n */\nexport async function acceptPendingTitle(chronicleId: string, chosenTitle?: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.pendingTitle) throw new Error(`No pending title for chronicle ${chronicleId}`);\n\n  record.title = chosenTitle || record.pendingTitle;\n  record.titleCandidates = record.pendingTitleCandidates;\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "chosenTitle", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::rejectPendingTitle", "name": "rejectPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reject a pending title on a published chronicle\n */\nexport async function rejectPendingTitle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRefs", "name": "updateChronicleImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with image refs refinement\n */\nexport async function updateChronicleImageRefs(\n  chronicleId: string,\n  imageRefs: ChronicleImageRefs,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.imageRefsGeneratedAt = Date.now();\n  record.imageRefsModel = model;\n  record.imageRefsTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRef", "name": "updateChronicleImageRef", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleImageRef(\n  chronicleId: string,\n  refId: string,\n  updates: {\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const refIndex = record.imageRefs.refs.findIndex((r) => r.refId === refId);\n  if (refIndex === -1) {\n    throw new Error(`Image ref ${refId} not found in chronicle ${chronicleId}`);\n  }\n\n  const ref = record.imageRefs.refs[refIndex];\n  const wantsPromptUpdates =\n    updates.status !== undefined ||\n    updates.generatedImageId !== undefined ||\n    updates.error !== undefined ||\n    updates.sceneDescription !== undefined;\n\n  if (wantsPromptUpdates && ref.type !== \"prompt_request\") {\n    throw new Error(`Image ref ${refId} is not a prompt request`);\n  }\n\n  applyBaseImageRefUpdates(ref, updates);\n  if (ref.type === \"prompt_request\") {\n    applyPromptRequestUpdates(ref, updates);\n  }\n\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::applyImageRefSelections", "name": "applyImageRefSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Apply image ref selections after version change.\n * - 'reuse': Keep the ref as-is\n * - 'regenerate': Reset the ref (clear generated image, set status to pending)\n * - 'skip': Remove the ref entirely\n *\n * Also updates imageRefsTargetVersionId to the new version.\n */\nexport async function applyImageRefSelections(\n  chronicleId: string,\n  selections: Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>,\n  newTargetVersionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const selectionMap = new Map(selections.map((s) => [s.refId, s.action]));\n\n  // Filter and transform refs based on selections\n  const updatedRefs = record.imageRefs.refs\n    .filter((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      return action !== \"skip\";\n    })\n    .map((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      if (action === \"regenerate\" && ref.type === \"prompt_request\") {\n        // Reset prompt request refs for regeneration\n        return {\n          ...ref,\n          status: \"pending\" as const,\n          generatedImageId: undefined,\n          error: undefined,\n        };\n      }\n      return ref;\n    });\n\n  record.imageRefs = {\n    ...record.imageRefs,\n    refs: updatedRefs,\n  };\n  record.imageRefsTargetVersionId = newTargetVersionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "selections", "type": "Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>", "optional": false}, {"name": "newTargetVersionId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImage", "name": "updateChronicleCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cover image scene description\n */\nexport async function updateChronicleCoverImage(\n  chronicleId: string,\n  coverImage: ChronicleCoverImage,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.coverImage = coverImage;\n  record.coverImageGeneratedAt = Date.now();\n  record.coverImageModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "coverImage", "type": "ChronicleCoverImage", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImageStatus", "name": "updateChronicleCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update cover image generation status (after image generation completes)\n */\nexport async function updateChronicleCoverImageStatus(\n  chronicleId: string,\n  updates: {\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.coverImage) throw new Error(`Chronicle ${chronicleId} has no cover image`);\n\n  record.coverImage.status = updates.status;\n  if (updates.generatedImageId !== undefined) {\n    record.coverImage.generatedImageId = updates.generatedImageId || undefined;\n  }\n  if (updates.error !== undefined) {\n    record.coverImage.error = updates.error || undefined;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalContext", "name": "updateChronicleTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle temporal context (e.g., post-publish corrections)\n */\nexport async function updateChronicleTemporalContext(\n  chronicleId: string,\n  temporalContext: ChronicleTemporalContext | undefined | null\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (temporalContext) {\n    record.temporalContext = temporalContext;\n  } else {\n    delete record.temporalContext;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "temporalContext", "type": "ChronicleTemporalContext | undefined | null", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::refreshEraSummariesInChronicles", "name": "refreshEraSummariesInChronicles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function refreshEraSummariesInChronicles(\n  simulationRunId: string,\n  currentEras: EraTemporalInfo[]\n): Promise<number> {\n  const summaryMap = new Map(currentEras.map((e) => [e.id, e.summary || \"\"]));\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const record of records) {\n    const changed = patchTemporalContext(record, summaryMap) || patchPerspectiveSynthesisFocalEra(record, summaryMap);\n    if (changed) {\n      record.updatedAt = Date.now();\n      toUpdate.push(record);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "currentEras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptChronicle", "name": "acceptChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as complete (user accepted)\n */\nexport async function acceptChronicle(\n  chronicleId: string,\n  options?: { finalContent?: string; acceptedVersionId?: string }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const fallbackActive = getLatestVersion(versions)?.versionId;\n  const activeVersionId = options?.acceptedVersionId || record.activeVersionId || fallbackActive;\n  const activeVersion = versions.find((v) => v.versionId === activeVersionId);\n  const acceptedVersionId = activeVersionId || record.acceptedVersionId;\n\n  record.finalContent = options?.finalContent ?? activeVersion?.content ?? record.assembledContent;\n  record.acceptedVersionId = acceptedVersionId;\n  record.activeVersionId = acceptedVersionId;\n  record.acceptedAt = Date.now();\n  record.status = \"complete\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "options", "type": "{ finalContent?: string; acceptedVersionId?: string }", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::unpublishChronicle", "name": "unpublishChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Unpublish a completed chronicle, reverting it to assembly_ready.\n */\nexport async function unpublishChronicle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  delete record.finalContent;\n  delete record.acceptedAt;\n  delete record.acceptedVersionId;\n  record.status = \"assembly_ready\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleActiveVersion", "name": "updateChronicleActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update which generation version should be published when accepting.\n */\nexport async function updateChronicleActiveVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before changing versions`);\n  }\n\n  ensureChronicleVersions(record);\n  if (!record.generationHistory?.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCombineInstructions", "name": "updateChronicleCombineInstructions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Manually set or update combine instructions for a chronicle.\n */\nexport async function updateChronicleCombineInstructions(\n  chronicleId: string,\n  combineInstructions: string | undefined\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  } else {\n    delete record.combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string | undefined", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicleVersion", "name": "deleteChronicleVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a specific version from a chronicle's generation history.\n * If the deleted version was the current or active version, switches to the most recent remaining version.\n */\nexport async function deleteChronicleVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before deleting versions`);\n  }\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const matchIndex = versions.findIndex((v) => v.versionId === versionId);\n  if (matchIndex === -1) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  if (versions.length <= 1) {\n    throw new Error(`Cannot delete the only version of chronicle ${chronicleId}`);\n  }\n\n  const latest = getLatestVersion(versions);\n  const isCurrentVersion = latest?.versionId === versionId;\n  const remaining = versions.filter((v) => v.versionId !== versionId);\n\n  if (isCurrentVersion) {\n    const nextLatest = getLatestVersion(remaining);\n    if (!nextLatest) {\n      throw new Error(`Cannot delete current version with no history to restore`);\n    }\n    record.assembledContent = nextLatest.content;\n    record.assembledAt = nextLatest.generatedAt;\n    record.model = nextLatest.model || record.model;\n    record.generationSystemPrompt = nextLatest.systemPrompt;\n    record.generationUserPrompt = nextLatest.userPrompt;\n    record.generationSampling = nextLatest.sampling;\n    record.generationStep = nextLatest.step;\n  }\n\n  record.generationHistory = remaining;\n\n  if (record.activeVersionId === versionId) {\n    record.activeVersionId = getLatestVersion(remaining)?.versionId;\n  }\n  if (record.summaryTargetVersionId === versionId) {\n    record.summaryTargetVersionId = record.activeVersionId;\n  }\n  if (record.imageRefsTargetVersionId === versionId) {\n    record.imageRefsTargetVersionId = record.activeVersionId;\n  }\n\n  record.updatedAt = Date.now();\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEntityBackportStatus", "name": "updateChronicleEntityBackportStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Merge per-entity backport status entries into a chronicle's entityBackportStatus map.\n */\nexport async function updateChronicleEntityBackportStatus(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").EntityBackportEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  const existing = record.entityBackportStatus || {};\n  for (const entry of entries) {\n    existing[entry.entityId] = entry;\n  }\n  record.entityBackportStatus = existing;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").EntityBackportEntry[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianNotes", "name": "updateChronicleHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update historian notes on a chronicle.\n */\nexport async function updateChronicleHistorianNotes(\n  chronicleId: string,\n  historianNotes: HistorianNote[],\n  prompts?: { systemPrompt: string; userPrompt: string },\n  reinforcedFacts?: string[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianNotes = historianNotes;\n  if (reinforcedFacts) {\n    record.reinforcedFacts = reinforcedFacts;\n  }\n  if (prompts) {\n    record.historianReviewSystemPrompt = prompts.systemPrompt;\n    record.historianReviewUserPrompt = prompts.userPrompt;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianNotes", "type": "HistorianNote[]", "optional": false}, {"name": "prompts", "type": "{ systemPrompt: string; userPrompt: string }", "optional": true}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::startChronicleValidation", "name": "startChronicleValidation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Start validation step (user approved assembly)\n */\nexport async function startChronicleValidation(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"validating\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::batchUpdateChronicleEraYears", "name": "batchUpdateChronicleEraYears", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read operations\n// ============================================================================\n\n/**\n * Get a chronicle record\n */\n/**\n * Batch update historian-assigned era years for multiple chronicles.\n */\nexport async function batchUpdateChronicleEraYears(\n  assignments: Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>\n): Promise<number> {\n  const ids = assignments.map((a) => a.chronicleId);\n  const records = await db.chronicles.where(\"chronicleId\").anyOf(ids).toArray();\n  const recordMap = new Map(records.map((r) => [r.chronicleId, r]));\n  const now = Date.now();\n\n  const toUpdate: ChronicleRecord[] = [];\n  for (const assignment of assignments) {\n    const record = recordMap.get(assignment.chronicleId);\n    if (!record) continue;\n    record.eraYear = assignment.eraYear;\n    record.eraYearReasoning = assignment.eraYearReasoning;\n    record.updatedAt = now;\n    toUpdate.push(record);\n  }\n\n  if (toUpdate.length > 0) {\n    await db.chronicles.bulkPut(toUpdate);\n  }\n\n  return toUpdate.length;\n}", "parameters": [{"name": "assignments", "type": "Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChronicle", "name": "getChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function getChronicle(chronicleId: string): Promise<ChronicleRecord | undefined> {\n  const record = await db.chronicles.get(chronicleId);\n  if (record && ensureChronicleVersions(record)) {\n    await db.chronicles.put(record);\n  }\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChroniclesForSimulation", "name": "getChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Get all chronicles for a specific simulation run\n */\nexport async function getChroniclesForSimulation(\n  simulationRunId: string\n): Promise<ChronicleRecord[]> {\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const updates: ChronicleRecord[] = [];\n  for (const record of records) {\n    if (ensureChronicleVersions(record)) {\n      updates.push(record);\n    }\n  }\n  if (updates.length > 0) {\n    await db.chronicles.bulkPut(updates);\n  }\n  return records;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicle", "name": "deleteChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a chronicle\n */\nexport async function deleteChronicle(chronicleId: string): Promise<void> {\n  await db.chronicles.delete(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChroniclesForSimulation", "name": "deleteChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete all chronicles for a simulation run\n */\nexport async function deleteChroniclesForSimulation(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  if (chronicles.length === 0) return 0;\n\n  const ids = chronicles.map((c) => c.chronicleId);\n  await db.chronicles.bulkDelete(ids);\n  return chronicles.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::putChronicle", "name": "putChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Entity Rename Support\n// ============================================================================\n\n/**\n * Write a fully-updated chronicle record back to the database.\n * Used by the entity rename flow to persist chronicle patches.\n */\nexport async function putChronicle(record: ChronicleRecord): Promise<void> {\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getEntityUsageStats", "name": "getEntityUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Computed queries\n// ============================================================================\n\n/**\n * Compute entity usage statistics from existing chronicles.\n * Returns a map of entityId -> usage stats.\n */\nexport async function getEntityUsageStats(\n  simulationRunId: string\n): Promise<Map<string, EntityUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, EntityUsageStats>();\n\n  for (const chronicle of chronicles) {\n    // Only count chronicles that have been generated (not just shells)\n    if (chronicle.status === \"generating\") continue;\n\n    for (const entityId of chronicle.selectedEntityIds) {\n      const existing = stats.get(entityId);\n      if (existing) {\n        existing.usageCount += 1;\n        existing.chronicleIds.push(chronicle.chronicleId);\n      } else {\n        stats.set(entityId, {\n          entityId,\n          usageCount: 1,\n          chronicleIds: [chronicle.chronicleId],\n        });\n      }\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, EntityUsageStats>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getNarrativeStyleUsageStats", "name": "getNarrativeStyleUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute narrative style usage statistics from existing chronicles.\n * Returns a map of styleId -> usage stats.\n */\nexport async function getNarrativeStyleUsageStats(\n  simulationRunId: string\n): Promise<Map<string, NarrativeStyleUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, NarrativeStyleUsageStats>();\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.narrativeStyleId) continue;\n\n    const existing = stats.get(chronicle.narrativeStyleId);\n    if (existing) {\n      existing.usageCount += 1;\n      existing.chronicleIds.push(chronicle.chronicleId);\n    } else {\n      stats.set(chronicle.narrativeStyleId, {\n        styleId: chronicle.narrativeStyleId,\n        usageCount: 1,\n        chronicleIds: [chronicle.chronicleId],\n      });\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, NarrativeStyleUsageStats>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::reconcileBackportStatusFromEntities", "name": "reconcileBackportStatusFromEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function reconcileBackportStatusFromEntities(\n  simulationRunId: string,\n  entities: Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>\n): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const entityBackrefs = buildEntityBackrefIndex(entities);\n  const now = Date.now();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const chronicle of chronicles) {\n    const eligibleIds = getEligibleEntityIds(chronicle);\n    const newStatus: Record<string, import(\"../chronicleTypes\").EntityBackportEntry> = {};\n    for (const entityId of eligibleIds) {\n      const backrefSet = entityBackrefs.get(entityId);\n      if (backrefSet && backrefSet.has(chronicle.chronicleId)) {\n        newStatus[entityId] = { entityId, status: \"backported\", updatedAt: now };\n      }\n    }\n\n    if (hasBackportStatusChanged(chronicle.entityBackportStatus || {}, newStatus)) {\n      chronicle.entityBackportStatus = newStatus;\n      chronicle.updatedAt = now;\n      toUpdate.push(chronicle);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::resetAllBackportFlags", "name": "resetAllBackportFlags", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reset entityBackportStatus on all chronicles in a simulation.\n * Returns the count of chronicles that were updated.\n */\nexport async function resetAllBackportFlags(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const toUpdate = chronicles.filter((c) => {\n    const status = c.entityBackportStatus;\n    return status && Object.keys(status).length > 0;\n  });\n\n  if (toUpdate.length === 0) return 0;\n\n  const now = Date.now();\n  await db.chronicles.bulkPut(\n    toUpdate.map((c) => ({\n      ...c,\n      entityBackportStatus: {},\n      updatedAt: now,\n    }))\n  );\n\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleToneRanking", "name": "updateChronicleToneRanking", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Tone Ranking & Assignment\n// ============================================================================\n\nexport async function updateChronicleToneRanking(\n  chronicleId: string,\n  ranking: [string, string, string],\n  rationale: string,\n  cost?: number,\n  rationales?: Record<string, string>\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.toneRanking = {\n    ranking: ranking as [\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n    ],\n    rationale,\n    rationales,\n    generatedAt: Date.now(),\n    actualCost: cost,\n  };\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "ranking", "type": "[string, string, string]", "optional": false}, {"name": "rationale", "type": "string", "optional": false}, {"name": "cost", "type": "number", "optional": true}, {"name": "rationales", "type": "Record<string, string>", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssignedTone", "name": "updateChronicleAssignedTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleAssignedTone(\n  chronicleId: string,\n  tone: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.assignedTone = tone as import(\"../historianTypes\").HistorianTone;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleGenerationVersion", "ChronicleShellMetadata", "ChronicleMetadata", "EntityUsageStats", "NarrativeStyleUsageStats", "VersionStep"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleTemporalContext", "CohesionReport", "ChronicleImageRefs", "ChronicleCoverImage", "EraTemporalInfo"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["ChronicleStep"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "ChronicleFocusType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::getChronicleFromStore", "name": "getChronicleFromStore", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Get a chronicle record imperatively (not a subscription).\n * For use in event handlers and callbacks.\n */\nexport function getChronicleFromStore(chronicleId: string): ChronicleRecord | undefined {\n  return useChronicleStore.getState().cache.get(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "ChronicleRecord | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::loadTree", "name": "loadTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function loadTree(\n  projectId: string,\n  simulationRunId: string\n): Promise<ContentTreeState | null> {\n  const record = await db.contentTrees.get([projectId, simulationRunId]);\n  return record ?? null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ContentTreeState | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["ContentTreeState"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::saveTree", "name": "saveTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function saveTree(tree: ContentTreeState): Promise<void> {\n  await db.contentTrees.put(tree);\n}", "parameters": [{"name": "tree", "type": "ContentTreeState", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["ContentTreeState"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::deleteTree", "name": "deleteTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function deleteTree(projectId: string, simulationRunId: string): Promise<void> {\n  await db.contentTrees.delete([projectId, simulationRunId]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["ContentTreeState"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::getCoordinateState", "name": "getCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function getCoordinateState(\n  simulationRunId: string\n): Promise<CoordinateStateRecord | undefined> {\n  return db.coordinateStates.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CoordinateStateRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "CoordinateStateRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["CoordinateState"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::upsertCoordinateState", "name": "upsertCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function upsertCoordinateState(\n  simulationRunId: string,\n  coordinateState: CoordinateState\n): Promise<void> {\n  await db.coordinateStates.put({\n    simulationRunId,\n    coordinateState,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "coordinateState", "type": "CoordinateState", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "CoordinateStateRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["CoordinateState"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::generateCostId", "name": "generateCostId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function generateCostId(): string {\n  return `cost_${Date.now()}_${crypto.randomUUID().slice(0, 9)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::createCostRecord", "name": "createCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function createCostRecord(input: CostRecordInput): CostRecord {\n  return {\n    id: input.id ?? generateCostId(),\n    timestamp: input.timestamp ?? Date.now(),\n    projectId: input.projectId,\n    simulationRunId: input.simulationRunId,\n    entityId: input.entityId,\n    entityName: input.entityName,\n    entityKind: input.entityKind,\n    chronicleId: input.chronicleId,\n    type: input.type,\n    model: input.model,\n    estimatedCost: input.estimatedCost,\n    actualCost: input.actualCost,\n    inputTokens: input.inputTokens,\n    outputTokens: input.outputTokens,\n  };\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "CostRecord", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecord", "name": "saveCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecord(record: CostRecord): Promise<void> {\n  console.debug(`${LOG_PREFIX} Save start`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n  await db.costs.put(record);\n  console.debug(`${LOG_PREFIX} Save complete`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n}", "parameters": [{"name": "record", "type": "CostRecord", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecordWithDefaults", "name": "saveCostRecordWithDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecordWithDefaults(input: CostRecordInput): Promise<void> {\n  return saveCostRecord(createCostRecord(input));\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForProject", "name": "getCostsForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForProject(projectId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForSimulation", "name": "getCostsForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForSimulation(simulationRunId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getAllCosts", "name": "getAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getAllCosts(): Promise<CostRecord[]> {\n  return db.costs.toArray();\n}", "parameters": [], "returnType": "Promise<CostRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsInRange", "name": "getCostsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsInRange(startTime: number, endTime: number): Promise<CostRecord[]> {\n  return db.costs.where(\"timestamp\").between(startTime, endTime, true, true).toArray();\n}", "parameters": [{"name": "startTime", "type": "number", "optional": false}, {"name": "endTime", "type": "number", "optional": false}], "returnType": "Promise<CostRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::summarizeCosts", "name": "summarizeCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function summarizeCosts(records: CostRecord[]): CostSummary {\n  const summary: CostSummary = {\n    totalEstimated: 0,\n    totalActual: 0,\n    count: records.length,\n    byType: {} as Record<CostType, { estimated: number; actual: number; count: number }>,\n    byModel: {},\n  };\n\n  for (const record of records) {\n    summary.totalEstimated += record.estimatedCost;\n    summary.totalActual += record.actualCost;\n\n    if (!summary.byType[record.type]) {\n      summary.byType[record.type] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byType[record.type].estimated += record.estimatedCost;\n    summary.byType[record.type].actual += record.actualCost;\n    summary.byType[record.type].count++;\n\n    if (!summary.byModel[record.model]) {\n      summary.byModel[record.model] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byModel[record.model].estimated += record.estimatedCost;\n    summary.byModel[record.model].actual += record.actualCost;\n    summary.byModel[record.model].count++;\n  }\n\n  return summary;\n}", "parameters": [{"name": "records", "type": "CostRecord[]", "optional": false}], "returnType": "CostSummary", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::clearAllCosts", "name": "clearAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function clearAllCosts(): Promise<void> {\n  await db.costs.clear();\n}", "parameters": [], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostCount", "name": "getCostCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostCount(): Promise<number> {\n  return db.costs.count();\n}", "parameters": [], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../costTypes", "specifiers": ["CostRecord", "CostType", "CostRecordInput", "CostSummary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::generateRunId", "name": "generateRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export function generateRunId(): string {\n  return `dynrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsRunStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::createDynamicsRun", "name": "createDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function createDynamicsRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string\n): Promise<DynamicsRun> {\n  const now = Date.now();\n\n  const run: DynamicsRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    messages: [],\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsRunStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::getDynamicsRun", "name": "getDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function getDynamicsRun(runId: string): Promise<DynamicsRun | undefined> {\n  return db.dynamicsRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsRunStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::updateDynamicsRun", "name": "updateDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function updateDynamicsRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<DynamicsRun> {\n  const run = await db.dynamicsRuns.get(runId);\n  if (!run) throw new Error(`Dynamics run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.messages !== undefined) run.messages = updates.messages;\n  if (updates.proposedDynamics !== undefined) run.proposedDynamics = updates.proposedDynamics;\n  if (updates.userFeedback !== undefined) run.userFeedback = updates.userFeedback;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<DynamicsRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsRunStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::deleteDynamicsRun", "name": "deleteDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function deleteDynamicsRun(runId: string): Promise<void> {\n  await db.dynamicsRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsRunStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::registerQueue", "name": "registerQueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the enrichment queue functions.\n */\nexport function registerQueue(enqueue: EnqueueFn, cancel: CancelFn): void {\n  _enqueue = enqueue;\n  _cancel = cancel;\n}", "parameters": [{"name": "enqueue", "type": "EnqueueFn", "optional": false}, {"name": "cancel", "type": "CancelFn", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getEnqueue", "name": "getEnqueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getEnqueue(): EnqueueFn {\n  if (!_enqueue) {\n    throw new Error(\"registerQueue must be called before getEnqueue\");\n  }\n  return _enqueue;\n}", "parameters": [], "returnType": "EnqueueFn", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getCancel", "name": "getCancel", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getCancel(): CancelFn {\n  if (!_cancel) {\n    throw new Error(\"registerQueue must be called before getCancel\");\n  }\n  return _cancel;\n}", "parameters": [], "returnType": "CancelFn", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/db/entityNav.ts::buildEntityNavItem", "name": "buildEntityNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityNav.ts", "sourceCode": "export function buildEntityNavItem(entity: PersistedEntity): EntityNavItem {\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  return {\n    id: entity.id,\n    name: entity.name,\n    kind: entity.kind,\n    subtype: entity.subtype,\n    prominence: entity.prominence,\n    culture: entity.culture,\n    status: entity.status,\n    summary: entity.summary,\n    eraId: entity.eraId,\n    hasDescription: !!(entity.summary && entity.description),\n    hasVisualThesis: !!entity.enrichment?.text?.visualThesis,\n    imageId: entity.enrichment?.image?.imageId,\n    descriptionCost: entity.enrichment?.text?.actualCost,\n    imageCost: entity.enrichment?.image?.actualCost,\n    aliases: entity.enrichment?.text?.aliases || [],\n    slugAliases: entity.enrichment?.slugAliases || [],\n    backrefCount: backrefs.length,\n    unconfiguredBackrefCount: backrefs.filter(\n      (b: { imageSource?: unknown }) => b.imageSource === undefined\n    ).length,\n    isManual: entity.id.startsWith(\"manual_\"),\n    lockedSummary: !!entity.lockedSummary,\n    hasHistorianNotes: (entity.enrichment?.historianNotes?.length ?? 0) > 0,\n    hasHistorianEdition: (entity.enrichment?.descriptionHistory || []).some(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ),\n    historianEditionCount: (entity.enrichment?.descriptionHistory || []).filter(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ).length,\n    descriptionWordCount: entity.description ? entity.description.split(/\\s+/).length : 0,\n  };\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}], "returnType": "EntityNavItem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::isSeeded", "name": "isSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed (Phase 1 bridge \u2014 replaced by Lore Weave write in future)\n// ---------------------------------------------------------------------------\n\n/**\n * Check whether entities have already been seeded for this simulation run.\n */\nexport async function isSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.entities.where(\"simulationRunId\").equals(simulationRunId).count();\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::seedEntities", "name": "seedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-write entities from worldData.hardState into Dexie.\n * Stamps each record with simulationRunId. Skips if already seeded.\n */\nexport async function seedEntities(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<void> {\n  const records: PersistedEntity[] = entities.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.entities.bulkPut(records);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::createEntity", "name": "createEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Manual Creation\n// ---------------------------------------------------------------------------\n\n/**\n * Create a single entity manually. Generates a collision-safe ID\n * with a `manual_` prefix.\n */\nexport async function createEntity(\n  simulationRunId: string,\n  entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<PersistedEntity> {\n  if (!simulationRunId) {\n    throw new Error(\"simulationRunId is required to create an entity\");\n  }\n  const now = Date.now();\n  const id = `manual_${entity.kind}_${now}_${crypto.randomUUID().slice(0, 8)}`;\n  const record: PersistedEntity = {\n    ...entity,\n    id,\n    createdAt: now,\n    updatedAt: now,\n    simulationRunId,\n  };\n  await db.entities.put(record);\n  return record;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entity", "type": "Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">", "optional": false}], "returnType": "Promise<PersistedEntity>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntity", "name": "deleteEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function deleteEntity(entityId: string): Promise<void> {\n  if (!entityId.startsWith(\"manual_\")) {\n    throw new Error(\"Only manually-created entities can be deleted\");\n  }\n  await db.entities.delete(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::patchEntitiesFromHardState", "name": "patchEntitiesFromHardState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Patch entities from hard state without overwriting existing values.\n * - Inserts missing entities\n * - For existing entities, fills only undefined/null fields (keeps enrichment intact)\n */\nexport async function patchEntitiesFromHardState(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<{ added: number; patched: number }> {\n  if (!entities?.length) return { added: 0, patched: 0 };\n\n  const existing = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const existingById = new Map(existing.map((e) => [e.id, e]));\n  let added = 0;\n  let patched = 0;\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const worldEntity of entities) {\n      const current = existingById.get(worldEntity.id);\n      if (!current) {\n        await db.entities.put({ ...worldEntity, simulationRunId });\n        added += 1;\n        continue;\n      }\n\n      const updates: Partial<PersistedEntity> = {};\n      for (const [key, value] of Object.entries(worldEntity)) {\n        if (key === \"enrichment\") continue;\n        if (value === undefined || value === null) continue;\n        const currentValue = (current as any)[key];\n        if (currentValue === undefined || currentValue === null) {\n          (updates as any)[key] = value;\n        }\n      }\n\n      if (Object.keys(updates).length > 0) {\n        await db.entities.update(current.id, updates);\n        patched += 1;\n      }\n    }\n  });\n\n  return { added, patched };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<{ added: number; patched: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntity", "name": "getEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getEntity(entityId: string): Promise<PersistedEntity | undefined> {\n  return db.entities.get(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByIds", "name": "getEntitiesByIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByIds(entityIds: string[]): Promise<PersistedEntity[]> {\n  const results = await db.entities.bulkGet(entityIds);\n  return results.filter((e): e is PersistedEntity => e !== undefined);\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<PersistedEntity[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesForRun", "name": "getEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesForRun(simulationRunId: string): Promise<PersistedEntity[]> {\n  return db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntityIdsForRun", "name": "getEntityIdsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntityIdsForRun(simulationRunId: string): Promise<string[]> {\n  const ids = await db.entities.where(\"simulationRunId\").equals(simulationRunId).primaryKeys();\n  return ids.map((id) => String(id));\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByKind", "name": "getEntitiesByKind", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByKind(\n  simulationRunId: string,\n  kind: string\n): Promise<PersistedEntity[]> {\n  return db.entities.where(\"[simulationRunId+kind]\").equals([simulationRunId, kind]).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityField", "name": "updateEntityField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Single-field updates\n// ---------------------------------------------------------------------------\n\nexport async function updateEntityField(\n  entityId: string,\n  field: string,\n  value: unknown\n): Promise<void> {\n  await db.entities.update(entityId, { [field]: value });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "field", "type": "string", "optional": false}, {"name": "value", "type": "unknown", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityFields", "name": "updateEntityFields", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function updateEntityFields(\n  entityId: string,\n  fields: Partial<PersistedEntity>\n): Promise<void> {\n  await db.entities.update(entityId, fields);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "fields", "type": "Partial<PersistedEntity>", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRename", "name": "applyRename", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function applyRename(\n  targetEntityId: string | null,\n  newName: string,\n  entityPatches: EntityPatch[],\n  simulationRunId: string,\n  addOldNameAsAlias?: boolean\n): Promise<string[]> {\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    if (targetEntityId) {\n      await renameTargetEntity(targetEntityId, newName, addOldNameAsAlias, updatedIds);\n    }\n\n    for (const patch of entityPatches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let changed = false;\n      const updates: Partial<PersistedEntity> = {};\n\n      for (const [key, value] of Object.entries(patch.changes)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n        if (applyFieldReplacement(field, replacements, entity, updates)) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        await db.entities.update(patch.entityId, updates);\n        if (!updatedIds.includes(patch.entityId)) updatedIds.push(patch.entityId);\n      }\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "entityPatches", "type": "EntityPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "addOldNameAsAlias", "type": "boolean", "optional": true}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyDescriptionResult", "name": "applyDescriptionResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Worker enrichment results\n// ---------------------------------------------------------------------------\n\n/**\n * Apply a description enrichment result from the worker.\n * Pushes current description to history if overwriting, merges enrichment.text.\n */\nexport async function applyDescriptionResult(\n  entityId: string,\n  enrichment: Partial<EntityEnrichment>,\n  summary?: string | null,\n  description?: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    // Push description history if overwriting an existing description\n    let baseEnrichment = entity.enrichment || {};\n    if (description !== undefined && entity.description) {\n      const history = [...(baseEnrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"description-task\",\n      });\n      baseEnrichment = { ...baseEnrichment, descriptionHistory: history };\n    }\n\n    const updates: Partial<PersistedEntity> = {\n      enrichment: { ...baseEnrichment, ...enrichment },\n    };\n    if (summary !== undefined) updates.summary = summary ?? undefined;\n    if (description !== undefined) updates.description = description;\n\n    await db.entities.update(entityId, updates);\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "enrichment", "type": "Partial<EntityEnrichment>", "optional": false}, {"name": "summary", "type": "string | null", "optional": true}, {"name": "description", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyVisualThesisResult", "name": "applyVisualThesisResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply a visual thesis result \u2014 updates only visual fields on enrichment.text,\n * preserving existing aliases, description, and summary.\n */\nexport async function applyVisualThesisResult(\n  entityId: string,\n  visualThesis: string,\n  visualTraits: string[],\n  meta: {\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const existingText = entity.enrichment?.text;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        text: {\n          aliases: existingText?.aliases || [],\n          visualThesis,\n          visualTraits,\n          generatedAt: meta.generatedAt,\n          model: meta.model,\n          estimatedCost: meta.estimatedCost,\n          actualCost: meta.actualCost,\n          inputTokens: meta.inputTokens,\n          outputTokens: meta.outputTokens,\n          chainDebug: meta.chainDebug,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "visualThesis", "type": "string", "optional": false}, {"name": "visualTraits", "type": "string[]", "optional": false}, {"name": "meta", "type": "{\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyImageResult", "name": "applyImageResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an image enrichment result from the worker.\n */\nexport async function applyImageResult(\n  entityId: string,\n  imageEnrichment: EntityEnrichment[\"image\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, image: imageEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageEnrichment", "type": "EntityEnrichment[\"image\"]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyEntityChronicleResult", "name": "applyEntityChronicleResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an entity chronicle enrichment result from the worker.\n */\nexport async function applyEntityChronicleResult(\n  entityId: string,\n  chronicleEnrichment: EntityEnrichment[\"entityChronicle\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, entityChronicle: chronicleEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "chronicleEnrichment", "type": "EntityEnrichment[\"entityChronicle\"]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::assignImage", "name": "assignImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// User actions\n// ---------------------------------------------------------------------------\n\n/**\n * Assign an existing library image to an entity.\n */\nexport async function assignImage(\n  entityId: string,\n  imageId: string,\n  imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        image: {\n          imageId,\n          generatedAt: imageMetadata?.generatedAt || Date.now(),\n          model: imageMetadata?.model || \"assigned\",\n          revisedPrompt: imageMetadata?.revisedPrompt,\n          estimatedCost: 0,\n          actualCost: 0,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageId", "type": "string", "optional": false}, {"name": "imageMetadata", "type": "{ generatedAt?: number; model?: string; revisedPrompt?: string }", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateDescriptionManual", "name": "updateDescriptionManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's description. Pushes current description to history\n * with source 'manual', bumps text.generatedAt to prevent enrichment overwrites.\n */\nexport async function updateDescriptionManual(\n  entityId: string,\n  description: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    let enrichment = entity.enrichment || {};\n\n    // Push current description to history\n    if (entity.description) {\n      const history = [...(enrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"manual\",\n      });\n      enrichment = { ...enrichment, descriptionHistory: history };\n    }\n\n    // Bump text.generatedAt so enrichment workers won't overwrite\n    if (enrichment.text) {\n      enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n    }\n\n    await db.entities.update(entityId, { description, enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "description", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateSummaryManual", "name": "updateSummaryManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's summary. Sets lockedSummary to prevent enrichment overwrites.\n */\nexport async function updateSummaryManual(entityId: string, summary: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, { summary, lockedSummary: true });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::undoDescription", "name": "undoDescription", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Undo the last description change by popping from descriptionHistory.\n */\nexport async function undoDescription(entityId: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (history.length === 0) return;\n    const previous = history.pop();\n    await db.entities.update(entityId, {\n      description: previous.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::restoreDescriptionFromHistory", "name": "restoreDescriptionFromHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Restore a specific description history entry as the active description.\n * The current description is pushed to history before the swap.\n */\nexport async function restoreDescriptionFromHistory(\n  entityId: string,\n  historyIndex: number\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (historyIndex < 0 || historyIndex >= history.length) return;\n\n    const selected = history[historyIndex];\n\n    // Push current description to history\n    if (entity.description) {\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"version-restore\",\n      });\n    }\n\n    // Remove the selected entry from history\n    history.splice(historyIndex, 1);\n\n    await db.entities.update(entityId, {\n      description: selected.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "historyIndex", "type": "number", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateBackrefs", "name": "updateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Set chronicle backrefs on an entity.\n */\nexport async function updateBackrefs(\n  entityId: string,\n  backrefs: NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "backrefs", "type": "NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateAliases", "name": "updateAliases", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Aliases\n// ---------------------------------------------------------------------------\n\n/**\n * Update the text aliases on an entity.\n */\nexport async function updateAliases(entityId: string, aliases: string[]): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const text = entity.enrichment?.text || {\n      aliases: [],\n      visualTraits: [],\n      generatedAt: 0,\n      model: \"\",\n    };\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, text: { ...text, aliases } },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "aliases", "type": "string[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRevisionPatches", "name": "applyRevisionPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply revision patches from summary revision, lore backport, or copy-edit.\n * Pushes descriptionHistory, bumps text.generatedAt. Returns updated entity IDs.\n */\nexport async function applyRevisionPatches(\n  patches: RevisionPatch[],\n  source: string\n): Promise<string[]> {\n  if (!patches?.length) return [];\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let enrichment = entity.enrichment || {};\n\n      // Push description history if overwriting\n      if (patch.description !== undefined && entity.description) {\n        const history = [...(enrichment.descriptionHistory || [])];\n        history.push({\n          description: entity.description,\n          replacedAt: Date.now(),\n          source,\n        });\n        enrichment = { ...enrichment, descriptionHistory: history };\n      }\n\n      // Bump text.generatedAt so stale persisted data won't overwrite\n      if (patch.description !== undefined && enrichment.text) {\n        enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n      }\n\n      const updates: Partial<PersistedEntity> = { enrichment };\n      if (patch.summary !== undefined) updates.summary = patch.summary;\n      if (patch.description !== undefined) updates.description = patch.description;\n\n      await db.entities.update(patch.entityId, updates);\n      updatedIds.push(patch.entityId);\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "source", "type": "string", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::revalidateBackrefs", "name": "revalidateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function revalidateBackrefs(\n  patches: RevisionPatch[],\n  options?: {\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      if (!patch.description && !options?.chronicleId) continue;\n\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      const desc = patch.description || entity.description || \"\";\n      let backrefs = [...(entity.enrichment?.chronicleBackrefs || [])];\n      if (backrefs.length === 0 && !patch.anchorPhrase) continue;\n\n      if (patch.description && backrefs.length > 0) {\n        backrefs = backrefs.map((br) =>\n          reResolveBackref(br, desc, entity.description, Boolean(options?.fuzzyFallback))\n        );\n      }\n\n      if (options?.chronicleId && patch.anchorPhrase) {\n        upsertBackref(backrefs, options.chronicleId, patch.anchorPhrase, desc, entity.id);\n      }\n\n      await db.entities.update(patch.entityId, {\n        enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n      });\n    }\n  });\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "options", "type": "{\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::setHistorianNotes", "name": "setHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Historian\n// ---------------------------------------------------------------------------\n\n/**\n * Set historian notes on an entity.\n */\nexport async function setHistorianNotes(\n  entityId: string,\n  notes: NonNullable<EntityEnrichment[\"historianNotes\"]>,\n  reinforcedFacts?: string[]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const enrichment = { ...entity.enrichment, historianNotes: notes };\n    if (reinforcedFacts) {\n      enrichment.reinforcedFacts = reinforcedFacts;\n    }\n    await db.entities.update(entityId, { enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "notes", "type": "NonNullable<EntityEnrichment[\"historianNotes\"]>", "optional": false}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::resetEntitiesToPreBackportState", "name": "resetEntitiesToPreBackportState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Backport Reset\n// ---------------------------------------------------------------------------\n\n/**\n * Reset entity descriptions to their pre-backport state.\n * Optionally accepts an entity list to ensure reset covers entities not yet persisted in Dexie.\n * For each entity that has lore-backport entries in descriptionHistory:\n * - Find the first 'lore-backport' entry\n * - Restore the description from that entry (which is the pre-backport state)\n * - Truncate history to remove all entries from that point onward\n * - Clear chronicleBackrefs (these were set by backport operations)\n *\n * Returns count of entities that were reset.\n */\nexport async function resetEntitiesToPreBackportState(\n  simulationRunId: string,\n  entitiesOverride?: PersistedEntity[]\n): Promise<{ resetCount: number; entityIds: string[] }> {\n  const entities = entitiesOverride?.length\n    ? entitiesOverride\n    : await getEntitiesForRun(simulationRunId);\n  const resetEntityIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    const existing = await db.entities.bulkGet(entities.map((entity) => entity.id));\n    const existingIds = new Set(existing.filter(Boolean).map((entity) => entity.id));\n\n    for (const entity of entities) {\n      const history = entity.enrichment?.descriptionHistory || [];\n      if (history.length === 0) continue;\n\n      // Find the first 'lore-backport' entry\n      const firstBackportIndex = history.findIndex((h) => h.source === \"lore-backport\");\n      if (firstBackportIndex === -1) continue; // Never backported\n\n      // The description in that entry is the pre-backport state\n      const preBackportDescription = history[firstBackportIndex].description;\n\n      // Truncate history to remove entries from the first backport onward\n      const newHistory = history.slice(0, firstBackportIndex);\n\n      // Clear chronicleBackrefs since those were set by backport\n      const newEnrichment = {\n        ...entity.enrichment,\n        descriptionHistory: newHistory,\n        chronicleBackrefs: [],\n      };\n\n      const updates = {\n        description: preBackportDescription,\n        enrichment: newEnrichment,\n      };\n\n      if (existingIds.has(entity.id)) {\n        await db.entities.update(entity.id, updates);\n      } else {\n        await db.entities.put({\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n          ...updates,\n        });\n      }\n\n      resetEntityIds.push(entity.id);\n    }\n  });\n\n  return {\n    resetCount: resetEntityIds.length,\n    entityIds: resetEntityIds,\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entitiesOverride", "type": "PersistedEntity[]", "optional": true}], "returnType": "Promise<{ resetCount: number; entityIds: string[] }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntitiesForRun", "name": "deleteEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEntitiesForRun(simulationRunId: string): Promise<void> {\n  await db.entities.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::convertLongEditionsToLegacy", "name": "convertLongEditionsToLegacy", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-convert all historian-edition history entries to 'legacy-copy-edit' source.\n * Clears the historian-edition slate so entities can go through a fresh edition cycle.\n *\n * Returns the count of entities modified.\n */\nexport async function convertLongEditionsToLegacy(entityIds: string[]): Promise<number> {\n  let modified = 0;\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const entityId of entityIds) {\n      const entity = await db.entities.get(entityId);\n      if (!entity) continue;\n\n      const history = [...(entity.enrichment?.descriptionHistory || [])];\n      let changed = false;\n      for (let i = 0; i < history.length; i++) {\n        if (history[i].source === \"historian-edition\") {\n          history[i] = { ...history[i], source: \"legacy-copy-edit\" };\n          changed = true;\n        }\n      }\n\n      if (!changed) continue;\n\n      await db.entities.update(entityId, {\n        enrichment: { ...entity.enrichment, descriptionHistory: history },\n      });\n      modified++;\n    }\n  });\n  return modified;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedEntity"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["EntityPatch"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyReplacements", "FieldReplacement"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EntityEnrichment", "DescriptionChainDebug"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase", "extractWordsAroundIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts::buildEraNarrativeNavItem", "name": "buildEraNarrativeNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts", "sourceCode": "export function buildEraNarrativeNavItem(\n  record: EraNarrativeRecord,\n  eraOrder?: number\n): EraNarrativeNavItem {\n  const wordCount = record.narrative?.editedWordCount ?? record.narrative?.wordCount ?? 0;\n\n  return {\n    id: `eranarr:${record.narrativeId}`,\n    narrativeId: record.narrativeId,\n    itemType: \"era_narrative\",\n    name: record.eraName,\n    eraName: record.eraName,\n    eraId: record.eraId,\n    status: record.status,\n    tone: record.tone,\n    currentStep: record.currentStep,\n    wordCount,\n    totalActualCost: record.totalActualCost,\n    threadCount: record.threadSynthesis?.threads?.length ?? 0,\n    movementCount: record.threadSynthesis?.movements?.length ?? 0,\n    hasThesis: !!record.threadSynthesis?.thesis,\n    createdAt: record.createdAt,\n    updatedAt: record.updatedAt,\n    focalEraName: record.eraName,\n    focalEraOrder: eraOrder,\n    eraYear: undefined,\n  };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}, {"name": "eraOrder", "type": "number", "optional": true}], "returnType": "EraNarrativeNavItem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateEraNarrativeId", "name": "generateEraNarrativeId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateEraNarrativeId(): string {\n  return `eranarr_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateVersionId", "name": "generateVersionId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateVersionId(): string {\n  return `enver_${Date.now()}_${crypto.randomUUID().slice(0, 6)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::createEraNarrative", "name": "createEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function createEraNarrative(record: EraNarrativeRecord): Promise<EraNarrativeRecord> {\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "Promise<EraNarrativeRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrative", "name": "getEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrative(\n  narrativeId: string\n): Promise<EraNarrativeRecord | undefined> {\n  return db.eraNarratives.get(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForEra", "name": "getEraNarrativesForEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForEra(\n  simulationRunId: string,\n  eraId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where({ simulationRunId, eraId }).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "eraId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForSimulation", "name": "getEraNarrativesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForSimulation(\n  simulationRunId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrative", "name": "updateEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrative(\n  narrativeId: string,\n  updates: Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  if (updates.status !== undefined) record.status = updates.status;\n  if (updates.error !== undefined) record.error = updates.error;\n  if (updates.currentStep !== undefined) record.currentStep = updates.currentStep;\n  if (updates.threadSynthesis !== undefined) record.threadSynthesis = updates.threadSynthesis;\n  if (updates.narrative !== undefined) record.narrative = updates.narrative;\n  if (updates.contentVersions !== undefined) record.contentVersions = updates.contentVersions;\n  if (updates.activeVersionId !== undefined) record.activeVersionId = updates.activeVersionId;\n  if (updates.coverImage !== undefined) record.coverImage = updates.coverImage;\n  if (updates.imageRefs !== undefined) record.imageRefs = updates.imageRefs;\n  if (updates.totalInputTokens !== undefined) record.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) record.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) record.totalActualCost = updates.totalActualCost;\n  if (updates.editInsertion !== undefined) record.editInsertion = updates.editInsertion;\n  record.updatedAt = Date.now();\n\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >", "optional": false}], "returnType": "Promise<EraNarrativeRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrative", "name": "deleteEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrative(narrativeId: string): Promise<void> {\n  await db.eraNarratives.delete(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrativeVersion", "name": "deleteEraNarrativeVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrativeVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  const target = versions.find((v) => v.versionId === versionId);\n  if (!target) throw new Error(`Version ${versionId} not found`);\n  if (target.step === \"generate\") throw new Error(\"Cannot delete the generate version\");\n\n  record.contentVersions = versions.filter((v) => v.versionId !== versionId);\n\n  // If deleted version was active, fall back to latest remaining\n  if (record.activeVersionId === versionId) {\n    const remaining = record.contentVersions;\n    record.activeVersionId =\n      remaining.length > 0 ? remaining[remaining.length - 1].versionId : undefined;\n  }\n\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::setEraNarrativeActiveVersion", "name": "setEraNarrativeActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function setEraNarrativeActiveVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  if (!versions.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found`);\n  }\n\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImage", "name": "updateEraNarrativeCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Cover Image\n// =============================================================================\n\nexport async function updateEraNarrativeCoverImage(\n  narrativeId: string,\n  coverImage: EraNarrativeCoverImage,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.coverImage = coverImage;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "coverImage", "type": "EraNarrativeCoverImage", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImageStatus", "name": "updateEraNarrativeCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeCoverImageStatus(\n  narrativeId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.coverImage) return;\n\n  record.coverImage.status = status;\n  if (imageId) record.coverImage.generatedImageId = imageId;\n  if (error) record.coverImage.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefs", "name": "updateEraNarrativeImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Image Refs\n// =============================================================================\n\nexport async function updateEraNarrativeImageRefs(\n  narrativeId: string,\n  imageRefs: EraNarrativeImageRefs,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "EraNarrativeImageRefs", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefStatus", "name": "updateEraNarrativeImageRefStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeImageRefStatus(\n  narrativeId: string,\n  refId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref || ref.type !== \"prompt_request\") return;\n\n  ref.status = status;\n  if (imageId) ref.generatedImageId = imageId;\n  if (error) ref.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefField", "name": "updateEraNarrativeImageRefField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "/**\n * Update arbitrary fields on an image ref (anchor text, size, justification).\n */\nexport async function updateEraNarrativeImageRefField(\n  narrativeId: string,\n  refId: string,\n  updates: { anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref) return;\n\n  if (updates.anchorText !== undefined) ref.anchorText = updates.anchorText;\n  if (updates.size !== undefined) (ref as any).size = updates.size;\n  if (updates.justification !== undefined) {\n    if (updates.justification === null) {\n      delete (ref as any).justification;\n    } else {\n      ref.justification = updates.justification;\n    }\n  }\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{ anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::resolveActiveContent", "name": "resolveActiveContent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Version Helpers\n// =============================================================================\n\n/**\n * Get the active version's content, falling back to legacy narrative field.\n * Returns the content string and the version list for display.\n */\nexport function resolveActiveContent(record: EraNarrativeRecord): {\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n} {\n  const versions = record.contentVersions || [];\n\n  if (versions.length > 0) {\n    const activeId = record.activeVersionId || versions[versions.length - 1].versionId;\n    const active = versions.find((v) => v.versionId === activeId) || versions[versions.length - 1];\n    return { content: active.content, versions, activeVersionId: active.versionId };\n  }\n\n  // Legacy fallback: migrate from narrative field\n  if (record.narrative) {\n    const legacyVersions: EraNarrativeContentVersion[] = [];\n    legacyVersions.push({\n      versionId: `legacy_gen_${record.narrative.generatedAt}`,\n      content: record.narrative.content,\n      wordCount: record.narrative.wordCount,\n      step: \"generate\",\n      generatedAt: record.narrative.generatedAt,\n      model: record.narrative.model,\n      systemPrompt: record.narrative.systemPrompt,\n      userPrompt: record.narrative.userPrompt,\n      inputTokens: record.narrative.inputTokens,\n      outputTokens: record.narrative.outputTokens,\n      actualCost: record.narrative.actualCost,\n    });\n    if (record.narrative.editedContent) {\n      legacyVersions.push({\n        versionId: `legacy_edit_${record.narrative.editedAt || record.narrative.generatedAt}`,\n        content: record.narrative.editedContent,\n        wordCount:\n          record.narrative.editedWordCount ||\n          record.narrative.editedContent.split(/\\s+/).filter(Boolean).length,\n        step: \"edit\",\n        generatedAt: record.narrative.editedAt || record.narrative.generatedAt,\n        model: record.narrative.model,\n        systemPrompt: record.narrative.editSystemPrompt || \"\",\n        userPrompt: record.narrative.editUserPrompt || \"\",\n        inputTokens: record.narrative.editInputTokens || 0,\n        outputTokens: record.narrative.editOutputTokens || 0,\n        actualCost: record.narrative.editActualCost || 0,\n      });\n    }\n\n    const activeId = legacyVersions[legacyVersions.length - 1].versionId;\n    return {\n      content: legacyVersions[legacyVersions.length - 1].content,\n      versions: legacyVersions,\n      activeVersionId: activeId,\n    };\n  }\n\n  return { content: undefined, versions: [], activeVersionId: undefined };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "{\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeCoverImage", "EraNarrativeImageRefs", "EraNarrativeContentVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::isNarrativeEventsSeeded", "name": "isNarrativeEventsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isNarrativeEventsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[EventRepo] isNarrativeEventsSeeded\", { simulationRunId, count, seeded: count > 0 });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::seedNarrativeEvents", "name": "seedNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function seedNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<void> {\n  console.log(\"[EventRepo] seedNarrativeEvents\", { simulationRunId, eventCount: events.length });\n  const records: PersistedNarrativeEvent[] = events.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.narrativeEvents.bulkPut(records);\n  console.log(\"[EventRepo] seedNarrativeEvents complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::patchNarrativeEvents", "name": "patchNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "/**\n * Patch narrative events without overwriting existing records.\n * Inserts only missing event IDs.\n */\nexport async function patchNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<number> {\n  if (!events?.length) return 0;\n\n  const existing = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingIds = new Set(existing.map((e) => e.id));\n\n  const toAdd: PersistedNarrativeEvent[] = [];\n  for (const event of events) {\n    if (!existingIds.has(event.id)) {\n      toAdd.push({ ...event, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.narrativeEvents.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEventsForRun", "name": "getNarrativeEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getNarrativeEventsForRun(\n  simulationRunId: string\n): Promise<PersistedNarrativeEvent[]> {\n  const events = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[EventRepo] getNarrativeEventsForRun\", { simulationRunId, count: events.length });\n  return events;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEvent", "name": "getNarrativeEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function getNarrativeEvent(\n  eventId: string\n): Promise<PersistedNarrativeEvent | undefined> {\n  return db.narrativeEvents.get(eventId);\n}", "parameters": [{"name": "eventId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::applyEventPatches", "name": "applyEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Named mutations\n// ---------------------------------------------------------------------------\n\n/**\n * Apply event patches from a rename operation.\n * Reads affected events from Dexie, applies text replacements, writes back.\n * Returns IDs of all updated events.\n */\nexport async function applyEventPatches(\n  eventPatches: EventPatch[],\n  simulationRunId: string\n): Promise<string[]> {\n  console.log(\"[EventRepo] applyEventPatches called\", {\n    patchCount: eventPatches.length,\n    simulationRunId,\n    patchEventIds: eventPatches.map((p) => p.eventId),\n    patchKeys: eventPatches.map((p) => Object.keys(p.changes)),\n  });\n\n  if (eventPatches.length === 0) return [];\n\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.narrativeEvents, async () => {\n    // Load all events for the run (needed for the batch patch function)\n    const allEvents = await db.narrativeEvents\n      .where(\"simulationRunId\")\n      .equals(simulationRunId)\n      .toArray();\n\n    console.log(\"[EventRepo] Loaded events from Dexie\", {\n      totalEvents: allEvents.length,\n      simulationRunId,\n    });\n\n    // Sample a patched event BEFORE applying patches\n    const firstPatchId = eventPatches[0]?.eventId;\n    const sampleBefore = allEvents.find((e) => e.id === firstPatchId);\n    if (sampleBefore) {\n      console.log(\"[EventRepo] Sample event BEFORE patch\", {\n        id: sampleBefore.id,\n        description: sampleBefore.description?.substring(0, 200),\n        action: (sampleBefore as any).action?.substring(0, 200),\n      });\n    } else {\n      console.warn(\"[EventRepo] First patch target NOT FOUND in Dexie events\", {\n        targetId: firstPatchId,\n        availableIds: allEvents.slice(0, 5).map((e) => e.id),\n      });\n    }\n\n    // Apply patches using the existing pure function\n    const patched = applyPatches(allEvents, eventPatches);\n\n    // Sample the same event AFTER applying patches\n    const sampleAfter = patched.find((e) => e.id === firstPatchId);\n    if (sampleAfter) {\n      console.log(\"[EventRepo] Sample event AFTER patch\", {\n        id: sampleAfter.id,\n        description: sampleAfter.description?.substring(0, 200),\n        action: (sampleAfter as any).action?.substring(0, 200),\n      });\n    }\n\n    // Find which events actually changed and write them back\n    const patchedEventIds = new Set(eventPatches.map((p) => p.eventId));\n    let writeCount = 0;\n    for (const event of patched) {\n      if (patchedEventIds.has(event.id)) {\n        await db.narrativeEvents.put(event);\n        updatedIds.push(event.id);\n        writeCount++;\n      }\n    }\n    console.log(\"[EventRepo] Wrote patched events back to Dexie\", {\n      writeCount,\n      updatedIds,\n    });\n  });\n\n  // Verify: re-read one event to confirm persistence\n  if (updatedIds.length > 0) {\n    const verify = await db.narrativeEvents.get(updatedIds[0]);\n    console.log(\"[EventRepo] VERIFY after transaction\", {\n      id: verify?.id,\n      description: verify?.description?.substring(0, 200),\n      action: (verify as any)?.action?.substring(0, 200),\n    });\n  }\n\n  return updatedIds;\n}", "parameters": [{"name": "eventPatches", "type": "EventPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::deleteEventsForRun", "name": "deleteEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEventsForRun(simulationRunId: string): Promise<void> {\n  await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedNarrativeEvent"], "category": "internal"}, {"source": "../entityRename", "specifiers": ["applyNarrativeEventPatches as applyPatches", "EventPatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::generateHistorianRunId", "name": "generateHistorianRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export function generateHistorianRunId(): string {\n  return `histrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianRun", "HistorianRunStatus", "HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::createHistorianRun", "name": "createHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function createHistorianRun(run: HistorianRun): Promise<HistorianRun> {\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "run", "type": "HistorianRun", "optional": false}], "returnType": "Promise<HistorianRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianRun", "HistorianRunStatus", "HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::getHistorianRun", "name": "getHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function getHistorianRun(runId: string): Promise<HistorianRun | undefined> {\n  return db.historianRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<HistorianRun | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianRun", "HistorianRunStatus", "HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::updateHistorianRun", "name": "updateHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function updateHistorianRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >\n): Promise<HistorianRun> {\n  const run = await db.historianRuns.get(runId);\n  if (!run) throw new Error(`Historian run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.notes !== undefined) run.notes = updates.notes;\n  if (updates.noteDecisions !== undefined) run.noteDecisions = updates.noteDecisions;\n  if (updates.chronologyAssignments !== undefined)\n    run.chronologyAssignments = updates.chronologyAssignments;\n  if (updates.inputTokens !== undefined) run.inputTokens = updates.inputTokens;\n  if (updates.outputTokens !== undefined) run.outputTokens = updates.outputTokens;\n  if (updates.actualCost !== undefined) run.actualCost = updates.actualCost;\n  if (updates.systemPrompt !== undefined) run.systemPrompt = updates.systemPrompt;\n  if (updates.userPrompt !== undefined) run.userPrompt = updates.userPrompt;\n  run.updatedAt = Date.now();\n\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >", "optional": false}], "returnType": "Promise<HistorianRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianRun", "HistorianRunStatus", "HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::deleteHistorianRun", "name": "deleteHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function deleteHistorianRun(runId: string): Promise<void> {\n  await db.historianRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianRun", "HistorianRunStatus", "HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::extractReinforcedFactIds", "name": "extractReinforcedFactIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Context extraction\n// ============================================================================\n\n/**\n * Extract reinforced fact IDs from a HistorianReviewConfig's contextJson.\n * Returns the factIds from factCoverageGuidance targets, or undefined if none.\n */\nexport function extractReinforcedFactIds(contextJson: string): string[] | undefined {\n  try {\n    const ctx = JSON.parse(contextJson);\n    if (!Array.isArray(ctx.factCoverageGuidance) || ctx.factCoverageGuidance.length === 0)\n      return undefined;\n    return ctx.factCoverageGuidance.map((t: { factId: string }) => t.factId).filter(Boolean);\n  } catch {\n    return undefined;\n  }\n}", "parameters": [{"name": "contextJson", "type": "string", "optional": false}], "returnType": "string[] | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "./enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "./historianRepository", "specifiers": ["getHistorianRun", "deleteHistorianRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::sleep", "name": "sleep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Helpers\n// ============================================================================\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}", "parameters": [{"name": "ms", "type": "number", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "./enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "./historianRepository", "specifiers": ["getHistorianRun", "deleteHistorianRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::dispatchReviewTask", "name": "dispatchReviewTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Enqueue a historian review task to the enrichment worker.\n */\nexport function dispatchReviewTask(runId: string): void {\n  getEnqueue()([\n    {\n      entity: {\n        id: \"__historian_review__\",\n        name: \"Historian Review\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      },\n      type: \"historianReview\" as EnrichmentType,\n      prompt: \"\",\n      chronicleId: runId,\n    },\n  ]);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "./enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "./historianRepository", "specifiers": ["getHistorianRun", "deleteHistorianRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::pollReviewCompletion", "name": "pollReviewCompletion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Poll a historian run until it reaches 'reviewing' (success) or 'failed'.\n *\n * @param isCancelled \u2014 checked before and after each sleep; return true to abort.\n * @returns ReviewResult on success, null if cancelled or run disappeared.\n * @throws on run failure.\n */\nexport async function pollReviewCompletion(\n  runId: string,\n  isCancelled: () => boolean\n): Promise<ReviewResult | null> {\n  while (true) {\n    if (isCancelled()) return null;\n    await sleep(POLL_INTERVAL_MS);\n    if (isCancelled()) return null;\n\n    const run = await getHistorianRun(runId);\n    if (!run) return null;\n\n    if (run.status === \"reviewing\") {\n      const cost = run.actualCost || 0;\n      const prompts =\n        run.systemPrompt && run.userPrompt\n          ? { systemPrompt: run.systemPrompt, userPrompt: run.userPrompt }\n          : undefined;\n      await deleteHistorianRun(runId);\n      return { notes: run.notes || [], cost, prompts };\n    }\n\n    if (run.status === \"failed\") {\n      const error = run.error || \"Unknown error\";\n      await deleteHistorianRun(runId);\n      throw new Error(error);\n    }\n  }\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "isCancelled", "type": "() => boolean", "optional": false}], "returnType": "Promise<ReviewResult | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "./enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "./historianRepository", "specifiers": ["getHistorianRun", "deleteHistorianRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::generateImageId", "name": "generateImageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Pure Functions\n// ============================================================================\n\nexport function generateImageId(entityId: string): string {\n  return `img_${entityId}_${Date.now()}`;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::classifyAspect", "name": "classifyAspect", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Classify aspect ratio from width/height.\n */\nexport function classifyAspect(width: number, height: number): ImageAspect {\n  const ratio = width / height;\n  if (ratio < 0.9) return \"portrait\";\n  if (ratio > 1.1) return \"landscape\";\n  return \"square\";\n}", "parameters": [{"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}], "returnType": "ImageAspect", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::extractImageDimensions", "name": "extractImageDimensions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Extract dimensions from an image blob using createImageBitmap (works in workers).\n */\nexport async function extractImageDimensions(\n  blob: Blob\n): Promise<{ width: number; height: number; aspect: ImageAspect }> {\n  const bitmap = await createImageBitmap(blob);\n  const { width, height } = bitmap;\n  bitmap.close();\n  return { width, height, aspect: classifyAspect(width, height) };\n}", "parameters": [{"name": "blob", "type": "Blob", "optional": false}], "returnType": "Promise<{ width: number; height: number; aspect: ImageAspect }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::saveImage", "name": "saveImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// CRUD\n// ============================================================================\n\nexport async function saveImage(\n  imageId: string,\n  blob: Blob,\n  metadata: ImageMetadata\n): Promise<string> {\n  const { size: sizeOverride, ...rest } = metadata as ImageMetadata & { size?: unknown };\n  const requestedSize =\n    typeof sizeOverride === \"string\" && sizeOverride.trim() ? sizeOverride : rest.requestedSize;\n  const metadataRecord = {\n    imageId,\n    mimeType: blob.type || \"image/png\",\n    size: blob.size,\n    ...rest,\n    requestedSize,\n    savedAt: Date.now(),\n  };\n\n  console.log(`${LOG_PREFIX} Image save start`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.put(metadataRecord as any);\n    await db.imageBlobs.put({ imageId, blob });\n  });\n\n  console.log(`${LOG_PREFIX} Image save complete`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  return imageId;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}, {"name": "blob", "type": "Blob", "optional": false}, {"name": "metadata", "type": "ImageMetadata", "optional": false}], "returnType": "Promise<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImage", "name": "deleteImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "export async function deleteImage(imageId: string): Promise<void> {\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.delete(imageId);\n    await db.imageBlobs.delete(imageId);\n  });\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImages", "name": "searchImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Queries\n// ============================================================================\n\n/**\n * Search images with pagination \u2014 returns metadata only (no blobs).\n */\nexport async function searchImages(options: ImageSearchOptions = {}): Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, search, limit = 20, offset = 0 } = options;\n  const searchLower = search?.toLowerCase() || \"\";\n\n  // Fetch candidates \u2014 use index when filtering by projectId\n  const allRecords = projectId\n    ? await db.images.where(\"projectId\").equals(projectId).toArray()\n    : await db.images.toArray();\n\n  // Apply search filter (on entityName \u2014 lightweight)\n  const filtered = searchLower\n    ? allRecords.filter((r) => r.entityName && r.entityName.toLowerCase().includes(searchLower))\n    : allRecords;\n\n  const total = filtered.length;\n\n  // Paginate and project to lightweight list items (no blob)\n  const items: ImageListItem[] = filtered.slice(offset, offset + limit).map((r) => ({\n    imageId: r.imageId,\n    entityId: r.entityId,\n    projectId: r.projectId,\n    entityName: r.entityName,\n    entityKind: r.entityKind,\n    generatedAt: r.generatedAt,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "options", "type": "ImageSearchOptions", "optional": true}], "returnType": "Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageDataUrl", "name": "getImageDataUrl", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Load a single image's dataUrl by ID (on-demand loading).\n */\nexport async function getImageDataUrl(imageId: string): Promise<string | null> {\n  const blobRecord = await db.imageBlobs.get(imageId);\n  if (!blobRecord?.blob) return null;\n\n  try {\n    return await blobToDataUrl(blobRecord.blob);\n  } catch (err) {\n    console.warn(`Failed to convert image ${imageId} to dataUrl:`, err);\n    return null;\n  }\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<string | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::loadImage", "name": "loadImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Load / Browse (used by UI components that previously used Canonry imageStore)\n// ============================================================================\n\n/**\n * Load an image by ID and create an object URL.\n * Returns { url, ...metadata } or null if not found.\n * Caller is responsible for revoking the object URL.\n */\nexport async function loadImage(imageId: string): Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null> {\n  if (!imageId) return null;\n  const [metadata, blobRecord] = await Promise.all([\n    db.images.get(imageId),\n    db.imageBlobs.get(imageId),\n  ]);\n  if (!metadata || !blobRecord?.blob) return null;\n\n  const url = URL.createObjectURL(blobRecord.blob);\n  return {\n    url,\n    imageId: metadata.imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    mimeType: metadata.mimeType,\n    size: metadata.size,\n    generatedAt: metadata.generatedAt,\n    model: metadata.model,\n    originalPrompt: metadata.originalPrompt,\n    finalPrompt: metadata.finalPrompt,\n    revisedPrompt: metadata.revisedPrompt,\n    entityName: metadata.entityName,\n    entityKind: metadata.entityKind,\n    entityCulture: metadata.entityCulture,\n    imageType: metadata.imageType,\n    chronicleId: metadata.chronicleId,\n    imageRefId: metadata.imageRefId,\n    sceneDescription: metadata.sceneDescription,\n  };\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get raw image blob by ID.\n */\nexport async function getImageBlob(imageId: string): Promise<Blob | null> {\n  if (!imageId) return null;\n  const record = await db.imageBlobs.get(imageId);\n  return record?.blob || null;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<Blob | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getAllImages", "name": "getAllImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get all images (metadata only, no blobs) sorted newest first.\n */\nexport async function getAllImages(): Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n> {\n  const records = await db.images.toArray();\n  const images = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    projectId: record.projectId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    revisedPrompt: record.revisedPrompt,\n    estimatedCost: record.estimatedCost,\n    actualCost: record.actualCost,\n    inputTokens: record.inputTokens,\n    outputTokens: record.outputTokens,\n    width: record.width,\n    height: record.height,\n    aspect: record.aspect,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    imageRefId: record.imageRefId,\n    sceneDescription: record.sceneDescription,\n    mimeType: record.mimeType,\n    size: typeof record.size === \"number\" && Number.isFinite(record.size) ? record.size : 0,\n    savedAt: record.savedAt,\n    hasBlob: true,\n  }));\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n  return images;\n}", "parameters": [], "returnType": "Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImages", "name": "deleteImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Delete multiple images by ID.\n */\nexport async function deleteImages(imageIds: string[]): Promise<void> {\n  if (!imageIds?.length) return;\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.bulkDelete(imageIds);\n    await db.imageBlobs.bulkDelete(imageIds);\n  });\n}", "parameters": [{"name": "imageIds", "type": "string[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getStorageStats", "name": "getStorageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get storage statistics (count, total size, breakdown by project).\n */\nexport async function getStorageStats(): Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}> {\n  const records = await db.images.toArray();\n\n  let totalSize = 0;\n  const byProject: Record<string, { count: number; size: number }> = {};\n\n  for (const img of records) {\n    const size = typeof img.size === \"number\" && Number.isFinite(img.size) ? img.size : 0;\n    totalSize += size;\n\n    const pid = img.projectId || \"unknown\";\n    if (!byProject[pid]) {\n      byProject[pid] = { count: 0, size: 0 };\n    }\n    byProject[pid].count++;\n    byProject[pid].size += size;\n  }\n\n  return { totalCount: records.length, totalSize, byProject };\n}", "parameters": [], "returnType": "Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageFilterOptions", "name": "getImageFilterOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get unique values for a metadata field (for filter dropdowns).\n */\nexport async function getImageFilterOptions(\n  field: \"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"\n): Promise<string[]> {\n  const records = await db.images.toArray();\n  const values = new Set<string>();\n  for (const record of records) {\n    const val = (record as any)[field];\n    if (val) values.add(val);\n  }\n  return [...values].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "field", "type": "\"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImagesWithFilters", "name": "searchImagesWithFilters", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search images with rich filters (entity kind, culture, model, text search).\n * Returns metadata without blobs.\n */\nexport async function searchImagesWithFilters(\n  filters: {\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  } = {}\n): Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>> {\n  const records = await db.images.toArray();\n\n  let images: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }> = records.map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  if (filters.projectId) images = images.filter((img) => img.projectId === filters.projectId);\n  if (filters.entityKind) images = images.filter((img) => img.entityKind === filters.entityKind);\n  if (filters.entityCulture)\n    images = images.filter((img) => img.entityCulture === filters.entityCulture);\n  if (filters.model) images = images.filter((img) => img.model === filters.model);\n  if (filters.imageType) images = images.filter((img) => img.imageType === filters.imageType);\n  if (filters.chronicleId) images = images.filter((img) => img.chronicleId === filters.chronicleId);\n  if (filters.imageRefId) images = images.filter((img) => img.imageRefId === filters.imageRefId);\n\n  if (filters.searchText) {\n    const search = filters.searchText.toLowerCase();\n    images = images.filter(\n      (img) =>\n        img.entityName?.toLowerCase().includes(search) ||\n        img.originalPrompt?.toLowerCase().includes(search) ||\n        img.finalPrompt?.toLowerCase().includes(search) ||\n        img.revisedPrompt?.toLowerCase().includes(search)\n    );\n  }\n\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  if (filters.limit && filters.limit > 0) {\n    images = images.slice(0, filters.limit);\n  }\n\n  return images;\n}", "parameters": [{"name": "filters", "type": "{\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  }", "optional": true}], "returnType": "Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchChronicleImages", "name": "searchChronicleImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search chronicle images with pagination.\n * Uses indexed queries when possible for better performance on large libraries.\n */\nexport async function searchChronicleImages(filters: {\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, chronicleId, imageRefId, limit = 20, offset = 0 } = filters;\n\n  // Start with indexed query on chronicleId if provided, else projectId\n  const query = chronicleId\n    ? db.images.where(\"chronicleId\").equals(chronicleId)\n    : db.images.where(\"projectId\").equals(projectId);\n\n  let records = await query.toArray();\n\n  // Apply additional filters\n  if (chronicleId && !imageRefId) {\n    // Already filtered by chronicleId via index\n  } else if (imageRefId) {\n    records = records.filter((r) => r.imageRefId === imageRefId);\n  }\n\n  // Only include chronicle images\n  records = records.filter((r) => r.imageType === \"chronicle\");\n\n  // Sort by generatedAt descending\n  records.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  const total = records.length;\n\n  // Paginate\n  const items = records.slice(offset, offset + limit).map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "filters", "type": "{\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}", "optional": false}], "returnType": "Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::formatBytes", "name": "formatBytes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (!bytes || !Number.isFinite(bytes) || bytes <= 0) return \"0 B\";\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n}", "parameters": [{"name": "bytes", "type": "number", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::exportImagePrompts", "name": "exportImagePrompts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Bulk Export for Prompt Analysis\n// ============================================================================\n\n/**\n * Export all image prompt data for analysis.\n * Excludes image blobs to keep export size manageable.\n */\nexport async function exportImagePrompts(): Promise<ImagePromptExport[]> {\n  const records = await db.images.toArray();\n\n  const exports: ImagePromptExport[] = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    revisedPrompt: record.revisedPrompt,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    sceneDescription: record.sceneDescription,\n  }));\n\n  // Sort by generatedAt descending (newest first)\n  exports.sort((a, b) => b.generatedAt - a.generatedAt);\n  return exports;\n}", "parameters": [], "returnType": "Promise<ImagePromptExport[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::downloadImagePromptExport", "name": "downloadImagePromptExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Export image prompts and download as JSON file.\n */\nexport async function downloadImagePromptExport(): Promise<void> {\n  const exports = await exportImagePrompts();\n  const json = JSON.stringify(exports, null, 2);\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `image-prompts-${new Date().toISOString().split(\"T\")[0]}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n\n  console.log(`Exported ${exports.length} image prompt records`);\n}", "parameters": [], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageType", "ImageAspect", "ImageMetadata", "ImageRecord", "ImageListItem", "ImageSearchOptions", "ImagePromptExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexComputation.ts::computeRunIndexes", "name": "computeRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexComputation.ts", "sourceCode": "export function computeRunIndexes(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): RunIndexRecord {\n  // --- Prominence scale (exclude manual_ entities) ---\n  const prominenceValues = entities\n    .filter((e) => !e.id.startsWith(\"manual_\"))\n    .map((e) => e.prominence)\n    .filter((v): v is number => typeof v === \"number\" && Number.isFinite(v));\n\n  const prominenceScale = buildProminenceScale(prominenceValues, {\n    distribution: DEFAULT_PROMINENCE_DISTRIBUTION,\n  });\n\n  const renownedThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  // --- Era temporal info ---\n  const eraEntities = entities.filter(\n    (e) => e.kind === \"era\" && (e as any).temporal?.startTick != null\n  );\n  const sortedEras = [...eraEntities].sort(\n    (a, b) => (a as any).temporal.startTick - (b as any).temporal.startTick\n  );\n\n  const eraTemporalInfo: EraTemporalEntry[] = sortedEras.map((era, index) => {\n    const startTick: number = (era as any).temporal.startTick;\n    const endTick: number = (era as any).temporal.endTick ?? startTick;\n    const eraId = resolveEntityEraId(era) || era.id;\n    return {\n      id: eraId,\n      name: era.name,\n      summary: (era as any).summary || \"\",\n      order: index,\n      startTick,\n      endTick,\n      duration: endTick - startTick,\n    };\n  });\n\n  // --- Era ID aliases (entityId -> eraId for eraTemporalInfoByKey) ---\n  const eraIdAliases: Record<string, string> = {};\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") continue;\n    const eraId = resolveEntityEraId(entity);\n    if (eraId) {\n      eraIdAliases[entity.id] = eraId;\n    }\n  }\n\n  // --- Prominent by culture (all entities, threshold from scale) ---\n  const prominentByCulture: Record<string, Array<{ id: string; name: string }>> = {};\n  for (const entity of entities) {\n    if (!entity.culture) continue;\n    if (typeof entity.prominence !== \"number\" || entity.prominence < renownedThreshold) continue;\n    if (!prominentByCulture[entity.culture]) {\n      prominentByCulture[entity.culture] = [];\n    }\n    prominentByCulture[entity.culture].push({ id: entity.id, name: entity.name });\n  }\n\n  return {\n    simulationRunId,\n    prominenceScale,\n    renownedThreshold,\n    eraTemporalInfo,\n    eraIdAliases,\n    prominentByCulture,\n    computedAt: Date.now(),\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "RunIndexRecord", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldEntity"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceThresholdFromScale"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["RunIndexRecord", "EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::getRunIndexes", "name": "getRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function getRunIndexes(simulationRunId: string): Promise<RunIndexRecord | undefined> {\n  return db.runIndexes.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<RunIndexRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./indexTypes", "specifiers": ["RunIndexRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::upsertRunIndexes", "name": "upsertRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function upsertRunIndexes(record: RunIndexRecord): Promise<void> {\n  await db.runIndexes.put(record);\n}", "parameters": [{"name": "record", "type": "RunIndexRecord", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./indexTypes", "specifiers": ["RunIndexRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::deleteRunIndexes", "name": "deleteRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function deleteRunIndexes(simulationRunId: string): Promise<void> {\n  await db.runIndexes.delete(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./indexTypes", "specifiers": ["RunIndexRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts::migrateFromLegacyDbs", "name": "migrateFromLegacyDbs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Run all legacy migrations. Safe to call multiple times \u2014 already-migrated\n * databases are skipped via localStorage tracking.\n */\nexport async function migrateFromLegacyDbs(): Promise<void> {\n  const state = getState();\n  const allDbs = [\n    \"canonry-chronicles\",\n    \"canonry-images\",\n    \"canonry-costs\",\n    \"canonry-traits\",\n    \"canonry-historian\",\n    \"canonry-summary-revision\",\n    \"canonry-dynamics-generation\",\n    \"canonry-static-pages\",\n    \"illuminator-styles\",\n  ];\n\n  const pending = allDbs.filter((name) => !(name in state));\n  if (pending.length === 0) return;\n\n  console.log(`${LOG_PREFIX} Starting migration for ${pending.length} legacy databases:`, pending);\n\n  // Run all migrations in parallel \u2014 they're independent\n  await Promise.allSettled([\n    migrateChronicles(),\n    migrateImages(),\n    migrateCosts(),\n    migrateTraits(),\n    migrateHistorianRuns(),\n    migrateSummaryRevisionRuns(),\n    migrateDynamicsRuns(),\n    migrateStaticPages(),\n    migrateStyleLibrary(),\n  ]);\n\n  console.log(`${LOG_PREFIX} Migration complete`);\n}", "parameters": [], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayout", "name": "getPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayout(\n  simulationRunId: string,\n  pageId: string\n): Promise<PageLayoutOverride | null> {\n  const record = await db.pageLayouts.get([simulationRunId, pageId]);\n  return record ?? null;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::putPageLayout", "name": "putPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function putPageLayout(override: PageLayoutOverride): Promise<void> {\n  await db.pageLayouts.put(override);\n}", "parameters": [{"name": "override", "type": "PageLayoutOverride", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::deletePageLayout", "name": "deletePageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function deletePageLayout(simulationRunId: string, pageId: string): Promise<void> {\n  await db.pageLayouts.delete([simulationRunId, pageId]);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getAllPageLayouts", "name": "getAllPageLayouts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getAllPageLayouts(simulationRunId: string): Promise<PageLayoutOverride[]> {\n  return db.pageLayouts.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayoutMap", "name": "getPageLayoutMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayoutMap(\n  simulationRunId: string\n): Promise<Map<string, PageLayoutOverride>> {\n  const all = await getAllPageLayouts(simulationRunId);\n  const map = new Map<string, PageLayoutOverride>();\n  for (const o of all) {\n    map.set(o.pageId, o);\n  }\n  return map;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, PageLayoutOverride>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../preprint/prePrintTypes", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::isRelationshipsSeeded", "name": "isRelationshipsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isRelationshipsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.relationships.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[RelationshipRepo] isRelationshipsSeeded\", {\n    simulationRunId,\n    count,\n    seeded: count > 0,\n  });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::seedRelationships", "name": "seedRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "export async function seedRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<void> {\n  console.log(\"[RelationshipRepo] seedRelationships\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  const records: PersistedRelationship[] = relationships.map((rel) => ({\n    ...rel,\n    simulationRunId,\n  }));\n  await db.relationships.bulkPut(records);\n  console.log(\"[RelationshipRepo] seedRelationships complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::patchRelationships", "name": "patchRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Patch relationships without overwriting existing records.\n * Inserts only missing relationship keys (src/dst/kind).\n */\nexport async function patchRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<number> {\n  if (!relationships?.length) return 0;\n\n  const existing = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingKeys = new Set(existing.map((rel) => `${rel.src}:${rel.dst}:${rel.kind}`));\n\n  const toAdd: PersistedRelationship[] = [];\n  for (const rel of relationships) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!existingKeys.has(key)) {\n      toAdd.push({ ...rel, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.relationships.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForRun", "name": "getRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getRelationshipsForRun(\n  simulationRunId: string\n): Promise<PersistedRelationship[]> {\n  const relationships = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[RelationshipRepo] getRelationshipsForRun\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  return relationships;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForEntity", "name": "getRelationshipsForEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Get all relationships involving a specific entity (as src or dst).\n * Uses the existing 'src' and 'dst' indexes for efficient per-entity queries.\n */\nexport async function getRelationshipsForEntity(\n  simulationRunId: string,\n  entityId: string\n): Promise<PersistedRelationship[]> {\n  const [asSrc, asDst] = await Promise.all([\n    db.relationships\n      .where(\"src\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n    db.relationships\n      .where(\"dst\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n  ]);\n  const seen = new Set<string>();\n  const result: PersistedRelationship[] = [];\n  for (const rel of [...asSrc, ...asDst]) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(rel);\n    }\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::deleteRelationshipsForRun", "name": "deleteRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteRelationshipsForRun(simulationRunId: string): Promise<void> {\n  await db.relationships.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["WorldRelationship"], "category": "external"}, {"source": "./illuminatorDb", "specifiers": ["db", "PersistedRelationship"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::getSchema", "name": "getSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function getSchema(projectId: string): Promise<WorldSchemaRecord | undefined> {\n  return db.worldSchemas.get(projectId);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<WorldSchemaRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "WorldSchemaRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::upsertSchema", "name": "upsertSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function upsertSchema(projectId: string, schema: CanonrySchemaSlice): Promise<void> {\n  await db.worldSchemas.put({\n    projectId,\n    schema,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "WorldSchemaRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function getSlot(\n  projectId: string,\n  slotIndex: number\n): Promise<SimulationSlotRecord | undefined> {\n  return db.simulationSlots.get([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<SimulationSlotRecord | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "SimulationSlotRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::upsertSlot", "name": "upsertSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function upsertSlot(record: SimulationSlotRecord): Promise<void> {\n  await db.simulationSlots.put(record);\n}", "parameters": [{"name": "record", "type": "SimulationSlotRecord", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "SimulationSlotRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::deleteSlot", "name": "deleteSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function deleteSlot(projectId: string, slotIndex: number): Promise<void> {\n  await db.simulationSlots.delete([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db", "SimulationSlotRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generatePageId", "name": "generatePageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generatePageId(): string {\n  return `static_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generateSlug", "name": "generateSlug", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, \"\")\n    .replace(/\\s+/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .substring(0, 100);\n}", "parameters": [{"name": "title", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::extractEntityLinks", "name": "extractEntityLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function extractEntityLinks(content: string): string[] {\n  const regex = /\\[\\[([^\\]]+)\\]\\]/g; // eslint-disable-line sonarjs/slow-regex -- character-class bounded, no backtracking\n  const matches: string[] = [];\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const entityName = match[1].trim();\n    if (entityName && !matches.includes(entityName)) {\n      matches.push(entityName);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::countWords", "name": "countWords", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function countWords(content: string): number {\n  /* eslint-disable sonarjs/slow-regex -- character-class bounded markdown patterns, no backtracking */\n  const plainText = content\n    .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, \"$1\")\n    .replace(/\\[\\[([^\\]]+)\\]\\]/g, \"$1\")\n    .replace(/!\\[[^\\]]*\\]\\([^)]+\\)/g, \"\")\n    /* eslint-enable sonarjs/slow-regex */\n    .replace(/[#*_~`>]/g, \"\")\n    .replace(/\\n+/g, \" \")\n    .trim();\n\n  if (!plainText) return 0;\n  return plainText.split(/\\s+/).length;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::createStaticPage", "name": "createStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function createStaticPage(input: CreateStaticPageInput): Promise<StaticPage> {\n  const now = Date.now();\n  const content = input.content ?? \"\";\n\n  const page: StaticPage = {\n    pageId: generatePageId(),\n    projectId: input.projectId,\n    title: input.title,\n    slug: generateSlug(input.title),\n    content,\n    summary: input.summary,\n    status: input.status ?? \"draft\",\n    createdAt: now,\n    updatedAt: now,\n    linkedEntityIds: extractEntityLinks(content),\n    wordCount: countWords(content),\n  };\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "input", "type": "CreateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::updateStaticPage", "name": "updateStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function updateStaticPage(\n  pageId: string,\n  updates: UpdateStaticPageInput\n): Promise<StaticPage> {\n  const page = await db.staticPages.get(pageId);\n  if (!page) throw new Error(`Static page ${pageId} not found`);\n\n  if (updates.title !== undefined) {\n    page.title = updates.title;\n    page.slug = generateSlug(updates.title);\n  }\n  if (updates.content !== undefined) {\n    page.content = updates.content;\n    page.linkedEntityIds = extractEntityLinks(updates.content);\n    page.wordCount = countWords(updates.content);\n  }\n  if (updates.summary !== undefined) {\n    page.summary = updates.summary;\n  }\n  if (updates.status !== undefined) {\n    page.status = updates.status;\n  }\n  page.updatedAt = Date.now();\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}, {"name": "updates", "type": "UpdateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPage", "name": "getStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPage(pageId: string): Promise<StaticPage | undefined> {\n  return db.staticPages.get(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await db.staticPages.where(\"projectId\").equals(projectId).toArray();\n  pages.sort((a, b) => b.updatedAt - a.updatedAt);\n  return pages;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getPublishedStaticPagesForProject", "name": "getPublishedStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getPublishedStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await getStaticPagesForProject(projectId);\n  return pages.filter((page) => page.status === \"published\");\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPage", "name": "deleteStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPage(pageId: string): Promise<void> {\n  await db.staticPages.delete(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPagesForProject(projectId: string): Promise<number> {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n  await db.staticPages.bulkDelete(pages.map((p) => p.pageId));\n  return pages.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage", "StaticPageStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::loadStyleLibrary", "name": "loadStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function loadStyleLibrary(): Promise<StyleLibrary | null> {\n  const result = await db.styleLibrary.get(LIBRARY_KEY);\n  return result?.library ?? null;\n}", "parameters": [], "returnType": "Promise<StyleLibrary | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["StyleLibraryRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::saveStyleLibrary", "name": "saveStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function saveStyleLibrary(library: StyleLibrary): Promise<void> {\n  const record: StyleLibraryRecord = {\n    id: LIBRARY_KEY,\n    library,\n    savedAt: Date.now(),\n  };\n  await db.styleLibrary.put(record);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["StyleLibraryRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::resetStyleLibrary", "name": "resetStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function resetStyleLibrary(): Promise<void> {\n  await db.styleLibrary.delete(LIBRARY_KEY);\n}", "parameters": [], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["StyleLibraryRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::getStyleLibrary", "name": "getStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function getStyleLibrary(): Promise<StyleLibrary> {\n  const stored = await loadStyleLibrary();\n  if (stored) return stored;\n  return createDefaultStyleLibrary();\n}", "parameters": [], "returnType": "Promise<StyleLibrary>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["StyleLibraryRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::hasCustomStyleLibrary", "name": "hasCustomStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function hasCustomStyleLibrary(): Promise<boolean> {\n  const stored = await loadStyleLibrary();\n  return stored !== null;\n}", "parameters": [], "returnType": "Promise<boolean>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["StyleLibraryRecord"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::generateRevisionRunId", "name": "generateRevisionRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export function generateRevisionRunId(): string {\n  return `revrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionRunStatus", "SummaryRevisionBatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::createRevisionRun", "name": "createRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function createRevisionRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string,\n  batches: SummaryRevisionBatch[],\n  context: {\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }\n): Promise<SummaryRevisionRun> {\n  const now = Date.now();\n\n  const run: SummaryRevisionRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    batches,\n    currentBatchIndex: 0,\n    patchDecisions: {},\n    worldDynamicsContext: context.worldDynamicsContext,\n    staticPagesContext: context.staticPagesContext,\n    schemaContext: context.schemaContext,\n    revisionGuidance: context.revisionGuidance,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "batches", "type": "SummaryRevisionBatch[]", "optional": false}, {"name": "context", "type": "{\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }", "optional": false}], "returnType": "Promise<SummaryRevisionRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionRunStatus", "SummaryRevisionBatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::getRevisionRun", "name": "getRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function getRevisionRun(runId: string): Promise<SummaryRevisionRun | undefined> {\n  return db.summaryRevisionRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<SummaryRevisionRun | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionRunStatus", "SummaryRevisionBatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::updateRevisionRun", "name": "updateRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function updateRevisionRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<SummaryRevisionRun> {\n  const run = await db.summaryRevisionRuns.get(runId);\n  if (!run) throw new Error(`Revision run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.batches !== undefined) run.batches = updates.batches;\n  if (updates.currentBatchIndex !== undefined) run.currentBatchIndex = updates.currentBatchIndex;\n  if (updates.patchDecisions !== undefined) run.patchDecisions = updates.patchDecisions;\n  if (updates.error !== undefined) (run as any).error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<SummaryRevisionRun>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionRunStatus", "SummaryRevisionBatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::deleteRevisionRun", "name": "deleteRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function deleteRevisionRun(runId: string): Promise<void> {\n  await db.summaryRevisionRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionRunStatus", "SummaryRevisionBatch"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getPalette", "name": "getPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getPalette(\n  projectId: string,\n  entityKind: string\n): Promise<TraitPalette | null> {\n  const id = paletteId(projectId, entityKind);\n  const result = await db.traitPalettes.get(id);\n  return result || null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::savePalette", "name": "savePalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function savePalette(palette: TraitPalette): Promise<void> {\n  await db.traitPalettes.put({\n    ...palette,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "palette", "type": "TraitPalette", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::updatePaletteItems", "name": "updatePaletteItems", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function updatePaletteItems(\n  projectId: string,\n  entityKind: string,\n  updates: {\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }\n): Promise<TraitPalette> {\n  const existing = await getPalette(projectId, entityKind);\n  const items = existing?.items || [];\n  const now = Date.now();\n\n  let filtered = items.filter((item) => !updates.removeIds?.includes(item.id));\n\n  for (const merge of updates.merges || []) {\n    const keepItem = filtered.find((i) => i.id === merge.keepId);\n    if (keepItem) {\n      keepItem.description = merge.newDescription;\n      const mergedItems = items.filter((i) => merge.mergeFromIds.includes(i.id));\n      keepItem.timesUsed += mergedItems.reduce((sum, i) => sum + i.timesUsed, 0);\n    }\n    filtered = filtered.filter((i) => !merge.mergeFromIds.includes(i.id));\n  }\n\n  for (const newItem of updates.newItems || []) {\n    filtered.push({\n      id: `palette_${now}_${crypto.randomUUID().slice(0, 8)}`,\n      category: newItem.category,\n      description: newItem.description,\n      examples: newItem.examples,\n      subtypes: newItem.subtypes,\n      era: newItem.era,\n      timesUsed: 0,\n      addedAt: now,\n    });\n  }\n\n  const palette: TraitPalette = {\n    id: paletteId(projectId, entityKind),\n    projectId,\n    entityKind,\n    items: filtered,\n    updatedAt: now,\n  };\n\n  await savePalette(palette);\n  return palette;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }", "optional": false}], "returnType": "Promise<TraitPalette>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::incrementPaletteUsage", "name": "incrementPaletteUsage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function incrementPaletteUsage(\n  projectId: string,\n  entityKind: string,\n  traits: string[]\n): Promise<void> {\n  const palette = await getPalette(projectId, entityKind);\n  if (!palette || palette.items.length === 0) return;\n\n  const traitLower = traits.map((t) => t.toLowerCase()).join(\" \");\n  let updated = false;\n\n  for (const item of palette.items) {\n    const categoryWords = item.category.toLowerCase().split(/\\s+/);\n    const exampleWords = item.examples.flatMap((e) => e.toLowerCase().split(/\\s+/));\n    const allWords = [...categoryWords, ...exampleWords];\n\n    const matches = allWords.filter((w) => w.length > 4 && traitLower.includes(w));\n    if (matches.length >= 2) {\n      item.timesUsed += 1;\n      updated = true;\n    }\n  }\n\n  if (updated) {\n    await savePalette(palette);\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::registerUsedTraits", "name": "registerUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function registerUsedTraits(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  entityId: string,\n  entityName: string,\n  traits: string[]\n): Promise<void> {\n  if (traits.length === 0) return;\n\n  const id = usedTraitId(projectId, simulationRunId, entityKind, entityId);\n\n  const record: UsedTraitRecord = {\n    id,\n    projectId,\n    simulationRunId,\n    entityKind,\n    entityId,\n    entityName,\n    traits,\n    registeredAt: Date.now(),\n  };\n\n  await db.usedTraits.put(record);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "entityName", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getUsedTraitsForRun", "name": "getUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string\n): Promise<UsedTraitRecord[]> {\n  if (!projectId || !simulationRunId || !entityKind) return [];\n\n  // Filter in memory \u2014 Dexie compound index not declared, use simple index\n  const records = await db.usedTraits.where(\"simulationRunId\").equals(simulationRunId).toArray();\n\n  return records.filter((r) => r.projectId === projectId && r.entityKind === entityKind);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<UsedTraitRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getHistoricalTraits", "name": "getHistoricalTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getHistoricalTraits(\n  projectId: string,\n  entityKind: string\n): Promise<string[]> {\n  if (!projectId || !entityKind) return [];\n\n  const records = await db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  return records.flatMap((r) => r.traits);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::countUsedTraits", "name": "countUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function countUsedTraits(projectId: string, entityKind: string): Promise<number> {\n  if (!projectId || !entityKind) return 0;\n\n  return db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .count();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getTraitGuidance", "name": "getTraitGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getTraitGuidance(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  subtype?: string,\n  eraId?: string\n): Promise<TraitGuidance> {\n  const palette = await getPalette(projectId, entityKind);\n  const allItems = palette?.items || [];\n\n  const categoryUsage: Record<string, number> = {};\n  for (const item of allItems) {\n    categoryUsage[item.category] = item.timesUsed;\n  }\n\n  if (!subtype) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  const subtypePool: PaletteItem[] = [];\n  const eraPool: PaletteItem[] = [];\n\n  for (const item of allItems) {\n    if (item.era) {\n      if (eraId && item.era.toLowerCase() === eraId.toLowerCase()) {\n        eraPool.push(item);\n      }\n    } else {\n      if (categoryMatchesSubtype(item, subtype)) {\n        subtypePool.push(item);\n      }\n    }\n  }\n\n  const numSubtypeCategories = Math.min(2, subtypePool.length);\n  const subtypeAssigned = selectCategoriesWeighted(subtypePool, numSubtypeCategories);\n  const eraAssigned = selectCategoriesWeighted(eraPool, 1);\n  const assigned = [...subtypeAssigned, ...eraAssigned];\n\n  if (assigned.length === 0) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  return {\n    assignedCategories: assigned,\n    categoryUsage,\n    selectionMethod: \"weighted-random\",\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "subtype", "type": "string", "optional": true}, {"name": "eraId", "type": "string", "optional": true}], "returnType": "Promise<TraitGuidance>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::deleteUsedTraitsForRun", "name": "deleteUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup / Export\n// ---------------------------------------------------------------------------\n\nexport async function deleteUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string\n): Promise<number> {\n  const records = await db.usedTraits\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  if (records.length === 0) return 0;\n  await db.usedTraits.bulkDelete(records.map((r) => r.id));\n  return records.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::exportPalettes", "name": "exportPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function exportPalettes(projectId: string): Promise<TraitPalette[]> {\n  return db.traitPalettes.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::importPalettes", "name": "importPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function importPalettes(palettes: TraitPalette[]): Promise<void> {\n  await db.traitPalettes.bulkPut(palettes);\n}", "parameters": [{"name": "palettes", "type": "TraitPalette[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDb", "specifiers": ["db"], "category": "internal"}, {"source": "../traitTypes", "specifiers": ["TraitPalette", "UsedTraitRecord", "PaletteItem", "TraitGuidance"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::createScaffold", "name": "createScaffold", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Scaffold\n// =============================================================================\n\nexport function createScaffold(projectId: string, simulationRunId: string): ContentTreeState {\n  return {\n    projectId,\n    simulationRunId,\n    nodes: [\n      {\n        id: generateId(),\n        name: \"Front Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Title Page\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Copyright\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Table of Contents\", type: \"folder\", children: [] },\n        ],\n      },\n      {\n        id: generateId(),\n        name: \"Body\",\n        type: \"folder\",\n        children: [],\n      },\n      {\n        id: generateId(),\n        name: \"Back Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Appendix\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Glossary\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Index\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Colophon\", type: \"folder\", children: [] },\n        ],\n      },\n    ],\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}]