[{"id": "packages/shared-components/src/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }"}, {"id": "packages/shared-components/src/index.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }"}, {"id": "packages/shared-components/src/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }"}, {"id": "packages/shared-components/src/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string"}, {"id": "packages/shared-components/src/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}"}, {"id": "packages/shared-components/src/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/TagSelector.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/TagSelector.jsx", "sourceCode": "export default function TagSelector({\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [highlightedIndex, setHighlightedIndex] = useState(0);\n  const [hoveredInvalidTag, setHoveredInvalidTag] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const tagLookup = useMemo(() => {\n    const lookup = {};\n    tagRegistry.forEach((tagDef) => {\n      lookup[tagDef.tag] = tagDef;\n    });\n    return lookup;\n  }, [tagRegistry]);\n\n  const groupedTags = useMemo(() => {\n    const groups = {};\n    const filtered = tagRegistry.filter((tagDef) => {\n      const normalizedQuery = searchQuery.toLowerCase();\n      const matchesSearch =\n        !searchQuery ||\n        tagDef.tag.toLowerCase().includes(normalizedQuery) ||\n        tagDef.description?.toLowerCase().includes(normalizedQuery);\n      return matchesSearch && !value.includes(tagDef.tag);\n    });\n\n    filtered.forEach((tagDef) => {\n      if (!groups[tagDef.category]) {\n        groups[tagDef.category] = [];\n      }\n      groups[tagDef.category].push(tagDef);\n    });\n\n    return groups;\n  }, [searchQuery, tagRegistry, value]);\n\n  const canCreateTag = useMemo(() => {\n    if (!searchQuery.trim()) return false;\n    const normalized = searchQuery.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');\n    if (!normalized) return false;\n    if (tagLookup[normalized]) return false;\n    if (value.includes(normalized)) return false;\n    return normalized;\n  }, [searchQuery, tagLookup, value]);\n\n  const flatOptions = useMemo(() => {\n    const result = [];\n    Object.entries(groupedTags).forEach(([_category, tags]) => {\n      tags.forEach((tagDef) => result.push({ type: 'existing', ...tagDef }));\n    });\n    if (canCreateTag) {\n      result.push({ type: 'create', tag: canCreateTag });\n    }\n    return result;\n  }, [groupedTags, canCreateTag]);\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (containerRef.current && !containerRef.current.contains(event.target)) {\n        setIsOpen(false);\n        setHoveredInvalidTag(null);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleKeyDown = (event) => {\n    if (!isOpen) {\n      if (event.key === 'Enter' || event.key === 'ArrowDown') {\n        event.preventDefault();\n        setIsOpen(true);\n      }\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.min(index + 1, flatOptions.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.max(index - 1, 0));\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (!flatOptions[highlightedIndex]) return;\n        if (flatOptions[highlightedIndex].type === 'create') {\n          handleCreateAndSelect(flatOptions[highlightedIndex].tag);\n        } else {\n          handleSelectTag(flatOptions[highlightedIndex].tag);\n        }\n        break;\n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        break;\n      case 'Backspace':\n        if (searchQuery === '' && value.length > 0) {\n          handleRemoveTag(value[value.length - 1]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleSelectTag = (tag) => {\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemoveTag = (tag) => {\n    onChange(value.filter((item) => item !== tag));\n  };\n\n  const handleCreateAndSelect = (tag) => {\n    if (onAddToRegistry) {\n      onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n    }\n\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleInvalidTagMouseEnter = (tag) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredInvalidTag(tag);\n  };\n\n  const handleInvalidTagMouseLeave = () => {\n    hoverTimeoutRef.current = setTimeout(() => {\n      setHoveredInvalidTag(null);\n    }, 150);\n  };\n\n  const handlePopupMouseEnter = () => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n  };\n\n  const renderRarityDots = (rarity) => {\n    const count = RARITY_DOTS[rarity] || RARITY_DOTS.common;\n    return (\n      <span className=\"tag-selector-rarity-dots\">\n        {Array.from({ length: count }).map((_, index) => (\n          <span key={index} className={`tag-selector-rarity-dot ${getRarityClass(rarity)}`} />\n        ))}\n      </span>\n    );\n  };\n\n  return (\n    <div ref={containerRef} className=\"tag-selector\">\n      <div\n        className={`tag-selector-input-wrapper ${isOpen ? 'tag-selector-input-wrapper-open' : 'tag-selector-input-wrapper-closed'}`}\n        onClick={() => {\n          setIsOpen(true);\n          inputRef.current?.focus();\n        }}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(event) => {\n          if (event.key === 'Enter' || event.key === ' ') {\n            event.currentTarget.click();\n          }\n        }}\n      >\n        {value.map((tag) => {\n          const tagMeta = tagLookup[tag];\n          const isInvalid = !tagMeta;\n          const categoryClass = isInvalid ? 'tag-selector-category-invalid' : getCategoryClass(tagMeta.category);\n\n          return (\n            <span\n              key={tag}\n              className={`tag-selector-chip ${categoryClass}`}\n              title={isInvalid ? 'Tag not in registry - hover to add' : tagMeta?.description}\n              onMouseEnter={() => isInvalid && onAddToRegistry && handleInvalidTagMouseEnter(tag)}\n              onMouseLeave={() => isInvalid && handleInvalidTagMouseLeave()}\n            >\n              {isInvalid && <span className=\"tag-selector-invalid-warning\">\u26a0</span>}\n              {tag}\n              {tagMeta?.isAxis && <span title=\"Semantic plane axis label\" className=\"tag-selector-axis-indicator\">\u2194</span>}\n              {tagMeta && renderRarityDots(tagMeta.rarity)}\n              <button\n                type=\"button\"\n                className=\"tag-selector-remove-button\"\n                onClick={(event) => {\n                  event.stopPropagation();\n                  handleRemoveTag(tag);\n                }}\n              >\n                \u00d7\n              </button>\n              {isInvalid && hoveredInvalidTag === tag && onAddToRegistry && (\n                <div\n                  className=\"tag-selector-invalid-popup\"\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n                    setHoveredInvalidTag(null);\n                  }}\n                  onMouseEnter={handlePopupMouseEnter}\n                  onMouseLeave={() => setHoveredInvalidTag(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(event) => {\n                    if (event.key === 'Enter' || event.key === ' ') {\n                      event.currentTarget.click();\n                    }\n                  }}\n                >\n                  + Add to registry\n                </div>\n              )}\n            </span>\n          );\n        })}\n\n        <input\n          ref={inputRef}\n          type=\"text\"\n          className=\"tag-selector-search-input\"\n          value={searchQuery}\n          onChange={(event) => {\n            setSearchQuery(event.target.value);\n            setHighlightedIndex(0);\n          }}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsOpen(true)}\n          placeholder={value.length === 0 ? placeholder : ''}\n        />\n      </div>\n\n      {matchAllEnabled && value.length > 1 && (\n        <div className=\"tag-selector-match-all\">\n          <label className=\"tag-selector-match-all-label\">\n            <input\n              type=\"checkbox\"\n              className=\"tag-selector-match-all-checkbox\"\n              checked={matchAll}\n              onChange={(event) => onMatchAllChange?.(event.target.checked)}\n            />\n            Match all tags (AND)\n          </label>\n          <span className=\"tag-selector-match-all-hint\">\n            {matchAll ? 'Entity must have all tags' : 'Entity must have any tag'}\n          </span>\n        </div>\n      )}\n\n      {isOpen && (\n        <div className=\"tag-selector-dropdown\">\n          {canCreateTag && onAddToRegistry && (\n            <div\n              className={`tag-selector-create-option ${highlightedIndex === flatOptions.length - 1 ? 'tag-selector-create-option-highlighted' : ''}`}\n              onClick={() => handleCreateAndSelect(canCreateTag)}\n              onMouseEnter={() => setHighlightedIndex(flatOptions.length - 1)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(event) => {\n                if (event.key === 'Enter' || event.key === ' ') {\n                  event.currentTarget.click();\n                }\n              }}\n            >\n// ... (truncated)", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}", "type": "{ value?: any[]; onChange: any; tagRegistry?: any[]; onAddToRegistry: any; placeholder?: string; matchAllEnabled?: boolean; matchAll?: boolean; onMatchAllChange: any; singleSelect?: boolean; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/CategorySection.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/CategorySection.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/ChipSelect.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ChipSelect.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * @typedef {Object} ChronicleRoleAssignment\r\n * @property {string} role\r\n * @property {string} entityId\r\n * @property {string} entityName\r\n * @property {string} entityKind\r\n * @property {boolean} isPrimary\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleTemporalContext\r\n * @property {{ id: string, name: string, summary?: string }} [focalEra]\r\n * @property {[number, number]} [chronicleTickRange]\r\n * @property {string} [temporalScope]\r\n * @property {boolean} [isMultiEra]\r\n * @property {string[]} [touchedEraIds]\r\n * @property {string} [temporalDescription]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleSeedData\r\n * @property {string} narrativeStyleId\r\n * @property {string} [narrativeStyleName]\r\n * @property {string} [entrypointId]\r\n * @property {string} [entrypointName]\r\n * @property {string} [narrativeDirection]\r\n * @property {ChronicleRoleAssignment[]} roleAssignments\r\n * @property {string[]} selectedEventIds\r\n * @property {string[]} selectedRelationshipIds\r\n * @property {ChronicleTemporalContext} [temporalContext]\r\n */\r\n\r\n/**\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames] - Resolved display names for event IDs\r\n * @param {Map<string, string>} [props.relationshipLabels] - Resolved display labels for relationship IDs\r\n */\r\nexport default function ChronicleSeedViewer({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}) {\r\n  const primaryRoles = seed.roleAssignments.filter((r) => r.isPrimary);\r\n  const supportingRoles = seed.roleAssignments.filter((r) => !r.isPrimary);\r\n\r\n  return (\r\n    <div className=\"csv-container\">\r\n      {/* Style & Entry Point */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Generation Settings</div>\r\n        <div className=\"csv-field\">\r\n          <span className=\"csv-field-label\">Style:</span>\r\n          <span className=\"csv-field-value\">{seed.narrativeStyleName || seed.narrativeStyleId}</span>\r\n        </div>\r\n        {seed.entrypointId && (\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Entry Point:</span>\r\n            <span className=\"csv-field-value\">{seed.entrypointName || seed.entrypointId}</span>\r\n          </div>\r\n        )}\r\n        {seed.narrativeDirection && (\r\n          <div className=\"csv-narrative-direction-wrapper\">\r\n            <div className=\"csv-narrative-direction-label\">\r\n              Narrative Direction:\r\n            </div>\r\n            <div\r\n              className=\"csv-narrative-direction-body\"\r\n              title=\"Click to copy\"\r\n              onClick={() => void navigator.clipboard.writeText(seed.narrativeDirection)}\r\n              role=\"button\"\r\n              tabIndex={0}\r\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n            >\r\n              {seed.narrativeDirection}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Role Assignments */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Cast ({seed.roleAssignments.length} entities)</div>\r\n        {seed.roleAssignments.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No roles assigned</div>\r\n        ) : (\r\n          <div className=\"csv-role-list\">\r\n            {primaryRoles.map((role, i) => (\r\n              <div key={`primary-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-primary-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n            {supportingRoles.map((role, i) => (\r\n              <div key={`supporting-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-supporting-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Temporal Context (optional, used by chronicler) */}\r\n      {seed.temporalContext && (\r\n        <div className=\"csv-section\">\r\n          <div className=\"csv-section-title\">Temporal Context</div>\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Focal Era:</span>\r\n            <span className=\"csv-field-value\">\r\n              {seed.temporalContext.focalEra?.name || \"Unknown\"}\r\n            </span>\r\n          </div>\r\n          {seed.temporalContext.focalEra?.summary && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Era Summary:</span>\r\n              <span className=\"csv-field-value\">{seed.temporalContext.focalEra.summary}</span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.temporalDescription && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Scope:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.temporalDescription}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.chronicleTickRange && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Ticks:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.chronicleTickRange[0]}&ndash;\r\n                {seed.temporalContext.chronicleTickRange[1]}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {typeof seed.temporalContext.isMultiEra === \"boolean\" && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Multi-era:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.isMultiEra ? \"Yes\" : \"No\"}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.touchedEraIds?.length ? (\r\n            <div>\r\n              <div className=\"csv-field-label-spaced\">Touched Eras:</div>\r\n              <div className=\"csv-id-list\">\r\n                {seed.temporalContext.touchedEraIds.map((id) => (\r\n                  <span key={id} className=\"csv-id-tag\">\r\n                    {id}\r\n                  </span>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n      )}\r\n\r\n      {/* Selected Events */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Events ({seed.selectedEventIds.length})</div>\r\n        {seed.selectedEventIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No events selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedEventIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {eventNames?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Selected Relationships */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Relationships ({seed.selectedRelationshipIds.length})</div>\r\n        {seed.selectedRelationshipIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No relationships selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedRelationshipIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {relationshipLabels?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/EmptyState.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/EmptyState.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/EnableToggle.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/EnableToggle.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/ExpandableCard.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ExpandableCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/FormGroup.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/IconButton.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/IconButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/InfoBox.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/InfoBox.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/NumberInput.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/NumberInput.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/ReferenceDropdown.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ReferenceDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/SectionHeader.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/SectionHeader.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }"}, {"id": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/components/CoverageMatrix/CoverageMatrix.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/CoverageMatrix/CoverageMatrix.jsx", "sourceCode": "export default function CoverageMatrix({\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}) {\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n  const [activeFilter, setActiveFilter] = useState(null);\r\n\r\n  // Normalize columns to { id, label } format\r\n  const normalizedColumns = useMemo(() => {\r\n    return columns.map((col) =>\r\n      typeof col === 'string' ? { id: col, label: col } : col\r\n    );\r\n  }, [columns]);\r\n\r\n  // Filter rows by search\r\n  const filteredRows = useMemo(() => {\r\n    let result = rows;\r\n\r\n    if (searchQuery) {\r\n      const query = searchQuery.toLowerCase();\r\n      result = result.filter(\r\n        (row) =>\r\n          row.id.toLowerCase().includes(query) ||\r\n          row.label.toLowerCase().includes(query) ||\r\n          (row.groupLabel && row.groupLabel.toLowerCase().includes(query))\r\n      );\r\n    }\r\n\r\n    if (activeFilter && filterOptions.length > 0) {\r\n      const filterDef = filterOptions.find((f) => f.id === activeFilter);\r\n      if (filterDef?.filter) {\r\n        result = result.filter(filterDef.filter);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }, [rows, searchQuery, activeFilter, filterOptions]);\r\n\r\n  // Group rows if groupByField is specified\r\n  const groupedRows = useMemo(() => {\r\n    if (!groupByField) {\r\n      return { _ungrouped: { label: '', rows: filteredRows } };\r\n    }\r\n\r\n    const groups = {};\r\n    filteredRows.forEach((row) => {\r\n      const groupId = row[groupByField] || '_ungrouped';\r\n      const groupLabel = row.groupLabel || groupId;\r\n      if (!groups[groupId]) {\r\n        groups[groupId] = { label: groupLabel, rows: [] };\r\n      }\r\n      groups[groupId].rows.push(row);\r\n    });\r\n    return groups;\r\n  }, [filteredRows, groupByField]);\r\n\r\n  // Default cell display function\r\n  const defaultGetCellDisplay = (value) => {\r\n    switch (value) {\r\n      case 'primary':\r\n        return { icon: '\u2713', className: 'primary', title: 'Primary' };\r\n      case 'secondary':\r\n        return { icon: '\u25cb', className: 'secondary', title: 'Secondary' };\r\n      case 'both':\r\n        return { icon: '\u25c9', className: 'both', title: 'Both' };\r\n      case 'none':\r\n      default:\r\n        return { icon: '-', className: 'none', title: 'None' };\r\n    }\r\n  };\r\n\r\n  const displayFn = getCellDisplay || defaultGetCellDisplay;\r\n\r\n  return (\r\n    <div className=\"coverage-matrix\">\r\n      {/* Header */}\r\n      <div className=\"cm-header\">\r\n        <h2 className=\"cm-title\">{title}</h2>\r\n        {subtitle && <p className=\"cm-subtitle\">{subtitle}</p>}\r\n      </div>\r\n\r\n      {/* Stats Bar */}\r\n      {stats.length > 0 && (\r\n        <div className=\"cm-stats\">\r\n          {stats.map((stat, idx) => (\r\n            <div key={idx} className={`cm-stat ${stat.variant || ''}`}>\r\n              <span className=\"cm-stat-value\">{stat.value}</span>\r\n              <span className=\"cm-stat-label\">{stat.label}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Toolbar */}\r\n      <div className=\"cm-toolbar\">\r\n        <input\r\n          type=\"text\"\r\n          className=\"cm-search\"\r\n          placeholder={searchPlaceholder}\r\n          value={searchQuery}\r\n          onChange={(e) => setSearchQuery(e.target.value)}\r\n        />\r\n        {filterOptions.length > 0 && (\r\n          <div className=\"cm-filters\">\r\n            {filterOptions.map((filter) => (\r\n              <button\r\n                key={filter.id}\r\n                className={`cm-filter-btn ${activeFilter === filter.id ? 'active' : ''}`}\r\n                onClick={() =>\r\n                  setActiveFilter(activeFilter === filter.id ? null : filter.id)\r\n                }\r\n              >\r\n                {filter.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Matrix Grid */}\r\n      <div className=\"cm-container\">\r\n        {(normalizedColumns.length === 0 || rows.length === 0) && (\r\n          <div className=\"cm-empty\">{emptyMessage}</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length === 0 && (\r\n          <div className=\"cm-empty\">No items match the current filters.</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length > 0 && (\r\n          <table className=\"cm-table\">\r\n            <thead>\r\n              <tr>\r\n                <th className=\"cm-group-col\">Group</th>\r\n                <th className=\"cm-label-col\">Name</th>\r\n                <th className=\"cm-status-col\">Status</th>\r\n                {normalizedColumns.map((col) => (\r\n                  <th\r\n                    key={col.id}\r\n                    className={`cm-data-col ${columnHeaderClass?.(col.id) || ''}`}\r\n                    title={col.label}\r\n                  >\r\n                    {col.label}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {Object.entries(groupedRows).map(([groupId, { label: groupLabel, rows: groupRows }]) =>\r\n                groupRows.map((row, idx) => (\r\n                  <MatrixRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    idx={idx}\r\n                    groupId={groupId}\r\n                    groupLabel={groupLabel}\r\n                    columns={normalizedColumns}\r\n                    getCellValue={getCellValue}\r\n                    displayFn={displayFn}\r\n                    onRowClick={onRowClick}\r\n                    onCellClick={onCellClick}\r\n                  />\r\n                ))\r\n              )}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      {legend.length > 0 && (\r\n        <div className=\"cm-legend\">\r\n          {legend.map((item, idx) => (\r\n            <span key={idx} className=\"cm-legend-item\">\r\n              <span className={`cm-cell-icon sample ${item.className || ''}`}>\r\n                {item.icon}\r\n              </span>\r\n              {item.label}\r\n            </span>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}", "type": "{ rows?: any[]; columns?: any[]; getCellValue: any; getCellDisplay: any; onRowClick: any; onCellClick: any; title?: string; subtitle?: string; stats?: any[]; legend?: any[]; searchPlaceholder?: string; groupByField?: string; columnHeaderClass: any; emptyMessage?: string; filterOptions?: any[]; }", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/utils/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }"}, {"id": "packages/shared-components/src/utils/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }"}, {"id": "packages/shared-components/src/utils/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string"}, {"id": "packages/shared-components/src/utils/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}"}, {"id": "packages/shared-components/src/utils/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "packages/shared-components/src/utils/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}]