[{"id": "apps/illuminator/webui/src/hooks/useImageGenSettings.ts::useImageGenSettings", "name": "useImageGenSettings", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useImageGenSettings.ts", "sourceCode": "/**\n * Hook providing global image generation settings backed by localStorage.\n *\n * Optional external sync: if onExternalSync is provided, changes are\n * also forwarded there (for syncing with parent shell).\n */\nexport function useImageGenSettings(\n  onExternalSync?: (settings: ImageGenSettings) => void\n): [ImageGenSettings, ImageGenSettingsUpdater] {\n  const [settings, setSettings] = useState<ImageGenSettings>(loadSettings);\n  const externalSyncRef = useRef(onExternalSync);\n  useEffect(() => {\n    externalSyncRef.current = onExternalSync;\n  }, [onExternalSync]);\n\n  const updateSettings = useCallback((partial: Partial<ImageGenSettings>) => {\n    setSettings((prev) => ({ ...prev, ...partial }));\n  }, []);\n\n  // Defer localStorage write and external sync to after render\n  const isInitialMount = useRef(true);\n  useEffect(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false;\n      return;\n    }\n    saveSettings(settings);\n    if (externalSyncRef.current) {\n      externalSyncRef.current(settings);\n    }\n  }, [settings]);\n\n  return [settings, updateSettings];\n}", "parameters": [{"name": "onExternalSync", "type": "(settings: ImageGenSettings) => void", "optional": true}], "returnType": "[ImageGenSettings, ImageGenSettingsUpdater]", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect", "useRef"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/hooks/usePromptBuilder.js::usePromptBuilder", "name": "usePromptBuilder", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/usePromptBuilder.js", "sourceCode": "// --- Main hook ---\n\nexport function usePromptBuilder({\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  relationshipsByEntity,\n  entityNavMap,\n  currentEra,\n  narrativeEvents,\n  prominentByCulture,\n  styleSelection,\n  worldSchema,\n  config,\n  prominenceScale,\n  styleLibrary,\n  eraTemporalInfo,\n  eraTemporalInfoByKey,\n}) {\n  // Get visual config for an entity (thesis/traits prompts, avoid elements, era)\n  const getVisualConfig = useCallback(\n    (entity) => {\n      const visualConfig = getVisualConfigFromGuidance(entityGuidance, entity.kind);\n\n      const entityEraId = resolveEntityEraId(entity);\n      const entityFocalEra = entityEraId ? eraTemporalInfoByKey.get(entityEraId) : undefined;\n      const entityAllEras = eraTemporalInfo.length > 0 ? eraTemporalInfo : undefined;\n\n      return {\n        ...visualConfig,\n        entityEraId,\n        entityFocalEra,\n        entityAllEras,\n      };\n    },\n    [entityGuidance, eraTemporalInfo, eraTemporalInfoByKey]\n  );\n\n  // Build prompt for entity using EntityGuidance and CultureIdentities directly\n  const buildPrompt = useCallback(\n    (entity, type) => {\n      const params = {\n        entityGuidance,\n        cultureIdentities,\n        worldContext,\n        relationshipsByEntity,\n        entityNavMap,\n        prominenceScale,\n        currentEra,\n        narrativeEvents,\n        prominentByCulture,\n        styleSelection,\n        worldSchema,\n        styleLibrary,\n        config,\n      };\n\n      if (type === \"description\") {\n        return buildEntityDescriptionPrompt(entity, params);\n      }\n      if (type === \"image\") {\n        return buildEntityImagePrompt(entity, params);\n      }\n      return `Describe ${entity.name}, a ${entity.subtype} ${entity.kind}.`;\n    },\n    [\n      worldContext,\n      entityGuidance,\n      cultureIdentities,\n      relationshipsByEntity,\n      entityNavMap,\n      currentEra,\n      narrativeEvents,\n      prominentByCulture,\n      styleSelection,\n      worldSchema,\n      styleLibrary,\n      config,\n      prominenceScale,\n    ]\n  );\n\n  return { buildPrompt, getVisualConfig };\n}", "parameters": [{"name": "{\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  relationshipsByEntity,\n  entityNavMap,\n  currentEra,\n  narrativeEvents,\n  prominentByCulture,\n  styleSelection,\n  worldSchema,\n  config,\n  prominenceScale,\n  styleLibrary,\n  eraTemporalInfo,\n  eraTemporalInfoByKey,\n}", "type": "{ entityGuidance: any; cultureIdentities: any; worldContext: any; relationshipsByEntity: any; entityNavMap: any; currentEra: any; narrativeEvents: any; prominentByCulture: any; styleSelection: any; worldSchema: any; config: any; prominenceScale: any; styleLibrary: any; eraTemporalInfo: any; eraTemporalInfoByKey: any; }", "optional": false}], "returnType": "{ buildPrompt: (entity: any, type: any) => string; getVisualConfig: (entity: any) => { entityEraId: any; entityFocalEra: any; entityAllEras: any; visualAvoid: string; visualThesisInstructions: string; visualThesisFraming: string; visualTraitsInstructions: string; visualTraitsFraming: string; }; }", "jsxLeafElements": [], "hookCalls": [{"name": "useCallback", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/promptBuilders", "specifiers": ["buildDescriptionPromptFromGuidance", "buildImagePromptFromGuidance", "getVisualConfigFromGuidance"], "category": "internal"}, {"source": "../components/StyleSelector", "specifiers": ["resolveStyleSelection"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "getEntityEvents", "getEntityEffects"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/hooks/useRevisionFlow.js::useRevisionFlow", "name": "useRevisionFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useRevisionFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useRevisionFlow({\n  projectId,\n  simulationRunId,\n  navEntities,\n  entityNavMap,\n  relationshipsByEntity,\n  prominenceScale,\n  worldContext,\n  worldSchema,\n  entityGuidance,\n  reloadEntities,\n}) {\n  const getEntityContextsForRevision = useCallback(\n    async (entityIds) => {\n      const fullEntities = await useEntityStore.getState().loadEntities(entityIds);\n      const params = { relationshipsByEntity, entityNavMap, prominenceScale, entityGuidance };\n      return fullEntities.map((entity) => mapEntityToRevisionContext(entity, params));\n    },\n    [entityNavMap, relationshipsByEntity, prominenceScale, entityGuidance]\n  );\n\n  const handleRevisionApplied = useCallback(\n    async (patches, source = \"summary-revision\") => {\n      if (!patches?.length) return;\n      const updatedIds = await entityRepo.applyRevisionPatches(patches, source);\n      await reloadEntities(updatedIds);\n    },\n    [reloadEntities]\n  );\n\n  const {\n    run: revisionRun,\n    isActive: isRevisionActive,\n    startRevision,\n    continueToNextBatch,\n    autoContineAll: autoContineAllRevision,\n    togglePatchDecision,\n    applyAccepted: applyAcceptedPatches,\n    cancelRevision,\n  } = useSummaryRevision(getEntityContextsForRevision);\n\n  const [revisionFilter, setRevisionFilter] = useState({\n    open: false,\n    totalEligible: 0,\n    usedInChronicles: 0,\n    chronicleEntityIds: new Set(),\n  });\n\n  const handleOpenRevisionFilter = useCallback(async () => {\n    if (!projectId || !simulationRunId) return;\n    const eligible = navEntities.filter((e) => e.hasDescription && !e.lockedSummary);\n    let chronicleEntityIds = new Set();\n    try {\n      const usageStats = await getEntityUsageStats(simulationRunId);\n      chronicleEntityIds = new Set(usageStats.keys());\n    } catch (err) {\n      console.warn(\"[Revision] Failed to load chronicle usage stats:\", err);\n    }\n    const usedInChronicles = eligible.filter((e) => chronicleEntityIds.has(e.id)).length;\n    setRevisionFilter({\n      open: true,\n      totalEligible: eligible.length,\n      usedInChronicles,\n      chronicleEntityIds,\n    });\n  }, [projectId, simulationRunId, navEntities]);\n\n  const handleStartRevision = useCallback(\n    async (excludeChronicleEntities) => {\n      if (!projectId || !simulationRunId) return;\n      setRevisionFilter((prev) => ({ ...prev, open: false }));\n      await buildRevisionStartPayload({\n        projectId,\n        simulationRunId,\n        worldContext,\n        worldSchema,\n        navEntities,\n        entityNavMap,\n        relationshipsByEntity,\n        prominenceScale,\n        excludeChronicleEntities,\n        chronicleEntityIds: revisionFilter.chronicleEntityIds,\n        startRevision,\n      });\n    },\n    [\n      projectId,\n      simulationRunId,\n      worldContext,\n      worldSchema,\n      navEntities,\n      entityNavMap,\n      relationshipsByEntity,\n      prominenceScale,\n      startRevision,\n      revisionFilter.chronicleEntityIds,\n    ]\n  );\n\n  const handleAcceptRevision = useCallback(() => {\n    handleRevisionApplied(applyAcceptedPatches());\n  }, [applyAcceptedPatches, handleRevisionApplied]);\n\n  return {\n    revisionRun,\n    isRevisionActive,\n    revisionFilter,\n    setRevisionFilter,\n    getEntityContextsForRevision,\n    handleOpenRevisionFilter,\n    handleStartRevision,\n    handleAcceptRevision,\n    continueToNextBatch,\n    autoContineAllRevision,\n    togglePatchDecision,\n    cancelRevision,\n    startRevision,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  navEntities,\n  entityNavMap,\n  relationshipsByEntity,\n  prominenceScale,\n  worldContext,\n  worldSchema,\n  entityGuidance,\n  reloadEntities,\n}", "type": "{ projectId: any; simulationRunId: any; navEntities: any; entityNavMap: any; relationshipsByEntity: any; prominenceScale: any; worldContext: any; worldSchema: any; entityGuidance: any; reloadEntities: any; }", "optional": false}], "returnType": "{ revisionRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isRevisionActive: boolean; revisionFilter: { open: boolean; totalEligible: number; usedInChronicles: number; chronicleEntityIds: Set<any>; }; setRevisionFilter: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<{ open: boolean; totalEligible: number; usedInChronicles: number; chronicleEntityIds: Set<any>; }>>; getEntityContextsForRevision: (entityIds: any) => Promise<{ existingAnchorPhrases: any; kindFocus: any; prominence: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").ProminenceLabel; relationships: any; aliases: any; subtype: any; culture: any; status: any; summary: any; description: any; visualThesis: any; id: any; name: any; kind: any; }[]>; handleOpenRevisionFilter: () => Promise<void>; handleStartRevision: (excludeChronicleEntities: any) => Promise<void>; handleAcceptRevision: () => void; continueToNextBatch: () => Promise<void>; autoContineAllRevision: () => Promise<void>; togglePatchDecision: (entityId: string, accepted: boolean) => Promise<void>; cancelRevision: () => void; startRevision: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useSummaryRevision\").SummaryRevisionConfig) => Promise<void>; }", "jsxLeafElements": [], "hookCalls": [{"name": "useCallback", "count": 5}, {"name": "useSummaryRevision", "count": 1}, {"name": "useState", "count": 1}], "customHookCalls": ["useSummaryRevision"], "imports": [{"source": "react", "specifiers": ["useState", "useCallback"], "category": "framework"}, {"source": "./useSummaryRevision", "specifiers": ["useSummaryRevision"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getEntityUsageStats"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getPublishedStaticPagesForProject"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/hooks/useStyleLibrary.ts::useStyleLibrary", "name": "useStyleLibrary", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useStyleLibrary.ts", "sourceCode": "export function useStyleLibrary(): UseStyleLibraryReturn {\n  const [styleLibrary, setStyleLibrary] = useState<StyleLibrary>(() => createDefaultStyleLibrary());\n  const [loading, setLoading] = useState(true);\n  const [isCustom, setIsCustom] = useState(false);\n\n  // Load style library on mount\n  useEffect(() => {\n    async function load() {\n      try {\n        const stored = await loadStyleLibrary();\n        if (stored) {\n          setStyleLibrary(stored);\n          setIsCustom(true);\n        } else {\n          setStyleLibrary(createDefaultStyleLibrary());\n          setIsCustom(false);\n        }\n      } catch (err) {\n        console.error(\"[useStyleLibrary] Failed to load:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n    void load();\n  }, []);\n\n  // Save entire library\n  const save = useCallback(async (library: StyleLibrary) => {\n    await saveStyleLibrary(library);\n    setStyleLibrary(library);\n    setIsCustom(true);\n  }, []);\n\n  // Reset to defaults\n  const reset = useCallback(async () => {\n    await resetStyleLibrary();\n    setStyleLibrary(createDefaultStyleLibrary());\n    setIsCustom(false);\n  }, []);\n\n  // Add artistic style\n  const addArtisticStyle = useCallback(\n    async (style: ArtisticStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: [...styleLibrary.artisticStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update artistic style\n  const updateArtisticStyle = useCallback(\n    async (id: string, updates: Partial<ArtisticStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: styleLibrary.artisticStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete artistic style\n  const deleteArtisticStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        artisticStyles: styleLibrary.artisticStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Add composition style\n  const addCompositionStyle = useCallback(\n    async (style: CompositionStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: [...styleLibrary.compositionStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update composition style\n  const updateCompositionStyle = useCallback(\n    async (id: string, updates: Partial<CompositionStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: styleLibrary.compositionStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete composition style\n  const deleteCompositionStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        compositionStyles: styleLibrary.compositionStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Add narrative style\n  const addNarrativeStyle = useCallback(\n    async (style: NarrativeStyle) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: [...styleLibrary.narrativeStyles, style],\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Update narrative style\n  const updateNarrativeStyle = useCallback(\n    async (id: string, updates: Partial<NarrativeStyle>) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: styleLibrary.narrativeStyles.map((s) =>\n          s.id === id ? { ...s, ...updates } : s\n        ),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  // Delete narrative style\n  const deleteNarrativeStyle = useCallback(\n    async (id: string) => {\n      const updated: StyleLibrary = {\n        ...styleLibrary,\n        narrativeStyles: styleLibrary.narrativeStyles.filter((s) => s.id !== id),\n      };\n      await save(updated);\n    },\n    [styleLibrary, save]\n  );\n\n  return {\n    styleLibrary,\n    loading,\n    isCustom,\n    save,\n    reset,\n    addArtisticStyle,\n    updateArtisticStyle,\n    deleteArtisticStyle,\n    addCompositionStyle,\n    updateCompositionStyle,\n    deleteCompositionStyle,\n    addNarrativeStyle,\n    updateNarrativeStyle,\n    deleteNarrativeStyle,\n  };\n}", "parameters": [], "returnType": "UseStyleLibraryReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 11}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["createDefaultStyleLibrary"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["StyleLibrary", "ArtisticStyle", "CompositionStyle", "NarrativeStyle"], "category": "external"}, {"source": "../lib/db/styleRepository", "specifiers": ["loadStyleLibrary", "saveStyleLibrary", "resetStyleLibrary"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useSummaryRevision.ts::useSummaryRevision", "name": "useSummaryRevision", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useSummaryRevision.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useSummaryRevision(\n  /** Callback to get entity context by IDs (called when dispatching a batch) */\n  getEntityContexts: (entityIds: string[]) => RevisionEntityContext[]\n): UseSummaryRevisionReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const autoModeRef = useRef(false);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for one batch\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__summary_revision__\",\n        name: \"Summary Revision\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"summaryRevision\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n\n            // In auto mode, continue to next batch if batch_reviewing\n            if (autoModeRef.current && updated.status === \"batch_reviewing\") {\n              const nextIndex = updated.currentBatchIndex + 1;\n              if (nextIndex < updated.batches.length) {\n                // Dispatch next batch\n                const nextBatch = updated.batches[nextIndex];\n                const contexts = getEntityContexts(nextBatch.entityIds);\n                await updateRevisionRun(runId, { currentBatchIndex: nextIndex });\n                dispatchBatch(runId, contexts);\n                startPolling(runId);\n              }\n            }\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling, dispatchBatch, getEntityContexts]\n  );\n\n  // Start a new revision session\n  const startRevision = useCallback(\n    async (config: SummaryRevisionConfig) => {\n      const runId = generateRevisionRunId();\n      autoModeRef.current = false;\n\n      // Filter out locked-summary entities\n      const eligibleEntities = config.entities;\n\n      // Group into batches\n      const batches = groupEntitiesIntoBatches(eligibleEntities);\n\n      if (batches.length === 0) {\n        return;\n      }\n\n      // Create run in IndexedDB\n      const newRun = await createRevisionRun(\n        runId,\n        config.projectId,\n        config.simulationRunId,\n        batches,\n        {\n          worldDynamicsContext: config.worldDynamicsContext,\n          staticPagesContext: config.staticPagesContext,\n          schemaContext: config.schemaContext,\n          revisionGuidance: config.revisionGuidance,\n        }\n      );\n\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch first batch\n      const firstBatch = batches[0];\n      const firstContexts = getEntityContexts(firstBatch.entityIds);\n      dispatchBatch(runId, firstContexts);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchBatch, startPolling, getEntityContexts]\n  );\n\n  // Continue to next batch after reviewing current one\n  const continueToNextBatch = useCallback(async () => {\n    if (!run) return;\n\n    const nextIndex = run.currentBatchIndex + 1;\n    if (nextIndex >= run.batches.length) {\n      // All batches done \u2014 move to run_reviewing\n      await updateRevisionRun(run.runId, { status: \"run_reviewing\" });\n      const updated = await getRevisionRun(run.runId);\n      if (updated) setRun(updated);\n      return;\n    }\n\n    // Advance to next batch\n    await updateRevisionRun(run.runId, {\n      currentBatchIndex: nextIndex,\n      status: \"generating\",\n    });\n\n    const nextBatch = run.batches[nextIndex];\n    const contexts = getEntityContexts(nextBatch.entityIds);\n    dispatchBatch(run.runId, contexts);\n    startPolling(run.runId);\n  }, [run, dispatchBatch, startPolling, getEntityContexts]);\n\n  // Auto-continue all remaining batches\n  const autoContineAll = useCallback(async () => {\n    if (!run) return;\n    autoModeRef.current = true;\n\n    // Trigger next batch\n    await continueToNextBatch();\n  }, [run, continueToNextBatch]);\n\n  // Toggle accept/reject for a specific entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply all accepted patches and return them\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect all patches from all batches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelRevision = useCallback(() => {\n    autoModeRef.current = false;\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startRevision,\n    continueToNextBatch,\n    autoContineAll,\n    togglePatchDecision,\n    applyAccepted,\n    cancelRevision,\n  };\n}", "parameters": [{"name": "getEntityContexts", "type": "(entityIds: string[]) => RevisionEntityContext[]", "optional": false}], "returnType": "UseSummaryRevisionReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useCallback", "count": 9}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionBatch", "SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::useToneRanking", "name": "useToneRanking", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "// ============================================================================\n// Hook \u2014 thin accessor over toneRankingStore\n// ============================================================================\n\nexport function useToneRanking(): UseToneRankingReturn {\n  const progress = useToneRankingStore((s) => s.progress);\n  const assignmentPreview = useToneRankingStore((s) => s.assignmentPreview);\n  const prepareToneRanking = useToneRankingStore((s) => s.prepareToneRanking);\n  const confirmToneRanking = useToneRankingStore((s) => s.confirmToneRanking);\n  const cancelToneRanking = useToneRankingStore((s) => s.cancelToneRanking);\n  const closeToneRanking = useToneRankingStore((s) => s.closeToneRanking);\n  const prepareAssignment = useToneRankingStore((s) => s.prepareAssignment);\n  const applyAssignment = useToneRankingStore((s) => s.applyAssignment);\n  const closeAssignment = useToneRankingStore((s) => s.closeAssignment);\n\n  const isActive = progress.status === \"running\" || progress.status === \"confirming\";\n\n  return {\n    progress,\n    isActive,\n    prepareToneRanking,\n    confirmToneRanking,\n    cancelToneRanking,\n    closeToneRanking,\n    assignmentPreview,\n    prepareAssignment,\n    applyAssignment,\n    closeAssignment,\n  };\n}", "parameters": [], "returnType": "UseToneRankingReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useToneRankingStore", "count": 9}], "customHookCalls": ["useToneRankingStore"], "imports": [{"source": "../lib/db/toneRankingStore", "specifiers": ["useToneRankingStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone"], "category": "internal"}]}, {"id": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/badges/index.js::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/index.js", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/components/badges/index.js::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/index.js", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/CoverageMatrix/index.js::CoverageMatrix", "name": "CoverageMatrix", "kind": "component", "filePath": "packages/shared-components/src/components/CoverageMatrix/index.js", "sourceCode": "export default function CoverageMatrix({\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}) {\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n  const [activeFilter, setActiveFilter] = useState(null);\r\n\r\n  // Normalize columns to { id, label } format\r\n  const normalizedColumns = useMemo(() => {\r\n    return columns.map((col) =>\r\n      typeof col === 'string' ? { id: col, label: col } : col\r\n    );\r\n  }, [columns]);\r\n\r\n  // Filter rows by search\r\n  const filteredRows = useMemo(() => {\r\n    let result = rows;\r\n\r\n    if (searchQuery) {\r\n      const query = searchQuery.toLowerCase();\r\n      result = result.filter(\r\n        (row) =>\r\n          row.id.toLowerCase().includes(query) ||\r\n          row.label.toLowerCase().includes(query) ||\r\n          (row.groupLabel && row.groupLabel.toLowerCase().includes(query))\r\n      );\r\n    }\r\n\r\n    if (activeFilter && filterOptions.length > 0) {\r\n      const filterDef = filterOptions.find((f) => f.id === activeFilter);\r\n      if (filterDef?.filter) {\r\n        result = result.filter(filterDef.filter);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }, [rows, searchQuery, activeFilter, filterOptions]);\r\n\r\n  // Group rows if groupByField is specified\r\n  const groupedRows = useMemo(() => {\r\n    if (!groupByField) {\r\n      return { _ungrouped: { label: '', rows: filteredRows } };\r\n    }\r\n\r\n    const groups = {};\r\n    filteredRows.forEach((row) => {\r\n      const groupId = row[groupByField] || '_ungrouped';\r\n      const groupLabel = row.groupLabel || groupId;\r\n      if (!groups[groupId]) {\r\n        groups[groupId] = { label: groupLabel, rows: [] };\r\n      }\r\n      groups[groupId].rows.push(row);\r\n    });\r\n    return groups;\r\n  }, [filteredRows, groupByField]);\r\n\r\n  // Default cell display function\r\n  const defaultGetCellDisplay = (value) => {\r\n    switch (value) {\r\n      case 'primary':\r\n        return { icon: '\u2713', className: 'primary', title: 'Primary' };\r\n      case 'secondary':\r\n        return { icon: '\u25cb', className: 'secondary', title: 'Secondary' };\r\n      case 'both':\r\n        return { icon: '\u25c9', className: 'both', title: 'Both' };\r\n      case 'none':\r\n      default:\r\n        return { icon: '-', className: 'none', title: 'None' };\r\n    }\r\n  };\r\n\r\n  const displayFn = getCellDisplay || defaultGetCellDisplay;\r\n\r\n  return (\r\n    <div className=\"coverage-matrix\">\r\n      {/* Header */}\r\n      <div className=\"cm-header\">\r\n        <h2 className=\"cm-title\">{title}</h2>\r\n        {subtitle && <p className=\"cm-subtitle\">{subtitle}</p>}\r\n      </div>\r\n\r\n      {/* Stats Bar */}\r\n      {stats.length > 0 && (\r\n        <div className=\"cm-stats\">\r\n          {stats.map((stat, idx) => (\r\n            <div key={idx} className={`cm-stat ${stat.variant || ''}`}>\r\n              <span className=\"cm-stat-value\">{stat.value}</span>\r\n              <span className=\"cm-stat-label\">{stat.label}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Toolbar */}\r\n      <div className=\"cm-toolbar\">\r\n        <input\r\n          type=\"text\"\r\n          className=\"cm-search\"\r\n          placeholder={searchPlaceholder}\r\n          value={searchQuery}\r\n          onChange={(e) => setSearchQuery(e.target.value)}\r\n        />\r\n        {filterOptions.length > 0 && (\r\n          <div className=\"cm-filters\">\r\n            {filterOptions.map((filter) => (\r\n              <button\r\n                key={filter.id}\r\n                className={`cm-filter-btn ${activeFilter === filter.id ? 'active' : ''}`}\r\n                onClick={() =>\r\n                  setActiveFilter(activeFilter === filter.id ? null : filter.id)\r\n                }\r\n              >\r\n                {filter.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Matrix Grid */}\r\n      <div className=\"cm-container\">\r\n        {(normalizedColumns.length === 0 || rows.length === 0) && (\r\n          <div className=\"cm-empty\">{emptyMessage}</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length === 0 && (\r\n          <div className=\"cm-empty\">No items match the current filters.</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length > 0 && (\r\n          <table className=\"cm-table\">\r\n            <thead>\r\n              <tr>\r\n                <th className=\"cm-group-col\">Group</th>\r\n                <th className=\"cm-label-col\">Name</th>\r\n                <th className=\"cm-status-col\">Status</th>\r\n                {normalizedColumns.map((col) => (\r\n                  <th\r\n                    key={col.id}\r\n                    className={`cm-data-col ${columnHeaderClass?.(col.id) || ''}`}\r\n                    title={col.label}\r\n                  >\r\n                    {col.label}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {Object.entries(groupedRows).map(([groupId, { label: groupLabel, rows: groupRows }]) =>\r\n                groupRows.map((row, idx) => (\r\n                  <MatrixRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    idx={idx}\r\n                    groupId={groupId}\r\n                    groupLabel={groupLabel}\r\n                    columns={normalizedColumns}\r\n                    getCellValue={getCellValue}\r\n                    displayFn={displayFn}\r\n                    onRowClick={onRowClick}\r\n                    onCellClick={onCellClick}\r\n                  />\r\n                ))\r\n              )}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      {legend.length > 0 && (\r\n        <div className=\"cm-legend\">\r\n          {legend.map((item, idx) => (\r\n            <span key={idx} className=\"cm-legend-item\">\r\n              <span className={`cm-cell-icon sample ${item.className || ''}`}>\r\n                {item.icon}\r\n              </span>\r\n              {item.label}\r\n            </span>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}", "type": "{ rows?: any[]; columns?: any[]; getCellValue: any; getCellDisplay: any; onRowClick: any; onCellClick: any; title?: string; subtitle?: string; stats?: any[]; legend?: any[]; searchPlaceholder?: string; groupByField?: string; columnHeaderClass: any; emptyMessage?: string; filterOptions?: any[]; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["h2", "p", "span", "input", "button", "div", "th", "tbody"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/components/hooks/useEditorState.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "packages/shared-components/src/components/hooks/useEditorState.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}]}, {"id": "packages/shared-components/src/components/hooks/useLocalInputState.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "packages/shared-components/src/components/hooks/useLocalInputState.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::ChronicleWizard", "name": "ChronicleWizard", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "// =============================================================================\n// Main Component (wraps with provider)\n// =============================================================================\n\nexport default function ChronicleWizard(props: Readonly<ChronicleWizardProps>) {\n  if (!props.isOpen) return null;\n\n  return (\n    <WizardProvider\n      entityKinds={props.entityKinds}\n      eras={props.eras ?? []}\n      simulationRunId={props.simulationRunId}\n    >\n      <InnerWizard {...props} />\n    </WizardProvider>\n  );\n}", "parameters": [{"name": "props", "type": "Readonly<ChronicleWizardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["InnerWizard"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::WizardProvider", "name": "WizardProvider", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "export function WizardProvider({\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}: Readonly<WizardProviderProps>) {\n  const [state, dispatch] = useReducer(wizardReducer, initialState);\n\n  // Build kind-to-category mapping\n  const kindToCategory = useMemo(() => buildKindToCategoryMap(entityKinds), [entityKinds]);\n\n  // Compute ALL relevant events (unlimited) for focal era computation\n  // This includes all events involving assigned entities, not just top 20\n  const allRelevantEvents = useMemo(() => {\n    const events = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    return events;\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Compute detected focal era from selected events (if any), otherwise all relevant events.\n  // This ensures that when the user narrows the event selection, the focal era updates to match.\n  const detectedFocalEra = useMemo<EraTemporalInfo | null>(() => {\n    if (eras.length === 0) return null;\n    // Prefer selected events when user has made a selection\n    const eventsForDetection =\n      state.selectedEventIds.size > 0\n        ? allRelevantEvents.filter((e) => state.selectedEventIds.has(e.id))\n        : allRelevantEvents;\n    return computeFocalEra(eventsForDetection, eras) || null;\n  }, [eras, allRelevantEvents, state.selectedEventIds]);\n\n  // Compute effective focal era (respecting override)\n  const effectiveFocalEraId = useMemo(() => {\n    return state.focalEraOverride || detectedFocalEra?.id || eras[0]?.id || \"\";\n  }, [state.focalEraOverride, detectedFocalEra, eras]);\n\n  // Compute temporal context from selected events, but align focal era to the dropdown choice\n  const temporalContext = useMemo<ChronicleTemporalContext | null>(() => {\n    if (eras.length === 0) return null;\n\n    // Get selected events for temporal computation\n    const selectedEvents = state.candidateEvents.filter((e) => state.selectedEventIds.has(e.id));\n\n    return computeTemporalContext(\n      selectedEvents,\n      eras,\n      state.entryPoint || undefined,\n      effectiveFocalEraId\n    );\n  }, [eras, state.candidateEvents, state.selectedEventIds, state.entryPoint, effectiveFocalEraId]);\n\n  // Navigation\n  const nextStep = useCallback(() => {\n    if (state.step < 5) {\n      dispatch({ type: \"SET_STEP\", step: (state.step + 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const prevStep = useCallback(() => {\n    if (state.step > 1) {\n      dispatch({ type: \"SET_STEP\", step: (state.step - 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const goToStep = useCallback((step: WizardStep) => {\n    dispatch({ type: \"SET_STEP\", step });\n  }, []);\n\n  // Step 1: Style selection\n  const selectStyle = useCallback((style: NarrativeStyle, acceptDefaults: boolean) => {\n    dispatch({ type: \"SELECT_STYLE\", style, acceptDefaults });\n  }, []);\n\n  const setAcceptDefaults = useCallback((acceptDefaults: boolean) => {\n    dispatch({ type: \"SET_ACCEPT_DEFAULTS\", acceptDefaults });\n  }, []);\n\n  // Step 2: Entry point selection\n  const selectEntryPoint = useCallback(\n    (\n      entity: EntityContext,\n      allEntities: EntityContext[],\n      allRelationships: RelationshipContext[],\n      allEvents: NarrativeEventContext[]\n    ) => {\n      dispatch({ type: \"SELECT_ENTRY_POINT\", entity });\n\n      // Build selection context for this entry point\n      if (state.narrativeStyle) {\n        const selectionContext = buildWizardSelectionContext(\n          entity,\n          allEntities,\n          allRelationships,\n          allEvents,\n          state.narrativeStyle,\n          { includeErasInNeighborhood: state.includeErasInNeighborhood }\n        );\n\n        dispatch({\n          type: \"SET_CANDIDATES\",\n          candidates: selectionContext.candidates,\n          relationships: selectionContext.candidateRelationships,\n          events: selectionContext.candidateEvents,\n          distances: selectionContext.distances,\n        });\n\n        // Auto-fill if accept defaults is checked\n        if (state.acceptDefaults) {\n          const roles = getRoles(state.narrativeStyle);\n          const suggested = suggestRoleAssignments(\n            selectionContext.candidates,\n            roles,\n            entity.id,\n            undefined, // entityRules removed\n            selectionContext.candidateRelationships,\n            kindToCategory\n          );\n          dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n        }\n      }\n    },\n    [state.narrativeStyle, state.acceptDefaults, state.includeErasInNeighborhood, kindToCategory]\n  );\n\n  // Clear entry point\n  const clearEntryPoint = useCallback(() => {\n    dispatch({ type: \"CLEAR_ENTRY_POINT\" });\n  }, []);\n\n  // Set include eras in neighborhood option\n  const setIncludeErasInNeighborhood = useCallback((include: boolean) => {\n    dispatch({ type: \"SET_INCLUDE_ERAS_IN_NEIGHBORHOOD\", include });\n  }, []);\n\n  // Compute metrics helper - uses stored distances from original graph construction\n  const computeMetrics = useCallback(\n    (usageStats: Map<string, { usageCount: number }>) => {\n      if (!state.entryPoint) return new Map<string, EntitySelectionMetrics>();\n\n      return computeAllEntityMetrics(\n        state.candidates,\n        state.entryPoint.id,\n        state.candidateRelationships,\n        state.candidateDistances,\n        usageStats,\n        state.roleAssignments,\n        kindToCategory\n      );\n    },\n    [\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      state.candidateDistances,\n      state.roleAssignments,\n      kindToCategory,\n    ]\n  );\n\n  // Compute event metrics for selection\n  const computeEventMetricsForSelection = useCallback(() => {\n    if (!state.entryPoint || eras.length === 0) {\n      return new Map<string, EventSelectionMetrics>();\n    }\n\n    // Get assigned entity IDs\n    const assignedEntityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n\n    return computeAllEventMetrics(\n      state.candidateEvents,\n      state.entryPoint.id,\n      state.entryPoint.createdAt,\n      effectiveFocalEraId,\n      eras,\n      assignedEntityIds\n    );\n  }, [state.entryPoint, state.candidateEvents, state.roleAssignments, eras, effectiveFocalEraId]);\n\n  // Auto-fill events based on temporal alignment\n  const autoFillEvents = useCallback(\n    (preferFocalEra: boolean = true) => {\n      const metricsMap = computeEventMetricsForSelection();\n\n      // Get relevant events (those involving assigned entities)\n      const relevantEvents = getRelevantEvents(\n        state.roleAssignments,\n        state.candidateEvents\n      );\n\n      const suggestedEventIds = suggestEventSelection(\n        relevantEvents,\n        metricsMap,\n        8, // maxEvents\n        preferFocalEra\n      );\n\n      dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds: suggestedEventIds });\n    },\n    [\n      computeEventMetricsForSelection,\n      state.roleAssignments,\n      state.candidateEvents,\n      state.narrativeStyle,\n    ]\n  );\n\n  // Auto-fill all events and relationships (used when skipping step 4 with defaults)\n  const autoFillEventsAndRelationships = useCallback(() => {\n    // Get all relevant relationships (include lens entity)\n    const lensIds = state.lens ? [state.lens.entityId] : [];\n    const relevantRelationships = getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensIds\n    );\n    const relationshipIds = relevantRelationships.map((r) => `${r.src}:${r.dst}:${r.kind}`);\n\n    // Get all relevant events\n    const relevantEvents = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    const eventIds = relevantEvents.map((e) => e.id);\n\n    // Select all\n    dispatch({ type: \"SELECT_ALL_RELATIONSHIPS\", relationshipIds });\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, [\n    state.roleAssignments,\n    state.candidateRelationships,\n    state.candidateEvents,\n    state.narrativeStyle,\n    state.lens,\n  ]);\n\n  // Step 3: Auto-fill roles\n  const autoFillRoles = useCallback(\n    (metricsMap?: Map<string, EntitySelectionMetrics>) => {\n      if (!state.narrativeStyle || !state.entryPoint) return;\n\n      const roles = getRoles(state.narrativeStyle);\n      const suggested = suggestRoleAssignments(\n        state.candidates,\n        roles,\n        state.entryPoint.id,\n        undefined, // entityRules removed\n        state.candidateRelationships,\n        kindToCategory,\n        metricsMap\n      );\n      dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n    },\n    [\n      state.narrativeStyle,\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      kindToCategory,\n    ]\n  );\n\n  const addRoleAssignment = useCallback((assignment: ChronicleRoleAssignment) => {\n    dispatch({ type: \"ADD_ROLE_ASSIGNMENT\", assignment });\n  }, []);\n\n  const removeRoleAssignment = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"REMOVE_ROLE_ASSIGNMENT\", entityId, role });\n  }, []);\n\n  const togglePrimary = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"TOGGLE_PRIMARY\", entityId, role });\n  }, []);\n\n  // Lens actions\n  const setLens = useCallback((lens: NarrativeLens) => {\n    dispatch({ type: \"SET_LENS\", lens });\n  }, []);\n\n  const clearLens = useCallback(() => {\n    dispatch({ type: \"CLEAR_LENS\" });\n  }, []);\n\n  // Step 4: Event/relationship selection\n  const toggleEvent = useCallback((eventId: string) => {\n    dispatch({ type: \"TOGGLE_EVENT\", eventId });\n  }, []);\n\n  const toggleRelationship = useCallback((relationshipId: string) => {\n    dispatch({ type: \"TOGGLE_RELATIONSHIP\", relationshipId });\n  }, []);\n\n  const selectAllEvents = useCallback((eventIds: string[]) => {\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, []);\n\n  const deselectAllEvents = useCallback(() => {\n    dispatch({ type: \"DESELECT_ALL_EVENTS\" });\n  }, []);\n// ... (truncated)", "parameters": [{"name": "{\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}", "type": "Readonly<WizardProviderProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["WizardContext.Provider"], "hookCalls": [{"name": "useReducer", "count": 1}, {"name": "useMemo", "count": 6}, {"name": "useCallback", "count": 28}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts::useWizard", "name": "useWizard", "kind": "hook", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/index.ts", "sourceCode": "// =============================================================================\n// Hook\n// =============================================================================\n\nexport function useWizard(): WizardContextValue {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error(\"useWizard must be used within a WizardProvider\");\n  }\n  return context;\n}", "parameters": [], "returnType": "WizardContextValue", "jsxLeafElements": [], "hookCalls": [{"name": "useContext", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx::WizardProvider", "name": "WizardProvider", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx", "sourceCode": "export function WizardProvider({\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}: Readonly<WizardProviderProps>) {\n  const [state, dispatch] = useReducer(wizardReducer, initialState);\n\n  // Build kind-to-category mapping\n  const kindToCategory = useMemo(() => buildKindToCategoryMap(entityKinds), [entityKinds]);\n\n  // Compute ALL relevant events (unlimited) for focal era computation\n  // This includes all events involving assigned entities, not just top 20\n  const allRelevantEvents = useMemo(() => {\n    const events = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    return events;\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Compute detected focal era from selected events (if any), otherwise all relevant events.\n  // This ensures that when the user narrows the event selection, the focal era updates to match.\n  const detectedFocalEra = useMemo<EraTemporalInfo | null>(() => {\n    if (eras.length === 0) return null;\n    // Prefer selected events when user has made a selection\n    const eventsForDetection =\n      state.selectedEventIds.size > 0\n        ? allRelevantEvents.filter((e) => state.selectedEventIds.has(e.id))\n        : allRelevantEvents;\n    return computeFocalEra(eventsForDetection, eras) || null;\n  }, [eras, allRelevantEvents, state.selectedEventIds]);\n\n  // Compute effective focal era (respecting override)\n  const effectiveFocalEraId = useMemo(() => {\n    return state.focalEraOverride || detectedFocalEra?.id || eras[0]?.id || \"\";\n  }, [state.focalEraOverride, detectedFocalEra, eras]);\n\n  // Compute temporal context from selected events, but align focal era to the dropdown choice\n  const temporalContext = useMemo<ChronicleTemporalContext | null>(() => {\n    if (eras.length === 0) return null;\n\n    // Get selected events for temporal computation\n    const selectedEvents = state.candidateEvents.filter((e) => state.selectedEventIds.has(e.id));\n\n    return computeTemporalContext(\n      selectedEvents,\n      eras,\n      state.entryPoint || undefined,\n      effectiveFocalEraId\n    );\n  }, [eras, state.candidateEvents, state.selectedEventIds, state.entryPoint, effectiveFocalEraId]);\n\n  // Navigation\n  const nextStep = useCallback(() => {\n    if (state.step < 5) {\n      dispatch({ type: \"SET_STEP\", step: (state.step + 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const prevStep = useCallback(() => {\n    if (state.step > 1) {\n      dispatch({ type: \"SET_STEP\", step: (state.step - 1) as WizardStep });\n    }\n  }, [state.step]);\n\n  const goToStep = useCallback((step: WizardStep) => {\n    dispatch({ type: \"SET_STEP\", step });\n  }, []);\n\n  // Step 1: Style selection\n  const selectStyle = useCallback((style: NarrativeStyle, acceptDefaults: boolean) => {\n    dispatch({ type: \"SELECT_STYLE\", style, acceptDefaults });\n  }, []);\n\n  const setAcceptDefaults = useCallback((acceptDefaults: boolean) => {\n    dispatch({ type: \"SET_ACCEPT_DEFAULTS\", acceptDefaults });\n  }, []);\n\n  // Step 2: Entry point selection\n  const selectEntryPoint = useCallback(\n    (\n      entity: EntityContext,\n      allEntities: EntityContext[],\n      allRelationships: RelationshipContext[],\n      allEvents: NarrativeEventContext[]\n    ) => {\n      dispatch({ type: \"SELECT_ENTRY_POINT\", entity });\n\n      // Build selection context for this entry point\n      if (state.narrativeStyle) {\n        const selectionContext = buildWizardSelectionContext(\n          entity,\n          allEntities,\n          allRelationships,\n          allEvents,\n          state.narrativeStyle,\n          { includeErasInNeighborhood: state.includeErasInNeighborhood }\n        );\n\n        dispatch({\n          type: \"SET_CANDIDATES\",\n          candidates: selectionContext.candidates,\n          relationships: selectionContext.candidateRelationships,\n          events: selectionContext.candidateEvents,\n          distances: selectionContext.distances,\n        });\n\n        // Auto-fill if accept defaults is checked\n        if (state.acceptDefaults) {\n          const roles = getRoles(state.narrativeStyle);\n          const suggested = suggestRoleAssignments(\n            selectionContext.candidates,\n            roles,\n            entity.id,\n            undefined, // entityRules removed\n            selectionContext.candidateRelationships,\n            kindToCategory\n          );\n          dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n        }\n      }\n    },\n    [state.narrativeStyle, state.acceptDefaults, state.includeErasInNeighborhood, kindToCategory]\n  );\n\n  // Clear entry point\n  const clearEntryPoint = useCallback(() => {\n    dispatch({ type: \"CLEAR_ENTRY_POINT\" });\n  }, []);\n\n  // Set include eras in neighborhood option\n  const setIncludeErasInNeighborhood = useCallback((include: boolean) => {\n    dispatch({ type: \"SET_INCLUDE_ERAS_IN_NEIGHBORHOOD\", include });\n  }, []);\n\n  // Compute metrics helper - uses stored distances from original graph construction\n  const computeMetrics = useCallback(\n    (usageStats: Map<string, { usageCount: number }>) => {\n      if (!state.entryPoint) return new Map<string, EntitySelectionMetrics>();\n\n      return computeAllEntityMetrics(\n        state.candidates,\n        state.entryPoint.id,\n        state.candidateRelationships,\n        state.candidateDistances,\n        usageStats,\n        state.roleAssignments,\n        kindToCategory\n      );\n    },\n    [\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      state.candidateDistances,\n      state.roleAssignments,\n      kindToCategory,\n    ]\n  );\n\n  // Compute event metrics for selection\n  const computeEventMetricsForSelection = useCallback(() => {\n    if (!state.entryPoint || eras.length === 0) {\n      return new Map<string, EventSelectionMetrics>();\n    }\n\n    // Get assigned entity IDs\n    const assignedEntityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n\n    return computeAllEventMetrics(\n      state.candidateEvents,\n      state.entryPoint.id,\n      state.entryPoint.createdAt,\n      effectiveFocalEraId,\n      eras,\n      assignedEntityIds\n    );\n  }, [state.entryPoint, state.candidateEvents, state.roleAssignments, eras, effectiveFocalEraId]);\n\n  // Auto-fill events based on temporal alignment\n  const autoFillEvents = useCallback(\n    (preferFocalEra: boolean = true) => {\n      const metricsMap = computeEventMetricsForSelection();\n\n      // Get relevant events (those involving assigned entities)\n      const relevantEvents = getRelevantEvents(\n        state.roleAssignments,\n        state.candidateEvents\n      );\n\n      const suggestedEventIds = suggestEventSelection(\n        relevantEvents,\n        metricsMap,\n        8, // maxEvents\n        preferFocalEra\n      );\n\n      dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds: suggestedEventIds });\n    },\n    [\n      computeEventMetricsForSelection,\n      state.roleAssignments,\n      state.candidateEvents,\n      state.narrativeStyle,\n    ]\n  );\n\n  // Auto-fill all events and relationships (used when skipping step 4 with defaults)\n  const autoFillEventsAndRelationships = useCallback(() => {\n    // Get all relevant relationships (include lens entity)\n    const lensIds = state.lens ? [state.lens.entityId] : [];\n    const relevantRelationships = getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensIds\n    );\n    const relationshipIds = relevantRelationships.map((r) => `${r.src}:${r.dst}:${r.kind}`);\n\n    // Get all relevant events\n    const relevantEvents = getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n    const eventIds = relevantEvents.map((e) => e.id);\n\n    // Select all\n    dispatch({ type: \"SELECT_ALL_RELATIONSHIPS\", relationshipIds });\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, [\n    state.roleAssignments,\n    state.candidateRelationships,\n    state.candidateEvents,\n    state.narrativeStyle,\n    state.lens,\n  ]);\n\n  // Step 3: Auto-fill roles\n  const autoFillRoles = useCallback(\n    (metricsMap?: Map<string, EntitySelectionMetrics>) => {\n      if (!state.narrativeStyle || !state.entryPoint) return;\n\n      const roles = getRoles(state.narrativeStyle);\n      const suggested = suggestRoleAssignments(\n        state.candidates,\n        roles,\n        state.entryPoint.id,\n        undefined, // entityRules removed\n        state.candidateRelationships,\n        kindToCategory,\n        metricsMap\n      );\n      dispatch({ type: \"SET_ROLE_ASSIGNMENTS\", assignments: suggested });\n    },\n    [\n      state.narrativeStyle,\n      state.entryPoint,\n      state.candidates,\n      state.candidateRelationships,\n      kindToCategory,\n    ]\n  );\n\n  const addRoleAssignment = useCallback((assignment: ChronicleRoleAssignment) => {\n    dispatch({ type: \"ADD_ROLE_ASSIGNMENT\", assignment });\n  }, []);\n\n  const removeRoleAssignment = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"REMOVE_ROLE_ASSIGNMENT\", entityId, role });\n  }, []);\n\n  const togglePrimary = useCallback((entityId: string, role: string) => {\n    dispatch({ type: \"TOGGLE_PRIMARY\", entityId, role });\n  }, []);\n\n  // Lens actions\n  const setLens = useCallback((lens: NarrativeLens) => {\n    dispatch({ type: \"SET_LENS\", lens });\n  }, []);\n\n  const clearLens = useCallback(() => {\n    dispatch({ type: \"CLEAR_LENS\" });\n  }, []);\n\n  // Step 4: Event/relationship selection\n  const toggleEvent = useCallback((eventId: string) => {\n    dispatch({ type: \"TOGGLE_EVENT\", eventId });\n  }, []);\n\n  const toggleRelationship = useCallback((relationshipId: string) => {\n    dispatch({ type: \"TOGGLE_RELATIONSHIP\", relationshipId });\n  }, []);\n\n  const selectAllEvents = useCallback((eventIds: string[]) => {\n    dispatch({ type: \"SELECT_ALL_EVENTS\", eventIds });\n  }, []);\n\n  const deselectAllEvents = useCallback(() => {\n    dispatch({ type: \"DESELECT_ALL_EVENTS\" });\n  }, []);\n// ... (truncated)", "parameters": [{"name": "{\n  children,\n  entityKinds,\n  eras = [],\n  simulationRunId,\n}", "type": "Readonly<WizardProviderProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["WizardContext.Provider"], "hookCalls": [{"name": "useReducer", "count": 1}, {"name": "useMemo", "count": 6}, {"name": "useCallback", "count": 28}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "createContext", "useContext", "useReducer", "ReactNode", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "EntityKindDefinition", "EntityCategory", "RoleDefinition"], "category": "external"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "NarrativeLens", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext"], "category": "internal"}, {"source": "../../lib/chronicle/selectionWizard", "specifiers": ["buildWizardSelectionContext", "suggestRoleAssignments", "computeAllEntityMetrics", "computeAllEventMetrics", "computeTemporalContext", "computeFocalEra", "suggestEventSelection", "getRelevantRelationships", "getRelevantEvents", "buildKindToCategoryMap", "EntitySelectionMetrics", "EventSelectionMetrics"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx::useWizard", "name": "useWizard", "kind": "hook", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/WizardContext.tsx", "sourceCode": "// =============================================================================\n// Hook\n// =============================================================================\n\nexport function useWizard(): WizardContextValue {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error(\"useWizard must be used within a WizardProvider\");\n  }\n  return context;\n}", "parameters": [], "returnType": "WizardContextValue", "jsxLeafElements": [], "hookCalls": [{"name": "useContext", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "createContext", "useContext", "useReducer", "ReactNode", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "EntityKindDefinition", "EntityCategory", "RoleDefinition"], "category": "external"}, {"source": "../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment", "NarrativeLens", "EntityContext", "RelationshipContext", "NarrativeEventContext", "EraTemporalInfo", "ChronicleTemporalContext"], "category": "internal"}, {"source": "../../lib/chronicle/selectionWizard", "specifiers": ["buildWizardSelectionContext", "suggestRoleAssignments", "computeAllEntityMetrics", "computeAllEventMetrics", "computeTemporalContext", "computeFocalEra", "suggestEventSelection", "getRelevantRelationships", "getRelevantEvents", "buildKindToCategoryMap", "EntitySelectionMetrics", "EventSelectionMetrics"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useChronicleNavItems", "name": "useChronicleNavItems", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "// ============================================================================\n// Nav item type \u2014 lightweight projection for the chronicle list sidebar\n// ============================================================================\n\n// ============================================================================\n// Selectors\n// ============================================================================\n\n/**\n * Sorted nav items for the chronicle list sidebar.\n * Subscribes to the chronicles record (reference-stable per chronicle),\n * derives lightweight nav items in a useMemo.\n */\nexport function useChronicleNavItems(\n  getEffectiveStatus?: (chronicleId: string, baseStatus: string) => string\n): ChronicleNavItem[] {\n  const navItems = useChronicleStore((state) => state.navItems);\n  const navOrder = useChronicleStore((state) => state.navOrder);\n\n  return useMemo(() => {\n    const items = navOrder.map((id) => navItems[id]).filter(Boolean);\n    if (!getEffectiveStatus) return items;\n    return items.map((item) => ({\n      ...item,\n      status: getEffectiveStatus(item.chronicleId, item.status),\n    }));\n  }, [navItems, navOrder, getEffectiveStatus]);\n}", "parameters": [{"name": "getEffectiveStatus", "type": "(chronicleId: string, baseStatus: string) => string", "optional": true}], "returnType": "ChronicleNavItem[]", "jsxLeafElements": [], "hookCalls": [{"name": "useChronicleStore", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": ["useChronicleStore"], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useSelectedChronicle", "name": "useSelectedChronicle", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Single chronicle record for the review panel.\n * Only re-renders when this specific chronicle's record reference changes.\n */\nexport function useSelectedChronicle(chronicleId: string | null): ChronicleRecord | undefined {\n  const record = useChronicleStore((state) =>\n    chronicleId ? state.cache.get(chronicleId) : undefined\n  );\n  const loadChronicle = useChronicleStore((state) => state.loadChronicle);\n\n  useEffect(() => {\n    if (chronicleId) {\n      void loadChronicle(chronicleId);\n    }\n  }, [chronicleId, loadChronicle]);\n\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string | null", "optional": false}], "returnType": "ChronicleRecord | undefined", "jsxLeafElements": [], "hookCalls": [{"name": "useChronicleStore", "count": 2}, {"name": "useEffect", "count": 1}], "customHookCalls": ["useChronicleStore"], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::useChronicleCount", "name": "useChronicleCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Chronicle count for stats display.\n */\nexport function useChronicleCount(): number {\n  return useChronicleStore((state) => state.navOrder.length);\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [{"name": "useChronicleStore", "count": 1}], "customHookCalls": ["useChronicleStore"], "imports": [{"source": "react", "specifiers": ["useMemo", "useEffect"], "category": "framework"}, {"source": "./chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "./chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavItems", "name": "useEntityNavItems", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Full nav item map for O(1) lookups \u2014 re-renders when any nav item changes */\nexport function useEntityNavItems(): Map<string, EntityNavItem> {\n  return useEntityStore((state) => state.navItems);\n}", "parameters": [], "returnType": "Map<string, EntityNavItem>", "jsxLeafElements": [], "hookCalls": [{"name": "useEntityStore", "count": 1}], "customHookCalls": ["useEntityStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavList", "name": "useEntityNavList", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Nav item array for list rendering \u2014 derived from map via useMemo */\nexport function useEntityNavList(): EntityNavItem[] {\n  const navItems = useEntityStore((state) => state.navItems);\n  return useMemo(() => (navItems.size ? Array.from(navItems.values()) : EMPTY_ARRAY), [navItems]);\n}", "parameters": [], "returnType": "EntityNavItem[]", "jsxLeafElements": [], "hookCalls": [{"name": "useEntityStore", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": ["useEntityStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityNavItem", "name": "useEntityNavItem", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Single nav item by ID \u2014 only re-renders when this specific nav item changes */\nexport function useEntityNavItem(id: string | undefined): EntityNavItem | undefined {\n  return useEntityStore((state) => (id ? state.navItems.get(id) : undefined));\n}", "parameters": [{"name": "id", "type": "string | undefined", "optional": false}], "returnType": "EntityNavItem | undefined", "jsxLeafElements": [], "hookCalls": [{"name": "useEntityStore", "count": 1}], "customHookCalls": ["useEntityStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntity", "name": "useEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/**\n * Single full entity from the bounded cache.\n * Returns undefined if the entity hasn't been loaded yet.\n * Pair with store.loadEntity(id) in a useEffect to trigger the load.\n */\nexport function useEntity(id: string | undefined): PersistedEntity | undefined {\n  return useEntityStore((state) => (id ? state.cache.get(id) : undefined));\n}", "parameters": [{"name": "id", "type": "string | undefined", "optional": false}], "returnType": "PersistedEntity | undefined", "jsxLeafElements": [], "hookCalls": [{"name": "useEntityStore", "count": 1}], "customHookCalls": ["useEntityStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/entitySelectors.ts::useEntityCount", "name": "useEntityCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/entitySelectors.ts", "sourceCode": "/** Entity count \u2014 only re-renders when count changes */\nexport function useEntityCount(): number {\n  return useEntityStore((state) => state.navItems.size);\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [{"name": "useEntityStore", "count": 1}], "customHookCalls": ["useEntityStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "./entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useProminenceScale", "name": "useProminenceScale", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useProminenceScale(): ProminenceScale {\n  return useIndexStore((state) => state.indexes?.prominenceScale ?? FALLBACK_SCALE);\n}", "parameters": [], "returnType": "ProminenceScale", "jsxLeafElements": [], "hookCalls": [{"name": "useIndexStore", "count": 1}], "customHookCalls": ["useIndexStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useRenownedThreshold", "name": "useRenownedThreshold", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useRenownedThreshold(): number {\n  return useIndexStore((state) => state.indexes?.renownedThreshold ?? 0);\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [{"name": "useIndexStore", "count": 1}], "customHookCalls": ["useIndexStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useEraTemporalInfo", "name": "useEraTemporalInfo", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useEraTemporalInfo(): EraTemporalEntry[] {\n  return useIndexStore((state) => state.indexes?.eraTemporalInfo ?? EMPTY_ERA_TEMPORAL);\n}", "parameters": [], "returnType": "EraTemporalEntry[]", "jsxLeafElements": [], "hookCalls": [{"name": "useIndexStore", "count": 1}], "customHookCalls": ["useIndexStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useEraTemporalInfoByKey", "name": "useEraTemporalInfoByKey", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useEraTemporalInfoByKey(): Map<string, EraTemporalEntry> {\n  const eraTemporalInfo = useIndexStore((state) => state.indexes?.eraTemporalInfo);\n  const eraIdAliases = useIndexStore((state) => state.indexes?.eraIdAliases);\n\n  return useMemo(() => {\n    if (!eraTemporalInfo?.length) return EMPTY_MAP;\n\n    const byId = new Map<string, EraTemporalEntry>(eraTemporalInfo.map((era) => [era.id, era]));\n    const map = new Map(byId);\n\n    if (eraIdAliases) {\n      for (const [entityId, eraId] of Object.entries(eraIdAliases)) {\n        const eraInfo = byId.get(entityId) || byId.get(eraId);\n        if (eraInfo) {\n          map.set(eraId, eraInfo);\n          map.set(entityId, eraInfo);\n        }\n      }\n    }\n\n    return map;\n  }, [eraTemporalInfo, eraIdAliases]);\n}", "parameters": [], "returnType": "Map<string, EraTemporalEntry>", "jsxLeafElements": [], "hookCalls": [{"name": "useIndexStore", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": ["useIndexStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/indexSelectors.ts::useProminentByCulture", "name": "useProminentByCulture", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/indexSelectors.ts", "sourceCode": "export function useProminentByCulture(): Record<string, Array<{ id: string; name: string }>> {\n  return useIndexStore((state) => state.indexes?.prominentByCulture ?? EMPTY_PROMINENT);\n}", "parameters": [], "returnType": "Record<string, Array<{ id: string; name: string }>>", "jsxLeafElements": [], "hookCalls": [{"name": "useIndexStore", "count": 1}], "customHookCalls": ["useIndexStore"], "imports": [{"source": "react", "specifiers": ["useMemo"], "category": "framework"}, {"source": "./indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION"], "category": "external"}, {"source": "./indexTypes", "specifiers": ["EraTemporalEntry"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts::useNarrativeEvents", "name": "useNarrativeEvents", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts", "sourceCode": "/** Full narrative events array \u2014 re-renders when events change */\nexport function useNarrativeEvents() {\n  return useNarrativeEventStore((state) => state.events);\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/illuminatorDb\").PersistedNarrativeEvent[]", "jsxLeafElements": [], "hookCalls": [{"name": "useNarrativeEventStore", "count": 1}], "customHookCalls": ["useNarrativeEventStore"], "imports": [{"source": "./narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts::useNarrativeEventCount", "name": "useNarrativeEventCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/narrativeEventSelectors.ts", "sourceCode": "/** Event count \u2014 re-renders when count changes */\nexport function useNarrativeEventCount(): number {\n  return useNarrativeEventStore((state) => state.events.length);\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [{"name": "useNarrativeEventStore", "count": 1}], "customHookCalls": ["useNarrativeEventStore"], "imports": [{"source": "./narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationships", "name": "useRelationships", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Full flat relationship array \u2014 re-renders when relationships change */\nexport function useRelationships(): PersistedRelationship[] {\n  return useRelationshipStore((state) => state.relationships);\n}", "parameters": [], "returnType": "PersistedRelationship[]", "jsxLeafElements": [], "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "customHookCalls": ["useRelationshipStore"], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipsByEntity", "name": "useRelationshipsByEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Precomputed byEntity index \u2014 re-renders when relationships change */\nexport function useRelationshipsByEntity(): RelationshipIndex {\n  return useRelationshipStore((state) => state.byEntity);\n}", "parameters": [], "returnType": "RelationshipIndex", "jsxLeafElements": [], "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "customHookCalls": ["useRelationshipStore"], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipsForEntity", "name": "useRelationshipsForEntity", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Relationships for a specific entity \u2014 re-renders when index changes */\nexport function useRelationshipsForEntity(entityId: string | undefined): PersistedRelationship[] {\n  return useRelationshipStore((state) =>\n    entityId\n      ? ((state.byEntity.get(entityId) as PersistedRelationship[] | undefined) ?? EMPTY_ARRAY)\n      : EMPTY_ARRAY\n  );\n}", "parameters": [{"name": "entityId", "type": "string | undefined", "optional": false}], "returnType": "PersistedRelationship[]", "jsxLeafElements": [], "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "customHookCalls": ["useRelationshipStore"], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts::useRelationshipCount", "name": "useRelationshipCount", "kind": "hook", "filePath": "apps/illuminator/webui/src/lib/db/relationshipSelectors.ts", "sourceCode": "/** Relationship count */\nexport function useRelationshipCount(): number {\n  return useRelationshipStore((state) => state.relationships.length);\n}", "parameters": [], "returnType": "number", "jsxLeafElements": [], "hookCalls": [{"name": "useRelationshipStore", "count": 1}], "customHookCalls": ["useRelationshipStore"], "imports": [{"source": "./relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "./illuminatorDb", "specifiers": ["PersistedRelationship"], "category": "internal"}, {"source": "./relationshipStore", "specifiers": ["RelationshipIndex"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::IntensitySparkline", "name": "IntensitySparkline", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function IntensitySparkline({\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}: Readonly<IntensitySparklineProps>) {\n  // Match padding with NarrativeTimeline for visual alignment\n  const padding = { left: 40, right: 40, top: 4, bottom: 4 };\n  const innerWidth = width - padding.left - padding.right;\n  const innerHeight = height - padding.top - padding.bottom;\n\n  // Build the SVG path\n  const { areaPath, linePath } = useMemo(() => {\n    if (points.length < 2) {\n      return { areaPath: \"\", linePath: \"\" };\n    }\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const scaleY = (intensity: number) => padding.top + (1 - intensity) * innerHeight;\n\n    // Build line path\n    const lineParts: string[] = [];\n    const areaParts: string[] = [];\n\n    points.forEach((point, i) => {\n      const x = scaleX(point.tick);\n      const y = scaleY(point.intensity);\n\n      if (i === 0) {\n        lineParts.push(`M ${x} ${y}`);\n        areaParts.push(`M ${x} ${height - padding.bottom}`);\n        areaParts.push(`L ${x} ${y}`);\n      } else {\n        lineParts.push(`L ${x} ${y}`);\n        areaParts.push(`L ${x} ${y}`);\n      }\n    });\n\n    // Close the area path\n    const lastX = scaleX(points[points.length - 1].tick);\n    areaParts.push(`L ${lastX} ${height - padding.bottom}`);\n    areaParts.push(\"Z\");\n\n    return {\n      areaPath: areaParts.join(\" \"),\n      linePath: lineParts.join(\" \"),\n    };\n  }, [points, extent, innerWidth, innerHeight, height, padding]);\n\n  // Build highlight rect for selected range\n  const highlightRect = useMemo(() => {\n    if (!selectedRange) return null;\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const x1 = scaleX(selectedRange[0]);\n    const x2 = scaleX(selectedRange[1]);\n\n    return {\n      x: Math.min(x1, x2),\n      width: Math.abs(x2 - x1),\n    };\n  }, [selectedRange, extent, innerWidth, padding]);\n\n  if (points.length < 2) {\n    return (\n      <svg width={width} height={height}>\n        <text\n          x={width / 2}\n          y={height / 2}\n          textAnchor=\"middle\"\n          fontSize=\"10\"\n          fill=\"var(--text-muted)\"\n        >\n          Not enough data\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={width} height={height} className=\"is-svg\">\n      {/* Selected range highlight */}\n      {highlightRect && (\n        <rect\n          x={highlightRect.x}\n          y={0}\n          width={highlightRect.width}\n          height={height}\n          fill=\"rgba(99, 102, 241, 0.15)\"\n        />\n      )}\n\n      {/* Area fill */}\n      <path d={areaPath} fill={fillColor} />\n\n      {/* Line stroke */}\n      <path d={linePath} fill=\"none\" stroke={strokeColor} strokeWidth={1.5} />\n\n      {/* Label */}\n      <text x={4} y={12} fontSize=\"9\" fill=\"var(--text-muted)\" fontFamily=\"inherit\">\n        Narrative Intensity\n      </text>\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}", "type": "Readonly<IntensitySparklineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["text"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::TimelineBrush", "name": "TimelineBrush", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function TimelineBrush({\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}: Readonly<TimelineBrushProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [dragMode, setDragMode] = useState<DragMode>(\"none\");\n  const [dragStart, setDragStart] = useState<{ x: number; selection: [number, number] | null }>({\n    x: 0,\n    selection: null,\n  });\n\n  const handleSize = 8;\n\n  // Convert selection to pixel positions\n  const selectionPx = selection\n    ? {\n        left: tickToX(selection[0], extent, width, padding),\n        right: tickToX(selection[1], extent, width, padding),\n      }\n    : null;\n\n  const getMouseX = useCallback((e: React.MouseEvent | MouseEvent) => {\n    if (!svgRef.current) return 0;\n    const rect = svgRef.current.getBoundingClientRect();\n    return e.clientX - rect.left;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, mode: DragMode) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragMode(mode);\n      setDragStart({ x: getMouseX(e), selection });\n    },\n    [selection, getMouseX]\n  );\n\n  const handleBackgroundMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      const x = getMouseX(e);\n      // If clicking outside selection, start creating new selection\n      if (!selectionPx || x < selectionPx.left - handleSize || x > selectionPx.right + handleSize) {\n        setDragMode(\"create\");\n        const tick = xToTick(x, extent, width, padding);\n        setDragStart({ x, selection: [tick, tick] });\n        onSelectionChange([tick, tick]);\n      }\n    },\n    [selectionPx, extent, width, padding, getMouseX, onSelectionChange, handleSize]\n  );\n\n  useEffect(() => {\n    if (dragMode === \"none\") return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const x = getMouseX(e);\n      const dx = x - dragStart.x;\n\n      if (dragMode === \"create\") {\n        const startTick = dragStart.selection[0];\n        const currentTick = xToTick(x, extent, width, padding);\n        const newSelection: [number, number] =\n          currentTick >= startTick ? [startTick, currentTick] : [currentTick, startTick];\n        onSelectionChange(newSelection);\n        return;\n      }\n\n      if (!dragStart.selection) return;\n\n      const [startTick, endTick] = dragStart.selection;\n\n      if (dragMode === \"left\") {\n        const newLeft = xToTick(\n          tickToX(startTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.min(newLeft, endTick - 1);\n        onSelectionChange([Math.max(extent[0], clamped), endTick]);\n      } else if (dragMode === \"right\") {\n        const newRight = xToTick(\n          tickToX(endTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.max(newRight, startTick + 1);\n        onSelectionChange([startTick, Math.min(extent[1], clamped)]);\n      } else if (dragMode === \"move\") {\n        const tickDelta =\n          xToTick(dragStart.x + dx, extent, width, padding) -\n          xToTick(dragStart.x, extent, width, padding);\n        let newStart = startTick + tickDelta;\n        let newEnd = endTick + tickDelta;\n\n        // Clamp to extent\n        if (newStart < extent[0]) {\n          const shift = extent[0] - newStart;\n          newStart = extent[0];\n          newEnd += shift;\n        }\n        if (newEnd > extent[1]) {\n          const shift = newEnd - extent[1];\n          newEnd = extent[1];\n          newStart -= shift;\n        }\n\n        onSelectionChange([Math.max(extent[0], newStart), Math.min(extent[1], newEnd)]);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setDragMode(\"none\");\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [dragMode, dragStart, extent, width, padding, getMouseX, onSelectionChange]);\n\n  const getCursor = (mode: DragMode) => {\n    switch (mode) {\n      case \"left\":\n      case \"right\":\n        return \"ew-resize\";\n      case \"move\":\n        return \"grab\";\n      case \"create\":\n        return \"crosshair\";\n      default:\n        return \"crosshair\";\n    }\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"tb-svg\"\n      style={{\n        '--tb-cursor': getCursor(dragMode === \"none\" ? \"create\" : dragMode),\n      } as React.CSSProperties}\n      onMouseDown={handleBackgroundMouseDown}\n    >\n      {/* Background track */}\n      <rect\n        x={padding}\n        y={4}\n        width={width - 2 * padding}\n        height={height - 8}\n        rx={4}\n        fill=\"var(--bg-tertiary)\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n      />\n\n      {/* Selection */}\n      {selectionPx && selectionPx.right - selectionPx.left >= minSelectionWidth && (\n        <g>\n          {/* Selection rect */}\n          <rect\n            x={selectionPx.left}\n            y={4}\n            width={selectionPx.right - selectionPx.left}\n            height={height - 8}\n            rx={4}\n            fill=\"rgba(99, 102, 241, 0.3)\"\n            stroke=\"var(--accent-color)\"\n            strokeWidth={1}\n            className=\"tb-grab\"\n            onMouseDown={(e) => handleMouseDown(e, \"move\")}\n          />\n\n          {/* Left handle */}\n          <rect\n            x={selectionPx.left - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"left\")}\n          />\n\n          {/* Right handle */}\n          <rect\n            x={selectionPx.right - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"right\")}\n          />\n\n          {/* Selection label */}\n          {selection && (\n            <text\n              x={(selectionPx.left + selectionPx.right) / 2}\n              y={height / 2 + 4}\n              textAnchor=\"middle\"\n              fontSize=\"10\"\n              fontWeight=\"500\"\n              fill=\"var(--accent-color)\"\n              className=\"tb-no-pointer\"\n            >\n              {selection[0]} \u2013 {selection[1]}\n            </text>\n          )}\n        </g>\n      )}\n\n      {/* Instructions when no selection */}\n      {!selectionPx && (\n        <text\n          x={width / 2}\n          y={height / 2 + 4}\n          textAnchor=\"middle\"\n          fontSize=\"11\"\n          fill=\"var(--text-muted)\"\n          className=\"tb-no-pointer\"\n        >\n          Drag to select time range\n        </text>\n      )}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}", "type": "Readonly<TimelineBrushProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["rect", "text"], "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 2}, {"name": "useCallback", "count": 3}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::NarrativeTimeline", "name": "NarrativeTimeline", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function NarrativeTimeline({\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}: Readonly<NarrativeTimelineProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredEvent, setHoveredEvent] = useState<TooltipData | null>(null);\n  const [hoveredCastMarker, setHoveredCastMarker] = useState<CastTooltipData | null>(null);\n\n  const padding = { left: 40, right: 40, top: 24, bottom: 32 };\n  const hasCastMarkers = castMarkers && castMarkers.length > 0;\n  const castTrackHeight = hasCastMarkers ? 28 : 0;\n  const laneHeight = height - padding.top - padding.bottom;\n  const eventAreaTop = padding.top + 20; // Leave room for era labels\n  const eventAreaHeight = laneHeight - 20 - castTrackHeight;\n  const castBaselineY = eventAreaTop + eventAreaHeight + 4;\n  const castMarkerCenterY = castBaselineY + 12;\n\n  // Use provided extent or compute from events as fallback\n  const extent = useMemo(() => {\n    if (extentProp) return extentProp;\n    return computeTimelineExtent(events.map((e) => ({ tick: e.tick }) as any));\n  }, [extentProp, events]);\n\n  // Scale functions\n  const scaleX = useCallback(\n    (tick: number) => tickToX(tick, extent, width, padding.left),\n    [extent, width, padding.left]\n  );\n\n  // Position events to avoid overlap using simple row allocation\n  const eventPositions = useMemo(() => {\n    const positions = new Map<string, { x: number; y: number; height: number; row: number }>();\n    const rows: Array<{ endX: number }> = [];\n    const eventWidth = 24;\n    const eventGap = 4;\n\n    // Sort by tick\n    const sorted = [...events].sort((a, b) => a.tick - b.tick);\n\n    for (const event of sorted) {\n      const x = scaleX(event.tick);\n      const eventHeight = getEventHeight(event.significance, 50, 20);\n\n      // Find first available row\n      let row = 0;\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].endX + eventGap < x) {\n          row = i;\n          break;\n        }\n        row = i + 1;\n      }\n\n      // Ensure row exists\n      while (rows.length <= row) {\n        rows.push({ endX: 0 });\n      }\n      rows[row].endX = x + eventWidth;\n\n      // Calculate y position (stack from bottom)\n      const y = eventAreaTop + eventAreaHeight - eventHeight - row * 12;\n\n      positions.set(event.id, { x, y, height: eventHeight, row });\n    }\n\n    return positions;\n  }, [events, scaleX, eventAreaTop, eventAreaHeight]);\n\n  // Generate tick marks\n  const tickMarks = useMemo(() => {\n    const [minTick, maxTick] = extent;\n    const range = maxTick - minTick;\n    const step = Math.ceil(range / 8);\n    const marks: number[] = [];\n\n    for (let tick = Math.ceil(minTick / step) * step; tick <= maxTick; tick += step) {\n      marks.push(tick);\n    }\n\n    return marks;\n  }, [extent]);\n\n  const handleEventClick = useCallback(\n    (e: React.MouseEvent, eventId: string) => {\n      e.stopPropagation();\n      onToggleEvent(eventId);\n    },\n    [onToggleEvent]\n  );\n\n  const handleEventHover = useCallback((event: TimelineEvent | null, e?: React.MouseEvent) => {\n    if (event && e && svgRef.current) {\n      const rect = svgRef.current.getBoundingClientRect();\n      setHoveredEvent({\n        event,\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    } else {\n      setHoveredEvent(null);\n    }\n  }, []);\n\n  return (\n    <div className=\"nt-wrap\">\n      <svg\n        ref={svgRef}\n        width={width}\n        height={height}\n        className=\"nt-svg\"\n      >\n        {/* Era bands */}\n        {eraRanges.map((era) => {\n          // Clamp era boundaries to the usable timeline area\n          const x1 = Math.max(scaleX(era.startTick), padding.left);\n          const x2 = Math.min(scaleX(era.endTick), width - padding.right);\n          const isFocal = focalEraId === era.id;\n          const bandWidth = x2 - x1;\n\n          // Skip eras that fall entirely outside the visible range\n          if (bandWidth <= 0) return null;\n\n          return (\n            <g key={era.id}>\n              {/* Era background band */}\n              <rect\n                x={x1}\n                y={padding.top}\n                width={bandWidth}\n                height={laneHeight}\n                fill={era.color}\n                opacity={isFocal ? 0.15 : 0.08}\n              />\n              {/* Era divider line */}\n              <line\n                x1={x1}\n                y1={padding.top}\n                x2={x1}\n                y2={height - padding.bottom}\n                stroke={era.color}\n                strokeWidth={isFocal ? 2 : 1}\n                strokeDasharray={isFocal ? \"none\" : \"4,4\"}\n              />\n              {/* Era label */}\n              <text\n                x={x1 + 6}\n                y={padding.top + 14}\n                fontSize=\"10\"\n                fontWeight={isFocal ? 600 : 400}\n                fill={era.color}\n              >\n                {era.name}\n                {isFocal && \" \u2605\"}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Timeline axis */}\n        <line\n          x1={padding.left}\n          y1={height - padding.bottom}\n          x2={width - padding.right}\n          y2={height - padding.bottom}\n          stroke=\"var(--border-color)\"\n          strokeWidth={1}\n        />\n\n        {/* Tick marks */}\n        {tickMarks.map((tick) => {\n          const x = scaleX(tick);\n          return (\n            <g key={tick}>\n              <line\n                x1={x}\n                y1={height - padding.bottom}\n                x2={x}\n                y2={height - padding.bottom + 4}\n                stroke=\"var(--text-muted)\"\n                strokeWidth={1}\n              />\n              <text\n                x={x}\n                y={height - padding.bottom + 16}\n                textAnchor=\"middle\"\n                fontSize=\"9\"\n                fill=\"var(--text-muted)\"\n              >\n                {tick}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Event cards */}\n        {events.map((event) => {\n          const pos = eventPositions.get(event.id);\n          if (!pos) return null;\n\n          const fill = getEventFill(event);\n          const cardWidth = 20;\n\n          return (\n            <g\n              key={event.id}\n              className=\"nt-cursor-pointer\"\n              onClick={(e) => handleEventClick(e, event.id)}\n              onMouseEnter={(e) => handleEventHover(event, e)}\n              onMouseLeave={() => handleEventHover(null)}\n            >\n              {/* Event card */}\n              <rect\n                x={pos.x - cardWidth / 2}\n                y={pos.y}\n                width={cardWidth}\n                height={pos.height}\n                rx={3}\n                fill={fill}\n                opacity={event.selected ? 1 : 0.4}\n                stroke={event.selected ? \"white\" : \"transparent\"}\n                strokeWidth={event.selected ? 2 : 0}\n              />\n              {/* Selection checkmark */}\n              {event.selected && (\n                <text\n                  x={pos.x}\n                  y={pos.y + pos.height / 2 + 4}\n                  textAnchor=\"middle\"\n                  fontSize=\"12\"\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  className=\"nt-no-pointer\"\n                >\n                  \u2713\n                </text>\n              )}\n            </g>\n          );\n        })}\n\n        {/* Cast creation markers */}\n        {hasCastMarkers && (\n          <g>\n            {/* Dashed baseline */}\n            <line\n              x1={padding.left}\n              y1={castBaselineY}\n              x2={width - padding.right}\n              y2={castBaselineY}\n              stroke=\"var(--border-color)\"\n              strokeWidth={1}\n              strokeDasharray=\"4,3\"\n            />\n            {/* \"Cast\" label */}\n            <text\n              x={padding.left - 4}\n              y={castMarkerCenterY + 3}\n              textAnchor=\"end\"\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n            >\n              Cast\n            </text>\n            {/* Markers */}\n            {castMarkers.map((marker) => {\n              if (typeof marker.createdAt !== \"number\" || Number.isNaN(marker.createdAt))\n                return null;\n              const x = scaleX(marker.createdAt);\n              const shape = getCastMarkerShape(marker.entityKind);\n              const color = getCastMarkerColor(marker.entityKind);\n              const isHovered = hoveredCastMarker?.marker.entityId === marker.entityId;\n\n              return (\n                <g\n                  key={marker.entityId}\n                  className=\"nt-cursor-pointer\"\n                  onMouseEnter={(e) => {\n                    if (svgRef.current) {\n                      const rect = svgRef.current.getBoundingClientRect();\n                      setHoveredCastMarker({\n                        marker,\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                      });\n                    }\n                  }}\n                  onMouseLeave={() => setHoveredCastMarker(null)}\n                >\n                  {/* Vertical tick from baseline to marker */}\n                  <line\n                    x1={x}\n                    y1={castBaselineY}\n                    x2={x}\n                    y2={castMarkerCenterY - shape.size / 2}\n// ... (truncated)", "parameters": [{"name": "{\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}", "type": "Readonly<NarrativeTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["rect", "line", "text", "path", "circle", "div", "span"], "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 2}, {"name": "useMemo", "count": 3}, {"name": "useCallback", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::FilterChips", "name": "FilterChips", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function FilterChips<T extends string>({\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}: Readonly<FilterChipsProps<T>>) {\n  const handleChipClick = (option: T) => {\n    const newSelected = new Set(selected);\n\n    if (newSelected.has(option)) {\n      newSelected.delete(option);\n    } else {\n      if (!multiSelect) {\n        newSelected.clear();\n      }\n      newSelected.add(option);\n    }\n\n    onSelectionChange(newSelected);\n  };\n\n  const handleClearAll = () => {\n    onSelectionChange(new Set());\n  };\n\n  const getChipColor = (option: T): string => {\n    if (getColor) return getColor(option);\n    return KIND_COLORS[option.toLowerCase()] || \"var(--accent-color)\";\n  };\n\n  const getDisplayLabel = (option: T): string => {\n    if (formatLabel) return formatLabel(option);\n    // Capitalize first letter\n    return option.charAt(0).toUpperCase() + option.slice(1);\n  };\n\n  return (\n    <div className=\"fc-wrap\">\n      {label && (\n        <div className=\"fc-header\">\n          <span className=\"fc-label\">\n            {label}\n          </span>\n          {selected.size > 0 && (\n            <button\n              onClick={handleClearAll}\n              className=\"fc-clear-btn\"\n            >\n              Clear\n            </button>\n          )}\n        </div>\n      )}\n\n      <div className=\"fc-chips\">\n        {options.map((option) => {\n          const isSelected = selected.has(option);\n          const color = getChipColor(option);\n\n          return (\n            <button\n              key={option}\n              onClick={() => handleChipClick(option)}\n              className=\"fc-chip\"\n              style={{\n                '--fc-chip-border': isSelected ? `1px solid ${color}` : \"1px solid var(--border-color)\",\n                '--fc-chip-bg': isSelected ? color : \"transparent\",\n                '--fc-chip-color': isSelected ? \"white\" : \"var(--text-secondary)\",\n                '--fc-chip-weight': isSelected ? 500 : 400,\n              } as React.CSSProperties}\n            >\n              {/* Color dot when not selected */}\n              {!isSelected && (\n                <span\n                  className=\"fc-chip-dot\"\n                  style={{\n                    '--fc-dot-bg': color,\n                  } as React.CSSProperties}\n                />\n              )}\n              {getDisplayLabel(option)}\n            </button>\n          );\n        })}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}", "type": "Readonly<FilterChipsProps<T>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryPotentialRadar", "name": "StoryPotentialRadar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function StoryPotentialRadar({\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}: Readonly<StoryPotentialRadarProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const maxRadius = size / 2 - (showLabels ? 28 : 8);\n  const numAxes = AXES.length;\n  const angleStep = (2 * Math.PI) / numAxes;\n  // Start from top (-90 degrees)\n  const startAngle = -Math.PI / 2;\n\n  // Compute axis endpoints\n  const axisPoints = useMemo(() => {\n    return AXES.map((_, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + maxRadius * Math.cos(angle),\n        y: cy + maxRadius * Math.sin(angle),\n        labelX: cx + (maxRadius + 14) * Math.cos(angle),\n        labelY: cy + (maxRadius + 14) * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Compute polygon points for the data\n  const dataPoints = useMemo(() => {\n    return AXES.map((axis, i) => {\n      const value = potential[axis.key as keyof StoryPotential];\n      const radius = value * maxRadius;\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n        value,\n        label: axis.label,\n      };\n    });\n  }, [potential, cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Build polygon path\n  const polygonPath =\n    dataPoints.map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x} ${p.y}`).join(\" \") + \" Z\";\n\n  // Grid rings (25%, 50%, 75%, 100%)\n  const gridRings = [0.25, 0.5, 0.75, 1];\n\n  return (\n    <svg width={size} height={size} className=\"spr-svg\">\n      {/* Background */}\n      <circle cx={cx} cy={cy} r={maxRadius} fill=\"var(--bg-tertiary)\" />\n\n      {/* Grid rings */}\n      {gridRings.map((ring) => (\n        <circle\n          key={ring}\n          cx={cx}\n          cy={cy}\n          r={maxRadius * ring}\n          fill=\"none\"\n          stroke=\"var(--border-color)\"\n          strokeWidth={ring === 1 ? 1 : 0.5}\n          strokeDasharray={ring === 1 ? \"none\" : \"2,2\"}\n        />\n      ))}\n\n      {/* Axis lines */}\n      {axisPoints.map((point, i) => (\n        <line\n          key={i}\n          x1={cx}\n          y1={cy}\n          x2={point.x}\n          y2={point.y}\n          stroke=\"var(--border-color)\"\n          strokeWidth={0.5}\n        />\n      ))}\n\n      {/* Data polygon */}\n      <path\n        d={polygonPath}\n        fill=\"rgba(99, 102, 241, 0.3)\"\n        stroke=\"var(--accent-color)\"\n        strokeWidth={2}\n      />\n\n      {/* Data points */}\n      {dataPoints.map((point, i) => (\n        <g key={i}>\n          <circle\n            cx={point.x}\n            cy={point.y}\n            r={4}\n            fill=\"var(--accent-color)\"\n            stroke=\"white\"\n            strokeWidth={1.5}\n          />\n          {interactive && <title>{`${point.label}: ${(point.value * 100).toFixed(0)}%`}</title>}\n        </g>\n      ))}\n\n      {/* Axis labels */}\n      {showLabels &&\n        axisPoints.map((point, i) => {\n          const axis = AXES[i];\n\n          // Adjust text anchor based on position\n          let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n          if (point.labelX < cx - 10) textAnchor = \"end\";\n          else if (point.labelX > cx + 10) textAnchor = \"start\";\n\n          // Adjust vertical position\n          let dy = 4;\n          if (point.labelY < cy - maxRadius * 0.5) dy = 12;\n          else if (point.labelY > cy + maxRadius * 0.5) dy = -2;\n\n          return (\n            <text\n              key={i}\n              x={point.labelX}\n              y={point.labelY}\n              dy={dy}\n              textAnchor={textAnchor}\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n              fontFamily=\"inherit\"\n            >\n              {axis.shortLabel}\n            </text>\n          );\n        })}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}", "type": "Readonly<StoryPotentialRadarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["circle", "line", "path", "title"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryPotentialRadarWithScore", "name": "StoryPotentialRadarWithScore", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Radar chart with score displayed below\n */\nexport function StoryPotentialRadarWithScore({\n  potential,\n  size = 160,\n}: Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>) {\n  return (\n    <div className=\"spr-with-score\">\n      <StoryPotentialRadar potential={potential} size={size} />\n      <div className=\"spr-score-wrap\">\n        <div className=\"spr-score-number\">\n          {(potential.overallScore * 100).toFixed(0)}\n        </div>\n        <div className=\"spr-score-label\">\n          Story Score\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n}", "type": "Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["StoryPotentialRadar", "div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryScoreBar", "name": "StoryScoreBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Compact score bar for list items\n */\nexport function StoryScoreBar({\n  score,\n  width = 60,\n  height = 8,\n}: Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>) {\n  const fillWidth = score * width;\n\n  return (\n    <svg width={width} height={height} className=\"spr-svg\">\n      {/* Background */}\n      <rect x={0} y={0} width={width} height={height} rx={height / 2} fill=\"var(--bg-tertiary)\" />\n      {/* Fill */}\n      <rect\n        x={0}\n        y={0}\n        width={fillWidth}\n        height={height}\n        rx={height / 2}\n        fill=\"var(--accent-color)\"\n      />\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  score,\n  width = 60,\n  height = 8,\n}", "type": "Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["rect"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::StoryScoreDots", "name": "StoryScoreDots", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "/**\n * Dot rating display (1-5 filled dots)\n */\nexport function StoryScoreDots({ score, maxDots = 5 }: Readonly<{ score: number; maxDots?: number }>) {\n  const filledDots = Math.max(1, Math.min(maxDots, Math.round(score * maxDots)));\n\n  return (\n    <div className=\"spr-dots\">\n      {Array.from({ length: maxDots }).map((_, i) => (\n        <span\n          key={i}\n          className={`spr-dot ${i < filledDots ? \"spr-dot-filled\" : \"spr-dot-empty\"}`}\n        />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ score, maxDots = 5 }", "type": "Readonly<{ score: number; maxDots?: number }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::MiniConstellation", "name": "MiniConstellation", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function MiniConstellation({\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}: Readonly<MiniConstellationProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const centerRadius = 16;\n  const nodeRadius = 10;\n  const orbitRadius = size / 2 - nodeRadius - 12;\n\n  // Limit and arrange connections\n  const visibleConnections = useMemo(() => {\n    // Group by kind and take most diverse sample\n    const byKind = new Map<string, ConnectedEntity[]>();\n    for (const conn of connections) {\n      const list = byKind.get(conn.kind) || [];\n      list.push(conn);\n      byKind.set(conn.kind, list);\n    }\n\n    // Take one from each kind first, then fill remaining\n    const result: ConnectedEntity[] = [];\n    const kindIterators = [...byKind.values()].map((list) => list[Symbol.iterator]());\n\n    while (result.length < maxConnections && kindIterators.length > 0) {\n      for (let i = kindIterators.length - 1; i >= 0; i--) {\n        if (result.length >= maxConnections) break;\n        const next = kindIterators[i].next();\n        if (next.done) {\n          kindIterators.splice(i, 1);\n        } else {\n          result.push(next.value);\n        }\n      }\n    }\n\n    return result;\n  }, [connections, maxConnections]);\n\n  const hiddenCount = connections.length - visibleConnections.length;\n\n  // Position nodes in a circle\n  const nodePositions = useMemo(() => {\n    const count = visibleConnections.length;\n    if (count === 0) return [];\n\n    const angleStep = (2 * Math.PI) / count;\n    const startAngle = -Math.PI / 2; // Start from top\n\n    return visibleConnections.map((conn, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        ...conn,\n        x: cx + orbitRadius * Math.cos(angle),\n        y: cy + orbitRadius * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [visibleConnections, cx, cy, orbitRadius]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (connections.length === 0) {\n    return (\n      <svg width={size} height={size} className=\"mc-svg\">\n        {/* Center node */}\n        <circle cx={cx} cy={cy} r={centerRadius} fill=\"var(--accent-color)\" />\n        <text x={cx} y={cy} textAnchor=\"middle\" dy={3} fontSize=\"10\" fill=\"white\" fontWeight=\"500\">\n          \u2605\n        </text>\n        <text\n          x={cx}\n          y={cy + centerRadius + 14}\n          textAnchor=\"middle\"\n          fontSize=\"9\"\n          fill=\"var(--text-muted)\"\n        >\n          No connections\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={size} height={size} className=\"mc-svg\">\n      {/* Connection lines */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n        const strength = node.strength ?? 0.5;\n\n        return (\n          <line\n            key={i}\n            x1={cx}\n            y1={cy}\n            x2={node.x}\n            y2={node.y}\n            stroke={color}\n            strokeWidth={1 + strength * 2}\n            strokeOpacity={0.4 + strength * 0.4}\n          />\n        );\n      })}\n\n      {/* Outer nodes */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n\n        return (\n          <g key={i}>\n            {/* Node circle */}\n            <circle cx={node.x} cy={node.y} r={nodeRadius} fill={color} opacity={0.9} />\n            {/* Kind initial */}\n            <text\n              x={node.x}\n              y={node.y}\n              textAnchor=\"middle\"\n              dy={3}\n              fontSize=\"8\"\n              fill=\"white\"\n              fontWeight=\"500\"\n            >\n              {node.kind.charAt(0).toUpperCase()}\n            </text>\n            {/* Name label */}\n            <title>{`${node.name} (${node.kind})\\n${node.relationshipKind}`}</title>\n          </g>\n        );\n      })}\n\n      {/* Center node (entry point) */}\n      <circle\n        cx={cx}\n        cy={cy}\n        r={centerRadius}\n        fill=\"var(--accent-color)\"\n        stroke=\"white\"\n        strokeWidth={2}\n      />\n      <text x={cx} y={cy} textAnchor=\"middle\" dy={4} fontSize=\"12\" fill=\"white\" fontWeight=\"600\">\n        \u2605\n      </text>\n\n      {/* Center label */}\n      <text x={cx} y={size - 6} textAnchor=\"middle\" fontSize=\"9\" fill=\"var(--text-muted)\">\n        {visibleConnections.length} connections\n        {hiddenCount > 0 && ` (+${hiddenCount})`}\n      </text>\n\n      {/* Legend - show unique kinds */}\n      {(() => {\n        const uniqueKinds = [...new Set(visibleConnections.map((c) => c.kind))];\n        if (uniqueKinds.length <= 4) {\n          return (\n            <g>\n              {uniqueKinds.map((kind, i) => (\n                <g key={kind} transform={`translate(${4 + i * 40}, 4)`}>\n                  <circle cx={4} cy={6} r={4} fill={getKindColor(kind)} />\n                  <text x={12} y={9} fontSize=\"8\" fill=\"var(--text-muted)\">\n                    {kind.slice(0, 4)}\n                  </text>\n                </g>\n              ))}\n            </g>\n          );\n        }\n        return null;\n      })()}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}", "type": "Readonly<MiniConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["circle", "text"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EnsembleConstellation", "name": "EnsembleConstellation", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EnsembleConstellation({\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}: Readonly<EnsembleConstellationProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);\n\n  // Compute layout\n  const nodes = useMemo(() => {\n    const layout = computeLayout(entryPointId, candidates, metricsMap, width, height);\n    const candidateMap = new Map(candidates.map((c) => [c.id, c]));\n    return layout.map((node) => {\n      const candidate = candidateMap.get(node.id);\n      const eraId = candidate?.eraId && candidate.eraId.length > 0 ? candidate.eraId : undefined;\n      return {\n        ...node,\n        isAssigned: assignedEntityIds.has(node.id),\n        eraColor: eraId ? (eraColorMap?.get(eraId) ?? \"#6b7280\") : \"#6b7280\",\n      };\n    });\n  }, [entryPointId, candidates, metricsMap, width, height, assignedEntityIds, eraColorMap]);\n\n  const nodeMap = useMemo(() => {\n    return new Map(nodes.map((n) => [n.id, n]));\n  }, [nodes]);\n\n  // Compute edges\n  const edges = useMemo(() => {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n    return computeEdges(relationships, nodeIds);\n  }, [relationships, nodes]);\n\n  // Compute bridge nodes (unassigned nodes connected to 2+ unique assigned entities)\n  const bridgeNodeIds = useMemo(() => {\n    // Map entity ID -> set of unique assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of relationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    const bridges = new Set<string>();\n    for (const [id, assignedConnections] of connectedToAssigned) {\n      if (assignedConnections.size >= 2) bridges.add(id);\n    }\n    return bridges;\n  }, [relationships, assignedEntityIds]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  const handleNodeClick = useCallback(\n    (nodeId: string) => {\n      if (selectedEntityId === nodeId) {\n        onSelectEntity(null);\n      } else {\n        onSelectEntity(nodeId);\n      }\n    },\n    [selectedEntityId, onSelectEntity]\n  );\n\n  // Determine node visual properties\n  const getNodeStyle = (node: ConstellationNode) => {\n    const isSelected = selectedEntityId === node.id;\n    const isHovered = hoveredNodeId === node.id;\n    const metrics = node.metrics;\n\n    // Base size\n    let radius = node.isEntryPoint ? 18 : 12;\n    if (isSelected || isHovered) radius += 2;\n\n    // Overused indicator\n    const isOverused = metrics && metrics.usageCount >= 5;\n\n    return { radius, isOverused, isSelected, isHovered };\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"ec-svg\"\n    >\n      {/* Orbit guides */}\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.25}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.5}\n      />\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.42}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.3}\n      />\n\n      {/* Edges */}\n      {edges.map((edge, i) => {\n        const source = nodeMap.get(edge.source);\n        const target = nodeMap.get(edge.target);\n        if (!source || !target) return null;\n\n        const sourceAssigned = assignedEntityIds.has(edge.source);\n        const targetAssigned = assignedEntityIds.has(edge.target);\n        const sourceSelected = selectedEntityId === edge.source || hoveredNodeId === edge.source;\n        const targetSelected = selectedEntityId === edge.target || hoveredNodeId === edge.target;\n\n        // Determine edge color and style based on node states\n        let strokeColor = \"var(--border-color)\";\n        let strokeOpacity = 0.2;\n        let strokeWidth = 1 + edge.strength * 1.5;\n\n        if (sourceAssigned && targetAssigned) {\n          // Both assigned - green, prominent\n          strokeColor = \"var(--success)\";\n          strokeOpacity = 0.7;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if ((sourceAssigned && targetSelected) || (targetAssigned && sourceSelected)) {\n          // One assigned, one selected - orange/gold\n          strokeColor = \"var(--warning)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceSelected || targetSelected) {\n          // One selected, neither assigned - purple\n          strokeColor = \"var(--accent-color)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceAssigned || targetAssigned) {\n          // One assigned, not selected - cyan to show potential ensemble connections\n          strokeColor = \"#06b6d4\"; // cyan\n          strokeOpacity = 0.5;\n          strokeWidth = 1.5 + edge.strength * 1.5;\n        }\n\n        return (\n          <line\n            key={i}\n            x1={source.x}\n            y1={source.y}\n            x2={target.x}\n            y2={target.y}\n            stroke={strokeColor}\n            strokeWidth={strokeWidth}\n            strokeOpacity={strokeOpacity}\n          />\n        );\n      })}\n\n      {/* Nodes */}\n      {nodes.map((node) => {\n        const style = getNodeStyle(node);\n        const color = getKindColor(node.kind);\n\n        return (\n          <g\n            key={node.id}\n            className=\"ec-cursor-pointer\"\n            onClick={() => handleNodeClick(node.id)}\n            onMouseEnter={() => setHoveredNodeId(node.id)}\n            onMouseLeave={() => setHoveredNodeId(null)}\n          >\n            {/* Overused glow */}\n            {style.isOverused && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 4}\n                fill=\"none\"\n                stroke=\"var(--error)\"\n                strokeWidth={2}\n                opacity={0.6}\n              />\n            )}\n\n            {/* Selection ring */}\n            {style.isSelected && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 3}\n                fill=\"none\"\n                stroke=\"var(--accent-color)\"\n                strokeWidth={2}\n              />\n            )}\n\n            {/* Bridge indicator (unassigned node connected to 2+ assigned) */}\n            {!node.isAssigned && !node.isEntryPoint && bridgeNodeIds.has(node.id) && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"#f59e0b\"\n                strokeWidth={2}\n                strokeDasharray=\"2,2\"\n              />\n            )}\n\n            {/* Assigned indicator */}\n            {node.isAssigned && !node.isEntryPoint && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"var(--success)\"\n                strokeWidth={2}\n                strokeDasharray=\"3,2\"\n              />\n            )}\n\n            {/* Node circle with era-colored ring */}\n            <circle\n              cx={node.x}\n              cy={node.y}\n              r={style.radius}\n              fill={node.isEntryPoint ? \"var(--accent-color)\" : color}\n              stroke={style.isHovered ? \"white\" : node.eraColor}\n              strokeWidth={2}\n            />\n\n            {/* Entry point star */}\n            {node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={5}\n                fontSize=\"14\"\n                fill=\"white\"\n                fontWeight=\"bold\"\n                className=\"ec-no-pointer\"\n              >\n                \u2605\n              </text>\n            )}\n\n            {/* Kind initial for non-entry-point nodes */}\n            {!node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={4}\n                fontSize=\"9\"\n                fill=\"white\"\n                fontWeight=\"500\"\n                className=\"ec-no-pointer\"\n              >\n                {node.kind.charAt(0).toUpperCase()}\n              </text>\n            )}\n          </g>\n        );\n      })}\n\n      {/* Tooltip layer - rendered on top of all nodes */}\n      {(() => {\n        const tooltipNodeId = hoveredNodeId || selectedEntityId;\n        const tooltipNode = tooltipNodeId ? nodeMap.get(tooltipNodeId) : null;\n        if (!tooltipNode) return null;\n\n        const style = getNodeStyle(tooltipNode);\n        const metrics = tooltipNode.metrics;\n        const usageCount = metrics?.usageCount ?? 0;\n        const linksToEnsemble = (() => {\n          if (tooltipNode.isAssigned) return null; // Don't show for assigned\n          let count = 0;\n          for (const rel of relationships) {\n// ... (truncated)", "parameters": [{"name": "{\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}", "type": "Readonly<EnsembleConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["circle", "line", "text", "tspan"], "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useState", "count": 1}, {"name": "useMemo", "count": 4}, {"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::RoleSlot", "name": "RoleSlot", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function RoleSlot({\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}: Readonly<RoleSlotProps>) {\n  const canAccept = hasSelection && !isAtMax;\n  const count = assignments.length;\n\n  const wrapClass = `rs-wrap ${canAccept ? \"rs-wrap-accept\" : isUnderMin ? \"rs-wrap-undermin\" : \"rs-wrap-default\"}`;\n\n  return (\n    <div\n      onClick={canAccept ? onAssign : undefined}\n      className={wrapClass}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      {/* Role header - single line */}\n      <div className={`rs-header ${assignments.length > 0 || canAccept ? \"rs-header-mb\" : \"\"}`}>\n        <div className=\"rs-name-row\">\n          <span className={`rs-role-name ${isUnderMin ? \"rs-role-name-error\" : \"rs-role-name-default\"}`}>\n            {role.role}\n          </span>\n          <span className={`rs-role-count ${isUnderMin ? \"rs-role-count-error\" : \"rs-role-count-default\"}`}>\n            {count}/{role.count.max}\n          </span>\n        </div>\n\n        {canAccept && (\n          <span className=\"rs-add-label\">\n            + Add\n          </span>\n        )}\n      </div>\n\n      {/* Assigned entities - visually distinct from header */}\n      {assignments.length > 0 && (\n        <div className=\"rs-assignments\">\n          {assignments.map((assignment) => (\n            <div\n              key={assignment.entityId}\n              className=\"rs-assignment-row\"\n              onClick={(e) => e.stopPropagation()}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              {/* Entity name */}\n              <span className=\"rs-entity-name\">\n                {assignment.entityName}\n                <span className=\"rs-entity-kind\">\n                  {assignment.entityKind}\n                </span>\n              </span>\n\n              {/* Primary/Support toggle - full text, more button-like */}\n              <button\n                onClick={() => onTogglePrimary(assignment.entityId)}\n                className={`rs-toggle-btn ${assignment.isPrimary ? \"rs-toggle-btn-primary\" : \"rs-toggle-btn-support\"}`}\n                title=\"Click to toggle primary/support\"\n              >\n                {assignment.isPrimary ? \"Primary\" : \"Support\"}\n              </button>\n\n              {/* Remove button */}\n              <button\n                onClick={() => onRemove(assignment.entityId)}\n                className=\"rs-remove-btn\"\n                title=\"Remove from role\"\n              >\n                \u00d7\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}", "type": "Readonly<RoleSlotProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EntityDetailCard", "name": "EntityDetailCard", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EntityDetailCard({\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}: Readonly<EntityDetailCardProps>) {\n  // Empty state\n  if (!entity) {\n    return (\n      <div className=\"edc-empty\">\n        <div className=\"edc-empty-sub\">No entity selected</div>\n        <div className=\"edc-empty-hint\">Click a node to see details</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edc-card\">\n      {/* Header - compact */}\n      <div className=\"edc-header\">\n        <div className=\"edc-name-row\">\n          {entity.name}\n          {isEntryPoint && (\n            <span className=\"edc-entry-badge\">\n              Entry\n            </span>\n          )}\n          {isAssigned && !isEntryPoint && (\n            <span className=\"edc-assigned-badge\">\n              Assigned\n            </span>\n          )}\n        </div>\n        <div className=\"edc-kind-line\">\n          {entity.kind}\n          {entity.subtype && ` \u00b7 ${entity.subtype}`}\n        </div>\n      </div>\n\n      {/* Metrics - two rows: stats on top, story effects below */}\n      {(metrics || eraName) && (\n        <div className=\"edc-metrics\">\n          {/* Row 1: Basic stats */}\n          <div className=\"edc-metric-row\">\n            {metrics && (\n              <>\n                <MetricChip\n                  label={(() => {\n                    if (metrics.distance === 0) return \"Entry\";\n                    if (metrics.distance === 1) return \"Direct\";\n                    if (metrics.distance >= 99) return \"Distant\";\n                    return `${metrics.distance}-hop`;\n                  })()}\n                />\n                <MetricChip\n                  label={`${metrics.usageCount}x used`}\n                  variant={(() => {\n                    if (metrics.usageCount >= 5) return \"error\" as const;\n                    if (metrics.usageCount >= 2) return \"warning\" as const;\n                    return \"default\" as const;\n                  })()}\n                />\n                <MetricChip label={`${(metrics.avgStrength * 100).toFixed(0)}% link`} />\n              </>\n            )}\n            {eraName && <MetricChip label={eraName} customColor={eraColor} />}\n          </div>\n          {/* Row 2: Story effects (always separate line) */}\n          {(metrics?.addsNewCategory || (metrics && metrics.newRelTypes > 0)) && (\n            <div className=\"edc-metric-row\">\n              {metrics?.addsNewCategory && <MetricChip label=\"+category\" variant=\"accent\" />}\n              {metrics && metrics.newRelTypes > 0 && (\n                <MetricChip label={`+${metrics.newRelTypes} rel`} variant=\"accent\" />\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}", "type": "Readonly<EntityDetailCardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts::EnsembleHealthBar", "name": "EnsembleHealthBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/index.ts", "sourceCode": "export default function EnsembleHealthBar({\n  assignments,\n  candidates,\n  kindToCategory,\n}: Readonly<EnsembleHealthBarProps>) {\n  // Compute category stats\n  const stats = useMemo(() => {\n    // Get all unique categories from candidates\n    const allCategories = new Set<string>();\n    const kindMap = kindToCategory || new Map<string, string>();\n\n    for (const candidate of candidates) {\n      const category = kindMap.get(candidate.kind) || candidate.kind;\n      allCategories.add(category);\n    }\n\n    // Count assigned categories\n    const assignedCategories = new Map<string, number>();\n    for (const assignment of assignments) {\n      const category = kindMap.get(assignment.entityKind) || assignment.entityKind;\n      assignedCategories.set(category, (assignedCategories.get(category) || 0) + 1);\n    }\n\n    // Find missing categories\n    const missingCategories: string[] = [];\n    for (const category of allCategories) {\n      if (!assignedCategories.has(category)) {\n        missingCategories.push(category);\n      }\n    }\n\n    // Calculate coverage percentage\n    const coveredCount = assignedCategories.size;\n    const totalCount = allCategories.size;\n    const coveragePercent = totalCount > 0 ? (coveredCount / totalCount) * 100 : 0;\n\n    return {\n      categories: [...allCategories],\n      assignedCategories,\n      missingCategories,\n      coveragePercent,\n      coveredCount,\n      totalCount,\n    };\n  }, [assignments, candidates, kindToCategory]);\n\n  const getColor = (category: string): string => {\n    return CATEGORY_COLORS[category.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (stats.totalCount === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"ehb-wrap\">\n      {/* Header */}\n      <div className=\"ehb-header\">\n        <span className=\"ehb-title\">\n          Ensemble Diversity\n        </span>\n        <span\n          className=\"ehb-count\"\n          style={{\n            '--ehb-count-color': stats.coveragePercent === 100 ? \"var(--success)\" : \"var(--text-muted)\",\n          } as React.CSSProperties}\n        >\n          {stats.coveredCount}/{stats.totalCount} categories\n        </span>\n      </div>\n\n      {/* Segmented bar */}\n      <div className=\"ehb-bar\">\n        {stats.categories.map((category, i) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const width = `${100 / stats.totalCount}%`;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              title={`${category}: ${count} assigned`}\n              className=\"ehb-bar-segment\"\n              style={{\n                '--ehb-seg-width': width,\n                '--ehb-seg-bg': isCovered ? color : \"transparent\",\n                '--ehb-seg-opacity': isCovered ? 1 : 0.3,\n                '--ehb-seg-border': i < stats.categories.length - 1 ? \"1px solid var(--bg-tertiary)\" : \"none\",\n              } as React.CSSProperties}\n            />\n          );\n        })}\n      </div>\n\n      {/* Category legend */}\n      <div\n        className=\"ehb-legend\"\n        style={{\n          '--ehb-legend-mb': stats.missingCategories.length > 0 ? \"8px\" : \"0\",\n        } as React.CSSProperties}\n      >\n        {stats.categories.map((category) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              className=\"ehb-legend-item\"\n              style={{\n                '--ehb-item-color': isCovered ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                '--ehb-item-opacity': isCovered ? 1 : 0.6,\n              } as React.CSSProperties}\n            >\n              <span\n                className=\"ehb-legend-dot\"\n                style={{\n                  '--ehb-dot-bg': isCovered ? color : \"var(--bg-secondary)\",\n                  '--ehb-dot-border': isCovered ? \"none\" : `1px solid ${color}`,\n                } as React.CSSProperties}\n              />\n              <span className=\"ehb-legend-label\">\n                {category}\n                {count > 1 && ` (${count})`}\n              </span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Missing categories warning */}\n      {stats.missingCategories.length > 0 && (\n        <div className=\"ehb-warning\">\n          <span className=\"ehb-warning-icon\">\ud83d\udca1</span>\n          <span>\n            Consider adding:{\" \"}\n            {stats.missingCategories.map((cat, i) => (\n              <span key={cat}>\n                <span className=\"ehb-missing-cat\">{cat}</span>\n                {i < stats.missingCategories.length - 1 && \", \"}\n              </span>\n            ))}\n          </span>\n        </div>\n      )}\n\n      {/* All covered celebration */}\n      {stats.missingCategories.length === 0 && stats.totalCount > 1 && (\n        <div className=\"ehb-success\">\n          <span>\u2713</span>\n          <span>All categories represented - diverse ensemble!</span>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  assignments,\n  candidates,\n  kindToCategory,\n}", "type": "Readonly<EnsembleHealthBarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryPotentialRadarWithScore", "name": "StoryPotentialRadarWithScore", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Radar chart with score displayed below\n */\nexport function StoryPotentialRadarWithScore({\n  potential,\n  size = 160,\n}: Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>) {\n  return (\n    <div className=\"spr-with-score\">\n      <StoryPotentialRadar potential={potential} size={size} />\n      <div className=\"spr-score-wrap\">\n        <div className=\"spr-score-number\">\n          {(potential.overallScore * 100).toFixed(0)}\n        </div>\n        <div className=\"spr-score-label\">\n          Story Score\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n}", "type": "Readonly<{\n  potential: StoryPotential;\n  size?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["StoryPotentialRadar", "div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryScoreBar", "name": "StoryScoreBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Compact score bar for list items\n */\nexport function StoryScoreBar({\n  score,\n  width = 60,\n  height = 8,\n}: Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>) {\n  const fillWidth = score * width;\n\n  return (\n    <svg width={width} height={height} className=\"spr-svg\">\n      {/* Background */}\n      <rect x={0} y={0} width={width} height={height} rx={height / 2} fill=\"var(--bg-tertiary)\" />\n      {/* Fill */}\n      <rect\n        x={0}\n        y={0}\n        width={fillWidth}\n        height={height}\n        rx={height / 2}\n        fill=\"var(--accent-color)\"\n      />\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  score,\n  width = 60,\n  height = 8,\n}", "type": "Readonly<{\n  score: number;\n  width?: number;\n  height?: number;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["rect"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::StoryScoreDots", "name": "StoryScoreDots", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "/**\n * Dot rating display (1-5 filled dots)\n */\nexport function StoryScoreDots({ score, maxDots = 5 }: Readonly<{ score: number; maxDots?: number }>) {\n  const filledDots = Math.max(1, Math.min(maxDots, Math.round(score * maxDots)));\n\n  return (\n    <div className=\"spr-dots\">\n      {Array.from({ length: maxDots }).map((_, i) => (\n        <span\n          key={i}\n          className={`spr-dot ${i < filledDots ? \"spr-dot-filled\" : \"spr-dot-empty\"}`}\n        />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ score, maxDots = 5 }", "type": "Readonly<{ score: number; maxDots?: number }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/lore-weave/webui/src/hooks/useSimulationWorker.ts::useSimulationWorker", "name": "useSimulationWorker", "kind": "hook", "filePath": "apps/lore-weave/webui/src/hooks/useSimulationWorker.ts", "sourceCode": "export function useSimulationWorker(): UseSimulationWorkerReturn {\n  const [state, setState] = useState<SimulationState>(initialState);\n  const workerRef = useRef<Worker | null>(null);\n\n  // Cleanup worker on unmount\n  useEffect(() => {\n    return () => {\n      if (workerRef.current) {\n        workerRef.current.terminate();\n        workerRef.current = null;\n      }\n    };\n  }, []);\n\n  const handleMessage = useCallback((event: MessageEvent<SimulationEvent>) => {\n    const message = event.data;\n\n    setState((prev) => {\n      switch (message.type) {\n        case \"progress\":\n          // Map progress phase to status (includes 'paused')\n          const status = message.payload.phase as SimulationState[\"status\"];\n          return {\n            ...prev,\n            status,\n            progress: message.payload,\n          };\n\n        case \"log\":\n          // Limit log entries to prevent memory issues\n          const newLogs = [...prev.logs, message.payload];\n          if (newLogs.length > MAX_LOG_ENTRIES) {\n            newLogs.splice(0, newLogs.length - MAX_LOG_ENTRIES);\n          }\n          return {\n            ...prev,\n            logs: newLogs,\n          };\n\n        case \"validation\":\n          return {\n            ...prev,\n            validation: message.payload,\n          };\n\n        case \"epoch_start\":\n          return {\n            ...prev,\n            currentEpoch: message.payload,\n          };\n\n        case \"epoch_stats\":\n          return {\n            ...prev,\n            epochStats: [...prev.epochStats, message.payload],\n          };\n\n        case \"growth_phase\":\n          return {\n            ...prev,\n            growthPhases: [...prev.growthPhases, message.payload],\n          };\n\n        case \"template_application\":\n          // Keep only last 1000 template applications (for trace visualization)\n          const newTemplateApps = [...prev.templateApplications, message.payload];\n          if (newTemplateApps.length > 1000) {\n            newTemplateApps.splice(0, newTemplateApps.length - 1000);\n          }\n          return {\n            ...prev,\n            templateApplications: newTemplateApps,\n          };\n\n        case \"action_application\":\n          return {\n            ...prev,\n            actionApplications: [...prev.actionApplications, message.payload],\n          };\n\n        case \"pressure_update\":\n          // Keep only last 500 pressure updates (enough for ~33 epochs at 15 ticks each)\n          const newPressureUpdates = [...prev.pressureUpdates, message.payload];\n          if (newPressureUpdates.length > 500) {\n            newPressureUpdates.splice(0, newPressureUpdates.length - 500);\n          }\n          return {\n            ...prev,\n            pressureUpdates: newPressureUpdates,\n          };\n\n        case \"population_report\":\n          return {\n            ...prev,\n            populationReport: message.payload,\n          };\n\n        case \"template_usage\":\n          return {\n            ...prev,\n            templateUsage: message.payload,\n          };\n\n        case \"coordinate_stats\":\n          return {\n            ...prev,\n            coordinateStats: message.payload,\n          };\n\n        case \"tag_health\":\n          return {\n            ...prev,\n            tagHealth: message.payload,\n          };\n\n        case \"system_health\":\n          return {\n            ...prev,\n            systemHealth: message.payload,\n          };\n\n        case \"system_action\":\n          // Keep only last 500 system actions\n          const newSystemActions = [...prev.systemActions, message.payload];\n          if (newSystemActions.length > 500) {\n            newSystemActions.splice(0, newSystemActions.length - 500);\n          }\n          return {\n            ...prev,\n            systemActions: newSystemActions,\n          };\n\n        case \"entity_breakdown\":\n          return {\n            ...prev,\n            entityBreakdown: message.payload,\n          };\n\n        case \"catalyst_stats\":\n          return {\n            ...prev,\n            catalystStats: message.payload,\n          };\n\n        case \"relationship_breakdown\":\n          return {\n            ...prev,\n            relationshipBreakdown: message.payload,\n          };\n\n        case \"notable_entities\":\n          return {\n            ...prev,\n            notableEntities: message.payload,\n          };\n\n        case \"complete\":\n          return {\n            ...prev,\n            status: \"complete\",\n            result: message.payload,\n          };\n\n        case \"state_export\":\n          return {\n            ...prev,\n            stateExport: message.payload,\n          };\n\n        case \"error\":\n          return {\n            ...prev,\n            status: \"error\",\n            error: message.payload,\n          };\n\n        default:\n          return prev;\n      }\n    });\n  }, []);\n\n  const start = useCallback(\n    (config: EngineConfig, initialEntities: HardState[]) => {\n      // Terminate existing worker if any\n      if (workerRef.current) {\n        workerRef.current.terminate();\n      }\n\n      // Reset state to initial values\n      setState({\n        ...initialState,\n        status: \"initializing\",\n      });\n\n      // Create new worker using Vite's web worker support\n      // Import the worker as a module - Vite bundles it appropriately\n      workerRef.current = new Worker(new URL(\"../workers/simulation.worker.ts\", import.meta.url), {\n        type: \"module\",\n      });\n\n      workerRef.current.onmessage = handleMessage;\n\n      workerRef.current.onerror = (error) => {\n        setState((prev) => ({\n          ...prev,\n          status: \"error\",\n          error: {\n            message: error.message || \"Worker error\",\n            phase: \"worker\",\n            context: {},\n          },\n        }));\n      };\n\n      // Start simulation\n      workerRef.current.postMessage({\n        type: \"start\",\n        config,\n        initialState: initialEntities,\n      });\n    },\n    [handleMessage]\n  );\n\n  const startStepping = useCallback(\n    (config: EngineConfig, initialEntities: HardState[]) => {\n      // Terminate existing worker if any\n      if (workerRef.current) {\n        workerRef.current.terminate();\n      }\n\n      // Reset state to initial values\n      setState({\n        ...initialState,\n        status: \"initializing\",\n      });\n\n      // Create new worker\n      workerRef.current = new Worker(new URL(\"../workers/simulation.worker.ts\", import.meta.url), {\n        type: \"module\",\n      });\n\n      workerRef.current.onmessage = handleMessage;\n\n      workerRef.current.onerror = (error) => {\n        setState((prev) => ({\n          ...prev,\n          status: \"error\",\n          error: {\n            message: error.message || \"Worker error\",\n            phase: \"worker\",\n            context: {},\n          },\n        }));\n      };\n\n      // Initialize for stepping (doesn't run automatically)\n      workerRef.current.postMessage({\n        type: \"startStepping\",\n        config,\n        initialState: initialEntities,\n      });\n    },\n    [handleMessage]\n  );\n\n  const step = useCallback(() => {\n    if (workerRef.current) {\n      workerRef.current.postMessage({ type: \"step\" });\n    }\n  }, []);\n\n  const runToCompletion = useCallback(() => {\n    if (workerRef.current) {\n      workerRef.current.postMessage({ type: \"runToCompletion\" });\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    if (workerRef.current) {\n      // Reset state but keep worker\n      setState((prev) => ({\n        ...prev,\n        status: \"initializing\",\n        epochStats: [],\n        growthPhases: [],\n        pressureUpdates: [],\n        populationReport: null,\n        templateUsage: null,\n        coordinateStats: null,\n        tagHealth: null,\n        systemHealth: null,\n        systemActions: [],\n        entityBreakdown: null,\n        catalystStats: null,\n        relationshipBreakdown: null,\n        notableEntities: null,\n        result: null,\n        error: null,\n// ... (truncated)", "parameters": [], "returnType": "UseSimulationWorkerReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 9}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../../../lib/observer/types", "specifiers": ["SimulationEvent", "ProgressPayload", "LogPayload", "ValidationPayload", "EpochStartPayload", "EpochStatsPayload", "GrowthPhasePayload", "TemplateApplicationPayload", "ActionApplicationPayload", "PressureUpdatePayload", "PopulationPayload", "TemplateUsagePayload", "CoordinateStatsPayload", "TagHealthPayload", "SystemHealthPayload", "SystemActionPayload", "EntityBreakdownPayload", "CatalystStatsPayload", "RelationshipBreakdownPayload", "NotableEntitiesPayload", "SimulationResultPayload", "StateExportPayload", "ErrorPayload"], "category": "internal"}, {"source": "../../../lib/engine/types", "specifiers": ["EngineConfig"], "category": "internal"}, {"source": "../../../lib/core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}]