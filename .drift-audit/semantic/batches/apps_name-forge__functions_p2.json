[{"id": "apps/name-forge/lib/phonology.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }"}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult"}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/pronounceability.ts::countMaxConsonantCluster", "name": "countMaxConsonantCluster", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Count maximum consecutive consonants in a name\r\n */\r\nexport function countMaxConsonantCluster(name: string): number {\r\n  let maxCluster = 0;\r\n  let currentCluster = 0;\r\n\r\n  for (const char of name.toLowerCase()) {\r\n    if (isVowel(char)) {\r\n      maxCluster = Math.max(maxCluster, currentCluster);\r\n      currentCluster = 0;\r\n    } else if (char.match(/[a-z]/)) {\r\n      // Only count letters, skip apostrophes/hyphens\r\n      currentCluster++;\r\n    }\r\n  }\r\n\r\n  return Math.max(maxCluster, currentCluster);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::checkVowelSpacing", "name": "checkVowelSpacing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Check vowel spacing (max consonants between vowels)\r\n */\r\nexport function checkVowelSpacing(name: string): number {\r\n  const chars = name.toLowerCase().split(\"\");\r\n  let maxGap = 0;\r\n  let currentGap = 0;\r\n  let foundVowel = false;\r\n\r\n  for (const char of chars) {\r\n    if (isVowel(char)) {\r\n      maxGap = Math.max(maxGap, currentGap);\r\n      currentGap = 0;\r\n      foundVowel = true;\r\n    } else if (char.match(/[a-z]/)) {\r\n      if (foundVowel) {\r\n        currentGap++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return maxGap;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreSonoritySequencing", "name": "scoreSonoritySequencing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score sonority sequencing violations\r\n *\r\n * Checks if syllables follow natural sonority rises/falls:\r\n * - Onsets should have rising sonority\r\n * - Codas should have falling sonority\r\n *\r\n * Returns: normalized score 0-1 (1 = perfect, 0 = many violations)\r\n */\r\nexport function scoreSonoritySequencing(\r\n  name: string,\r\n  phonemes: string[],\r\n  customRanks?: Record<string, number>\r\n): number {\r\n  if (phonemes.length === 0) return 1.0;\r\n\r\n  let violations = 0;\r\n  let transitions = 0;\r\n\r\n  // Scan through phoneme sequence\r\n  for (let i = 0; i < phonemes.length - 1; i++) {\r\n    const current = phonemes[i];\r\n    const next = phonemes[i + 1];\r\n\r\n    const currentSonority = getSonority(current, customRanks);\r\n    const nextSonority = getSonority(next, customRanks);\r\n\r\n    transitions++;\r\n\r\n    // If we're going from consonant to consonant\r\n    if (currentSonority < 5 && nextSonority < 5) {\r\n      // In onset (start of syllable), sonority should rise\r\n      // In coda (end of syllable), sonority should fall\r\n      // We penalize plateaus or inversions in consonant clusters\r\n      if (nextSonority < currentSonority) {\r\n        violations++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (transitions === 0) return 1.0;\r\n  return Math.max(0, 1 - violations / transitions);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "customRanks", "type": "Record<string, number>", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreTemplateLegality", "name": "scoreTemplateLegality", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score template legality\r\n *\r\n * Checks if the name can be decomposed into allowed syllable templates.\r\n * Uses the phonology profile's syllable templates.\r\n *\r\n * Returns: 0-1 score (1 = fully legal, 0 = no templates match)\r\n */\r\nexport function scoreTemplateLegality(\r\n  name: string,\r\n  syllables: string[],\r\n  allowedTemplates: string[]\r\n): number {\r\n  if (syllables.length === 0) return 0;\r\n\r\n  let matchedSyllables = 0;\r\n\r\n  for (const syllable of syllables) {\r\n    // Convert syllable to template pattern (C/V)\r\n    const pattern = syllable\r\n      .split(\"\")\r\n      .map((char) => (isVowel(char) ? \"V\" : \"C\"))\r\n      .join(\"\");\r\n\r\n    // Check if pattern matches any allowed template\r\n    if (allowedTemplates.includes(pattern)) {\r\n      matchedSyllables++;\r\n    }\r\n  }\r\n\r\n  return matchedSyllables / syllables.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "allowedTemplates", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreHarmonicConstraints", "name": "scoreHarmonicConstraints", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Compute harmonic constraint violations\r\n *\r\n * Checks culture-specific phonotactic rules:\r\n * - Max consonant cluster size\r\n * - Vowel spacing requirements\r\n *\r\n * Returns: 0-1 score (1 = no violations, 0 = many violations)\r\n */\r\nexport function scoreHarmonicConstraints(\r\n  name: string,\r\n  profile: PhonologyProfile\r\n): number {\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  const actualMaxCluster = countMaxConsonantCluster(name);\r\n  const actualVowelGap = checkVowelSpacing(name);\r\n\r\n  let violations = 0;\r\n\r\n  // Penalize exceeding max consonant cluster\r\n  if (actualMaxCluster > maxConsonantCluster) {\r\n    violations += actualMaxCluster - maxConsonantCluster;\r\n  }\r\n\r\n  // Penalize exceeding vowel spacing\r\n  if (actualVowelGap > minVowelSpacing) {\r\n    violations += actualVowelGap - minVowelSpacing;\r\n  }\r\n\r\n  // Normalize: assume max 5 violations is very bad\r\n  return Math.max(0, 1 - violations / 5);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scorePronounceability", "name": "scorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Combined pronounceability score\r\n *\r\n * Weights:\r\n * - 30% template legality (structural correctness)\r\n * - 30% sonority sequencing (natural flow)\r\n * - 40% harmonic constraints (culture-specific rules)\r\n *\r\n * Returns: 0-1 score (1 = highly pronounceable)\r\n */\r\nexport function scorePronounceability(\r\n  name: string,\r\n  syllables: string[],\r\n  phonemes: string[],\r\n  profile: PhonologyProfile\r\n): number {\r\n  const templateScore = scoreTemplateLegality(name, syllables, profile.syllableTemplates);\r\n  const sonorityScore = scoreSonoritySequencing(name, phonemes, profile.sonorityRanks);\r\n  const harmonicScore = scoreHarmonicConstraints(name, profile);\r\n\r\n  // Weighted combination\r\n  return 0.3 * templateScore + 0.3 * sonorityScore + 0.4 * harmonicScore;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::batchScorePronounceability", "name": "batchScorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "export function batchScorePronounceability(\r\n  names: string[],\r\n  syllablesPerName: string[][],\r\n  phonemesPerName: string[][],\r\n  profile: PhonologyProfile\r\n): PronounceabilityReport {\r\n  const scores = names.map((name, i) =>\r\n    scorePronounceability(name, syllablesPerName[i] ?? [], phonemesPerName[i] ?? [], profile)\r\n  );\r\n\r\n  scores.sort((a, b) => a - b);\r\n\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  let tooManyConsonants = 0;\r\n  let poorVowelSpacing = 0;\r\n\r\n  for (const name of names) {\r\n    if (countMaxConsonantCluster(name) > maxConsonantCluster) {\r\n      tooManyConsonants++;\r\n    }\r\n    if (checkVowelSpacing(name) > minVowelSpacing) {\r\n      poorVowelSpacing++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\r\n    minScore: scores[0],\r\n    maxScore: scores[scores.length - 1],\r\n    p5: scores[Math.floor(scores.length * 0.05)],\r\n    p95: scores[Math.floor(scores.length * 0.95)],\r\n    violations: {\r\n      tooManyConsonants,\r\n      poorVowelSpacing,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "syllablesPerName", "type": "string[][]", "optional": false}, {"name": "phonemesPerName", "type": "string[][]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "PronounceabilityReport"}, {"id": "apps/name-forge/lib/style.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }"}, {"id": "apps/name-forge/lib/style.ts::hasPreferredEnding", "name": "hasPreferredEnding", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if a name has a preferred ending\r\n */\r\nexport function hasPreferredEnding(\r\n  name: string,\r\n  preferredEndings?: string[]\r\n): boolean {\r\n  if (!preferredEndings || preferredEndings.length === 0) {\r\n    return false;\r\n  }\r\n  return endsWithAny(name, preferredEndings);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/style.ts::selectWithPreferredEndings", "name": "selectWithPreferredEndings", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Generate multiple candidates and boost those with preferred endings\r\n */\r\nexport function selectWithPreferredEndings<T>(\r\n  rng: () => number,\r\n  candidates: T[],\r\n  nameExtractor: (candidate: T) => string,\r\n  preferredEndings?: string[],\r\n  boost: number = 2.0\r\n): T {\r\n  if (\r\n    !preferredEndings ||\r\n    preferredEndings.length === 0 ||\r\n    candidates.length === 0\r\n  ) {\r\n    // No preference, pick uniformly\r\n    return candidates[Math.floor(rng() * candidates.length)];\r\n  }\r\n\r\n  // Calculate weights\r\n  const weights = candidates.map((candidate) => {\r\n    const name = nameExtractor(candidate);\r\n    return hasPreferredEnding(name, preferredEndings) ? boost : 1.0;\r\n  });\r\n\r\n  // Weighted selection\r\n  const total = weights.reduce((sum, w) => sum + w, 0);\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n\r\n  for (let i = 0; i < candidates.length; i++) {\r\n    cumulative += weights[i];\r\n    if (r < cumulative) {\r\n      return candidates[i];\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return candidates[candidates.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "T[]", "optional": false}, {"name": "nameExtractor", "type": "(candidate: T) => string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}, {"name": "boost", "type": "number", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/style.ts::applyRhythmBias", "name": "applyRhythmBias", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply rhythm-based adjustments to a name\r\n * This is a placeholder for future enhancement\r\n */\r\nexport function applyRhythmBias(\r\n  name: string,\r\n  _rhythmBias?: \"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"\r\n): string {\r\n  // Rhythm bias is primarily enforced during phonology generation.\r\n  // Post-processing transformations (softening consonant clusters,\r\n  // emphasizing consonants, adding syllable breaks, smoothing transitions)\r\n  // can be added here in the future.\r\n  return name;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_rhythmBias", "type": "\"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::validateStyle", "name": "validateStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Validate that a name meets style constraints\r\n */\r\nexport function validateStyle(name: string, _style: StyleRules): boolean {\r\n  // Basic validation: more complex checks (apostrophe/hyphen placement,\r\n  // capitalization, double apostrophes) can be added here.\r\n  return name.length > 0;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_style", "type": "StyleRules", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/style.ts::applyStyleWithCandidates", "name": "applyStyleWithCandidates", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply all stylistic transforms and select best candidate\r\n */\r\nexport function applyStyleWithCandidates(\r\n  rng: () => number,\r\n  candidates: string[],\r\n  style: StyleRules,\r\n  syllablesPerCandidate?: string[][]\r\n): string {\r\n  if (candidates.length === 0) {\r\n    throw new Error(\"No candidates provided\");\r\n  }\r\n\r\n  // Generate styled versions\r\n  const styledCandidates = candidates.map((name, index) => {\r\n    const syllables = syllablesPerCandidate?.[index];\r\n    const { result } = applyStyle(rng, name, style, syllables);\r\n    return result;\r\n  });\r\n\r\n  // Select with preferred endings boost\r\n  return selectWithPreferredEndings(\r\n    rng,\r\n    styledCandidates,\r\n    (name) => name,\r\n    style.preferredEndings,\r\n    style.preferredEndingBoost\r\n  );\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllablesPerCandidate", "type": "string[][]", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::normalizeForComparison", "name": "normalizeForComparison", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Strip style markers for comparison\r\n * Useful for validation and deduplication\r\n */\r\nexport function normalizeForComparison(name: string): string {\r\n  return name\r\n    .toLowerCase()\r\n    .replace(/['\\-\\s]/g, \"\") // Remove apostrophes, hyphens, spaces\r\n    .trim();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::areTooSimilar", "name": "areTooSimilar", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if two names are too similar (considering style variations)\r\n */\r\nexport function areTooSimilar(name1: string, name2: string): boolean {\r\n  const norm1 = normalizeForComparison(name1);\r\n  const norm2 = normalizeForComparison(name2);\r\n  return norm1 === norm2;\r\n}", "parameters": [{"name": "name1", "type": "string", "optional": false}, {"name": "name2", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/genetic.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/genetic.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/hillclimb.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/hillclimb.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/optimizer/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/optimizer/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/sim-anneal.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/sim-anneal.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::endsWithAny", "name": "endsWithAny", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a string ends with any of the given suffixes\r\n */\r\nexport function endsWithAny(str: string, suffixes: string[]): boolean {\r\n  return suffixes.some((suffix) =>\r\n    str.toLowerCase().endsWith(suffix.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "suffixes", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::findSyllableBoundaries", "name": "findSyllableBoundaries", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Find legal positions to insert apostrophes or hyphens\r\n * Returns indices between syllables (not in the middle of syllable templates)\r\n */\r\nexport function findSyllableBoundaries(\r\n  word: string,\r\n  syllables: string[]\r\n): number[] {\r\n  const boundaries: number[] = [];\r\n  let position = 0;\r\n\r\n  for (let i = 0; i < syllables.length - 1; i++) {\r\n    position += syllables[i].length;\r\n    boundaries.push(position);\r\n  }\r\n\r\n  return boundaries;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/utils/helpers.ts::insertAtBoundary", "name": "insertAtBoundary", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Insert a character at a random syllable boundary\r\n */\r\nexport function insertAtBoundary(\r\n  word: string,\r\n  char: string,\r\n  boundaries: number[],\r\n  rng: () => number\r\n): string {\r\n  if (boundaries.length === 0) return word;\r\n\r\n  const index = boundaries[Math.floor(rng() * boundaries.length)];\r\n  return word.slice(0, index) + char + word.slice(index);\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "char", "type": "string", "optional": false}, {"name": "boundaries", "type": "number[]", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasForbiddenCluster", "name": "hasForbiddenCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Validate that a name doesn't contain forbidden clusters\r\n */\r\nexport function hasForbiddenCluster(\r\n  name: string,\r\n  forbiddenClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return forbiddenClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "forbiddenClusters", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasFavoredCluster", "name": "hasFavoredCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a name contains any favored clusters\r\n */\r\nexport function hasFavoredCluster(\r\n  name: string,\r\n  favoredClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return favoredClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "favoredClusters", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Count syllables in a word (rough approximation based on vowel groups)\r\n */\r\nexport function estimateSyllableCount(word: string): number {\r\n  // Simple heuristic: count vowel groups\r\n  const vowelGroups = word.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/helpers.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(word: string): number {\r\n  if (word.length === 0) return 0;\r\n  const vowelCount = (word.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / word.length;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/helpers.ts::normalizeWeights", "name": "normalizeWeights", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Normalize weights array (make them sum to 1)\r\n */\r\nexport function normalizeWeights(weights: number[]): number[] {\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All zero, return uniform\r\n    return weights.map(() => 1 / weights.length);\r\n  }\r\n  return weights.map((w) => Math.max(0, w) / total);\r\n}", "parameters": [{"name": "weights", "type": "number[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/utils/helpers.ts::deepClone", "name": "deepClone", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Deep clone an object using JSON serialization\r\n * Note: Loses functions, undefined, symbols, etc.\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  return JSON.parse(JSON.stringify(obj)) as T;\r\n}", "parameters": [{"name": "obj", "type": "T", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick multiple random elements from an array without replacement\r\n */\r\nexport function pickMultiple<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  count: number\r\n): T[] {\r\n  if (count <= 0) {\r\n    return [];\r\n  }\r\n  if (count >= array.length) {\r\n    return [...array];\r\n  }\r\n\r\n  const remaining = [...array];\r\n  const result: T[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const index = Math.floor(rng() * remaining.length);\r\n    result.push(remaining[index]);\r\n    remaining.splice(index, 1);\r\n  }\r\n\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]"}, {"id": "apps/name-forge/lib/utils/rng.ts::randomInt", "name": "randomInt", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random integer in range [min, max] inclusive\r\n */\r\nexport function randomInt(rng: () => number, min: number, max: number): number {\r\n  return Math.floor(rng() * (max - min + 1)) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/rng.ts::randomFloat", "name": "randomFloat", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random number in range [min, max]\r\n */\r\nexport function randomFloat(\r\n  rng: () => number,\r\n  min: number,\r\n  max: number\r\n): number {\r\n  return rng() * (max - min) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/rng.ts::chance", "name": "chance", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Return true with given probability\r\n */\r\nexport function chance(rng: () => number, probability: number): boolean {\r\n  return rng() < probability;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "probability", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/rng.ts::shuffle", "name": "shuffle", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Shuffle an array in place using Fisher-Yates algorithm\r\n */\r\nexport function shuffle<T>(rng: () => number, array: T[]): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(rng() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/name-forge/lib/validation/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport"}, {"id": "apps/name-forge/lib/validation/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport"}, {"id": "apps/name-forge/lib/validation/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]"}, {"id": "apps/name-forge/lib/validation/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport"}, {"id": "apps/name-forge/lib/validation/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector"}]