[{"id": "packages/canonry-dsl/src/compile.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl/src/compile.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl/src/index.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/parser.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/parser.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}]