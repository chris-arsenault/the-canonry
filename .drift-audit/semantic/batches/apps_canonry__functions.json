[{"id": "apps/canonry/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/App.jsx", "sourceCode": "// normalizeUiState moved to stores/useCanonryUiStore.js\n\nexport default function App() {\n  const activeTab = useCanonryUiStore(s => s.activeTab);\n  const activeSectionByTab = useCanonryUiStore(s => s.activeSectionByTab);\n  const showHome = useCanonryUiStore(s => s.showHome);\n  const helpModalOpen = useCanonryUiStore(s => s.helpModalOpen);\n  const chroniclerRequestedPage = useCanonryUiStore(s => s.chroniclerRequestedPage);\n  const [archivistData, setArchivistData] = useState(null);\n  const [worldContext, setWorldContext] = useState(null);\n  const [entityGuidance, setEntityGuidance] = useState(null);\n  const [cultureIdentities, setCultureIdentities] = useState(null);\n  const [enrichmentConfig, setEnrichmentConfig] = useState(null);\n  const [styleSelection, setStyleSelection] = useState(null);\n  const [historianConfig, setHistorianConfig] = useState(null);\n  const [simulationResults, setSimulationResults] = useState(null);\n  const [simulationState, setSimulationState] = useState(null);\n  const [slots, setSlots] = useState({});\n  const [activeSlotIndex, setActiveSlotIndex] = useState(0);\n  const [exportModalSlotIndex, setExportModalSlotIndex] = useState(null);\n  const [exportBundleStatus, setExportBundleStatus] = useState({\n    state: \"idle\",\n    detail: \"\"\n  });\n  // AWS state from zustand store\n  const awsModalOpen = useCanonryAwsStore(s => s.modalOpen);\n  const awsConfig = useCanonryAwsStore(s => s.config);\n  const awsTokens = useCanonryAwsStore(s => s.tokens);\n  const awsStatus = useCanonryAwsStore(s => s.status);\n  const awsBrowseState = useCanonryAwsStore(s => s.browseState);\n  const awsUsername = useCanonryAwsStore(s => s.username);\n  const awsPassword = useCanonryAwsStore(s => s.password);\n  const awsUserLabel = useCanonryAwsStore(s => s.userLabel);\n  const awsSyncProgress = useCanonryAwsStore(s => s.syncProgress);\n  const awsUploadPlan = useCanonryAwsStore(s => s.uploadPlan);\n  const snapshotStatus = useCanonryAwsStore(s => s.snapshotStatus);\n  // AWS actions from zustand store (stable references, no useCallback needed)\n  const updateAwsConfig = useCanonryAwsStore(s => s.updateConfig);\n  const setAwsTokens = useCanonryAwsStore(s => s.setTokens);\n  const setAwsStatus = useCanonryAwsStore(s => s.setStatus);\n  const setAwsBrowseState = useCanonryAwsStore(s => s.setBrowseState);\n  const setAwsUsername = useCanonryAwsStore(s => s.setUsername);\n  const setAwsPassword = useCanonryAwsStore(s => s.setPassword);\n  const setAwsUserLabel = useCanonryAwsStore(s => s.setUserLabel);\n  const setAwsSyncProgress = useCanonryAwsStore(s => s.setSyncProgress);\n  const setAwsUploadPlan = useCanonryAwsStore(s => s.setUploadPlan);\n  const setSnapshotStatus = useCanonryAwsStore(s => s.setSnapshotStatus);\n  const openAwsModal = useCanonryAwsStore(s => s.openModal);\n  const closeAwsModal = useCanonryAwsStore(s => s.closeModal);\n  const exportCancelRef = useRef(false);\n  const exportModalMouseDown = useRef(false);\n  const awsModalMouseDown = useRef(false);\n  const simulationOwnerRef = useRef(null);\n  const currentProjectRef = useRef(null);\n  // Track whether we're loading from a saved slot (to skip auto-save to scratch)\n  const isLoadingSlotRef = useRef(false);\n  // Track the last saved simulation results object to detect new simulations\n  const lastSavedResultsRef = useRef(null);\n  const bestRunScoreRef = useRef(-Infinity);\n  const bestRunSaveQueueRef = useRef(Promise.resolve());\n  const activeSection = useCanonryUiStore(selectActiveSection);\n  const s3Client = useMemo(() => createS3Client(awsConfig, awsTokens), [awsConfig, awsTokens]);\n  useEffect(() => {\n    const tokens = extractCognitoTokensFromUrl();\n    if (tokens) {\n      setAwsTokens(tokens);\n      clearCognitoHash();\n    }\n  }, [setAwsTokens]);\n  useEffect(() => {\n    let canceled = false;\n    const userPoolConfigured = Boolean(awsConfig?.cognitoUserPoolId && awsConfig?.cognitoClientId);\n    if (!userPoolConfigured || isTokenValid(awsTokens)) return;\n    getUserPoolSession(awsConfig).then(session => {\n      if (canceled || !session) return;\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      const username = session.getIdToken().payload?.[\"cognito:username\"] || \"\";\n      if (username) setAwsUserLabel(username);\n    }).catch(() => {});\n    return () => {\n      canceled = true;\n    };\n  }, [awsConfig, awsTokens, setAwsTokens, setAwsUserLabel]);\n  // UI actions from zustand store (stable references, no useCallback needed)\n  const setActiveSection = useCanonryUiStore(s => s.setActiveSection);\n  const setActiveSectionForTab = useCanonryUiStore(s => s.setActiveSectionForTab);\n  const handleTabChange = useCanonryUiStore(s => s.setActiveTab);\n  const handleGoHome = useCanonryUiStore(s => s.goHome);\n  const handleLandingNavigate = useCanonryUiStore(s => s.setActiveTab);\n  const clearChroniclerRequestedPage = useCanonryUiStore(s => s.clearChroniclerRequestedPage);\n  const openHelpModal = useCanonryUiStore(s => s.openHelpModal);\n  const closeHelpModal = useCanonryUiStore(s => s.closeHelpModal);\n  // Listen for cross-MFE navigation events (e.g., Archivist -> Chronicler)\n  useEffect(() => {\n    const navigateTo = useCanonryUiStore.getState().navigateTo;\n    const handleCrossNavigation = e => {\n      const {\n        tab,\n        pageId\n      } = e.detail || {};\n      if (tab) navigateTo(tab, pageId);\n    };\n    window.addEventListener(\"canonry:navigate\", handleCrossNavigation);\n    return () => window.removeEventListener(\"canonry:navigate\", handleCrossNavigation);\n  }, []);\n\n  // Listen for Illuminator world data mutations (rename, patch, enrichment)\n  // The Illuminator writes to its own Dexie store, then dispatches this event.\n  // We read from Dexie and merge into archivistData so other tabs see the changes.\n  useEffect(() => {\n    const handler = async e => {\n      const {\n        simulationRunId\n      } = e.detail || {};\n      if (!simulationRunId) return;\n      try {\n        const [{\n          getEntitiesForRun\n        }, {\n          getNarrativeEventsForRun\n        }] = await Promise.all([import(\"illuminator/entityRepository\"), import(\"illuminator/eventRepository\")]);\n        await Promise.all([getEntitiesForRun(simulationRunId), getNarrativeEventsForRun(simulationRunId)]);\n\n        // DISABLED: Automatic hardState updates removed due to data loss bug.\n        // The enrichment data lives in Dexie and is loaded by IlluminatorRemote.\n        // Do NOT modify worldData.hardState from this event handler.\n      } catch (err) {\n        console.warn(\"[Canonry] Failed to load Illuminator world data from Dexie:\", err);\n      }\n    };\n    window.addEventListener(\"illuminator:worlddata-changed\", handler);\n    return () => window.removeEventListener(\"illuminator:worlddata-changed\", handler);\n  }, []);\n\n  // Listen for hash changes to switch tabs (enables back button across MFEs)\n  // Hash formats: Archivist uses #/entity/{id}, Chronicler uses #/page/{id|slug}\n  useEffect(() => {\n    const handleHashChange = () => {\n      const hash = window.location.hash;\n      if (hash.startsWith(\"#/entity/\") || hash === \"#/entity\") {\n        if (activeTab !== \"archivist\") handleTabChange(\"archivist\");\n      } else if (hash.startsWith(\"#/page/\") || hash === \"#/page\") {\n        if (activeTab !== \"chronicler\") handleTabChange(\"chronicler\");\n      }\n    };\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [activeTab, handleTabChange]);\n  const openExportModal = useCallback(slotIndex => {\n    exportCancelRef.current = false;\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n    setExportModalSlotIndex(slotIndex);\n  }, []);\n  const closeExportModal = useCallback(() => {\n    setExportModalSlotIndex(null);\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n  }, []);\n  const handleExportModalMouseDown = useCallback(e => {\n    exportModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleExportModalClick = useCallback(e => {\n    if (exportBundleStatus.state === \"working\") return;\n    if (exportModalMouseDown.current && e.target === e.currentTarget) {\n      closeExportModal();\n    }\n  }, [closeExportModal, exportBundleStatus.state]);\n  const handleAwsModalMouseDown = useCallback(e => {\n    awsModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleAwsModalClick = useCallback(e => {\n    if (awsModalMouseDown.current && e.target === e.currentTarget) {\n      closeAwsModal();\n    }\n  }, [closeAwsModal]);\n  const handleAwsLogin = useCallback(async () => {\n    if (!awsUsername || !awsPassword) {\n      alert(\"Enter username and password.\");\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Signing in...\"\n      });\n      const session = await signInWithUserPool({\n        username: awsUsername,\n        password: awsPassword,\n        config: awsConfig\n      });\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      setAwsUserLabel(awsUsername);\n      setAwsPassword(\"\");\n      setAwsStatus({\n        state: \"idle\",\n        detail: \"Signed in.\"\n      });\n    } catch (err) {\n      console.error(\"Failed to sign in:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"Sign in failed.\"\n      });\n    }\n  }, [awsUsername, awsPassword, awsConfig, setAwsStatus, setAwsTokens, setAwsUserLabel, setAwsPassword]);\n  const handleAwsLogout = useCallback(() => {\n    signOutUserPool(awsConfig);\n    setAwsTokens(null);\n    setAwsUserLabel(\"\");\n    setAwsStatus({\n      state: \"idle\",\n      detail: \"Signed out.\"\n    });\n  }, [awsConfig, setAwsTokens, setAwsUserLabel, setAwsStatus]);\n  const handleAwsBrowsePrefixes = useCallback(async () => {\n    if (!s3Client || !awsConfig?.imageBucket) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: \"Missing S3 client or bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsBrowseState({\n        loading: true,\n        prefixes: [],\n        error: null\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      setAwsBrowseState({\n        loading: false,\n        prefixes,\n        error: null\n      });\n    } catch (err) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: err.message || \"Failed to list prefixes.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsBrowseState]);\n  const handleAwsTestSetup = useCallback(async () => {\n    if (!s3Client) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing AWS credentials.\"\n      });\n      return;\n    }\n    if (!awsConfig?.imageBucket) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing image bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Testing S3 access...\"\n      });\n      setAwsSyncProgress({\n        phase: \"test\",\n        processed: 0,\n        total: 0,\n        uploaded: 0\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      const prefixLabel = prefixes.length ? `Found ${prefixes.length} prefixes.` : \"Access OK.\";\n      setAwsStatus({\n        state: \"idle\",\n        detail: `Test passed. ${prefixLabel}`\n      });\n    } catch (err) {\n      console.error(\"Failed to test S3 setup:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"S3 test failed.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsStatus, setAwsSyncProgress]);\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/theme.js::getAccentColor", "name": "getAccentColor", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get accent color for current app\nexport function getAccentColor(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return colors.accentEnumerist;\n    case \"names\":\n      return colors.accentNameForge;\n    case \"cosmography\":\n      return colors.accentCosmographer;\n    case \"coherence\":\n      return colors.accentCoherence;\n    case \"simulation\":\n      return colors.accentSimulation;\n    case \"illuminator\":\n      return colors.accentIlluminator;\n    case \"archivist\":\n      return colors.accentArchivist;\n    case \"chronicler\":\n      return colors.accentChronicler;\n    default:\n      return colors.accent;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/theme.js::getAccentGradient", "name": "getAccentGradient", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get gradient for active nav buttons\nexport function getAccentGradient(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return `linear-gradient(135deg, ${colors.accentEnumerist} 0%, ${colors.accentEnumeristLight} 100%)`;\n    case \"names\":\n      return `linear-gradient(135deg, ${colors.accentNameForge} 0%, ${colors.accentNameForgeLight} 100%)`;\n    case \"cosmography\":\n      return `linear-gradient(135deg, ${colors.accentCosmographer} 0%, ${colors.accentCosmographerLight} 100%)`;\n    case \"coherence\":\n      return `linear-gradient(135deg, ${colors.accentCoherence} 0%, ${colors.accentCoherenceLight} 100%)`;\n    case \"simulation\":\n      return `linear-gradient(135deg, ${colors.accentSimulation} 0%, ${colors.accentSimulationLight} 100%)`;\n    case \"illuminator\":\n      return `linear-gradient(135deg, ${colors.accentIlluminator} 0%, ${colors.accentIlluminatorLight} 100%)`;\n    case \"archivist\":\n      return `linear-gradient(135deg, ${colors.accentArchivist} 0%, ${colors.accentArchivistLight} 100%)`;\n    case \"chronicler\":\n      return `linear-gradient(135deg, ${colors.accentChronicler} 0%, ${colors.accentChroniclerLight} 100%)`;\n    default:\n      return `linear-gradient(135deg, ${colors.accent} 0%, ${colors.accentLight} 100%)`;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/theme.js::getHoverBg", "name": "getHoverBg", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get hover background for current app\nexport function getHoverBg(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"names\":\n      return \"rgba(251, 191, 36, 0.15)\";\n    case \"cosmography\":\n      return \"rgba(96, 165, 250, 0.15)\";\n    case \"coherence\":\n      return \"rgba(245, 158, 11, 0.15)\";\n    case \"simulation\":\n      return \"rgba(167, 139, 250, 0.15)\";\n    case \"illuminator\":\n      return \"rgba(168, 85, 247, 0.15)\";\n    case \"archivist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"chronicler\":\n      return \"rgba(16, 185, 129, 0.15)\";\n    default:\n      return colors.hoverBg;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsConfig", "name": "loadAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsConfig() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(CONFIG_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsConfig", "name": "saveAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsConfig(config) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!config) {\n    localStorage.removeItem(CONFIG_KEY);\n    return;\n  }\n  localStorage.setItem(CONFIG_KEY, JSON.stringify(config));\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsTokens", "name": "loadAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsTokens() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(TOKEN_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsTokens", "name": "saveAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsTokens(tokens) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!tokens) {\n    localStorage.removeItem(TOKEN_KEY);\n    return;\n  }\n  localStorage.setItem(TOKEN_KEY, JSON.stringify(tokens));\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::clearAwsTokens", "name": "clearAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function clearAwsTokens() {\n  if (typeof localStorage === \"undefined\") return;\n  localStorage.removeItem(TOKEN_KEY);\n}", "parameters": [], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::isTokenValid", "name": "isTokenValid", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function isTokenValid(tokens) {\n  if (!tokens?.idToken) return false;\n  if (!tokens.expiresAt) return true;\n  return Date.now() < tokens.expiresAt - 30_000;\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "boolean"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildImageStorageConfig", "name": "buildImageStorageConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildImageStorageConfig(config, projectId) {\n  if (!config?.imageBucket) return null;\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  return {\n    provider: \"s3\",\n    bucket: config.imageBucket.trim(),\n    region: config.region?.trim() || \"us-east-1\",\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    projectId,\n  };\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "projectId", "type": "any", "optional": false}], "returnType": "{ provider: string; bucket: any; region: any; basePrefix: any; rawPrefix: string; webpPrefix: string; thumbPrefix: string; projectId: any; }"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::createS3Client", "name": "createS3Client", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function createS3Client(config, tokens) {\n  if (!config?.identityPoolId || !config?.region) return null;\n  const region = config.region.trim();\n  const identityPoolId = config.identityPoolId.trim();\n  const logins = {};\n  const userPoolId = config.cognitoUserPoolId?.trim();\n  if (tokens?.idToken && userPoolId) {\n    const loginKey = `cognito-idp.${region}.amazonaws.com/${userPoolId}`;\n    logins[loginKey] = tokens.idToken;\n  }\n\n  return new S3Client({\n    region,\n    credentials: fromCognitoIdentityPool({\n      clientConfig: { region },\n      identityPoolId,\n      logins: Object.keys(logins).length ? logins : undefined,\n    }),\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "tokens", "type": "any", "optional": false}], "returnType": "S3Client"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::loadImageManifest", "name": "loadImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function loadImageManifest(s3, { bucket, basePrefix }) {\n  if (!s3 || !bucket) return null;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  try {\n    const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n    const text = await readBodyAsText(response.Body);\n    if (!text) return null;\n    return JSON.parse(text);\n  } catch (err) {\n    if (err?.name === \"NoSuchKey\" || err?.$metadata?.httpStatusCode === 404) {\n      return null;\n    }\n    console.warn(\"Failed to load image manifest:\", err);\n    return null;\n  }\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::saveImageManifest", "name": "saveImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function saveImageManifest(s3, { bucket, basePrefix }, manifest) {\n  if (!s3 || !bucket) return;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  const body = JSON.stringify(manifest, null, 2);\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}, {"name": "manifest", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::listS3Prefixes", "name": "listS3Prefixes", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function listS3Prefixes(s3, { bucket, prefix }) {\n  if (!s3 || !bucket) return [];\n  const response = await s3.send(\n    new ListObjectsV2Command({\n      Bucket: bucket,\n      Prefix: prefix || undefined,\n      Delimiter: \"/\",\n      MaxKeys: 200,\n    })\n  );\n  return (response.CommonPrefixes || []).map((item) => item.Prefix).filter(Boolean);\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, prefix }", "type": "{ bucket: any; prefix: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::getS3ImageUploadPlan", "name": "getS3ImageUploadPlan", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function getS3ImageUploadPlan({ projectId, s3, config, repairSizes = false }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const manifestFromS3 = await loadImageManifest(s3, { bucket, basePrefix });\n  const manifest = manifestFromS3 || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  const candidates = [];\n  const repairs = { attempted: 0, updated: 0, skipped: 0, failed: 0 };\n  const manifestRepairs = { updated: 0, skipped: 0, failed: 0 };\n  const canRepairManifest = Boolean(repairSizes && manifestFromS3);\n  let manifestChanged = false;\n  let db = null;\n\n  try {\n    if (repairSizes) {\n      db = await openIlluminatorDb();\n    }\n\n    for (const image of images) {\n      if (!image?.imageId) continue;\n      const updatedAt = image.savedAt || image.generatedAt || 0;\n      const entry = existing[image.imageId];\n      const rawSize = image.size;\n      const normalizedSize = normalizeImageSize(rawSize);\n\n      let { effectiveSize, sizeSource, needsBlob } = resolveEffectiveSize(\n        image, entry, updatedAt, normalizedSize, repairSizes\n      );\n      let blob = null;\n\n      if (needsBlob) {\n        blob = await getImageBlob(image.imageId);\n        ({ effectiveSize, sizeSource } = applyBlobSize(blob, effectiveSize, sizeSource));\n      }\n\n      if (canRepairManifest && entry && entry.updatedAt >= updatedAt) {\n        if (repairManifestEntry(entry, updatedAt, effectiveSize, manifestRepairs)) {\n          manifestChanged = true;\n        }\n      }\n\n      if (repairSizes && blob && effectiveSize != null && effectiveSize !== normalizedSize) {\n        await repairImageSize(db, image.imageId, effectiveSize, repairs);\n      }\n\n      const reasons = collectUploadReasons(entry, updatedAt, effectiveSize);\n      if (!reasons.length) continue;\n\n      candidates.push({\n        imageId: image.imageId,\n        entityId: image.entityId || null,\n        entityName: image.entityName || null,\n        imageType: image.imageType || \"entity\",\n        updatedAt,\n        size: rawSize ?? null,\n        effectiveSize,\n        sizeSource,\n        manifestUpdatedAt: entry?.updatedAt ?? null,\n        manifestSize: entry?.size ?? null,\n        reason: reasons.join(\"+\"),\n      });\n    }\n  } finally {\n    if (db) {\n      db.close();\n    }\n  }\n\n  if (canRepairManifest && manifestChanged) {\n    manifest.generatedAt = new Date().toISOString();\n    manifest.count = Object.keys(existing).length;\n    await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n  }\n\n  return {\n    total: images.length,\n    candidates,\n    manifestFound: Boolean(manifestFromS3),\n    basePrefix,\n    repairs: repairSizes ? repairs : null,\n    manifestRepairs: canRepairManifest ? manifestRepairs : null,\n  };\n}", "parameters": [{"name": "{ projectId, s3, config, repairSizes = false }", "type": "{ projectId: any; s3: any; config: any; repairSizes?: boolean; }", "optional": false}], "returnType": "Promise<{ total: any; candidates: { imageId: any; entityId: any; entityName: any; imageType: any; updatedAt: any; size: any; effectiveSize: any; sizeSource: string; manifestUpdatedAt: any; manifestSize: any; reason: string; }[]; manifestFound: boolean; basePrefix: any; repairs: { attempted: number; updated: number; skipped: number; failed: number; }; manifestRepairs: { updated: number; skipped: number; failed: number; }; }>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::syncProjectImagesToS3", "name": "syncProjectImagesToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function syncProjectImagesToS3({ projectId, s3, config, onProgress }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const rawPrefix = DEFAULT_RAW_PREFIX;\n  const manifest = (await loadImageManifest(s3, { bucket, basePrefix })) || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  let processed = 0;\n  let uploaded = 0;\n  const total = images.length;\n\n  for (const image of images) {\n    if (!image?.imageId) continue;\n    processed += 1;\n    if (onProgress) {\n      onProgress({ phase: \"scan\", processed, total, uploaded });\n    }\n\n    const updatedAt = image.savedAt || image.generatedAt || 0;\n    const entry = existing[image.imageId];\n    const normalizedSize = normalizeImageSize(image.size);\n\n    let blob = null;\n    if (entry && entry.updatedAt >= updatedAt && normalizedSize == null) {\n      blob = await getImageBlob(image.imageId);\n    }\n\n    if (shouldSkipSyncImage(entry, updatedAt, normalizedSize, blob)) continue;\n\n    if (!blob) {\n      blob = await getImageBlob(image.imageId);\n      if (!blob) continue;\n    }\n\n    const buffer = await blob.arrayBuffer();\n    const body = new Uint8Array(buffer);\n    const contentLength = body.byteLength;\n\n    const rawKey = toS3Key(basePrefix, rawPrefix, projectId, image.imageId);\n    const tagging = buildTagging({ ...image, projectId, savedAt: updatedAt });\n\n    await s3.send(\n      new PutObjectCommand({\n        Bucket: bucket,\n        Key: rawKey,\n        Body: body,\n        ContentType: image.mimeType || blob.type || \"application/octet-stream\",\n        ContentLength: contentLength,\n        Tagging: tagging,\n        CacheControl: \"public, max-age=31536000, immutable\",\n      })\n    );\n\n    existing[image.imageId] = buildManifestEntry(\n      image, projectId, rawKey, blob, normalizedSize, contentLength, updatedAt\n    );\n\n    uploaded += 1;\n    if (onProgress) {\n      onProgress({ phase: \"upload\", processed, total, uploaded });\n    }\n  }\n\n  manifest.images = existing;\n  manifest.generatedAt = new Date().toISOString();\n  manifest.count = Object.keys(existing).length;\n  await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n\n  return { total, uploaded, manifest };\n}", "parameters": [{"name": "{ projectId, s3, config, onProgress }", "type": "{ projectId: any; s3: any; config: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: any; uploaded: number; manifest: any; }>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildStorageImageUrl", "name": "buildStorageImageUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildStorageImageUrl(storage, variant, imageId) {\n  if (!storage || !imageId) return null;\n  const basePrefix = storage.basePrefix || \"\";\n  const projectId = storage.projectId || \"\";\n  let prefix;\n  if (variant === \"raw\") {\n    prefix = storage.rawPrefix;\n  } else if (variant === \"thumb\") {\n    prefix = storage.thumbPrefix;\n  } else {\n    prefix = storage.webpPrefix;\n  }\n  const filename = variant === \"raw\" ? imageId : `${imageId}.webp`;\n  const path = toS3Key(basePrefix, prefix, projectId, filename);\n  return `/${path}`;\n}", "parameters": [{"name": "storage", "type": "any", "optional": false}, {"name": "variant", "type": "any", "optional": false}, {"name": "imageId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::extractCognitoTokensFromUrl", "name": "extractCognitoTokensFromUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function extractCognitoTokensFromUrl() {\n  if (typeof window === \"undefined\") return null;\n  const params = parseHashParams(window.location.hash || \"\");\n  if (!params.id_token) return null;\n  const expiresIn = Number(params.expires_in || 0);\n  const expiresAt = expiresIn ? Date.now() + expiresIn * 1000 : null;\n  return {\n    idToken: params.id_token,\n    accessToken: params.access_token || null,\n    tokenType: params.token_type || null,\n    expiresAt,\n  };\n}", "parameters": [], "returnType": "{ idToken: any; accessToken: any; tokenType: any; expiresAt: number; }"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::clearCognitoHash", "name": "clearCognitoHash", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function clearCognitoHash() {\n  if (typeof window === \"undefined\") return;\n  if (window.location.hash) {\n    history.replaceState(null, document.title, window.location.pathname + window.location.search);\n  }\n}", "parameters": [], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLoginUrl", "name": "buildHostedUiLoginUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLoginUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const scope = config?.cognitoScope?.trim() || \"openid email profile\";\n  const params = new URLSearchParams({\n    client_id: clientId,\n    response_type: \"token\",\n    scope,\n    redirect_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/login?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLogoutUrl", "name": "buildHostedUiLogoutUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLogoutUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const params = new URLSearchParams({\n    client_id: clientId,\n    logout_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/logout?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signInWithUserPool", "name": "signInWithUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function signInWithUserPool({ username, password, config }) {\n  const authenticationDetails = new AuthenticationDetails({\n    Username: username,\n    Password: password,\n  });\n\n  const user = new CognitoUser({\n    Username: username,\n    Pool: getUserPool(config),\n  });\n\n  return new Promise((resolve, reject) => {\n    user.authenticateUser(authenticationDetails, {\n      onSuccess: (session) => resolve(session),\n      onFailure: (error) => reject(error),\n    });\n  });\n}", "parameters": [{"name": "{ username, password, config }", "type": "{ username: any; password: any; config: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::getUserPoolSession", "name": "getUserPoolSession", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function getUserPoolSession(config) {\n  const user = getCurrentUser(config);\n  if (!user) return null;\n  return new Promise((resolve) => {\n    user.getSession((error, session) => {\n      if (error || !session) {\n        resolve(null);\n        return;\n      }\n      resolve(session);\n    });\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signOutUserPool", "name": "signOutUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function signOutUserPool(config) {\n  const user = getCurrentUser(config);\n  user?.signOut();\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::sessionToTokens", "name": "sessionToTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function sessionToTokens(session) {\n  if (!session) return null;\n  const idToken = session.getIdToken().getJwtToken();\n  const accessToken = session.getAccessToken().getJwtToken();\n  const expiresAt = session.getIdToken().getExpiration() * 1000;\n  return {\n    idToken,\n    accessToken,\n    tokenType: \"Bearer\",\n    expiresAt,\n  };\n}", "parameters": [{"name": "session", "type": "any", "optional": false}], "returnType": "{ idToken: any; accessToken: any; tokenType: string; expiresAt: number; }"}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::exportIndexedDbToS3", "name": "exportIndexedDbToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function exportIndexedDbToS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/export] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Enumerating databases...\");\n  const dbList = await indexedDB.databases();\n  if (!dbList || dbList.length === 0) {\n    throw new Error(\"No IndexedDB databases found\");\n  }\n\n  const snapshot = {\n    format: \"canonry-indexeddb-snapshot\",\n    version: 1,\n    exportedAt: new Date().toISOString(),\n    databases: {},\n  };\n\n  for (let i = 0; i < dbList.length; i++) {\n    const { name, version } = dbList[i];\n    if (!name) continue;\n    report(`Exporting ${name} v${version} (${i + 1}/${dbList.length})...`);\n\n    const dbSnapshot = await exportSingleDatabase(name, version);\n    if (dbSnapshot) {\n      snapshot.databases[name] = dbSnapshot;\n    }\n  }\n\n  report(\"Uploading to S3...\");\n  const body = JSON.stringify(snapshot);\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n\n  const sizeMb = (body.length / (1024 * 1024)).toFixed(1);\n  const dbCount = Object.keys(snapshot.databases).length;\n  const storeCount = Object.values(snapshot.databases).reduce(\n    (sum, db) => sum + Object.keys(db.stores).length,\n    0\n  );\n\n  console.log(`[snapshot/export] Done: ${dbCount} databases, ${storeCount} stores, ${sizeMb} MB`);\n\n  return {\n    size: body.length,\n    sizeMb,\n    dbCount,\n    storeCount,\n    key,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ size: number; sizeMb: string; dbCount: number; storeCount: any; key: string; }>"}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::importIndexedDbFromS3", "name": "importIndexedDbFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function importIndexedDbFromS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/import] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Downloading snapshot from S3...\");\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n  const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n  const text = await readS3BodyAsText(response.Body);\n  if (!text) throw new Error(\"Empty snapshot file\");\n\n  report(`Parsing snapshot (${(text.length / (1024 * 1024)).toFixed(1)} MB)...`);\n  const snapshot = JSON.parse(text);\n  if (snapshot.format !== \"canonry-indexeddb-snapshot\") {\n    throw new Error(`Unknown snapshot format: ${snapshot.format}`);\n  }\n\n  const existingDbs = await getExistingDatabases();\n  const dbNames = Object.keys(snapshot.databases);\n  console.log(\n    `[snapshot/import] Snapshot from ${snapshot.exportedAt}, ${dbNames.length} databases: [${dbNames.join(\", \")}]. Local: [${Array.from(existingDbs.keys()).join(\", \")}]`\n  );\n\n  const warnings = [];\n  let totalStoresRestored = 0;\n  let totalRecordsWritten = 0;\n\n  for (let i = 0; i < dbNames.length; i++) {\n    const name = dbNames[i];\n    const dbSnapshot = snapshot.databases[name];\n    const snapshotStoreNames = Object.keys(dbSnapshot.stores);\n\n    report(\n      `Restoring ${name} v${dbSnapshot.version} (${i + 1}/${dbNames.length}) \u2014 ${snapshotStoreNames.length} stores [${snapshotStoreNames.join(\", \")}]`\n    );\n\n    let db;\n    try {\n      db = await openDatabaseForImport(name, dbSnapshot, existingDbs);\n    } catch (err) {\n      const msg = `Failed to open \"${name}\" for import: ${err.message}`;\n      console.error(`[snapshot/import] ${msg}`);\n      warnings.push(msg);\n      continue;\n    }\n\n    const { storesRestored, recordsWritten } = await restoreStoresFromSnapshot(\n      db, name, dbSnapshot, warnings\n    );\n    totalStoresRestored += storesRestored;\n    totalRecordsWritten += recordsWritten;\n\n    db.close();\n    console.log(`[snapshot/import] \"${name}\" done`);\n  }\n\n  console.log(\n    `[snapshot/import] Import complete: ${totalStoresRestored} stores, ${totalRecordsWritten} records`\n  );\n  if (warnings.length) {\n    console.warn(`[snapshot/import] Warnings (${warnings.length}):`, warnings);\n  }\n\n  return {\n    exportedAt: snapshot.exportedAt,\n    dbCount: dbNames.length,\n    storeCount: totalStoresRestored,\n    recordCount: totalRecordsWritten,\n    warnings,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ exportedAt: any; dbCount: number; storeCount: number; recordCount: number; warnings: string[]; }>"}, {"id": "apps/canonry/webui/src/aws/s3ImagePull.js::pullImagesFromS3", "name": "pullImagesFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/s3ImagePull.js", "sourceCode": "export async function pullImagesFromS3({ s3, config, projectId, onProgress }) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[s3-pull] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  // 1. Load manifest (read-only \u2014 never written back)\n  report(\"Loading image manifest from S3...\");\n  const manifest = await loadImageManifest(s3, { bucket, basePrefix });\n  if (!manifest || !manifest.images) {\n    throw new Error('No image manifest found in S3. Push images first with \"Sync Images to S3\".');\n  }\n\n  const allEntries = Object.values(manifest.images);\n  // Filter to requested project if provided\n  const entries = projectId ? allEntries.filter((e) => e.projectId === projectId) : allEntries;\n\n  const projectScope = projectId ? ` for project ${projectId}` : \" (all projects)\";\n  report(\n    `Manifest has ${entries.length} images${projectScope}. Checking local state...`\n  );\n\n  // 2. Check what exists locally\n  const db = await openIlluminatorDb();\n  let localBlobIds;\n  let localImageIds;\n  try {\n    localBlobIds = await getLocalBlobIds(db);\n    localImageIds = await getLocalImageIds(db);\n  } catch (err) {\n    db.close();\n    throw err;\n  }\n\n  // 3. Compute what needs downloading\n  const missing = entries.filter((e) => !localBlobIds.has(e.imageId));\n  const total = entries.length;\n  const skippedCount = total - missing.length;\n\n  report(`${missing.length} to download, ${skippedCount} already local`);\n\n  if (missing.length === 0) {\n    db.close();\n    return { total, downloaded: 0, skipped: skippedCount, errors: 0 };\n  }\n\n  // 4. Download incrementally\n  let downloaded = 0;\n  let errors = 0;\n  const logInterval = Math.max(1, Math.floor(missing.length / 5));\n\n  for (let i = 0; i < missing.length; i++) {\n    const entry = missing[i];\n\n    if (i % logInterval === 0) {\n      report(`Downloading ${i + 1}/${missing.length}...`);\n    }\n\n    try {\n      const response = await s3.send(\n        new GetObjectCommand({\n          Bucket: bucket,\n          Key: entry.rawKey,\n        })\n      );\n\n      const blob = await readBodyAsBlob(response.Body, entry.mimeType);\n\n      // Write blob, and metadata if missing locally\n      const needsMetadata = !localImageIds.has(entry.imageId);\n      const metadata = needsMetadata ? manifestEntryToMetadata(entry) : null;\n\n      await writeImageToDb(db, entry.imageId, blob, metadata);\n      downloaded++;\n    } catch (err) {\n      errors++;\n      console.error(\n        `[s3-pull] Failed to download \"${entry.imageId}\" (key=${entry.rawKey}):`,\n        err.message\n      );\n    }\n  }\n\n  db.close();\n\n  const summary = `Done: ${downloaded} downloaded, ${skippedCount} already local, ${errors} errors`;\n  report(summary);\n\n  return { total, downloaded, skipped: skippedCount, errors };\n}", "parameters": [{"name": "{ s3, config, projectId, onProgress }", "type": "{ s3: any; config: any; projectId: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: number; downloaded: number; skipped: number; errors: number; }>"}, {"id": "apps/canonry/webui/src/components/HelpModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/HelpModal.jsx", "sourceCode": "export default function HelpModal({ isOpen, onClose, activeTab }) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const content = HELP_CONTENT[activeTab] || HELP_CONTENT.enumerist;\n\n  return (\n    <div\n      className=\"modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"modal help-modal\">\n        <div className=\"modal-header\">\n          <div className=\"modal-title hm-title-colored\" style={{ '--hm-title-color': content.color }}>\n            {content.title}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n        <div className=\"modal-body modal-body-single\">\n          {/* Description */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">What is this?</h3>\n            <p className=\"help-text\">{content.description}</p>\n          </div>\n\n          {/* Workflow */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">Workflow</h3>\n            {content.workflow.map((step, index) => (\n              <div key={index} className=\"workflow-step\">\n                <div className=\"workflow-step-header\">\n                  <div className=\"workflow-step-number hm-step-number-colored\" style={{ '--hm-step-bg': content.color }}>\n                    {index + 1}\n                  </div>\n                  <div className=\"workflow-step-title\">{step.title}</div>\n                </div>\n                <p className=\"workflow-step-desc\">{step.desc}</p>\n                <ul className=\"workflow-step-list\">\n                  {step.items.map((item, i) => (\n                    <li key={i}>{item}</li>\n                  ))}\n                </ul>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, activeTab }", "type": "{ isOpen: any; onClose: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/LandingPage.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/LandingPage.jsx", "sourceCode": "export default function LandingPage({ onNavigate, hasProject }) {\n  return (\n    <div className=\"lp-container\">\n      {/* Hero Section */}\n      <div className=\"lp-hero\">\n        <h1 className=\"lp-title\">Welcome to The Canonry</h1>\n        <p className=\"lp-subtitle\">\n          A unified suite for procedural world-building. Define your schema, configure naming\n          systems, place entities on semantic planes, and generate interconnected histories.\n        </p>\n        <p className=\"lp-tagline\">Yes, this is probably overkill. No, we&apos;re not sorry.</p>\n      </div>\n\n      {/* App Cards */}\n      <div className=\"lp-cards-grid\">\n        {APP_CARDS.map((app) => (\n          <AppCard key={app.id} app={app} onNavigate={onNavigate} hasProject={hasProject} />\n        ))}\n      </div>\n\n      {/* Footer */}\n      <div className=\"lp-footer\">\n        <h2 className=\"lp-footer-title\">Get Started</h2>\n        <p className=\"lp-footer-text\">\n          {hasProject\n            ? \"Click on any card above to start working with your project.\"\n            : \"Create a new project or open an existing one using the project selector above.\"}\n        </p>\n        <p className=\"lp-footer-hint\">\n          Projects are stored locally in your browser. Use Export to create backups.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onNavigate, hasProject }", "type": "{ onNavigate: any; hasProject: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/Navigation.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/Navigation.jsx", "sourceCode": "export default function Navigation({ activeTab, onTabChange, onHelpClick, onAwsClick }) {\n  const getTabClassName = (tab) => {\n    if (!tab.enabled) {\n      return \"nav-tab nav-tab-disabled\";\n    }\n    if (tab.id === activeTab) {\n      return \"nav-tab nav-tab-active\";\n    }\n    return \"nav-tab nav-tab-inactive\";\n  };\n\n  const getTabDynamicStyle = (tab) => {\n    if (tab.id === activeTab && tab.enabled) {\n      return {\n        '--nav-tab-bg': getAccentGradient(tab.id),\n        '--nav-tab-color': colors.bgSidebar,\n      };\n    }\n    return undefined;\n  };\n\n  return (\n    <nav className=\"nav-bar\">\n      <div className=\"nav-tabs-container\">\n        {TABS.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => tab.enabled && onTabChange(tab.id)}\n            className={getTabClassName(tab)}\n            style={getTabDynamicStyle(tab)}\n            disabled={!tab.enabled}\n            onMouseEnter={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = getHoverBg(tab.id);\n                e.target.style.color = getAccentColor(tab.id);\n              }\n            }}\n            onMouseLeave={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = \"transparent\";\n                e.target.style.color = colors.textSecondary;\n              }\n            }}\n          >\n            {tab.label}\n            {tab.badge && <span className=\"nav-badge\">{tab.badge}</span>}\n          </button>\n        ))}\n      </div>\n      <button\n        className=\"nav-help-button\"\n        onClick={onAwsClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"AWS & S3 Sync\"\n      >\n        AWS\n      </button>\n      <button\n        className=\"nav-help-button\"\n        onClick={onHelpClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"Help & Workflow Guide\"\n      >\n        ? Help\n      </button>\n    </nav>\n  );\n}", "parameters": [{"name": "{ activeTab, onTabChange, onHelpClick, onAwsClick }", "type": "{ activeTab: any; onTabChange: any; onHelpClick: any; onAwsClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/ProjectManager.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ProjectManager.jsx", "sourceCode": "export default function ProjectManager({\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [showNewModal, setShowNewModal] = useState(false);\n  const [newProjectName, setNewProjectName] = useState(\"\");\n  const dropdownRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowNewModal(false);\n    }\n  }, []);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  const handleCreate = () => {\n    if (newProjectName.trim()) {\n      onCreateProject(newProjectName.trim());\n      setNewProjectName(\"\");\n      setShowNewModal(false);\n      setShowDropdown(false);\n    }\n  };\n\n  const handleImport = async (e) => {\n    const file = e.target.files?.[0];\n    if (!file) return;\n\n    try {\n      // Require zip file imports\n      if (!file.name.endsWith(\".zip\") && file.type !== \"application/zip\") {\n        throw new Error(\"Unsupported file type. Import requires a .zip project export.\");\n      }\n      await onImportProject(file);\n      setShowDropdown(false);\n    } catch (err) {\n      alert(\"Failed to import: \" + err.message);\n    }\n    e.target.value = \"\";\n  };\n\n  const handleExport = async () => {\n    try {\n      const zipBlob = await onExportProject();\n      if (!zipBlob) return;\n\n      const url = URL.createObjectURL(zipBlob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${currentProject?.name || \"world\"}.canonry.zip`;\n      a.click();\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      alert(\"Failed to export: \" + err.message);\n    }\n  };\n\n  const formatDate = (dateString) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <header className=\"app-header\">\n      <div className=\"app-header-left\">\n        <div className=\"app-logo\" onClick={onGoHome} title=\"Go to home\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onGoHome(e); }} >\n          The Canonry\n        </div>\n\n        <div className=\"project-selector\" ref={dropdownRef}>\n          <button\n            className=\"project-selector-trigger\"\n            onClick={() => setShowDropdown(!showDropdown)}\n          >\n            <span className=\"project-selector-name\">\n              {currentProject?.name || \"Select Project\"}\n            </span>\n            <span className=\"project-selector-chevron\">{showDropdown ? \"\u25b2\" : \"\u25bc\"}</span>\n          </button>\n\n          {showDropdown && (\n            <div className=\"project-dropdown\">\n              <div className=\"project-dropdown-header\">\n                <span className=\"project-dropdown-title\">Projects</span>\n                <div className=\"project-dropdown-actions\">\n                  <button\n                    className=\"btn-sm btn-sm-primary\"\n                    onClick={() => {\n                      setShowDropdown(false);\n                      setShowNewModal(true);\n                    }}\n                  >\n                    + New\n                  </button>\n                  <button className=\"btn-sm\" onClick={() => fileInputRef.current?.click()}>\n                    Import\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"project-list\">\n                {projects.length === 0 ? (\n                  <div className=\"empty-state-compact\">\n                    No projects yet. Create one to get started!\n                  </div>\n                ) : (\n                  projects.map((project) => (\n                    <div\n                      key={project.id}\n                      className={[\"project-item\", currentProject?.id === project.id ? \"project-item-active\" : \"\"].join(\" \").trim()}\n                      onClick={() => {\n                        onOpenProject(project.id);\n                        setShowDropdown(false);\n                      }}\n                      onMouseEnter={() => setHoveredProject(project.id)}\n                      onMouseLeave={() => setHoveredProject(null)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <div className=\"project-item-name\">{project.name}</div>\n                      <div className=\"project-item-meta\">\n                        <span>{project.entityCount} entities</span>\n                        <span>{project.cultureCount} cultures</span>\n                        <span>{formatDate(project.updatedAt)}</span>\n                      </div>\n                      <div className=\"project-item-actions\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                        {project.id === defaultProjectId && onReloadFromDefaults && (\n                          <button\n                            className=\"btn-xs\"\n                            onClick={async () => {\n                              if (\n                                confirm(\n                                  \"Reload project from defaults? This will overwrite your configuration changes but preserve world data.\"\n                                )\n                              ) {\n                                try {\n                                  await onReloadFromDefaults();\n                                  setShowDropdown(false);\n                                } catch (err) {\n                                  alert(\"Failed to reload: \" + err.message);\n                                }\n                              }\n                            }}\n                          >\n                            Reload Defaults\n                          </button>\n                        )}\n                        <button className=\"btn-xs\" onClick={() => onDuplicateProject(project.id)}>\n                          Duplicate\n                        </button>\n                        <button\n                          className=\"btn-xs btn-xs-danger\"\n                          onClick={() => {\n                            if (confirm(`Delete \"${project.name}\"?`)) {\n                              onDeleteProject(project.id);\n                            }\n                          }}\n                        >\n                          Delete\n                        </button>\n                      </div>\n                    </div>\n                  ))\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        {currentProject && onLoadSlot && (\n          <SlotSelector\n            slots={slots}\n            activeSlotIndex={activeSlotIndex}\n            onLoadSlot={onLoadSlot}\n            onSaveToSlot={onSaveToSlot}\n            onClearSlot={onClearSlot}\n            onUpdateTitle={onUpdateSlotTitle}\n            onExportSlot={onExportSlot}\n            onImportSlot={onImportSlot}\n            onLoadExampleOutput={onLoadExampleOutput}\n            hasDataInScratch={hasDataInScratch}\n          />\n        )}\n      </div>\n\n      <div className=\"app-header-right\">\n        {currentProject && <TracePopover simulationState={simulationState} systems={systems} />}\n        {currentProject && (\n          <ValidationPopover\n            validationResult={validationResult}\n            onNavigateToValidation={onNavigateToValidation}\n            onRemoveProperty={onRemoveProperty}\n          />\n        )}\n        <button className=\"btn btn-secondary\" onClick={handleExport} disabled={!currentProject}>\n          Export\n        </button>\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\".zip\"\n          className=\"pm-hidden-input\"\n          onChange={handleImport}\n        />\n      </div>\n\n      {showNewModal && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal modal-simple\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Create New Project</div>\n              <button className=\"btn-close\" onClick={() => setShowNewModal(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"modal-body\">\n              {/* eslint-disable-next-line jsx-a11y/no-autofocus -- intentional UX: modal input should auto-focus */}\n              <input\n                className=\"input\"\n                type=\"text\"\n                placeholder=\"Project name...\"\n                value={newProjectName}\n                onChange={(e) => setNewProjectName(e.target.value)}\n                onKeyDown={(e) => e.key === \"Enter\" && handleCreate()}\n                autoFocus\n              />\n              <div className=\"modal-actions\">\n                <button className=\"btn btn-secondary\" onClick={() => setShowNewModal(false)}>\n                  Cancel\n                </button>\n                <button className=\"btn btn-primary\" onClick={handleCreate}>\n                  Create\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </header>\n  );\n}", "parameters": [{"name": "{\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}", "type": "{ projects: any; currentProject: any; onCreateProject: any; onOpenProject: any; onDeleteProject: any; onDuplicateProject: any; onExportProject: any; onImportProject: any; onReloadFromDefaults: any; defaultProjectId: any; onGoHome: any; validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; simulationState: any; systems?: any[]; slots?: Readonly<{}>; activeSlotIndex?: number; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateSlotTitle: any; onExportSlot: any; on...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SlotSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SlotSelector.jsx", "sourceCode": "export default function SlotSelector({\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [editingSlot, setEditingSlot] = useState(null);\n  const [editValue, setEditValue] = useState(\"\");\n  const [importTargetSlot, setImportTargetSlot] = useState(null);\n  const dropdownRef = useRef(null);\n  const inputRef = useRef(null);\n  const fileInputRef = useRef(null);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n        setEditingSlot(null);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  // Focus input when editing starts\n  useEffect(() => {\n    if (editingSlot !== null && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [editingSlot]);\n\n  const handleStartEdit = useCallback((slotIndex, currentTitle, e) => {\n    e.stopPropagation();\n    setEditingSlot(slotIndex);\n    setEditValue(currentTitle || \"\");\n  }, []);\n\n  const handleSaveEdit = useCallback(() => {\n    if (editingSlot !== null && editValue.trim()) {\n      onUpdateTitle(editingSlot, editValue.trim());\n    }\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, [editingSlot, editValue, onUpdateTitle]);\n\n  const handleCancelEdit = useCallback(() => {\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Enter\") {\n        handleSaveEdit();\n      } else if (e.key === \"Escape\") {\n        handleCancelEdit();\n      }\n    },\n    [handleSaveEdit, handleCancelEdit]\n  );\n\n  const handleImportRequest = useCallback(\n    (slotIndex) => {\n      if (!onImportSlot) return;\n      const slot = slots[slotIndex];\n      const slotTitle = slot?.title || (slotIndex === 0 ? \"Scratch\" : `Slot ${slotIndex}`);\n      if (slot && !window.confirm(`Overwrite \"${slotTitle}\" with imported data?`)) {\n        return;\n      }\n      setImportTargetSlot(slotIndex);\n      fileInputRef.current?.click();\n    },\n    [onImportSlot, slots]\n  );\n\n  const handleImportFile = useCallback(\n    (e) => {\n      const file = e.target.files?.[0];\n      if (!file || importTargetSlot === null || !onImportSlot) {\n        e.target.value = \"\";\n        return;\n      }\n      onImportSlot(importTargetSlot, file);\n      setImportTargetSlot(null);\n      setShowDropdown(false);\n      e.target.value = \"\";\n    },\n    [importTargetSlot, onImportSlot]\n  );\n\n  // Get active slot data for display\n  const activeSlot = slots[activeSlotIndex];\n  const activeTitle =\n    activeSlotIndex === 0\n      ? activeSlot?.title || \"Scratch\"\n      : activeSlot?.title || `Slot ${activeSlotIndex}`;\n\n  // Determine which slots to show:\n  // - Always show slot 0 (scratch)\n  // - Show filled save slots\n  // - Show next empty slot if scratch has data\n  const visibleSlots = [0]; // Always show scratch\n  let nextEmptySlot = null;\n\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (slots[i]) {\n      visibleSlots.push(i);\n    } else if (nextEmptySlot === null) {\n      nextEmptySlot = i;\n    }\n  }\n\n  // Add next empty slot if scratch has data\n  if (hasDataInScratch && nextEmptySlot !== null) {\n    visibleSlots.push(nextEmptySlot);\n  }\n\n  return (\n    <div className=\"slot-selector\" ref={dropdownRef}>\n      <button className=\"slot-selector-trigger\" onClick={() => setShowDropdown(!showDropdown)}>\n        <span className=\"slot-selector-name\">{activeTitle}</span>\n        <span className=\"slot-selector-chevron\">{showDropdown ? \"\\u25B2\" : \"\\u25BC\"}</span>\n      </button>\n\n      {showDropdown && (\n        <div className=\"slot-dropdown\">\n          <div className=\"slot-dropdown-header\">\n            <span className=\"slot-dropdown-title\">Run Slots</span>\n          </div>\n\n          <div className=\"slot-list\">\n            {visibleSlots.map((slotIndex) => (\n              <SlotItem\n                key={slotIndex}\n                slotIndex={slotIndex}\n                slot={slots[slotIndex]}\n                isActive={slotIndex === activeSlotIndex}\n                editingSlot={editingSlot}\n                editValue={editValue}\n                setEditValue={setEditValue}\n                inputRef={inputRef}\n                handleKeyDown={handleKeyDown}\n                handleSaveEdit={handleSaveEdit}\n                handleStartEdit={handleStartEdit}\n                canExport={Boolean(onExportSlot && slots[slotIndex])}\n                canImport={Boolean(onImportSlot)}\n                hasDataInScratch={hasDataInScratch}\n                activeSlotIndex={activeSlotIndex}\n                onLoadSlot={onLoadSlot}\n                onSaveToSlot={onSaveToSlot}\n                onClearSlot={onClearSlot}\n                onExportSlot={onExportSlot}\n                handleImportRequest={handleImportRequest}\n                setShowDropdown={setShowDropdown}\n              />\n            ))}\n\n            {visibleSlots.length === 1 && !hasDataInScratch && (\n              <div className=\"slot-empty-hint\">\n                Run a simulation to create data, then save to a slot.\n              </div>\n            )}\n\n            {onLoadExampleOutput && (\n              <div className=\"slot-item slot-item-empty\">\n                <div className=\"slot-item-content\">\n                  <div className=\"slot-item-name\">Example Output</div>\n                  <div className=\"slot-item-meta\">Load a sample Lore Weave run.</div>\n                </div>\n                <div className=\"slot-item-actions\">\n                  <button\n                    className=\"btn-xs\"\n                    onClick={() => {\n                      if (\n                        hasDataInScratch &&\n                        !window.confirm(\"Overwrite scratch with the example output?\")\n                      ) {\n                        return;\n                      }\n                      onLoadExampleOutput();\n                      setShowDropdown(false);\n                    }}\n                  >\n                    Load\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\".json,.zip,application/json,application/zip\"\n        className=\"ss-hidden-input\"\n        onChange={handleImportFile}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}", "type": "{ slots: any; activeSlotIndex: any; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateTitle: any; onExportSlot: any; onImportSlot: any; onLoadExampleOutput: any; hasDataInScratch: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/TracePopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/TracePopover.jsx", "sourceCode": "export default function TracePopover({ simulationState }) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // Extract data from simulation state\n  const hasData = simulationState?.pressureUpdates?.length > 0;\n  const tickCount = simulationState?.pressureUpdates?.length || 0;\n  const templateCount = simulationState?.templateApplications?.length || 0;\n  const actionCount = simulationState?.actionApplications?.length || 0;\n  const eraTransitions = (simulationState?.systemActions || []).filter(\n    (a) => a.details?.eraTransition\n  ).length;\n\n  // Button label\n  const buttonLabel = useMemo(() => {\n    if (!hasData) return \"No trace\";\n    return `${tickCount} ticks`;\n  }, [hasData, tickCount]);\n\n  // Button class\n  const buttonClassName = useMemo(() => {\n    if (!hasData) {\n      return \"tp-button tp-button-disabled\";\n    }\n    return \"tp-button tp-button-active\";\n  }, [hasData]);\n\n  const loadingFallback = useMemo(\n    () => <div className=\"tp-loading-overlay\">Loading trace visualization...</div>,\n    []\n  );\n\n  const handleOpen = () => {\n    if (hasData) {\n      setIsOpen(true);\n    }\n  };\n  const handleClose = useCallback(() => setIsOpen(false), []);\n\n  return (\n    <>\n      <button\n        className={buttonClassName}\n        onClick={handleOpen}\n        disabled={!hasData}\n        title={\n          hasData\n            ? `View simulation trace: ${tickCount} ticks, ${templateCount} templates, ${actionCount} actions, ${eraTransitions} era transitions`\n            : \"Run a simulation to see trace data\"\n        }\n      >\n        <span className=\"tp-tilde\">~</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && hasData && (\n        <Suspense fallback={loadingFallback}>\n          <SimulationTraceVisx\n            pressureUpdates={simulationState.pressureUpdates}\n            epochStats={simulationState.epochStats}\n            templateApplications={simulationState.templateApplications}\n            actionApplications={simulationState.actionApplications}\n            systemActions={simulationState.systemActions}\n            onClose={handleClose}\n          />\n        </Suspense>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ simulationState }", "type": "{ simulationState: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/ValidationPopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ValidationPopover.jsx", "sourceCode": "export default function ValidationPopover({\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const popoverRef = useRef(null);\n\n  const { valid, errors, warnings } = validationResult || { valid: true, errors: [], warnings: [] };\n  const totalIssues = errors.length + warnings.length;\n\n  // Determine button class\n  const buttonClassName = useMemo(() => {\n    if (errors.length > 0) return \"vp-button vp-button-error\";\n    if (warnings.length > 0) return \"vp-button vp-button-warning\";\n    return \"vp-button vp-button-valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get button label\n  const buttonLabel = useMemo(() => {\n    if (errors.length > 0) return `${errors.length} error${errors.length !== 1 ? \"s\" : \"\"}`;\n    if (warnings.length > 0) return `${warnings.length} warning${warnings.length !== 1 ? \"s\" : \"\"}`;\n    return \"Valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get icon\n  const icon = useMemo(() => {\n    if (errors.length > 0) return \"\u2717\";\n    if (warnings.length > 0) return \"\u26a0\";\n    return \"\u2713\";\n  }, [errors.length, warnings.length]);\n\n  // Combined and limited list\n  const displayItems = useMemo(() => {\n    const items = [\n      ...errors.map((e) => ({ ...e, isWarning: false })),\n      ...warnings.map((w) => ({ ...w, isWarning: true })),\n    ];\n    return items.slice(0, MAX_ERRORS_SHOWN);\n  }, [errors, warnings]);\n\n  const remainingCount = totalIssues - displayItems.length;\n\n  const handleNavigate = () => {\n    setIsOpen(false);\n    onNavigateToValidation?.();\n  };\n\n  return (\n    <div className=\"vp-container\">\n      <button\n        className={buttonClassName}\n        onClick={() => setIsOpen(!isOpen)}\n        title={valid ? \"Configuration is valid\" : \"Click to see validation issues\"}\n      >\n        <span>{icon}</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && (\n        <div className=\"vp-popover\" ref={popoverRef}>\n          <div className=\"vp-popover-header\">\n            <span className=\"vp-popover-title\">Structure Validation</span>\n            <button className=\"vp-close-button\" onClick={() => setIsOpen(false)}>\n              \u00d7\n            </button>\n          </div>\n\n          <div className=\"vp-popover-body\">\n            {valid && warnings.length === 0 ? (\n              <div className=\"vp-valid-message\">\n                <span>\u2713</span>\n                <span>All configuration files are valid</span>\n              </div>\n            ) : (\n              <div className=\"vp-error-list\">\n                {displayItems.map((item, i) => (\n                  <ErrorCard\n                    key={i}\n                    error={item}\n                    isWarning={item.isWarning}\n                    onRemoveProperty={onRemoveProperty}\n                  />\n                ))}\n              </div>\n            )}\n          </div>\n\n          {remainingCount > 0 && (\n            <div className=\"vp-more-count\">\n              +{remainingCount} more issue{remainingCount !== 1 ? \"s\" : \"\"}.{\" \"}\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View all in Validation tab\n              </span>\n            </div>\n          )}\n\n          {totalIssues > 0 && remainingCount === 0 && onNavigateToValidation && (\n            <div className=\"vp-more-count\">\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View full details in Validation tab\n              </span>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}", "type": "{ validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/lib/illuminatorDbReader.js::openIlluminatorDb", "name": "openIlluminatorDb", "kind": "function", "filePath": "apps/canonry/webui/src/lib/illuminatorDbReader.js", "sourceCode": "export function openIlluminatorDb() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME);\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // If another connection triggers a version upgrade while we're\n      // still open, close immediately so we don't block it.\n      db.onversionchange = () => {\n        db.close();\n      };\n\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(request.error || new Error('Failed to open illuminator DB'));\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImagesByProject", "name": "getImagesByProject", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get all image metadata records for a project (no blobs).\n */\nexport async function getImagesByProject(projectId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const store = tx.objectStore('images');\n      const index = store.index('projectId');\n      const request = index.getAll(projectId);\n      request.onsuccess = () => resolve(request.result || []);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageMetadata", "name": "getImageMetadata", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get a single image metadata record by imageId (no blob).\n */\nexport async function getImageMetadata(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const request = tx.objectStore('images').get(imageId);\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get the raw blob for an image by imageId.\n */\nexport async function getImageBlob(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('imageBlobs', 'readonly');\n      const request = tx.objectStore('imageBlobs').get(imageId);\n      request.onsuccess = () => resolve(request.result?.blob || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/remotes/ArchivistHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ArchivistHost.jsx", "sourceCode": "export default function ArchivistHost({\n  projectId,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Archivist encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ArchivistRemote projectId={projectId} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex\n}", "type": "{ projectId: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx", "sourceCode": "export default function ChroniclerHost({\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Chronicler encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ChroniclerRemote projectId={projectId} activeSlotIndex={activeSlotIndex} requestedPageId={requestedPageId} onRequestedPageConsumed={onRequestedPageConsumed} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}", "type": "{ projectId: any; activeSlotIndex: any; requestedPageId: any; onRequestedPageConsumed: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx", "sourceCode": "export default function CoherenceEngineHost({\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Coherence Engine encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CoherenceEngineRemote projectId={projectId} schema={schema} eras={eras} onErasChange={onErasChange} pressures={pressures} onPressuresChange={onPressuresChange} generators={generators} onGeneratorsChange={onGeneratorsChange} actions={actions} onActionsChange={onActionsChange} systems={systems} onSystemsChange={onSystemsChange} activeSection={activeSection} onSectionChange={onSectionChange} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}", "type": "{ projectId: any; schema: any; eras: any; onErasChange: any; pressures: any; onPressuresChange: any; generators: any; onGeneratorsChange: any; actions: any; onActionsChange: any; systems: any; onSystemsChange: any; activeSection: any; onSectionChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/CosmographerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CosmographerHost.jsx", "sourceCode": "export default function CosmographerHost({\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Cosmographer encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CosmographerRemote schema={schema} axisDefinitions={axisDefinitions} seedEntities={seedEntities} seedRelationships={seedRelationships} onEntityKindsChange={onEntityKindsChange} onCulturesChange={onCulturesChange} onAxisDefinitionsChange={onAxisDefinitionsChange} onTagRegistryChange={onTagRegistryChange} onSeedEntitiesChange={onSeedEntitiesChange} onSeedRelationshipsChange={onSeedRelationshipsChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} schemaUsage={schemaUsage} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}", "type": "{ schema: any; axisDefinitions: any; seedEntities: any; seedRelationships: any; onEntityKindsChange: any; onCulturesChange: any; onAxisDefinitionsChange: any; onTagRegistryChange: any; onSeedEntitiesChange: any; onSeedRelationshipsChange: any; onAddTag: any; activeSection: any; onSectionChange: any; schemaUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx", "sourceCode": "export default function IlluminatorHost({\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Illuminator encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <IlluminatorRemote projectId={projectId} schema={schema} worldData={worldData} worldContext={worldContext} onWorldContextChange={onWorldContextChange} entityGuidance={entityGuidance} onEntityGuidanceChange={onEntityGuidanceChange} cultureIdentities={cultureIdentities} onCultureIdentitiesChange={onCultureIdentitiesChange} enrichmentConfig={enrichmentConfig} onEnrichmentConfigChange={onEnrichmentConfigChange} styleSelection={styleSelection} onStyleSelectionChange={onStyleSelectionChange} historianConfig={historianConfig} onHistorianConfigChange={onHistorianConfigChange} activeSection={activeSection} onSectionChange={onSectionChange} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; styleSelection: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx", "sourceCode": "export default function LoreWeaveHost({\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Lore Weave encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <LoreWeaveRemote projectId={projectId} schema={schema} eras={eras} pressures={pressures} generators={generators} systems={systems} actions={actions} seedEntities={seedEntities} seedRelationships={seedRelationships} distributionTargets={distributionTargets} onDistributionTargetsChange={onDistributionTargetsChange} activeSection={activeSection} onSectionChange={onSectionChange} simulationResults={simulationResults} onSimulationResultsChange={onSimulationResultsChange} simulationState={simulationState} onSimulationStateChange={onSimulationStateChange} onSearchRunScored={onSearchRunScored} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}", "type": "{ projectId: any; schema: any; eras: any; pressures: any; generators: any; systems: any; actions: any; seedEntities: any; seedRelationships: any; distributionTargets: any; onDistributionTargetsChange: any; activeSection: any; onSectionChange: any; simulationResults: any; onSimulationResultsChange: any; simulationState: any; onSimulationStateChange: any; onSearchRunScored: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/NameForgeHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/NameForgeHost.jsx", "sourceCode": "export default function NameForgeHost({\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Name Forge encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <NameForgeRemote projectId={projectId} schema={schema} onNamingDataChange={onNamingDataChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} generators={generators} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}", "type": "{ projectId: any; schema: any; onNamingDataChange: any; onAddTag: any; activeSection: any; onSectionChange: any; generators: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx", "sourceCode": "export default function RemotePlaceholder({ name, instructions }) {\n  return (\n    <div className=\"rph-container\">\n      <div className=\"rph-icon\">\ud83d\udd0c</div>\n      <div className=\"rph-title\">{name} Not Connected</div>\n      <div className=\"rph-message\">\n        The {name} module is not currently running. Start it to enable this feature.\n      </div>\n      {instructions && <div className=\"rph-instructions\">{instructions}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{ name, instructions }", "type": "{ name: any; instructions: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForSimulation", "name": "getCompletedChroniclesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForProject", "name": "getCompletedChroniclesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForProject(projectId) {\n  if (!projectId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"projectId\");\n        const request = index.getAll(IDBKeyRange.only(projectId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::importChronicles", "name": "importChronicles", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "/**\n * Import chronicles into a project (overwrite-merge by chronicleId).\n *\n * @param {string} projectId\n * @param {Array} chronicles\n * @param {Object} options\n * @param {string} options.simulationRunId - Optional run ID to apply when missing\n */\nexport async function importChronicles(projectId, chronicles, options = {}) {\n  if (!projectId || !Array.isArray(chronicles) || chronicles.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  const { simulationRunId } = options;\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n\n      for (const chronicle of chronicles) {\n        if (!chronicle?.chronicleId) {\n          skipped += 1;\n          continue;\n        }\n        const record = {\n          ...chronicle,\n          projectId,\n          simulationRunId: chronicle.simulationRunId || simulationRunId || null,\n        };\n        const req = store.get(record.chronicleId);\n        req.onsuccess = () => {\n          if (req.result) overwritten += 1;\n          store.put(record);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "chronicles", "type": "any[]", "optional": false}, {"name": "options", "type": "{ simulationRunId: string; }", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getChronicleCountForProject", "name": "getChronicleCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getChronicleCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::openDatabase", "name": "openDatabase", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Open (or reuse) the IndexedDB database.\n */\nexport async function openDatabase() {\n  if (dbInstance) return dbInstance;\n\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n\n    request.onsuccess = () => {\n      dbInstance = request.result;\n      resolve(dbInstance);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n        store.createIndex(\"name\", \"name\", { unique: false });\n        store.createIndex(\"updatedAt\", \"updatedAt\", { unique: false });\n      }\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::saveProject", "name": "saveProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Save a project to the database.\n */\nexport async function saveProject(project) {\n  const db = await openDatabase();\n  const timestamp = new Date().toISOString();\n\n  const projectToSave = {\n    ...project,\n    updatedAt: timestamp,\n    createdAt: project.createdAt || timestamp,\n  };\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put(projectToSave);\n\n    request.onsuccess = () => resolve(projectToSave);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "project", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::loadProject", "name": "loadProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Load a project by ID.\n */\nexport async function loadProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.get(id);\n\n    request.onsuccess = () => resolve(request.result || null);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::deleteProject", "name": "deleteProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Delete a project by ID.\n */\nexport async function deleteProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.delete(id);\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::listProjects", "name": "listProjects", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * List all projects (metadata only, sorted by recency).\n */\nexport async function listProjects() {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.getAll();\n\n    request.onsuccess = () => {\n      const projects = request.result.map((p) => ({\n        id: p.id,\n        name: p.name,\n        updatedAt: p.updatedAt,\n        entityCount: p.seedEntities?.length || 0,\n        cultureCount: p.cultures?.length || 0,\n      }));\n\n      // Sort by most recently updated\n      projects.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));\n      resolve(projects);\n    };\n\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::createEmptyProject", "name": "createEmptyProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Create a new empty project with default structure.\n */\nexport function createEmptyProject(name = \"New World\") {\n  return {\n    id: `project_${Date.now()}`,\n    name,\n    version: \"1.0\",\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    // Schema (Enumerist)\n    entityKinds: [],\n    relationshipKinds: [],\n    // Cultures (Enumerist + Name Forge + Cosmographer)\n    cultures: [],\n    // Tag Registry (Enumerist)\n    tagRegistry: [],\n    // Axis definitions (Cosmographer)\n    axisDefinitions: [],\n    // UI configuration (Archivist + UI hints)\n    uiConfig: DEFAULT_UI_CONFIG,\n    // Temporal structure (Cosmographer)\n    eras: [],\n    // Simulation config (Coherence Engine)\n    pressures: [],\n    generators: [],\n    systems: [],\n    actions: [],\n    // Seed data (Cosmographer)\n    seedEntities: [],\n    seedRelationships: [],\n    // Distribution targets (Lore Weave)\n    distributionTargets: null,\n    // Simulation (Simulation Workshop) - optional, undefined until configured\n    simulation: undefined,\n  };\n}", "parameters": [{"name": "name", "type": "string", "optional": true}], "returnType": "{ id: string; name: string; version: string; createdAt: string; updatedAt: string; entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; axisDefinitions: any[]; uiConfig: { worldIcon: string; prominenceLevels: string[]; prominenceColors: { forgotten: string; marginal: string; recognized: string; renowned: string; mythic: string; }; }; eras: any[]; pressures: any[]; generators: any[]; systems: any[]; actions: any[]; seedEntities: any[]; seedRelationships: any[]; distributionTargets: any; simulation: any; }"}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::importEntities", "name": "importEntities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function importEntities(simulationRunId, entities) {\n  if (!simulationRunId || !Array.isArray(entities) || entities.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(ENTITIES_STORE_NAME)) {\n      throw new Error(\"Illuminator entities store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n\n      for (const entity of entities) {\n        if (!entity?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(entity.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n\n          const merged = mergeDefined(existing, incoming);\n          const incomingEnrichment = incoming.enrichment || {};\n          const existingEnrichment = existing.enrichment || {};\n\n          merged.enrichment = { ...existingEnrichment, ...incomingEnrichment };\n          merged.summary = incoming.summary ?? existing.summary;\n          merged.description = incoming.description ?? existing.description;\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "entities", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::getEntityCountForRun", "name": "getEntityCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function getEntityCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eraNarrativeStorage.js::getCompletedEraNarrativesForSimulation", "name": "getCompletedEraNarrativesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eraNarrativeStorage.js", "sourceCode": "export async function getCompletedEraNarrativesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Check if the store exists (older DB versions may not have it)\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        return [];\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(STORE_NAME, \"readonly\");\n        const store = tx.objectStore(STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allRecords = request.result || [];\n          const projected = allRecords.map(projectForExport).filter(Boolean);\n\n          // Keep only the latest completed narrative per era\n          const byEra = new Map();\n          for (const record of projected) {\n            const existing = byEra.get(record.eraId);\n            if (!existing || record.updatedAt > existing.updatedAt) {\n              byEra.set(record.eraId, record);\n            }\n          }\n\n          resolve(Array.from(byEra.values()));\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get era narratives\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[eraNarrativeStorage] Failed to load era narratives:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::importNarrativeEvents", "name": "importNarrativeEvents", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function importNarrativeEvents(simulationRunId, events) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(EVENTS_STORE_NAME)) {\n      throw new Error(\"Illuminator narrativeEvents store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n\n      for (const event of events) {\n        if (!event?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...event,\n          simulationRunId: event.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(event.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n          const merged = mergeDefined(existing, incoming);\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "events", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::getNarrativeEventCountForRun", "name": "getNarrativeEventCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function getNarrativeEventCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () =>\n        reject(request.error || new Error(\"Failed to count narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::importBundleImageReferences", "name": "importBundleImageReferences", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function importBundleImageReferences({ projectId, imageData, images } = {}) {\n  if (!projectId) return { imported: 0, skipped: 0 };\n  const results = Array.isArray(imageData?.results) ? imageData.results : [];\n  if (results.length === 0) return { imported: 0, skipped: 0 };\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(IMAGES_STORE_NAME)) {\n      throw new Error(\"Illuminator images store is unavailable.\");\n    }\n\n    const now = Date.now();\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n\n      for (const entry of results) {\n        const imageId = entry?.imageId;\n        if (!imageId) {\n          skipped += 1;\n          continue;\n        }\n\n        const rawPath = (images && images[imageId]) || entry.localPath;\n        const sourcePath = normalizeSourcePath(rawPath);\n        const mimeType = inferMimeType(sourcePath);\n        const incomingEntityId = entry.entityId || entry.chronicleId || null;\n\n        const getReq = store.get(imageId);\n        getReq.onsuccess = () => {\n          const existing = getReq.result || {};\n          if (getReq.result) overwritten += 1;\n          const merged = {\n            ...existing,\n            imageId,\n            projectId,\n            entityId: incomingEntityId ?? existing.entityId ?? \"chronicle\",\n            entityName: entry.entityName ?? existing.entityName,\n            entityKind: entry.entityKind ?? existing.entityKind,\n            entityCulture: entry.entityCulture ?? existing.entityCulture,\n            originalPrompt: entry.prompt ?? existing.originalPrompt,\n            finalPrompt: entry.prompt ?? existing.finalPrompt,\n            imageType: entry.imageType ?? existing.imageType,\n            chronicleId: entry.chronicleId ?? existing.chronicleId,\n            imageRefId: entry.imageRefId ?? existing.imageRefId,\n            sceneDescription: entry.sceneDescription ?? existing.sceneDescription,\n            generatedAt: existing.generatedAt ?? now,\n            model: existing.model || \"imported\",\n            mimeType: existing.mimeType || mimeType,\n            size: typeof existing.size === \"number\" ? existing.size : 0,\n            savedAt: existing.savedAt ?? now,\n          };\n\n          store.put(merged);\n          imported += 1;\n        };\n        getReq.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import image references\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{ projectId, imageData, images }", "type": "{}", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::getImageCountForProject", "name": "getImageCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function getImageCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count images\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlots", "name": "getRunSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlots(projectId) {\n  if (!projectId) return {};\n  const records = await idbGetByProject(projectId);\n  return records.reduce((acc, record) => {\n    acc[record.slotIndex] = stripRunRecord(record);\n    return acc;\n  }, {});\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlot", "name": "getRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlot(projectId, slotIndex) {\n  if (!projectId) return null;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = await idbGet(projectId, normalized);\n  return stripRunRecord(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::saveRunSlot", "name": "saveRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function saveRunSlot(projectId, slotIndex, slotData) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = {\n    projectId,\n    slotIndex: normalized,\n    ...slotData,\n  };\n  await idbSet(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlot", "name": "deleteRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlot(projectId, slotIndex) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  await idbDelete(projectId, normalized);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlotsForProject", "name": "deleteRunSlotsForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlotsForProject(projectId) {\n  if (!projectId) return;\n  await idbDeleteProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "// ============================================================================\n// Storage Operations\n// ============================================================================\n\n/**\n * Get all static pages for a project (both draft and published)\n */\nexport async function getStaticPagesForProject(projectId) {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const req = index.getAll(projectId);\n      req.onsuccess = () => {\n        const pages = req.result || [];\n        pages.sort((a, b) => b.updatedAt - a.updatedAt);\n        resolve(pages);\n      };\n      req.onerror = () => reject(req.error || new Error(\"Failed to get static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::importStaticPages", "name": "importStaticPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Import static pages into a project (used during project import)\n * This replaces all existing pages for the project.\n *\n * @param {string} projectId - The project ID to import pages into\n * @param {Array} pages - Array of page objects to import\n * @param {Object} options - Import options\n * @param {boolean} options.preserveIds - If true, use page IDs from import data\n */\nexport async function importStaticPages(projectId, pages, options = {}) {\n  if (!Array.isArray(pages) || pages.length === 0) {\n    return 0;\n  }\n\n  const db = await openIlluminatorDb();\n  const now = Date.now();\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      let importedCount = 0;\n\n      for (const pageData of pages) {\n        const page = {\n          pageId: options.preserveIds && pageData.pageId ? pageData.pageId : generatePageId(),\n          projectId,\n          title: pageData.title || \"Untitled\",\n          slug: pageData.slug || generateSlug(pageData.title || \"untitled\"),\n          content: pageData.content || \"\",\n          summary: pageData.summary,\n          status: pageData.status || \"draft\",\n          createdAt: pageData.createdAt || now,\n          updatedAt: pageData.updatedAt || now,\n          linkedEntityIds: extractEntityLinks(pageData.content || \"\"),\n          wordCount: countWords(pageData.content || \"\"),\n        };\n\n        store.put(page);\n        importedCount++;\n      }\n\n      tx.oncomplete = () => resolve(importedCount);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import static pages\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "pages", "type": "any[]", "optional": false}, {"name": "options", "type": "{ preserveIds: boolean; }", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Delete all static pages for a project\n */\nexport async function deleteStaticPagesForProject(projectId) {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      for (const page of pages) {\n        store.delete(page.pageId);\n      }\n\n      tx.oncomplete = () => resolve(pages.length);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to delete static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::loadAndImportSeedPages", "name": "loadAndImportSeedPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Load seed pages from staticPages.json and import them\n * Used when reloading defaults\n */\nexport async function loadAndImportSeedPages(projectId, seedPagesUrl) {\n  const url = seedPagesUrl || `${import.meta.env.BASE_URL}default-project/staticPages.json`;\n\n  let seedPages;\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.log(\"No seed pages file found\");\n      return 0;\n    }\n    seedPages = await response.json();\n  } catch (err) {\n    console.log(\"Failed to load seed pages:\", err);\n    return 0;\n  }\n\n  if (!Array.isArray(seedPages) || seedPages.length === 0) {\n    return 0;\n  }\n\n  // Convert seed pages to import format\n  const pagesToImport = seedPages.map((seed) => ({\n    title: seed.title,\n    slug: seed.slug,\n    content: seed.content,\n    summary: seed.summary,\n    status: seed.status || \"published\",\n  }));\n\n  // Clear existing pages and import fresh\n  await deleteStaticPagesForProject(projectId);\n  return importStaticPages(projectId, pagesToImport);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "seedPagesUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadUiState", "name": "loadUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadUiState() {\n  if (!canUseStorage()) return null;\n  try {\n    const raw = localStorage.getItem(UI_STATE_KEY);\n    if (!raw) return null;\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveUiState", "name": "saveUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveUiState(state) {\n  if (!canUseStorage()) return;\n  try {\n    localStorage.setItem(UI_STATE_KEY, JSON.stringify(state));\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "state", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadLastProjectId", "name": "loadLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadLastProjectId() {\n  if (!canUseStorage()) return null;\n  try {\n    return localStorage.getItem(LAST_PROJECT_KEY);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "string"}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveLastProjectId", "name": "saveLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveLastProjectId(projectId) {\n  if (!canUseStorage()) return;\n  try {\n    if (projectId) {\n      localStorage.setItem(LAST_PROJECT_KEY, projectId);\n    } else {\n      localStorage.removeItem(LAST_PROJECT_KEY);\n    }\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldStore", "name": "loadWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Public API - Core Store Operations\n// =============================================================================\n\n/**\n * Load all persisted data for a project\n */\nexport async function loadWorldStore(projectId) {\n  if (!projectId) return null;\n  let record = null;\n  try {\n    record = await idbGet(projectId);\n  } catch {\n    // Fall back to localStorage\n    record = lsGet(projectId);\n  }\n  if (!record) record = lsGet(projectId);\n  return normalizeWorldStore(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldStore", "name": "saveWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save all data for a project (merges with existing)\n */\nexport async function saveWorldStore(projectId, data) {\n  if (!projectId) return;\n  let existing = null;\n  try {\n    existing = await idbGet(projectId);\n  } catch {\n    existing = null;\n  }\n\n  const merged = { ...(normalizeWorldStore(existing) || { activeSlotIndex: 0 }), ...data };\n  delete merged.projectId;\n  delete merged.slots;\n\n  try {\n    await idbSet(projectId, merged);\n  } catch {\n    const localExisting = normalizeWorldStore(lsGet(projectId)) || { activeSlotIndex: 0 };\n    const localMerged = { ...localExisting, ...data };\n    delete localMerged.slots;\n    lsSet(projectId, localMerged);\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "data", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearWorldStore", "name": "clearWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear all persisted data for a project\n */\nexport async function clearWorldStore(projectId) {\n  if (!projectId) return;\n  try {\n    await idbDelete(projectId);\n  } catch {\n    // Ignore\n  }\n  lsDelete(projectId);\n  await deleteRunSlotsForProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlotIndex", "name": "getActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Slot Operations\n// =============================================================================\n\n/**\n * Get the active slot index for a project\n */\nexport async function getActiveSlotIndex(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.activeSlotIndex ?? 0;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::setActiveSlotIndex", "name": "setActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Set the active slot index for a project\n */\nexport async function setActiveSlotIndex(projectId, slotIndex) {\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlots", "name": "getSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get all slots for a project\n */\nexport async function getSlots(projectId) {\n  await loadWorldStore(projectId);\n  return getRunSlots(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for a specific slot\n */\nexport async function getSlot(projectId, slotIndex) {\n  await loadWorldStore(projectId);\n  return getRunSlot(projectId, slotIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlot", "name": "getActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for the currently active slot\n */\nexport async function getActiveSlot(projectId) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  return getSlot(projectId, activeIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSlot", "name": "saveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to a specific slot\n */\nexport async function saveSlot(projectId, slotIndex, slotData) {\n  await saveRunSlot(projectId, slotIndex, slotData);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToActiveSlot", "name": "saveToActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to the currently active slot (merges with existing slot data)\n */\nexport async function saveToActiveSlot(projectId, slotData) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  const existingSlot = (await getSlot(projectId, activeIndex)) || {};\n  const updatedSlot = { ...existingSlot, ...slotData };\n  await saveRunSlot(projectId, activeIndex, updatedSlot);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToSlot", "name": "saveToSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Move data from scratch (slot 0) to a save slot (1-4)\n * Clears scratch and switches active to the target slot\n */\nexport async function saveToSlot(projectId, targetSlotIndex) {\n  if (targetSlotIndex < 1 || targetSlotIndex > MAX_SAVE_SLOTS) {\n    throw new Error(`Invalid save slot: ${targetSlotIndex}. Must be 1-${MAX_SAVE_SLOTS}`);\n  }\n\n  const scratchData = await getSlot(projectId, 0);\n\n  if (!scratchData || !scratchData.simulationResults) {\n    throw new Error(\"No data in scratch slot to save\");\n  }\n\n  // Generate title if not present\n  const title =\n    scratchData.title && scratchData.title !== \"Scratch\"\n      ? scratchData.title\n      : generateSlotTitle(targetSlotIndex);\n\n  // Move data to target slot\n  await saveRunSlot(projectId, targetSlotIndex, { ...scratchData, title, savedAt: Date.now() });\n  await deleteRunSlot(projectId, 0);\n  await saveWorldStore(projectId, { activeSlotIndex: targetSlotIndex });\n\n  return targetSlotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "targetSlotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSlot", "name": "loadSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load a saved slot by switching active index\n */\nexport async function loadSlot(projectId, slotIndex) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} is empty`);\n  }\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n  return slotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearSlot", "name": "clearSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear a specific slot\n */\nexport async function clearSlot(projectId, slotIndex) {\n  const store = (await loadWorldStore(projectId)) || { activeSlotIndex: 0 };\n  await deleteRunSlot(projectId, slotIndex);\n\n  const slots = await getSlots(projectId);\n\n  // Determine new active slot index\n  let newActiveSlotIndex = store.activeSlotIndex ?? 0;\n  if (newActiveSlotIndex === slotIndex) {\n    // If clearing the active slot:\n    // - If it's slot 0 (scratch), stay on 0 (scratch is conceptually always available)\n    // - Otherwise, switch to scratch (0) or first available slot\n    if (slotIndex === 0) {\n      newActiveSlotIndex = 0;\n    } else {\n      // Find first available slot (prefer scratch if it exists, otherwise first saved slot)\n      const availableSlots = Object.keys(slots)\n        .map(Number)\n        .sort((a, b) => a - b);\n      newActiveSlotIndex = availableSlots.length > 0 ? availableSlots[0] : 0;\n    }\n  }\n\n  await saveWorldStore(projectId, { activeSlotIndex: newActiveSlotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::updateSlotTitle", "name": "updateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Update the title of a slot\n */\nexport async function updateSlotTitle(projectId, slotIndex, title) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} does not exist`);\n  }\n  await saveRunSlot(projectId, slotIndex, { ...slot, title });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "title", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getNextAvailableSlot", "name": "getNextAvailableSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get the next available save slot (1-4), or null if all full\n */\nexport async function getNextAvailableSlot(projectId) {\n  const slots = await getSlots(projectId);\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (!slots[i]) return i;\n  }\n  return null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::generateSlotTitle", "name": "generateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Generate a default title for a slot\n */\nexport function generateSlotTitle(slotIndex, timestamp = Date.now()) {\n  const date = new Date(timestamp);\n  const formatted = date.toLocaleString(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n  return `Run ${slotIndex} - ${formatted}`;\n}", "parameters": [{"name": "slotIndex", "type": "any", "optional": false}, {"name": "timestamp", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSimulationData", "name": "saveSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Convenience methods - operate on active slot\n// =============================================================================\n\n/**\n * Save simulation run data to the active slot\n */\nexport async function saveSimulationData(projectId, { simulationResults, simulationState }) {\n  // Always write new simulations to scratch (slot 0)\n  const existingSlot = (await getSlot(projectId, 0)) || {};\n  const updatedSlot = { ...existingSlot, simulationResults, simulationState };\n  await saveRunSlot(projectId, 0, updatedSlot);\n  await saveWorldStore(projectId, { activeSlotIndex: 0 });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "{ simulationResults, simulationState }", "type": "{ simulationResults: any; simulationState: any; }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSimulationData", "name": "loadSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load simulation run data from the active slot\n */\nexport async function loadSimulationData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return {\n    simulationResults: slot?.simulationResults || null,\n    simulationState: slot?.simulationState || null,\n  };\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<{ simulationResults: any; simulationState: any; }>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldData", "name": "saveWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save world data to the active slot\n */\nexport async function saveWorldData(projectId, worldData) {\n  await saveToActiveSlot(projectId, { worldData });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldData", "name": "loadWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load world data from the active slot\n */\nexport async function loadWorldData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return slot?.worldData || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldContext", "name": "saveWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator world context (shared across slots)\n */\nexport async function saveWorldContext(projectId, worldContext) {\n  await saveWorldStore(projectId, { worldContext });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldContext", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldContext", "name": "loadWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator world context\n */\nexport async function loadWorldContext(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.worldContext || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEnrichmentConfig", "name": "saveEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator enrichment config (shared across slots)\n */\nexport async function saveEnrichmentConfig(projectId, enrichmentConfig) {\n  await saveWorldStore(projectId, { enrichmentConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "enrichmentConfig", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadEnrichmentConfig", "name": "loadEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator enrichment config\n */\nexport async function loadEnrichmentConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.enrichmentConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEntityGuidance", "name": "saveEntityGuidance", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save entity guidance (shared across slots)\n */\nexport async function saveEntityGuidance(projectId, entityGuidance) {\n  await saveWorldStore(projectId, { entityGuidance });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "entityGuidance", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveCultureIdentities", "name": "saveCultureIdentities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save culture identities (shared across slots)\n */\nexport async function saveCultureIdentities(projectId, cultureIdentities) {\n  await saveWorldStore(projectId, { cultureIdentities });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "cultureIdentities", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveStyleSelection", "name": "saveStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator style selection (shared across slots)\n */\nexport async function saveStyleSelection(projectId, styleSelection) {\n  await saveWorldStore(projectId, { styleSelection });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "styleSelection", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveHistorianConfig", "name": "saveHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save historian persona config (shared across slots)\n */\nexport async function saveHistorianConfig(projectId, historianConfig) {\n  await saveWorldStore(projectId, { historianConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "historianConfig", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadHistorianConfig", "name": "loadHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load historian persona config\n */\nexport async function loadHistorianConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.historianConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadStyleSelection", "name": "loadStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator style selection\n */\nexport async function loadStyleSelection(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.styleSelection || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/stores/useCanonryUiStore.js::selectActiveSection", "name": "selectActiveSection", "kind": "function", "filePath": "apps/canonry/webui/src/stores/useCanonryUiStore.js", "sourceCode": "/** Selector for the computed activeSection */\r\nexport function selectActiveSection(s) {\r\n  return s.activeTab ? (s.activeSectionByTab[s.activeTab] ?? null) : null;\r\n}", "parameters": [{"name": "s", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx", "sourceCode": "export default function CultureEditor({ cultures, onChange }) {\n  const [expandedCultures, setExpandedCultures] = useState({});\n\n  const getStableKey = (culture) => culture._key || culture.id;\n\n  const toggleCulture = useCallback((stableKey) => {\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addCulture = () => {\n    const stableKey = `culture_${Date.now()}`;\n    const newCulture = {\n      id: stableKey,\n      name: \"New Culture\",\n      description: \"\",\n      color: PRESET_COLORS[cultures.length % PRESET_COLORS.length],\n      _key: stableKey,\n    };\n    onChange([...cultures, newCulture]);\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateCulture = (cultureId, updates) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    onChange(cultures.map((c) => (c.id === cultureId ? { ...c, ...updates } : c)));\n  };\n\n  const deleteCulture = (cultureId) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this culture?\")) {\n      onChange(cultures.filter((c) => c.id !== cultureId));\n    }\n  };\n\n  const getCultureSummary = (culture) => {\n    const parts = [];\n    if (culture.naming?.domains?.length) parts.push(`${culture.naming.domains.length} domains`);\n    if (culture.axisBiases && Object.keys(culture.axisBiases).length) parts.push(\"axis biases\");\n    return parts.length > 0 ? parts.join(\", \") : \"not configured\";\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addCulture}>\n      + Add Culture\n    </button>\n  );\n\n  const renderCultureTitle = (culture) => (\n    <span className=\"ced-title-wrapper\">\n      <span\n        className=\"ced-color-swatch\"\n        style={{ '--ced-swatch-color': culture.color }}\n      />\n      {culture.name}\n    </span>\n  );\n\n  const renderCultureActions = (culture, isFramework) => (\n    <span className=\"text-muted text-small\">\n      {getCultureSummary(culture)}\n      {isFramework && (\n        <span className=\"badge badge-info ced-framework-badge\">\n          framework\n        </span>\n      )}\n    </span>\n  );\n\n  return (\n    <div className=\"editor-container ced-container\">\n      <SectionHeader\n        title=\"Cultures\"\n        description=\"Define cultural groups with their own naming conventions and placement biases.\"\n        count={cultures.length}\n        actions={renderHeaderActions()}\n      />\n\n      {cultures.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83c\udfad\"\n          title=\"No cultures defined\"\n          description=\"Add one to give your world cultural diversity.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {cultures.map((culture) => {\n            const stableKey = getStableKey(culture);\n            const isExpanded = expandedCultures[stableKey];\n            const isFramework = Boolean(culture.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleCulture}\n                toggleId={stableKey}\n                title={renderCultureTitle(culture)}\n                subtitle={culture.id}\n                actions={renderCultureActions(culture, isFramework)}\n              >\n                {/* Name and ID */}\n                <FormRow>\n                  <FormGroup label=\"Name\">\n                    <input\n                      className=\"input\"\n                      value={culture.name}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { name: e.target.value })}\n                      placeholder=\"Culture name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"ID\">\n                    <input\n                      className=\"input\"\n                      value={culture.id}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newId = e.target.value.toLowerCase().replace(/[^a-z0-9-_]/g, \"\");\n                        if (newId && !cultures.some((c) => c.id === newId && c.id !== culture.id)) {\n                          updateCulture(culture.id, { id: newId });\n                        }\n                      }}\n                      placeholder=\"culture-id\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                <FormRow>\n                  <FormGroup label=\"Description\" wide>\n                    <input\n                      className=\"input\"\n                      value={culture.description || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { description: e.target.value })}\n                      placeholder=\"Optional description\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                {/* Color Selection */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Color</div>\n                  <div className=\"ced-color-row\">\n                    <div\n                      className=\"ced-color-preview\"\n                      style={{ '--ced-preview-color': culture.color }}\n                    />\n                    <div className=\"chip-list\">\n                      {PRESET_COLORS.map((color) => (\n                        <div\n                          key={color}\n                          className={`chip chip-clickable ced-color-chip ${culture.color === color ? \"chip-active\" : \"\"}`}\n                          style={{\n                            '--ced-chip-bg': color,\n                            '--ced-chip-border': culture.color === color ? '#fff' : 'transparent',\n                            '--ced-chip-opacity': isFramework ? 0.6 : 1,\n                            '--ced-chip-pointer': isFramework ? 'none' : 'auto',\n                          }}\n                          onClick={() => updateCulture(culture.id, { color })}\n                          role=\"button\"\n                          tabIndex={0}\n                          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                        />\n                      ))}\n                    </div>\n                  </div>\n                </div>\n\n                {/* Info about other editors */}\n                <InfoBox title=\"Additional configuration\">\n                  <ul className=\"ced-info-list\">\n                    <li>\n                      <strong>Names tab</strong> \u2014 Configure naming domains, grammars, and profiles\n                    </li>\n                    <li>\n                      <strong>Cosmography tab</strong> \u2014 Configure axis biases and home regions\n                    </li>\n                  </ul>\n                </InfoBox>\n\n                {/* Actions */}\n                <div className=\"danger-zone\">\n                  <div className=\"ced-action-badges\">\n                    {culture.naming && <span className=\"badge\">has naming</span>}\n                    {culture.axisBiases && <span className=\"badge\">has biases</span>}\n                  </div>\n                  <button\n                    className=\"btn btn-danger\"\n                    onClick={() => deleteCulture(culture.id)}\n                    disabled={isFramework}\n                  >\n                    Delete Culture\n                  </button>\n                </div>\n              </ExpandableCard>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ cultures, onChange }", "type": "{ cultures: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx", "sourceCode": "export default function EntityKindEditor({\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}) {\n  const [expandedKinds, setExpandedKinds] = useState({});\n  const [newSubtype, setNewSubtype] = useState({});\n  const [newStatus, setNewStatus] = useState({});\n\n  const namingProfileUsage = useMemo(() => computeNamingProfileUsage(namingData), [namingData]);\n\n  const getNamingProfileCount = (kind) => {\n    const specific = namingProfileUsage[kind]?.profiles?.length || 0;\n    const wildcard = namingProfileUsage[\"*\"]?.profiles?.length || 0;\n    return specific + wildcard;\n  };\n\n  const getStableKey = (ek) => ek._key || ek.kind;\n\n  const toggleKind = useCallback((stableKey) => {\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addEntityKind = () => {\n    const stableKey = `kind_${Date.now()}`;\n    const newKind = {\n      kind: stableKey,\n      description: \"New Entity Kind\",\n      subtypes: [],\n      statuses: [{ id: \"active\", name: \"Active\", isTerminal: false }],\n      defaultStatus: \"active\",\n      style: { color: getDefaultKindColor(stableKey, entityKinds.length) },\n      _key: stableKey,\n    };\n    onChange([...entityKinds, newKind]);\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateKind = (kindKey, updates) => {\n    const existing = entityKinds.find((k) => k.kind === kindKey);\n    if (existing?.isFramework) return;\n    onChange(entityKinds.map((k) => (k.kind === kindKey ? { ...k, ...updates } : k)));\n  };\n\n  const updateKindStyle = (kindKey, updates) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (!kind) return;\n    updateKind(kindKey, { style: { ...(kind.style || {}), ...updates } });\n  };\n\n  const deleteKind = (kindKey) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (kind?.isFramework) return;\n    if (confirm(\"Delete this entity kind? This cannot be undone.\")) {\n      onChange(entityKinds.filter((k) => k.kind !== kindKey));\n    }\n  };\n\n  const addSubtype = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newSubtype[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const subtype = { id: generateId(name), name };\n    updateKind(kindKey, { subtypes: [...ek.subtypes, subtype] });\n    setNewSubtype((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeSubtype = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { subtypes: ek.subtypes.filter((s) => s.id !== subtypeId) });\n  };\n\n  const addStatus = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newStatus[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const status = { id: generateId(name), name, isTerminal: false, polarity: \"neutral\" };\n    updateKind(kindKey, { statuses: [...ek.statuses, status] });\n    setNewStatus((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeStatus = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { statuses: ek.statuses.filter((s) => s.id !== statusId) });\n  };\n\n  const toggleStatusTerminal = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, isTerminal: !s.isTerminal } : s\n      ),\n    });\n  };\n\n  const updateStatusPolarity = (kindKey, statusId, polarity) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) => (s.id === statusId ? { ...s, polarity } : s)),\n    });\n  };\n\n  const updateStatusTransitionVerb = (kindKey, statusId, transitionVerb) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, transitionVerb: transitionVerb || undefined } : s\n      ),\n    });\n  };\n\n  const toggleSubtypeAuthority = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      subtypes: ek.subtypes.map((s) =>\n        s.id === subtypeId ? { ...s, isAuthority: !s.isAuthority } : s\n      ),\n    });\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addEntityKind}>\n      + Add Entity Kind\n    </button>\n  );\n\n  const renderKindActions = (kind, profileCount, isFramework) => (\n    <>\n      <UsageBadges usage={getEntityKindUsageSummary(schemaUsage, kind.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {profileCount > 0 && (\n        <span\n          className=\"badge badge-warning\"\n          title={`Used in ${profileCount} naming profile group${profileCount !== 1 ? \"s\" : \"\"}`}\n        >\n          \u270e {profileCount}\n        </span>\n      )}\n      <span className=\"text-muted text-small\">\n        {kind.subtypes.length} subtypes, {kind.statuses.length} statuses\n      </span>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container eke-container\">\n      <SectionHeader\n        title=\"Entity Kinds\"\n        description=\"Define the types of entities that exist in your world.\"\n        count={entityKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {entityKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udce6\"\n          title=\"No entity kinds defined\"\n          description=\"Add one to get started.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {entityKinds.map((ek) => {\n            const stableKey = getStableKey(ek);\n            const isExpanded = expandedKinds[stableKey];\n            const profileCount = getNamingProfileCount(ek.kind);\n            const kindColor = ek.style?.color;\n            const isFramework = Boolean(ek.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleKind}\n                toggleId={stableKey}\n                title={ek.description}\n                subtitle={ek.kind}\n                actions={renderKindActions(ek, profileCount, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <FormRow>\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={ek.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateKind(ek.kind, { description: e.target.value })}\n                      placeholder=\"Entity kind display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={ek.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !entityKinds.some((k) => k.kind === newKind && k.kind !== ek.kind)\n                        ) {\n                          updateKind(ek.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"entity_kind_id\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Color\">\n                    <input\n                      className=\"input\"\n                      type=\"color\"\n                      value={kindColor ?? \"#000000\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateKindStyle(ek.kind, { color: e.target.value })}\n                    />\n                    {!kindColor && (\n                      <div className=\"eke-color-missing\">\n                        Color required\n                      </div>\n                    )}\n                  </FormGroup>\n                  <FormGroup\n                    label=\"Category\"\n                    tooltip=\"Abstract category for narrative style recommendations\"\n                  >\n                    <select\n                      className=\"input\"\n                      value={ek.category || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) =>\n                        updateKind(ek.kind, { category: e.target.value || undefined })\n                      }\n                    >\n                      <option value=\"\">-- Not set --</option>\n                      {Object.entries(ENTITY_CATEGORIES).map(([categoryId, categoryInfo]) => (\n                        <option key={categoryId} value={categoryId}>\n                          {categoryInfo.name}\n                        </option>\n                      ))}\n                    </select>\n                  </FormGroup>\n                </FormRow>\n\n                {/* Subtypes */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Subtypes</div>\n                  <div className=\"chip-list\">\n                    {ek.subtypes.map((subtype) => {\n                      const usage = getSubtypeUsage(schemaUsage, ek.kind, subtype.id);\n                      const isUnused = usage.total === 0;\n                      const tooltipParts = [];\n                      if (usage.generators > 0)\n                        tooltipParts.push(\n                          `${usage.generators} generator${usage.generators !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.systems > 0)\n                        tooltipParts.push(\n                          `${usage.systems} system${usage.systems !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.seeds > 0)\n                        tooltipParts.push(`${usage.seeds} seed${usage.seeds !== 1 ? \"s\" : \"\"}`);\n                      const tooltip =\n                        tooltipParts.length > 0\n                          ? tooltipParts.join(\", \")\n                          : \"Not used by any generator, system, or seed\";\n\n                      return (\n                        <div\n                          key={subtype.id}\n                          className={`chip ${isUnused ? \"chip-unused\" : \"\"}`}\n                          title={tooltip}\n                        >\n                          <input\n                            type=\"checkbox\"\n                            checked={subtype.isAuthority || false}\n                            disabled={isFramework}\n                            onChange={() => toggleSubtypeAuthority(ek.kind, subtype.id)}\n                            title=\"Authority subtype (for leadership/succession events)\"\n                          />\n                          <span className=\"chip-content\">\n                            {subtype.name}\n                            {subtype.isAuthority && (\n                              <span className=\"badge badge-warning eke-authority-badge\">\n                                \ud83d\udc51\n// ... (truncated)", "parameters": [{"name": "{\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ entityKinds: any; onChange: any; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/index.jsx", "sourceCode": "export default function SchemaEditor({\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}) {\n  // Use passed-in activeSection, fallback to entityKinds\n  const currentSection = activeSection || \"entityKinds\";\n  const handleNavigateToRelationship = useCallback(() => {\n    onSectionChange(\"relationshipKinds\");\n  }, [onSectionChange]);\n  const tagRegistryOrEmpty = useMemo(() => project.tagRegistry || [], [project.tagRegistry]);\n\n  const counts = {\n    entityKinds: project.entityKinds.length,\n    relationshipKinds: project.relationshipKinds.length,\n    cultures: project.cultures.length,\n    tagRegistry: (project.tagRegistry || []).length,\n  };\n\n  const renderEditor = () => {\n    switch (currentSection) {\n      case \"entityKinds\":\n        return (\n          <EntityKindEditor\n            entityKinds={project.entityKinds}\n            onChange={onUpdateEntityKinds}\n            schemaUsage={schemaUsage}\n            namingData={namingData}\n          />\n        );\n\n      case \"relationshipKinds\":\n        return (\n          <RelationshipKindEditor\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateRelationshipKinds}\n            schemaUsage={schemaUsage}\n          />\n        );\n\n      case \"relationshipMatrix\":\n        return (\n          <RelationshipKindMatrix\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onNavigateToRelationship={handleNavigateToRelationship}\n          />\n        );\n\n      case \"cultures\":\n        return <CultureEditor cultures={project.cultures} onChange={onUpdateCultures} />;\n\n      case \"tags\":\n        return (\n          <TagRegistryEditor\n            tagRegistry={tagRegistryOrEmpty}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateTagRegistry}\n            tagUsage={tagUsage}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"se-container\">\n      <div className=\"se-sidebar\">\n        <div className=\"se-sidebar-title\">Schema</div>\n        {SECTIONS.map((section) => (\n          <div\n            key={section.id}\n            className={`se-sidebar-item ${section.id === currentSection ? \"se-sidebar-item-active\" : \"se-sidebar-item-inactive\"}`}\n            style={section.id === currentSection ? { '--se-sidebar-active-bg': getAccentGradient(\"enumerist\") } : undefined}\n            onClick={() => onSectionChange(section.id)}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            {section.label}\n            {section.countKey && (\n              <span className=\"se-sidebar-count\">{counts[section.countKey]}</span>\n            )}\n          </div>\n        ))}\n      </div>\n      <div className=\"se-main\">{renderEditor()}</div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ project: any; activeSection: any; onSectionChange: any; onUpdateEntityKinds: any; onUpdateRelationshipKinds: any; onUpdateCultures: any; onUpdateTagRegistry: any; tagUsage?: {}; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx", "sourceCode": "export default function RelationshipKindEditor({\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}) {\n  const [expandedRels, setExpandedRels] = useState({});\n\n  const getStableKey = (rel) => rel._key || rel.kind;\n\n  const toggleRel = useCallback((stableKey) => {\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addRelationship = () => {\n    const stableKey = `rel_${Date.now()}`;\n    const newRel = {\n      kind: stableKey,\n      description: \"New Relationship\",\n      srcKinds: [],\n      dstKinds: [],\n      cullable: true,\n      decayRate: \"medium\",\n      polarity: \"neutral\",\n      _key: stableKey,\n    };\n    onChange([...relationshipKinds, newRel]);\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateRel = (relKind, updates) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    onChange(relationshipKinds.map((r) => (r.kind === relKind ? { ...r, ...updates } : r)));\n  };\n\n  const deleteRel = (relKind) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this relationship kind?\")) {\n      onChange(relationshipKinds.filter((r) => r.kind !== relKind));\n    }\n  };\n\n  const toggleEntityKind = (relKind, field, entityKindId) => {\n    const rel = relationshipKinds.find((r) => r.kind === relKind);\n    if (!rel || rel.isFramework) return;\n    const current = rel[field] || [];\n    const updated = current.includes(entityKindId)\n      ? current.filter((k) => k !== entityKindId)\n      : [...current, entityKindId];\n    updateRel(relKind, { [field]: updated });\n  };\n\n  const getSummary = (rel) => {\n    const srcNames =\n      rel.srcKinds?.length > 0\n        ? rel.srcKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    const dstNames =\n      rel.dstKinds?.length > 0\n        ? rel.dstKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    return { srcNames, dstNames };\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addRelationship}>\n      + Add Relationship\n    </button>\n  );\n\n  const renderRelationshipActions = (rel, srcNames, dstNames, isFramework) => (\n    <>\n      <UsageBadges usage={getRelationshipKindUsageSummary(schemaUsage, rel.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {rel.cullable === false && <span className=\"badge badge-info\">protected</span>}\n      <div className=\"text-muted text-small rke-actions-flow\">\n        {srcNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.srcKinds?.length > 2 && <span>+{rel.srcKinds.length - 2}</span>}\n        <span>\u2192</span>\n        {dstNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.dstKinds?.length > 2 && <span>+{rel.dstKinds.length - 2}</span>}\n      </div>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container rke-container\">\n      <SectionHeader\n        title=\"Relationship Kinds\"\n        description=\"Define how entities can be connected to each other.\"\n        count={relationshipKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {relationshipKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udd17\"\n          title=\"No relationship kinds defined\"\n          description=\"Add one to connect entities.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {relationshipKinds.map((rel) => {\n            const stableKey = getStableKey(rel);\n            const isExpanded = expandedRels[stableKey];\n            const { srcNames, dstNames } = getSummary(rel);\n            const isFramework = Boolean(rel.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleRel}\n                toggleId={stableKey}\n                title={rel.description}\n                subtitle={rel.kind}\n                actions={renderRelationshipActions(rel, srcNames, dstNames, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <div className=\"rke-name-row\">\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={rel.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateRel(rel.kind, { description: e.target.value })}\n                      placeholder=\"Relationship display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={rel.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !relationshipKinds.some((r) => r.kind === newKind && r.kind !== rel.kind)\n                        ) {\n                          updateRel(rel.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"relationship_kind_id\"\n                    />\n                  </FormGroup>\n                </div>\n\n                {/* Entity Kind Constraints */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-constraint-label\">\n                    Entity Kind Constraints\n                  </div>\n                  {entityKinds.length === 0 ? (\n                    <div className=\"text-muted text-small\">\n                      Define entity kinds first to set constraints.\n                    </div>\n                  ) : (\n                    <div className=\"rke-constraint-row\">\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Source</span>\n                          {rel.srcKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.srcKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"srcKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                      <div className=\"text-dim rke-arrow\">\n                        \u2192\n                      </div>\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Destination</span>\n                          {rel.dstKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.dstKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"dstKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    </div>\n                  )}\n                </div>\n\n                {/* Maintenance Settings */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-maintenance-label\">\n                    Maintenance Settings\n                  </div>\n                  <div className=\"rke-maintenance-row\">\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Decay</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.decayRate || \"medium\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { decayRate: e.target.value })}\n                      >\n                        <option value=\"none\">None</option>\n                        <option value=\"slow\">Slow</option>\n                        <option value=\"medium\">Medium</option>\n                        <option value=\"fast\">Fast</option>\n                      </select>\n                    </div>\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Polarity</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.polarity || \"neutral\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { polarity: e.target.value })}\n                        title=\"Affects narrative event types\"\n                      >\n                        <option value=\"positive\">Positive</option>\n                        <option value=\"neutral\">Neutral</option>\n                        <option value=\"negative\">Negative</option>\n                      </select>\n                    </div>\n                    <label className=\"rke-cullable-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={rel.cullable !== false}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { cullable: e.target.checked })}\n                        className=\"rke-checkbox\"\n                      />\n                      <span className=\"text-small\">Cullable</span>\n                    </label>\n                  </div>\n                </div>\n\n                {/* Narrative Verbs */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-verbs-label\">\n                    Narrative Verbs\n                  </div>\n                  <div className=\"text-muted text-small rke-verbs-hint\">\n                    Verbs used in narrative event descriptions when this relationship is formed or\n                    ended.\n                  </div>\n                  <div className=\"rke-verbs-row\">\n                    <FormGroup label=\"Formed\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.formed || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n                          updateRel(rel.kind, {\n                            verbs: { ...rel.verbs, formed: e.target.value },\n                          })\n                        }\n                        placeholder=\"e.g., joined, allied with\"\n                      />\n                    </FormGroup>\n                    <FormGroup label=\"Ended\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.ended || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n// ... (truncated)", "parameters": [{"name": "{\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}", "type": "{ relationshipKinds: any; entityKinds: any; onChange: any; schemaUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx", "sourceCode": "export default function RelationshipKindMatrix({\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}) {\n  // Build rows from relationship kinds\n  const rows = useMemo(() => {\n    return relationshipKinds.map((rel) => ({\n      id: rel.kind,\n      label: rel.description || rel.kind,\n      // Store original data for getCellValue\n      srcKinds: rel.srcKinds || [],\n      dstKinds: rel.dstKinds || [],\n      // Status badges\n      statusBadges: getStatusBadges(rel),\n    }));\n  }, [relationshipKinds]);\n\n  // Build columns from entity kinds\n  const columns = useMemo(() => {\n    return entityKinds.map((ek) => ({\n      id: ek.kind,\n      label: ek.description || ek.kind,\n    }));\n  }, [entityKinds]);\n\n  // Calculate coverage stats\n  const stats = useMemo(() => {\n    const totalRels = relationshipKinds.length;\n    const totalEntityKinds = entityKinds.length;\n\n    // Count relationships that have explicit constraints\n    const constrainedRels = relationshipKinds.filter(\n      (r) => r.srcKinds?.length > 0 || r.dstKinds?.length > 0\n    ).length;\n\n    // Count relationships with no constraints (wildcard)\n    const wildcardRels = totalRels - constrainedRels;\n\n    // Find entity kinds that are never used as source or destination\n    const usedAsSource = new Set();\n    const usedAsDestination = new Set();\n    relationshipKinds.forEach((rel) => {\n      (rel.srcKinds || []).forEach((k) => usedAsSource.add(k));\n      (rel.dstKinds || []).forEach((k) => usedAsDestination.add(k));\n    });\n\n    const result = [\n      { label: \"Relationships\", value: totalRels },\n      { label: \"Entity Kinds\", value: totalEntityKinds },\n      { label: \"Constrained\", value: constrainedRels },\n    ];\n\n    if (wildcardRels > 0) {\n      result.push({ label: \"Wildcards\", value: wildcardRels, variant: \"warning\" });\n    }\n\n    return result;\n  }, [relationshipKinds, entityKinds]);\n\n  // Get cell value for a relationship \u00d7 entity kind intersection\n  const getCellValue = useCallback((rowId, columnId, row) => {\n    // Check if explicitly constrained vs wildcard\n    const srcExplicit = row.srcKinds.length > 0 && row.srcKinds.includes(columnId);\n    const dstExplicit = row.dstKinds.length > 0 && row.dstKinds.includes(columnId);\n    const srcWildcard = row.srcKinds.length === 0;\n    const dstWildcard = row.dstKinds.length === 0;\n\n    if (srcExplicit && dstExplicit) return \"both\";\n    if (srcExplicit) return \"primary\"; // explicitly source\n    if (dstExplicit) return \"secondary\"; // explicitly destination\n    if (srcWildcard && dstWildcard) return \"both\"; // wildcard both\n    if (srcWildcard) return \"primary\"; // wildcard source\n    if (dstWildcard) return \"secondary\"; // wildcard destination\n    return \"none\";\n  }, []);\n\n  // Custom cell display for relationship coverage\n  const getCellDisplay = useCallback((value) => {\n    switch (value) {\n      case \"both\":\n        return { icon: \"B\", className: \"both\", title: \"Both source and destination\" };\n      case \"primary\":\n        return { icon: \"S\", className: \"primary\", title: \"Source only\" };\n      case \"secondary\":\n        return { icon: \"D\", className: \"secondary\", title: \"Destination only\" };\n      case \"none\":\n      default:\n        return { icon: \"-\", className: \"none\", title: \"Not allowed\" };\n    }\n  }, []);\n\n  // Handle row click to navigate to relationship\n  const handleRowClick = useCallback(\n    (rowId) => {\n      if (onNavigateToRelationship) {\n        onNavigateToRelationship(rowId);\n      }\n    },\n    [onNavigateToRelationship]\n  );\n\n  // Filter options\n  const filterOptions = useMemo(\n    () => [\n      {\n        id: \"wildcards\",\n        label: \"Wildcards Only\",\n        filter: (row) => row.srcKinds.length === 0 || row.dstKinds.length === 0,\n      },\n      {\n        id: \"constrained\",\n        label: \"Constrained Only\",\n        filter: (row) => row.srcKinds.length > 0 && row.dstKinds.length > 0,\n      },\n    ],\n    []\n  );\n\n  // Legend items\n  const legend = useMemo(\n    () => [\n      { icon: \"S\", className: \"primary\", label: \"Can be source\" },\n      { icon: \"D\", className: \"secondary\", label: \"Can be destination\" },\n      { icon: \"B\", className: \"both\", label: \"Both source and destination\" },\n      { icon: \"-\", className: \"none\", label: \"Not allowed\" },\n    ],\n    []\n  );\n\n  return (\n    <CoverageMatrix\n      rows={rows}\n      columns={columns}\n      getCellValue={getCellValue}\n      getCellDisplay={getCellDisplay}\n      onRowClick={handleRowClick}\n      title=\"Relationship \u00d7 Entity Kind Matrix\"\n      subtitle=\"Shows which entity kinds can participate in each relationship as source (S), destination (D), or both (B). Click a row to navigate to that relationship.\"\n      stats={stats}\n      legend={legend}\n      searchPlaceholder=\"Search relationships...\"\n      groupByField={null}\n      emptyMessage=\"No relationship kinds defined.\"\n      filterOptions={filterOptions}\n    />\n  );\n}", "parameters": [{"name": "{\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}", "type": "{ relationshipKinds?: any[]; entityKinds?: any[]; onNavigateToRelationship: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx", "sourceCode": "export default function TagRegistryEditor({\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}) {\n  const [expandedTags, setExpandedTags] = useState({});\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [categoryFilter, setCategoryFilter] = useState(\"all\");\n  const [rarityFilter, setRarityFilter] = useState(\"all\");\n\n  // Compute stats\n  const stats = useMemo(() => {\n    const byCategory = {};\n    const byRarity = {};\n    CATEGORIES.forEach((c) => (byCategory[c] = 0));\n    RARITIES.forEach((r) => (byRarity[r] = 0));\n    tagRegistry.forEach((tag) => {\n      byCategory[tag.category] = (byCategory[tag.category] || 0) + 1;\n      byRarity[tag.rarity] = (byRarity[tag.rarity] || 0) + 1;\n    });\n    return { total: tagRegistry.length, byCategory, byRarity };\n  }, [tagRegistry]);\n\n  // Filter tags\n  const filteredTags = useMemo(() => {\n    return tagRegistry.filter((tag) => {\n      const matchesSearch =\n        !searchQuery ||\n        tag.tag.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        tag.description?.toLowerCase().includes(searchQuery.toLowerCase());\n      const matchesCategory = categoryFilter === \"all\" || tag.category === categoryFilter;\n      const matchesRarity = rarityFilter === \"all\" || tag.rarity === rarityFilter;\n      return matchesSearch && matchesCategory && matchesRarity;\n    });\n  }, [tagRegistry, searchQuery, categoryFilter, rarityFilter]);\n\n  const toggleTag = useCallback((tagId) => {\n    setExpandedTags((prev) => ({ ...prev, [tagId]: !prev[tagId] }));\n  }, []);\n\n  const addTag = () => {\n    const newTag = {\n      tag: `new_tag_${Date.now()}`,\n      category: \"trait\",\n      rarity: \"common\",\n      description: \"New tag description\",\n      usageCount: 0,\n      templates: [],\n      entityKinds: [],\n      minUsage: 1,\n      maxUsage: 50,\n      relatedTags: [],\n      conflictingTags: [],\n    };\n    onChange([newTag, ...tagRegistry]);\n    setExpandedTags((prev) => ({ ...prev, [newTag.tag]: true }));\n  };\n\n  const updateTag = (tagId, updates) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    onChange(tagRegistry.map((t) => (t.tag === tagId ? { ...t, ...updates } : t)));\n  };\n\n  const renderTagTitle = (tag) => <span className=\"tre-monospace\">{tag.tag}</span>;\n\n  const renderTagActions = (tag, catColor, rarColor, isFramework) => (\n    <>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': catColor.bg, '--tre-badge-color': catColor.color }}>\n        {tag.category}\n      </span>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': rarColor.bg, '--tre-badge-color': rarColor.color }}>\n        {tag.rarity}\n      </span>\n      {tag.isAxis && (\n        <span\n          className=\"badge tre-badge-dynamic\"\n          style={{ '--tre-badge-bg': 'rgba(34, 211, 238, 0.2)', '--tre-badge-color': '#22d3ee' }}\n        >\n          \u2194 axis\n        </span>\n      )}\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {tagUsage[tag.tag] && <UsageBadges usage={tagUsage[tag.tag]} compact />}\n      <span className=\"text-muted text-small\">\n        {tag.minUsage || 0}-{tag.maxUsage || \"\u221e\"} | {(tag.entityKinds || []).length} kinds\n      </span>\n    </>\n  );\n\n  const deleteTag = (tagId) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this tag? This cannot be undone.\")) {\n      onChange(tagRegistry.filter((t) => t.tag !== tagId));\n    }\n  };\n\n  // Related tags management\n  const removeRelatedTag = (tagId, relatedTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, { relatedTags: (tag.relatedTags || []).filter((r) => r !== relatedTag) });\n  };\n\n  // Conflicting tags management\n  const removeConflictingTag = (tagId, conflictingTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, {\n      conflictingTags: (tag.conflictingTags || []).filter((c) => c !== conflictingTag),\n    });\n  };\n\n  const allTagNames = useMemo(() => tagRegistry.map((t) => t.tag), [tagRegistry]);\n\n  const handleTagIdChange = (oldId, newId) => {\n    const updatedRegistry = tagRegistry.map((t) => {\n      if (t.tag === oldId) return { ...t, tag: newId };\n      const updated = { ...t };\n      if (t.relatedTags?.includes(oldId)) {\n        updated.relatedTags = t.relatedTags.map((r) =>\n          r === oldId ? newId : r\n        );\n      }\n      if (t.conflictingTags?.includes(oldId)) {\n        updated.conflictingTags = t.conflictingTags.map((c) =>\n          c === oldId ? newId : c\n        );\n      }\n      return updated;\n    });\n    setExpandedTags((prev) => {\n      const updated = { ...prev };\n      if (updated[oldId]) {\n        updated[newId] = updated[oldId];\n        delete updated[oldId];\n      }\n      return updated;\n    });\n    onChange(updatedRegistry);\n  };\n\n  const handleEntityKindToggle = (tag, ek, isFramework) => {\n    if (isFramework) return;\n    const isSelected = (tag.entityKinds || []).includes(ek.kind);\n    const current = tag.entityKinds || [];\n    const updated = isSelected\n      ? current.filter((k) => k !== ek.kind)\n      : [...current, ek.kind];\n    updateTag(tag.tag, { entityKinds: updated });\n  };\n\n  return (\n    <div className=\"editor-container tre-container\">\n      <SectionHeader\n        title=\"Tag Registry\"\n        description=\"Define tags that categorize entities. Tags provide governance through usage limits, relationships, and conflicts.\"\n      />\n\n      {/* Stats Bar - Compact */}\n      <div className=\"tre-stats-bar\">\n        <span className=\"text-small tre-stat-total\">\n          <strong>{stats.total}</strong> tags\n        </span>\n        {CATEGORIES.filter((cat) => stats.byCategory[cat] > 0).map((cat) => (\n          <span\n            key={cat}\n            className=\"text-small tre-stat-category\"\n            style={{\n              '--tre-stat-bg': CATEGORY_COLORS[cat].bg,\n              '--tre-stat-color': CATEGORY_COLORS[cat].color,\n            }}\n          >\n            {stats.byCategory[cat]} {cat}\n          </span>\n        ))}\n      </div>\n\n      {/* Toolbar */}\n      <div className=\"tre-toolbar\">\n        <input\n          className=\"input tre-search\"\n          type=\"text\"\n          placeholder=\"Search tags...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n        />\n        <select\n          className=\"input\"\n          value={categoryFilter}\n          onChange={(e) => setCategoryFilter(e.target.value)}\n        >\n          <option value=\"all\">All Categories</option>\n          {CATEGORIES.map((cat) => (\n            <option key={cat} value={cat}>\n              {cat}\n            </option>\n          ))}\n        </select>\n        <select\n          className=\"input\"\n          value={rarityFilter}\n          onChange={(e) => setRarityFilter(e.target.value)}\n        >\n          <option value=\"all\">All Rarities</option>\n          {RARITIES.map((r) => (\n            <option key={r} value={r}>\n              {r}\n            </option>\n          ))}\n        </select>\n        <span className=\"text-muted\">\n          {filteredTags.length} of {tagRegistry.length} tags\n        </span>\n        <button className=\"btn btn-primary\" onClick={addTag}>\n          + Add Tag\n        </button>\n      </div>\n\n      {tagRegistry.length === 0 && (\n        <EmptyState icon=\"\ud83c\udff7\ufe0f\" title=\"No tags defined\" description=\"Add one to get started.\" />\n      )}\n      {tagRegistry.length > 0 && filteredTags.length === 0 && (\n        <EmptyState icon=\"\ud83d\udd0d\" title=\"No matches\" description=\"No tags match your filters.\" />\n      )}\n      {filteredTags.length > 0 && (\n        <div className=\"list-stack\">\n          {filteredTags.map((tag) => {\n            const isExpanded = expandedTags[tag.tag];\n            const catColor = CATEGORY_COLORS[tag.category] || CATEGORY_COLORS.trait;\n            const rarColor = RARITY_COLORS[tag.rarity] || RARITY_COLORS.common;\n            const isFramework = Boolean(tag.isFramework);\n\n            return (\n              <ExpandableCard\n                key={tag.tag}\n                expanded={isExpanded}\n                onToggle={toggleTag}\n                toggleId={tag.tag}\n                title={renderTagTitle(tag)}\n                actions={renderTagActions(tag, catColor, rarColor, isFramework)}\n              >\n                {/* Basic Info Row */}\n                <div className=\"tre-basic-row\">\n                  <div className=\"tre-field-id\">\n                    <div className=\"label tre-label-gap\">\n                      Tag ID\n                    </div>\n                    <TagIdInput\n                      value={tag.tag}\n                      allTagIds={allTagNames.filter((t) => t !== tag.tag)}\n                      disabled={isFramework}\n                      onChange={(newId) => handleTagIdChange(tag.tag, newId)}\n                    />\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Category\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.category}\n                      onChange={(e) => updateTag(tag.tag, { category: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {CATEGORIES.map((cat) => (\n                        <option key={cat} value={cat}>\n                          {cat}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Rarity\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.rarity}\n                      onChange={(e) => updateTag(tag.tag, { rarity: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {RARITIES.map((r) => (\n                        <option key={r} value={r}>\n                          {r}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div className=\"tre-axis-group\">\n                    <label className=\"tre-axis-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={tag.isAxis || false}\n                        disabled={isFramework}\n                        onChange={(e) => updateTag(tag.tag, { isAxis: e.target.checked })}\n                        className=\"tre-checkbox\"\n                      />\n// ... (truncated)", "parameters": [{"name": "{\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}", "type": "{ tagRegistry?: any[]; entityKinds?: any[]; onChange: any; tagUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}]