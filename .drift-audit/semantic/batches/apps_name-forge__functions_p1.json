[{"id": "apps/name-forge/lib/derivation.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType"}, {"id": "apps/name-forge/lib/generate.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>"}, {"id": "apps/name-forge/lib/generate.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/name-forge/lib/generate.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/generate.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult"}, {"id": "apps/name-forge/lib/generate.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/name-forge/lib/index.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>"}, {"id": "apps/name-forge/lib/index.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/name-forge/lib/index.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult"}, {"id": "apps/name-forge/lib/index.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/name-forge/lib/index.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult"}, {"id": "apps/name-forge/lib/index.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }"}, {"id": "apps/name-forge/lib/index.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/index.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }"}, {"id": "apps/name-forge/lib/index.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/name-forge/lib/index.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number"}, {"id": "apps/name-forge/lib/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/index.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/index.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType"}, {"id": "apps/name-forge/lib/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport"}, {"id": "apps/name-forge/lib/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport"}, {"id": "apps/name-forge/lib/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport"}, {"id": "apps/name-forge/lib/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}"}, {"id": "apps/name-forge/lib/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]"}, {"id": "apps/name-forge/lib/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}"}, {"id": "apps/name-forge/lib/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector"}, {"id": "apps/name-forge/lib/index.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}"}, {"id": "apps/name-forge/lib/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/markov-loader-node.ts::loadModelFromFilesystem", "name": "loadModelFromFilesystem", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader-node.ts", "sourceCode": "/**\r\n * Load a model from the filesystem.\r\n */\r\nexport function loadModelFromFilesystem(modelId: string): MarkovModel | null {\r\n  const modelPath = path.join(modelsDir, `${modelId}.json`);\r\n\r\n  if (!fs.existsSync(modelPath)) {\r\n    console.warn(`Markov model '${modelId}' not found at ${modelPath}`);\r\n    return null;\r\n  }\r\n\r\n  const data = fs.readFileSync(modelPath, \"utf-8\");\r\n  return JSON.parse(data) as MarkovModel;\r\n}", "parameters": [{"name": "modelId", "type": "string", "optional": false}], "returnType": "MarkovModel | null"}, {"id": "apps/name-forge/lib/markov-loader.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/name-forge/lib/markov-loader.ts::loadMarkovModel", "name": "loadMarkovModel", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Load a Markov model by ID.\r\n */\r\nexport async function loadMarkovModel(\r\n  modelId: MarkovModelId\r\n): Promise<MarkovModel | null> {\r\n  // Check cache first\r\n  if (modelCache.has(modelId)) {\r\n    return modelCache.get(modelId)!;\r\n  }\r\n\r\n  try {\r\n    const model = isBrowser\r\n      ? await loadFromBrowser(modelId)\r\n      : await loadFromNode(modelId);\r\n\r\n    if (model) {\r\n      modelCache.set(modelId, model);\r\n    }\r\n    return model;\r\n  } catch (error) {\r\n    console.warn(`Failed to load Markov model '${modelId}':`, error);\r\n    return null;\r\n  }\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "Promise<MarkovModel | null>"}, {"id": "apps/name-forge/lib/markov-loader.ts::extractMarkovModelIds", "name": "extractMarkovModelIds", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Grammar Scanning\r\n// ============================================================================\r\n\r\n/**\r\n * Extract Markov model IDs referenced in grammars.\r\n */\r\nexport function extractMarkovModelIds(grammars: Grammar[]): MarkovModelId[] {\r\n  const modelIds = new Set<MarkovModelId>();\r\n\r\n  for (const grammar of grammars) {\r\n    for (const productions of Object.values(grammar.rules || {})) {\r\n      for (const production of productions) {\r\n        for (const token of production) {\r\n          const match = token.match(/markov:([a-z]+)/);\r\n          if (match) {\r\n            modelIds.add(match[1] as MarkovModelId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(modelIds);\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "MarkovModelId[]"}, {"id": "apps/name-forge/lib/markov-loader.ts::preloadModels", "name": "preloadModels", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Preloading\r\n// ============================================================================\r\n\r\n/**\r\n * Preload all Markov models referenced in grammars.\r\n */\r\nexport async function preloadModels(\r\n  grammars: Grammar[]\r\n): Promise<Map<string, MarkovModel>> {\r\n  const modelIds = extractMarkovModelIds(grammars);\r\n  const models = new Map<string, MarkovModel>();\r\n\r\n  await Promise.all(\r\n    modelIds.map(async (id) => {\r\n      const model = await loadMarkovModel(id);\r\n      if (model) {\r\n        models.set(id, model);\r\n      }\r\n    })\r\n  );\r\n\r\n  return models;\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "Promise<Map<string, MarkovModel>>"}, {"id": "apps/name-forge/lib/markov-loader.ts::isModelCached", "name": "isModelCached", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Cache Management\r\n// ============================================================================\r\n\r\n/**\r\n * Check if a model is cached.\r\n */\r\nexport function isModelCached(modelId: MarkovModelId): boolean {\r\n  return modelCache.has(modelId);\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/markov-loader.ts::clearModelCache", "name": "clearModelCache", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Clear the model cache.\r\n */\r\nexport function clearModelCache(): void {\r\n  modelCache.clear();\r\n}", "parameters": [], "returnType": "void"}, {"id": "apps/name-forge/lib/markov.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/markov.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphologyBest", "name": "applyMorphologyBest", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphology with multiple candidates and pick best\r\n * Useful for avoiding overly long or awkward combinations\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphologyBest(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  candidateCount: number = 3,\r\n  maxLength: number = 20,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const candidates: {\r\n    result: string;\r\n    structure: string;\r\n    parts: string[];\r\n    syllables: string[];\r\n    score: number;\r\n  }[] = [];\r\n\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    const morphed = applyMorphology(rng, root, profile, rootSyllables);\r\n\r\n    // Score based on length (prefer moderate length)\r\n    let score = 1.0;\r\n    if (morphed.result.length > maxLength) {\r\n      score *= 0.5; // Penalize overly long names\r\n    }\r\n    if (morphed.result.length < 3) {\r\n      score *= 0.5; // Penalize overly short names\r\n    }\r\n\r\n    candidates.push({ ...morphed, score });\r\n  }\r\n\r\n  // Pick weighted by score\r\n  const scores = candidates.map((c) => c.score);\r\n  const totalScore = scores.reduce((sum, s) => sum + s, 0);\r\n\r\n  const r = rng() * totalScore;\r\n  let cumulative = 0;\r\n  for (const candidate of candidates) {\r\n    cumulative += candidate.score;\r\n    if (r < cumulative) {\r\n      return {\r\n        result: candidate.result,\r\n        structure: candidate.structure,\r\n        parts: candidate.parts,\r\n        syllables: candidate.syllables,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return {\r\n    result: candidates[0].result,\r\n    structure: candidates[0].structure,\r\n    parts: candidates[0].parts,\r\n    syllables: candidates[0].syllables,\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}, {"name": "maxLength", "type": "number", "optional": true}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/morphology.ts::canApplyMorphology", "name": "canApplyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Check if a morphology profile can actually modify names\r\n * (i.e., has at least some affixes or structures beyond \"root\")\r\n */\r\nexport function canApplyMorphology(profile: MorphologyProfile): boolean {\r\n  // Check if there are any non-root structures\r\n  const hasComplexStructures = profile.structure.some(\r\n    (s) => s !== \"root\" && s.includes(\"-\")\r\n  );\r\n\r\n  if (!hasComplexStructures) {\r\n    return false;\r\n  }\r\n\r\n  // Check if there are any affixes available\r\n  const hasAffixes =\r\n    (profile.prefixes && profile.prefixes.length > 0) ||\r\n    (profile.suffixes && profile.suffixes.length > 0) ||\r\n    (profile.infixes && profile.infixes.length > 0) ||\r\n    (profile.wordRoots && profile.wordRoots.length > 0);\r\n\r\n  return Boolean(hasAffixes);\r\n}", "parameters": [{"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/morphology.ts::generateCompound", "name": "generateCompound", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Generate a compound name (root-root structure)\r\n * Useful for location names and titles\r\n */\r\nexport function generateCompound(\r\n  rng: () => number,\r\n  root1: string,\r\n  root2: string,\r\n  separator: string = \"\"\r\n): string {\r\n  return root1 + separator + root2;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root1", "type": "string", "optional": false}, {"name": "root2", "type": "string", "optional": false}, {"name": "separator", "type": "string", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/morphology.ts::applyHonorific", "name": "applyHonorific", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply honorific prefix\r\n */\r\nexport function applyHonorific(\r\n  rng: () => number,\r\n  name: string,\r\n  profile: MorphologyProfile\r\n): string {\r\n  if (!profile.honorifics || profile.honorifics.length === 0) {\r\n    return name;\r\n  }\r\n\r\n  const honorific = pickRandom(rng, profile.honorifics);\r\n  return `${honorific} ${name}`;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllConsonants", "name": "getAllConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all consonants as flat array\n */\nexport function getAllConsonants(): string[] {\n  const all: string[] = [];\n  all.push(...CONSONANT_LIBRARY.plosives.voiceless);\n  all.push(...CONSONANT_LIBRARY.plosives.voiced);\n  all.push(...CONSONANT_LIBRARY.nasals);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiceless);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiced);\n  all.push(...CONSONANT_LIBRARY.affricates);\n  all.push(...CONSONANT_LIBRARY.approximants);\n  all.push(...CONSONANT_LIBRARY.trills);\n  all.push(...CONSONANT_LIBRARY.fantasy);\n  return [...new Set(all)]; // Remove duplicates\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllVowels", "name": "getAllVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all vowels as flat array\n */\nexport function getAllVowels(): string[] {\n  const all: string[] = [];\n  all.push(...VOWEL_LIBRARY.basic);\n  all.push(...VOWEL_LIBRARY.front);\n  all.push(...VOWEL_LIBRARY.central);\n  all.push(...VOWEL_LIBRARY.back);\n  all.push(...VOWEL_LIBRARY.long);\n  all.push(...VOWEL_LIBRARY.umlauts);\n  all.push(...VOWEL_LIBRARY.diphthongs);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllTemplates", "name": "getAllTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all templates as flat array\n */\nexport function getAllTemplates(): string[] {\n  const all: string[] = [];\n  all.push(...TEMPLATE_LIBRARY.simple);\n  all.push(...TEMPLATE_LIBRARY.complexOnset);\n  all.push(...TEMPLATE_LIBRARY.complexCoda);\n  all.push(...TEMPLATE_LIBRARY.complex);\n  all.push(...TEMPLATE_LIBRARY.vowelHeavy);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllClusters", "name": "getAllClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all clusters as flat array\n */\nexport function getAllClusters(): string[] {\n  const all: string[] = [];\n  all.push(...CLUSTER_LIBRARY.onsets.stopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.sStop);\n  all.push(...CLUSTER_LIBRARY.onsets.sStopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.other);\n  all.push(...CLUSTER_LIBRARY.codas.liquidStop);\n  all.push(...CLUSTER_LIBRARY.codas.nasalStop);\n  all.push(...CLUSTER_LIBRARY.codas.stopS);\n  all.push(...CLUSTER_LIBRARY.codas.other);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllStructures", "name": "getAllStructures", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all structures as flat array\n */\nexport function getAllStructures(): string[] {\n  const all: string[] = [];\n  all.push(...STRUCTURE_LIBRARY.simple);\n  all.push(...STRUCTURE_LIBRARY.prefixed);\n  all.push(...STRUCTURE_LIBRARY.suffixed);\n  all.push(...STRUCTURE_LIBRARY.compound);\n  all.push(...STRUCTURE_LIBRARY.complex);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableConsonants", "name": "getAvailableConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get phonemes not currently in a domain\n */\nexport function getAvailableConsonants(currentConsonants: string[]): string[] {\n  const all = getAllConsonants();\n  return all.filter(c => !currentConsonants.includes(c));\n}", "parameters": [{"name": "currentConsonants", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableVowels", "name": "getAvailableVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableVowels(currentVowels: string[]): string[] {\n  const all = getAllVowels();\n  return all.filter(v => !currentVowels.includes(v));\n}", "parameters": [{"name": "currentVowels", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableTemplates", "name": "getAvailableTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableTemplates(currentTemplates: string[]): string[] {\n  const all = getAllTemplates();\n  return all.filter(t => !currentTemplates.includes(t));\n}", "parameters": [{"name": "currentTemplates", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableClusters", "name": "getAvailableClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableClusters(currentClusters: string[]): string[] {\n  const all = getAllClusters();\n  return all.filter(c => !currentClusters.includes(c));\n}", "parameters": [{"name": "currentClusters", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phonology.ts::generateSyllable", "name": "generateSyllable", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a single syllable from a phonology profile\r\n */\r\nexport function generateSyllable(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): SyllableResult {\r\n  // Pick a syllable template\r\n  const template = pickWeighted(\r\n    rng,\r\n    profile.syllableTemplates,\r\n    profile.templateWeights\r\n  );\r\n\r\n  // Build syllable by replacing C and V with phonemes\r\n  let syllable = \"\";\r\n  for (const symbol of template) {\r\n    if (symbol === \"C\") {\r\n      // Pick a consonant\r\n      const consonant = pickWeighted(\r\n        rng,\r\n        profile.consonants,\r\n        profile.consonantWeights\r\n      );\r\n      syllable += consonant;\r\n    } else if (symbol === \"V\") {\r\n      // Pick a vowel\r\n      const vowel = pickWeighted(rng, profile.vowels, profile.vowelWeights);\r\n      syllable += vowel;\r\n    } else {\r\n      // Literal character (for templates like \"CVC-\")\r\n      syllable += symbol;\r\n    }\r\n  }\r\n\r\n  return { syllable, template };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "SyllableResult"}, {"id": "apps/name-forge/lib/phonology.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/phonology.ts::generateWordWithFavoredClusters", "name": "generateWordWithFavoredClusters", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate multiple word candidates and pick the best one based on favored clusters\r\n */\r\nexport function generateWordWithFavoredClusters(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  candidateCount: number = 5\r\n): string {\r\n  // If no favored clusters, just generate one word\r\n  if (!profile.favoredClusters || profile.favoredClusters.length === 0) {\r\n    return generateWord(rng, profile);\r\n  }\r\n\r\n  // Generate multiple candidates\r\n  const candidates: string[] = [];\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    candidates.push(generateWord(rng, profile));\r\n  }\r\n\r\n  // Calculate scores based on favored clusters\r\n  const boost = profile.favoredClusterBoost ?? 2.0;\r\n  const scores = candidates.map((word) => {\r\n    const hasFavored = hasFavoredCluster(word, profile.favoredClusters!);\r\n    return hasFavored ? boost : 1.0;\r\n  });\r\n\r\n  // Pick a candidate weighted by scores\r\n  return pickWeighted(rng, candidates, scores);\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/phonology.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]"}]