[{"id": "apps/lore-weave/lib/index.ts::generateId", "name": "generateId", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function generateId(prefix: string): string {\n  return `${prefix}_${idCounter++}`;\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function pickRandom<T>(array: T[]): T {\r\n  return array[Math.floor(secureRandom() * array.length)];\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/lore-weave/lib/index.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function pickMultiple<T>(array: T[], count: number): T[] {\r\n  const shuffled = shuffle(array);\r\n  return shuffled.slice(0, Math.min(count, array.length));\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]"}, {"id": "apps/lore-weave/lib/index.ts::findEntities", "name": "findEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Find entities matching criteria\r\n */\r\nexport function findEntities(\r\n  graph: Graph,\r\n  criteria: Partial<HardState>\r\n): HardState[] {\r\n  const results: HardState[] = [];\r\n\r\n  graph.forEachEntity(entity => {\r\n    let matches = true;\r\n\r\n    for (const [key, value] of Object.entries(criteria)) {\r\n      if (entity[key as keyof HardState] !== value) {\r\n        matches = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches) {\r\n      results.push(entity);\r\n    }\r\n  });\r\n\r\n  return results;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "criteria", "type": "Partial<HardState>", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::getRelated", "name": "getRelated", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get related entities via relationships\r\n */\r\nexport function getRelated(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipKind?: string,\r\n  direction: 'src' | 'dst' | 'both' = 'both',\r\n  options?: RelationshipQueryOptions\r\n): HardState[] {\r\n  const related: Array<{ entity: HardState; strength: number }> = [];\r\n  const opts = options || {};\r\n\r\n  graph.getRelationships().forEach(rel => {\r\n    if (relationshipKind && rel.kind !== relationshipKind) return;\r\n\r\n    // Strength filtering\r\n    const strength = rel.strength ?? 0.5;\r\n    if (opts.minStrength !== undefined && strength < opts.minStrength) return;\r\n    if (opts.maxStrength !== undefined && strength > opts.maxStrength) return;\r\n\r\n    if ((direction === 'src' || direction === 'both') && rel.src === entityId) {\r\n      const entity = graph.getEntity(rel.dst);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n\r\n    if ((direction === 'dst' || direction === 'both') && rel.dst === entityId) {\r\n      const entity = graph.getEntity(rel.src);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n  });\r\n\r\n  // Sort by strength if requested\r\n  if (opts.sortByStrength) {\r\n    related.sort((a, b) => b.strength - a.strength);\r\n  }\r\n\r\n  return related.map(r => r.entity);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": true}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}, {"name": "options", "type": "RelationshipQueryOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function hasRelationship(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind?: string\r\n): boolean {\r\n  return graph.getRelationships().some(rel =>\r\n    rel.src === srcId &&\r\n    rel.dst === dstId &&\r\n    (!kind || rel.kind === kind)\r\n  );\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::normalizeInitialState", "name": "normalizeInitialState", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function normalizeInitialState(entities: RawEntityInput[]): HardState[] {\n  return entities.map((entity, index) => {\n    if (!entity.id) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no id. ` +\n        `Seed entities must include a stable id used by relationships.`\n      );\n    }\n    if (!entity.name) {\n      throw new Error(\n        `normalizeInitialState: entity at index ${index} has no name. ` +\n        `Initial state entities must have names defined in JSON.`\n      );\n    }\n    if (!entity.coordinates) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no coordinates. ` +\n        `Initial state entities must have coordinates defined in JSON.`\n      );\n    }\n    if (!entity.kind) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no kind.`\n      );\n    }\n    if (!entity.subtype) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no subtype.`\n      );\n    }\n    if (!entity.status) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no status.`\n      );\n    }\n    if (!entity.prominence) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no prominence.`\n      );\n    }\n    if (!entity.culture) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no culture.`\n      );\n    }\n\n    // Handle both old array format and new KVP format for tags\n    let tags: EntityTags;\n    if (Array.isArray(entity.tags)) {\n      tags = arrayToTags(entity.tags);\n    } else {\n      tags = entity.tags || {};\n    }\n\n    const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n    return {\n      id: entity.id,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      name: entity.name,\n      summary: entity.summary,\n      narrativeHint,\n      description: entity.description || '',\n      status: entity.status,\n      prominence: entity.prominence,\n      culture: entity.culture,\n      tags,\n      createdAt: 0,\n      updatedAt: 0,\n      coordinates: entity.coordinates\n    };\n  });\n}", "parameters": [{"name": "entities", "type": "RawEntityInput[]", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::slugifyName", "name": "slugifyName", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Slugify a name for use in IDs or other contexts\n */\nexport function slugifyName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '') || 'unknown'; // eslint-disable-line sonarjs/slow-regex -- short slug string, no ReDoS risk\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/index.ts::generateEntityIdFromName", "name": "generateEntityIdFromName", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Generate a stable entity ID from a name, with optional collision handling.\n */\nexport function generateEntityIdFromName(\n  name: string,\n  hasEntity?: (id: string) => boolean,\n  log?: (message: string, context?: Record<string, unknown>) => void\n): string {\n  const baseId = slugifyName(name);\n  if (!hasEntity) return baseId;\n  if (!hasEntity(baseId)) return baseId;\n\n  let suffix = 2;\n  let candidate = `${baseId}-${suffix}`;\n  while (hasEntity(candidate)) {\n    suffix += 1;\n    candidate = `${baseId}-${suffix}`;\n  }\n\n  log?.(`Entity id collision for \"${name}\". Using \"${candidate}\".`, {\n    name,\n    baseId,\n    resolvedId: candidate\n  });\n\n  return candidate;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "hasEntity", "type": "(id: string) => boolean", "optional": true}, {"name": "log", "type": "(message: string, context?: Record<string, unknown>) => void", "optional": true}], "returnType": "string"}, {"id": "apps/lore-weave/lib/index.ts::archiveRelationship", "name": "archiveRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Archive a relationship by marking it as historical.\r\n */\r\nexport function archiveRelationship(\r\n  graph: Graph,\r\n  src: string,\r\n  dst: string,\r\n  kind: string,\r\n  reason?: string\r\n): void {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === src &&\r\n    r.dst === dst &&\r\n    r.kind === kind &&\r\n    r.status !== 'historical'\r\n  );\r\n\r\n  if (rel) {\r\n    const age = graph.tick - (rel.createdAt ?? 0);\r\n    rel.status = 'historical';\r\n    rel.archivedAt = graph.tick;\r\n\r\n    // Record archival for context-based event generation\r\n    graph.mutationTracker?.recordRelationshipArchived({\r\n      srcId: src,\r\n      dstId: dst,\r\n      kind,\r\n      age,\r\n      reason,\r\n    });\r\n  }\r\n\r\n  const srcEntity = graph.getEntity(src);\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  const dstEntity = graph.getEntity(dst);\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "reason", "type": "string", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::modifyRelationshipStrength", "name": "modifyRelationshipStrength", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Modify relationship strength by delta\r\n */\r\nexport function modifyRelationshipStrength(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind: string,\r\n  delta: number\r\n): boolean {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === srcId && r.dst === dstId && r.kind === kind\r\n  );\r\n\r\n  if (!rel) return false;\r\n\r\n  const currentStrength = rel.strength ?? 0.5;\r\n  rel.strength = Math.max(0.0, Math.min(1.0, currentStrength + delta));\r\n\r\n  const srcEntity = graph.getEntity(srcId);\r\n  const dstEntity = graph.getEntity(dstId);\r\n\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  return true;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "delta", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::mergeTags", "name": "mergeTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Merge multiple tag objects. Later tags override earlier ones.\r\n */\r\nexport function mergeTags(...tagSets: (EntityTags | undefined)[]): EntityTags {\r\n  const result: EntityTags = {};\r\n  for (const tags of tagSets) {\r\n    if (tags) {\r\n      Object.assign(result, tags);\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "tagSets", "type": "(EntityTags | undefined)[]", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/index.ts::hasTag", "name": "hasTag", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if an entity has a specific tag.\r\n * @param tags - The entity's tags\r\n * @param key - The tag key to check\r\n * @param value - Optional: specific value to match (if not provided, checks key existence)\r\n */\r\nexport function hasTag(tags: EntityTags | undefined, key: string, value?: string | boolean): boolean {\r\n  if (!tags) return false;\r\n  if (!(key in tags)) return false;\r\n  if (value === undefined) return true;\r\n  return tags[key] === value;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "value", "type": "string | boolean", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::getTagValue", "name": "getTagValue", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get a tag's value, with optional default.\r\n */\r\nexport function getTagValue<T extends string | boolean>(\r\n  tags: EntityTags | undefined,\r\n  key: string,\r\n  defaultValue?: T\r\n): T | undefined {\r\n  if (!tags || !(key in tags)) return defaultValue;\r\n  return tags[key] as T;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "defaultValue", "type": "T", "optional": true}], "returnType": "T | undefined"}, {"id": "apps/lore-weave/lib/index.ts::getTrueTagKeys", "name": "getTrueTagKeys", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get all tag keys that have truthy values.\r\n */\r\nexport function getTrueTagKeys(tags: EntityTags | undefined): string[] {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => value === true)\r\n    .map(([key]) => key);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "string[]"}, {"id": "apps/lore-weave/lib/index.ts::getStringTags", "name": "getStringTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get all string-valued tags as key-value entries.\r\n */\r\nexport function getStringTags(tags: EntityTags | undefined): Array<[string, string]> {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => typeof value === 'string')\r\n    .map(([key, value]) => [key, value as string]);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "Array<[string, string]>"}, {"id": "apps/lore-weave/lib/index.ts::arrayToTags", "name": "arrayToTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Convert array tags to EntityTags (KVP) format.\r\n * Plain strings become boolean true, \"key:value\" becomes string value.\r\n */\r\nexport function arrayToTags(arr: string[] | undefined): EntityTags {\r\n  if (!arr) return {};\r\n  const result: EntityTags = {};\r\n  for (const tag of arr) {\r\n    if (tag.startsWith('!')) {\r\n      result[tag.slice(1)] = false;\r\n    } else if (tag.includes(':')) {\r\n      const [key, ...valueParts] = tag.split(':');\r\n      result[key] = valueParts.join(':');\r\n    } else {\r\n      result[tag] = true;\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "arr", "type": "string[] | undefined", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/index.ts::rollProbability", "name": "rollProbability", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if a probabilistic event should occur, scaled by an era modifier.\r\n *\r\n * @param baseProbability - Base chance of the event occurring (0.0 to 1.0)\r\n *                         e.g., 0.3 = 30% chance\r\n * @param eraModifier - Era-based multiplier for the probability\r\n *                      > 1 increases likelihood, < 1 decreases it\r\n * @returns true if the event should occur\r\n *\r\n * @example\r\n * // 30% base chance, doubled in conflict era (modifier = 2)\r\n * if (rollProbability(0.3, eraModifier)) {\r\n *   createConflict();\r\n * }\r\n */\r\nexport function rollProbability(baseProbability: number, eraModifier: number = 1.0): boolean {\r\n  const p = baseProbability;\r\n\r\n  // Edge cases: probability of 0 or 1 should be deterministic\r\n  if (p <= 0) return false;\r\n  if (p >= 1) return true;\r\n\r\n  // odds scaling\r\n  const odds = p / (1 - p);\r\n  const scaledOdds = Math.pow(odds, eraModifier);\r\n  const scaledP = scaledOdds / (1 + scaledOdds);\r\n\r\n  return secureRandom() < scaledP;\r\n}", "parameters": [{"name": "baseProbability", "type": "number", "optional": false}, {"name": "eraModifier", "type": "number", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::addEntity", "name": "addEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export async function addEntity(graph: Graph, entity: Partial<HardState>, source?: string, placementStrategy?: string): Promise<string> {\n  validateEntityForAdd(entity);\n\n  const coords = entity.coordinates!;\n  const tags: EntityTags = Array.isArray(entity.tags) ? arrayToTags(entity.tags) : { ...(entity.tags || {}) };\n\n  const entityId = generateEntityIdFromName(entity.name!, id => graph.hasEntity(id));\n\n  // Delegate to Graph.createEntity()\n  // Use validated coords to satisfy TypeScript (already validated above)\n  if (typeof coords.z !== 'number') {\n    throw new Error(\n      `addEntity: coordinates must include numeric z. ` +\n      `Entity kind: ${entity.kind}, name: ${entity.name || 'unnamed'}. ` +\n      `Received: ${JSON.stringify(coords)}.`\n    );\n  }\n  const validCoords = { x: coords.x, y: coords.y, z: coords.z };\n\n  const currentEraEntity = entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA\n    ? graph.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0]\n    : undefined;\n  const explicitEraId = entity.eraId;\n  let resolvedEraId: string | undefined;\n  if (typeof explicitEraId === 'string' && explicitEraId) {\n    resolvedEraId = explicitEraId;\n  } else if (entity.kind === FRAMEWORK_ENTITY_KINDS.ERA) {\n    resolvedEraId = entity.subtype;\n  } else {\n    resolvedEraId = currentEraEntity?.id;\n  }\n\n  const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n  const createdId = await graph.createEntity({\n    id: entityId,\n    kind: entity.kind!,\n    subtype: entity.subtype!,\n    coordinates: validCoords,\n    tags,\n    eraId: resolvedEraId,\n    name: entity.name,\n    description: entity.description,\n    narrativeHint,\n    status: entity.status!,\n    prominence: entity.prominence!,\n    culture: entity.culture!,\n    temporal: entity.temporal,\n    source,\n    placementStrategy\n  });\n\n  // Create CREATED_DURING relationship to current era (unless entity is an era itself)\n  // This is a framework-level temporal relationship distinct from spatial \"originated_in\"\n  if (entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA && currentEraEntity) {\n    graph.addRelationship(\n      FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING,\n      entityId,\n      currentEraEntity.id,\n      FRAMEWORK_RELATIONSHIP_PROPERTIES[FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING].defaultStrength\n    );\n  }\n\n  return createdId;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "Partial<HardState>", "optional": false}, {"name": "source", "type": "string", "optional": true}, {"name": "placementStrategy", "type": "string", "optional": true}], "returnType": "Promise<string>"}, {"id": "apps/lore-weave/lib/index.ts::addRelationship", "name": "addRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP MUTATION\r\n// ===========================\r\n\r\n/**\r\n * Add a relationship between two entities.\r\n * Distance is ALWAYS computed from Euclidean distance between coordinates.\r\n */\r\nexport function addRelationship(\r\n  graph: Graph,\r\n  kind: string,\r\n  srcId: string,\r\n  dstId: string,\r\n  strength: number = 0.5\r\n): void {\r\n  graph.addRelationship(kind, srcId, dstId, strength);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::canFormRelationship", "name": "canFormRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP COOLDOWN\r\n// ===========================\r\n\r\n/**\r\n * Check if an entity can form a new relationship based on cooldown.\r\n */\r\nexport function canFormRelationship(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string,\r\n  cooldownTicks: number\r\n): boolean {\r\n  const entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n  if (!entityCooldowns) return true;\r\n\r\n  const lastFormationTick = entityCooldowns.get(relationshipType);\r\n  if (lastFormationTick === undefined) return true;\r\n\r\n  return (graph.tick - lastFormationTick) >= cooldownTicks;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}, {"name": "cooldownTicks", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::recordRelationshipFormation", "name": "recordRelationshipFormation", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Record that an entity has formed a relationship.\r\n */\r\nexport function recordRelationshipFormation(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string\r\n): void {\r\n  let entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n\r\n  if (!entityCooldowns) {\r\n    entityCooldowns = new Map();\r\n    graph.relationshipCooldowns.set(entityId, entityCooldowns);\r\n  }\r\n\r\n  entityCooldowns.set(relationshipType, graph.tick);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::getConnectionWeight", "name": "getConnectionWeight", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Calculate relationship formation weight based on existing connection count.\r\n * Favors underconnected entities to balance network density and prevent hubs.\r\n */\r\nexport function getConnectionWeight(graph: Graph, entity: HardState): number {\r\n  const connectionCount = graph.getEntityRelationships(entity.id, 'both').length;\r\n\r\n  // Boost isolated/underconnected entities\r\n  if (connectionCount === 0) return 3.0;    // Strongly boost isolated\r\n  if (connectionCount <= 2) return 2.0;     // Boost underconnected (below median)\r\n  if (connectionCount <= 5) return 1.0;     // Normal\r\n  if (connectionCount <= 10) return 0.5;    // Reduce well-connected\r\n  return 0.2;                               // Heavily reduce hubs (15+)\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/index.ts::validateWorld", "name": "validateWorld", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// validateLorePresence moved to @illuminator\n\n/**\n * Run all validators and generate a complete report\n */\nexport function validateWorld(graph: Graph, config: EngineConfig): ValidationReport {\n  const results: ValidationResult[] = [\n    validateConnectedEntities(graph),\n    validateNPCStructure(graph, config),\n    validateRelationshipIntegrity(graph)\n    // validateLorePresence moved to @illuminator\n  ];\n\n  const passed = results.filter(r => r.passed).length;\n  const failed = results.filter(r => !r.passed).length;\n\n  return {\n    totalChecks: results.length,\n    passed,\n    failed,\n    results\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationReport"}, {"id": "apps/lore-weave/lib/index.ts::calculateSimilarity", "name": "calculateSimilarity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Calculate similarity score between two entities based on criteria\n */\nexport function calculateSimilarity(\n  e1: HardState,\n  e2: HardState,\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime\n): { score: number; matchedCriteria: string[] } {\n  let score = 0;\n  const matchedCriteria: string[] = [];\n\n  for (const criterion of criteria) {\n    let matches = false;\n\n    switch (criterion.type) {\n      case 'shared_relationship': {\n        if (!criterion.relationshipKind) break;\n        const direction = criterion.direction || 'src';\n\n        const e1Related = graphView.getConnectedEntities(e1.id, criterion.relationshipKind, direction);\n        const e2Related = graphView.getConnectedEntities(e2.id, criterion.relationshipKind, direction);\n        const e1RelatedIds = new Set(e1Related.map(r => r.id));\n        matches = e2Related.some(r => e1RelatedIds.has(r.id));\n        break;\n      }\n\n      case 'shared_tags': {\n        const e1Tags = new Set(Object.keys(e1.tags || {}));\n        const e2Tags = new Set(Object.keys(e2.tags || {}));\n        const intersection = Array.from(e1Tags).filter(t => e2Tags.has(t)).length;\n        const union = new Set([...e1Tags, ...e2Tags]).size;\n        const jaccard = union > 0 ? intersection / union : 0;\n        matches = jaccard >= (criterion.threshold || 0.3);\n        break;\n      }\n\n      case 'temporal_proximity': {\n        const timeDiff = Math.abs(e1.createdAt - e2.createdAt);\n        matches = timeDiff <= (criterion.threshold || 30);\n        break;\n      }\n\n      case 'same_subtype': {\n        matches = e1.subtype === e2.subtype;\n        break;\n      }\n\n      case 'same_culture': {\n        matches = e1.culture === e2.culture;\n        break;\n      }\n\n      case 'custom': {\n        if (criterion.predicate) {\n          matches = criterion.predicate(e1, e2, graphView);\n        }\n        break;\n      }\n    }\n\n    if (matches) {\n      score += criterion.weight;\n      matchedCriteria.push(criterion.type);\n    }\n  }\n\n  return { score, matchedCriteria };\n}", "parameters": [{"name": "e1", "type": "HardState", "optional": false}, {"name": "e2", "type": "HardState", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "{ score: number; matchedCriteria: string[] }"}, {"id": "apps/lore-weave/lib/index.ts::detectClusters", "name": "detectClusters", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function detectClusters(\n  entities: HardState[],\n  config: ClusterConfig,\n  graphView: WorldRuntime\n): Cluster[] {\n  if (entities.length < config.minSize) {\n    return [];\n  }\n\n  // Sort by creation time (cluster chronologically related entities)\n  const sorted = [...entities].sort((a, b) => a.createdAt - b.createdAt);\n\n  // Greedy clustering: try to add each entity to an existing cluster or create new one\n  const clusters: Cluster[] = [];\n  const clusterJoinThreshold = config.clusterJoinThreshold ?? 0.7;\n\n  for (const entity of sorted) {\n    const matched = tryAddToExistingCluster(entity, clusters, config, clusterJoinThreshold, graphView);\n    if (!matched) {\n      clusters.push({\n        entities: [entity],\n        score: config.minimumScore,\n        matchedCriteria: []\n      });\n    }\n  }\n\n  // Filter clusters by minimum size and apply maximum size\n  const validClusters = clusters.filter(c => {\n    if (c.entities.length < config.minSize) return false;\n    if (config.maxSize && c.entities.length > config.maxSize) {\n      // Truncate cluster to max size (keep earliest created)\n      c.entities = c.entities.slice(0, config.maxSize);\n    }\n    return true;\n  });\n\n  return validClusters;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "config", "type": "ClusterConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "Cluster[]"}, {"id": "apps/lore-weave/lib/index.ts::filterClusterableEntities", "name": "filterClusterableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Filter entities that are eligible for clustering.\n * Excludes historical entities and meta-entities.\n *\n * @param entities - All entities to filter\n * @returns Filtered entities eligible for clustering\n */\nexport function filterClusterableEntities(entities: HardState[]): HardState[] {\n  return entities.filter(e =>\n    e.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    e.status !== FRAMEWORK_STATUS.SUBSUMED &&\n    !hasTag(e.tags, FRAMEWORK_TAGS.META_ENTITY)\n  );\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::findBestClusterMatch", "name": "findBestClusterMatch", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Find the best cluster match for a new entity.\n * Useful for deciding which existing cluster to add a new entity to.\n *\n * @param entity - Entity to find cluster for\n * @param clusters - Existing clusters\n * @param criteria - Similarity criteria\n * @param graphView - Graph view for relationship queries\n * @param minimumScore - Minimum score to be considered a match\n * @returns Best matching cluster or undefined\n */\nexport function findBestClusterMatch(\n  entity: HardState,\n  clusters: Cluster[],\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime,\n  minimumScore: number\n): Cluster | undefined {\n  let bestCluster: Cluster | undefined;\n  let bestScore = 0;\n\n  for (const cluster of clusters) {\n    let totalScore = 0;\n    let count = 0;\n\n    for (const member of cluster.entities) {\n      const { score } = calculateSimilarity(entity, member, criteria, graphView);\n      totalScore += score;\n      count++;\n    }\n\n    const avgScore = count > 0 ? totalScore / count : 0;\n\n    if (avgScore >= minimumScore && avgScore > bestScore) {\n      bestCluster = cluster;\n      bestScore = avgScore;\n    }\n  }\n\n  return bestCluster;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "clusters", "type": "Cluster[]", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "minimumScore", "type": "number", "optional": false}], "returnType": "Cluster | undefined"}, {"id": "apps/lore-weave/lib/index.ts::archiveEntity", "name": "archiveEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Mark an entity as historical and optionally archive its relationships.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity to archive\n * @param options - Archival options\n */\nexport function archiveEntity(\n  graph: Graph,\n  entityId: string,\n  options: ArchiveEntityOptions = {}\n): void {\n  const entity = graph.getEntity(entityId);\n  if (!entity) return;\n\n  const {\n    archiveRelationships: shouldArchiveRels = true,\n    excludeRelationshipKinds = [],\n    status = FRAMEWORK_STATUS.HISTORICAL\n  } = options;\n\n  // Mark entity as historical (use updateEntity to trigger mutation tracking)\n  graph.updateEntity(entityId, { status });\n\n  // Archive relationships if requested\n  if (shouldArchiveRels) {\n    const entityRelationships = graph.getRelationships().filter(r =>\n      (r.src === entityId || r.dst === entityId) &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n      !excludeRelationshipKinds.includes(r.kind)\n    );\n\n    entityRelationships.forEach(rel => {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::archiveEntities", "name": "archiveEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Archive multiple entities at once.\n *\n * @param graph - The world graph\n * @param entityIds - IDs of entities to archive\n * @param options - Archival options\n */\nexport function archiveEntities(\n  graph: Graph,\n  entityIds: string[],\n  options: ArchiveEntityOptions = {}\n): void {\n  entityIds.forEach(id => archiveEntity(graph, id, options));\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityIds", "type": "string[]", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::transferRelationships", "name": "transferRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Transfer relationships from source entities to a target entity.\n * Creates new relationships with the target and optionally archives originals.\n *\n * @param graph - The world graph\n * @param sourceIds - IDs of entities to transfer relationships from\n * @param targetId - ID of entity to transfer relationships to\n * @param options - Transfer options\n * @returns Number of relationships transferred\n */\nexport function transferRelationships(\n  graph: Graph,\n  sourceIds: string[],\n  targetId: string,\n  options: TransferRelationshipsOptions = {}\n): number {\n  const {\n    excludeKinds = [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n    sourceOnly = false,\n    destinationOnly = false,\n    archiveOriginals = true\n  } = options;\n\n  const sourceIdSet = new Set(sourceIds);\n  const transferred = new Set<string>();\n\n  // Find all relationships involving source entities\n  const toTransfer = graph.getRelationships().filter(r =>\n    (sourceIdSet.has(r.src) || sourceIdSet.has(r.dst)) &&\n    r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    !excludeKinds.includes(r.kind)\n  );\n\n  toTransfer.forEach(rel => {\n    let newSrc = rel.src;\n    let newDst = rel.dst;\n\n    // Determine new endpoints\n    if (sourceIdSet.has(rel.src) && !destinationOnly) {\n      newSrc = targetId;\n    }\n    if (sourceIdSet.has(rel.dst) && !sourceOnly) {\n      newDst = targetId;\n    }\n\n    // Skip if no change (shouldn't happen with proper source filtering)\n    if (newSrc === rel.src && newDst === rel.dst) return;\n\n    // Handle self-loops (both endpoints are being transferred to same target)\n    // Don't create self-referential relationship, but DO archive the original\n    if (newSrc === newDst) {\n      if (archiveOriginals) {\n        archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n      }\n      return;\n    }\n\n    // Avoid duplicates\n    const key = `${newSrc}:${newDst}:${rel.kind}`;\n    if (transferred.has(key)) return;\n\n    // Create new relationship\n    addRelationship(graph, rel.kind, newSrc, newDst);\n    transferred.add(key);\n\n    // Archive original if requested\n    if (archiveOriginals) {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    }\n  });\n\n  return transferred.size;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "sourceIds", "type": "string[]", "optional": false}, {"name": "targetId", "type": "string", "optional": false}, {"name": "options", "type": "TransferRelationshipsOptions", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/index.ts::createPartOfRelationships", "name": "createPartOfRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Create part_of relationships from members to a container entity.\n *\n * @param graph - The world graph\n * @param memberIds - IDs of member entities\n * @param containerId - ID of container entity\n * @returns Number of relationships created\n */\nexport function createPartOfRelationships(\n  graph: Graph,\n  memberIds: string[],\n  containerId: string\n): number {\n  let created = 0;\n\n  memberIds.forEach(memberId => {\n    // Check if relationship already exists\n    const exists = graph.getRelationships().some(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.src === memberId &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    );\n\n    if (!exists) {\n      addRelationship(graph, FRAMEWORK_RELATIONSHIP_KINDS.PART_OF, memberId, containerId);\n      created++;\n    }\n  });\n\n  return created;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "memberIds", "type": "string[]", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/index.ts::getActiveRelationships", "name": "getActiveRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all active relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @param direction - Filter by direction ('src', 'dst', or 'both')\n * @returns Active relationships\n */\nexport function getActiveRelationships(\n  graph: Graph,\n  entityId: string,\n  direction: 'src' | 'dst' | 'both' = 'both'\n): Relationship[] {\n  return graph.getRelationships().filter(r => {\n    if (r.status === FRAMEWORK_STATUS.HISTORICAL) return false;\n\n    switch (direction) {\n      case 'src':\n        return r.src === entityId;\n      case 'dst':\n        return r.dst === entityId;\n      case 'both':\n        return r.src === entityId || r.dst === entityId;\n    }\n  });\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}], "returnType": "Relationship[]"}, {"id": "apps/lore-weave/lib/index.ts::getHistoricalRelationships", "name": "getHistoricalRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all historical relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @returns Historical relationships\n */\nexport function getHistoricalRelationships(\n  graph: Graph,\n  entityId: string\n): Relationship[] {\n  return graph.getRelationships().filter(r =>\n    r.status === FRAMEWORK_STATUS.HISTORICAL &&\n    (r.src === entityId || r.dst === entityId)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Relationship[]"}, {"id": "apps/lore-weave/lib/index.ts::isHistoricalEntity", "name": "isHistoricalEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity is historical.\n *\n * @param entity - Entity to check\n * @returns True if entity is historical\n */\nexport function isHistoricalEntity(entity: HardState): boolean {\n  return entity.status === FRAMEWORK_STATUS.HISTORICAL;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::getPartOfMembers", "name": "getPartOfMembers", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all entities that are part of a container entity.\n *\n * @param graph - The world graph\n * @param containerId - ID of container entity\n * @returns Member entities\n */\nexport function getPartOfMembers(\n  graph: Graph,\n  containerId: string\n): HardState[] {\n  const memberIds = graph.getRelationships()\n    .filter(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    )\n    .map(r => r.src);\n\n  return memberIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::supersedeEntity", "name": "supersedeEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Supersede one entity with another.\n * Creates supersedes relationship, transfers relationships, and archives original.\n *\n * @param graph - The world graph\n * @param oldEntityId - ID of entity being superseded\n * @param newEntityId - ID of new entity\n * @param options - Supersede options\n */\nexport function supersedeEntity(\n  graph: Graph,\n  oldEntityId: string,\n  newEntityId: string,\n  options: SupersedeEntityOptions = {}\n): void {\n  const {\n    archiveSuperseded = true,\n    createSupersedes = true,\n    ...transferOptions\n  } = options;\n\n  // Create supersedes relationship (new supersedes old)\n  if (createSupersedes) {\n    addRelationship(\n      graph,\n      FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n      newEntityId,\n      oldEntityId\n    );\n  }\n\n  // Transfer relationships from old to new\n  transferRelationships(\n    graph,\n    [oldEntityId],\n    newEntityId,\n    {\n      ...transferOptions,\n      excludeKinds: [\n        ...(transferOptions.excludeKinds || []),\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    }\n  );\n\n  // Archive old entity\n  if (archiveSuperseded) {\n    archiveEntity(graph, oldEntityId, {\n      archiveRelationships: false, // Already handled by transfer\n      excludeRelationshipKinds: [\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "oldEntityId", "type": "string", "optional": false}, {"name": "newEntityId", "type": "string", "optional": false}, {"name": "options", "type": "SupersedeEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::buildRelationships", "name": "buildRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Helper function to create a new RelationshipBuilder\n * Usage: buildRelationships().add(...).add(...).build()\n */\nexport function buildRelationships(): RelationshipBuilder {\n  return new RelationshipBuilder();\n}", "parameters": [], "returnType": "RelationshipBuilder"}, {"id": "apps/lore-weave/lib/index.ts::initializeCatalyst", "name": "initializeCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Initialize or update catalyst properties for an entity\n * This is a helper for domain code to set up catalyst properties\n * @param entity - The entity to initialize\n * @param canAct - Can this entity perform actions?\n */\nexport function initializeCatalyst(\n  entity: HardState,\n  canAct: boolean\n): void {\n  entity.catalyst = {\n    canAct\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "canAct", "type": "boolean", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::initializeCatalystSmart", "name": "initializeCatalystSmart", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Initialize catalyst properties for entities of actor kinds.\n * All entities of eligible kinds can act - prominence affects action\n * success chance and attempt rate, not eligibility.\n *\n * @param entity - The entity to initialize\n */\nexport function initializeCatalystSmart(entity: HardState): void {\n  // Entity kinds that can act\n  const actorKinds = ['npc', 'faction', 'ability', 'occurrence', 'location', 'artifact', 'rule'];\n  if (!actorKinds.includes(entity.kind)) {\n    return;\n  }\n\n  entity.catalyst = {\n    canAct: true\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/index.ts::getAgentsByCategory", "name": "getAgentsByCategory", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all entities that can act (have catalyst.canAct = true)\n * @param graph - The world graph\n * @param category - Filter by agent category\n * @returns Array of agent entities\n */\nexport function getAgentsByCategory(\n  graph: Graph,\n  category: 'first-order' | 'second-order' | 'all' = 'all'\n): HardState[] {\n  const agents = graph.getEntities()\n    .filter(e => e.catalyst?.canAct === true);\n\n  if (category === 'all') {\n    return agents;\n  }\n\n  // First-order agents: npc, faction, ability, location (rare)\n  // Second-order agents: occurrence\n  if (category === 'first-order') {\n    return agents.filter(e => e.kind !== FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  } else {\n    return agents.filter(e => e.kind === FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "category", "type": "'first-order' | 'second-order' | 'all'", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/index.ts::canPerformAction", "name": "canPerformAction", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity can perform actions\n * @param entity - The entity to check\n * @returns True if entity can act\n */\nexport function canPerformAction(entity: HardState): boolean {\n  return entity.catalyst?.canAct === true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::recordCatalyst", "name": "recordCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Record catalyst attribution on a relationship\n * @param relationship - The relationship to attribute\n * @param catalystId - ID of the agent that caused this\n * @returns The relationship with attribution added\n */\nexport function recordCatalyst(\n  relationship: Relationship,\n  catalystId: string\n): Relationship {\n  return {\n    ...relationship,\n    catalyzedBy: catalystId\n  };\n}", "parameters": [{"name": "relationship", "type": "Relationship", "optional": false}, {"name": "catalystId", "type": "string", "optional": false}], "returnType": "Relationship"}, {"id": "apps/lore-weave/lib/index.ts::getCatalyzedEvents", "name": "getCatalyzedEvents", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all events (relationships/entities) catalyzed by an entity\n * @param graph - The world graph\n * @param entityId - ID of the catalyst entity\n * @returns Array of relationships and entities caused by this catalyst\n */\nexport function getCatalyzedEvents(\n  graph: Graph,\n  entityId: string\n): (Relationship | HardState)[] {\n  const results: (Relationship | HardState)[] = [];\n\n  // Find relationships catalyzed by this entity\n  graph.getRelationships().forEach(rel => {\n    if (rel.catalyzedBy === entityId) {\n      results.push(rel);\n    }\n  });\n\n  // Find entities catalyzed by this entity (e.g., occurrences triggered by NPCs)\n  graph.forEachEntity(entity => {\n    const triggeredByRel = graph.getEntityRelationships(entity.id, 'src')\n      .find(rel => rel.kind === 'triggered_by' && rel.dst === entityId);\n    if (triggeredByRel) {\n      results.push(entity);\n    }\n  });\n\n  return results;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "(Relationship | HardState)[]"}, {"id": "apps/lore-weave/lib/index.ts::calculateAttemptChance", "name": "calculateAttemptChance", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Calculate action attempt chance based on entity prominence\n * @param entity - The entity attempting action\n * @param baseRate - Base action attempt rate (from system parameters)\n * @returns Probability of action attempt this tick\n */\nexport function calculateAttemptChance(\n  entity: HardState,\n  baseRate: number\n): number {\n  if (!entity.catalyst?.canAct) {\n    return 0;\n  }\n\n  const multiplier = getProminenceMultiplierValue(entity.prominence, 'action_rate');\n  const chance = baseRate * multiplier;\n\n  // Clamp to [0, 1]\n  return Math.max(0, Math.min(1, chance));\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "baseRate", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/index.ts::createConnectionEvolutionSystem", "name": "createConnectionEvolutionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ConnectionEvolutionConfig\r\n */\r\nexport function createConnectionEvolutionSystem(\r\n  config: ConnectionEvolutionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      return applyConnectionEvolution(config, graphView, modifier);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ConnectionEvolutionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::createGraphContagionSystem", "name": "createGraphContagionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a GraphContagionConfig\r\n */\r\nexport function createGraphContagionSystem(\r\n  config: GraphContagionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Use multi-source mode if configured, otherwise single-source mode\r\n      if (config.multiSource) {\r\n        return applyMultiSourceContagion(config, graphView, modifier);\r\n      } else {\r\n        return applySingleSourceContagion(config, graphView, modifier);\r\n      }\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "GraphContagionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::createThresholdTriggerSystem", "name": "createThresholdTriggerSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ThresholdTriggerConfig\r\n */\r\nexport function createThresholdTriggerSystem(\r\n  config: ThresholdTriggerConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Find entities matching selection\r\n      const selectionCtx = createSystemContext(graphView);\r\n      let entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      // Apply cooldown filter\r\n      if (config.cooldownTag) {\r\n        entities = entities.filter(e => !hasTag(e.tags, config.cooldownTag!));\r\n      }\r\n\r\n      // Evaluate conditions on each entity\r\n      const matchingEntities = entities.filter(entity =>\r\n        evaluateAllConditions(entity, config.conditions, graphView)\r\n      );\r\n\r\n      if (matchingEntities.length === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: no matches`\r\n        };\r\n      }\r\n\r\n      // Cluster matching entities\r\n      const clusters = clusterEntities(matchingEntities, config, graphView);\r\n\r\n      if (clusters.size === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: clusters too small`\r\n        };\r\n      }\r\n\r\n      // Apply actions\r\n      const { modifications, relationships, relationshipsAdjusted, relationshipsToArchive, pressureChanges, skippedMembers, narrationsByGroup } =\r\n        applyActions(clusters, config, graphView);\r\n\r\n      const skippedInfo = skippedMembers > 0 ? `, ${skippedMembers} skipped (missing vars)` : '';\r\n      return {\r\n        relationshipsAdded: relationships,\r\n        relationshipsAdjusted,\r\n        relationshipsToArchive,\r\n        entitiesModified: modifications as SystemResult['entitiesModified'],\r\n        pressureChanges,\r\n        description: `${config.name}: ${clusters.size} trigger(s), ${modifications.length} entities tagged${skippedInfo}`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined,\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ThresholdTriggerConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::createClusterFormationSystem", "name": "createClusterFormationSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// SYSTEM FACTORY\n// =============================================================================\n\n/**\n * Create a SimulationSystem from a ClusterFormationConfig\n */\nexport function createClusterFormationSystem(\n  config: ClusterFormationConfig\n): SimulationSystem {\n  // Convert declarative criteria to runtime criteria\n  const clusterConfig: ClusterConfig = {\n    minSize: config.clustering.minSize,\n    maxSize: config.clustering.maxSize,\n    criteria: toClusterCriteria(config.clustering.criteria),\n    minimumScore: config.clustering.minimumScore\n  };\n\n  return {\n    id: config.id,\n    name: config.name,\n\n    apply: async (graphView: WorldRuntime, _modifier: number = 1.0): Promise<SystemResult> => {\n      // Check epoch end if required\n      if (config.runAtEpochEnd) {\n        const ticksPerEpoch = graphView.config.ticksPerEpoch || 15;\n        if (graphView.tick % ticksPerEpoch !== 0) {\n          return {\n            relationshipsAdded: [],\n            entitiesModified: [],\n            pressureChanges: {},\n            description: `${config.name}: not epoch end, skipping`\n          };\n        }\n      }\n\n      // Find entities eligible for clustering\n      const selectionCtx = createSystemContext(graphView);\n      let entities = selectEntities(config.selection, selectionCtx);\n\n      // Filter out historical and meta-entities\n      entities = filterClusterableEntities(entities);\n\n      if (entities.length < clusterConfig.minSize) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${config.name}: not enough entities (${entities.length})`\n        };\n      }\n\n      // Detect clusters\n      const clusters = detectClusters(entities, clusterConfig, graphView);\n\n      const relationshipsAdded: Array<Relationship & { narrativeGroupId?: string }> = [];\n      const entitiesModified: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\n      const metaEntitiesCreated: string[] = [];\n      const factionsCreated: string[] = [];\n      const narrationsByGroup: Record<string, string> = {};\n\n      // Form meta-entities from valid clusters\n      for (const cluster of clusters) {\n        if (cluster.score < clusterConfig.minimumScore) continue;\n\n        // Create the meta-entity partial\n        const metaEntityPartial = await createMetaEntity(cluster.entities, config.metaEntity, graphView);\n\n        // Enter narration context BEFORE creating the entity (narration added after we have the name)\n        const tracker = graphView.mutationTracker;\n        const contextId = `${config.id}:${metaEntitiesCreated.length}`;\n        if (config.narrationTemplate && tracker) {\n          tracker.enterContext('system', contextId);\n        }\n\n        // Now create the entity (will be recorded under the narration context)\n        const metaEntityId = await graphView.addEntity(metaEntityPartial);\n        const metaEntity = graphView.getEntity(metaEntityId)!;\n        metaEntitiesCreated.push(metaEntityId);\n\n        // Generate narration now that we have the full entity with name\n        // and SET IT ON THE CURRENT CONTEXT so the event builder finds it\n        let generatedNarration: string | undefined;\n        if (config.narrationTemplate && tracker) {\n          const entityNames = cluster.entities.map(e => e.name).join(', ');\n          const templateWithReplacements = config.narrationTemplate\n            .replace('{count}', String(cluster.entities.length))\n            .replace('{names}', entityNames);\n          const narrationCtx = createSystemRuleContext({ self: metaEntity });\n          const narrationResult = interpolate(templateWithReplacements, narrationCtx);\n          if (narrationResult.complete) {\n            generatedNarration = narrationResult.text;\n            narrationsByGroup[metaEntityId] = generatedNarration;\n            // Update the context's narration directly\n            const currentContext = tracker.getCurrentContext();\n            if (currentContext) {\n              currentContext.narration = generatedNarration;\n            }\n          }\n        }\n\n        // Get cluster entity IDs\n        const clusterIds = cluster.entities.map(e => e.id);\n\n        // Handle practitioner relationships based on masterSelection config\n        if (config.masterSelection) {\n          // Collect all practitioners of cluster members\n          const allPractitioners: HardState[] = [];\n          const seenIds = new Set<string>();\n          for (const memberId of clusterIds) {\n            const practitioners = graphView.getConnectedEntities(memberId, 'practitioner_of', 'dst');\n            for (const p of practitioners) {\n              if (!seenIds.has(p.id)) {\n                seenIds.add(p.id);\n                allPractitioners.push(p);\n              }\n            }\n          }\n\n          // Select masters using the simplified selection logic\n          const masters = selectMasters(allPractitioners, metaEntity, config.masterSelection);\n\n          // Create practitioner_of relationships only for masters\n          for (const master of masters) {\n            graphView.createRelationship('practitioner_of', master.id, metaEntityId);\n            relationshipsAdded.push({\n              kind: 'practitioner_of',\n              src: master.id,\n              dst: metaEntityId,\n              strength: 1.0,\n              narrativeGroupId: metaEntityId\n            });\n            // Archive the old practitioner_of relationships for this master\n            for (const memberId of clusterIds) {\n              graphView.archiveRelationship(master.id, memberId, 'practitioner_of');\n            }\n          }\n\n          // Find origin location from absorbed abilities' manifests_at relationships\n          const locationCounts = new Map<string, number>();\n          for (const memberId of clusterIds) {\n            const locations = graphView.getConnectedEntities(memberId, 'manifests_at', 'src');\n            for (const loc of locations) {\n              locationCounts.set(loc.id, (locationCounts.get(loc.id) || 0) + 1);\n            }\n          }\n\n          // Create originated_in link to most common location\n          if (locationCounts.size > 0) {\n            const originLocationId = getMajority(locationCounts, '');\n            if (originLocationId) {\n              graphView.createRelationship('originated_in', metaEntityId, originLocationId);\n              relationshipsAdded.push({\n                kind: 'originated_in',\n                src: metaEntityId,\n                dst: originLocationId,\n                strength: 1.0,\n                narrativeGroupId: metaEntityId\n              });\n            }\n          }\n\n          graphView.log('info', `${config.name}: selected ${masters.length} masters from ${allPractitioners.length} practitioners`);\n        } else {\n          // Original behavior: transfer all relationships\n          graphView.transferRelationships(\n            clusterIds,\n            metaEntityId,\n            {\n              excludeKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n              archiveOriginals: true\n            }\n          );\n        }\n\n        // Create subsumes relationships (meta-entity subsumes member)\n        // This makes it explicit that the meta-entity absorbs the cluster members\n        clusterIds.forEach((id, index) => {\n          graphView.createRelationship('subsumes', metaEntityId, id);\n          relationshipsAdded.push({\n            kind: 'subsumes',\n            src: metaEntityId,\n            dst: id,\n            strength: 1.0,\n            // Link first relationship to narration for this cluster\n            narrativeGroupId: index === 0 ? metaEntityId : undefined\n          });\n        });\n\n        // Post-process: create emergent region if configured\n        if (config.postProcess?.createEmergentRegion && metaEntityPartial.coordinates) {\n          const regionLabel = (config.postProcess.emergentRegionLabel || '{name} Region')\n            .replace('{name}', metaEntity.name);\n          const regionDescription = (config.postProcess.emergentRegionDescription || 'A semantic cluster formed around {name}')\n            .replace('{name}', metaEntity.name);\n\n          const regionResult = graphView.createEmergentRegion(\n            config.metaEntity.kind,\n            metaEntityPartial.coordinates,\n            regionLabel,\n            regionDescription,\n            metaEntity.culture,\n            metaEntityId\n          );\n\n          if (regionResult.success && regionResult.region) {\n            graphView.log('info', `Created emergent region \"${regionResult.region.label}\" for meta-entity \"${metaEntity.name}\"`);\n          }\n        }\n\n        // Post-process: create governance faction if configured\n        if (config.postProcess?.createGovernanceFaction) {\n          const { factionId, relationships } = await createGovernanceFaction(\n            graphView,\n            metaEntityId,\n            metaEntity,\n            config.postProcess\n          );\n\n          relationshipsAdded.push(...relationships);\n          if (factionId) {\n            factionsCreated.push(factionId);\n          }\n        }\n\n        // Apply member updates or fall back to archiving\n        if (config.memberUpdates && config.memberUpdates.length > 0) {\n          // Find the status mutation if present\n          const statusMutation = config.memberUpdates.find(\n            m => m.type === 'change_status'\n          ) as { type: 'change_status'; newStatus: string } | undefined;\n\n          const newStatus = statusMutation?.newStatus ?? FRAMEWORK_STATUS.SUBSUMED;\n\n          // Apply status change to each cluster member\n          for (const memberId of clusterIds) {\n            graphView.updateEntityStatus(memberId, newStatus);\n\n            entitiesModified.push({\n              id: memberId,\n              changes: { status: newStatus }\n            });\n          }\n        } else {\n          // Original behavior: archive as historical\n          graphView.archiveEntities(\n            clusterIds,\n            {\n              archiveRelationships: false,\n              excludeRelationshipKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF]\n            }\n          );\n\n          // Track modifications\n          clusterIds.forEach(id => {\n            entitiesModified.push({\n              id,\n              changes: { status: 'historical' }\n            });\n          });\n        }\n\n        // Exit narration context if we entered one\n        if (config.narrationTemplate && tracker) {\n          tracker.exitContext();\n        }\n      }\n\n      // Pressure changes\n      const pressureChanges = metaEntitiesCreated.length > 0\n        ? (config.postProcess?.pressureChanges ?? { stability: 2 })\n        : {};\n\n      return {\n        relationshipsAdded,\n        entitiesModified,\n        pressureChanges,\n        description: `${config.name}: ${metaEntitiesCreated.length} meta-entities formed` +\n          (factionsCreated.length > 0 ? `, ${factionsCreated.length} factions` : ''),\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "ClusterFormationConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::createTagDiffusionSystem", "name": "createTagDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a TagDiffusionConfig\r\n */\r\nexport function createTagDiffusionSystem(\r\n  config: TagDiffusionConfig\r\n): SimulationSystem {\r\n  const direction = config.connectionDirection ?? 'both';\r\n  const maxTags = config.maxTags ?? 10;\r\n\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const modifiedTags = new Map<string, Record<string, boolean | string>>();\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const entityNarrations = new Map<string, { tag: string; type: 'convergence' | 'divergence' }>();\r\n\r\n      // Find entities to evaluate\r\n      const selectionCtx = createSystemContext(graphView);\r\n      const entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      if (entities.length < 2) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: not enough entities`\r\n        };\r\n      }\r\n\r\n      // Track divergent entities for pressure calculation\r\n      let divergentCount = 0;\r\n\r\n      // === CONVERGENCE: Connected entities gain shared tags ===\r\n      if (config.convergence) {\r\n        const conv = config.convergence;\r\n        const maxShared = conv.maxSharedTags ?? 2;\r\n\r\n        // Compare pairs of entities\r\n        for (let i = 0; i < entities.length; i++) {\r\n          const entity = entities[i];\r\n          const connected = getConnectedEntities(entity, config.connectionKind, direction, graphView);\r\n\r\n          // Filter to only entities in our evaluation set\r\n          const connectedInSet = connected.filter(c =>\r\n            entities.some(e => e.id === c.id)\r\n          );\r\n\r\n          if (connectedInSet.length >= conv.minConnections) {\r\n            // Check shared tags with connected entities\r\n            for (const other of connectedInSet) {\r\n              const sharedCount = countSharedTags(entity, other, conv.tags);\r\n\r\n              if (sharedCount < maxShared) {\r\n                // Roll for convergence\r\n                if (rollProbability(conv.probability, modifier)) {\r\n                  // Pick a tag that neither has\r\n                  const candidateTags = conv.tags.filter(t =>\r\n                    !hasTag(entity.tags, t) && !hasTag(other.tags, t)\r\n                  );\r\n\r\n                  if (candidateTags.length > 0) {\r\n                    const newTag = pickRandom(candidateTags);\r\n                    const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                    if (Object.keys(currentTags).length < maxTags) {\r\n                      currentTags[newTag] = true;\r\n                      modifiedTags.set(entity.id, currentTags);\r\n                      // Track for narration\r\n                      if (!entityNarrations.has(entity.id)) {\r\n                        entityNarrations.set(entity.id, { tag: newTag, type: 'convergence' });\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // === DIVERGENCE: Isolated entities gain unique tags ===\r\n      if (config.divergence) {\r\n        const div = config.divergence;\r\n\r\n        for (const entity of entities) {\r\n          const connectionCount = countConnections(entity, config.connectionKind, direction, graphView);\r\n\r\n          if (connectionCount <= div.maxConnections) {\r\n            // This entity is isolated\r\n            if (rollProbability(div.probability, modifier)) {\r\n              // Pick a divergence tag the entity doesn't have\r\n              const candidateTags = div.tags.filter(t => !hasTag(entity.tags, t));\r\n\r\n              if (candidateTags.length > 0) {\r\n                const newTag = pickRandom(candidateTags);\r\n                const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                if (Object.keys(currentTags).length < maxTags) {\r\n                  currentTags[newTag] = true;\r\n                  modifiedTags.set(entity.id, currentTags);\r\n                  // Track for narration\r\n                  if (!entityNarrations.has(entity.id)) {\r\n                    entityNarrations.set(entity.id, { tag: newTag, type: 'divergence' });\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // Track for pressure calculation\r\n            if (div.tags.some(t => hasTag(entity.tags, t))) {\r\n              divergentCount++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert tag modifications to entity modifications and generate narrations\r\n      for (const [entityId, tags] of modifiedTags) {\r\n        const entity = graphView.getEntity(entityId);\r\n        const narrationInfo = entityNarrations.get(entityId);\r\n\r\n        // Generate narration if template is available\r\n        if (entity && narrationInfo) {\r\n          const template = narrationInfo.type === 'convergence'\r\n            ? config.convergence?.narrationTemplate\r\n            : config.divergence?.narrationTemplate;\r\n\r\n          if (template) {\r\n            const narrationCtx = createSystemRuleContext({ self: entity });\r\n            const narrationResult = interpolate(template, narrationCtx);\r\n            if (narrationResult.complete) {\r\n              narrationsByGroup[entityId] = narrationResult.text;\r\n            }\r\n          }\r\n        }\r\n\r\n        modifications.push({\r\n          id: entityId,\r\n          changes: { tags: tags as Record<string, boolean> },\r\n          narrativeGroupId: narrationInfo ? entityId : undefined\r\n        });\r\n      }\r\n\r\n      // Calculate pressure changes\r\n      let pressureChanges: Record<string, number> = {};\r\n\r\n      if (modifications.length > 0 && config.pressureChanges) {\r\n        pressureChanges = { ...config.pressureChanges };\r\n      }\r\n\r\n      // Apply divergence-specific pressure\r\n      if (config.divergencePressure && divergentCount >= config.divergencePressure.minDivergent) {\r\n        pressureChanges[config.divergencePressure.pressureName] =\r\n          (pressureChanges[config.divergencePressure.pressureName] ?? 0) +\r\n          config.divergencePressure.delta * modifier;\r\n      }\r\n\r\n      return {\r\n        relationshipsAdded: [],\r\n        entitiesModified: modifications,\r\n        pressureChanges,\r\n        description: `${config.name}: ${modifications.length} entities affected`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "TagDiffusionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::createPlaneDiffusionSystem", "name": "createPlaneDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a PlaneDiffusionConfig\r\n */\r\nexport function createPlaneDiffusionSystem(\r\n  config: PlaneDiffusionConfig\r\n): SimulationSystem<DiffusionState> {\r\n  const diffusionRate = config.diffusion.rate ?? 0.2;\r\n  const sourceRadius = config.diffusion.sourceRadius ?? 1;\r\n  const decayRate = config.diffusion.decayRate ?? 0; // Default to 0\r\n  const falloffType = config.diffusion.falloffType ?? 'absolute';\r\n  const iterationsPerTick = config.diffusion.iterationsPerTick ?? 20; // Default 20 for fast spreading\r\n\r\n  // Validate ranges\r\n  if (diffusionRate < 0 || diffusionRate > 1) {\r\n    throw new Error(`[${config.id}] Diffusion rate must be between 0 and 1, got ${diffusionRate}`);\r\n  }\r\n  if (decayRate < 0 || decayRate > 1) {\r\n    throw new Error(`[${config.id}] Decay rate must be between 0 and 1, got ${decayRate}`);\r\n  }\r\n  if (sourceRadius < 0 || sourceRadius > 50) {\r\n    throw new Error(`[${config.id}] Source radius must be between 0 and 50, got ${sourceRadius}`);\r\n  }\r\n  if (!config.selection?.kind) {\r\n    throw new Error(`[${config.id}] Plane diffusion requires selection.kind to define the semantic plane.`);\r\n  }\r\n\r\n  // Create the system with internal state\r\n  const system: SimulationSystem<DiffusionState> = {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    // Internal state - will be initialized by initialize()\r\n    state: undefined,\r\n\r\n    // Initialize the grid on first use\r\n    initialize: function() {\r\n      this.state = {\r\n        grid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        tempGrid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        initialized: true,\r\n      };\r\n    },\r\n\r\n    apply: function(graphView: WorldRuntime, _modifier: number = 1.0): SystemResult {\r\n      // Ensure state is initialized (safety check)\r\n      if (!this.state?.initialized) {\r\n        this.initialize!();\r\n      }\r\n      const state = this.state!;\r\n\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        // eslint-disable-next-line sonarjs/pseudo-random -- simulation throttle check\r\n        if (Math.random() > config.throttleChance) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`,\r\n            details: {\r\n              diffusionSnapshot: {\r\n                grid: Array.from(state.grid),\r\n                gridSize: GRID_SIZE,\r\n                sources: [],\r\n                sinks: [],\r\n                entities: [],\r\n              },\r\n            },\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const metricCtx = createSystemContext(graphView);\r\n\r\n      const getFalloff = (distance: number, strength: number): number => {\r\n        const maxDistance = falloffType === 'absolute' ? strength : sourceRadius + 1;\r\n        if (maxDistance <= 0) return 0;\r\n        const metric: Metric = {\r\n          type: 'falloff',\r\n          falloffType,\r\n          distance,\r\n          maxDistance,\r\n        };\r\n        return evaluateMetric(metric, metricCtx).value;\r\n      };\r\n\r\n      // Find all entities on the target plane\r\n      const entities = selectEntities(config.selection, metricCtx);\r\n\r\n      // Filter to entities with valid coordinates\r\n      const entitiesWithCoords = entities.filter(hasCoordinates);\r\n\r\n      // Identify sources and sinks\r\n      const sources = entitiesWithCoords.filter(e => hasTag(e.tags, config.sources.tagFilter));\r\n      const sinks = config.sinks\r\n        ? entitiesWithCoords.filter(e => hasTag(e.tags, config.sinks!.tagFilter))\r\n        : [];\r\n\r\n      // =======================================================================\r\n      // STEP 1: Build a mask of fixed boundary cells (only when decay=0)\r\n      // - decay=0: Sources SET values, need Dirichlet boundary (fixed during diffusion)\r\n      // - decay>0: Sources ADD values, no fixed boundary (diffusion happens normally)\r\n      // - Sinks never create fixed cells - they subtract and let diffusion happen\r\n      // =======================================================================\r\n      const fixedCells = new Set<number>();\r\n\r\n      // Only create fixed boundaries when decay=0 (SET mode)\r\n      if (decayRate === 0) {\r\n        for (const source of sources) {\r\n          const gx = coordToGrid(source.coordinates.x);\r\n          const gy = coordToGrid(source.coordinates.y);\r\n          for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n            for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n              const dist = Math.sqrt(dx * dx + dy * dy);\r\n              if (dist <= sourceRadius) {\r\n                const nx = gx + dx;\r\n                const ny = gy + dy;\r\n                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {\r\n                  fixedCells.add(ny * GRID_SIZE + nx);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2a: Sources SET (decay=0) or ADD (decay>0) their values\r\n      // - decay=0: Dirichlet boundary - stable fixed values\r\n      // - decay>0: Injection model - add per tick, decay prevents unbounded growth\r\n      // =======================================================================\r\n      const sourceMode = decayRate > 0 ? 'add' : 'set';\r\n\r\n      for (const source of sources) {\r\n        const gx = coordToGrid(source.coordinates.x);\r\n        const gy = coordToGrid(source.coordinates.y);\r\n        // Note: source strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(source, config.sources.strengthTag, config.sources.defaultStrength);\r\n\r\n        // Set/Add values within source radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const injectionValue = strength * falloff;\r\n\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              if (sourceMode === 'add') {\r\n                // ADD mode: inject on top of existing value\r\n                const currentValue = getGridValue(state.grid, nx, ny);\r\n                setGridValue(state.grid, nx, ny, currentValue + injectionValue);\r\n              } else {\r\n                // SET mode: fixed boundary value\r\n                setGridValue(state.grid, nx, ny, injectionValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2b: Sinks SUBTRACT from existing values (not SET)\r\n      // This allows sinks in source regions to reduce the field, not overwrite it\r\n      // =======================================================================\r\n      for (const sink of sinks) {\r\n        const gx = coordToGrid(sink.coordinates.x);\r\n        const gy = coordToGrid(sink.coordinates.y);\r\n        // Note: sink strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(sink, config.sinks!.strengthTag, config.sinks!.defaultStrength);\r\n\r\n        // Subtract values within sink radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const subtractAmount = strength * falloff;\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              const currentValue = getGridValue(state.grid, nx, ny);\r\n              setGridValue(state.grid, nx, ny, currentValue - subtractAmount);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3: Apply diffusion (heat equation)\r\n      // Skip source cells (Dirichlet source), edges diffuse normally (Neumann-like)\r\n      // Out-of-bounds neighbors return 0, so edges naturally trend toward 0\r\n      // =======================================================================\r\n      for (let iter = 0; iter < iterationsPerTick; iter++) {\r\n        state.tempGrid.set(state.grid);\r\n\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n\r\n            // Skip source cells - they maintain their set values\r\n            if (fixedCells.has(idx)) {\r\n              continue;\r\n            }\r\n\r\n            const current = getGridValue(state.tempGrid, x, y);\r\n\r\n            // Get 4-connected neighbors (out-of-bounds returns 0)\r\n            const north = getGridValue(state.tempGrid, x, y - 1);\r\n            const south = getGridValue(state.tempGrid, x, y + 1);\r\n            const east = getGridValue(state.tempGrid, x + 1, y);\r\n            const west = getGridValue(state.tempGrid, x - 1, y);\r\n\r\n            // Average of neighbors\r\n            const neighborAvg = (north + south + east + west) / 4;\r\n\r\n            // Diffusion: move toward neighbor average\r\n            const diffused = current + diffusionRate * (neighborAvg - current);\r\n\r\n            setGridValue(state.grid, x, y, diffused);\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3b: Apply decay ONCE per tick (not per iteration)\r\n      // =======================================================================\r\n      if (decayRate > 0) {\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n            // Don't decay fixed boundary cells\r\n            if (!fixedCells.has(idx)) {\r\n              const current = getGridValue(state.grid, x, y);\r\n              setGridValue(state.grid, x, y, current * (1 - decayRate));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 4: Sample grid at entity positions and set tags (CLAMPED OUTPUT)\r\n      // Track significant modifications (new output tags) separately from\r\n      // value tag updates to avoid false positives in the trace.\r\n      // =======================================================================\r\n      let significantModificationCount = 0;\r\n\r\n      for (const entity of entitiesWithCoords) {\r\n        const rawFieldValue = sampleGrid(state.grid, entity.coordinates.x, entity.coordinates.y);\r\n        // Clamp to output range for game space\r\n        const fieldValue = clampToOutput(rawFieldValue);\r\n\r\n        const newTags: Record<string, boolean | string> = { ...entity.tags };\r\n        let tagsChanged = false;\r\n\r\n        // Track which output tags the entity currently has\r\n        const previousOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            previousOutputTags.add(outputTag.tag);\r\n          }\r\n        }\r\n\r\n        // Remove old output tags and value tag\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            delete newTags[outputTag.tag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n        if (config.valueTag) {\r\n          if (config.valueTag in newTags) {\r\n            delete newTags[config.valueTag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n\r\n        // Add appropriate output tag based on thresholds (using clamped value)\r\n        // Track if any NEW output tag was added (not previously present)\r\n        let newOutputTagAdded = false;\r\n        let gainedOutputTag: DiffusionOutputTag | undefined;\r\n        const newOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          const minOk = outputTag.minValue === undefined || fieldValue >= outputTag.minValue;\r\n          const maxOk = outputTag.maxValue === undefined || fieldValue < outputTag.maxValue;\r\n\r\n          if (minOk && maxOk) {\r\n            newTags[outputTag.tag] = true;\r\n            newOutputTags.add(outputTag.tag);\r\n            tagsChanged = true;\r\n            // This is a significant change if entity didn't have this tag before\r\n            if (!previousOutputTags.has(outputTag.tag)) {\r\n              newOutputTagAdded = true;\r\n              gainedOutputTag = outputTag;\r\n// ... (truncated)", "parameters": [{"name": "config", "type": "PlaneDiffusionConfig", "optional": false}], "returnType": "SimulationSystem<DiffusionState>"}, {"id": "apps/lore-weave/lib/index.ts::createGrowthSystem", "name": "createGrowthSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function createGrowthSystem(\n  config: GrowthSystemConfig,\n  deps: GrowthSystemDependencies\n): GrowthSystem {\n  const state: GrowthState = {\n    epoch: -1,\n    epochTarget: 0,\n    entitiesCreated: 0,\n    templatesApplied: 0,\n    templatesUsed: new Set(),\n    yieldSamples: [],\n    phaseCompleted: false\n  };\n\n  const maxTemplatesPerTick = config.maxTemplatesPerTick ?? 5;\n  const minTemplatesPerTick = config.minTemplatesPerTick ?? 1;\n  const yieldWindow = config.yieldAveragingWindow ?? 30;\n  const maxAttemptsPerTick = config.maxAttemptsPerTick ?? 40;\n\n  function getExpectedYield(): number {\n    if (state.yieldSamples.length === 0) return 1;\n    const avg = state.yieldSamples.reduce((sum, val) => sum + val, 0) / state.yieldSamples.length;\n    // Avoid runaway budgets from unlucky zeros\n    return Math.max(1, avg);\n  }\n\n  function recordPhaseCompletion(graphView: WorldRuntime, reason: GrowthPhaseCompletion['reason']): void {\n    if (state.phaseCompleted) return;\n    if (state.epochTarget <= 0) return;\n    const eraId = state.epochEra?.id ?? deps.getEpochEra().id;\n    if (!eraId) return;\n\n    state.phaseCompleted = true;\n    graphView.growthPhaseHistory.push({\n      epoch: state.epoch,\n      eraId,\n      tick: graphView.tick,\n      reason\n    });\n  }\n\n  async function applyTemplateOnce(\n    template: GrowthTemplate,\n    graphView: WorldRuntime,\n    _era: Era\n  ): Promise<number> {\n    try {\n      // Check applicability\n      if (!template.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n          if (!diag.applicabilityPassed) {\n            graphView.debug('templates', `${template.id} rejected: ${diag.failedRules.join('; ')}`);\n          } else if (diag.selectionCount === 0) {\n            graphView.debug('templates', `${template.id} selection(${diag.selectionStrategy}) returned 0 targets`);\n          }\n        }\n        return 0;\n      }\n\n      const templateTargets = template.findTargets(graphView);\n      if (templateTargets.length === 0) {\n        graphView.debug('selection', `${template.id} found no targets via findTargets()`);\n        return 0;\n      }\n\n      const target = pickRandom(templateTargets);\n\n      const pressureModsBefore = deps.getPendingPressureModifications().length;\n      graphView.setPressureModificationCallback((pressureId, delta, source) => {\n        deps.trackPressureModification(pressureId, delta, source);\n      });\n      graphView.setCurrentSource({ type: 'template', templateId: template.id });\n\n      // LINEAGE: Enter template context for entity/relationship stamping.\n      // All entities and relationships created will have\n      // createdBy = { tick, source: 'template', sourceId: template.id }.\n      // See LINEAGE.md for design details.\n      // NOTE: Context must stay open until AFTER addEntity/createRelationship calls below.\n      deps.mutationTracker?.enterContext('template', template.id);\n\n      let result: import('../engine/types').TemplateResult;\n      try {\n        result = await template.expand(graphView, target);\n      } catch (error) {\n        // LINEAGE: Exit context on expand error\n        deps.mutationTracker?.exitContext();\n        throw error;\n      }\n      graphView.clearCurrentSource();\n\n      // Contract enforcement warnings\n      const allTagsSet = new Set<string>();\n      for (const entity of result.entities) {\n        Object.keys(entity.tags || {}).forEach(tag => allTagsSet.add(tag));\n      }\n      const allTagsToAdd = Array.from(allTagsSet);\n      const tagSaturationCheck = deps.contractEnforcer.checkTagSaturation(graphView, allTagsToAdd);\n      if (tagSaturationCheck.saturated) {\n        deps.emitter.log('warn', `Template ${template.id} would oversaturate tags: ${tagSaturationCheck.oversaturatedTags.join(', ')}`);\n      }\n      const orphanCheck = deps.contractEnforcer.checkTagOrphans(allTagsToAdd);\n      if (orphanCheck.hasOrphans && orphanCheck.orphanTags.length >= 3) {\n        deps.emitter.log('debug', `Template ${template.id} creates unregistered tags: ${orphanCheck.orphanTags.slice(0, 5).join(', ')}`);\n      }\n\n      deps.statisticsCollector.recordTemplateApplication(template.id);\n\n      const createdEntities: HardState[] = [];\n      const newIds: string[] = [];\n\n      for (let i = 0; i < result.entities.length; i++) {\n        const entity = result.entities[i];\n        const placementStrategy = result.placementStrategies?.[i] || 'unknown';\n        const id = await graphView.addEntity(entity, `template:${template.id}`, placementStrategy);\n        newIds.push(id);\n        const ref = graphView.getEntity(id);\n        if (ref) {\n          createdEntities.push(ref);\n        }\n      }\n\n      for (const entity of createdEntities) {\n        initializeCatalystSmart(entity);\n      }\n\n      result.relationships.forEach(rel => {\n        const srcId = rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src;\n        const dstId = rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst;\n\n        if (srcId && dstId) {\n          graphView.createRelationship(rel.kind, srcId, dstId, rel.strength);\n        }\n      });\n\n      // LINEAGE: Exit template context now that entities/relationships are created.\n      // They are now stamped with createdBy = { source: 'template', sourceId: template.id }.\n      deps.mutationTracker?.exitContext();\n\n      for (const entity of createdEntities) {\n        const coverageCheck = deps.contractEnforcer.enforceTagCoverage(entity, graphView);\n        if (coverageCheck.needsAdjustment) {\n          deps.emitter.log('debug', coverageCheck.suggestion || '', { entity: entity.id });\n        }\n        const taxonomyCheck = deps.contractEnforcer.validateTagTaxonomy(entity);\n        if (!taxonomyCheck.valid) {\n          deps.emitter.log('warn', `Entity ${entity.name} has conflicting tags`, { conflicts: taxonomyCheck.conflicts });\n        }\n      }\n\n      // Record creation batch for narrative event generation\n      if (newIds.length > 0) {\n        // Summarize relationships by kind\n        const relationshipCounts = new Map<string, number>();\n        for (const rel of result.relationships) {\n          relationshipCounts.set(rel.kind, (relationshipCounts.get(rel.kind) || 0) + 1);\n        }\n        const relationshipSummary: RelationshipSummary[] = [];\n        for (const [kind, count] of relationshipCounts) {\n          relationshipSummary.push({ kind, count });\n        }\n\n        // Use description from first creation item if available\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        const rawDescription = declTemplate?.creation?.[0]?.description;\n        // DescriptionSpec can be string or { template, replacements } - extract string if possible\n        const primaryDescription = typeof rawDescription === 'string' ? rawDescription : undefined;\n\n        // Generate narration ONCE here, now that entities have names\n        // result.resolvedVariables contains $target, $enemy, etc. from template expansion\n        let narration: string | undefined;\n        if (declTemplate?.narrationTemplate) {\n          // Start with the resolved variables from template expansion (like $target, $enemy)\n          const variables: Record<string, HardState | HardState[] | undefined> = {\n            ...(result.resolvedVariables || {}),\n          };\n\n          // Add created entities by their entityRef (like $war, $ideology)\n          // Use entityRefToIndex mapping since createChance can skip entities\n          if (result.entityRefToIndex) {\n            for (const [entityRef, idx] of Object.entries(result.entityRefToIndex)) {\n              const index = idx;\n              if (createdEntities[index]) {\n                // Ensure $ prefix for the key\n                const key = entityRef.startsWith('$') ? entityRef : `$${entityRef}`;\n                variables[key] = createdEntities[index];\n              }\n            }\n          }\n\n          const narrationCtx = createGeneratorContext({\n            target,\n            variables,\n          });\n          const narrationResult = interpolate(declTemplate.narrationTemplate, narrationCtx);\n          // Use narration even if not complete - partial narration better than mechanical\n          narration = narrationResult.text;\n          if (!narrationResult.complete) {\n            // Debug: log unresolved tokens (use debug level since partial is expected sometimes)\n            console.debug(`[GrowthSystem] Template ${template.id} narration partial:`, {\n              unresolvedTokens: narrationResult.unresolvedTokens,\n              variableKeys: Object.keys(variables),\n            });\n          }\n        }\n\n        deps.stateChangeTracker.recordCreationBatch(\n          template.id,\n          template.name || template.id,\n          newIds,\n          relationshipSummary,\n          primaryDescription || result.description,\n          narration\n        );\n      }\n\n      const templatePressureMods = deps.getPendingPressureModifications().slice(pressureModsBefore);\n      const pressureChanges: Record<string, number> = {};\n      for (const mod of templatePressureMods) {\n        pressureChanges[mod.pressureId] = (pressureChanges[mod.pressureId] || 0) + mod.delta;\n      }\n\n      const resolvedRelationships = result.relationships.map(rel => ({\n        kind: rel.kind,\n        srcId: rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src,\n        dstId: rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst,\n        strength: rel.strength\n      }));\n\n      deps.emitter.templateApplication({\n        tick: graphView.tick,\n        epoch: deps.getCurrentEpoch(),\n        templateId: template.id,\n        targetEntityId: target.id,\n        targetEntityName: target.name,\n        targetEntityKind: target.kind,\n        description: result.description,\n        entitiesCreated: createdEntities.map((e, i) => {\n          const placementDebug = result.placementDebugList?.[i];\n          const strategy = result.placementStrategies?.[i] || 'unknown';\n          return {\n            id: e.id,\n            name: e.name,\n            kind: e.kind,\n            subtype: e.subtype,\n            culture: e.culture,\n            prominence: prominenceLabel(e.prominence),\n            tags: e.tags,\n            placementStrategy: strategy,\n            coordinates: e.coordinates,\n            regionId: placementDebug?.regionId ?? e.regionId,\n            allRegionIds: placementDebug?.allRegionIds ?? e.allRegionIds,\n            derivedTags: result.derivedTagsList?.[i],\n            placement: placementDebug ? {\n              anchorType: placementDebug.anchorType,\n              anchorEntity: placementDebug.anchorEntity,\n              anchorCulture: placementDebug.anchorCulture,\n              resolvedVia: placementDebug.resolvedVia,\n              seedRegionsAvailable: placementDebug.seedRegionsAvailable,\n              emergentRegionCreated: placementDebug.emergentRegionCreated\n            } : undefined\n          };\n        }),\n        relationshipsCreated: resolvedRelationships,\n        pressureChanges\n      });\n\n      return result.entities.length;\n    } catch (error) {\n      graphView.clearCurrentSource();\n      const message = error instanceof Error ? error.message : String(error);\n      const templateLabel = template.name ? `${template.name} (${template.id})` : template.id;\n      throw new Error(`Template ${templateLabel} failed: ${message}`);\n    }\n  }\n\n  function buildApplicableTemplates(\n    graphView: WorldRuntime,\n    rejectionReasons: Map<string, string>\n  ): GrowthTemplate[] {\n    return deps.runtimeTemplates.filter(t => {\n      const runCount = deps.templateRunCounts.get(t.id) || 0;\n      if (runCount >= deps.maxRunsPerTemplate) {\n        rejectionReasons.set(t.id, `run_cap: ${runCount}/${deps.maxRunsPerTemplate}`);\n        return false;\n      }\n\n      if (!t.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(t.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n// ... (truncated)", "parameters": [{"name": "config", "type": "GrowthSystemConfig", "optional": false}, {"name": "deps", "type": "GrowthSystemDependencies", "optional": false}], "returnType": "GrowthSystem"}, {"id": "apps/lore-weave/lib/index.ts::loadActions", "name": "loadActions", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load declarative actions and convert them to executable actions.\n */\nexport function loadActions(actions: DeclarativeAction[]): ExecutableAction[] {\n  if (!Array.isArray(actions)) {\n    console.warn('loadActions: expected array, got', typeof actions);\n    return [];\n  }\n\n  const executableActions: ExecutableAction[] = [];\n\n  for (const action of actions) {\n    if (!action || !action.id) {\n      console.warn('loadActions: skipping invalid action', action);\n      continue;\n    }\n\n    // Skip disabled actions (default to enabled if not specified)\n    if (action.enabled === false) {\n      continue;\n    }\n\n    try {\n      const executable = createExecutableAction(action);\n      executableActions.push(executable);\n    } catch (error) {\n      console.error(`Failed to create action ${action.id}:`, error);\n    }\n  }\n\n  return executableActions;\n}", "parameters": [{"name": "actions", "type": "DeclarativeAction[]", "optional": false}], "returnType": "ExecutableAction[]"}, {"id": "apps/lore-weave/lib/index.ts::createExecutableAction", "name": "createExecutableAction", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// ACTION FACTORY\n// =============================================================================\n\n/**\n * Convert a declarative action to an executable action.\n */\nexport function createExecutableAction(action: DeclarativeAction): ExecutableAction {\n  return {\n    type: action.id,\n    name: action.name,\n    description: action.description,\n    baseSuccessChance: action.probability.baseSuccessChance,\n    baseWeight: action.probability.baseWeight,\n    pressureModifiers: action.probability.pressureModifiers || [],\n    actorConfig: action.actor,\n    actorProminenceDelta: {\n      onSuccess: action.outcome.actorProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.actorProminenceDelta?.onFailure ?? 0,\n    },\n    targetProminenceDelta: {\n      onSuccess: action.outcome.targetProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.targetProminenceDelta?.onFailure ?? 0,\n    },\n    handler: createActionHandler(action)\n  };\n}", "parameters": [{"name": "action", "type": "DeclarativeAction", "optional": false}], "returnType": "ExecutableAction"}, {"id": "apps/lore-weave/lib/index.ts::matchesActorConfig", "name": "matchesActorConfig", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity matches the actor configuration for an action.\n */\nexport function matchesActorConfig(\n  entity: HardState,\n  actorConfig: ActionActorConfig,\n  graphView: WorldRuntime\n): boolean {\n  const bindings: Record<string, HardState | undefined> = { actor: entity };\n  const ctx = createActionContext(graphView, bindings, entity);\n\n  // Eligibility: actor must appear in selection results (no random picking).\n  const selectionRule = {\n    ...actorConfig.selection,\n    pickStrategy: 'all' as const,\n    maxResults: undefined,\n  };\n\n  const candidates = selectEntities(selectionRule, ctx);\n  if (!candidates.some((candidate) => candidate.id === entity.id)) {\n    return false;\n  }\n\n  // Resolve optional instigator\n  if (actorConfig.instigator) {\n    const instigator = resolveSingleEntity(actorConfig.instigator, ctx);\n    if (!instigator && actorConfig.instigator.required) {\n      return false;\n    }\n    bindings.instigator = instigator;\n  }\n\n  // Evaluate conditions\n  if (actorConfig.conditions && actorConfig.conditions.length > 0) {\n    for (const condition of actorConfig.conditions) {\n      const result = evaluateCondition(condition, ctx, entity);\n      if (!result.passed) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "actorConfig", "type": "ActionActorConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/index.ts::createCoordinateContext", "name": "createCoordinateContext", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// FACTORY FUNCTION\n// =============================================================================\n\n/**\n * Create a CoordinateContext from configuration.\n */\nexport function createCoordinateContext(\n  config: CoordinateContextConfig\n): CoordinateContext {\n  return new CoordinateContext(config);\n}", "parameters": [{"name": "config", "type": "CoordinateContextConfig", "optional": false}], "returnType": "CoordinateContext"}, {"id": "apps/lore-weave/lib/index.ts::createTemplateFromDeclarative", "name": "createTemplateFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Creates a GrowthTemplate from a DeclarativeTemplate.\r\n * This allows declarative templates to be used with the existing WorldEngine.\r\n */\r\nexport function createTemplateFromDeclarative(\r\n  template: DeclarativeTemplate,\r\n  interpreter: TemplateInterpreter\r\n): GrowthTemplate {\r\n  return {\r\n    id: template.id,\r\n    name: template.name,\r\n\r\n    canApply: (graphView: WorldRuntime) => {\r\n      return interpreter.canApply(template, graphView);\r\n    },\r\n\r\n    findTargets: (graphView: WorldRuntime) => {\r\n      return interpreter.findTargets(template, graphView);\r\n    },\r\n\r\n    expand: async (graphView: WorldRuntime, target?: HardState) => {\r\n      return interpreter.expand(template, graphView, target);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "template", "type": "DeclarativeTemplate", "optional": false}, {"name": "interpreter", "type": "TemplateInterpreter", "optional": false}], "returnType": "GrowthTemplate"}, {"id": "apps/lore-weave/lib/index.ts::createPressureFromDeclarative", "name": "createPressureFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// PRESSURE INTERPRETER\n// =============================================================================\n\n/**\n * Convert a declarative pressure to a runtime Pressure object\n */\nexport function createPressureFromDeclarative(definition: DeclarativePressure): Pressure {\n  return {\n    id: definition.id,\n    name: definition.name,\n    value: definition.initialValue,\n    homeostasis: definition.homeostasis,\n    contract: definition.contract,\n\n    growth: (graph: Graph): number => {\n      const config = definition.growth;\n      const metricCtx = createMetricContext(graph);\n\n      let total = 0;\n\n      // Add positive feedback\n      for (const factor of config.positiveFeedback) {\n        total += evaluateFactor(factor, metricCtx);\n      }\n\n      // Subtract negative feedback\n      for (const factor of config.negativeFeedback) {\n        total -= evaluateFactor(factor, metricCtx);\n      }\n\n      return total;\n    }\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure"}, {"id": "apps/lore-weave/lib/index.ts::loadPressures", "name": "loadPressures", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load all pressures from a PressuresFile\n */\nexport function loadPressures(file: PressuresFile): Pressure[] {\n  return file.pressures.map(createPressureFromDeclarative);\n}", "parameters": [{"name": "file", "type": "PressuresFile", "optional": false}], "returnType": "Pressure[]"}, {"id": "apps/lore-weave/lib/index.ts::loadPressure", "name": "loadPressure", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load a single pressure from a declarative definition\n */\nexport function loadPressure(definition: DeclarativePressure): Pressure {\n  return createPressureFromDeclarative(definition);\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure"}, {"id": "apps/lore-weave/lib/index.ts::createSystemFromDeclarative", "name": "createSystemFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM CREATION\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a declarative configuration.\r\n *\r\n * @param declarative - The declarative system configuration\r\n * @returns A SimulationSystem that can be used by WorldEngine\r\n */\r\nexport function createSystemFromDeclarative(\r\n  declarative: DeclarativeSystem,\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem {\r\n  switch (declarative.systemType) {\r\n    case 'connectionEvolution':\r\n      return createConnectionEvolutionSystem(declarative.config);\r\n\r\n    case 'graphContagion':\r\n      return createGraphContagionSystem(declarative.config);\r\n\r\n    case 'thresholdTrigger':\r\n      return createThresholdTriggerSystem(declarative.config);\r\n\r\n    case 'clusterFormation':\r\n      return createClusterFormationSystem(declarative.config);\r\n\r\n    case 'tagDiffusion':\r\n      return createTagDiffusionSystem(declarative.config);\r\n\r\n    case 'planeDiffusion':\r\n      return createPlaneDiffusionSystem(declarative.config);\r\n\r\n    // Framework systems - create configured instances\r\n    case 'eraSpawner':\r\n      return createEraSpawnerSystem(declarative.config);\r\n\r\n    case 'eraTransition':\r\n      return createEraTransitionSystem(declarative.config);\r\n\r\n    case 'universalCatalyst':\r\n      return createUniversalCatalystSystem(declarative.config);\r\n\r\n    case 'relationshipMaintenance':\r\n      return createRelationshipMaintenanceSystem(declarative.config);\r\n\r\n    case 'growth':\r\n      if (!options?.growthDependencies) {\r\n        throw new Error('Growth system requires engine-level dependencies; pass growthDependencies to createSystemFromDeclarative');\r\n      }\r\n      return createGrowthSystem(declarative.config, options.growthDependencies);\r\n\r\n    default: {\r\n      // TypeScript should catch this, but just in case\r\n      const exhaustive: never = declarative;\r\n      throw new Error(`Unknown system type: ${(exhaustive as DeclarativeSystem).systemType}`);\r\n    }\r\n  }\r\n}", "parameters": [{"name": "declarative", "type": "DeclarativeSystem", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/index.ts::loadSystems", "name": "loadSystems", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Load multiple systems from declarative configurations.\r\n * Filters out any invalid configs and logs warnings.\r\n *\r\n * @param declaratives - Array of declarative system configurations\r\n * @returns Array of SimulationSystem objects\r\n */\r\nexport function loadSystems(\r\n  declaratives: DeclarativeSystem[],\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem[] {\r\n  if (!Array.isArray(declaratives)) {\r\n    console.warn('loadSystems: expected array, got', typeof declaratives);\r\n    return [];\r\n  }\r\n\r\n  return declaratives\r\n    .filter(d => {\r\n      if (!d || typeof d !== 'object') {\r\n        console.warn('loadSystems: skipping invalid config', d);\r\n        return false;\r\n      }\r\n      if ('enabled' in d && d.enabled === false) {\r\n        return false;\r\n      }\r\n      if (!d.systemType) {\r\n        console.warn('loadSystems: skipping config without systemType', d);\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    .map(d => {\r\n      try {\r\n        return createSystemFromDeclarative(d, options);\r\n      } catch (error) {\r\n        console.error(`Failed to create system from config:`, d, error);\r\n        throw error;\r\n      }\r\n    });\r\n}", "parameters": [{"name": "declaratives", "type": "DeclarativeSystem[]", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem[]"}, {"id": "apps/lore-weave/lib/index.ts::isDeclarativeSystem", "name": "isDeclarativeSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if a value is a valid declarative system configuration.\r\n */\r\nexport function isDeclarativeSystem(value: unknown): value is DeclarativeSystem {\r\n  if (!value || typeof value !== 'object') return false;\r\n  const sys = value as Record<string, unknown>;\r\n  return (\r\n    sys.systemType === 'connectionEvolution' ||\r\n    sys.systemType === 'graphContagion' ||\r\n    sys.systemType === 'thresholdTrigger' ||\r\n    sys.systemType === 'clusterFormation' ||\r\n    sys.systemType === 'tagDiffusion' ||\r\n    sys.systemType === 'planeDiffusion' ||\r\n    sys.systemType === 'eraSpawner' ||\r\n    sys.systemType === 'eraTransition' ||\r\n    sys.systemType === 'universalCatalyst' ||\r\n    sys.systemType === 'relationshipMaintenance' ||\r\n    sys.systemType === 'growth'\r\n  ) && sys.config !== undefined;\r\n}", "parameters": [{"name": "value", "type": "unknown", "optional": false}], "returnType": "value is DeclarativeSystem"}, {"id": "apps/lore-weave/lib/coordinates/coordinateContext.ts::createCoordinateContext", "name": "createCoordinateContext", "kind": "function", "filePath": "apps/lore-weave/lib/coordinates/coordinateContext.ts", "sourceCode": "// =============================================================================\n// FACTORY FUNCTION\n// =============================================================================\n\n/**\n * Create a CoordinateContext from configuration.\n */\nexport function createCoordinateContext(\n  config: CoordinateContextConfig\n): CoordinateContext {\n  return new CoordinateContext(config);\n}", "parameters": [{"name": "config", "type": "CoordinateContextConfig", "optional": false}], "returnType": "CoordinateContext"}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateId", "name": "generateId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "export function generateId(prefix: string): string {\n  return `${prefix}_${idCounter++}`;\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateEventId", "name": "generateEventId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "/**\n * Generate a globally unique ID for narrative events.\n */\nexport function generateEventId(): string {\n  const cryptoObj = (globalThis as { crypto?: { randomUUID?: () => string } }).crypto;\n  if (cryptoObj?.randomUUID) {\n    return `event_${cryptoObj.randomUUID()}`;\n  }\n  return `event_${Date.now()}_${eventCounter++}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateLoreId", "name": "generateLoreId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "/**\r\n * Generate unique ID for lore records with timestamp and counter\r\n */\r\nexport function generateLoreId(prefix: string): string {\r\n  return `${prefix}_${Date.now()}_${loreRecordCounter++}`;\r\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/engine/actionInterpreter.ts::createExecutableAction", "name": "createExecutableAction", "kind": "function", "filePath": "apps/lore-weave/lib/engine/actionInterpreter.ts", "sourceCode": "// =============================================================================\n// ACTION FACTORY\n// =============================================================================\n\n/**\n * Convert a declarative action to an executable action.\n */\nexport function createExecutableAction(action: DeclarativeAction): ExecutableAction {\n  return {\n    type: action.id,\n    name: action.name,\n    description: action.description,\n    baseSuccessChance: action.probability.baseSuccessChance,\n    baseWeight: action.probability.baseWeight,\n    pressureModifiers: action.probability.pressureModifiers || [],\n    actorConfig: action.actor,\n    actorProminenceDelta: {\n      onSuccess: action.outcome.actorProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.actorProminenceDelta?.onFailure ?? 0,\n    },\n    targetProminenceDelta: {\n      onSuccess: action.outcome.targetProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.targetProminenceDelta?.onFailure ?? 0,\n    },\n    handler: createActionHandler(action)\n  };\n}", "parameters": [{"name": "action", "type": "DeclarativeAction", "optional": false}], "returnType": "ExecutableAction"}, {"id": "apps/lore-weave/lib/engine/actionInterpreter.ts::loadActions", "name": "loadActions", "kind": "function", "filePath": "apps/lore-weave/lib/engine/actionInterpreter.ts", "sourceCode": "/**\n * Load declarative actions and convert them to executable actions.\n */\nexport function loadActions(actions: DeclarativeAction[]): ExecutableAction[] {\n  if (!Array.isArray(actions)) {\n    console.warn('loadActions: expected array, got', typeof actions);\n    return [];\n  }\n\n  const executableActions: ExecutableAction[] = [];\n\n  for (const action of actions) {\n    if (!action || !action.id) {\n      console.warn('loadActions: skipping invalid action', action);\n      continue;\n    }\n\n    // Skip disabled actions (default to enabled if not specified)\n    if (action.enabled === false) {\n      continue;\n    }\n\n    try {\n      const executable = createExecutableAction(action);\n      executableActions.push(executable);\n    } catch (error) {\n      console.error(`Failed to create action ${action.id}:`, error);\n    }\n  }\n\n  return executableActions;\n}", "parameters": [{"name": "actions", "type": "DeclarativeAction[]", "optional": false}], "returnType": "ExecutableAction[]"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateTemplates", "name": "validateTemplates", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "// =============================================================================\r\n// VALIDATION FUNCTIONS\r\n// =============================================================================\r\n\r\nexport function validateTemplates(templates: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(templates)) {\r\n    errors.push({\r\n      path: 'templates',\r\n      message: 'Expected array',\r\n      value: templates,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  templates.forEach((template, index) => {\r\n    // Skip disabled templates\r\n    if (typeof template === 'object' && template !== null &&\r\n        'enabled' in template && (template as { enabled: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(template) || `[${index}]`;\r\n\r\n    if (!validateGenerator(template)) {\r\n      errors.push(...formatAjvErrors(validateGenerator.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "templates", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validatePressures", "name": "validatePressures", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validatePressures(pressures: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(pressures)) {\r\n    errors.push({\r\n      path: 'pressures',\r\n      message: 'Expected array',\r\n      value: pressures,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  pressures.forEach((pressure, index) => {\r\n    const itemId = getItemId(pressure) || `[${index}]`;\r\n\r\n    if (!validatePressure(pressure)) {\r\n      errors.push(...formatAjvErrors(validatePressure.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "pressures", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateSystems", "name": "validateSystems", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateSystems(systems: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(systems)) {\r\n    errors.push({\r\n      path: 'systems',\r\n      message: 'Expected array',\r\n      value: systems,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  systems.forEach((system, index) => {\r\n    // Skip disabled systems\r\n    if (typeof system === 'object' && system !== null &&\r\n        'enabled' in system && (system as { enabled?: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(system) || `[${index}]`;\r\n\r\n    if (!validateSystem(system)) {\r\n      errors.push(...formatAjvErrors(validateSystem.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "systems", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateEras", "name": "validateEras", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateEras(eras: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(eras)) {\r\n    errors.push({\r\n      path: 'eras',\r\n      message: 'Expected array',\r\n      value: eras,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  eras.forEach((era, index) => {\r\n    const itemId = getItemId(era) || `[${index}]`;\r\n\r\n    if (!validateEra(era)) {\r\n      errors.push(...formatAjvErrors(validateEra.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "eras", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateActions", "name": "validateActions", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateActions(actions: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(actions)) {\r\n    errors.push({\r\n      path: 'actions',\r\n      message: 'Expected array',\r\n      value: actions,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  actions.forEach((action, index) => {\r\n    // Skip disabled actions\r\n    if (typeof action === 'object' && action !== null &&\r\n        'enabled' in action && (action as { enabled: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(action) || `[${index}]`;\r\n\r\n    if (!validateAction(action)) {\r\n      errors.push(...formatAjvErrors(validateAction.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "actions", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateEntities", "name": "validateEntities", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "/**\r\n * Validate world entities from simulation output or persisted data.\r\n * Use this when loading saved simulation data from IndexedDB.\r\n */\r\nexport function validateEntities(entities: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(entities)) {\r\n    errors.push({\r\n      path: 'entities',\r\n      message: 'Expected array',\r\n      value: entities,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  entities.forEach((entity, index) => {\r\n    const itemId = getItemId(entity) || `[${index}]`;\r\n\r\n    if (!validateEntity(entity)) {\r\n      errors.push(...formatAjvErrors(validateEntity.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "entities", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateAllConfigs", "name": "validateAllConfigs", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "/**\r\n * Validate all configuration files at once\r\n */\r\nexport function validateAllConfigs(config: {\r\n  templates?: unknown;\r\n  pressures?: unknown;\r\n  systems?: unknown;\r\n  eras?: unknown;\r\n  actions?: unknown;\r\n  seedEntities?: unknown;\r\n  schema?: {\r\n    cultures?: string[];\r\n    entityKinds?: string[];\r\n    relationshipKinds?: string[];\r\n  };\r\n}): SchemaValidationResult {\r\n  const allErrors: SchemaError[] = [];\r\n  const allWarnings: SchemaError[] = [];\r\n\r\n  if (config.templates !== undefined) {\r\n    const result = validateTemplates(config.templates);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.pressures !== undefined) {\r\n    const result = validatePressures(config.pressures);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.systems !== undefined) {\r\n    const result = validateSystems(config.systems);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.eras !== undefined) {\r\n    const result = validateEras(config.eras);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.actions !== undefined) {\r\n    const result = validateActions(config.actions);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.seedEntities !== undefined) {\r\n    const result = validateEntities(config.seedEntities);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  return {\r\n    valid: allErrors.length === 0,\r\n    errors: allErrors,\r\n    warnings: allWarnings,\r\n  };\r\n}", "parameters": [{"name": "config", "type": "{\r\n  templates?: unknown;\r\n  pressures?: unknown;\r\n  systems?: unknown;\r\n  eras?: unknown;\r\n  actions?: unknown;\r\n  seedEntities?: unknown;\r\n  schema?: {\r\n    cultures?: string[];\r\n    entityKinds?: string[];\r\n    relationshipKinds?: string[];\r\n  };\r\n}", "optional": false}], "returnType": "SchemaValidationResult"}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::formatValidationResult", "name": "formatValidationResult", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function formatValidationResult(result: SchemaValidationResult): string {\r\n  if (result.valid && result.warnings.length === 0) {\r\n    return 'Configuration is valid.';\r\n  }\r\n\r\n  const lines: string[] = [\r\n    ...formatErrorLines(result.errors),\r\n    ...formatWarningLines(result.warnings),\r\n  ];\r\n\r\n  return lines.join('\\n');\r\n}", "parameters": [{"name": "result", "type": "SchemaValidationResult", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::selectEra", "name": "selectEra", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Select the appropriate era based on the current epoch.\n * Distributes epochs evenly across eras.\n */\nexport function selectEra(epoch: number, eras: Era[], epochsPerEra: number = 2): Era {\n  const eraIndex = Math.floor(epoch / epochsPerEra);\n  return eras[Math.min(eraIndex, eras.length - 1)];\n}", "parameters": [{"name": "epoch", "type": "number", "optional": false}, {"name": "eras", "type": "Era[]", "optional": false}, {"name": "epochsPerEra", "type": "number", "optional": true}], "returnType": "Era"}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::getTemplateWeight", "name": "getTemplateWeight", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Get the era-modified weight for a template.\n * Returns baseWeight * era modifier (defaults to 1.0 if not specified).\n */\nexport function getTemplateWeight(\n  era: Era,\n  templateId: string,\n  baseWeight: number = 1.0\n): number {\n  const modifier = era.templateWeights[templateId] ?? 1.0;\n  return baseWeight * modifier;\n}", "parameters": [{"name": "era", "type": "Era", "optional": false}, {"name": "templateId", "type": "string", "optional": false}, {"name": "baseWeight", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::getSystemModifier", "name": "getSystemModifier", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Get the era modifier for a system.\n * Returns baseValue * era modifier (defaults to 1.0 if not specified).\n */\nexport function getSystemModifier(\n  era: Era,\n  systemId: string,\n  baseValue: number = 1.0\n): number {\n  const modifier = era.systemModifiers[systemId] ?? 1.0;\n  return baseValue * modifier;\n}", "parameters": [{"name": "era", "type": "Era", "optional": false}, {"name": "systemId", "type": "string", "optional": false}, {"name": "baseValue", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::evaluatePressureGrowthWithBreakdown", "name": "evaluatePressureGrowthWithBreakdown", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Evaluate all factors for a pressure and return detailed breakdown\n */\nexport function evaluatePressureGrowthWithBreakdown(\n  definition: DeclarativePressure,\n  graph: Graph\n): {\n  positiveFeedback: FeedbackContribution[];\n  negativeFeedback: FeedbackContribution[];\n  feedbackTotal: number;\n} {\n  const config = definition.growth;\n\n  const positiveFeedback: FeedbackContribution[] = [];\n  const negativeFeedback: FeedbackContribution[] = [];\n  const metricCtx = createMetricContext(graph);\n\n  let total = 0;\n\n  for (const factor of config.positiveFeedback) {\n    const details = evaluateFactorWithDetails(factor, metricCtx);\n    positiveFeedback.push(details);\n    total += details.contribution;\n  }\n\n  for (const factor of config.negativeFeedback) {\n    const details = evaluateFactorWithDetails(factor, metricCtx);\n    negativeFeedback.push(details);\n    total -= details.contribution;\n  }\n\n  return {\n    positiveFeedback,\n    negativeFeedback,\n    feedbackTotal: total\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}, {"name": "graph", "type": "Graph", "optional": false}], "returnType": "{\n  positiveFeedback: FeedbackContribution[];\n  negativeFeedback: FeedbackContribution[];\n  feedbackTotal: number;\n}"}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::createPressureFromDeclarative", "name": "createPressureFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "// =============================================================================\n// PRESSURE INTERPRETER\n// =============================================================================\n\n/**\n * Convert a declarative pressure to a runtime Pressure object\n */\nexport function createPressureFromDeclarative(definition: DeclarativePressure): Pressure {\n  return {\n    id: definition.id,\n    name: definition.name,\n    value: definition.initialValue,\n    homeostasis: definition.homeostasis,\n    contract: definition.contract,\n\n    growth: (graph: Graph): number => {\n      const config = definition.growth;\n      const metricCtx = createMetricContext(graph);\n\n      let total = 0;\n\n      // Add positive feedback\n      for (const factor of config.positiveFeedback) {\n        total += evaluateFactor(factor, metricCtx);\n      }\n\n      // Subtract negative feedback\n      for (const factor of config.negativeFeedback) {\n        total -= evaluateFactor(factor, metricCtx);\n      }\n\n      return total;\n    }\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure"}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::loadPressures", "name": "loadPressures", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Load all pressures from a PressuresFile\n */\nexport function loadPressures(file: PressuresFile): Pressure[] {\n  return file.pressures.map(createPressureFromDeclarative);\n}", "parameters": [{"name": "file", "type": "PressuresFile", "optional": false}], "returnType": "Pressure[]"}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::loadPressure", "name": "loadPressure", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Load a single pressure from a declarative definition\n */\nexport function loadPressure(definition: DeclarativePressure): Pressure {\n  return createPressureFromDeclarative(definition);\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure"}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::createSystemFromDeclarative", "name": "createSystemFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM CREATION\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a declarative configuration.\r\n *\r\n * @param declarative - The declarative system configuration\r\n * @returns A SimulationSystem that can be used by WorldEngine\r\n */\r\nexport function createSystemFromDeclarative(\r\n  declarative: DeclarativeSystem,\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem {\r\n  switch (declarative.systemType) {\r\n    case 'connectionEvolution':\r\n      return createConnectionEvolutionSystem(declarative.config);\r\n\r\n    case 'graphContagion':\r\n      return createGraphContagionSystem(declarative.config);\r\n\r\n    case 'thresholdTrigger':\r\n      return createThresholdTriggerSystem(declarative.config);\r\n\r\n    case 'clusterFormation':\r\n      return createClusterFormationSystem(declarative.config);\r\n\r\n    case 'tagDiffusion':\r\n      return createTagDiffusionSystem(declarative.config);\r\n\r\n    case 'planeDiffusion':\r\n      return createPlaneDiffusionSystem(declarative.config);\r\n\r\n    // Framework systems - create configured instances\r\n    case 'eraSpawner':\r\n      return createEraSpawnerSystem(declarative.config);\r\n\r\n    case 'eraTransition':\r\n      return createEraTransitionSystem(declarative.config);\r\n\r\n    case 'universalCatalyst':\r\n      return createUniversalCatalystSystem(declarative.config);\r\n\r\n    case 'relationshipMaintenance':\r\n      return createRelationshipMaintenanceSystem(declarative.config);\r\n\r\n    case 'growth':\r\n      if (!options?.growthDependencies) {\r\n        throw new Error('Growth system requires engine-level dependencies; pass growthDependencies to createSystemFromDeclarative');\r\n      }\r\n      return createGrowthSystem(declarative.config, options.growthDependencies);\r\n\r\n    default: {\r\n      // TypeScript should catch this, but just in case\r\n      const exhaustive: never = declarative;\r\n      throw new Error(`Unknown system type: ${(exhaustive as DeclarativeSystem).systemType}`);\r\n    }\r\n  }\r\n}", "parameters": [{"name": "declarative", "type": "DeclarativeSystem", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::loadSystems", "name": "loadSystems", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "/**\r\n * Load multiple systems from declarative configurations.\r\n * Filters out any invalid configs and logs warnings.\r\n *\r\n * @param declaratives - Array of declarative system configurations\r\n * @returns Array of SimulationSystem objects\r\n */\r\nexport function loadSystems(\r\n  declaratives: DeclarativeSystem[],\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem[] {\r\n  if (!Array.isArray(declaratives)) {\r\n    console.warn('loadSystems: expected array, got', typeof declaratives);\r\n    return [];\r\n  }\r\n\r\n  return declaratives\r\n    .filter(d => {\r\n      if (!d || typeof d !== 'object') {\r\n        console.warn('loadSystems: skipping invalid config', d);\r\n        return false;\r\n      }\r\n      if ('enabled' in d && d.enabled === false) {\r\n        return false;\r\n      }\r\n      if (!d.systemType) {\r\n        console.warn('loadSystems: skipping config without systemType', d);\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    .map(d => {\r\n      try {\r\n        return createSystemFromDeclarative(d, options);\r\n      } catch (error) {\r\n        console.error(`Failed to create system from config:`, d, error);\r\n        throw error;\r\n      }\r\n    });\r\n}", "parameters": [{"name": "declaratives", "type": "DeclarativeSystem[]", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem[]"}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::isDeclarativeSystem", "name": "isDeclarativeSystem", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "/**\r\n * Check if a value is a valid declarative system configuration.\r\n */\r\nexport function isDeclarativeSystem(value: unknown): value is DeclarativeSystem {\r\n  if (!value || typeof value !== 'object') return false;\r\n  const sys = value as Record<string, unknown>;\r\n  return (\r\n    sys.systemType === 'connectionEvolution' ||\r\n    sys.systemType === 'graphContagion' ||\r\n    sys.systemType === 'thresholdTrigger' ||\r\n    sys.systemType === 'clusterFormation' ||\r\n    sys.systemType === 'tagDiffusion' ||\r\n    sys.systemType === 'planeDiffusion' ||\r\n    sys.systemType === 'eraSpawner' ||\r\n    sys.systemType === 'eraTransition' ||\r\n    sys.systemType === 'universalCatalyst' ||\r\n    sys.systemType === 'relationshipMaintenance' ||\r\n    sys.systemType === 'growth'\r\n  ) && sys.config !== undefined;\r\n}", "parameters": [{"name": "value", "type": "unknown", "optional": false}], "returnType": "value is DeclarativeSystem"}, {"id": "apps/lore-weave/lib/engine/templateInterpreter.ts::createTemplateFromDeclarative", "name": "createTemplateFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/templateInterpreter.ts", "sourceCode": "/**\r\n * Creates a GrowthTemplate from a DeclarativeTemplate.\r\n * This allows declarative templates to be used with the existing WorldEngine.\r\n */\r\nexport function createTemplateFromDeclarative(\r\n  template: DeclarativeTemplate,\r\n  interpreter: TemplateInterpreter\r\n): GrowthTemplate {\r\n  return {\r\n    id: template.id,\r\n    name: template.name,\r\n\r\n    canApply: (graphView: WorldRuntime) => {\r\n      return interpreter.canApply(template, graphView);\r\n    },\r\n\r\n    findTargets: (graphView: WorldRuntime) => {\r\n      return interpreter.findTargets(template, graphView);\r\n    },\r\n\r\n    expand: async (graphView: WorldRuntime, target?: HardState) => {\r\n      return interpreter.expand(template, graphView, target);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "template", "type": "DeclarativeTemplate", "optional": false}, {"name": "interpreter", "type": "TemplateInterpreter", "optional": false}], "returnType": "GrowthTemplate"}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateConnectedEntities", "name": "validateConnectedEntities", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that all entities have at least one connection (incoming or outgoing)\n */\nexport function validateConnectedEntities(graph: Graph): ValidationResult {\n  const unconnected = graph.getEntities().filter(entity => {\n    const hasOutgoing = graph.getEntityRelationships(entity.id, 'src').length > 0;\n    const hasIncoming = graph.getEntityRelationships(entity.id, 'dst').length > 0;\n\n    return !hasOutgoing && !hasIncoming;\n  });\n\n  const passed = unconnected.length === 0;\n\n  let details = passed\n    ? 'All entities have at least one connection'\n    : `${unconnected.length} entities have no connections:\\n`;\n\n  if (!passed) {\n    // Group by kind for summary\n    const byKind = new Map<string, number>();\n    unconnected.forEach(e => {\n      const key = `${e.kind}:${e.subtype}`;\n      byKind.set(key, (byKind.get(key) || 0) + 1);\n    });\n\n    byKind.forEach((count, kind) => {\n      details += `  - ${kind}: ${count}\\n`;\n    });\n\n    // Add sample entities\n    details += '\\nSample unconnected entities:\\n';\n    unconnected.slice(0, 5).forEach(e => {\n      details += `  - ${e.name} (${e.kind}:${e.subtype}, created tick ${e.createdAt})\\n`;\n    });\n  }\n\n  return {\n    name: 'Connected Entities',\n    passed,\n    failureCount: unconnected.length,\n    details,\n    failedEntities: unconnected\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "ValidationResult"}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateNPCStructure", "name": "validateNPCStructure", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that entities have required structural relationships.\n * Uses canonical schema requirements (no hardcoded entity kinds).\n */\nexport function validateNPCStructure(graph: Graph, config: EngineConfig): ValidationResult {\n  const invalidEntities: HardState[] = [];\n  const missingByKindSubtype = new Map<string, Map<string, number>>();\n  const kindsWithRequirements = config.schema.entityKinds.filter(\n    kindDef => kindDef.requiredRelationships && kindDef.requiredRelationships.length > 0\n  );\n\n  if (kindsWithRequirements.length === 0) {\n    return {\n      name: 'Entity Structure',\n      passed: true,\n      failureCount: 0,\n      details: 'No requiredRelationships defined in schema'\n    };\n  }\n\n  // Check all entities against schema requirements\n  for (const entity of graph.getEntities()) {\n    const kindDef = config.schema.entityKinds.find(kind => kind.kind === entity.kind);\n    const required = kindDef?.requiredRelationships;\n    if (!required || required.length === 0) continue;\n\n    const relationships = graph.getEntityRelationships(entity.id, 'both', { includeHistorical: true });\n    const missing = required.filter(rule => !relationships.some(rel => rel.kind === rule.kind));\n\n    if (missing.length > 0) {\n      invalidEntities.push(entity);\n\n      // Track missing relationships by kind:subtype\n      const key = `${entity.kind}:${entity.subtype}`;\n      if (!missingByKindSubtype.has(key)) {\n        missingByKindSubtype.set(key, new Map());\n      }\n      const subtypeMap = missingByKindSubtype.get(key)!;\n\n      missing.forEach(rule => {\n        subtypeMap.set(rule.kind, (subtypeMap.get(rule.kind) || 0) + 1);\n      });\n    }\n  }\n\n  const passed = invalidEntities.length === 0;\n\n  let details = passed\n    ? 'All entities have required relationships'\n    : `${invalidEntities.length} entities missing required relationships:\\n`;\n\n  if (!passed) {\n    // Group by kind:subtype and missing relationships\n    missingByKindSubtype.forEach((relMap, kindSubtype) => {\n      relMap.forEach((count, relKind) => {\n        details += `  - ${kindSubtype}: ${count} (missing ${relKind})\\n`;\n      });\n    });\n  }\n\n  return {\n    name: 'Entity Structure',\n    passed,\n    failureCount: invalidEntities.length,\n    details,\n    failedEntities: invalidEntities\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationResult"}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateRelationshipIntegrity", "name": "validateRelationshipIntegrity", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that all relationship references point to existing entities\n */\nexport function validateRelationshipIntegrity(graph: Graph): ValidationResult {\n  const brokenRelationships: string[] = [];\n\n  graph.getRelationships().forEach((rel, index) => {\n    const srcExists = graph.getEntity(rel.src) !== undefined;\n    const dstExists = graph.getEntity(rel.dst) !== undefined;\n\n    if (!srcExists || !dstExists) {\n      const srcName = graph.getEntity(rel.src)?.name || rel.src;\n      const dstName = graph.getEntity(rel.dst)?.name || rel.dst;\n      brokenRelationships.push(\n        `[${index}] ${rel.kind}: ${srcName} \u2192 ${dstName} ` +\n        `(${!srcExists ? 'src missing' : ''} ${!dstExists ? 'dst missing' : ''})`\n      );\n    }\n  });\n\n  const passed = brokenRelationships.length === 0;\n\n  let details = passed\n    ? 'All relationships reference existing entities'\n    : `${brokenRelationships.length} broken relationships:\\n`;\n\n  if (!passed) {\n    brokenRelationships.slice(0, 10).forEach(msg => {\n      details += `  - ${msg}\\n`;\n    });\n    if (brokenRelationships.length > 10) {\n      details += `  ... and ${brokenRelationships.length - 10} more\\n`;\n    }\n  }\n\n  return {\n    name: 'Relationship Integrity',\n    passed,\n    failureCount: brokenRelationships.length,\n    details\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "ValidationResult"}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateWorld", "name": "validateWorld", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "// validateLorePresence moved to @illuminator\n\n/**\n * Run all validators and generate a complete report\n */\nexport function validateWorld(graph: Graph, config: EngineConfig): ValidationReport {\n  const results: ValidationResult[] = [\n    validateConnectedEntities(graph),\n    validateNPCStructure(graph, config),\n    validateRelationshipIntegrity(graph)\n    // validateLorePresence moved to @illuminator\n  ];\n\n  const passed = results.filter(r => r.passed).length;\n  const failed = results.filter(r => !r.passed).length;\n\n  return {\n    totalChecks: results.length,\n    passed,\n    failed,\n    results\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationReport"}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::calculateSimilarity", "name": "calculateSimilarity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Calculate similarity score between two entities based on criteria\n */\nexport function calculateSimilarity(\n  e1: HardState,\n  e2: HardState,\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime\n): { score: number; matchedCriteria: string[] } {\n  let score = 0;\n  const matchedCriteria: string[] = [];\n\n  for (const criterion of criteria) {\n    let matches = false;\n\n    switch (criterion.type) {\n      case 'shared_relationship': {\n        if (!criterion.relationshipKind) break;\n        const direction = criterion.direction || 'src';\n\n        const e1Related = graphView.getConnectedEntities(e1.id, criterion.relationshipKind, direction);\n        const e2Related = graphView.getConnectedEntities(e2.id, criterion.relationshipKind, direction);\n        const e1RelatedIds = new Set(e1Related.map(r => r.id));\n        matches = e2Related.some(r => e1RelatedIds.has(r.id));\n        break;\n      }\n\n      case 'shared_tags': {\n        const e1Tags = new Set(Object.keys(e1.tags || {}));\n        const e2Tags = new Set(Object.keys(e2.tags || {}));\n        const intersection = Array.from(e1Tags).filter(t => e2Tags.has(t)).length;\n        const union = new Set([...e1Tags, ...e2Tags]).size;\n        const jaccard = union > 0 ? intersection / union : 0;\n        matches = jaccard >= (criterion.threshold || 0.3);\n        break;\n      }\n\n      case 'temporal_proximity': {\n        const timeDiff = Math.abs(e1.createdAt - e2.createdAt);\n        matches = timeDiff <= (criterion.threshold || 30);\n        break;\n      }\n\n      case 'same_subtype': {\n        matches = e1.subtype === e2.subtype;\n        break;\n      }\n\n      case 'same_culture': {\n        matches = e1.culture === e2.culture;\n        break;\n      }\n\n      case 'custom': {\n        if (criterion.predicate) {\n          matches = criterion.predicate(e1, e2, graphView);\n        }\n        break;\n      }\n    }\n\n    if (matches) {\n      score += criterion.weight;\n      matchedCriteria.push(criterion.type);\n    }\n  }\n\n  return { score, matchedCriteria };\n}", "parameters": [{"name": "e1", "type": "HardState", "optional": false}, {"name": "e2", "type": "HardState", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "{ score: number; matchedCriteria: string[] }"}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::detectClusters", "name": "detectClusters", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "export function detectClusters(\n  entities: HardState[],\n  config: ClusterConfig,\n  graphView: WorldRuntime\n): Cluster[] {\n  if (entities.length < config.minSize) {\n    return [];\n  }\n\n  // Sort by creation time (cluster chronologically related entities)\n  const sorted = [...entities].sort((a, b) => a.createdAt - b.createdAt);\n\n  // Greedy clustering: try to add each entity to an existing cluster or create new one\n  const clusters: Cluster[] = [];\n  const clusterJoinThreshold = config.clusterJoinThreshold ?? 0.7;\n\n  for (const entity of sorted) {\n    const matched = tryAddToExistingCluster(entity, clusters, config, clusterJoinThreshold, graphView);\n    if (!matched) {\n      clusters.push({\n        entities: [entity],\n        score: config.minimumScore,\n        matchedCriteria: []\n      });\n    }\n  }\n\n  // Filter clusters by minimum size and apply maximum size\n  const validClusters = clusters.filter(c => {\n    if (c.entities.length < config.minSize) return false;\n    if (config.maxSize && c.entities.length > config.maxSize) {\n      // Truncate cluster to max size (keep earliest created)\n      c.entities = c.entities.slice(0, config.maxSize);\n    }\n    return true;\n  });\n\n  return validClusters;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "config", "type": "ClusterConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "Cluster[]"}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::filterClusterableEntities", "name": "filterClusterableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Filter entities that are eligible for clustering.\n * Excludes historical entities and meta-entities.\n *\n * @param entities - All entities to filter\n * @returns Filtered entities eligible for clustering\n */\nexport function filterClusterableEntities(entities: HardState[]): HardState[] {\n  return entities.filter(e =>\n    e.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    e.status !== FRAMEWORK_STATUS.SUBSUMED &&\n    !hasTag(e.tags, FRAMEWORK_TAGS.META_ENTITY)\n  );\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::findBestClusterMatch", "name": "findBestClusterMatch", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Find the best cluster match for a new entity.\n * Useful for deciding which existing cluster to add a new entity to.\n *\n * @param entity - Entity to find cluster for\n * @param clusters - Existing clusters\n * @param criteria - Similarity criteria\n * @param graphView - Graph view for relationship queries\n * @param minimumScore - Minimum score to be considered a match\n * @returns Best matching cluster or undefined\n */\nexport function findBestClusterMatch(\n  entity: HardState,\n  clusters: Cluster[],\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime,\n  minimumScore: number\n): Cluster | undefined {\n  let bestCluster: Cluster | undefined;\n  let bestScore = 0;\n\n  for (const cluster of clusters) {\n    let totalScore = 0;\n    let count = 0;\n\n    for (const member of cluster.entities) {\n      const { score } = calculateSimilarity(entity, member, criteria, graphView);\n      totalScore += score;\n      count++;\n    }\n\n    const avgScore = count > 0 ? totalScore / count : 0;\n\n    if (avgScore >= minimumScore && avgScore > bestScore) {\n      bestCluster = cluster;\n      bestScore = avgScore;\n    }\n  }\n\n  return bestCluster;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "clusters", "type": "Cluster[]", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "minimumScore", "type": "number", "optional": false}], "returnType": "Cluster | undefined"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::archiveEntity", "name": "archiveEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Mark an entity as historical and optionally archive its relationships.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity to archive\n * @param options - Archival options\n */\nexport function archiveEntity(\n  graph: Graph,\n  entityId: string,\n  options: ArchiveEntityOptions = {}\n): void {\n  const entity = graph.getEntity(entityId);\n  if (!entity) return;\n\n  const {\n    archiveRelationships: shouldArchiveRels = true,\n    excludeRelationshipKinds = [],\n    status = FRAMEWORK_STATUS.HISTORICAL\n  } = options;\n\n  // Mark entity as historical (use updateEntity to trigger mutation tracking)\n  graph.updateEntity(entityId, { status });\n\n  // Archive relationships if requested\n  if (shouldArchiveRels) {\n    const entityRelationships = graph.getRelationships().filter(r =>\n      (r.src === entityId || r.dst === entityId) &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n      !excludeRelationshipKinds.includes(r.kind)\n    );\n\n    entityRelationships.forEach(rel => {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::archiveEntities", "name": "archiveEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Archive multiple entities at once.\n *\n * @param graph - The world graph\n * @param entityIds - IDs of entities to archive\n * @param options - Archival options\n */\nexport function archiveEntities(\n  graph: Graph,\n  entityIds: string[],\n  options: ArchiveEntityOptions = {}\n): void {\n  entityIds.forEach(id => archiveEntity(graph, id, options));\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityIds", "type": "string[]", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::transferRelationships", "name": "transferRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Transfer relationships from source entities to a target entity.\n * Creates new relationships with the target and optionally archives originals.\n *\n * @param graph - The world graph\n * @param sourceIds - IDs of entities to transfer relationships from\n * @param targetId - ID of entity to transfer relationships to\n * @param options - Transfer options\n * @returns Number of relationships transferred\n */\nexport function transferRelationships(\n  graph: Graph,\n  sourceIds: string[],\n  targetId: string,\n  options: TransferRelationshipsOptions = {}\n): number {\n  const {\n    excludeKinds = [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n    sourceOnly = false,\n    destinationOnly = false,\n    archiveOriginals = true\n  } = options;\n\n  const sourceIdSet = new Set(sourceIds);\n  const transferred = new Set<string>();\n\n  // Find all relationships involving source entities\n  const toTransfer = graph.getRelationships().filter(r =>\n    (sourceIdSet.has(r.src) || sourceIdSet.has(r.dst)) &&\n    r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    !excludeKinds.includes(r.kind)\n  );\n\n  toTransfer.forEach(rel => {\n    let newSrc = rel.src;\n    let newDst = rel.dst;\n\n    // Determine new endpoints\n    if (sourceIdSet.has(rel.src) && !destinationOnly) {\n      newSrc = targetId;\n    }\n    if (sourceIdSet.has(rel.dst) && !sourceOnly) {\n      newDst = targetId;\n    }\n\n    // Skip if no change (shouldn't happen with proper source filtering)\n    if (newSrc === rel.src && newDst === rel.dst) return;\n\n    // Handle self-loops (both endpoints are being transferred to same target)\n    // Don't create self-referential relationship, but DO archive the original\n    if (newSrc === newDst) {\n      if (archiveOriginals) {\n        archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n      }\n      return;\n    }\n\n    // Avoid duplicates\n    const key = `${newSrc}:${newDst}:${rel.kind}`;\n    if (transferred.has(key)) return;\n\n    // Create new relationship\n    addRelationship(graph, rel.kind, newSrc, newDst);\n    transferred.add(key);\n\n    // Archive original if requested\n    if (archiveOriginals) {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    }\n  });\n\n  return transferred.size;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "sourceIds", "type": "string[]", "optional": false}, {"name": "targetId", "type": "string", "optional": false}, {"name": "options", "type": "TransferRelationshipsOptions", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::createPartOfRelationships", "name": "createPartOfRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Create part_of relationships from members to a container entity.\n *\n * @param graph - The world graph\n * @param memberIds - IDs of member entities\n * @param containerId - ID of container entity\n * @returns Number of relationships created\n */\nexport function createPartOfRelationships(\n  graph: Graph,\n  memberIds: string[],\n  containerId: string\n): number {\n  let created = 0;\n\n  memberIds.forEach(memberId => {\n    // Check if relationship already exists\n    const exists = graph.getRelationships().some(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.src === memberId &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    );\n\n    if (!exists) {\n      addRelationship(graph, FRAMEWORK_RELATIONSHIP_KINDS.PART_OF, memberId, containerId);\n      created++;\n    }\n  });\n\n  return created;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "memberIds", "type": "string[]", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getActiveRelationships", "name": "getActiveRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all active relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @param direction - Filter by direction ('src', 'dst', or 'both')\n * @returns Active relationships\n */\nexport function getActiveRelationships(\n  graph: Graph,\n  entityId: string,\n  direction: 'src' | 'dst' | 'both' = 'both'\n): Relationship[] {\n  return graph.getRelationships().filter(r => {\n    if (r.status === FRAMEWORK_STATUS.HISTORICAL) return false;\n\n    switch (direction) {\n      case 'src':\n        return r.src === entityId;\n      case 'dst':\n        return r.dst === entityId;\n      case 'both':\n        return r.src === entityId || r.dst === entityId;\n    }\n  });\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}], "returnType": "Relationship[]"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getHistoricalRelationships", "name": "getHistoricalRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all historical relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @returns Historical relationships\n */\nexport function getHistoricalRelationships(\n  graph: Graph,\n  entityId: string\n): Relationship[] {\n  return graph.getRelationships().filter(r =>\n    r.status === FRAMEWORK_STATUS.HISTORICAL &&\n    (r.src === entityId || r.dst === entityId)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Relationship[]"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::isHistoricalEntity", "name": "isHistoricalEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Check if an entity is historical.\n *\n * @param entity - Entity to check\n * @returns True if entity is historical\n */\nexport function isHistoricalEntity(entity: HardState): boolean {\n  return entity.status === FRAMEWORK_STATUS.HISTORICAL;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getPartOfMembers", "name": "getPartOfMembers", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all entities that are part of a container entity.\n *\n * @param graph - The world graph\n * @param containerId - ID of container entity\n * @returns Member entities\n */\nexport function getPartOfMembers(\n  graph: Graph,\n  containerId: string\n): HardState[] {\n  const memberIds = graph.getRelationships()\n    .filter(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    )\n    .map(r => r.src);\n\n  return memberIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::supersedeEntity", "name": "supersedeEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Supersede one entity with another.\n * Creates supersedes relationship, transfers relationships, and archives original.\n *\n * @param graph - The world graph\n * @param oldEntityId - ID of entity being superseded\n * @param newEntityId - ID of new entity\n * @param options - Supersede options\n */\nexport function supersedeEntity(\n  graph: Graph,\n  oldEntityId: string,\n  newEntityId: string,\n  options: SupersedeEntityOptions = {}\n): void {\n  const {\n    archiveSuperseded = true,\n    createSupersedes = true,\n    ...transferOptions\n  } = options;\n\n  // Create supersedes relationship (new supersedes old)\n  if (createSupersedes) {\n    addRelationship(\n      graph,\n      FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n      newEntityId,\n      oldEntityId\n    );\n  }\n\n  // Transfer relationships from old to new\n  transferRelationships(\n    graph,\n    [oldEntityId],\n    newEntityId,\n    {\n      ...transferOptions,\n      excludeKinds: [\n        ...(transferOptions.excludeKinds || []),\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    }\n  );\n\n  // Archive old entity\n  if (archiveSuperseded) {\n    archiveEntity(graph, oldEntityId, {\n      archiveRelationships: false, // Already handled by transfer\n      excludeRelationshipKinds: [\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "oldEntityId", "type": "string", "optional": false}, {"name": "newEntityId", "type": "string", "optional": false}, {"name": "options", "type": "SupersedeEntityOptions", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/graph/entityClusterBuilder.ts::buildCluster", "name": "buildCluster", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityClusterBuilder.ts", "sourceCode": "/**\n * Helper function to create a new EntityClusterBuilder\n * Usage: buildCluster().addEntity(...).relate(...).build()\n */\nexport function buildCluster(): EntityClusterBuilder {\n  return new EntityClusterBuilder();\n}", "parameters": [], "returnType": "EntityClusterBuilder"}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::slugifyName", "name": "slugifyName", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Slugify a name for use in IDs or other contexts\n */\nexport function slugifyName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '') || 'unknown'; // eslint-disable-line sonarjs/slow-regex -- short slug string, no ReDoS risk\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::generateEntityIdFromName", "name": "generateEntityIdFromName", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Generate a stable entity ID from a name, with optional collision handling.\n */\nexport function generateEntityIdFromName(\n  name: string,\n  hasEntity?: (id: string) => boolean,\n  log?: (message: string, context?: Record<string, unknown>) => void\n): string {\n  const baseId = slugifyName(name);\n  if (!hasEntity) return baseId;\n  if (!hasEntity(baseId)) return baseId;\n\n  let suffix = 2;\n  let candidate = `${baseId}-${suffix}`;\n  while (hasEntity(candidate)) {\n    suffix += 1;\n    candidate = `${baseId}-${suffix}`;\n  }\n\n  log?.(`Entity id collision for \"${name}\". Using \"${candidate}\".`, {\n    name,\n    baseId,\n    resolvedId: candidate\n  });\n\n  return candidate;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "hasEntity", "type": "(id: string) => boolean", "optional": true}, {"name": "log", "type": "(message: string, context?: Record<string, unknown>) => void", "optional": true}], "returnType": "string"}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::normalizeInitialState", "name": "normalizeInitialState", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "export function normalizeInitialState(entities: RawEntityInput[]): HardState[] {\n  return entities.map((entity, index) => {\n    if (!entity.id) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no id. ` +\n        `Seed entities must include a stable id used by relationships.`\n      );\n    }\n    if (!entity.name) {\n      throw new Error(\n        `normalizeInitialState: entity at index ${index} has no name. ` +\n        `Initial state entities must have names defined in JSON.`\n      );\n    }\n    if (!entity.coordinates) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no coordinates. ` +\n        `Initial state entities must have coordinates defined in JSON.`\n      );\n    }\n    if (!entity.kind) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no kind.`\n      );\n    }\n    if (!entity.subtype) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no subtype.`\n      );\n    }\n    if (!entity.status) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no status.`\n      );\n    }\n    if (!entity.prominence) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no prominence.`\n      );\n    }\n    if (!entity.culture) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no culture.`\n      );\n    }\n\n    // Handle both old array format and new KVP format for tags\n    let tags: EntityTags;\n    if (Array.isArray(entity.tags)) {\n      tags = arrayToTags(entity.tags);\n    } else {\n      tags = entity.tags || {};\n    }\n\n    const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n    return {\n      id: entity.id,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      name: entity.name,\n      summary: entity.summary,\n      narrativeHint,\n      description: entity.description || '',\n      status: entity.status,\n      prominence: entity.prominence,\n      culture: entity.culture,\n      tags,\n      createdAt: 0,\n      updatedAt: 0,\n      coordinates: entity.coordinates\n    };\n  });\n}", "parameters": [{"name": "entities", "type": "RawEntityInput[]", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::addEntity", "name": "addEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "export async function addEntity(graph: Graph, entity: Partial<HardState>, source?: string, placementStrategy?: string): Promise<string> {\n  validateEntityForAdd(entity);\n\n  const coords = entity.coordinates!;\n  const tags: EntityTags = Array.isArray(entity.tags) ? arrayToTags(entity.tags) : { ...(entity.tags || {}) };\n\n  const entityId = generateEntityIdFromName(entity.name!, id => graph.hasEntity(id));\n\n  // Delegate to Graph.createEntity()\n  // Use validated coords to satisfy TypeScript (already validated above)\n  if (typeof coords.z !== 'number') {\n    throw new Error(\n      `addEntity: coordinates must include numeric z. ` +\n      `Entity kind: ${entity.kind}, name: ${entity.name || 'unnamed'}. ` +\n      `Received: ${JSON.stringify(coords)}.`\n    );\n  }\n  const validCoords = { x: coords.x, y: coords.y, z: coords.z };\n\n  const currentEraEntity = entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA\n    ? graph.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0]\n    : undefined;\n  const explicitEraId = entity.eraId;\n  let resolvedEraId: string | undefined;\n  if (typeof explicitEraId === 'string' && explicitEraId) {\n    resolvedEraId = explicitEraId;\n  } else if (entity.kind === FRAMEWORK_ENTITY_KINDS.ERA) {\n    resolvedEraId = entity.subtype;\n  } else {\n    resolvedEraId = currentEraEntity?.id;\n  }\n\n  const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n  const createdId = await graph.createEntity({\n    id: entityId,\n    kind: entity.kind!,\n    subtype: entity.subtype!,\n    coordinates: validCoords,\n    tags,\n    eraId: resolvedEraId,\n    name: entity.name,\n    description: entity.description,\n    narrativeHint,\n    status: entity.status!,\n    prominence: entity.prominence!,\n    culture: entity.culture!,\n    temporal: entity.temporal,\n    source,\n    placementStrategy\n  });\n\n  // Create CREATED_DURING relationship to current era (unless entity is an era itself)\n  // This is a framework-level temporal relationship distinct from spatial \"originated_in\"\n  if (entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA && currentEraEntity) {\n    graph.addRelationship(\n      FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING,\n      entityId,\n      currentEraEntity.id,\n      FRAMEWORK_RELATIONSHIP_PROPERTIES[FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING].defaultStrength\n    );\n  }\n\n  return createdId;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "Partial<HardState>", "optional": false}, {"name": "source", "type": "string", "optional": true}, {"name": "placementStrategy", "type": "string", "optional": true}], "returnType": "Promise<string>"}]