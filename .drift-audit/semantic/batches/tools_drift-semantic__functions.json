[{"id": "tools/drift-semantic/extractor/src/behaviorMarkers.ts::analyzeBehavior", "name": "analyzeBehavior", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/behaviorMarkers.ts", "sourceCode": "/**\n * Walk the AST subtree rooted at `node` and detect behavioral markers.\n */\nexport function analyzeBehavior(node: Node): BehaviorMarkers {\n  const markers: BehaviorMarkers = {\n    isAsync: false,\n    hasErrorHandling: false,\n    hasLoadingState: false,\n    hasEmptyState: false,\n    hasRetryLogic: false,\n    rendersIteration: false,\n    rendersConditional: false,\n    sideEffects: false,\n  };\n\n  // Check if the function itself is async\n  if (Node.isFunctionDeclaration(node) || Node.isMethodDeclaration(node)) {\n    markers.isAsync = node.isAsync();\n  } else if (Node.isVariableDeclaration(node)) {\n    const init = node.getInitializer();\n    if (init && Node.isArrowFunction(init)) {\n      markers.isAsync = init.isAsync();\n    } else if (init && Node.isFunctionExpression(init)) {\n      markers.isAsync = init.isAsync();\n    }\n  }\n\n  // Walk the full subtree once and check patterns\n  node.forEachDescendant(desc => {\n    const kindNum = desc.getKind();\n\n    // hasErrorHandling: try/catch or .catch()\n    if (kindNum === SyntaxKind.TryStatement) {\n      markers.hasErrorHandling = true;\n    }\n    if (Node.isPropertyAccessExpression(desc) && desc.getName() === 'catch') {\n      markers.hasErrorHandling = true;\n    }\n\n    // hasLoadingState: variable/state named loading/isLoading/pending\n    if (Node.isIdentifier(desc)) {\n      const name = desc.getText();\n      if (/^(loading|isLoading|isPending|pending|isSubmitting)$/.test(name)) {\n        markers.hasLoadingState = true;\n      }\n      // hasRetryLogic: retry/attempt/MAX_RETRIES identifiers\n      if (/^(retry|retryCount|attempt|attempts|MAX_RETRIES|maxRetries|retries)$/i.test(name)) {\n        markers.hasRetryLogic = true;\n      }\n    }\n\n    // hasEmptyState: checks for .length === 0 or !data patterns\n    if (Node.isBinaryExpression(desc)) {\n      const text = desc.getText();\n      if (/\\.length\\s*===?\\s*0/.test(text) || /\\.length\\s*!==?\\s*[^0]/.test(text) === false && /\\.length\\s*<\\s*1/.test(text)) {\n        markers.hasEmptyState = true;\n      }\n    }\n    if (Node.isPrefixUnaryExpression(desc) && desc.getOperatorToken() === SyntaxKind.ExclamationToken) {\n      const operand = desc.getOperand();\n      if (Node.isIdentifier(operand)) {\n        const name = operand.getText();\n        if (/^(data|items|results|entries|records|list|rows)$/i.test(name)) {\n          markers.hasEmptyState = true;\n        }\n      }\n    }\n\n    // rendersIteration: .map() in JSX context\n    if (Node.isCallExpression(desc)) {\n      const expr = desc.getExpression();\n      if (Node.isPropertyAccessExpression(expr) && expr.getName() === 'map') {\n        // Check if ancestor is a JSX expression\n        let ancestor: Node | undefined = desc.getParent();\n        while (ancestor) {\n          if (ancestor.getKind() === SyntaxKind.JsxExpression) {\n            markers.rendersIteration = true;\n            break;\n          }\n          if (ancestor.getKind() === SyntaxKind.ReturnStatement) {\n            markers.rendersIteration = true;\n            break;\n          }\n          ancestor = ancestor.getParent();\n        }\n      }\n\n      // sideEffects: useEffect, addEventListener, setTimeout, setInterval\n      const callText = desc.getExpression().getText();\n      if (/^(useEffect|useLayoutEffect)$/.test(callText)) {\n        markers.sideEffects = true;\n      }\n      if (/addEventListener|setTimeout|setInterval|requestAnimationFrame/.test(callText)) {\n        markers.sideEffects = true;\n      }\n    }\n\n    // rendersConditional: && or ternary in JSX return context\n    if (kindNum === SyntaxKind.JsxExpression) {\n      const exprChild = desc.getChildAtIndex(1); // The expression inside { }\n      if (exprChild) {\n        const exprText = exprChild.getText();\n        // Pattern: condition && <Jsx> or condition ? <A> : <B>\n        if (exprChild.getKind() === SyntaxKind.BinaryExpression) {\n          const opToken = exprChild.getChildAtIndex(1);\n          if (opToken && opToken.getKind() === SyntaxKind.AmpersandAmpersandToken) {\n            markers.rendersConditional = true;\n          }\n        }\n        if (exprChild.getKind() === SyntaxKind.ConditionalExpression) {\n          markers.rendersConditional = true;\n        }\n        // Also handle nested ternaries/&& in the text\n        if (!markers.rendersConditional && (/&&/.test(exprText) || /\\?.*:/.test(exprText))) {\n          markers.rendersConditional = true;\n        }\n      }\n    }\n  });\n\n  return markers;\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "BehaviorMarkers"}, {"id": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts::analyzeCallGraph", "name": "analyzeCallGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts", "sourceCode": "/**\n * Analyze outbound call graph for a function/component/hook.\n *\n * Walks the function body, finds all CallExpression nodes, resolves targets,\n * classifies call context, and detects method chain patterns.\n */\nexport function analyzeCallGraph(node: Node, _sourceFile: SourceFile): CallGraphInfo {\n  const callees: CalleeEntry[] = [];\n  const calleesByContext = new Map<string, string[]>();\n  const chainPatterns = new Set<string>();\n  let maxChainDepth = 0;\n  const uniqueTargets = new Set<string>();\n\n  // Get the function body to analyze\n  const body = getFunctionBody(node);\n  if (!body) {\n    return {\n      callees: [],\n      calleeSequence: {},\n      callDepth: 0,\n      uniqueCallees: 0,\n      chainPatterns: [],\n    };\n  }\n\n  // Find all call expressions\n  body.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    // Skip if this call is inside a nested function definition (not our scope)\n    // unless it's inside useEffect/useCallback/useMemo callbacks which ARE our scope\n    if (isInsideNestedFunctionDef(desc, body)) return;\n\n    const target = resolveCallTarget(desc);\n    const context = classifyCallContext(desc, body);\n\n    callees.push({ target, context });\n    uniqueTargets.add(target);\n\n    // Add to context-grouped sequence\n    if (!calleesByContext.has(context)) {\n      calleesByContext.set(context, []);\n    }\n    calleesByContext.get(context)!.push(target);\n\n    // Detect method chain patterns\n    const chainDepth = detectChainPattern(desc, chainPatterns);\n    if (chainDepth > maxChainDepth) maxChainDepth = chainDepth;\n  });\n\n  // Build calleeSequence record\n  const calleeSequence: Record<string, string[]> = {};\n  for (const [ctx, targets] of calleesByContext) {\n    calleeSequence[ctx] = targets;\n  }\n\n  return {\n    callees,\n    calleeSequence,\n    callDepth: maxChainDepth,\n    uniqueCallees: uniqueTargets.size,\n    chainPatterns: [...chainPatterns],\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}, {"name": "_sourceFile", "type": "SourceFile", "optional": false}], "returnType": "CallGraphInfo"}, {"id": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts::buildConsumerGraph", "name": "buildConsumerGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts", "sourceCode": "/**\n * Build the consumer graph across all extracted units (second pass).\n *\n * For each unit, looks at its imports. For each internal import that resolves\n * to a file with known exported units, adds this unit as a consumer of those\n * target units. Then computes consumer counts, kinds, directories, and\n * co-occurrence data.\n *\n * Mutates units in place.\n */\nexport function buildConsumerGraph(units: CodeUnit[]): void {\n  // Build lookup maps\n  const unitById = new Map<string, CodeUnit>();\n  const unitsByFile = new Map<string, string[]>(); // filePath \u2192 list of unit IDs\n\n  for (const unit of units) {\n    unitById.set(unit.id, unit);\n\n    if (!unitsByFile.has(unit.filePath)) {\n      unitsByFile.set(unit.filePath, []);\n    }\n    unitsByFile.get(unit.filePath)!.push(unit.id);\n  }\n\n  // First pass: build consumer lists\n  // For each unit, look at its internal imports and link to target units\n  for (const unit of units) {\n    for (const imp of unit.imports) {\n      if (imp.category !== 'internal') continue;\n\n      // Resolve the import source relative to the unit's file\n      const resolvedTargets = resolveImportToFile(unit.filePath, imp.source, unitsByFile);\n\n      for (const targetUnitId of resolvedTargets) {\n        const targetUnit = unitById.get(targetUnitId);\n        if (!targetUnit) continue;\n        if (targetUnit.id === unit.id) continue; // Don't self-reference\n\n        // Check if any of the imported specifiers match the target unit name\n        const targetName = targetUnit.name;\n        const specifierMatch = imp.specifiers.length === 0 || // default import or namespace\n          imp.specifiers.some(spec => {\n            // Handle \"Name as Alias\" patterns\n            const baseName = spec.includes(' as ') ? spec.split(' as ')[0].trim() : spec;\n            return baseName === targetName || baseName === 'default' || spec.startsWith('* as');\n          });\n\n        if (specifierMatch) {\n          if (!targetUnit.consumers.includes(unit.id)) {\n            targetUnit.consumers.push(unit.id);\n          }\n        }\n      }\n    }\n  }\n\n  // Second pass: compute consumer metadata\n  for (const unit of units) {\n    unit.consumerCount = unit.consumers.length;\n\n    // Consumer kinds: set of kinds that consume this unit\n    const kindSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) kindSet.add(consumer.kind);\n    }\n    unit.consumerKinds = [...kindSet].sort();\n\n    // Consumer directories: set of directory prefixes\n    const dirSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) {\n        // Use the first two path segments as directory prefix\n        const parts = consumer.filePath.split('/');\n        if (parts.length >= 2) {\n          dirSet.add(parts.slice(0, 2).join('/'));\n        } else {\n          dirSet.add(parts[0]);\n        }\n      }\n    }\n    unit.consumerDirectories = [...dirSet].sort();\n  }\n\n  // Third pass: build co-occurrence data\n  buildCoOccurrences(units, unitById, unitsByFile);\n}", "parameters": [{"name": "units", "type": "CodeUnit[]", "optional": false}], "returnType": "void"}, {"id": "tools/drift-semantic/extractor/src/hookAnalyzer.ts::analyzeHooks", "name": "analyzeHooks", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/hookAnalyzer.ts", "sourceCode": "/**\n * Analyze hook usage within a function/component body.\n *\n * Finds all call expressions where the callee name starts with `use` (React convention).\n * Counts occurrences, categorizes built-in vs custom, and counts state variables.\n */\nexport function analyzeHooks(node: Node): HookInfo {\n  const hookCounts = new Map<string, number>();\n  const customHookSet = new Set<string>();\n  let stateVariableCount = 0;\n\n  node.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    const expr = desc.getExpression();\n    let hookName: string | null = null;\n\n    // Direct call: useFoo()\n    if (Node.isIdentifier(expr)) {\n      const name = expr.getText();\n      if (name.startsWith('use') && name.length > 3 && name[3] === name[3].toUpperCase()) {\n        hookName = name;\n      }\n    }\n\n    // Namespaced call: React.useState()\n    if (Node.isPropertyAccessExpression(expr)) {\n      const propName = expr.getName();\n      if (propName.startsWith('use') && propName.length > 3 && propName[3] === propName[3].toUpperCase()) {\n        hookName = propName;\n      }\n    }\n\n    if (!hookName) return;\n\n    // Count occurrences\n    hookCounts.set(hookName, (hookCounts.get(hookName) ?? 0) + 1);\n\n    // Classify as custom if not a React built-in\n    if (!REACT_BUILT_IN_HOOKS.has(hookName)) {\n      customHookSet.add(hookName);\n    }\n\n    // Count state variables from useState destructuring:\n    // const [value, setValue] = useState(...)\n    if (hookName === 'useState') {\n      const parent = desc.getParent();\n      if (parent && Node.isVariableDeclaration(parent)) {\n        const nameNode = parent.getNameNode();\n        if (Node.isArrayBindingPattern(nameNode)) {\n          // Each element with a \"set\" prefix is a setter\n          const elements = nameNode.getElements();\n          // Count the number of state values (the non-setter elements, typically first)\n          // Standard pattern: [value, setValue] = one state variable\n          stateVariableCount += 1;\n        }\n      }\n    }\n  });\n\n  // Build ordered hookCalls list (ordered by first appearance - Map preserves insertion order)\n  const hookCalls: HookCallEntry[] = [];\n  for (const [name, count] of hookCounts) {\n    hookCalls.push({ name, count });\n  }\n\n  return {\n    hookCalls,\n    customHookCalls: [...customHookSet].sort(),\n    stateVariableCount,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "HookInfo"}, {"id": "tools/drift-semantic/extractor/src/importAnalyzer.ts::analyzeImports", "name": "analyzeImports", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/importAnalyzer.ts", "sourceCode": "/**\n * Analyze all imports in a source file.\n * Also detects store access patterns and data source access.\n */\nexport function analyzeImports(sourceFile: SourceFile, _projectRoot: string): ImportInfo {\n  const imports: ImportEntry[] = [];\n  const storeAccess: string[] = [];\n  const dataSourceAccess: string[] = [];\n\n  // Process import declarations\n  for (const decl of sourceFile.getImportDeclarations()) {\n    const source = decl.getModuleSpecifierValue();\n    const specifiers: string[] = [];\n\n    // Default import\n    const defaultImport = decl.getDefaultImport();\n    if (defaultImport) {\n      specifiers.push(defaultImport.getText());\n    }\n\n    // Named imports\n    for (const named of decl.getNamedImports()) {\n      const alias = named.getAliasNode();\n      specifiers.push(alias ? `${named.getName()} as ${alias.getText()}` : named.getName());\n    }\n\n    // Namespace import\n    const nsImport = decl.getNamespaceImport();\n    if (nsImport) {\n      specifiers.push(`* as ${nsImport.getText()}`);\n    }\n\n    imports.push({\n      source,\n      specifiers,\n      category: categorizeImport(source),\n    });\n  }\n\n  // Detect store access patterns in the full file text\n  const fullText = sourceFile.getFullText();\n\n  // useXxxStore() calls\n  const storeCallPattern = /\\buse(\\w+Store)\\s*\\(/g;\n  let match: RegExpExecArray | null;\n  const seenStores = new Set<string>();\n  while ((match = storeCallPattern.exec(fullText)) !== null) {\n    const storeName = `use${match[1]}`;\n    if (!seenStores.has(storeName)) {\n      seenStores.add(storeName);\n      storeAccess.push(storeName);\n    }\n  }\n\n  // store.getState() / store.setState() patterns\n  const storeGetSetPattern = /\\b(\\w+Store)\\.(getState|setState|subscribe)\\s*\\(/g;\n  while ((match = storeGetSetPattern.exec(fullText)) !== null) {\n    const access = `${match[1]}.${match[2]}`;\n    if (!seenStores.has(access)) {\n      seenStores.add(access);\n      storeAccess.push(access);\n    }\n  }\n\n  // Data source access patterns\n  const seenDataSources = new Set<string>();\n\n  // Dexie: db.tableName patterns\n  const dbTablePattern = /\\bdb\\.(\\w+)\\b/g;\n  while ((match = dbTablePattern.exec(fullText)) !== null) {\n    const access = `db.${match[1]}`;\n    if (!seenDataSources.has(access)) {\n      seenDataSources.add(access);\n      dataSourceAccess.push(access);\n    }\n  }\n\n  // useLiveQuery calls\n  if (/\\buseLiveQuery\\s*\\(/.test(fullText)) {\n    if (!seenDataSources.has('useLiveQuery')) {\n      seenDataSources.add('useLiveQuery');\n      dataSourceAccess.push('useLiveQuery');\n    }\n  }\n\n  // fetch() calls\n  sourceFile.forEachDescendant(node => {\n    if (Node.isCallExpression(node)) {\n      const expr = node.getExpression();\n      if (Node.isIdentifier(expr) && expr.getText() === 'fetch') {\n        if (!seenDataSources.has('fetch')) {\n          seenDataSources.add('fetch');\n          dataSourceAccess.push('fetch');\n        }\n      }\n    }\n  });\n\n  return { imports, storeAccess, dataSourceAccess };\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "_projectRoot", "type": "string", "optional": false}], "returnType": "ImportInfo"}, {"id": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts::analyzeJsx", "name": "analyzeJsx", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts", "sourceCode": "/**\n * Analyze JSX structure in a component function.\n *\n * Returns null for non-component functions (no JSX return).\n * Builds a nested tree of JSX elements with map/conditional markers.\n * Strips attributes/props -- we only care about structural nesting.\n */\nexport function analyzeJsx(node: Node): JsxInfo | null {\n  // Find return statements that contain JSX\n  const returnStatements = node.getDescendantsOfKind(SyntaxKind.ReturnStatement);\n\n  let jsxRoot: Node | null = null;\n\n  for (const ret of returnStatements) {\n    const expr = ret.getExpression();\n    if (!expr) continue;\n\n    // Check if the return expression is JSX or a parenthesized JSX\n    if (isJsxNode(expr)) {\n      jsxRoot = expr;\n      break;\n    }\n\n    // Check inside parenthesized expression\n    if (Node.isParenthesizedExpression(expr)) {\n      const inner = expr.getExpression();\n      if (isJsxNode(inner)) {\n        jsxRoot = inner;\n        break;\n      }\n    }\n  }\n\n  // Also handle arrow functions with expression bodies (no explicit return):\n  // const Foo = () => <div>...</div>\n  if (!jsxRoot) {\n    if (Node.isArrowFunction(node)) {\n      const body = node.getBody();\n      if (body && isJsxNode(body)) {\n        jsxRoot = body;\n      } else if (body && Node.isParenthesizedExpression(body)) {\n        const inner = body.getExpression();\n        if (isJsxNode(inner)) {\n          jsxRoot = inner;\n        }\n      }\n    }\n    // For VariableDeclaration wrapping an arrow function\n    if (!jsxRoot && Node.isVariableDeclaration(node)) {\n      const init = node.getInitializer();\n      if (init && Node.isArrowFunction(init)) {\n        const body = init.getBody();\n        if (body && isJsxNode(body)) {\n          jsxRoot = body;\n        } else if (body && Node.isParenthesizedExpression(body)) {\n          const inner = body.getExpression();\n          if (isJsxNode(inner)) {\n            jsxRoot = inner;\n          }\n        }\n      }\n    }\n  }\n\n  if (!jsxRoot) return null;\n\n  const tree = buildJsxTree(jsxRoot, false, false);\n  if (!tree) return null;\n\n  const leafElements: string[] = [];\n  const depth = computeDepthAndLeaves(tree, leafElements);\n\n  return {\n    jsxTree: tree,\n    jsxLeafElements: [...new Set(leafElements)],\n    jsxDepth: depth,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "JsxInfo | null"}, {"id": "tools/drift-semantic/extractor/src/projectLoader.ts::loadProjects", "name": "loadProjects", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/projectLoader.ts", "sourceCode": "/**\n * Load all TypeScript/JavaScript projects from the monorepo.\n *\n * - Creates a ts-morph Project for each tsconfig.json / tsconfig.app.json\n * - For webui directories not covered by any tsconfig, creates an ad-hoc Project\n *   with allowJs + JSX support\n * - Returns projects and a set of seen absolute file paths for deduplication\n */\nexport function loadProjects(projectRoot: string): LoadedProjects {\n  const tsconfigPaths = findTsconfigFiles(projectRoot);\n  const seenFiles = new Set<string>();\n  const projects: Project[] = [];\n\n  // Prefer tsconfig.app.json over tsconfig.json when both exist in same dir\n  const byDir = new Map<string, string[]>();\n  for (const tc of tsconfigPaths) {\n    const dir = path.dirname(tc);\n    if (!byDir.has(dir)) byDir.set(dir, []);\n    byDir.get(dir)!.push(tc);\n  }\n\n  const selectedTsconfigs: string[] = [];\n  for (const [, configs] of byDir) {\n    const appConfig = configs.find(c => path.basename(c) === 'tsconfig.app.json');\n    // If tsconfig.app.json exists, prefer it (it's the actual source config);\n    // otherwise use tsconfig.json\n    selectedTsconfigs.push(appConfig ?? configs[0]);\n  }\n\n  for (const tsconfigPath of selectedTsconfigs) {\n    try {\n      const project = new Project({ tsConfigFilePath: tsconfigPath });\n      const sourceFiles = project.getSourceFiles();\n\n      // Track which files this project covers\n      for (const sf of sourceFiles) {\n        seenFiles.add(sf.getFilePath());\n      }\n\n      projects.push(project);\n      process.stderr.write(`  tsconfig: ${path.relative(projectRoot, tsconfigPath)} \u2192 ${sourceFiles.length} files\\n`);\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to load ${path.relative(projectRoot, tsconfigPath)}: ${err}\\n`);\n    }\n  }\n\n  // Find and create ad-hoc projects for uncovered webui directories\n  const uncoveredWebuis = findUncoveredWebuis(projectRoot, selectedTsconfigs);\n\n  for (const webuiDir of uncoveredWebuis) {\n    try {\n      const project = new Project({\n        compilerOptions: {\n          target: ts.ScriptTarget.ES2022,\n          module: ts.ModuleKind.ESNext,\n          moduleResolution: ts.ModuleResolutionKind.Bundler,\n          allowJs: true,\n          jsx: ts.JsxEmit.ReactJSX,\n          strict: false,\n          noEmit: true,\n          esModuleInterop: true,\n          skipLibCheck: true,\n        },\n      });\n\n      // Add all .js/.jsx/.ts/.tsx files from the webui/src directory\n      const srcDir = path.join(webuiDir, 'src');\n      if (fs.existsSync(srcDir)) {\n        addSourceFilesRecursively(project, srcDir, seenFiles);\n      }\n\n      const sourceFiles = project.getSourceFiles();\n      if (sourceFiles.length > 0) {\n        projects.push(project);\n        process.stderr.write(`  ad-hoc:   ${path.relative(projectRoot, webuiDir)}/src \u2192 ${sourceFiles.length} files\\n`);\n      }\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to create ad-hoc project for ${path.relative(projectRoot, webuiDir)}: ${err}\\n`);\n    }\n  }\n\n  return { projects, seenFiles };\n}", "parameters": [{"name": "projectRoot", "type": "string", "optional": false}], "returnType": "LoadedProjects"}, {"id": "tools/drift-semantic/extractor/src/unitExtractor.ts::extractUnits", "name": "extractUnits", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/unitExtractor.ts", "sourceCode": "/**\n * Extract all exported code units from a source file.\n *\n * Iterates over all exported declarations, determines their kind,\n * runs all analyzers, and returns an array of CodeUnit records.\n */\nexport function extractUnits(sourceFile: SourceFile, projectRoot: string): CodeUnit[] {\n  const units: CodeUnit[] = [];\n  const relativePath = path.relative(projectRoot, sourceFile.getFilePath());\n\n  // Import analysis is per-file (shared across all units in the file)\n  const importInfo = analyzeImports(sourceFile, projectRoot);\n\n  let exportedDeclarations: ReadonlyMap<string, Node[]>;\n  try {\n    exportedDeclarations = sourceFile.getExportedDeclarations();\n  } catch {\n    process.stderr.write(`  WARN: failed to get exports from ${relativePath}\\n`);\n    return units;\n  }\n\n  if (exportedDeclarations.size === 0) return units;\n\n  for (const [exportName, declarations] of exportedDeclarations) {\n    for (const decl of declarations) {\n      try {\n        const unit = extractSingleUnit(decl, exportName, relativePath, sourceFile, projectRoot, importInfo);\n        if (unit) units.push(unit);\n      } catch (err) {\n        process.stderr.write(`  WARN: failed to extract ${exportName} from ${relativePath}: ${err}\\n`);\n      }\n    }\n  }\n\n  return units;\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "projectRoot", "type": "string", "optional": false}], "returnType": "CodeUnit[]"}]