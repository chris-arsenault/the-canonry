[{"id": "apps/coherence-engine/webui/src/components/generators/tabs/index.js::RelationshipsTab", "name": "RelationshipsTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function RelationshipsTab({ generator, onChange, schema }) {\n  const relationships = generator.relationships || [];\n  const saturationLimits = generator.selection?.saturationLimits || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  // Find the first created entity ref for implied relationships\n  const firstCreatedRef = useMemo(() => {\n    const creation = generator.creation || [];\n    return creation.length > 0 ? creation[0].entityRef : \"$created\";\n  }, [generator.creation]);\n\n  const handleAdd = () => {\n    onChange({\n      ...generator,\n      relationships: [\n        ...relationships,\n        {\n          kind: schema?.relationshipKinds?.[0]?.kind || \"ally_of\",\n          src: availableRefs[1] || \"$entity1\",\n          dst: \"$target\",\n          strength: 0.8,\n        },\n      ],\n    });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Relationships</div>\n        <div className=\"section-desc\">\n          Define relationships created between entities. Use entity references like{\" \"}\n          <code className=\"inline-code\">$target</code>, created entities like{\" \"}\n          <code className=\"inline-code\">$hero</code>, or variables like{\" \"}\n          <code className=\"inline-code\">$faction</code>.\n        </div>\n\n        {/* Implied relationships from saturation limits */}\n        {saturationLimits.length > 0 && (\n          <div className=\"mb-xl\">\n            {saturationLimits.map((limit, index) => (\n              <ImpliedRelationshipCard\n                key={`implied-${index}`}\n                saturationLimit={limit}\n                schema={schema}\n                createdEntityRef={firstCreatedRef}\n              />\n            ))}\n          </div>\n        )}\n\n        {relationships.length === 0 && saturationLimits.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udd17</div>\n            <div className=\"empty-state-title\">No relationships</div>\n            <div className=\"empty-state-desc\">\n              This generator doesn&apos;t create any relationships. Add relationships to connect\n              entities.\n            </div>\n          </div>\n        ) : (\n          relationships.map((rel, index) => (\n            <RelationshipCard\n              key={index}\n              rel={rel}\n              onChange={(updated) => {\n                const newRels = [...relationships];\n                newRels[index] = updated;\n                onChange({ ...generator, relationships: newRels });\n              }}\n              onRemove={() =>\n                onChange({\n                  ...generator,\n                  relationships: relationships.filter((_, i) => i !== index),\n                })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Relationship\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "code", "ImpliedRelationshipCard", "button"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/index.js::EffectsTab", "name": "EffectsTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Object} props.schema - Domain schema\n */\nexport function EffectsTab({ generator, onChange, pressures, schema }) {\n  const stateUpdates = generator.stateUpdates || [];\n  const [showTypeMenu, setShowTypeMenu] = useState(false);\n  const [dropdownPos, setDropdownPos] = useState({ top: 0, left: 0, width: 0 });\n  const addButtonRef = useRef(null);\n\n  // Build available entity references from target + variables + created entities\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  const createMutation = (type) => {\n    let newUpdate;\n    switch (type) {\n      case \"modify_pressure\":\n        newUpdate = { type: \"modify_pressure\", pressureId: pressures?.[0]?.id || \"\", delta: 0 };\n        break;\n      case \"archive_relationship\":\n        newUpdate = {\n          type: \"archive_relationship\",\n          entity: \"$target\",\n          relationshipKind: \"\",\n          direction: \"both\",\n        };\n        break;\n      case \"change_status\":\n        newUpdate = { type: \"change_status\", entity: \"$target\", newStatus: \"\" };\n        break;\n      case \"set_tag\":\n        newUpdate = { type: \"set_tag\", entity: \"$target\", tag: \"\", value: true };\n        break;\n      case \"remove_tag\":\n        newUpdate = { type: \"remove_tag\", entity: \"$target\", tag: \"\" };\n        break;\n      case \"update_rate_limit\":\n        newUpdate = { type: \"update_rate_limit\" };\n        break;\n      default:\n        return null;\n    }\n    return newUpdate;\n  };\n\n  const addMutation = (type) => {\n    const next = createMutation(type);\n    if (!next) return;\n    onChange({ ...generator, stateUpdates: [...stateUpdates, next] });\n  };\n\n  const updateMutation = (index, updated) => {\n    const newUpdates = [...stateUpdates];\n    newUpdates[index] = updated;\n    onChange({ ...generator, stateUpdates: newUpdates });\n  };\n\n  const removeMutation = (index) => {\n    onChange({ ...generator, stateUpdates: stateUpdates.filter((_, i) => i !== index) });\n  };\n\n  const knownTypes = new Set(DEFAULT_MUTATION_TYPES.map((type) => type.value));\n  const unrecognizedUpdates = stateUpdates\n    .map((update, index) => (knownTypes.has(update.type) ? null : { update, index }))\n    .filter(Boolean);\n\n  useLayoutEffect(() => {\n    if (showTypeMenu && addButtonRef.current) {\n      const rect = addButtonRef.current.getBoundingClientRect();\n      setDropdownPos({\n        top: rect.bottom + 4,\n        left: rect.left,\n        width: Math.max(rect.width, 220),\n      });\n    }\n  }, [showTypeMenu]);\n\n  useEffect(() => {\n    if (!showTypeMenu) return;\n    const handleClickOutside = (event) => {\n      if (addButtonRef.current && !addButtonRef.current.contains(event.target)) {\n        setShowTypeMenu(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showTypeMenu]);\n\n  return (\n    <div>\n      {/* Unrecognized Effects - shown first to draw attention */}\n      {unrecognizedUpdates.length > 0 && (\n        <div className=\"section et-unrecognized-section\">\n          <div className=\"section-title et-unrecognized-title\">\n            <span>\u26a0\ufe0f</span> Unrecognized Effects\n          </div>\n          <div className=\"section-desc mb-lg\">\n            These state updates have unrecognized types and may be from an older version. Remove\n            them to clear validation errors.\n          </div>\n\n          {unrecognizedUpdates.map((entry) => {\n            const globalIdx = entry.index;\n            const update = entry.update;\n            return (\n              <div\n                key={globalIdx}\n                className=\"item-card et-unrecognized-card\"\n              >\n                <div className=\"et-unrecognized-body\">\n                  <div className=\"et-unrecognized-layout\">\n                    <div className=\"flex-1\">\n                      <div className=\"et-unrecognized-type\">\n                        Unknown type: &quot;{update.type || \"(no type)\"}&quot;\n                      </div>\n                      <pre className=\"et-unrecognized-json\">\n                        {JSON.stringify(update, null, 2)}\n                      </pre>\n                    </div>\n                    <button\n                      className=\"btn btn-danger flex-shrink-0\"\n                      onClick={() => removeMutation(globalIdx)}\n                    >\n                      Remove\n                    </button>\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      <div className=\"section\">\n        <div className=\"section-title\">\u26a1 Effects ({stateUpdates.length})</div>\n        <div className=\"section-desc\">\n          Apply state updates when this generator runs. Effects use the unified mutation library.\n        </div>\n\n        {stateUpdates.map((update, index) => {\n          if (!knownTypes.has(update.type)) return null;\n          return (\n            <MutationCard\n              key={index}\n              mutation={update}\n              onChange={(updated) => updateMutation(index, updated)}\n              onRemove={() => removeMutation(index)}\n              schema={schema}\n              pressures={pressures}\n              entityOptions={availableRefs}\n              typeOptions={DEFAULT_MUTATION_TYPES}\n              createMutation={createMutation}\n            />\n          );\n        })}\n\n        <div ref={addButtonRef} className=\"relative mt-lg\">\n          <button onClick={() => setShowTypeMenu(!showTypeMenu)} className=\"btn-add-inline\">\n            + Add Effect\n          </button>\n\n          {showTypeMenu && (\n            <div\n              className=\"dropdown-menu et-dropdown-fixed\"\n              // eslint-disable-next-line local/no-inline-styles -- dynamic position from measured DOM rect\n              style={{ '--et-dd-top': `${dropdownPos.top}px`, '--et-dd-left': `${dropdownPos.left}px`, '--et-dd-width': `${dropdownPos.width}px`, top: 'var(--et-dd-top)', left: 'var(--et-dd-left)', width: 'var(--et-dd-width)' }}\n            >\n              {MUTATION_TYPE_OPTIONS.map((opt) => (\n                <div\n                  key={opt.value}\n                  onClick={() => {\n                    addMutation(opt.value);\n                    setShowTypeMenu(false);\n                  }}\n                  className=\"dropdown-menu-item\"\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <span\n                    className=\"dropdown-menu-icon\"\n                    // eslint-disable-next-line local/no-inline-styles -- dynamic color per mutation type\n                    style={{ '--et-icon-bg': `${opt.color}20`, backgroundColor: 'var(--et-icon-bg)' }}\n                  >\n                    {opt.icon}\n                  </span>\n                  <span className=\"dropdown-menu-label\">{opt.label}</span>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, pressures, schema }", "type": "{ generator: any; onChange: Function; pressures: any[]; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div", "pre", "button", "MutationCard"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useMemo", "count": 1}, {"name": "useLayoutEffect", "count": 1}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/index.js::ApplicabilityTab", "name": "ApplicabilityTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n * @param {Array} props.eras - Available era definitions\n */\nexport function ApplicabilityTab({ generator, onChange, schema, pressures, eras }) {\n  const rules = generator.applicability || [];\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Applicability Rules</div>\n        <div className=\"section-desc\">\n          Define when this generator is eligible to run. If no rules are defined, the generator will\n          always be eligible. Multiple top-level rules are combined with AND logic.\n        </div>\n\n        {rules.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\u2713</div>\n            <div className=\"empty-state-title\">No applicability rules</div>\n            <div className=\"empty-state-desc\">\n              This generator will always be eligible to run. Add rules to control when it activates.\n            </div>\n          </div>\n        ) : (\n          rules.map((rule, index) => (\n            <ApplicabilityRuleCard\n              key={index}\n              rule={rule}\n              onChange={(updated) => {\n                const newRules = [...rules];\n                newRules[index] = updated;\n                onChange({ ...generator, applicability: newRules });\n              }}\n              onRemove={() =>\n                onChange({ ...generator, applicability: rules.filter((_, i) => i !== index) })\n              }\n              schema={schema}\n              pressures={pressures}\n              eras={eras}\n            />\n          ))\n        )}\n\n        <AddRuleButton\n          onAdd={(type) => {\n            const newRule = createNewRule(type, pressures);\n            onChange({ ...generator, applicability: [...rules, newRule] });\n          }}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema, pressures, eras }", "type": "{ generator: any; onChange: Function; schema: any; pressures: any[]; eras: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "AddRuleButton"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx::OverviewTab", "name": "OverviewTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/OverviewTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Function} props.onDelete - Callback to delete the generator\n * @param {Function} props.onDuplicate - Callback to duplicate the generator\n */\nexport function OverviewTab({ generator, onChange, onDelete, onDuplicate }) {\n  const updateField = (field, value) => {\n    onChange({ ...generator, [field]: value });\n  };\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(generator.id, (value) =>\n    updateField(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(generator.name, (value) =>\n    updateField(\"name\", value)\n  );\n\n  const summary = useMemo(() => {\n    return {\n      rules: generator.applicability?.length || 0,\n      variables: Object.keys(generator.variables || {}).length,\n      creates: generator.creation?.length || 0,\n      relationships: generator.relationships?.length || 0,\n      effects: generator.stateUpdates?.length || 0,\n    };\n  }, [generator]);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Basic Information</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label htmlFor=\"generator-id\" className=\"label\">Generator ID</label>\n            <input id=\"generator-id\"\n              type=\"text\"\n              value={localId}\n              onChange={(e) => setLocalId(e.target.value)}\n              onBlur={handleIdBlur}\n              className=\"input\"\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"display-name\" className=\"label\">Display Name</label>\n            <input id=\"display-name\"\n              type=\"text\"\n              value={localName}\n              onChange={(e) => setLocalName(e.target.value)}\n              onBlur={handleNameBlur}\n              className=\"input\"\n              placeholder=\"Optional friendly name\"\n            />\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Enabled\n          <EnableToggle\n            enabled={generator.enabled !== false}\n            onChange={(enabled) => updateField(\"enabled\", enabled)}\n            label={generator.enabled !== false ? \"Generator is active\" : \"Generator is disabled\"}\n          />\n          </label>\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">Narration Template</span>\n          <div className=\"section-desc mb-md\">\n            Syntax: {\"{$target.field}\"}, {\"{$var.field}\"}, {\"{count:kind}\"}, {\"{list:created}\"},{\" \"}\n            {\"{field|fallback}\"}.\n          </div>\n          <LocalTextArea\n            value={generator.narrationTemplate || \"\"}\n            onChange={(value) => updateField(\"narrationTemplate\", value || undefined)}\n            placeholder=\"e.g., From {$target.name}, {count:npc} new souls emerged to shape the realm.\"\n            rows={2}\n          />\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Summary</div>\n        <div className=\"summary-stats-grid\">\n          {[\n            { label: \"Rules\", value: summary.rules, icon: \"\u2713\" },\n            { label: \"Variables\", value: summary.variables, icon: \"\ud83d\udce6\" },\n            { label: \"Creates\", value: summary.creates, icon: \"\u2728\" },\n            { label: \"Connects\", value: summary.relationships, icon: \"\ud83d\udd17\" },\n            { label: \"Effects\", value: summary.effects, icon: \"\u26a1\" },\n          ].map((stat) => (\n            <div key={stat.label} className=\"summary-stat\">\n              <div className=\"summary-stat-icon\">{stat.icon}</div>\n              <div className=\"summary-stat-value\">{stat.value}</div>\n              <div className=\"summary-stat-label\">{stat.label}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"danger-zone\">\n        <button className=\"btn btn-secondary\" onClick={onDuplicate}>\n          Duplicate Generator\n        </button>\n        <button className=\"btn btn-danger\" onClick={onDelete}>\n          Delete Generator\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, onDelete, onDuplicate }", "type": "{ generator: any; onChange: Function; onDelete: Function; onDuplicate: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "label", "input", "EnableToggle", "span", "LocalTextArea", "button"], "hookCalls": [{"name": "useLocalInputState", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": ["useLocalInputState"], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["EnableToggle", "useLocalInputState", "LocalTextArea"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx::RelationshipsTab", "name": "RelationshipsTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/RelationshipsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function RelationshipsTab({ generator, onChange, schema }) {\n  const relationships = generator.relationships || [];\n  const saturationLimits = generator.selection?.saturationLimits || [];\n\n  const availableRefs = useMemo(() => {\n    const refs = [\"$target\"];\n    Object.keys(generator.variables || {}).forEach((v) => refs.push(v));\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef) refs.push(c.entityRef);\n    });\n    return refs;\n  }, [generator.variables, generator.creation]);\n\n  // Find the first created entity ref for implied relationships\n  const firstCreatedRef = useMemo(() => {\n    const creation = generator.creation || [];\n    return creation.length > 0 ? creation[0].entityRef : \"$created\";\n  }, [generator.creation]);\n\n  const handleAdd = () => {\n    onChange({\n      ...generator,\n      relationships: [\n        ...relationships,\n        {\n          kind: schema?.relationshipKinds?.[0]?.kind || \"ally_of\",\n          src: availableRefs[1] || \"$entity1\",\n          dst: \"$target\",\n          strength: 0.8,\n        },\n      ],\n    });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Relationships</div>\n        <div className=\"section-desc\">\n          Define relationships created between entities. Use entity references like{\" \"}\n          <code className=\"inline-code\">$target</code>, created entities like{\" \"}\n          <code className=\"inline-code\">$hero</code>, or variables like{\" \"}\n          <code className=\"inline-code\">$faction</code>.\n        </div>\n\n        {/* Implied relationships from saturation limits */}\n        {saturationLimits.length > 0 && (\n          <div className=\"mb-xl\">\n            {saturationLimits.map((limit, index) => (\n              <ImpliedRelationshipCard\n                key={`implied-${index}`}\n                saturationLimit={limit}\n                schema={schema}\n                createdEntityRef={firstCreatedRef}\n              />\n            ))}\n          </div>\n        )}\n\n        {relationships.length === 0 && saturationLimits.length === 0 ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udd17</div>\n            <div className=\"empty-state-title\">No relationships</div>\n            <div className=\"empty-state-desc\">\n              This generator doesn&apos;t create any relationships. Add relationships to connect\n              entities.\n            </div>\n          </div>\n        ) : (\n          relationships.map((rel, index) => (\n            <RelationshipCard\n              key={index}\n              rel={rel}\n              onChange={(updated) => {\n                const newRels = [...relationships];\n                newRels[index] = updated;\n                onChange({ ...generator, relationships: newRels });\n              }}\n              onRemove={() =>\n                onChange({\n                  ...generator,\n                  relationships: relationships.filter((_, i) => i !== index),\n                })\n              }\n              schema={schema}\n              availableRefs={availableRefs}\n            />\n          ))\n        )}\n\n        <button className=\"btn-add\" onClick={handleAdd}>\n          + Add Relationship\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "code", "ImpliedRelationshipCard", "button"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "./RelationshipsTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx::TargetTab", "name": "TargetTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/TargetTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema with entity/relationship kinds\n */\nexport function TargetTab({ generator, onChange, schema }) {\n  const selection = generator.selection || { strategy: \"by_kind\" };\n\n  // Get the kind of the first created entity for saturation limit inference\n  const firstCreatedKind = (generator.creation || [])[0]?.kind;\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Target Selection</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What is $target?</div>\n          <div className=\"info-box-text\">\n            The <code className=\"inline-code\">$target</code> is the primary entity this generator\n            operates on. It&apos;s selected from the world graph based on the rules you define here. Once\n            selected, you can reference it in creation rules (e.g., inherit culture from $target)\n            and relationships (e.g., connect new entity to $target).\n          </div>\n        </div>\n\n        <SelectionRuleEditor\n          value={selection}\n          onChange={(updated) => onChange({ ...generator, selection: updated })}\n          schema={schema}\n          availableRefs={[\"$target\", ...Object.keys(generator.variables || {})]}\n        />\n\n        {/* Saturation Limits */}\n        <div className=\"mt-2xl\">\n          <span className=\"label\">Saturation Limits</span>\n          <div className=\"info-box-text mb-lg text-sm\">\n            Limit targets based on existing relationship counts. Only targets with fewer than the\n            max count of relationships will be selected.\n          </div>\n          <SaturationLimitsEditor\n            limits={selection.saturationLimits || []}\n            onChange={(limits) =>\n              onChange({\n                ...generator,\n                selection: {\n                  ...selection,\n                  saturationLimits: limits.length > 0 ? limits : undefined,\n                },\n              })\n            }\n            schema={schema}\n            createdKind={firstCreatedKind}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "code", "SelectionRuleEditor", "span", "SaturationLimitsEditor"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "../../shared/SelectionRuleEditor", "specifiers": ["SelectionRuleEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx::VariablesTab", "name": "VariablesTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/generators/tabs/VariablesTab.jsx", "sourceCode": "// ============================================================================\n// VariablesTab - Main tab component\n// ============================================================================\n\n/**\n * @param {Object} props\n * @param {Object} props.generator - The generator being edited\n * @param {Function} props.onChange - Callback when generator changes\n * @param {Object} props.schema - Domain schema\n */\nexport function VariablesTab({ generator, onChange, schema }) {\n  const variables = generator.variables || {};\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddForm, setShowAddForm] = useState(false);\n\n  // Build available refs for relationship queries (target + other vars + creation refs)\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$target\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    (generator.creation || []).forEach((c) => {\n      if (c.entityRef && !refs.includes(c.entityRef)) refs.push(c.entityRef);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    // Ensure the name starts with $\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    // Create with empty required fields - validation will flag them\n    onChange({\n      ...generator,\n      variables: {\n        ...variables,\n        [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"\" } },\n      },\n    });\n    setNewVarName(\"\");\n    setShowAddForm(false);\n  };\n\n  const varEntries = Object.entries(variables);\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Variables</div>\n\n        <div className=\"info-box\">\n          <div className=\"info-box-title\">What are variables?</div>\n          <div className=\"info-box-text\">\n            Variables let you select additional entities from the graph to use in creation and\n            relationships. For example, you might select a{\" \"}\n            <code className=\"inline-code\">$faction</code> to make a new NPC a member of, or an{\" \"}\n            <code className=\"inline-code\">$ability</code> for them to practice. Variables are\n            selected after <code className=\"inline-code\">$target</code> is chosen.\n          </div>\n        </div>\n\n        {varEntries.length === 0 && !showAddForm ? (\n          <div className=\"empty-state\">\n            <div className=\"empty-state-icon\">\ud83d\udce6</div>\n            <div className=\"empty-state-title\">No variables defined</div>\n            <div className=\"empty-state-desc\">\n              Add variables to select additional entities for use in creation and relationships.\n            </div>\n          </div>\n        ) : (\n          varEntries.map(([name, config]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={config}\n              onChange={(updated) =>\n                onChange({ ...generator, variables: { ...variables, [name]: updated } })\n              }\n              onRemove={() => {\n                const newVars = { ...variables };\n                delete newVars[name];\n                onChange({ ...generator, variables: newVars });\n              }}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ generator, onChange, schema }", "type": "{ generator: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "code", "label", "input", "button"], "hookCalls": [{"name": "useState", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared/VariableSelectionEditor", "specifiers": ["VariableSelectionEditor"], "category": "internal"}, {"source": "./VariablesTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/pressures/cards/FactorCard.jsx::FactorCard", "name": "FactorCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/cards/FactorCard.jsx", "sourceCode": "export function FactorCard({\n  factor,\n  feedbackType,\n  onEdit,\n  onDelete,\n  schema: _schema\n}) {\n  const typeConfig = FACTOR_TYPES[factor.type] || {};\n\n  // Generate summary based on factor type\n  const getSummary = () => {\n    switch (factor.type) {\n      case \"entity_count\":\n        {\n          const entityKindSpec = `${factor.kind}${factor.subtype ? \":\" + factor.subtype : \"\"}`;\n          const statusSuffix = factor.status ? ` (${factor.status})` : \"\";\n          return `${entityKindSpec}${statusSuffix}`;\n        }\n      case \"relationship_count\":\n        return factor.relationshipKinds?.join(\", \") || \"No relationships selected\";\n      case \"tag_count\":\n        return factor.tags?.join(\", \") || \"No tags selected\";\n      case \"ratio\":\n        {\n          const num = factor.numerator?.kind || factor.numerator?.relationshipKinds?.join(\",\") || \"?\";\n          const den = factor.denominator?.kind || factor.denominator?.relationshipKinds?.join(\",\") || factor.denominator?.type || \"?\";\n          return `${num} / ${den}`;\n        }\n      case \"status_ratio\":\n        {\n          const statusKindSpec = `${factor.kind}${factor.subtype ? \":\" + factor.subtype : \"\"}`;\n          return `${statusKindSpec} (${factor.aliveStatus})`;\n        }\n      case \"cross_culture_ratio\":\n        return factor.relationshipKinds?.join(\", \") || \"No relationships selected\";\n      default:\n        return \"Unknown factor\";\n    }\n  };\n  return <div className=\"nested-card\">\n      <div className=\"nested-card-header\" onClick={onEdit} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") onEdit(e);\n    }}>\n        {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color */}\n        <div className=\"nested-card-icon\" style={{\n        '--fc-icon-bg': `${typeConfig.color}20`, backgroundColor: 'var(--fc-icon-bg)'\n      }}>\n          {typeConfig.icon}\n        </div>\n        <div className=\"nested-card-info\">\n          <div className=\"nested-card-type\">{typeConfig.label}</div>\n          <div className=\"nested-card-summary\">{getSummary()}</div>\n        </div>\n        <div className={`nested-card-coefficient ${feedbackType === \"positive\" ? \"pc-factor-positive\" : \"pc-factor-negative\"}`}>\n          {feedbackType === \"positive\" ? \"+\" : \"\u2212\"}\n          {Math.abs(factor.coefficient)}\n          {factor.cap ? ` (cap: ${factor.cap})` : \"\"}\n        </div>\n        <div className=\"nested-card-actions\">\n          <button className=\"icon-button\" onClick={e => {\n          e.stopPropagation();\n          onEdit();\n        }} title=\"Edit\">\n            \u270f\ufe0f\n          </button>\n          <button className=\"icon-button delete-button\" onClick={e => {\n          e.stopPropagation();\n          onDelete();\n        }} title=\"Remove\">\n            \ud83d\uddd1\ufe0f\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  factor,\n  feedbackType,\n  onEdit,\n  onDelete,\n  schema: _schema\n}", "type": "{ factor: any; feedbackType: any; onEdit: any; onDelete: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["FACTOR_TYPES"], "category": "internal"}, {"source": "./PressureCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/pressures/cards/index.js::FactorCard", "name": "FactorCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/cards/index.js", "sourceCode": "export function FactorCard({\n  factor,\n  feedbackType,\n  onEdit,\n  onDelete,\n  schema: _schema\n}) {\n  const typeConfig = FACTOR_TYPES[factor.type] || {};\n\n  // Generate summary based on factor type\n  const getSummary = () => {\n    switch (factor.type) {\n      case \"entity_count\":\n        {\n          const entityKindSpec = `${factor.kind}${factor.subtype ? \":\" + factor.subtype : \"\"}`;\n          const statusSuffix = factor.status ? ` (${factor.status})` : \"\";\n          return `${entityKindSpec}${statusSuffix}`;\n        }\n      case \"relationship_count\":\n        return factor.relationshipKinds?.join(\", \") || \"No relationships selected\";\n      case \"tag_count\":\n        return factor.tags?.join(\", \") || \"No tags selected\";\n      case \"ratio\":\n        {\n          const num = factor.numerator?.kind || factor.numerator?.relationshipKinds?.join(\",\") || \"?\";\n          const den = factor.denominator?.kind || factor.denominator?.relationshipKinds?.join(\",\") || factor.denominator?.type || \"?\";\n          return `${num} / ${den}`;\n        }\n      case \"status_ratio\":\n        {\n          const statusKindSpec = `${factor.kind}${factor.subtype ? \":\" + factor.subtype : \"\"}`;\n          return `${statusKindSpec} (${factor.aliveStatus})`;\n        }\n      case \"cross_culture_ratio\":\n        return factor.relationshipKinds?.join(\", \") || \"No relationships selected\";\n      default:\n        return \"Unknown factor\";\n    }\n  };\n  return <div className=\"nested-card\">\n      <div className=\"nested-card-header\" onClick={onEdit} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") onEdit(e);\n    }}>\n        {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color */}\n        <div className=\"nested-card-icon\" style={{\n        '--fc-icon-bg': `${typeConfig.color}20`, backgroundColor: 'var(--fc-icon-bg)'\n      }}>\n          {typeConfig.icon}\n        </div>\n        <div className=\"nested-card-info\">\n          <div className=\"nested-card-type\">{typeConfig.label}</div>\n          <div className=\"nested-card-summary\">{getSummary()}</div>\n        </div>\n        <div className={`nested-card-coefficient ${feedbackType === \"positive\" ? \"pc-factor-positive\" : \"pc-factor-negative\"}`}>\n          {feedbackType === \"positive\" ? \"+\" : \"\u2212\"}\n          {Math.abs(factor.coefficient)}\n          {factor.cap ? ` (cap: ${factor.cap})` : \"\"}\n        </div>\n        <div className=\"nested-card-actions\">\n          <button className=\"icon-button\" onClick={e => {\n          e.stopPropagation();\n          onEdit();\n        }} title=\"Edit\">\n            \u270f\ufe0f\n          </button>\n          <button className=\"icon-button delete-button\" onClick={e => {\n          e.stopPropagation();\n          onDelete();\n        }} title=\"Remove\">\n            \ud83d\uddd1\ufe0f\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  factor,\n  feedbackType,\n  onEdit,\n  onDelete,\n  schema: _schema\n}", "type": "{ factor: any; feedbackType: any; onEdit: any; onDelete: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/pressures/cards/index.js::PressureCard", "name": "PressureCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/cards/index.js", "sourceCode": "export function PressureCard({\n  pressure,\n  expanded,\n  onToggle,\n  onChange,\n  onDelete,\n  schema,\n  usageMap,\n  projectId,\n}) {\n  const [, setHovering] = useState(false);\n  const [editingFactor, setEditingFactor] = useState(null);\n  const [addingFactorType, setAddingFactorType] = useState(null);\n  const factorModalKey = buildStorageKey(projectId, \"pressures:factorModal\");\n\n  const handleFieldChange = useCallback(\n    (field, value) => {\n      onChange({\n        ...pressure,\n        [field]: value,\n      });\n    },\n    [pressure, onChange]\n  );\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(pressure.id, (value) =>\n    handleFieldChange(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(pressure.name, (value) =>\n    handleFieldChange(\"name\", value)\n  );\n  const [localDescription, setLocalDescription, handleDescriptionBlur] = useLocalInputState(\n    pressure.description || \"\",\n    (value) => handleFieldChange(\"description\", value)\n  );\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"pressure\", pressure.id)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, pressure.id]\n  );\n\n  const usage = useMemo(() => {\n    if (!usageMap?.pressures?.[pressure.id]) return null;\n    return usageMap.pressures[pressure.id];\n  }, [usageMap, pressure.id]);\n\n  const hasErrors = validation.invalidRefs.length > 0;\n  const isOrphan = validation.isOrphan;\n  const usedByCount = usage\n    ? (usage.generators?.length || 0) + (usage.systems?.length || 0) + (usage.actions?.length || 0)\n    : 0;\n\n  const handleGrowthChange = useCallback(\n    (field, value) => {\n      onChange({\n        ...pressure,\n        growth: {\n          ...pressure.growth,\n          [field]: value,\n        },\n      });\n    },\n    [pressure, onChange]\n  );\n\n  const persistFactorModal = useCallback(\n    (payload) => {\n      if (!factorModalKey) return;\n      if (payload) {\n        saveStoredValue(factorModalKey, payload);\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    },\n    [factorModalKey]\n  );\n\n  const handleAddFactor = useCallback(\n    (feedbackType) => {\n      setAddingFactorType(feedbackType);\n      persistFactorModal({\n        pressureId: pressure.id,\n        mode: \"add\",\n        feedbackType,\n      });\n    },\n    [pressure.id, persistFactorModal]\n  );\n\n  const handleSaveFactor = useCallback(\n    (factor, feedbackType, index) => {\n      const feedbackKey = feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const currentFactors = [...(pressure.growth?.[feedbackKey] || [])];\n\n      if (index !== undefined && index >= 0) {\n        currentFactors[index] = factor;\n      } else {\n        currentFactors.push(factor);\n      }\n\n      handleGrowthChange(feedbackKey, currentFactors);\n      setEditingFactor(null);\n      setAddingFactorType(null);\n      persistFactorModal(null);\n    },\n    [pressure, handleGrowthChange, persistFactorModal]\n  );\n\n  const handleEditFactor = useCallback(\n    (factor, feedbackType, index) => {\n      setEditingFactor({ factor, feedbackType, index });\n      persistFactorModal({\n        pressureId: pressure.id,\n        mode: \"edit\",\n        feedbackType,\n        factorIndex: index,\n      });\n    },\n    [pressure.id, persistFactorModal]\n  );\n\n  const handleCloseFactorModal = useCallback(() => {\n    setEditingFactor(null);\n    setAddingFactorType(null);\n    persistFactorModal(null);\n  }, [persistFactorModal]);\n\n  const handleRemoveFactor = useCallback(\n    (feedbackType, index) => {\n      const feedbackKey = feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const newFactors = [...(pressure.growth?.[feedbackKey] || [])];\n      newFactors.splice(index, 1);\n      handleGrowthChange(feedbackKey, newFactors);\n    },\n    [pressure, handleGrowthChange]\n  );\n\n  const positiveFeedback = pressure.growth?.positiveFeedback || [];\n  const negativeFeedback = pressure.growth?.negativeFeedback || [];\n  // Compute feedback loop balance status\n  const feedbackStatus = useMemo(() => {\n    const hasPositive = positiveFeedback.length > 0;\n    const hasNegative = negativeFeedback.length > 0;\n    const hasHomeostasis = (pressure.homeostasis || 0) !== 0;\n\n    if (!hasPositive && !hasNegative && !hasHomeostasis) {\n      return {\n        icon: \"\u26aa\",\n        color: \"#9ca3af\",\n        label: \"Static\",\n        description: \"No feedback or homeostasis\",\n      };\n    }\n    if (!hasPositive && !hasNegative && hasHomeostasis) {\n      return {\n        icon: \"\ud83e\udded\",\n        color: \"#22c55e\",\n        label: \"Centering\",\n        description: \"Homeostasis will pull toward equilibrium\",\n      };\n    }\n    if (hasPositive && !hasNegative) {\n      return {\n        icon: \"\ud83d\udcc8\",\n        color: \"#f59e0b\",\n        label: \"Runaway\",\n        description: \"May grow unbounded - consider adding negative feedback\",\n      };\n    }\n    if (!hasPositive && hasNegative && !hasHomeostasis) {\n      return {\n        icon: \"\ud83d\udcc9\",\n        color: \"#3b82f6\",\n        label: \"Diminishing\",\n        description: \"Will trend downward from feedback alone\",\n      };\n    }\n    // Both present - self-correcting\n    return {\n      icon: \"\u2696\ufe0f\",\n      color: \"#22c55e\",\n      label: \"Balanced\",\n      description: \"Feedback plus homeostasis provide stabilization\",\n    };\n  }, [positiveFeedback.length, negativeFeedback.length, pressure.homeostasis]);\n\n  // Restore factor modal state from storage (guarded)\n  const restoredModalKeyRef = useRef(null);\n  useEffect(() => {\n    if (!factorModalKey || editingFactor || addingFactorType || restoredModalKeyRef.current === factorModalKey) {\n      return;\n    }\n\n    restoredModalKeyRef.current = factorModalKey;\n    const stored = loadStoredValue(factorModalKey);\n    if (!(stored && stored.pressureId === pressure.id)) {\n      return;\n    }\n\n    if (stored.mode === \"add\") {\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted factor modal state\n      setAddingFactorType(stored.feedbackType);\n      return;\n    }\n\n    if (stored.mode === \"edit\") {\n      const feedbackKey =\n        stored.feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const factor = pressure.growth?.[feedbackKey]?.[stored.factorIndex];\n      if (factor) {\n        // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted factor modal state\n        setEditingFactor({ factor, feedbackType: stored.feedbackType, index: stored.factorIndex });\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    }\n  }, [addingFactorType, editingFactor, factorModalKey, pressure]);\n\n  return (\n    <div className=\"expandable-card\">\n      <div\n        className=\"expandable-card-header\"\n        onClick={onToggle}\n        onMouseEnter={() => setHovering(true)}\n        onMouseLeave={() => setHovering(false)}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggle(e); }}\n      >\n        <div\n          className=\"expandable-card-title pc-title-layout\"\n        >\n          <div className=\"pc-title-row\">\n            <span className=\"expandable-card-name\">{pressure.name}</span>\n            <span className=\"expandable-card-id\">{pressure.id}</span>\n            {hasErrors && (\n              <span className=\"card-error-badge\">\n                {validation.invalidRefs.length} error\n                {validation.invalidRefs.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n            {usedByCount > 0 && <span className=\"card-usage-badge\">Used by {usedByCount}</span>}\n            {isOrphan && !hasErrors && <span className=\"card-orphan-badge\">Not used</span>}\n          </div>\n          {pressure.description && (\n            <div className=\"expandable-card-subtitle\">{pressure.description}</div>\n          )}\n        </div>\n        <div className=\"pc-header-right\">\n          <div className=\"expandable-card-stats\">\n            <div className=\"stat\">\n              <span className=\"stat-label\">Initial</span>\n              <span className=\"stat-value\">{pressure.initialValue}</span>\n              <div className=\"stat-bar\">\n                <div\n                  className=\"stat-bar-fill pc-stat-bar-fill\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic width from pressure value\n                  style={{\n                    '--pc-bar-width': `${Math.min(100, Math.max(0, ((pressure.initialValue || 0) + 100) / 2))}%`,\n                    width: 'var(--pc-bar-width)',\n                  }}\n                />\n              </div>\n            </div>\n            <div className=\"stat\">\n              <span className=\"stat-label\">Homeostasis</span>\n              <span className=\"stat-value\">{pressure.homeostasis}</span>\n            </div>\n            <div className=\"stat\">\n              <span className=\"stat-label\">Factors</span>\n              <span className=\"stat-value\">\n                <span className=\"pc-factor-positive\">+{positiveFeedback.length}</span>\n                {\" / \"}\n                <span className=\"pc-factor-negative\">-{negativeFeedback.length}</span>\n              </span>\n            </div>\n            <div className=\"stat\" title={feedbackStatus.description}>\n              <span className=\"stat-label\">Balance</span>\n              {/* eslint-disable-next-line local/no-inline-styles -- dynamic feedback color */}\n              <span\n                className=\"stat-value pc-balance-value\"\n                style={{ '--pc-balance-color': feedbackStatus.color, color: 'var(--pc-balance-color)' }}\n              >\n                <span>{feedbackStatus.icon}</span>\n                <span className=\"pc-balance-label\">{feedbackStatus.label}</span>\n              </span>\n            </div>\n          </div>\n          <span className={`expand-icon ${expanded ? \"expand-icon-open\" : \"\"}`}>\u25bc</span>\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {/* Basic Info */}\n          <div className=\"section\">\n// ... (truncated)", "parameters": [{"name": "{\n  pressure,\n  expanded,\n  onToggle,\n  onChange,\n  onDelete,\n  schema,\n  usageMap,\n  projectId,\n}", "type": "{ pressure: any; expanded: any; onToggle: any; onChange: any; onDelete: any; schema: any; usageMap: any; projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div", "label", "input", "NumberInput", "textarea", "button", "FactorEditorModal"], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useCallback", "count": 8}, {"name": "useLocalInputState", "count": 3}, {"name": "useMemo", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "customHookCalls": ["useLocalInputState"], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/pressures/cards/PressureCard.jsx::PressureCard", "name": "PressureCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/cards/PressureCard.jsx", "sourceCode": "export function PressureCard({\n  pressure,\n  expanded,\n  onToggle,\n  onChange,\n  onDelete,\n  schema,\n  usageMap,\n  projectId,\n}) {\n  const [, setHovering] = useState(false);\n  const [editingFactor, setEditingFactor] = useState(null);\n  const [addingFactorType, setAddingFactorType] = useState(null);\n  const factorModalKey = buildStorageKey(projectId, \"pressures:factorModal\");\n\n  const handleFieldChange = useCallback(\n    (field, value) => {\n      onChange({\n        ...pressure,\n        [field]: value,\n      });\n    },\n    [pressure, onChange]\n  );\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(pressure.id, (value) =>\n    handleFieldChange(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(pressure.name, (value) =>\n    handleFieldChange(\"name\", value)\n  );\n  const [localDescription, setLocalDescription, handleDescriptionBlur] = useLocalInputState(\n    pressure.description || \"\",\n    (value) => handleFieldChange(\"description\", value)\n  );\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"pressure\", pressure.id)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, pressure.id]\n  );\n\n  const usage = useMemo(() => {\n    if (!usageMap?.pressures?.[pressure.id]) return null;\n    return usageMap.pressures[pressure.id];\n  }, [usageMap, pressure.id]);\n\n  const hasErrors = validation.invalidRefs.length > 0;\n  const isOrphan = validation.isOrphan;\n  const usedByCount = usage\n    ? (usage.generators?.length || 0) + (usage.systems?.length || 0) + (usage.actions?.length || 0)\n    : 0;\n\n  const handleGrowthChange = useCallback(\n    (field, value) => {\n      onChange({\n        ...pressure,\n        growth: {\n          ...pressure.growth,\n          [field]: value,\n        },\n      });\n    },\n    [pressure, onChange]\n  );\n\n  const persistFactorModal = useCallback(\n    (payload) => {\n      if (!factorModalKey) return;\n      if (payload) {\n        saveStoredValue(factorModalKey, payload);\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    },\n    [factorModalKey]\n  );\n\n  const handleAddFactor = useCallback(\n    (feedbackType) => {\n      setAddingFactorType(feedbackType);\n      persistFactorModal({\n        pressureId: pressure.id,\n        mode: \"add\",\n        feedbackType,\n      });\n    },\n    [pressure.id, persistFactorModal]\n  );\n\n  const handleSaveFactor = useCallback(\n    (factor, feedbackType, index) => {\n      const feedbackKey = feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const currentFactors = [...(pressure.growth?.[feedbackKey] || [])];\n\n      if (index !== undefined && index >= 0) {\n        currentFactors[index] = factor;\n      } else {\n        currentFactors.push(factor);\n      }\n\n      handleGrowthChange(feedbackKey, currentFactors);\n      setEditingFactor(null);\n      setAddingFactorType(null);\n      persistFactorModal(null);\n    },\n    [pressure, handleGrowthChange, persistFactorModal]\n  );\n\n  const handleEditFactor = useCallback(\n    (factor, feedbackType, index) => {\n      setEditingFactor({ factor, feedbackType, index });\n      persistFactorModal({\n        pressureId: pressure.id,\n        mode: \"edit\",\n        feedbackType,\n        factorIndex: index,\n      });\n    },\n    [pressure.id, persistFactorModal]\n  );\n\n  const handleCloseFactorModal = useCallback(() => {\n    setEditingFactor(null);\n    setAddingFactorType(null);\n    persistFactorModal(null);\n  }, [persistFactorModal]);\n\n  const handleRemoveFactor = useCallback(\n    (feedbackType, index) => {\n      const feedbackKey = feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const newFactors = [...(pressure.growth?.[feedbackKey] || [])];\n      newFactors.splice(index, 1);\n      handleGrowthChange(feedbackKey, newFactors);\n    },\n    [pressure, handleGrowthChange]\n  );\n\n  const positiveFeedback = pressure.growth?.positiveFeedback || [];\n  const negativeFeedback = pressure.growth?.negativeFeedback || [];\n  // Compute feedback loop balance status\n  const feedbackStatus = useMemo(() => {\n    const hasPositive = positiveFeedback.length > 0;\n    const hasNegative = negativeFeedback.length > 0;\n    const hasHomeostasis = (pressure.homeostasis || 0) !== 0;\n\n    if (!hasPositive && !hasNegative && !hasHomeostasis) {\n      return {\n        icon: \"\u26aa\",\n        color: \"#9ca3af\",\n        label: \"Static\",\n        description: \"No feedback or homeostasis\",\n      };\n    }\n    if (!hasPositive && !hasNegative && hasHomeostasis) {\n      return {\n        icon: \"\ud83e\udded\",\n        color: \"#22c55e\",\n        label: \"Centering\",\n        description: \"Homeostasis will pull toward equilibrium\",\n      };\n    }\n    if (hasPositive && !hasNegative) {\n      return {\n        icon: \"\ud83d\udcc8\",\n        color: \"#f59e0b\",\n        label: \"Runaway\",\n        description: \"May grow unbounded - consider adding negative feedback\",\n      };\n    }\n    if (!hasPositive && hasNegative && !hasHomeostasis) {\n      return {\n        icon: \"\ud83d\udcc9\",\n        color: \"#3b82f6\",\n        label: \"Diminishing\",\n        description: \"Will trend downward from feedback alone\",\n      };\n    }\n    // Both present - self-correcting\n    return {\n      icon: \"\u2696\ufe0f\",\n      color: \"#22c55e\",\n      label: \"Balanced\",\n      description: \"Feedback plus homeostasis provide stabilization\",\n    };\n  }, [positiveFeedback.length, negativeFeedback.length, pressure.homeostasis]);\n\n  // Restore factor modal state from storage (guarded)\n  const restoredModalKeyRef = useRef(null);\n  useEffect(() => {\n    if (!factorModalKey || editingFactor || addingFactorType || restoredModalKeyRef.current === factorModalKey) {\n      return;\n    }\n\n    restoredModalKeyRef.current = factorModalKey;\n    const stored = loadStoredValue(factorModalKey);\n    if (!(stored && stored.pressureId === pressure.id)) {\n      return;\n    }\n\n    if (stored.mode === \"add\") {\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted factor modal state\n      setAddingFactorType(stored.feedbackType);\n      return;\n    }\n\n    if (stored.mode === \"edit\") {\n      const feedbackKey =\n        stored.feedbackType === \"positive\" ? \"positiveFeedback\" : \"negativeFeedback\";\n      const factor = pressure.growth?.[feedbackKey]?.[stored.factorIndex];\n      if (factor) {\n        // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted factor modal state\n        setEditingFactor({ factor, feedbackType: stored.feedbackType, index: stored.factorIndex });\n      } else {\n        clearStoredValue(factorModalKey);\n      }\n    }\n  }, [addingFactorType, editingFactor, factorModalKey, pressure]);\n\n  return (\n    <div className=\"expandable-card\">\n      <div\n        className=\"expandable-card-header\"\n        onClick={onToggle}\n        onMouseEnter={() => setHovering(true)}\n        onMouseLeave={() => setHovering(false)}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggle(e); }}\n      >\n        <div\n          className=\"expandable-card-title pc-title-layout\"\n        >\n          <div className=\"pc-title-row\">\n            <span className=\"expandable-card-name\">{pressure.name}</span>\n            <span className=\"expandable-card-id\">{pressure.id}</span>\n            {hasErrors && (\n              <span className=\"card-error-badge\">\n                {validation.invalidRefs.length} error\n                {validation.invalidRefs.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n            {usedByCount > 0 && <span className=\"card-usage-badge\">Used by {usedByCount}</span>}\n            {isOrphan && !hasErrors && <span className=\"card-orphan-badge\">Not used</span>}\n          </div>\n          {pressure.description && (\n            <div className=\"expandable-card-subtitle\">{pressure.description}</div>\n          )}\n        </div>\n        <div className=\"pc-header-right\">\n          <div className=\"expandable-card-stats\">\n            <div className=\"stat\">\n              <span className=\"stat-label\">Initial</span>\n              <span className=\"stat-value\">{pressure.initialValue}</span>\n              <div className=\"stat-bar\">\n                <div\n                  className=\"stat-bar-fill pc-stat-bar-fill\"\n                  // eslint-disable-next-line local/no-inline-styles -- dynamic width from pressure value\n                  style={{\n                    '--pc-bar-width': `${Math.min(100, Math.max(0, ((pressure.initialValue || 0) + 100) / 2))}%`,\n                    width: 'var(--pc-bar-width)',\n                  }}\n                />\n              </div>\n            </div>\n            <div className=\"stat\">\n              <span className=\"stat-label\">Homeostasis</span>\n              <span className=\"stat-value\">{pressure.homeostasis}</span>\n            </div>\n            <div className=\"stat\">\n              <span className=\"stat-label\">Factors</span>\n              <span className=\"stat-value\">\n                <span className=\"pc-factor-positive\">+{positiveFeedback.length}</span>\n                {\" / \"}\n                <span className=\"pc-factor-negative\">-{negativeFeedback.length}</span>\n              </span>\n            </div>\n            <div className=\"stat\" title={feedbackStatus.description}>\n              <span className=\"stat-label\">Balance</span>\n              {/* eslint-disable-next-line local/no-inline-styles -- dynamic feedback color */}\n              <span\n                className=\"stat-value pc-balance-value\"\n                style={{ '--pc-balance-color': feedbackStatus.color, color: 'var(--pc-balance-color)' }}\n              >\n                <span>{feedbackStatus.icon}</span>\n                <span className=\"pc-balance-label\">{feedbackStatus.label}</span>\n              </span>\n            </div>\n          </div>\n          <span className={`expand-icon ${expanded ? \"expand-icon-open\" : \"\"}`}>\u25bc</span>\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {/* Basic Info */}\n          <div className=\"section\">\n// ... (truncated)", "parameters": [{"name": "{\n  pressure,\n  expanded,\n  onToggle,\n  onChange,\n  onDelete,\n  schema,\n  usageMap,\n  projectId,\n}", "type": "{ pressure: any; expanded: any; onToggle: any; onChange: any; onDelete: any; schema: any; usageMap: any; projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div", "label", "input", "NumberInput", "textarea", "button", "FactorEditorModal"], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useCallback", "count": 8}, {"name": "useLocalInputState", "count": 3}, {"name": "useMemo", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "customHookCalls": ["useLocalInputState"], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./FactorCard", "specifiers": ["FactorCard"], "category": "internal"}, {"source": "../modals/FactorEditorModal", "specifiers": ["FactorEditorModal"], "category": "internal"}, {"source": "../../shared", "specifiers": ["getElementValidation", "useLocalInputState", "NumberInput"], "category": "internal"}, {"source": "../../../utils/persistence", "specifiers": ["buildStorageKey", "clearStoredValue", "loadStoredValue", "saveStoredValue"], "category": "internal"}, {"source": "./PressureCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/pressures/modals/FactorEditorModal.jsx::FactorEditorModal", "name": "FactorEditorModal", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/modals/FactorEditorModal.jsx", "sourceCode": "export function FactorEditorModal({ isOpen, onClose, factor, onChange, feedbackType, schema }) {\n  const [localFactor, setLocalFactor] = useState(factor || { type: \"entity_count\" });\n  const [selectedType, setSelectedType] = useState(factor?.type || \"entity_count\");\n\n  // Build options from schema\n  const entityKindOptions = useMemo(() => {\n    return (schema?.entityKinds || []).map((ek) => ({\n      value: ek.kind,\n      label: ek.description || ek.kind,\n    }));\n  }, [schema]);\n\n  const getSubtypeOptions = useCallback(\n    (kind) => {\n      const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n      if (!ek?.subtypes) return [];\n      return ek.subtypes.map((st) => ({\n        value: st.id,\n        label: st.name || st.id,\n      }));\n    },\n    [schema]\n  );\n\n  const getStatusOptions = useCallback(\n    (kind) => {\n      const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n      if (!ek?.statuses) return [];\n      return ek.statuses.map((st) => ({\n        value: st.id,\n        label: st.name || st.id,\n        meta: st.isTerminal ? \"terminal\" : \"\",\n      }));\n    },\n    [schema]\n  );\n\n  const relationshipKindOptions = useMemo(() => {\n    return (schema?.relationshipKinds || []).map((rk) => ({\n      value: rk.kind,\n      label: rk.description || rk.kind,\n    }));\n  }, [schema]);\n\n  // Sync local state when factor or isOpen changes\n  useEffect(() => {\n    if (factor) {\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n      setLocalFactor(factor);\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n      setSelectedType(factor.type);\n      return;\n    }\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n    setLocalFactor({ type: \"entity_count\", coefficient: 1 });\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n    setSelectedType(\"entity_count\");\n  }, [factor, isOpen]);\n\n  const handleTypeChange = (type) => {\n    setSelectedType(type);\n    // Reset factor to defaults for new type\n    const defaults = { type, coefficient: 1 };\n    if (type === \"ratio\") {\n      defaults.numerator = { type: \"entity_count\" };\n      defaults.denominator = { type: \"entity_count\" };\n      defaults.fallbackValue = 0;\n    }\n    setLocalFactor(defaults);\n  };\n\n  const updateField = (field, value) => {\n    setLocalFactor((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleSave = () => {\n    onChange(localFactor);\n    onClose();\n  };\n\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const typeConfig = FACTOR_TYPES[selectedType];\n\n  // Render numerator/denominator editor for ratio type\n  const renderCountEditor = (countObj, onCountChange, label) => {\n    const countType = countObj?.type || \"entity_count\";\n    return (\n      <div className=\"nested-section\">\n        <div className=\"nested-title\">{label}</div>\n        <div className=\"input-grid\">\n          <ReferenceDropdown\n            label=\"Count Type\"\n            value={countType}\n            onChange={(v) => onCountChange({ ...countObj, type: v })}\n            options={[\n              { value: \"entity_count\", label: \"Entity Count\" },\n              { value: \"relationship_count\", label: \"Relationship Count\" },\n              { value: \"total_entities\", label: \"Total Entities\" },\n            ]}\n          />\n          {countType === \"entity_count\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Entity Kind\"\n                value={countObj?.kind || \"\"}\n                onChange={(v) => onCountChange({ ...countObj, kind: v, subtype: undefined })}\n                options={entityKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              {countObj?.kind && (\n                <ReferenceDropdown\n                  label=\"Subtype (optional)\"\n                  value={countObj?.subtype || \"\"}\n                  onChange={(v) => onCountChange({ ...countObj, subtype: v || undefined })}\n                  options={getSubtypeOptions(countObj.kind)}\n                  placeholder=\"Any subtype\"\n                />\n              )}\n            </>\n          )}\n          {countType === \"relationship_count\" && (\n            <ChipSelect\n              label=\"Relationship Kinds\"\n              value={countObj?.relationshipKinds || []}\n              onChange={(v) => onCountChange({ ...countObj, relationshipKinds: v })}\n              options={relationshipKindOptions}\n              placeholder=\"Select relationships...\"\n            />\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div\n      className=\"modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"modal\">\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            <span>{typeConfig?.icon}</span>\n            {factor ? \"Edit Factor\" : \"Add Factor\"}\n            <span\n              className={feedbackType === \"positive\" ? \"fem-feedback-badge-positive\" : \"fem-feedback-badge-negative\"}\n            >\n              {feedbackType === \"positive\" ? \"+ Positive\" : \"- Negative\"}\n            </span>\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n\n        <div className=\"modal-content\">\n          {/* Type selector - compact pills */}\n          <div className=\"mb-2xl\">\n            <span className=\"label\">Factor Type</span>\n            <div className=\"type-selector\">\n              {Object.entries(FACTOR_TYPES).map(([type, config]) => (\n                <div\n                  key={type}\n                  onClick={() => handleTypeChange(type)}\n                  className={`type-pill ${selectedType === type ? \"type-pill-selected\" : \"\"}`}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <span className=\"type-pill-icon\">{config.icon}</span>\n                  <span>{config.label}</span>\n                </div>\n              ))}\n            </div>\n            {typeConfig && <div className=\"type-description\">{typeConfig.description}</div>}\n          </div>\n\n          {/* Type-specific fields */}\n          <div className=\"input-grid\">\n            {/* Entity Count fields */}\n            {selectedType === \"entity_count\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={localFactor.kind || \"\"}\n                  onChange={(v) => updateField(\"kind\", v)}\n                  options={entityKindOptions}\n                  placeholder=\"Select kind...\"\n                />\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Subtype (optional)\"\n                    value={localFactor.subtype || \"\"}\n                    onChange={(v) => updateField(\"subtype\", v || undefined)}\n                    options={getSubtypeOptions(localFactor.kind)}\n                    placeholder=\"Any subtype\"\n                  />\n                )}\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Status (optional)\"\n                    value={localFactor.status || \"\"}\n                    onChange={(v) => updateField(\"status\", v || undefined)}\n                    options={getStatusOptions(localFactor.kind)}\n                    placeholder=\"Any status\"\n                  />\n                )}\n              </>\n            )}\n\n            {/* Relationship Count fields */}\n            {selectedType === \"relationship_count\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Relationship Kinds\"\n                  value={localFactor.relationshipKinds || []}\n                  onChange={(v) => updateField(\"relationshipKinds\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship types...\"\n                />\n              </div>\n            )}\n\n            {/* Tag Count fields */}\n            {selectedType === \"tag_count\" && (\n              <div className=\"grid-col-full\">\n                <label className=\"label\">Tags\n                <TagSelector\n                  value={localFactor.tags || []}\n                  onChange={(v) => updateField(\"tags\", v)}\n                  tagRegistry={schema?.tagRegistry || []}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n            )}\n\n            {/* Status Ratio fields */}\n            {selectedType === \"status_ratio\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={localFactor.kind || \"\"}\n                  onChange={(v) => {\n                    updateField(\"kind\", v);\n                    updateField(\"subtype\", undefined);\n                    updateField(\"aliveStatus\", undefined);\n                  }}\n                  options={entityKindOptions}\n                  placeholder=\"Select kind...\"\n                />\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Subtype (optional)\"\n                    value={localFactor.subtype || \"\"}\n                    onChange={(v) => updateField(\"subtype\", v || undefined)}\n                    options={getSubtypeOptions(localFactor.kind)}\n                    placeholder=\"Any subtype\"\n                  />\n                )}\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Alive Status\"\n                    value={localFactor.aliveStatus || \"\"}\n                    onChange={(v) => updateField(\"aliveStatus\", v)}\n                    options={getStatusOptions(localFactor.kind)}\n                    placeholder=\"Select status...\"\n                  />\n                )}\n              </>\n            )}\n\n            {/* Cross-Culture Ratio fields */}\n            {selectedType === \"cross_culture_ratio\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Relationship Kinds\"\n                  value={localFactor.relationshipKinds || []}\n                  onChange={(v) => updateField(\"relationshipKinds\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship types...\"\n                />\n              </div>\n// ... (truncated)", "parameters": [{"name": "{ isOpen, onClose, factor, onChange, feedbackType, schema }", "type": "{ isOpen: any; onClose: any; factor: any; onChange: any; feedbackType: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "ChipSelect"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 2}, {"name": "useCallback", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useRef", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["FACTOR_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "./FactorEditorModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/pressures/modals/index.js::FactorEditorModal", "name": "FactorEditorModal", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/pressures/modals/index.js", "sourceCode": "export function FactorEditorModal({ isOpen, onClose, factor, onChange, feedbackType, schema }) {\n  const [localFactor, setLocalFactor] = useState(factor || { type: \"entity_count\" });\n  const [selectedType, setSelectedType] = useState(factor?.type || \"entity_count\");\n\n  // Build options from schema\n  const entityKindOptions = useMemo(() => {\n    return (schema?.entityKinds || []).map((ek) => ({\n      value: ek.kind,\n      label: ek.description || ek.kind,\n    }));\n  }, [schema]);\n\n  const getSubtypeOptions = useCallback(\n    (kind) => {\n      const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n      if (!ek?.subtypes) return [];\n      return ek.subtypes.map((st) => ({\n        value: st.id,\n        label: st.name || st.id,\n      }));\n    },\n    [schema]\n  );\n\n  const getStatusOptions = useCallback(\n    (kind) => {\n      const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n      if (!ek?.statuses) return [];\n      return ek.statuses.map((st) => ({\n        value: st.id,\n        label: st.name || st.id,\n        meta: st.isTerminal ? \"terminal\" : \"\",\n      }));\n    },\n    [schema]\n  );\n\n  const relationshipKindOptions = useMemo(() => {\n    return (schema?.relationshipKinds || []).map((rk) => ({\n      value: rk.kind,\n      label: rk.description || rk.kind,\n    }));\n  }, [schema]);\n\n  // Sync local state when factor or isOpen changes\n  useEffect(() => {\n    if (factor) {\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n      setLocalFactor(factor);\n      // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n      setSelectedType(factor.type);\n      return;\n    }\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n    setLocalFactor({ type: \"entity_count\", coefficient: 1 });\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync modal draft from props on open/change\n    setSelectedType(\"entity_count\");\n  }, [factor, isOpen]);\n\n  const handleTypeChange = (type) => {\n    setSelectedType(type);\n    // Reset factor to defaults for new type\n    const defaults = { type, coefficient: 1 };\n    if (type === \"ratio\") {\n      defaults.numerator = { type: \"entity_count\" };\n      defaults.denominator = { type: \"entity_count\" };\n      defaults.fallbackValue = 0;\n    }\n    setLocalFactor(defaults);\n  };\n\n  const updateField = (field, value) => {\n    setLocalFactor((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleSave = () => {\n    onChange(localFactor);\n    onClose();\n  };\n\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const typeConfig = FACTOR_TYPES[selectedType];\n\n  // Render numerator/denominator editor for ratio type\n  const renderCountEditor = (countObj, onCountChange, label) => {\n    const countType = countObj?.type || \"entity_count\";\n    return (\n      <div className=\"nested-section\">\n        <div className=\"nested-title\">{label}</div>\n        <div className=\"input-grid\">\n          <ReferenceDropdown\n            label=\"Count Type\"\n            value={countType}\n            onChange={(v) => onCountChange({ ...countObj, type: v })}\n            options={[\n              { value: \"entity_count\", label: \"Entity Count\" },\n              { value: \"relationship_count\", label: \"Relationship Count\" },\n              { value: \"total_entities\", label: \"Total Entities\" },\n            ]}\n          />\n          {countType === \"entity_count\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Entity Kind\"\n                value={countObj?.kind || \"\"}\n                onChange={(v) => onCountChange({ ...countObj, kind: v, subtype: undefined })}\n                options={entityKindOptions}\n                placeholder=\"Select kind...\"\n              />\n              {countObj?.kind && (\n                <ReferenceDropdown\n                  label=\"Subtype (optional)\"\n                  value={countObj?.subtype || \"\"}\n                  onChange={(v) => onCountChange({ ...countObj, subtype: v || undefined })}\n                  options={getSubtypeOptions(countObj.kind)}\n                  placeholder=\"Any subtype\"\n                />\n              )}\n            </>\n          )}\n          {countType === \"relationship_count\" && (\n            <ChipSelect\n              label=\"Relationship Kinds\"\n              value={countObj?.relationshipKinds || []}\n              onChange={(v) => onCountChange({ ...countObj, relationshipKinds: v })}\n              options={relationshipKindOptions}\n              placeholder=\"Select relationships...\"\n            />\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div\n      className=\"modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"modal\">\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            <span>{typeConfig?.icon}</span>\n            {factor ? \"Edit Factor\" : \"Add Factor\"}\n            <span\n              className={feedbackType === \"positive\" ? \"fem-feedback-badge-positive\" : \"fem-feedback-badge-negative\"}\n            >\n              {feedbackType === \"positive\" ? \"+ Positive\" : \"- Negative\"}\n            </span>\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n\n        <div className=\"modal-content\">\n          {/* Type selector - compact pills */}\n          <div className=\"mb-2xl\">\n            <span className=\"label\">Factor Type</span>\n            <div className=\"type-selector\">\n              {Object.entries(FACTOR_TYPES).map(([type, config]) => (\n                <div\n                  key={type}\n                  onClick={() => handleTypeChange(type)}\n                  className={`type-pill ${selectedType === type ? \"type-pill-selected\" : \"\"}`}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <span className=\"type-pill-icon\">{config.icon}</span>\n                  <span>{config.label}</span>\n                </div>\n              ))}\n            </div>\n            {typeConfig && <div className=\"type-description\">{typeConfig.description}</div>}\n          </div>\n\n          {/* Type-specific fields */}\n          <div className=\"input-grid\">\n            {/* Entity Count fields */}\n            {selectedType === \"entity_count\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={localFactor.kind || \"\"}\n                  onChange={(v) => updateField(\"kind\", v)}\n                  options={entityKindOptions}\n                  placeholder=\"Select kind...\"\n                />\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Subtype (optional)\"\n                    value={localFactor.subtype || \"\"}\n                    onChange={(v) => updateField(\"subtype\", v || undefined)}\n                    options={getSubtypeOptions(localFactor.kind)}\n                    placeholder=\"Any subtype\"\n                  />\n                )}\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Status (optional)\"\n                    value={localFactor.status || \"\"}\n                    onChange={(v) => updateField(\"status\", v || undefined)}\n                    options={getStatusOptions(localFactor.kind)}\n                    placeholder=\"Any status\"\n                  />\n                )}\n              </>\n            )}\n\n            {/* Relationship Count fields */}\n            {selectedType === \"relationship_count\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Relationship Kinds\"\n                  value={localFactor.relationshipKinds || []}\n                  onChange={(v) => updateField(\"relationshipKinds\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship types...\"\n                />\n              </div>\n            )}\n\n            {/* Tag Count fields */}\n            {selectedType === \"tag_count\" && (\n              <div className=\"grid-col-full\">\n                <label className=\"label\">Tags\n                <TagSelector\n                  value={localFactor.tags || []}\n                  onChange={(v) => updateField(\"tags\", v)}\n                  tagRegistry={schema?.tagRegistry || []}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n            )}\n\n            {/* Status Ratio fields */}\n            {selectedType === \"status_ratio\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity Kind\"\n                  value={localFactor.kind || \"\"}\n                  onChange={(v) => {\n                    updateField(\"kind\", v);\n                    updateField(\"subtype\", undefined);\n                    updateField(\"aliveStatus\", undefined);\n                  }}\n                  options={entityKindOptions}\n                  placeholder=\"Select kind...\"\n                />\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Subtype (optional)\"\n                    value={localFactor.subtype || \"\"}\n                    onChange={(v) => updateField(\"subtype\", v || undefined)}\n                    options={getSubtypeOptions(localFactor.kind)}\n                    placeholder=\"Any subtype\"\n                  />\n                )}\n                {localFactor.kind && (\n                  <ReferenceDropdown\n                    label=\"Alive Status\"\n                    value={localFactor.aliveStatus || \"\"}\n                    onChange={(v) => updateField(\"aliveStatus\", v)}\n                    options={getStatusOptions(localFactor.kind)}\n                    placeholder=\"Select status...\"\n                  />\n                )}\n              </>\n            )}\n\n            {/* Cross-Culture Ratio fields */}\n            {selectedType === \"cross_culture_ratio\" && (\n              <div className=\"grid-col-full\">\n                <ChipSelect\n                  label=\"Relationship Kinds\"\n                  value={localFactor.relationshipKinds || []}\n                  onChange={(v) => updateField(\"relationshipKinds\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship types...\"\n                />\n              </div>\n// ... (truncated)", "parameters": [{"name": "{ isOpen, onClose, factor, onChange, feedbackType, schema }", "type": "{ isOpen: any; onClose: any; factor: any; onChange: any; feedbackType: any; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "ChipSelect"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 2}, {"name": "useCallback", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useRef", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/cards/index.js::SystemListCard", "name": "SystemListCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/cards/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system to display\n * @param {Function} props.onClick - Called when card is clicked\n * @param {Function} props.onToggle - Called to toggle enabled state\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport function SystemListCard({ system, onClick, onToggle, usageMap }) {\n  const config = system.config;\n  const sysId = config.id;\n  const isEnabled = system.enabled !== false;\n  const typeConfig = SYSTEM_TYPES[system.systemType] || {};\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"system\", sysId)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, sysId]\n  );\n\n  const eraUsage = useMemo(() => {\n    if (!usageMap?.systems?.[sysId]) return [];\n    return usageMap.systems[sysId].eras || [];\n  }, [usageMap, sysId]);\n\n  const errorCount = validation.invalidRefs.length;\n  const hasErrors = errorCount > 0;\n  const isOrphan = validation.isOrphan;\n\n  const cardClassName = [\n    \"card card-clickable\",\n    !isEnabled && \"card-disabled\",\n    hasErrors && \"card-error\",\n    isOrphan && !hasErrors && \"card-warning\",\n  ]\n    .filter(Boolean)\n    .join(\" \");\n\n  return (\n    <div className={cardClassName} onClick={onClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }} >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{config.name || config.id}</span>\n            <ErrorBadge count={errorCount} />\n          </div>\n          <div className=\"card-id\">{config.id}</div>\n        </div>\n        <EnableToggle\n          enabled={isEnabled}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n        />\n      </div>\n\n      <div className=\"card-badges\">\n        {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color from config */}\n        <span\n          className=\"type-badge\"\n          style={{ '--slc-type-bg': `${typeConfig.color}30`, '--slc-type-color': typeConfig.color, backgroundColor: 'var(--slc-type-bg)', color: 'var(--slc-type-color)' }}\n        >\n          {typeConfig.icon} {typeConfig.label}\n        </span>\n      </div>\n\n      {config.description && <div className=\"card-desc\">{config.description}</div>}\n\n      <EraBadges eras={eraUsage} />\n      {isOrphan && (\n        <div className=\"mt-md\">\n          <OrphanBadge isOrphan={isOrphan} />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onClick, onToggle, usageMap }", "type": "{ system: any; onClick: Function; onToggle: Function; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "ErrorBadge", "div", "EnableToggle", "EraBadges", "OrphanBadge"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/cards/SystemListCard.jsx::SystemListCard", "name": "SystemListCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/cards/SystemListCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system to display\n * @param {Function} props.onClick - Called when card is clicked\n * @param {Function} props.onToggle - Called to toggle enabled state\n * @param {Object} props.usageMap - Schema usage map for validation\n */\nexport function SystemListCard({ system, onClick, onToggle, usageMap }) {\n  const config = system.config;\n  const sysId = config.id;\n  const isEnabled = system.enabled !== false;\n  const typeConfig = SYSTEM_TYPES[system.systemType] || {};\n\n  // Get validation and usage info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"system\", sysId)\n        : { invalidRefs: [], isOrphan: false },\n    [usageMap, sysId]\n  );\n\n  const eraUsage = useMemo(() => {\n    if (!usageMap?.systems?.[sysId]) return [];\n    return usageMap.systems[sysId].eras || [];\n  }, [usageMap, sysId]);\n\n  const errorCount = validation.invalidRefs.length;\n  const hasErrors = errorCount > 0;\n  const isOrphan = validation.isOrphan;\n\n  const cardClassName = [\n    \"card card-clickable\",\n    !isEnabled && \"card-disabled\",\n    hasErrors && \"card-error\",\n    isOrphan && !hasErrors && \"card-warning\",\n  ]\n    .filter(Boolean)\n    .join(\" \");\n\n  return (\n    <div className={cardClassName} onClick={onClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }} >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{config.name || config.id}</span>\n            <ErrorBadge count={errorCount} />\n          </div>\n          <div className=\"card-id\">{config.id}</div>\n        </div>\n        <EnableToggle\n          enabled={isEnabled}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n        />\n      </div>\n\n      <div className=\"card-badges\">\n        {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color from config */}\n        <span\n          className=\"type-badge\"\n          style={{ '--slc-type-bg': `${typeConfig.color}30`, '--slc-type-color': typeConfig.color, backgroundColor: 'var(--slc-type-bg)', color: 'var(--slc-type-color)' }}\n        >\n          {typeConfig.icon} {typeConfig.label}\n        </span>\n      </div>\n\n      {config.description && <div className=\"card-desc\">{config.description}</div>}\n\n      <EraBadges eras={eraUsage} />\n      {isOrphan && (\n        <div className=\"mt-md\">\n          <OrphanBadge isOrphan={isOrphan} />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onClick, onToggle, usageMap }", "type": "{ system: any; onClick: Function; onToggle: Function; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "ErrorBadge", "div", "EnableToggle", "EraBadges", "OrphanBadge"], "hookCalls": [{"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["SYSTEM_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ErrorBadge", "OrphanBadge", "EraBadges", "EnableToggle"], "category": "internal"}, {"source": "../../shared", "specifiers": ["getElementValidation"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/ClusterFormationTab.jsx::ClusterFormationTab", "name": "ClusterFormationTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/ClusterFormationTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function ClusterFormationTab({ system, onChange, schema }) {\n  const config = system.config;\n\n  const entityKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateClustering = (field, value) => {\n    updateConfig(\"clustering\", { ...config.clustering, [field]: value });\n  };\n\n  const updateMetaEntity = (field, value) => {\n    updateConfig(\"metaEntity\", { ...config.metaEntity, [field]: value });\n  };\n\n  // Criteria\n  const criteria = config.clustering?.criteria || [];\n\n  const addCriterion = () => {\n    updateClustering(\"criteria\", [...criteria, { type: \"same_culture\", weight: 1.0 }]);\n  };\n\n  const updateCriterion = (index, crit) => {\n    const newCriteria = [...criteria];\n    newCriteria[index] = crit;\n    updateClustering(\"criteria\", newCriteria);\n  };\n\n  const removeCriterion = (index) => {\n    updateClustering(\n      \"criteria\",\n      criteria.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Clustering Configuration</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Min Size\n            <NumberInput\n              value={config.clustering?.minSize}\n              onChange={(v) => updateClustering(\"minSize\", v)}\n              min={2}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Size\n            <NumberInput\n              value={config.clustering?.maxSize}\n              onChange={(v) => updateClustering(\"maxSize\", v)}\n              min={2}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Minimum Score\n            <NumberInput\n              value={config.clustering?.minimumScore}\n              onChange={(v) => updateClustering(\"minimumScore\", v)}\n              min={0}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Clustering Criteria ({criteria.length})</label>\n        </div>\n\n        {criteria.map((crit, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Type\"\n                    value={crit.type}\n                    onChange={(v) => updateCriterion(index, { ...crit, type: v })}\n                    options={CLUSTERING_CRITERIA_TYPES}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Weight\n                    <NumberInput\n                      value={crit.weight}\n                      onChange={(v) => updateCriterion(index, { ...crit, weight: v ?? 0 })}\n                      min={0}\n                    />\n                    </label>\n                  </div>\n                  {crit.type === \"shared_relationship\" && (\n                    <ReferenceDropdown\n                      label=\"Relationship Kind\"\n                      value={crit.relationshipKind}\n                      onChange={(v) => updateCriterion(index, { ...crit, relationshipKind: v })}\n                      options={relationshipKindOptions}\n                    />\n                  )}\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeCriterion(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addCriterion}>\n          + Add Criterion\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Meta Entity</div>\n        <div className=\"section-desc\">Configuration for the meta-entity created from clusters.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Kind\"\n            value={config.metaEntity?.kind}\n            onChange={(v) => updateMetaEntity(\"kind\", v)}\n            options={entityKindOptions}\n          />\n          <div className=\"form-group\">\n            <label htmlFor=\"status\" className=\"label\">Status</label>\n            <input id=\"status\"\n              type=\"text\"\n              value={config.metaEntity?.status || \"\"}\n              onChange={(e) => updateMetaEntity(\"status\", e.target.value)}\n              className=\"input\"\n            />\n          </div>\n        </div>\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Description Template\n            <LocalTextArea\n              value={config.metaEntity?.descriptionTemplate || \"\"}\n              onChange={(value) => updateMetaEntity(\"descriptionTemplate\", value)}\n              placeholder=\"Use {names}, {count} placeholders\"\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Narration Template</div>\n        <div className=\"section-desc mb-md text-xs\">\n          Syntax: {\"{list:members}\"}, {\"{count}\"}, {\"{field|fallback}\"}.\n        </div>\n        <LocalTextArea\n          value={config.narrationTemplate || \"\"}\n          onChange={(value) => updateConfig(\"narrationTemplate\", value || undefined)}\n          placeholder=\"e.g., {list:members} united to form a new alliance.\"\n          rows={2}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "NumberInput", "label", "ReferenceDropdown", "button", "input", "LocalTextArea"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["CLUSTERING_CRITERIA_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput", "LocalTextArea"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/CommonSettingsTab.jsx::CommonSettingsTab", "name": "CommonSettingsTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/CommonSettingsTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n */\nexport function CommonSettingsTab({ system, onChange, schema, pressures }) {\n  const config = system.config;\n  const selection = config.selection || DEFAULT_SELECTION;\n  const supportsSelection = [\n    \"graphContagion\",\n    \"connectionEvolution\",\n    \"thresholdTrigger\",\n    \"clusterFormation\",\n    \"tagDiffusion\",\n    \"planeDiffusion\",\n  ].includes(system.systemType);\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  return (\n    <div>\n      {supportsSelection && (\n        <div className=\"section\">\n          <div className=\"section-title\">Entity Selection</div>\n          <div className=\"section-desc\">Define which entities this system operates on.</div>\n          <SelectionRuleEditor\n            value={selection}\n            onChange={(next) => updateConfig(\"selection\", next)}\n            schema={schema}\n            availableRefs={[]}\n            showPickStrategy={false}\n            showMaxResults={false}\n            showFilters\n            allowAnyKind\n            showExcludeSubtypes\n          />\n        </div>\n      )}\n\n      <div className=\"section\">\n        <div className=\"section-title\">Throttling</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Throttle Chance (0-1)\n            <NumberInput\n              value={config.throttleChance}\n              onChange={(v) => updateConfig(\"throttleChance\", v)}\n              className=\"input\"\n              min={0}\n              max={1}\n              step={0.1}\n              placeholder=\"0.2\"\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Cooldown (ticks)\n            <NumberInput\n              value={config.cooldown}\n              onChange={(v) => updateConfig(\"cooldown\", v)}\n              className=\"input\"\n              min={0}\n              placeholder=\"0\"\n              allowEmpty\n              integer\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <PressureChangesEditor\n          value={config.pressureChanges || EMPTY_PRESSURE_CHANGES}\n          onChange={(v) =>\n            updateConfig(\"pressureChanges\", Object.keys(v).length > 0 ? v : undefined)\n          }\n          pressures={pressures}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema, pressures }", "type": "{ system: any; onChange: Function; schema: any; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "SelectionRuleEditor", "NumberInput", "PressureChangesEditor"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["PressureChangesEditor", "NumberInput"], "category": "internal"}, {"source": "../../shared/SelectionRuleEditor", "specifiers": ["SelectionRuleEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/ConnectionEvolutionTab.jsx::ConnectionEvolutionTab", "name": "ConnectionEvolutionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/ConnectionEvolutionTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function ConnectionEvolutionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const selectionKind =\n    config.selection?.kind && config.selection.kind !== \"any\" ? config.selection.kind : undefined;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    if (!kind) return [];\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateMetric = (field, value) => {\n    updateConfig(\"metric\", { ...config.metric, [field]: value });\n  };\n\n  // Rules\n  const rules = config.rules || [];\n\n  const addRule = () => {\n    updateConfig(\"rules\", [\n      ...rules,\n      {\n        condition: { operator: \">=\", threshold: 1 },\n        probability: 0.1,\n        action: { type: \"adjust_prominence\", entity: \"$self\", delta: 0.2 },\n      },\n    ]);\n  };\n\n  const updateRule = (index, rule) => {\n    const newRules = [...rules];\n    newRules[index] = rule;\n    updateConfig(\"rules\", newRules);\n  };\n\n  const removeRule = (index) => {\n    updateConfig(\n      \"rules\",\n      rules.filter((_, i) => i !== index)\n    );\n  };\n\n  // Subtype bonuses\n  const subtypeBonuses = config.subtypeBonuses || [];\n\n  const addSubtypeBonus = () => {\n    updateConfig(\"subtypeBonuses\", [...subtypeBonuses, { subtype: \"\", bonus: 0 }]);\n  };\n\n  const updateSubtypeBonus = (index, bonus) => {\n    const newBonuses = [...subtypeBonuses];\n    newBonuses[index] = bonus;\n    updateConfig(\"subtypeBonuses\", newBonuses);\n  };\n\n  const removeSubtypeBonus = (index) => {\n    updateConfig(\n      \"subtypeBonuses\",\n      subtypeBonuses.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Metric</div>\n        <div className=\"section-desc\">How entities are measured for rule evaluation.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Metric Type\"\n            value={config.metric?.type || \"connection_count\"}\n            onChange={(v) => updateMetric(\"type\", v)}\n            options={METRIC_TYPES}\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={config.metric?.direction || \"both\"}\n            onChange={(v) => updateMetric(\"direction\", v)}\n            options={DIRECTIONS}\n          />\n          {(config.metric?.type === \"connection_count\" ||\n            config.metric?.type === \"relationship_count\") && (\n            <div className=\"form-group\">\n              <label htmlFor=\"filter-by-relationship-kinds-optional\" className=\"label\">Filter by Relationship Kinds (optional)</label>\n              <input id=\"filter-by-relationship-kinds-optional\"\n                type=\"text\"\n                value={(config.metric?.relationshipKinds || []).join(\", \")}\n                onChange={(e) => {\n                  const kinds = e.target.value\n                    .split(\",\")\n                    .map((s) => s.trim())\n                    .filter(Boolean);\n                  updateMetric(\"relationshipKinds\", kinds.length > 0 ? kinds : undefined);\n                }}\n                className=\"input\"\n                placeholder=\"Leave empty for all kinds\"\n              />\n            </div>\n          )}\n          {config.metric?.type === \"shared_relationship\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Shared Relationship Kind\"\n                value={config.metric?.sharedRelationshipKind}\n                onChange={(v) => updateMetric(\"sharedRelationshipKind\", v)}\n                options={relationshipKindOptions}\n              />\n              <ReferenceDropdown\n                label=\"Shared Direction\"\n                value={config.metric?.sharedDirection || \"src\"}\n                onChange={(v) => updateMetric(\"sharedDirection\", v)}\n                options={[\n                  { value: \"src\", label: \"Source (outgoing)\" },\n                  { value: \"dst\", label: \"Destination (incoming)\" },\n                ]}\n              />\n            </>\n          )}\n          <div className=\"form-group\">\n            <label className=\"label\">Min Strength\n            <NumberInput\n              value={config.metric?.minStrength}\n              onChange={(v) => updateMetric(\"minStrength\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n              placeholder=\"0\"\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Rules ({rules.length})</div>\n        <div className=\"section-desc\">Conditions and actions based on the metric.</div>\n\n        {rules.map((rule, index) => (\n          <RuleCard\n            key={index}\n            rule={rule}\n            onChange={(r) => updateRule(index, r)}\n            onRemove={() => removeRule(index)}\n            schema={schema}\n          />\n        ))}\n\n        <button className=\"btn-add\" onClick={addRule}>\n          + Add Rule\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Subtype Bonuses ({subtypeBonuses.length})</div>\n        <div className=\"section-desc\">Bonuses added to metric value based on entity subtype.</div>\n\n        {subtypeBonuses.map((bonus, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Subtype\"\n                    value={bonus.subtype}\n                    onChange={(v) => updateSubtypeBonus(index, { ...bonus, subtype: v })}\n                    options={getSubtypeOptions(selectionKind)}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Bonus\n                    <NumberInput\n                      value={bonus.bonus}\n                      onChange={(v) => updateSubtypeBonus(index, { ...bonus, bonus: v ?? 0 })}\n                    />\n                    </label>\n                  </div>\n                </div>\n                <button\n                  className=\"btn-icon btn-icon-danger\"\n                  onClick={() => removeSubtypeBonus(index)}\n                >\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addSubtypeBonus}>\n          + Add Subtype Bonus\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "label", "input", "NumberInput", "RuleCard", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["METRIC_TYPES", "DIRECTIONS"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput", "LocalTextArea"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "./ConnectionEvolutionTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/FrameworkSystemTab.jsx::FrameworkSystemTab", "name": "FrameworkSystemTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/FrameworkSystemTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n */\nexport function FrameworkSystemTab({ system, onChange }) {\n  const config = system.config;\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  return (\n    <div>\n      <div className=\"info-box\">\n        <div className=\"info-box-title\">Framework System</div>\n        <div className=\"info-box-text\">\n          This is a framework-level system with specific configuration options.\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Configuration</div>\n\n        {system.systemType === \"eraTransition\" && (\n          <div className=\"form-grid\">\n            <p className=\"label grid-col-full text-dim\">\n              Era transition timing is controlled by per-era exitConditions in eras.json. Add a time\n              condition (e.g., {`{ type: 'time_elapsed', minTicks: 25 }`}) to control minimum era\n              length.\n            </p>\n          </div>\n        )}\n\n        {system.systemType === \"universalCatalyst\" && (\n          <div className=\"form-grid\">\n            <div className=\"form-group\">\n              <label className=\"label\">Action Attempt Rate\n              <NumberInput\n                value={config.actionAttemptRate}\n                onChange={(v) => updateConfig(\"actionAttemptRate\", v)}\n                className=\"input\"\n                step={0.1}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Pressure Multiplier\n              <NumberInput\n                value={config.pressureMultiplier}\n                onChange={(v) => updateConfig(\"pressureMultiplier\", v)}\n                className=\"input\"\n                step={0.1}\n                min={0}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Prominence Up % on Success\n              <NumberInput\n                value={config.prominenceUpChanceOnSuccess}\n                onChange={(v) => updateConfig(\"prominenceUpChanceOnSuccess\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Prominence Down % on Failure\n              <NumberInput\n                value={config.prominenceDownChanceOnFailure}\n                onChange={(v) => updateConfig(\"prominenceDownChanceOnFailure\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n          </div>\n        )}\n\n        {system.systemType === \"relationshipMaintenance\" && (\n          <div className=\"form-grid\">\n            <div className=\"form-group\">\n              <label className=\"label\">Maintenance Frequency\n              <NumberInput\n                value={config.maintenanceFrequency}\n                onChange={(v) => updateConfig(\"maintenanceFrequency\", v)}\n                className=\"input\"\n                min={1}\n                allowEmpty\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Cull Threshold\n              <NumberInput\n                value={config.cullThreshold}\n                onChange={(v) => updateConfig(\"cullThreshold\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Grace Period\n              <NumberInput\n                value={config.gracePeriod}\n                onChange={(v) => updateConfig(\"gracePeriod\", v)}\n                className=\"input\"\n                min={0}\n                allowEmpty\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Reinforcement Bonus\n              <NumberInput\n                value={config.reinforcementBonus}\n                onChange={(v) => updateConfig(\"reinforcementBonus\", v)}\n                className=\"input\"\n                step={0.01}\n                min={0}\n                allowEmpty\n              />\n              </label>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange }", "type": "{ system: any; onChange: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "p", "NumberInput"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["NumberInput"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/GraphContagionTab.jsx::GraphContagionTab", "name": "GraphContagionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/GraphContagionTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function GraphContagionTab({ system, onChange, schema }) {\n  const config = system.config;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateContagion = (field, value) => {\n    updateConfig(\"contagion\", { ...config.contagion, [field]: value });\n  };\n\n  const updateTransmission = (field, value) => {\n    updateConfig(\"transmission\", { ...config.transmission, [field]: value });\n  };\n\n  const updateInfectionAction = (field, value) => {\n    updateConfig(\"infectionAction\", { ...config.infectionAction, [field]: value });\n  };\n\n  // Vectors\n  const vectors = config.vectors || [];\n\n  const addVector = () => {\n    updateConfig(\"vectors\", [\n      ...vectors,\n      { relationshipKind: \"\", direction: \"both\", minStrength: 0.5 },\n    ]);\n  };\n\n  const updateVector = (index, field, value) => {\n    const newVectors = [...vectors];\n    newVectors[index] = { ...newVectors[index], [field]: value };\n    updateConfig(\"vectors\", newVectors);\n  };\n\n  const removeVector = (index) => {\n    updateConfig(\n      \"vectors\",\n      vectors.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Contagion Source</div>\n        <div className=\"section-desc\">What is being spread through the network.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Type\"\n            value={config.contagion?.type || \"relationship\"}\n            onChange={(v) => updateContagion(\"type\", v)}\n            options={[\n              { value: \"relationship\", label: \"Relationship\" },\n              { value: \"tag\", label: \"Tag\" },\n            ]}\n          />\n          {config.contagion?.type === \"relationship\" && (\n            <ReferenceDropdown\n              label=\"Relationship Kind\"\n              value={config.contagion?.relationshipKind}\n              onChange={(v) => updateContagion(\"relationshipKind\", v)}\n              options={relationshipKindOptions}\n            />\n          )}\n          {config.contagion?.type === \"tag\" && (\n            <div className=\"form-group\">\n              <label htmlFor=\"tag\" className=\"label\">Tag</label>\n              <input id=\"tag\"\n                type=\"text\"\n                value={config.contagion?.tagPattern || \"\"}\n                onChange={(e) => updateContagion(\"tagPattern\", e.target.value)}\n                className=\"input\"\n              />\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Transmission Vectors ({vectors.length})</div>\n        <div className=\"section-desc\">Relationships through which the contagion spreads.</div>\n\n        {vectors.map((vector, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"p-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Relationship Kind\"\n                    value={vector.relationshipKind}\n                    onChange={(v) => updateVector(index, \"relationshipKind\", v)}\n                    options={relationshipKindOptions}\n                  />\n                  <ReferenceDropdown\n                    label=\"Direction\"\n                    value={vector.direction || \"both\"}\n                    onChange={(v) => updateVector(index, \"direction\", v)}\n                    options={DIRECTIONS}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Min Strength\n                    <NumberInput\n                      value={vector.minStrength}\n                      onChange={(v) => updateVector(index, \"minStrength\", v)}\n                      className=\"input\"\n                      step={0.1}\n                      min={0}\n                      max={1}\n                      allowEmpty\n                    />\n                    </label>\n                  </div>\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeVector(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addVector}>\n          + Add Vector\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Transmission Rates</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Base Rate\n            <NumberInput\n              value={config.transmission?.baseRate}\n              onChange={(v) => updateTransmission(\"baseRate\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Contact Multiplier\n            <NumberInput\n              value={config.transmission?.contactMultiplier}\n              onChange={(v) => updateTransmission(\"contactMultiplier\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Probability\n            <NumberInput\n              value={config.transmission?.maxProbability}\n              onChange={(v) => updateTransmission(\"maxProbability\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Infection Action</div>\n        <div className=\"section-desc\">What happens when an entity gets infected.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Action Type\"\n            value={config.infectionAction?.type || \"create_relationship\"}\n            onChange={(v) => updateInfectionAction(\"type\", v)}\n            options={[\n              { value: \"create_relationship\", label: \"Create Relationship\" },\n              { value: \"set_tag\", label: \"Set Tag\" },\n            ]}\n          />\n          {config.infectionAction?.type === \"create_relationship\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Relationship Kind\"\n                value={config.infectionAction?.kind}\n                onChange={(v) => updateInfectionAction(\"kind\", v)}\n                options={relationshipKindOptions}\n              />\n              <ReferenceDropdown\n                label=\"Source\"\n                value={config.infectionAction?.src || \"$self\"}\n                onChange={(v) => updateInfectionAction(\"src\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <ReferenceDropdown\n                label=\"Destination\"\n                value={config.infectionAction?.dst || \"$source\"}\n                onChange={(v) => updateInfectionAction(\"dst\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <div className=\"form-group\">\n                <label className=\"label\">Strength\n                <NumberInput\n                  value={config.infectionAction?.strength}\n                  onChange={(v) => updateInfectionAction(\"strength\", v)}\n                  className=\"input\"\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  allowEmpty\n                />\n                </label>\n              </div>\n              <div className=\"form-group\">\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={config.infectionAction?.bidirectional || false}\n                    onChange={(e) =>\n                      updateInfectionAction(\"bidirectional\", e.target.checked || undefined)\n                    }\n                    className=\"checkbox\"\n                  />\n                  Bidirectional\n                </label>\n              </div>\n            </>\n          )}\n          {config.infectionAction?.type === \"set_tag\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Entity\"\n                value={config.infectionAction?.entity || \"$self\"}\n                onChange={(v) => updateInfectionAction(\"entity\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <div className=\"form-group\">\n                <label className=\"label\">Tag\n                <TagSelector\n                  value={config.infectionAction?.tag ? [config.infectionAction.tag] : []}\n                  onChange={(tags) => updateInfectionAction(\"tag\", tags[0] || \"\")}\n                  tagRegistry={schema?.tagRegistry || []}\n                  placeholder=\"Select tag...\"\n                  singleSelect\n                />\n                </label>\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"value-optional\" className=\"label\">Value (optional)</label>\n                <input id=\"value-optional\"\n                  type=\"text\"\n                  value={\n                    config.infectionAction?.value !== undefined\n                      ? String(config.infectionAction.value)\n                      : \"\"\n                  }\n                  onChange={(e) => updateInfectionAction(\"value\", e.target.value || undefined)}\n                  className=\"input\"\n                  placeholder=\"true\"\n                />\n              </div>\n            </>\n          )}\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">Narration Template</span>\n          <div className=\"section-desc mb-xs text-xs\">\n            Syntax: {\"{$self.field}\"}, {\"{$source.field}\"}, {\"{$contagion_source.field}\"},{\" \"}\n            {\"{field|fallback}\"}.\n          </div>\n          <LocalTextArea\n            value={config.narrationTemplate || \"\"}\n// ... (truncated)", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "label", "input", "NumberInput", "button", "TagSelector", "span", "LocalTextArea"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["DIRECTIONS"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput", "LocalTextArea"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::OverviewTab", "name": "OverviewTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Function} props.onDelete - Called to delete the system\n */\nexport function OverviewTab({ system, onChange, onDelete }) {\n  const config = system.config;\n  const typeConfig = SYSTEM_TYPES[system.systemType] || {};\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(config.id, (value) =>\n    updateConfig(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(config.name, (value) =>\n    updateConfig(\"name\", value)\n  );\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Basic Information</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label htmlFor=\"system-id\" className=\"label\">System ID</label>\n            <input id=\"system-id\"\n              type=\"text\"\n              value={localId}\n              onChange={(e) => setLocalId(e.target.value)}\n              onBlur={handleIdBlur}\n              className=\"input\"\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"display-name\" className=\"label\">Display Name</label>\n            <input id=\"display-name\"\n              type=\"text\"\n              value={localName}\n              onChange={(e) => setLocalName(e.target.value)}\n              onBlur={handleNameBlur}\n              className=\"input\"\n            />\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Description\n            <LocalTextArea\n              value={config.description || \"\"}\n              onChange={(value) => updateConfig(\"description\", value)}\n              className=\"ot-description-textarea\"\n              placeholder=\"Describe what this system does...\"\n            />\n            </label>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">System Type</span>\n          <div className=\"flex items-center gap-lg\">\n            {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color from config */}\n            <span\n              className=\"type-badge\"\n              style={{ '--ot-type-bg': `${typeConfig.color}30`, '--ot-type-color': typeConfig.color, backgroundColor: 'var(--ot-type-bg)', color: 'var(--ot-type-color)' }}\n            >\n              {typeConfig.icon} {typeConfig.label}\n            </span>\n            <span className=\"text-muted ot-type-desc\">\n              {typeConfig.desc}\n            </span>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Enabled\n          <EnableToggle\n            enabled={system.enabled !== false}\n            onChange={(enabled) => onChange({ ...system, enabled })}\n            label={system.enabled !== false ? \"System is active\" : \"System is disabled\"}\n          />\n          </label>\n        </div>\n      </div>\n\n      <div className=\"danger-zone\">\n        <button className=\"btn btn-danger\" onClick={onDelete}>\n          Delete System\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, onDelete }", "type": "{ system: any; onChange: Function; onDelete: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "label", "input", "LocalTextArea", "span", "EnableToggle", "button"], "hookCalls": [{"name": "useLocalInputState", "count": 2}], "customHookCalls": ["useLocalInputState"], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::CommonSettingsTab", "name": "CommonSettingsTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n */\nexport function CommonSettingsTab({ system, onChange, schema, pressures }) {\n  const config = system.config;\n  const selection = config.selection || DEFAULT_SELECTION;\n  const supportsSelection = [\n    \"graphContagion\",\n    \"connectionEvolution\",\n    \"thresholdTrigger\",\n    \"clusterFormation\",\n    \"tagDiffusion\",\n    \"planeDiffusion\",\n  ].includes(system.systemType);\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  return (\n    <div>\n      {supportsSelection && (\n        <div className=\"section\">\n          <div className=\"section-title\">Entity Selection</div>\n          <div className=\"section-desc\">Define which entities this system operates on.</div>\n          <SelectionRuleEditor\n            value={selection}\n            onChange={(next) => updateConfig(\"selection\", next)}\n            schema={schema}\n            availableRefs={[]}\n            showPickStrategy={false}\n            showMaxResults={false}\n            showFilters\n            allowAnyKind\n            showExcludeSubtypes\n          />\n        </div>\n      )}\n\n      <div className=\"section\">\n        <div className=\"section-title\">Throttling</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Throttle Chance (0-1)\n            <NumberInput\n              value={config.throttleChance}\n              onChange={(v) => updateConfig(\"throttleChance\", v)}\n              className=\"input\"\n              min={0}\n              max={1}\n              step={0.1}\n              placeholder=\"0.2\"\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Cooldown (ticks)\n            <NumberInput\n              value={config.cooldown}\n              onChange={(v) => updateConfig(\"cooldown\", v)}\n              className=\"input\"\n              min={0}\n              placeholder=\"0\"\n              allowEmpty\n              integer\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <PressureChangesEditor\n          value={config.pressureChanges || EMPTY_PRESSURE_CHANGES}\n          onChange={(v) =>\n            updateConfig(\"pressureChanges\", Object.keys(v).length > 0 ? v : undefined)\n          }\n          pressures={pressures}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema, pressures }", "type": "{ system: any; onChange: Function; schema: any; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "SelectionRuleEditor", "NumberInput", "PressureChangesEditor"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::GraphContagionTab", "name": "GraphContagionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function GraphContagionTab({ system, onChange, schema }) {\n  const config = system.config;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateContagion = (field, value) => {\n    updateConfig(\"contagion\", { ...config.contagion, [field]: value });\n  };\n\n  const updateTransmission = (field, value) => {\n    updateConfig(\"transmission\", { ...config.transmission, [field]: value });\n  };\n\n  const updateInfectionAction = (field, value) => {\n    updateConfig(\"infectionAction\", { ...config.infectionAction, [field]: value });\n  };\n\n  // Vectors\n  const vectors = config.vectors || [];\n\n  const addVector = () => {\n    updateConfig(\"vectors\", [\n      ...vectors,\n      { relationshipKind: \"\", direction: \"both\", minStrength: 0.5 },\n    ]);\n  };\n\n  const updateVector = (index, field, value) => {\n    const newVectors = [...vectors];\n    newVectors[index] = { ...newVectors[index], [field]: value };\n    updateConfig(\"vectors\", newVectors);\n  };\n\n  const removeVector = (index) => {\n    updateConfig(\n      \"vectors\",\n      vectors.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Contagion Source</div>\n        <div className=\"section-desc\">What is being spread through the network.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Type\"\n            value={config.contagion?.type || \"relationship\"}\n            onChange={(v) => updateContagion(\"type\", v)}\n            options={[\n              { value: \"relationship\", label: \"Relationship\" },\n              { value: \"tag\", label: \"Tag\" },\n            ]}\n          />\n          {config.contagion?.type === \"relationship\" && (\n            <ReferenceDropdown\n              label=\"Relationship Kind\"\n              value={config.contagion?.relationshipKind}\n              onChange={(v) => updateContagion(\"relationshipKind\", v)}\n              options={relationshipKindOptions}\n            />\n          )}\n          {config.contagion?.type === \"tag\" && (\n            <div className=\"form-group\">\n              <label htmlFor=\"tag\" className=\"label\">Tag</label>\n              <input id=\"tag\"\n                type=\"text\"\n                value={config.contagion?.tagPattern || \"\"}\n                onChange={(e) => updateContagion(\"tagPattern\", e.target.value)}\n                className=\"input\"\n              />\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Transmission Vectors ({vectors.length})</div>\n        <div className=\"section-desc\">Relationships through which the contagion spreads.</div>\n\n        {vectors.map((vector, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"p-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Relationship Kind\"\n                    value={vector.relationshipKind}\n                    onChange={(v) => updateVector(index, \"relationshipKind\", v)}\n                    options={relationshipKindOptions}\n                  />\n                  <ReferenceDropdown\n                    label=\"Direction\"\n                    value={vector.direction || \"both\"}\n                    onChange={(v) => updateVector(index, \"direction\", v)}\n                    options={DIRECTIONS}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Min Strength\n                    <NumberInput\n                      value={vector.minStrength}\n                      onChange={(v) => updateVector(index, \"minStrength\", v)}\n                      className=\"input\"\n                      step={0.1}\n                      min={0}\n                      max={1}\n                      allowEmpty\n                    />\n                    </label>\n                  </div>\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeVector(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addVector}>\n          + Add Vector\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Transmission Rates</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Base Rate\n            <NumberInput\n              value={config.transmission?.baseRate}\n              onChange={(v) => updateTransmission(\"baseRate\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Contact Multiplier\n            <NumberInput\n              value={config.transmission?.contactMultiplier}\n              onChange={(v) => updateTransmission(\"contactMultiplier\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Probability\n            <NumberInput\n              value={config.transmission?.maxProbability}\n              onChange={(v) => updateTransmission(\"maxProbability\", v)}\n              className=\"input\"\n              step={0.05}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Infection Action</div>\n        <div className=\"section-desc\">What happens when an entity gets infected.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Action Type\"\n            value={config.infectionAction?.type || \"create_relationship\"}\n            onChange={(v) => updateInfectionAction(\"type\", v)}\n            options={[\n              { value: \"create_relationship\", label: \"Create Relationship\" },\n              { value: \"set_tag\", label: \"Set Tag\" },\n            ]}\n          />\n          {config.infectionAction?.type === \"create_relationship\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Relationship Kind\"\n                value={config.infectionAction?.kind}\n                onChange={(v) => updateInfectionAction(\"kind\", v)}\n                options={relationshipKindOptions}\n              />\n              <ReferenceDropdown\n                label=\"Source\"\n                value={config.infectionAction?.src || \"$self\"}\n                onChange={(v) => updateInfectionAction(\"src\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <ReferenceDropdown\n                label=\"Destination\"\n                value={config.infectionAction?.dst || \"$source\"}\n                onChange={(v) => updateInfectionAction(\"dst\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <div className=\"form-group\">\n                <label className=\"label\">Strength\n                <NumberInput\n                  value={config.infectionAction?.strength}\n                  onChange={(v) => updateInfectionAction(\"strength\", v)}\n                  className=\"input\"\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  allowEmpty\n                />\n                </label>\n              </div>\n              <div className=\"form-group\">\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={config.infectionAction?.bidirectional || false}\n                    onChange={(e) =>\n                      updateInfectionAction(\"bidirectional\", e.target.checked || undefined)\n                    }\n                    className=\"checkbox\"\n                  />\n                  Bidirectional\n                </label>\n              </div>\n            </>\n          )}\n          {config.infectionAction?.type === \"set_tag\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Entity\"\n                value={config.infectionAction?.entity || \"$self\"}\n                onChange={(v) => updateInfectionAction(\"entity\", v)}\n                options={[\n                  { value: \"$self\", label: \"$self\" },\n                  { value: \"$source\", label: \"$source\" },\n                  { value: \"$contagion_source\", label: \"$contagion_source\" },\n                ]}\n              />\n              <div className=\"form-group\">\n                <label className=\"label\">Tag\n                <TagSelector\n                  value={config.infectionAction?.tag ? [config.infectionAction.tag] : []}\n                  onChange={(tags) => updateInfectionAction(\"tag\", tags[0] || \"\")}\n                  tagRegistry={schema?.tagRegistry || []}\n                  placeholder=\"Select tag...\"\n                  singleSelect\n                />\n                </label>\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"value-optional\" className=\"label\">Value (optional)</label>\n                <input id=\"value-optional\"\n                  type=\"text\"\n                  value={\n                    config.infectionAction?.value !== undefined\n                      ? String(config.infectionAction.value)\n                      : \"\"\n                  }\n                  onChange={(e) => updateInfectionAction(\"value\", e.target.value || undefined)}\n                  className=\"input\"\n                  placeholder=\"true\"\n                />\n              </div>\n            </>\n          )}\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">Narration Template</span>\n          <div className=\"section-desc mb-xs text-xs\">\n            Syntax: {\"{$self.field}\"}, {\"{$source.field}\"}, {\"{$contagion_source.field}\"},{\" \"}\n            {\"{field|fallback}\"}.\n          </div>\n          <LocalTextArea\n            value={config.narrationTemplate || \"\"}\n// ... (truncated)", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "label", "input", "NumberInput", "button", "TagSelector", "span", "LocalTextArea"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::ConnectionEvolutionTab", "name": "ConnectionEvolutionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function ConnectionEvolutionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const selectionKind =\n    config.selection?.kind && config.selection.kind !== \"any\" ? config.selection.kind : undefined;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    if (!kind) return [];\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateMetric = (field, value) => {\n    updateConfig(\"metric\", { ...config.metric, [field]: value });\n  };\n\n  // Rules\n  const rules = config.rules || [];\n\n  const addRule = () => {\n    updateConfig(\"rules\", [\n      ...rules,\n      {\n        condition: { operator: \">=\", threshold: 1 },\n        probability: 0.1,\n        action: { type: \"adjust_prominence\", entity: \"$self\", delta: 0.2 },\n      },\n    ]);\n  };\n\n  const updateRule = (index, rule) => {\n    const newRules = [...rules];\n    newRules[index] = rule;\n    updateConfig(\"rules\", newRules);\n  };\n\n  const removeRule = (index) => {\n    updateConfig(\n      \"rules\",\n      rules.filter((_, i) => i !== index)\n    );\n  };\n\n  // Subtype bonuses\n  const subtypeBonuses = config.subtypeBonuses || [];\n\n  const addSubtypeBonus = () => {\n    updateConfig(\"subtypeBonuses\", [...subtypeBonuses, { subtype: \"\", bonus: 0 }]);\n  };\n\n  const updateSubtypeBonus = (index, bonus) => {\n    const newBonuses = [...subtypeBonuses];\n    newBonuses[index] = bonus;\n    updateConfig(\"subtypeBonuses\", newBonuses);\n  };\n\n  const removeSubtypeBonus = (index) => {\n    updateConfig(\n      \"subtypeBonuses\",\n      subtypeBonuses.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Metric</div>\n        <div className=\"section-desc\">How entities are measured for rule evaluation.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Metric Type\"\n            value={config.metric?.type || \"connection_count\"}\n            onChange={(v) => updateMetric(\"type\", v)}\n            options={METRIC_TYPES}\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={config.metric?.direction || \"both\"}\n            onChange={(v) => updateMetric(\"direction\", v)}\n            options={DIRECTIONS}\n          />\n          {(config.metric?.type === \"connection_count\" ||\n            config.metric?.type === \"relationship_count\") && (\n            <div className=\"form-group\">\n              <label htmlFor=\"filter-by-relationship-kinds-optional\" className=\"label\">Filter by Relationship Kinds (optional)</label>\n              <input id=\"filter-by-relationship-kinds-optional\"\n                type=\"text\"\n                value={(config.metric?.relationshipKinds || []).join(\", \")}\n                onChange={(e) => {\n                  const kinds = e.target.value\n                    .split(\",\")\n                    .map((s) => s.trim())\n                    .filter(Boolean);\n                  updateMetric(\"relationshipKinds\", kinds.length > 0 ? kinds : undefined);\n                }}\n                className=\"input\"\n                placeholder=\"Leave empty for all kinds\"\n              />\n            </div>\n          )}\n          {config.metric?.type === \"shared_relationship\" && (\n            <>\n              <ReferenceDropdown\n                label=\"Shared Relationship Kind\"\n                value={config.metric?.sharedRelationshipKind}\n                onChange={(v) => updateMetric(\"sharedRelationshipKind\", v)}\n                options={relationshipKindOptions}\n              />\n              <ReferenceDropdown\n                label=\"Shared Direction\"\n                value={config.metric?.sharedDirection || \"src\"}\n                onChange={(v) => updateMetric(\"sharedDirection\", v)}\n                options={[\n                  { value: \"src\", label: \"Source (outgoing)\" },\n                  { value: \"dst\", label: \"Destination (incoming)\" },\n                ]}\n              />\n            </>\n          )}\n          <div className=\"form-group\">\n            <label className=\"label\">Min Strength\n            <NumberInput\n              value={config.metric?.minStrength}\n              onChange={(v) => updateMetric(\"minStrength\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n              placeholder=\"0\"\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Rules ({rules.length})</div>\n        <div className=\"section-desc\">Conditions and actions based on the metric.</div>\n\n        {rules.map((rule, index) => (\n          <RuleCard\n            key={index}\n            rule={rule}\n            onChange={(r) => updateRule(index, r)}\n            onRemove={() => removeRule(index)}\n            schema={schema}\n          />\n        ))}\n\n        <button className=\"btn-add\" onClick={addRule}>\n          + Add Rule\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Subtype Bonuses ({subtypeBonuses.length})</div>\n        <div className=\"section-desc\">Bonuses added to metric value based on entity subtype.</div>\n\n        {subtypeBonuses.map((bonus, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Subtype\"\n                    value={bonus.subtype}\n                    onChange={(v) => updateSubtypeBonus(index, { ...bonus, subtype: v })}\n                    options={getSubtypeOptions(selectionKind)}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Bonus\n                    <NumberInput\n                      value={bonus.bonus}\n                      onChange={(v) => updateSubtypeBonus(index, { ...bonus, bonus: v ?? 0 })}\n                    />\n                    </label>\n                  </div>\n                </div>\n                <button\n                  className=\"btn-icon btn-icon-danger\"\n                  onClick={() => removeSubtypeBonus(index)}\n                >\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addSubtypeBonus}>\n          + Add Subtype Bonus\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "label", "input", "NumberInput", "RuleCard", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::ThresholdTriggerTab", "name": "ThresholdTriggerTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Pressure definitions\n */\nexport function ThresholdTriggerTab({ system, onChange, schema, pressures }) {\n  const config = system.config;\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddVarForm, setShowAddVarForm] = useState(false);\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  // Conditions\n  const conditions = config.conditions || [];\n\n  const addCondition = (type) => {\n    const newRule = createNewRule(type, pressures);\n    updateConfig(\"conditions\", [...conditions, newRule]);\n  };\n\n  const updateCondition = (index, cond) => {\n    const newConditions = [...conditions];\n    newConditions[index] = cond;\n    updateConfig(\"conditions\", newConditions);\n  };\n\n  const removeCondition = (index) => {\n    updateConfig(\n      \"conditions\",\n      conditions.filter((_, i) => i !== index)\n    );\n  };\n\n  // Variables\n  const variables = config.variables || {};\n\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$self\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    updateConfig(\"variables\", {\n      ...variables,\n      [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"random\" } },\n    });\n    setNewVarName(\"\");\n    setShowAddVarForm(false);\n  };\n\n  const updateVariable = (name, config) => {\n    updateConfig(\"variables\", { ...variables, [name]: config });\n  };\n\n  const removeVariable = (name) => {\n    const newVars = { ...variables };\n    delete newVars[name];\n    updateConfig(\"variables\", newVars);\n  };\n\n  // Build entity options for actions (include defined variables)\n  const entityOptions = [\n    { value: \"$self\", label: \"$self\" },\n    { value: \"$member\", label: \"$member\" },\n    { value: \"$member2\", label: \"$member2\" },\n    ...Object.keys(variables).map((v) => ({ value: v, label: v })),\n  ];\n\n  // Actions (mutations)\n  const actions = config.actions || [];\n\n  const createAction = (type) => {\n    const defaultPressure = pressures?.[0]?.id || \"\";\n    switch (type) {\n      case \"modify_pressure\":\n        return { type: \"modify_pressure\", pressureId: defaultPressure, delta: 0 };\n      case \"set_tag\":\n        return { type: \"set_tag\", entity: \"$self\", tag: \"\", value: true };\n      case \"remove_tag\":\n        return { type: \"remove_tag\", entity: \"$self\", tag: \"\" };\n      case \"change_status\":\n        return { type: \"change_status\", entity: \"$self\", newStatus: \"\" };\n      case \"adjust_prominence\":\n        return { type: \"adjust_prominence\", entity: \"$self\", delta: 0.25 };\n      case \"archive_relationship\":\n        return {\n          type: \"archive_relationship\",\n          entity: \"$self\",\n          relationshipKind: \"\",\n          direction: \"both\",\n        };\n      case \"adjust_relationship_strength\":\n        return {\n          type: \"adjust_relationship_strength\",\n          kind: \"\",\n          src: \"$self\",\n          dst: \"$self\",\n          delta: 0.1,\n        };\n      case \"transfer_relationship\":\n        return {\n          type: \"transfer_relationship\",\n          entity: \"$self\",\n          relationshipKind: \"\",\n          from: \"$self\",\n          to: \"$self\",\n        };\n      case \"update_rate_limit\":\n        return { type: \"update_rate_limit\" };\n      case \"for_each_related\":\n        return { type: \"for_each_related\", relationship: \"\", direction: \"both\", actions: [] };\n      case \"conditional\":\n        return {\n          type: \"conditional\",\n          condition: { type: \"random_chance\", chance: 0.5 },\n          thenActions: [],\n          elseActions: [],\n        };\n      case \"create_relationship\":\n      default:\n        return { type: \"create_relationship\", kind: \"\", src: \"$self\", dst: \"$self\", strength: 0.5 };\n    }\n  };\n\n  const addAction = (type) => {\n    updateConfig(\"actions\", [...actions, createAction(type)]);\n  };\n\n  const updateAction = (index, action) => {\n    const newActions = [...actions];\n    newActions[index] = action;\n    updateConfig(\"actions\", newActions);\n  };\n\n  const removeAction = (index) => {\n    updateConfig(\n      \"actions\",\n      actions.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Conditions ({conditions.length})</div>\n        <div className=\"section-desc\">\n          All conditions must pass for an entity to be included in the trigger.\n        </div>\n\n        {conditions.length === 0 ? (\n          <div className=\"empty-state-compact\">No conditions defined.</div>\n        ) : (\n          conditions.map((cond, index) => (\n            <ApplicabilityRuleCard\n              key={index}\n              rule={cond}\n              onChange={(c) => updateCondition(index, c)}\n              onRemove={() => removeCondition(index)}\n              schema={schema}\n              pressures={pressures}\n            />\n          ))\n        )}\n\n        <AddRuleButton onAdd={addCondition} />\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Variables ({Object.keys(variables).length})</div>\n        <div className=\"section-desc\">\n          Variables select additional entities from the graph to use in actions. Referenced as{\" \"}\n          <code className=\"inline-code\">$varName</code> in action entity fields.\n        </div>\n\n        {Object.keys(variables).length === 0 && !showAddVarForm ? (\n          <div className=\"empty-state-compact\">No variables defined.</div>\n        ) : (\n          Object.entries(variables).map(([name, varConfig]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={varConfig}\n              onChange={(updated) => updateVariable(name, updated)}\n              onRemove={() => removeVariable(name)}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddVarForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddVarForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddVarForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Actions ({actions.length})</div>\n        <div className=\"section-desc\">\n          Mutations applied to each matching entity (or clusters when configured).\n        </div>\n\n        {actions.map((actionItem, index) => (\n          <div key={index} className=\"mb-lg\">\n            <MutationCard\n              mutation={actionItem}\n              onChange={(a) => updateAction(index, a)}\n              onRemove={() => removeAction(index)}\n              schema={schema}\n              pressures={pressures}\n              entityOptions={entityOptions}\n              typeOptions={TRIGGER_MUTATION_TYPES}\n              createMutation={createAction}\n              titlePrefix=\"Action\"\n            />\n            {actionItem.type === \"create_relationship\" && (\n              <label className=\"checkbox-label mt-md\">\n                <input\n                  type=\"checkbox\"\n                  checked={actionItem.betweenMatching || false}\n                  onChange={(e) =>\n                    updateAction(index, { ...actionItem, betweenMatching: e.target.checked })\n                  }\n                  className=\"checkbox\"\n                />\n                Between matching entities\n              </label>\n            )}\n          </div>\n        ))}\n\n        <div className=\"form-group mt-lg\">\n          <select\n            className=\"select\"\n            value=\"\"\n            onChange={(e) => {\n              if (!e.target.value) return;\n              addAction(e.target.value);\n            }}\n          >\n            <option value=\"\">+ Add action...</option>\n            {TRIGGER_MUTATION_TYPES.map((opt) => (\n              <option key={opt.value} value={opt.value}>\n                {opt.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Clustering</div>\n// ... (truncated)", "parameters": [{"name": "{ system, onChange, schema, pressures }", "type": "{ system: any; onChange: Function; schema: any; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "AddRuleButton", "code", "label", "input", "button", "MutationCard", "option", "ReferenceDropdown", "NumberInput", "LocalTextArea"], "hookCalls": [{"name": "useState", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::ClusterFormationTab", "name": "ClusterFormationTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function ClusterFormationTab({ system, onChange, schema }) {\n  const config = system.config;\n\n  const entityKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateClustering = (field, value) => {\n    updateConfig(\"clustering\", { ...config.clustering, [field]: value });\n  };\n\n  const updateMetaEntity = (field, value) => {\n    updateConfig(\"metaEntity\", { ...config.metaEntity, [field]: value });\n  };\n\n  // Criteria\n  const criteria = config.clustering?.criteria || [];\n\n  const addCriterion = () => {\n    updateClustering(\"criteria\", [...criteria, { type: \"same_culture\", weight: 1.0 }]);\n  };\n\n  const updateCriterion = (index, crit) => {\n    const newCriteria = [...criteria];\n    newCriteria[index] = crit;\n    updateClustering(\"criteria\", newCriteria);\n  };\n\n  const removeCriterion = (index) => {\n    updateClustering(\n      \"criteria\",\n      criteria.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Clustering Configuration</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Min Size\n            <NumberInput\n              value={config.clustering?.minSize}\n              onChange={(v) => updateClustering(\"minSize\", v)}\n              min={2}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Size\n            <NumberInput\n              value={config.clustering?.maxSize}\n              onChange={(v) => updateClustering(\"maxSize\", v)}\n              min={2}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Minimum Score\n            <NumberInput\n              value={config.clustering?.minimumScore}\n              onChange={(v) => updateClustering(\"minimumScore\", v)}\n              min={0}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Clustering Criteria ({criteria.length})</label>\n        </div>\n\n        {criteria.map((crit, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <ReferenceDropdown\n                    label=\"Type\"\n                    value={crit.type}\n                    onChange={(v) => updateCriterion(index, { ...crit, type: v })}\n                    options={CLUSTERING_CRITERIA_TYPES}\n                  />\n                  <div className=\"form-group\">\n                    <label className=\"label\">Weight\n                    <NumberInput\n                      value={crit.weight}\n                      onChange={(v) => updateCriterion(index, { ...crit, weight: v ?? 0 })}\n                      min={0}\n                    />\n                    </label>\n                  </div>\n                  {crit.type === \"shared_relationship\" && (\n                    <ReferenceDropdown\n                      label=\"Relationship Kind\"\n                      value={crit.relationshipKind}\n                      onChange={(v) => updateCriterion(index, { ...crit, relationshipKind: v })}\n                      options={relationshipKindOptions}\n                    />\n                  )}\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeCriterion(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addCriterion}>\n          + Add Criterion\n        </button>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Meta Entity</div>\n        <div className=\"section-desc\">Configuration for the meta-entity created from clusters.</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Kind\"\n            value={config.metaEntity?.kind}\n            onChange={(v) => updateMetaEntity(\"kind\", v)}\n            options={entityKindOptions}\n          />\n          <div className=\"form-group\">\n            <label htmlFor=\"status\" className=\"label\">Status</label>\n            <input id=\"status\"\n              type=\"text\"\n              value={config.metaEntity?.status || \"\"}\n              onChange={(e) => updateMetaEntity(\"status\", e.target.value)}\n              className=\"input\"\n            />\n          </div>\n        </div>\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Description Template\n            <LocalTextArea\n              value={config.metaEntity?.descriptionTemplate || \"\"}\n              onChange={(value) => updateMetaEntity(\"descriptionTemplate\", value)}\n              placeholder=\"Use {names}, {count} placeholders\"\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Narration Template</div>\n        <div className=\"section-desc mb-md text-xs\">\n          Syntax: {\"{list:members}\"}, {\"{count}\"}, {\"{field|fallback}\"}.\n        </div>\n        <LocalTextArea\n          value={config.narrationTemplate || \"\"}\n          onChange={(value) => updateConfig(\"narrationTemplate\", value || undefined)}\n          placeholder=\"e.g., {list:members} united to form a new alliance.\"\n          rows={2}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "NumberInput", "label", "ReferenceDropdown", "button", "input", "LocalTextArea"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::TagDiffusionTab", "name": "TagDiffusionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function TagDiffusionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateConvergence = (field, value) => {\n    updateConfig(\"convergence\", { ...config.convergence, [field]: value });\n  };\n\n  const updateDivergence = (field, value) => {\n    updateConfig(\"divergence\", { ...config.divergence, [field]: value });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Connection</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Connection Kind\"\n            value={config.connectionKind}\n            onChange={(v) => updateConfig(\"connectionKind\", v)}\n            options={relationshipKindOptions}\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={config.connectionDirection || \"both\"}\n            onChange={(v) => updateConfig(\"connectionDirection\", v)}\n            options={DIRECTIONS}\n          />\n          <div className=\"form-group\">\n            <label className=\"label\">Max Tags\n            <NumberInput\n              value={config.maxTags}\n              onChange={(v) => updateConfig(\"maxTags\", v)}\n              min={1}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Convergence</div>\n        <div className=\"section-desc\">Connected entities become more similar.</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tags\n            <TagSelector\n              value={config.convergence?.tags || []}\n              onChange={(tags) => updateConvergence(\"tags\", tags)}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Min Connections\n            <NumberInput\n              value={config.convergence?.minConnections}\n              onChange={(v) => updateConvergence(\"minConnections\", v)}\n              min={0}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Probability\n            <NumberInput\n              value={config.convergence?.probability}\n              onChange={(v) => updateConvergence(\"probability\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Divergence</div>\n        <div className=\"section-desc\">Isolated entities become more unique.</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tags\n            <TagSelector\n              value={config.divergence?.tags || []}\n              onChange={(tags) => updateDivergence(\"tags\", tags)}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Connections\n            <NumberInput\n              value={config.divergence?.maxConnections}\n              onChange={(v) => updateDivergence(\"maxConnections\", v)}\n              min={0}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Probability\n            <NumberInput\n              value={config.divergence?.probability}\n              onChange={(v) => updateDivergence(\"probability\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "NumberInput", "TagSelector"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::PlaneDiffusionTab", "name": "PlaneDiffusionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema (for tag registry)\n */\nexport function PlaneDiffusionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateSources = (field, value) => {\n    updateConfig(\"sources\", { ...config.sources, [field]: value });\n  };\n\n  const updateSinks = (field, value) => {\n    updateConfig(\"sinks\", { ...config.sinks, [field]: value });\n  };\n\n  const updateDiffusion = (field, value) => {\n    updateConfig(\"diffusion\", { ...config.diffusion, [field]: value });\n  };\n\n  // Output tags\n  const outputTags = config.outputTags || [];\n\n  const addOutputTag = () => {\n    updateConfig(\"outputTags\", [...outputTags, { tag: \"\", minValue: 0 }]);\n  };\n\n  const updateOutputTag = (index, tag) => {\n    const newTags = [...outputTags];\n    newTags[index] = tag;\n    updateConfig(\"outputTags\", newTags);\n  };\n\n  const removeOutputTag = (index) => {\n    updateConfig(\n      \"outputTags\",\n      outputTags.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Sources</div>\n        <div className=\"pdt-section-hint\">\n          Entities that SET values into the diffusion field. Values are maintained at source\n          positions each tick (Dirichlet boundary condition).\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tag Filter\n            <TagSelector\n              value={config.sources?.tagFilter ? [config.sources.tagFilter] : []}\n              onChange={(tags) => updateSources(\"tagFilter\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">Tag that marks an entity as a source</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Default Strength\n            <NumberInput\n              value={config.sources?.defaultStrength}\n              onChange={(v) => updateSources(\"defaultStrength\", v)}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Any number. Simulation is uncapped. Output tags clamp to -100/100.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Sinks</div>\n        <div className=\"pdt-section-hint\">\n          Entities that SET negative values into the diffusion field.\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tag Filter\n            <TagSelector\n              value={config.sinks?.tagFilter ? [config.sinks.tagFilter] : []}\n              onChange={(tags) => updateSinks(\"tagFilter\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">Tag that marks an entity as a sink</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Default Strength\n            <NumberInput\n              value={config.sinks?.defaultStrength}\n              onChange={(v) => updateSinks(\"defaultStrength\", v)}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">Will be negated. Any number - simulation is uncapped.</div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Diffusion</div>\n        <div className=\"pdt-section-hint\">\n          Heat equation parameters. Each tick: sources/sinks SET values (fixed boundary), then\n          diffusion runs N iterations to spread values.\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Rate\n            <NumberInput\n              value={config.diffusion?.rate}\n              onChange={(v) => updateDiffusion(\"rate\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              0-1. Recommended 0.1-0.25. Above 0.25 may cause oscillations.\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Source Radius\n            <NumberInput\n              value={config.diffusion?.sourceRadius}\n              onChange={(v) => updateDiffusion(\"sourceRadius\", v)}\n              min={0}\n              max={50}\n              integer\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">Grid cells where source/sink SET values. Default: 1.</div>\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"falloff-type\" className=\"label\">Falloff Type</label>\n            <select id=\"falloff-type\"\n              className=\"input\"\n              value={config.diffusion?.falloffType || \"absolute\"}\n              onChange={(e) => updateDiffusion(\"falloffType\", e.target.value)}\n            >\n              {FALLOFF_OPTIONS.map((opt) => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.label}\n                </option>\n              ))}\n            </select>\n            <div className=\"pdt-hint\">How strength decreases within source radius.</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Decay Rate\n            <NumberInput\n              value={config.diffusion?.decayRate}\n              onChange={(v) => updateDiffusion(\"decayRate\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              0-1. Default: 0 (no decay). Decay fights diffusion spreading.\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Iterations Per Tick\n            <NumberInput\n              value={config.diffusion?.iterationsPerTick}\n              onChange={(v) => updateDiffusion(\"iterationsPerTick\", v)}\n              min={1}\n              max={200}\n              integer\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Default: 20. Higher = faster spreading. 20 achieves ~50 cells in 15 ticks.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Output Tags ({outputTags.length})</div>\n        <div className=\"pdt-section-hint\">\n          Tags assigned to entities based on sampled field value (clamped to -100 to 100).\n        </div>\n\n        {outputTags.map((tag, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <div className=\"form-group\">\n                    <label className=\"label\">Tag\n                    <TagSelector\n                      value={tag.tag ? [tag.tag] : []}\n                      onChange={(tags) => updateOutputTag(index, { ...tag, tag: tags[0] || \"\" })}\n                      tagRegistry={tagRegistry}\n                      placeholder=\"Select tag...\"\n                      singleSelect\n                    />\n                    </label>\n                  </div>\n                  <div className=\"form-group\">\n                    <label className=\"label\">Min Value\n                    <NumberInput\n                      value={tag.minValue}\n                      onChange={(v) => updateOutputTag(index, { ...tag, minValue: v })}\n                      min={-100}\n                      max={100}\n                      allowEmpty\n                    />\n                    </label>\n                    <div className=\"pdt-hint\">-100 to 100</div>\n                  </div>\n                  <div className=\"form-group\">\n                    <label className=\"label\">Max Value\n                    <NumberInput\n                      value={tag.maxValue}\n                      onChange={(v) => updateOutputTag(index, { ...tag, maxValue: v })}\n                      min={-100}\n                      max={100}\n                      allowEmpty\n                    />\n                    </label>\n                    <div className=\"pdt-hint\">-100 to 100</div>\n                  </div>\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeOutputTag(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addOutputTag}>\n          + Add Output Tag\n        </button>\n\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Value Tag\n            <TagSelector\n              value={config.valueTag ? [config.valueTag] : []}\n              onChange={(tags) => updateConfig(\"valueTag\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Optional: Store clamped field value as tag (e.g., &quot;field_value:25.5&quot;)\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "TagSelector", "NumberInput", "label", "option", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/index.js::FrameworkSystemTab", "name": "FrameworkSystemTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n */\nexport function FrameworkSystemTab({ system, onChange }) {\n  const config = system.config;\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  return (\n    <div>\n      <div className=\"info-box\">\n        <div className=\"info-box-title\">Framework System</div>\n        <div className=\"info-box-text\">\n          This is a framework-level system with specific configuration options.\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Configuration</div>\n\n        {system.systemType === \"eraTransition\" && (\n          <div className=\"form-grid\">\n            <p className=\"label grid-col-full text-dim\">\n              Era transition timing is controlled by per-era exitConditions in eras.json. Add a time\n              condition (e.g., {`{ type: 'time_elapsed', minTicks: 25 }`}) to control minimum era\n              length.\n            </p>\n          </div>\n        )}\n\n        {system.systemType === \"universalCatalyst\" && (\n          <div className=\"form-grid\">\n            <div className=\"form-group\">\n              <label className=\"label\">Action Attempt Rate\n              <NumberInput\n                value={config.actionAttemptRate}\n                onChange={(v) => updateConfig(\"actionAttemptRate\", v)}\n                className=\"input\"\n                step={0.1}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Pressure Multiplier\n              <NumberInput\n                value={config.pressureMultiplier}\n                onChange={(v) => updateConfig(\"pressureMultiplier\", v)}\n                className=\"input\"\n                step={0.1}\n                min={0}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Prominence Up % on Success\n              <NumberInput\n                value={config.prominenceUpChanceOnSuccess}\n                onChange={(v) => updateConfig(\"prominenceUpChanceOnSuccess\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Prominence Down % on Failure\n              <NumberInput\n                value={config.prominenceDownChanceOnFailure}\n                onChange={(v) => updateConfig(\"prominenceDownChanceOnFailure\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n          </div>\n        )}\n\n        {system.systemType === \"relationshipMaintenance\" && (\n          <div className=\"form-grid\">\n            <div className=\"form-group\">\n              <label className=\"label\">Maintenance Frequency\n              <NumberInput\n                value={config.maintenanceFrequency}\n                onChange={(v) => updateConfig(\"maintenanceFrequency\", v)}\n                className=\"input\"\n                min={1}\n                allowEmpty\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Cull Threshold\n              <NumberInput\n                value={config.cullThreshold}\n                onChange={(v) => updateConfig(\"cullThreshold\", v)}\n                className=\"input\"\n                step={0.05}\n                min={0}\n                max={1}\n                allowEmpty\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Grace Period\n              <NumberInput\n                value={config.gracePeriod}\n                onChange={(v) => updateConfig(\"gracePeriod\", v)}\n                className=\"input\"\n                min={0}\n                allowEmpty\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"form-group\">\n              <label className=\"label\">Reinforcement Bonus\n              <NumberInput\n                value={config.reinforcementBonus}\n                onChange={(v) => updateConfig(\"reinforcementBonus\", v)}\n                className=\"input\"\n                step={0.01}\n                min={0}\n                allowEmpty\n              />\n              </label>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange }", "type": "{ system: any; onChange: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "p", "NumberInput"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/OverviewTab.jsx::OverviewTab", "name": "OverviewTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/OverviewTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Function} props.onDelete - Called to delete the system\n */\nexport function OverviewTab({ system, onChange, onDelete }) {\n  const config = system.config;\n  const typeConfig = SYSTEM_TYPES[system.systemType] || {};\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const [localId, setLocalId, handleIdBlur] = useLocalInputState(config.id, (value) =>\n    updateConfig(\"id\", value)\n  );\n  const [localName, setLocalName, handleNameBlur] = useLocalInputState(config.name, (value) =>\n    updateConfig(\"name\", value)\n  );\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Basic Information</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label htmlFor=\"system-id\" className=\"label\">System ID</label>\n            <input id=\"system-id\"\n              type=\"text\"\n              value={localId}\n              onChange={(e) => setLocalId(e.target.value)}\n              onBlur={handleIdBlur}\n              className=\"input\"\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"display-name\" className=\"label\">Display Name</label>\n            <input id=\"display-name\"\n              type=\"text\"\n              value={localName}\n              onChange={(e) => setLocalName(e.target.value)}\n              onBlur={handleNameBlur}\n              className=\"input\"\n            />\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Description\n            <LocalTextArea\n              value={config.description || \"\"}\n              onChange={(value) => updateConfig(\"description\", value)}\n              className=\"ot-description-textarea\"\n              placeholder=\"Describe what this system does...\"\n            />\n            </label>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <span className=\"label\">System Type</span>\n          <div className=\"flex items-center gap-lg\">\n            {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color from config */}\n            <span\n              className=\"type-badge\"\n              style={{ '--ot-type-bg': `${typeConfig.color}30`, '--ot-type-color': typeConfig.color, backgroundColor: 'var(--ot-type-bg)', color: 'var(--ot-type-color)' }}\n            >\n              {typeConfig.icon} {typeConfig.label}\n            </span>\n            <span className=\"text-muted ot-type-desc\">\n              {typeConfig.desc}\n            </span>\n          </div>\n        </div>\n\n        <div className=\"mt-xl\">\n          <label className=\"label\">Enabled\n          <EnableToggle\n            enabled={system.enabled !== false}\n            onChange={(enabled) => onChange({ ...system, enabled })}\n            label={system.enabled !== false ? \"System is active\" : \"System is disabled\"}\n          />\n          </label>\n        </div>\n      </div>\n\n      <div className=\"danger-zone\">\n        <button className=\"btn btn-danger\" onClick={onDelete}>\n          Delete System\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, onDelete }", "type": "{ system: any; onChange: Function; onDelete: Function; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "label", "input", "LocalTextArea", "span", "EnableToggle", "button"], "hookCalls": [{"name": "useLocalInputState", "count": 2}], "customHookCalls": ["useLocalInputState"], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["SYSTEM_TYPES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["EnableToggle", "useLocalInputState", "LocalTextArea"], "category": "internal"}, {"source": "./OverviewTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/PlaneDiffusionTab.jsx::PlaneDiffusionTab", "name": "PlaneDiffusionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/PlaneDiffusionTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema (for tag registry)\n */\nexport function PlaneDiffusionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateSources = (field, value) => {\n    updateConfig(\"sources\", { ...config.sources, [field]: value });\n  };\n\n  const updateSinks = (field, value) => {\n    updateConfig(\"sinks\", { ...config.sinks, [field]: value });\n  };\n\n  const updateDiffusion = (field, value) => {\n    updateConfig(\"diffusion\", { ...config.diffusion, [field]: value });\n  };\n\n  // Output tags\n  const outputTags = config.outputTags || [];\n\n  const addOutputTag = () => {\n    updateConfig(\"outputTags\", [...outputTags, { tag: \"\", minValue: 0 }]);\n  };\n\n  const updateOutputTag = (index, tag) => {\n    const newTags = [...outputTags];\n    newTags[index] = tag;\n    updateConfig(\"outputTags\", newTags);\n  };\n\n  const removeOutputTag = (index) => {\n    updateConfig(\n      \"outputTags\",\n      outputTags.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Sources</div>\n        <div className=\"pdt-section-hint\">\n          Entities that SET values into the diffusion field. Values are maintained at source\n          positions each tick (Dirichlet boundary condition).\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tag Filter\n            <TagSelector\n              value={config.sources?.tagFilter ? [config.sources.tagFilter] : []}\n              onChange={(tags) => updateSources(\"tagFilter\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">Tag that marks an entity as a source</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Default Strength\n            <NumberInput\n              value={config.sources?.defaultStrength}\n              onChange={(v) => updateSources(\"defaultStrength\", v)}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Any number. Simulation is uncapped. Output tags clamp to -100/100.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Sinks</div>\n        <div className=\"pdt-section-hint\">\n          Entities that SET negative values into the diffusion field.\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tag Filter\n            <TagSelector\n              value={config.sinks?.tagFilter ? [config.sinks.tagFilter] : []}\n              onChange={(tags) => updateSinks(\"tagFilter\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">Tag that marks an entity as a sink</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Default Strength\n            <NumberInput\n              value={config.sinks?.defaultStrength}\n              onChange={(v) => updateSinks(\"defaultStrength\", v)}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">Will be negated. Any number - simulation is uncapped.</div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Diffusion</div>\n        <div className=\"pdt-section-hint\">\n          Heat equation parameters. Each tick: sources/sinks SET values (fixed boundary), then\n          diffusion runs N iterations to spread values.\n        </div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Rate\n            <NumberInput\n              value={config.diffusion?.rate}\n              onChange={(v) => updateDiffusion(\"rate\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              0-1. Recommended 0.1-0.25. Above 0.25 may cause oscillations.\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Source Radius\n            <NumberInput\n              value={config.diffusion?.sourceRadius}\n              onChange={(v) => updateDiffusion(\"sourceRadius\", v)}\n              min={0}\n              max={50}\n              integer\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">Grid cells where source/sink SET values. Default: 1.</div>\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"falloff-type\" className=\"label\">Falloff Type</label>\n            <select id=\"falloff-type\"\n              className=\"input\"\n              value={config.diffusion?.falloffType || \"absolute\"}\n              onChange={(e) => updateDiffusion(\"falloffType\", e.target.value)}\n            >\n              {FALLOFF_OPTIONS.map((opt) => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.label}\n                </option>\n              ))}\n            </select>\n            <div className=\"pdt-hint\">How strength decreases within source radius.</div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Decay Rate\n            <NumberInput\n              value={config.diffusion?.decayRate}\n              onChange={(v) => updateDiffusion(\"decayRate\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              0-1. Default: 0 (no decay). Decay fights diffusion spreading.\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Iterations Per Tick\n            <NumberInput\n              value={config.diffusion?.iterationsPerTick}\n              onChange={(v) => updateDiffusion(\"iterationsPerTick\", v)}\n              min={1}\n              max={200}\n              integer\n              allowEmpty\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Default: 20. Higher = faster spreading. 20 achieves ~50 cells in 15 ticks.\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Output Tags ({outputTags.length})</div>\n        <div className=\"pdt-section-hint\">\n          Tags assigned to entities based on sampled field value (clamped to -100 to 100).\n        </div>\n\n        {outputTags.map((tag, index) => (\n          <div key={index} className=\"item-card\">\n            <div className=\"py-lg px-xl\">\n              <div className=\"form-row-with-delete\">\n                <div className=\"form-row-fields\">\n                  <div className=\"form-group\">\n                    <label className=\"label\">Tag\n                    <TagSelector\n                      value={tag.tag ? [tag.tag] : []}\n                      onChange={(tags) => updateOutputTag(index, { ...tag, tag: tags[0] || \"\" })}\n                      tagRegistry={tagRegistry}\n                      placeholder=\"Select tag...\"\n                      singleSelect\n                    />\n                    </label>\n                  </div>\n                  <div className=\"form-group\">\n                    <label className=\"label\">Min Value\n                    <NumberInput\n                      value={tag.minValue}\n                      onChange={(v) => updateOutputTag(index, { ...tag, minValue: v })}\n                      min={-100}\n                      max={100}\n                      allowEmpty\n                    />\n                    </label>\n                    <div className=\"pdt-hint\">-100 to 100</div>\n                  </div>\n                  <div className=\"form-group\">\n                    <label className=\"label\">Max Value\n                    <NumberInput\n                      value={tag.maxValue}\n                      onChange={(v) => updateOutputTag(index, { ...tag, maxValue: v })}\n                      min={-100}\n                      max={100}\n                      allowEmpty\n                    />\n                    </label>\n                    <div className=\"pdt-hint\">-100 to 100</div>\n                  </div>\n                </div>\n                <button className=\"btn-icon btn-icon-danger\" onClick={() => removeOutputTag(index)}>\n                  \u00d7\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n\n        <button className=\"btn-add\" onClick={addOutputTag}>\n          + Add Output Tag\n        </button>\n\n        <div className=\"mt-xl\">\n          <div className=\"form-group\">\n            <label className=\"label\">Value Tag\n            <TagSelector\n              value={config.valueTag ? [config.valueTag] : []}\n              onChange={(tags) => updateConfig(\"valueTag\", tags[0] || \"\")}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tag...\"\n              singleSelect\n            />\n            </label>\n            <div className=\"pdt-hint\">\n              Optional: Store clamped field value as tag (e.g., &quot;field_value:25.5&quot;)\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "TagSelector", "NumberInput", "label", "option", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["NumberInput"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "./PlaneDiffusionTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/TagDiffusionTab.jsx::TagDiffusionTab", "name": "TagDiffusionTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/TagDiffusionTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n */\nexport function TagDiffusionTab({ system, onChange, schema }) {\n  const config = system.config;\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  const updateConvergence = (field, value) => {\n    updateConfig(\"convergence\", { ...config.convergence, [field]: value });\n  };\n\n  const updateDivergence = (field, value) => {\n    updateConfig(\"divergence\", { ...config.divergence, [field]: value });\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Connection</div>\n        <div className=\"form-grid\">\n          <ReferenceDropdown\n            label=\"Connection Kind\"\n            value={config.connectionKind}\n            onChange={(v) => updateConfig(\"connectionKind\", v)}\n            options={relationshipKindOptions}\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={config.connectionDirection || \"both\"}\n            onChange={(v) => updateConfig(\"connectionDirection\", v)}\n            options={DIRECTIONS}\n          />\n          <div className=\"form-group\">\n            <label className=\"label\">Max Tags\n            <NumberInput\n              value={config.maxTags}\n              onChange={(v) => updateConfig(\"maxTags\", v)}\n              min={1}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Convergence</div>\n        <div className=\"section-desc\">Connected entities become more similar.</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tags\n            <TagSelector\n              value={config.convergence?.tags || []}\n              onChange={(tags) => updateConvergence(\"tags\", tags)}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Min Connections\n            <NumberInput\n              value={config.convergence?.minConnections}\n              onChange={(v) => updateConvergence(\"minConnections\", v)}\n              min={0}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Probability\n            <NumberInput\n              value={config.convergence?.probability}\n              onChange={(v) => updateConvergence(\"probability\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Divergence</div>\n        <div className=\"section-desc\">Isolated entities become more unique.</div>\n        <div className=\"form-grid\">\n          <div className=\"form-group\">\n            <label className=\"label\">Tags\n            <TagSelector\n              value={config.divergence?.tags || []}\n              onChange={(tags) => updateDivergence(\"tags\", tags)}\n              tagRegistry={tagRegistry}\n              placeholder=\"Select tags...\"\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Max Connections\n            <NumberInput\n              value={config.divergence?.maxConnections}\n              onChange={(v) => updateDivergence(\"maxConnections\", v)}\n              min={0}\n              integer\n              allowEmpty\n            />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label className=\"label\">Probability\n            <NumberInput\n              value={config.divergence?.probability}\n              onChange={(v) => updateDivergence(\"probability\", v)}\n              min={0}\n              max={1}\n              allowEmpty\n            />\n            </label>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ system, onChange, schema }", "type": "{ system: any; onChange: Function; schema: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "ReferenceDropdown", "NumberInput", "TagSelector"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["DIRECTIONS"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/tabs/ThresholdTriggerTab.jsx::ThresholdTriggerTab", "name": "ThresholdTriggerTab", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/tabs/ThresholdTriggerTab.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Pressure definitions\n */\nexport function ThresholdTriggerTab({ system, onChange, schema, pressures }) {\n  const config = system.config;\n  const [newVarName, setNewVarName] = useState(\"\");\n  const [showAddVarForm, setShowAddVarForm] = useState(false);\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const updateConfig = (field, value) => {\n    onChange({ ...system, config: { ...config, [field]: value } });\n  };\n\n  // Conditions\n  const conditions = config.conditions || [];\n\n  const addCondition = (type) => {\n    const newRule = createNewRule(type, pressures);\n    updateConfig(\"conditions\", [...conditions, newRule]);\n  };\n\n  const updateCondition = (index, cond) => {\n    const newConditions = [...conditions];\n    newConditions[index] = cond;\n    updateConfig(\"conditions\", newConditions);\n  };\n\n  const removeCondition = (index) => {\n    updateConfig(\n      \"conditions\",\n      conditions.filter((_, i) => i !== index)\n    );\n  };\n\n  // Variables\n  const variables = config.variables || {};\n\n  const buildAvailableRefs = (excludeVar) => {\n    const refs = [\"$self\"];\n    Object.keys(variables).forEach((v) => {\n      if (v !== excludeVar) refs.push(v);\n    });\n    return refs;\n  };\n\n  const handleAddVariable = () => {\n    if (!newVarName.trim()) return;\n    const name = newVarName.startsWith(\"$\") ? newVarName : `$${newVarName}`;\n    updateConfig(\"variables\", {\n      ...variables,\n      [name]: { select: { from: \"graph\", kind: \"\", pickStrategy: \"random\" } },\n    });\n    setNewVarName(\"\");\n    setShowAddVarForm(false);\n  };\n\n  const updateVariable = (name, config) => {\n    updateConfig(\"variables\", { ...variables, [name]: config });\n  };\n\n  const removeVariable = (name) => {\n    const newVars = { ...variables };\n    delete newVars[name];\n    updateConfig(\"variables\", newVars);\n  };\n\n  // Build entity options for actions (include defined variables)\n  const entityOptions = [\n    { value: \"$self\", label: \"$self\" },\n    { value: \"$member\", label: \"$member\" },\n    { value: \"$member2\", label: \"$member2\" },\n    ...Object.keys(variables).map((v) => ({ value: v, label: v })),\n  ];\n\n  // Actions (mutations)\n  const actions = config.actions || [];\n\n  const createAction = (type) => {\n    const defaultPressure = pressures?.[0]?.id || \"\";\n    switch (type) {\n      case \"modify_pressure\":\n        return { type: \"modify_pressure\", pressureId: defaultPressure, delta: 0 };\n      case \"set_tag\":\n        return { type: \"set_tag\", entity: \"$self\", tag: \"\", value: true };\n      case \"remove_tag\":\n        return { type: \"remove_tag\", entity: \"$self\", tag: \"\" };\n      case \"change_status\":\n        return { type: \"change_status\", entity: \"$self\", newStatus: \"\" };\n      case \"adjust_prominence\":\n        return { type: \"adjust_prominence\", entity: \"$self\", delta: 0.25 };\n      case \"archive_relationship\":\n        return {\n          type: \"archive_relationship\",\n          entity: \"$self\",\n          relationshipKind: \"\",\n          direction: \"both\",\n        };\n      case \"adjust_relationship_strength\":\n        return {\n          type: \"adjust_relationship_strength\",\n          kind: \"\",\n          src: \"$self\",\n          dst: \"$self\",\n          delta: 0.1,\n        };\n      case \"transfer_relationship\":\n        return {\n          type: \"transfer_relationship\",\n          entity: \"$self\",\n          relationshipKind: \"\",\n          from: \"$self\",\n          to: \"$self\",\n        };\n      case \"update_rate_limit\":\n        return { type: \"update_rate_limit\" };\n      case \"for_each_related\":\n        return { type: \"for_each_related\", relationship: \"\", direction: \"both\", actions: [] };\n      case \"conditional\":\n        return {\n          type: \"conditional\",\n          condition: { type: \"random_chance\", chance: 0.5 },\n          thenActions: [],\n          elseActions: [],\n        };\n      case \"create_relationship\":\n      default:\n        return { type: \"create_relationship\", kind: \"\", src: \"$self\", dst: \"$self\", strength: 0.5 };\n    }\n  };\n\n  const addAction = (type) => {\n    updateConfig(\"actions\", [...actions, createAction(type)]);\n  };\n\n  const updateAction = (index, action) => {\n    const newActions = [...actions];\n    newActions[index] = action;\n    updateConfig(\"actions\", newActions);\n  };\n\n  const removeAction = (index) => {\n    updateConfig(\n      \"actions\",\n      actions.filter((_, i) => i !== index)\n    );\n  };\n\n  return (\n    <div>\n      <div className=\"section\">\n        <div className=\"section-title\">Conditions ({conditions.length})</div>\n        <div className=\"section-desc\">\n          All conditions must pass for an entity to be included in the trigger.\n        </div>\n\n        {conditions.length === 0 ? (\n          <div className=\"empty-state-compact\">No conditions defined.</div>\n        ) : (\n          conditions.map((cond, index) => (\n            <ApplicabilityRuleCard\n              key={index}\n              rule={cond}\n              onChange={(c) => updateCondition(index, c)}\n              onRemove={() => removeCondition(index)}\n              schema={schema}\n              pressures={pressures}\n            />\n          ))\n        )}\n\n        <AddRuleButton onAdd={addCondition} />\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Variables ({Object.keys(variables).length})</div>\n        <div className=\"section-desc\">\n          Variables select additional entities from the graph to use in actions. Referenced as{\" \"}\n          <code className=\"inline-code\">$varName</code> in action entity fields.\n        </div>\n\n        {Object.keys(variables).length === 0 && !showAddVarForm ? (\n          <div className=\"empty-state-compact\">No variables defined.</div>\n        ) : (\n          Object.entries(variables).map(([name, varConfig]) => (\n            <VariableCard\n              key={name}\n              name={name}\n              config={varConfig}\n              onChange={(updated) => updateVariable(name, updated)}\n              onRemove={() => removeVariable(name)}\n              schema={schema}\n              availableRefs={buildAvailableRefs(name)}\n            />\n          ))\n        )}\n\n        {showAddVarForm ? (\n          <div className=\"item-card add-form\">\n            <div className=\"add-form-fields\">\n              <div className=\"flex-1\">\n                <label htmlFor=\"variable-name\" className=\"label\">Variable Name</label>\n                <input id=\"variable-name\"\n                  type=\"text\"\n                  value={newVarName}\n                  onChange={(e) => setNewVarName(e.target.value.replace(/[^a-zA-Z0-9_$]/g, \"\"))}\n                  className=\"input\"\n                  placeholder=\"$myVariable\"\n                  // eslint-disable-next-line jsx-a11y/no-autofocus\n                  autoFocus\n                />\n              </div>\n              <button\n                className=\"btn btn-primary\"\n                onClick={handleAddVariable}\n                disabled={!newVarName.trim()}\n              >\n                Add\n              </button>\n              <button\n                className=\"btn btn-secondary\"\n                onClick={() => {\n                  setShowAddVarForm(false);\n                  setNewVarName(\"\");\n                }}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        ) : (\n          <button className=\"btn-add\" onClick={() => setShowAddVarForm(true)}>\n            + Add Variable\n          </button>\n        )}\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Actions ({actions.length})</div>\n        <div className=\"section-desc\">\n          Mutations applied to each matching entity (or clusters when configured).\n        </div>\n\n        {actions.map((actionItem, index) => (\n          <div key={index} className=\"mb-lg\">\n            <MutationCard\n              mutation={actionItem}\n              onChange={(a) => updateAction(index, a)}\n              onRemove={() => removeAction(index)}\n              schema={schema}\n              pressures={pressures}\n              entityOptions={entityOptions}\n              typeOptions={TRIGGER_MUTATION_TYPES}\n              createMutation={createAction}\n              titlePrefix=\"Action\"\n            />\n            {actionItem.type === \"create_relationship\" && (\n              <label className=\"checkbox-label mt-md\">\n                <input\n                  type=\"checkbox\"\n                  checked={actionItem.betweenMatching || false}\n                  onChange={(e) =>\n                    updateAction(index, { ...actionItem, betweenMatching: e.target.checked })\n                  }\n                  className=\"checkbox\"\n                />\n                Between matching entities\n              </label>\n            )}\n          </div>\n        ))}\n\n        <div className=\"form-group mt-lg\">\n          <select\n            className=\"select\"\n            value=\"\"\n            onChange={(e) => {\n              if (!e.target.value) return;\n              addAction(e.target.value);\n            }}\n          >\n            <option value=\"\">+ Add action...</option>\n            {TRIGGER_MUTATION_TYPES.map((opt) => (\n              <option key={opt.value} value={opt.value}>\n                {opt.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n\n      <div className=\"section\">\n        <div className=\"section-title\">Clustering</div>\n// ... (truncated)", "parameters": [{"name": "{ system, onChange, schema, pressures }", "type": "{ system: any; onChange: Function; schema: any; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "AddRuleButton", "code", "label", "input", "button", "MutationCard", "option", "ReferenceDropdown", "NumberInput", "LocalTextArea"], "hookCalls": [{"name": "useState", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["CLUSTER_MODES"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ReferenceDropdown", "NumberInput", "LocalTextArea"], "category": "internal"}, {"source": "../../shared/VariableSelectionEditor", "specifiers": ["VariableSelectionEditor"], "category": "internal"}, {"source": "../../generators/applicability/ApplicabilityRuleCard", "specifiers": ["ApplicabilityRuleCard"], "category": "internal"}, {"source": "../../generators/applicability/AddRuleButton", "specifiers": ["AddRuleButton"], "category": "internal"}, {"source": "../../generators/applicability/createNewRule", "specifiers": ["createNewRule"], "category": "internal"}, {"source": "../../shared/MutationCard", "specifiers": ["MutationCard", "DEFAULT_MUTATION_TYPES"], "category": "internal"}, {"source": "./ThresholdTriggerTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/validation/cards/index.js::IssueCard", "name": "IssueCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/validation/cards/index.js", "sourceCode": "export function IssueCard({ issue, onItemClick }) {\n  const [expanded, setExpanded] = useState(false);\n  const [, setHovering] = useState(false);\n  const [, setHoveredItem] = useState(null);\n\n  const severityClass =\n    issue.severity === \"error\"\n      ? \"validation-issue-severity validation-status-error\"\n      : \"validation-issue-severity validation-status-warning\";\n\n  const icons = {\n    error: \"\u274c\",\n    warning: \"\u26a0\ufe0f\",\n  };\n\n  return (\n    <div className=\"validation-issue-card\">\n      <div\n        className=\"validation-issue-header\"\n        onClick={() => setExpanded(!expanded)}\n        onMouseEnter={() => setHovering(true)}\n        onMouseLeave={() => setHovering(false)}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <span className=\"validation-issue-icon\">{icons[issue.severity]}</span>\n        <span className=\"validation-issue-title\">{issue.title}</span>\n        <span className=\"validation-issue-count\">{issue.affectedItems.length}</span>\n        <span className={severityClass}>{issue.severity.toUpperCase()}</span>\n        <span\n          className={`validation-issue-expand-icon ${expanded ? \"ic-expand-rotated\" : \"\"}`}\n        >\n          \u25bc\n        </span>\n      </div>\n      {expanded && (\n        <div className=\"validation-issue-content\">\n          <div className=\"validation-issue-message\">{issue.message}</div>\n          <div className=\"validation-affected-items\">\n            {issue.affectedItems.map((item) => (\n              <div key={item.id} className=\"flex-col ic-affected-item-row\">\n                <span\n                  className=\"validation-affected-item\"\n                  title={item.detail}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    onItemClick?.(item.id);\n                  }}\n                  onMouseEnter={() => setHoveredItem(item.id)}\n                  onMouseLeave={() => setHoveredItem(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.label}\n                </span>\n                {item.detail && <span className=\"validation-detail-row\">{item.detail}</span>}\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ issue, onItemClick }", "type": "{ issue: any; onItemClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useState", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/cards/IssueCard.jsx::IssueCard", "name": "IssueCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/validation/cards/IssueCard.jsx", "sourceCode": "export function IssueCard({ issue, onItemClick }) {\n  const [expanded, setExpanded] = useState(false);\n  const [, setHovering] = useState(false);\n  const [, setHoveredItem] = useState(null);\n\n  const severityClass =\n    issue.severity === \"error\"\n      ? \"validation-issue-severity validation-status-error\"\n      : \"validation-issue-severity validation-status-warning\";\n\n  const icons = {\n    error: \"\u274c\",\n    warning: \"\u26a0\ufe0f\",\n  };\n\n  return (\n    <div className=\"validation-issue-card\">\n      <div\n        className=\"validation-issue-header\"\n        onClick={() => setExpanded(!expanded)}\n        onMouseEnter={() => setHovering(true)}\n        onMouseLeave={() => setHovering(false)}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <span className=\"validation-issue-icon\">{icons[issue.severity]}</span>\n        <span className=\"validation-issue-title\">{issue.title}</span>\n        <span className=\"validation-issue-count\">{issue.affectedItems.length}</span>\n        <span className={severityClass}>{issue.severity.toUpperCase()}</span>\n        <span\n          className={`validation-issue-expand-icon ${expanded ? \"ic-expand-rotated\" : \"\"}`}\n        >\n          \u25bc\n        </span>\n      </div>\n      {expanded && (\n        <div className=\"validation-issue-content\">\n          <div className=\"validation-issue-message\">{issue.message}</div>\n          <div className=\"validation-affected-items\">\n            {issue.affectedItems.map((item) => (\n              <div key={item.id} className=\"flex-col ic-affected-item-row\">\n                <span\n                  className=\"validation-affected-item\"\n                  title={item.detail}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    onItemClick?.(item.id);\n                  }}\n                  onMouseEnter={() => setHoveredItem(item.id)}\n                  onMouseLeave={() => setHoveredItem(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.label}\n                </span>\n                {item.detail && <span className=\"validation-detail-row\">{item.detail}</span>}\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ issue, onItemClick }", "type": "{ issue: any; onItemClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useState", "count": 3}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../validation.css", "specifiers": [], "category": "internal"}, {"source": "./IssueCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/CopyGrammarModal.jsx::CopyGrammarModal", "name": "CopyGrammarModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/CopyGrammarModal.jsx", "sourceCode": "/**\n * Copy Grammar Modal - copy grammar from another culture with smart substitution\n */\nexport function CopyGrammarModal({\n  cultureId,\n  cultureConfig,\n  allCultures,\n  existingGrammarIds,\n  onCopy,\n  onClose,\n}) {\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [selectedGrammar, setSelectedGrammar] = useState(null);\n  const [newGrammarId, setNewGrammarId] = useState(\"\");\n  const [substitutedGrammar, setSubstitutedGrammar] = useState(null);\n  const [dependencies, setDependencies] = useState({ missing: [], existing: [] });\n  const [selectedDeps, setSelectedDeps] = useState(new Set());\n\n  const otherCultures = Object.entries(allCultures || {})\n    .filter(([id]) => id !== cultureId)\n    .map(([id, config]) => ({\n      id,\n      name: config.name || id,\n      grammars: config.naming?.grammars || [],\n    }));\n\n  useEffect(() => {\n    if (!selectedGrammar || !selectedCulture) {\n      setSubstitutedGrammar(null);\n      setDependencies({ missing: [], existing: [] });\n      setSelectedDeps(new Set());\n      return;\n    }\n\n    const sourceCulture = allCultures[selectedCulture];\n    const sourceGrammar = sourceCulture?.naming?.grammars?.find((g) => g.id === selectedGrammar);\n    if (!sourceGrammar) return;\n\n    // Find dependencies\n    const slotRefs = extractSlotReferences(sourceGrammar);\n    const targetLexemes = Object.keys(cultureConfig?.naming?.lexemeLists || {});\n    const sourceLexemes = sourceCulture?.naming?.lexemeLists || {};\n\n    const missing = [];\n    const existing = [];\n    slotRefs.forEach((slotId) => {\n      if (sourceLexemes[slotId]) {\n        const suffix = slotId.replace(/^[^_]+_/, \"\");\n        const targetEquivalent = targetLexemes.find((tl) => {\n          const tSuffix = tl.replace(/^[^_]+_/, \"\");\n          return tSuffix === suffix;\n        });\n\n        if (targetEquivalent) {\n          existing.push({ sourceId: slotId, targetId: targetEquivalent });\n        } else {\n          missing.push({ sourceId: slotId, entries: sourceLexemes[slotId].entries?.length || 0 });\n        }\n      }\n    });\n\n    setDependencies({ missing, existing });\n    setSelectedDeps(new Set(missing.map((d) => d.sourceId)));\n\n    const substituted = substituteGrammarReferences(\n      sourceGrammar,\n      sourceCulture,\n      cultureConfig,\n      cultureId\n    );\n    const finalId = generateUniqueId(cultureId, sourceGrammar.id, existingGrammarIds);\n\n    setNewGrammarId(finalId);\n    setSubstitutedGrammar({ ...substituted, id: finalId });\n  }, [selectedGrammar, selectedCulture, allCultures, cultureConfig, cultureId, existingGrammarIds]);\n\n  const toggleDep = (sourceId) => {\n    const newSelected = new Set(selectedDeps);\n    if (newSelected.has(sourceId)) {\n      newSelected.delete(sourceId);\n    } else {\n      newSelected.add(sourceId);\n    }\n    setSelectedDeps(newSelected);\n  };\n\n  const handleCopy = () => {\n    if (!substitutedGrammar) return;\n\n    const copiedLexemeLists = {};\n    const sourceCulture = allCultures[selectedCulture];\n    const existingListIds = Object.keys(cultureConfig?.naming?.lexemeLists || {});\n\n    selectedDeps.forEach((sourceId) => {\n      const sourceList = sourceCulture?.naming?.lexemeLists?.[sourceId];\n      if (sourceList) {\n        const newId = generateUniqueId(cultureId, sourceId, [\n          ...existingListIds,\n          ...Object.keys(copiedLexemeLists),\n        ]);\n        copiedLexemeLists[newId] = {\n          ...sourceList,\n          id: newId,\n          description: sourceList.description\n            ? `${sourceList.description} (copied from ${selectedCulture})`\n            : `Copied from ${selectedCulture}`,\n        };\n      }\n    });\n\n    let finalGrammar = { ...substitutedGrammar, id: newGrammarId };\n    if (Object.keys(copiedLexemeLists).length > 0) {\n      const idMapping = {};\n      selectedDeps.forEach((sourceId) => {\n        const suffix = sourceId.replace(/^[^_]+_/, \"\");\n        const newId = Object.keys(copiedLexemeLists).find((k) => {\n          const kSuffix = k.replace(/^[^_]+_/, \"\").replace(/_\\d+$/, \"\");\n          return kSuffix === suffix;\n        });\n        if (newId) idMapping[sourceId] = newId;\n      });\n\n      const newRules = {};\n      for (const [key, productions] of Object.entries(finalGrammar.rules || {})) {\n        newRules[key] = productions.map((prod) =>\n          prod.map((token) => applySlotIdMapping(token, idMapping))\n        );\n      }\n      finalGrammar = { ...finalGrammar, rules: newRules };\n    }\n\n    onCopy(finalGrammar, copiedLexemeLists);\n  };\n\n  const selectedCultureGrammars = selectedCulture\n    ? (allCultures[selectedCulture]?.naming?.grammars || []).filter(\n        (g) => Object.keys(g.rules || {}).length > 0\n      )\n    : [];\n\n  const footer = (\n    <>\n      <button className=\"secondary\" onClick={onClose}>\n        Cancel\n      </button>\n      <button\n        className=\"primary\"\n        onClick={handleCopy}\n        disabled={!substitutedGrammar || !newGrammarId.trim()}\n      >\n        Copy Grammar\n        {selectedDeps.size > 0 && (\n          ` + ${selectedDeps.size} List${selectedDeps.size > 1 ? \"s\" : \"\"}`\n        )}\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onClose} title=\"Copy Grammar from Another Culture\" className=\"copy-modal\" footer={footer}>\n      <div className=\"form-group\">\n        <label htmlFor=\"source-culture\">Source Culture</label>\n        <select id=\"source-culture\"\n          value={selectedCulture || \"\"}\n          onChange={(e) => {\n            setSelectedCulture(e.target.value || null);\n            setSelectedGrammar(null);\n          }}\n        >\n          <option value=\"\">Select a culture...</option>\n          {otherCultures.map((c) => (\n            <option key={c.id} value={c.id}>\n              {c.name} ({c.grammars.filter((g) => Object.keys(g.rules || {}).length > 0).length}{\" \"}\n              grammars)\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {selectedCulture && (\n        <div className=\"form-group\">\n          <label htmlFor=\"grammar-to-copy\">Grammar to Copy</label>\n          {selectedCultureGrammars.length === 0 ? (\n            <p className=\"text-muted text-small\">No grammars with rules in this culture.</p>\n          ) : (\n            <select\n              id=\"grammar-to-copy\"\n              value={selectedGrammar || \"\"}\n              onChange={(e) => setSelectedGrammar(e.target.value || null)}\n            >\n              <option value=\"\">Select a grammar...</option>\n              {selectedCultureGrammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      )}\n\n      {substitutedGrammar && (\n        <div className=\"copy-preview\">\n          <div className=\"form-group\">\n            <label htmlFor=\"new-grammar-id\">New Grammar ID</label>\n            <input id=\"new-grammar-id\"\n              value={newGrammarId}\n              onChange={(e) => setNewGrammarId(e.target.value)}\n              placeholder=\"grammar_id\"\n            />\n          </div>\n\n          {(dependencies.missing.length > 0 || dependencies.existing.length > 0) && (\n            <div className=\"dependency-section\">\n              <h5>Lexeme List Dependencies</h5>\n\n              {dependencies.existing.length > 0 && (\n                <div className=\"dependency-list mb-sm\">\n                  {dependencies.existing.map((dep) => (\n                    <div key={dep.sourceId} className=\"dependency-item exists\">\n                      <span>\u2713</span>\n                      <span>\n                        <code>{dep.sourceId}</code> \u2192 <code>{dep.targetId}</code>\n                      </span>\n                    </div>\n                  ))}\n                </div>\n              )}\n\n              {dependencies.missing.length > 0 && (\n                <>\n                  <p className=\"text-small text-muted mb-sm\">\n                    These lexeme lists are missing. Select which to copy:\n                  </p>\n                  <div className=\"dependency-list\">\n                    {dependencies.missing.map((dep) => (\n                      <label key={dep.sourceId} className=\"dependency-item missing\">\n                        <input\n                          type=\"checkbox\"\n                          checked={selectedDeps.has(dep.sourceId)}\n                          onChange={() => toggleDep(dep.sourceId)}\n                        />\n                        <span>\n                          <code>{dep.sourceId}</code> ({dep.entries} entries)\n                        </span>\n                      </label>\n                    ))}\n                  </div>\n                </>\n              )}\n            </div>\n          )}\n\n          <div className=\"copy-preview-section\">\n            <h4>Substitutions Applied</h4>\n            <p className=\"text-small text-muted\">\n              References to source culture resources are substituted with matching resources\n              from this culture.\n            </p>\n            <div className=\"copy-preview-rules\">\n              {Object.entries(substitutedGrammar.rules || {}).map(([key, productions]) => (\n                <div key={key} className=\"rule-card\">\n                  <div className=\"font-mono text-small\">\n                    <strong className=\"text-gold\">{key}</strong>\n                    <span className=\"text-muted\"> \u2192 </span>\n                    {productions.map((prod, i) => (\n                      <span key={i}>\n                        <span className=\"text-light\">{prod.join(\" \")}</span>\n                        {i < productions.length - 1 && <span className=\"text-muted\"> | </span>}\n                      </span>\n                    ))}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          <div className=\"copy-preview-section\">\n            <h4>Sample Names</h4>\n            <GrammarPreview\n              grammar={substitutedGrammar}\n              domains={cultureConfig?.naming?.domains || []}\n              lexemeLists={cultureConfig?.naming?.lexemeLists || EMPTY_LEXEME_LISTS}\n            />\n          </div>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  allCultures,\n  existingGrammarIds,\n  onCopy,\n  onClose,\n}", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; existingGrammarIds: any; onCopy: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["label", "option", "p", "input", "h5", "span", "code", "h4", "strong", "GrammarPreview"], "hookCalls": [{"name": "useState", "count": 6}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "../../../lib/browser-generator", "specifiers": ["previewGrammarNames"], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/CopyLexemeModal.jsx::CopyLexemeModal", "name": "CopyLexemeModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/CopyLexemeModal.jsx", "sourceCode": "/**\n * Copy Lexeme List Modal - copy lexeme lists from another culture\n */\nexport function CopyLexemeModal({ cultureId, allCultures, existingListIds, onCopy, onClose }) {\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [selectedLists, setSelectedLists] = useState(new Set());\n\n  const otherCultures = Object.entries(allCultures || {})\n    .filter(([id]) => id !== cultureId)\n    .map(([id, config]) => ({\n      id,\n      name: config.name || id,\n      lexemeLists: config.naming?.lexemeLists || {},\n    }));\n\n  const selectedCultureLists = selectedCulture\n    ? Object.entries(allCultures[selectedCulture]?.naming?.lexemeLists || {})\n    : [];\n\n  const toggleList = (listId) => {\n    const newSelected = new Set(selectedLists);\n    if (newSelected.has(listId)) {\n      newSelected.delete(listId);\n    } else {\n      newSelected.add(listId);\n    }\n    setSelectedLists(newSelected);\n  };\n\n  const selectAll = () => {\n    setSelectedLists(new Set(selectedCultureLists.map(([id]) => id)));\n  };\n\n  const selectNone = () => {\n    setSelectedLists(new Set());\n  };\n\n  const handleCopy = () => {\n    if (selectedLists.size === 0) return;\n\n    const sourceCulture = allCultures[selectedCulture];\n    const copiedLists = {};\n    const usedIds = [...existingListIds];\n\n    selectedLists.forEach((listId) => {\n      const sourceList = sourceCulture?.naming?.lexemeLists?.[listId];\n      if (sourceList) {\n        const newId = generateUniqueId(cultureId, listId, usedIds);\n        usedIds.push(newId);\n\n        copiedLists[newId] = {\n          ...sourceList,\n          id: newId,\n          description: sourceList.description\n            ? `${sourceList.description} (copied from ${selectedCulture})`\n            : `Copied from ${selectedCulture}`,\n        };\n      }\n    });\n\n    onCopy(copiedLists);\n  };\n\n  const footer = (\n    <>\n      <button className=\"secondary\" onClick={onClose}>\n        Cancel\n      </button>\n      <button className=\"primary\" onClick={handleCopy} disabled={selectedLists.size === 0}>\n        Copy{\" \"}\n        {(() => {\n          if (selectedLists.size === 0) return \"Lists\";\n          const plural = selectedLists.size > 1 ? \"s\" : \"\";\n          return `${selectedLists.size} List${plural}`;\n        })()}\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onClose} title=\"Copy Lexeme Lists from Another Culture\" className=\"copy-modal\" footer={footer}>\n      <div className=\"form-group\">\n        <label htmlFor=\"source-culture\">Source Culture</label>\n        <select id=\"source-culture\"\n          value={selectedCulture || \"\"}\n          onChange={(e) => {\n            setSelectedCulture(e.target.value || null);\n            setSelectedLists(new Set());\n          }}\n        >\n          <option value=\"\">Select a culture...</option>\n          {otherCultures.map((c) => (\n            <option key={c.id} value={c.id}>\n              {c.name} ({Object.keys(c.lexemeLists).length} lists)\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {selectedCulture && selectedCultureLists.length > 0 && (\n        <div className=\"form-group\">\n          <div className=\"flex justify-between align-center mb-sm\">\n            <span className=\"mb-0\">Select Lists to Copy</span>\n            <div className=\"flex gap-sm\">\n              <button className=\"secondary sm\" onClick={selectAll}>\n                All\n              </button>\n              <button className=\"secondary sm\" onClick={selectNone}>\n                None\n              </button>\n            </div>\n          </div>\n          <div className=\"copy-list-grid\">\n            {selectedCultureLists.map(([listId, list]) => (\n              // eslint-disable-next-line jsx-a11y/label-has-associated-control\n              <label key={listId} className=\"copy-list-item\">\n                <input\n                  type=\"checkbox\"\n                  checked={selectedLists.has(listId)}\n                  onChange={() => toggleList(listId)}\n                />\n                <div className=\"copy-list-item-info\">\n                  <strong>{listId}</strong>\n                  <span className=\"text-muted text-small\">\n                    {list.entries?.length || 0} entries\n                    {list.source === \"llm\" && \" \u2022 LLM\"}\n                    {list.source === \"manual\" && \" \u2022 Manual\"}\n                  </span>\n                </div>\n              </label>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {selectedCulture && selectedCultureLists.length === 0 && (\n        <p className=\"text-muted\">No lexeme lists in this culture.</p>\n      )}\n\n      {selectedLists.size > 0 && (\n        <div className=\"copy-preview\">\n          <h4>\n            Will Copy {selectedLists.size} List{selectedLists.size > 1 ? \"s\" : \"\"}\n          </h4>\n          <p className=\"text-small text-muted\">\n            Lists will be renamed with &quot;{cultureId}_&quot; prefix.\n          </p>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ cultureId, allCultures, existingListIds, onCopy, onClose }", "type": "{ cultureId: any; allCultures: any; existingListIds: any; onCopy: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["label", "option", "span", "button", "input", "strong", "p", "h4"], "hookCalls": [{"name": "useState", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}]}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::DomainTab", "name": "DomainTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "strong", "code", "div"], "hookCalls": [{"name": "useState", "count": 4}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::LexemesTab", "name": "LexemesTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "span", "div", "h4", "strong", "p", "CopyLexemeModal"], "hookCalls": [{"name": "useState", "count": 9}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::GrammarsTab", "name": "GrammarsTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "code", "p", "strong", "GrammarPreview", "GrammarHelpModal", "CopyGrammarModal"], "hookCalls": [{"name": "useState", "count": 8}, {"name": "useRef", "count": 3}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "p", "strong", "span", "ProfileModal"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "p", "strong", "span", "ProfileModal"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::StrategyGroupEditor", "name": "StrategyGroupEditor", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Strategy group editor component\n */\nexport default function StrategyGroupEditor({\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}) {\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n  const hasConditions = !!group.conditions;\n\n  const toggleConditions = () => {\n    const groups = [...editedProfile.strategyGroups];\n    if (hasConditions) {\n      groups[groupIdx] = { ...groups[groupIdx], conditions: null };\n    } else {\n      groups[groupIdx] = {\n        ...groups[groupIdx],\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      };\n    }\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  return (\n    <div className={`strategy-group ${hasConditions ? \"conditional\" : \"default\"}`}>\n      <div className=\"flex justify-between align-center mb-md\">\n        <div className=\"flex align-center gap-md\">\n          <input\n            value={group.name || \"\"}\n            onChange={(e) => {\n              const groups = [...editedProfile.strategyGroups];\n              groups[groupIdx] = { ...groups[groupIdx], name: e.target.value };\n              setEditedProfile({ ...editedProfile, strategyGroups: groups });\n            }}\n            placeholder=\"Group name\"\n            className=\"input-group-name\"\n          />\n          <div className=\"flex align-center gap-xs\">\n            <label className=\"text-xs text-muted\">Priority:\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => {\n                const groups = [...editedProfile.strategyGroups];\n                groups[groupIdx] = { ...groups[groupIdx], priority: v ?? 0 };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"input-priority\"\n              integer\n            />\n            </label>\n          </div>\n          <button className=\"secondary btn-xs\" onClick={toggleConditions}>\n            {hasConditions ? \"Remove Conditions\" : \"Add Conditions\"}\n          </button>\n        </div>\n        <button className=\"danger text-xs\" onClick={() => onDeleteGroup(groupIdx)}>\n          Delete Group\n        </button>\n      </div>\n\n      {/* Group Conditions */}\n      {hasConditions && (\n        <div className=\"conditions-panel\">\n          <div className=\"text-xs font-bold text-purple mb-md\">Group Conditions</div>\n\n          {/* Row 1: Entity Types and Prominence */}\n          <div className=\"form-grid-2 mb-md\">\n            {/* Entity Types */}\n            <div>\n              <label className=\"condition-label\">Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => onConditionChange(groupIdx, \"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            {/* Prominence */}\n            <div>\n              <label className=\"condition-label\">Prominence\n              <MultiSelectPills\n                options={prominenceLevels}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => onConditionChange(groupIdx, \"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n          </div>\n\n          {/* Row 2: Subtypes and Tags */}\n          <div className=\"form-grid-2\">\n            {/* Subtypes */}\n            <div>\n              <div className=\"flex justify-between align-center mb-xs\">\n                <span className=\"condition-label mb-0\">Subtypes</span>\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) =>\n                      onConditionChange(groupIdx, \"subtypeMatchAll\", e.target.checked)\n                    }\n                    className=\"checkbox-small\"\n                  />\n                  Match all\n                </label>\n              </div>\n              <TagsInput\n                value={group.conditions?.subtypes || []}\n                onChange={(val) => onConditionChange(groupIdx, \"subtypes\", val)}\n                placeholder=\"Type and press space...\"\n              />\n            </div>\n\n            {/* Tags */}\n            <div>\n              <label className=\"condition-label\">Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => onConditionChange(groupIdx, \"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => onConditionChange(groupIdx, \"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Strategies */}\n      {group.strategies.length === 0 && (\n        <div className=\"text-muted text-small mb-sm\">No strategies. Add one below.</div>\n      )}\n\n      {group.strategies.map((strategy, stratIdx) => (\n        <div key={stratIdx} className={`strategy-card ${strategy.type}`}>\n          <div className=\"flex justify-between align-center mb-sm\">\n            <div className=\"flex align-center gap-sm\">\n              <strong className=\"capitalize text-small\">{strategy.type}</strong>\n              <span className=\"weight-badge\">\n                {groupTotalWeight > 0 ? ((strategy.weight / groupTotalWeight) * 100).toFixed(0) : 0}\n                %\n              </span>\n            </div>\n            <button className=\"danger btn-xs\" onClick={() => onDeleteStrategy(groupIdx, stratIdx)}>\n              Remove\n            </button>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.05\"\n            value={strategy.weight}\n            onChange={(e) => onWeightChange(groupIdx, stratIdx, e.target.value)}\n            className=\"strategy-slider\"\n          />\n\n          {strategy.type === \"phonotactic\" && (\n            <select\n              value={strategy.domainId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], domainId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select domain...</option>\n              {domains.map((d) => (\n                <option key={d.id} value={d.id}>\n                  {d.id}\n                </option>\n              ))}\n            </select>\n          )}\n\n          {strategy.type === \"grammar\" && (\n            <select\n              value={strategy.grammarId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], grammarId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select grammar...</option>\n              {grammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      ))}\n\n      <div className=\"flex gap-xs mt-sm\">\n        <button\n          className=\"secondary text-xs\"\n          onClick={() => onAddStrategy(groupIdx, \"phonotactic\")}\n        >\n          + Phonotactic\n        </button>\n        <button className=\"secondary text-xs\" onClick={() => onAddStrategy(groupIdx, \"grammar\")}>\n          + Grammar\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; domains: any; grammars: any; entityKinds: any; prominenceLevels: any; tagRegistry: any; editedProfile: any; setEditedProfile: any; onDeleteGroup: any; onAddStrategy: any; onDeleteStrategy: any; onWeightChange: any; onConditionChange: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["input", "NumberInput", "button", "div", "MultiSelectPills", "span", "TagsInput", "TagSelector", "strong", "option"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::TestPanel", "name": "TestPanel", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Test panel for generating test names from a profile\n */\nexport default function TestPanel({\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}) {\n  return (\n    <div className=\"test-panel\">\n      <div className=\"flex justify-between align-center mb-md\">\n        <h4 className=\"mt-0 mb-0\">Test: {profile.id}</h4>\n        <div className=\"flex gap-sm\">\n          <button\n            className=\"primary text-small\"\n            onClick={() => onTest(profile, 10)}\n            disabled={testLoading}\n          >\n            {testLoading ? \"...\" : \"Generate\"}\n          </button>\n          <button className=\"secondary text-small\" onClick={onClose}>\n            Close\n          </button>\n        </div>\n      </div>\n\n      {testError && <div className=\"error mb-md text-small\">{testError}</div>}\n\n      {strategyUsage && (\n        <div className=\"strategy-usage-panel\">\n          {Object.entries(strategyUsage)\n            .filter(([, count]) => count > 0)\n            .map(([strategy, count]) => (\n              <span key={strategy} className=\"mr-sm\">\n                {strategy}: {count}\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-names-list\">\n          {testNames.map((name, i) => (\n            <div key={i} className=\"test-name-item\">\n              {name}\n            </div>\n          ))}\n        </div>\n      ) : (\n        <p className=\"text-muted text-small mt-0 mb-0\">Click Generate to test this profile</p>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}", "type": "{ profile: any; testNames: any; testLoading: any; testError: any; strategyUsage: any; onTest: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h4", "button", "div", "span", "p"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::MultiSelectPills", "name": "MultiSelectPills", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Multi-select pills component for selecting multiple options\n * Note: Consider replacing with ChipSelect from shared-components in future\n */\nexport default function MultiSelectPills({ options, selected, onChange, allLabel = \"All\" }) {\n  const isAllSelected = selected.length === 0 || (selected.length === 1 && selected[0] === \"*\");\n\n  const handleToggle = (value) => {\n    if (value === \"*\") {\n      onChange([]);\n    } else {\n      const newSelected = selected.filter((s) => s !== \"*\");\n      if (newSelected.includes(value)) {\n        const filtered = newSelected.filter((s) => s !== value);\n        onChange(filtered.length === 0 ? [] : filtered);\n      } else {\n        onChange([...newSelected, value]);\n      }\n    }\n  };\n\n  return (\n    <div className=\"flex flex-wrap gap-xs\">\n      <button\n        type=\"button\"\n        onClick={() => handleToggle(\"*\")}\n        className={`pill-button ${isAllSelected ? \"selected-gold\" : \"\"}`}\n      >\n        {allLabel}\n      </button>\n      {options.map((opt) => {\n        const isSelected = !isAllSelected && selected.includes(opt);\n        return (\n          <button\n            key={opt}\n            type=\"button\"\n            onClick={() => handleToggle(opt)}\n            className={`pill-button ${isSelected ? \"selected-green\" : \"\"}`}\n          >\n            {opt}\n          </button>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ options, selected, onChange, allLabel = \"All\" }", "type": "{ options: any; selected: any; onChange: any; allLabel?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::TagsInput", "name": "TagsInput", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Tags input with auto-split on space/comma\n * Note: Consider using TagSelector from shared-components in future\n */\nexport default function TagsInput({ value, onChange, placeholder }) {\n  const tags = Array.isArray(value) ? value : [];\n\n  const handleKeyDown = (e) => {\n    if (e.key === \" \" || e.key === \",\" || e.key === \"Enter\") {\n      e.preventDefault();\n      const input = e.target.value.trim();\n      if (input && !tags.includes(input)) {\n        onChange([...tags, input]);\n      }\n      e.target.value = \"\";\n    } else if (e.key === \"Backspace\" && e.target.value === \"\" && tags.length > 0) {\n      onChange(tags.slice(0, -1));\n    }\n  };\n\n  const handleRemove = (tag) => {\n    onChange(tags.filter((t) => t !== tag));\n  };\n\n  return (\n    <div className=\"tags-input-container\">\n      {tags.map((tag) => (\n        <span key={tag} className=\"tag-chip\">\n          {tag}\n          <button type=\"button\" onClick={() => handleRemove(tag)} className=\"tag-remove-btn\">\n            x\n          </button>\n        </span>\n      ))}\n      <input\n        type=\"text\"\n        onKeyDown={handleKeyDown}\n        placeholder={tags.length === 0 ? placeholder : \"\"}\n        className=\"tags-input\"\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ value, onChange, placeholder }", "type": "{ value: any; onChange: any; placeholder: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["button", "input"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::OverviewTab", "name": "OverviewTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function OverviewTab({\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}) {\n  const matchCount = generatorUsage?.totalMatches || 0;\n  const groups = profile.strategyGroups || [];\n\n  // Drag state\n  const [draggedIdx, setDraggedIdx] = useState(null);\n  const [dragOverIdx, setDragOverIdx] = useState(null);\n  const dragNodeRef = useRef(null);\n\n  const handleDragStart = (e, idx) => {\n    setDraggedIdx(idx);\n    dragNodeRef.current = e.target;\n    e.target.classList.add(\"dragging\");\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setData(\"text/plain\", idx);\n  };\n\n  const handleDragEnd = (e) => {\n    e.target.classList.remove(\"dragging\");\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n    dragNodeRef.current = null;\n  };\n\n  const handleDragOver = (e, idx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === idx) return;\n    setDragOverIdx(idx);\n  };\n\n  const handleDragLeave = () => {\n    setDragOverIdx(null);\n  };\n\n  const handleDrop = (e, dropIdx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === dropIdx) return;\n\n    const newGroups = [...groups];\n    const [draggedGroup] = newGroups.splice(draggedIdx, 1);\n    newGroups.splice(dropIdx, 0, draggedGroup);\n\n    onChange({ ...profile, strategyGroups: newGroups });\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n  };\n\n  const getStrategyTypeCounts = (group) => {\n    const counts = { phonotactic: 0, grammar: 0 };\n    (group.strategies || []).forEach((s) => {\n      if (counts[s.type] !== undefined) counts[s.type]++;\n    });\n    return counts;\n  };\n\n  return (\n    <div className=\"profile-overview-tab\">\n      {/* Profile ID */}\n      <div className=\"form-group\">\n        <label htmlFor=\"profile-id\">Profile ID</label>\n        <input id=\"profile-id\"\n          value={profile.id || \"\"}\n          onChange={(e) => onChange({ ...profile, id: e.target.value })}\n          placeholder=\"e.g., culture_default\"\n        />\n        <small className=\"text-muted\">\n          Unique identifier used to reference this profile in generators\n        </small>\n      </div>\n\n      {/* Default Profile Toggle */}\n      <div className=\"form-group\">\n        <label className=\"checkbox-label\">\n          <input\n            type=\"checkbox\"\n            checked={profile.isDefault || false}\n            onChange={(e) => onChange({ ...profile, isDefault: e.target.checked })}\n          />\n          <span>Default Profile</span>\n        </label>\n        <small className=\"text-muted\">\n          Use this profile when no entity kind matches. Only one profile should be marked as\n          default.\n        </small>\n      </div>\n\n      {/* Entity Kinds Binding */}\n      <div className=\"form-group\">\n        <label>Entity Kinds\n        <MultiSelectPills\n          options={entityKinds}\n          selected={profile.entityKinds || []}\n          onChange={(kinds) => onChange({ ...profile, entityKinds: kinds })}\n          allLabel=\"Any\"\n        />\n        </label>\n        <small className=\"text-muted\">\n          Profile applies when generating names for these entity kinds. &quot;Any&quot; means use default\n          profile logic.\n        </small>\n      </div>\n\n      {/* Stats */}\n      <div className=\"profile-stats\">\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.length}</div>\n          <div className=\"stat-label\">Strategy Groups</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">\n            {groups.reduce((sum, g) => sum + (g.strategies?.length || 0), 0)}\n          </div>\n          <div className=\"stat-label\">Total Strategies</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.filter((g) => g.conditions).length}</div>\n          <div className=\"stat-label\">Conditional</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{matchCount}</div>\n          <div className=\"stat-label\">Generator Matches</div>\n        </div>\n      </div>\n\n      {/* Groups Overview */}\n      <div className=\"groups-overview\">\n        <div className=\"groups-header\">\n          <h4>Strategy Groups</h4>\n          <span className=\"text-muted text-small\">Drag to reorder priority</span>\n        </div>\n\n        {groups.length === 0 ? (\n          <div className=\"empty-groups\">\n            <p>No strategy groups yet. Add one using the buttons below the sidebar.</p>\n          </div>\n        ) : (\n          <div className=\"groups-list\">\n            {groups.map((group, idx) => {\n              const isConditional = !!group.conditions;\n              const counts = getStrategyTypeCounts(group);\n              const isDragOver = dragOverIdx === idx && draggedIdx !== idx;\n\n              return (\n                <div\n                  key={idx}\n                  className={`group-row ${isDragOver ? \"drag-over\" : \"\"} ${draggedIdx === idx ? \"dragging\" : \"\"}`}\n                  draggable\n                  onDragStart={(e) => handleDragStart(e, idx)}\n                  onDragEnd={handleDragEnd}\n                  onDragOver={(e) => handleDragOver(e, idx)}\n                  onDragLeave={handleDragLeave}\n                  onDrop={(e) => handleDrop(e, idx)}\n                  onClick={() => onNavigateToGroup?.(idx)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div className=\"drag-handle\" title=\"Drag to reorder\">\n                    <span>\u22ee\u22ee</span>\n                  </div>\n\n                  <div className=\"group-info\">\n                    <span className=\"group-name\">{group.name || `Group ${idx + 1}`}</span>\n                    <span\n                      className={`group-type-badge ${isConditional ? \"conditional\" : \"default\"}`}\n                    >\n                      {isConditional ? \"\ud83c\udfaf Conditional\" : \"\ud83d\udce6 Default\"}\n                    </span>\n                  </div>\n\n                  <div className=\"group-meta\">\n                    <span className=\"priority-badge\" title=\"Priority\">\n                      P{group.priority || 0}\n                    </span>\n                    {counts.phonotactic > 0 && (\n                      <span className=\"strategy-count phonotactic\" title=\"Phonotactic strategies\">\n                        {counts.phonotactic}\n                      </span>\n                    )}\n                    {counts.grammar > 0 && (\n                      <span className=\"strategy-count grammar\" title=\"Grammar strategies\">\n                        {counts.grammar}\n                      </span>\n                    )}\n                    {counts.phonotactic === 0 && counts.grammar === 0 && (\n                      <span className=\"no-strategies\">No strategies</span>\n                    )}\n                  </div>\n\n                  <div className=\"group-arrow\">\u2192</div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n\n        <p className=\"text-muted text-xs mt-sm\">\n          Groups are evaluated by priority (highest first). First matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Actions */}\n      <div className=\"profile-actions\">\n        <button className=\"secondary\" onClick={onDuplicate}>\n          Duplicate Profile\n        </button>\n      </div>\n\n      {/* Danger Zone */}\n      <div className=\"danger-zone\">\n        <h4>Danger Zone</h4>\n        <button className=\"danger\" onClick={onDelete}>\n          Delete Profile\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}", "type": "{ profile: any; onChange: any; onDelete: any; onDuplicate: any; onNavigateToGroup: any; generatorUsage: any; entityKinds?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["label", "input", "small", "span", "MultiSelectPills", "div", "h4", "p", "button"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::SingleGroupTab", "name": "SingleGroupTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function SingleGroupTab({\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}) {\n  const hasConditions = !!group.conditions;\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n\n  // Compute available subtypes based on selected entity kinds\n  // worldSchema.hardState has: { kind, subtype: string[], status: string[] }\n  const availableSubtypes = useMemo(() => {\n    const selectedKinds = group.conditions?.entityKinds || [];\n    const entityDefs = worldSchema?.hardState || [];\n\n    // If no entity kinds selected, show all subtypes from all entity kinds\n    const kindsToCheck =\n      selectedKinds.length > 0\n        ? entityDefs.filter((e) => selectedKinds.includes(e.kind))\n        : entityDefs;\n\n    const subtypes = new Set();\n    kindsToCheck.forEach((entityDef) => {\n      // subtype is already a string array in hardState format\n      (entityDef.subtype || []).forEach((st) => {\n        if (st) subtypes.add(st);\n      });\n    });\n\n    return Array.from(subtypes).sort();\n  }, [group.conditions?.entityKinds, worldSchema]);\n\n  const updateGroup = (updates) => {\n    onChange({ ...group, ...updates });\n  };\n\n  const toggleConditions = () => {\n    if (hasConditions) {\n      updateGroup({ conditions: null });\n    } else {\n      updateGroup({\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      });\n    }\n  };\n\n  const handleConditionChange = (field, value) => {\n    updateGroup({\n      conditions: { ...group.conditions, [field]: value },\n    });\n  };\n\n  const handleAddStrategy = (type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n    updateGroup({\n      strategies: [...group.strategies, newStrategy],\n    });\n  };\n\n  const handleDeleteStrategy = (stratIdx) => {\n    updateGroup({\n      strategies: group.strategies.filter((_, i) => i !== stratIdx),\n    });\n  };\n\n  const handleWeightChange = (stratIdx, newWeight) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    updateGroup({ strategies });\n  };\n\n  const handleStrategyConfigChange = (stratIdx, field, value) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], [field]: value };\n    updateGroup({ strategies });\n  };\n\n  return (\n    <div className=\"single-group-tab\">\n      {/* Group Header */}\n      <div className=\"group-header-section\">\n        <div className=\"group-name-row\">\n          <div className=\"form-group\">\n            <label htmlFor=\"group-name\">Group Name</label>\n            <input id=\"group-name\"\n              value={group.name || \"\"}\n              onChange={(e) => updateGroup({ name: e.target.value })}\n              placeholder=\"e.g., Noble Names\"\n            />\n          </div>\n          <div className=\"form-group priority-field\">\n            <label>Priority\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => updateGroup({ priority: v ?? 0 })}\n              integer\n            />\n            </label>\n          </div>\n        </div>\n        <p className=\"text-muted text-small mt-0\">\n          Higher priority groups are evaluated first. The first matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Conditions Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Conditions</h4>\n          <button\n            className={`toggle-btn ${hasConditions ? \"active\" : \"\"}`}\n            onClick={toggleConditions}\n          >\n            {hasConditions ? \"Conditional\" : \"Always Match\"}\n          </button>\n        </div>\n\n        {hasConditions ? (\n          <div className=\"conditions-grid\">\n            <div className=\"condition-field\">\n              <label>Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => handleConditionChange(\"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Prominence\n              <MultiSelectPills\n                options={PROMINENCE_LEVELS}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => handleConditionChange(\"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>\n                Subtypes\n                <label className=\"match-all-toggle\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) => handleConditionChange(\"subtypeMatchAll\", e.target.checked)}\n                  />\n                  Match all\n                </label>\n              </label>\n              {availableSubtypes.length > 0 ? (\n                <MultiSelectPills\n                  options={availableSubtypes}\n                  selected={group.conditions?.subtypes || []}\n                  onChange={(val) => handleConditionChange(\"subtypes\", val)}\n                  allLabel=\"Any\"\n                />\n              ) : (\n                <p className=\"text-muted text-small sgt-no-subtypes\">\n                  {(group.conditions?.entityKinds?.length || 0) > 0\n                    ? \"Selected entity types have no subtypes defined\"\n                    : \"Select entity types to see available subtypes\"}\n                </p>\n              )}\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => handleConditionChange(\"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => handleConditionChange(\"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        ) : (\n          <p className=\"text-muted text-small\">\n            This group will always be considered. Click &quot;Always Match&quot; to add conditions.\n          </p>\n        )}\n      </div>\n\n      {/* Strategies Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Strategies</h4>\n          <div className=\"add-strategy-buttons\">\n            <button\n              className=\"add-btn phonotactic\"\n              onClick={() => handleAddStrategy(\"phonotactic\")}\n            >\n              + Phonotactic\n            </button>\n            <button className=\"add-btn grammar\" onClick={() => handleAddStrategy(\"grammar\")}>\n              + Grammar\n            </button>\n          </div>\n        </div>\n\n        {group.strategies.length === 0 ? (\n          <div className=\"empty-strategies\">\n            <p>No strategies yet. Add a strategy to define how names are generated.</p>\n          </div>\n        ) : (\n          <div className=\"strategies-list\">\n            {group.strategies.map((strategy, stratIdx) => (\n              <div key={stratIdx} className={`strategy-item ${strategy.type}`}>\n                <div className=\"strategy-header\">\n                  <span className=\"strategy-type\">{strategy.type}</span>\n                  <span className=\"strategy-weight\">\n                    {groupTotalWeight > 0\n                      ? Math.round((strategy.weight / groupTotalWeight) * 100)\n                      : 0}\n                    %\n                  </span>\n                  <button className=\"remove-btn\" onClick={() => handleDeleteStrategy(stratIdx)}>\n                    \u00d7\n                  </button>\n                </div>\n\n                <div className=\"strategy-body\">\n                  <div className=\"weight-slider\">\n                    <label htmlFor=\"weight\">Weight</label>\n                    <input id=\"weight\"\n                      type=\"range\"\n                      min=\"0\"\n                      max=\"1\"\n                      step=\"0.05\"\n                      value={strategy.weight}\n                      onChange={(e) => handleWeightChange(stratIdx, e.target.value)}\n                    />\n                  </div>\n\n                  {strategy.type === \"phonotactic\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"domain\">Domain</label>\n                      <select id=\"domain\"\n                        value={strategy.domainId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"domainId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select domain...</option>\n                        {domains.map((d) => (\n                          <option key={d.id} value={d.id}>\n                            {d.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n\n                  {strategy.type === \"grammar\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"grammar\">Grammar</label>\n                      <select id=\"grammar\"\n                        value={strategy.grammarId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"grammarId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select grammar...</option>\n                        {grammars.map((g) => (\n                          <option key={g.id} value={g.id}>\n                            {g.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n                </div>\n              </div>\n// ... (truncated)", "parameters": [{"name": "{\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; onChange: any; onDelete: any; domains: any; grammars: any; entityKinds: any; worldSchema: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["label", "input", "NumberInput", "p", "h4", "button", "MultiSelectPills", "TagSelector", "span", "option"], "hookCalls": [{"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js::TestTab", "name": "TestTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/index.js", "sourceCode": "export default function TestTab({ profile, cultureConfig }) {\n  const [testNames, setTestNames] = useState([]);\n  const [testLoading, setTestLoading] = useState(false);\n  const [testError, setTestError] = useState(null);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [count, setCount] = useState(10);\n\n  const handleTestNames = async () => {\n    if (!profile || !cultureConfig) return;\n\n    setTestLoading(true);\n    setTestError(null);\n    setTestNames([]);\n    setStrategyUsage(null);\n\n    try {\n      const result = await generateTestNames({\n        culture: cultureConfig,\n        profileId: profile.id,\n        count,\n        seed: `test-${Date.now()}`,\n      });\n\n      setTestNames(result.names || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setTestError(err.message);\n    } finally {\n      setTestLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"profile-test-tab\">\n      <div className=\"test-controls\">\n        <div className=\"test-count-control\">\n          <label>Count:\n          <NumberInput\n            min={1}\n            max={100}\n            value={count}\n            onChange={(v) => setCount(v ?? 10)}\n            integer\n          />\n          </label>\n        </div>\n        <button className=\"primary\" onClick={handleTestNames} disabled={testLoading}>\n          {testLoading ? \"Generating...\" : \"Generate Names\"}\n        </button>\n      </div>\n\n      {testError && <div className=\"error-box\">{testError}</div>}\n\n      {strategyUsage && Object.keys(strategyUsage).length > 0 && (\n        <div className=\"strategy-usage-summary\">\n          <span className=\"usage-label\">Strategy usage:</span>\n          {Object.entries(strategyUsage)\n            .filter(([, cnt]) => cnt > 0)\n            .map(([strategy, cnt]) => (\n              <span key={strategy} className=\"usage-item\">\n                <span className=\"usage-strategy\">{strategy}</span>\n                <span className=\"usage-count\">{cnt}</span>\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-results\">\n          <div className=\"results-header\">\n            <span className=\"results-count\">{testNames.length} names generated</span>\n          </div>\n          <div className=\"test-names-grid\">\n            {testNames.map((name, i) => (\n              <div key={i} className=\"test-name-card\">\n                {name}\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div className=\"empty-test-state\">\n          <p>Click &quot;Generate Names&quot; to test this profile</p>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ profile, cultureConfig }", "type": "{ profile: any; cultureConfig: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["NumberInput", "button", "div", "span", "p"], "hookCalls": [{"name": "useState", "count": 5}], "customHookCalls": [], "imports": []}]