[{"id": "apps/coherence-engine/webui/src/components/shared/index.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "apps/coherence-engine/webui/src/components/shared/index.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/shared/index.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "apps/coherence-engine/webui/src/components/shared/index.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/shared/MutationCard.jsx::MutationCard", "name": "MutationCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/shared/MutationCard.jsx", "sourceCode": "export function MutationCard({\n  mutation,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  entityOptions,\n  typeOptions,\n  createMutation,\n  titlePrefix,\n}) {\n  const [expanded, setExpanded] = useState(false);\n  const types = typeOptions || DEFAULT_MUTATION_TYPES;\n  const entityRefs = normalizeOptions(entityOptions);\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n  const pressureOptions = (pressures || []).map((p) => ({\n    value: p.id,\n    label: p.name || p.id,\n  }));\n  const tagRegistry = schema?.tagRegistry || [];\n\n  const update = (field, value) => {\n    onChange({ ...mutation, [field]: value });\n  };\n\n  const updateType = (value) => {\n    if (createMutation) {\n      onChange(createMutation(value));\n      return;\n    }\n    update(\"type\", value);\n  };\n\n  const fallbackLabel =\n    types.find((t) => t.value === mutation.type)?.label ||\n    MUTATION_TYPE_META[mutation.type]?.label ||\n    mutation.type;\n  const typeMeta = MUTATION_TYPE_META[mutation.type] || { icon: \"?\", color: \"#6b7280\" };\n  const headerLabel = titlePrefix ? `${titlePrefix}: ${fallbackLabel}` : fallbackLabel;\n\n  const getSummary = () => {\n    switch (mutation.type) {\n      case \"modify_pressure\":\n        return `${mutation.pressureId || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"set_tag\": {\n        const value = mutation.value !== undefined ? ` = ${mutation.value}` : \"\";\n        return `${mutation.entity || \"?\"} tag ${mutation.tag || \"?\"}${value}`;\n      }\n      case \"remove_tag\":\n        return `${mutation.entity || \"?\"} remove ${mutation.tag || \"?\"}`;\n      case \"change_status\":\n        return `${mutation.entity || \"?\"} -> ${mutation.newStatus || \"?\"}`;\n      case \"adjust_prominence\":\n        return `${mutation.entity || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"archive_relationship\": {\n        return `${mutation.entity || \"?\"} ${mutation.relationshipKind || \"?\"} with ${mutation.with || \"?\"}`;\n      }\n      case \"archive_all_relationships\": {\n        const dirLabel =\n          mutation.direction && mutation.direction !== \"both\" ? ` (${mutation.direction})` : \"\";\n        return `${mutation.entity || \"?\"} all ${mutation.relationshipKind || \"?\"}${dirLabel}`;\n      }\n      case \"adjust_relationship_strength\":\n        return `${mutation.kind || \"?\"} ${mutation.src || \"?\"} -> ${mutation.dst || \"?\"} ${formatDelta(mutation.delta)}`;\n      case \"create_relationship\": {\n        const arrow = mutation.bidirectional ? \"<->\" : \"->\";\n        return `${mutation.kind || \"?\"} ${mutation.src || \"?\"} ${arrow} ${mutation.dst || \"?\"}`;\n      }\n      case \"update_rate_limit\":\n        return \"track execution\";\n      case \"transfer_relationship\":\n        return `${mutation.entity || \"?\"} ${mutation.relationshipKind || \"?\"} from ${mutation.from || \"?\"} to ${mutation.to || \"?\"}`;\n      case \"for_each_related\": {\n        const actionCount = (mutation.actions || []).length;\n        return `${mutation.relationship || \"?\"} (${actionCount} action${actionCount !== 1 ? \"s\" : \"\"})`;\n      }\n      case \"conditional\": {\n        const thenCount = (mutation.thenActions || []).length;\n        const elseCount = (mutation.elseActions || []).length;\n        return `then: ${thenCount}, else: ${elseCount}`;\n      }\n      default:\n        return \"\";\n    }\n  };\n\n  const summary = getSummary();\n\n  return (\n    <div className=\"condition-card\">\n      <div className={`condition-card-header ${expanded ? \"\" : \"mb-0\"}`}>\n        <div className=\"condition-card-type\">\n          {/* eslint-disable-next-line local/no-inline-styles -- dynamic type color */}\n          <div className=\"condition-card-icon\" style={{ '--mc-icon-bg': `${typeMeta.color}20`, backgroundColor: 'var(--mc-icon-bg)' }}>\n            {typeMeta.icon}\n          </div>\n          <div>\n            <div className=\"condition-card-label\">{headerLabel}</div>\n            {summary && <div className=\"condition-card-summary\">{summary}</div>}\n          </div>\n        </div>\n        <div className=\"condition-card-actions\">\n          <button className=\"btn-icon\" onClick={() => setExpanded(!expanded)}>\n            {expanded ? \"^\" : \"v\"}\n          </button>\n          {onRemove && (\n            <button className=\"btn-icon btn-icon-danger\" onClick={onRemove}>\n              x\n            </button>\n          )}\n        </div>\n      </div>\n\n      {expanded && (\n        <div className=\"condition-card-fields\">\n          <div className=\"form-grid mc-fields-full\">\n            <ReferenceDropdown\n              label=\"Type\"\n              value={mutation.type}\n              onChange={updateType}\n              options={types}\n            />\n\n            {mutation.type === \"modify_pressure\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Pressure\"\n                  value={mutation.pressureId || \"\"}\n                  onChange={(v) => update(\"pressureId\", v)}\n                  options={pressureOptions}\n                  placeholder=\"Select pressure...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Delta\n                  <NumberInput value={mutation.delta} onChange={(v) => update(\"delta\", v ?? 0)} />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {(mutation.type === \"set_tag\" || mutation.type === \"remove_tag\") && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Tag\n                  <TagSelector\n                    value={mutation.tag ? [mutation.tag] : []}\n                    onChange={(tags) => update(\"tag\", tags[0] || \"\")}\n                    tagRegistry={tagRegistry}\n                    placeholder=\"Select tag...\"\n                    singleSelect\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"set_tag\" && (\n              <>\n                <div className=\"form-group\">\n                  <label htmlFor=\"value-optional\" className=\"label\">Value (optional)</label>\n                  <input id=\"value-optional\"\n                    type=\"text\"\n                    value={mutation.value !== undefined ? String(mutation.value) : \"\"}\n                    onChange={(e) => update(\"value\", parseTagValue(e.target.value))}\n                    className=\"input\"\n                    placeholder=\"true\"\n                    disabled={Boolean(mutation.valueFrom)}\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label htmlFor=\"value-source-optional\" className=\"label\">Value Source (optional)</label>\n                  <input id=\"value-source-optional\"\n                    type=\"text\"\n                    value={mutation.valueFrom || \"\"}\n                    onChange={(e) => update(\"valueFrom\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"e.g., cluster_id\"\n                  />\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"change_status\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label htmlFor=\"new-status\" className=\"label\">New Status</label>\n                  <input id=\"new-status\"\n                    type=\"text\"\n                    value={mutation.newStatus || \"\"}\n                    onChange={(e) => update(\"newStatus\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"e.g., active\"\n                  />\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"adjust_prominence\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Entity\"\n                  value={mutation.entity || \"\"}\n                  onChange={(v) => update(\"entity\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select entity...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Delta\n                  <NumberInput\n                    value={mutation.delta}\n                    onChange={(v) => update(\"delta\", v ?? 0)}\n                    placeholder=\"e.g., 0.25 or -0.15\"\n                  />\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"create_relationship\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Relationship Kind\"\n                  value={mutation.kind || \"\"}\n                  onChange={(v) => update(\"kind\", v)}\n                  options={relationshipKindOptions}\n                  placeholder=\"Select relationship...\"\n                />\n                <ReferenceDropdown\n                  label=\"Source\"\n                  value={mutation.src || \"\"}\n                  onChange={(v) => update(\"src\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select source...\"\n                />\n                <ReferenceDropdown\n                  label=\"Destination\"\n                  value={mutation.dst || \"\"}\n                  onChange={(v) => update(\"dst\", v)}\n                  options={entityRefs}\n                  placeholder=\"Select destination...\"\n                />\n                <div className=\"form-group\">\n                  <label className=\"label\">Strength\n                  <NumberInput\n                    value={mutation.strength}\n                    onChange={(v) => update(\"strength\", v)}\n                    min={0}\n                    max={1}\n                    allowEmpty\n                  />\n                  </label>\n                </div>\n                <div className=\"form-group\">\n                  <label htmlFor=\"category-optional\" className=\"label\">Category (optional)</label>\n                  <input id=\"category-optional\"\n                    type=\"text\"\n                    value={mutation.category || \"\"}\n                    onChange={(e) => update(\"category\", e.target.value || undefined)}\n                    className=\"input\"\n                    placeholder=\"Optional\"\n                  />\n                </div>\n                <div className=\"form-group\">\n                  <label className=\"checkbox-label\">\n                    <input\n                      type=\"checkbox\"\n                      checked={mutation.bidirectional || false}\n                      onChange={(e) => update(\"bidirectional\", e.target.checked || undefined)}\n                      className=\"checkbox\"\n                    />\n                    Bidirectional\n                  </label>\n                </div>\n              </>\n            )}\n\n            {mutation.type === \"adjust_relationship_strength\" && (\n              <>\n                <ReferenceDropdown\n                  label=\"Relationship Kind\"\n                  value={mutation.kind || \"\"}\n                  onChange={(v) => update(\"kind\", v)}\n                  options={relationshipKindOptions}\n// ... (truncated)", "parameters": [{"name": "{\n  mutation,\n  onChange,\n  onRemove,\n  schema,\n  pressures,\n  entityOptions,\n  typeOptions,\n  createMutation,\n  titlePrefix,\n}", "type": "{ mutation: any; onChange: any; onRemove: any; schema: any; pressures: any; entityOptions: any; typeOptions: any; createMutation: any; titlePrefix: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "button", "ReferenceDropdown", "NumberInput", "TagSelector", "label", "input", "code", "MutationCard"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "NumberInput"], "category": "internal"}, {"source": "@the-canonry/shared-components/TagSelector", "specifiers": ["TagSelector"], "category": "external"}, {"source": "../actions/constants", "specifiers": ["MUTATION_TYPE_META", "MUTATION_TYPE_ORDER"], "category": "internal"}, {"source": "./MutationCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/shared/SelectionRuleEditor.jsx::SelectionRuleEditor", "name": "SelectionRuleEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/shared/SelectionRuleEditor.jsx", "sourceCode": "export function SelectionRuleEditor({\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  showFilters = true,\n  allowAnyKind = false,\n  showExcludeSubtypes = false,\n}) {\n  const selection = value || { strategy: \"by_kind\" };\n\n  const baseKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n  const entityKindOptions = allowAnyKind\n    ? [{ value: \"any\", label: \"Any kind\" }, ...baseKindOptions]\n    : baseKindOptions;\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateSelection = (field, fieldValue) => {\n    onChange({ ...selection, [field]: fieldValue });\n  };\n\n  const updateSelectionMultiple = (updates) => {\n    onChange({ ...selection, ...updates });\n  };\n\n  const referenceOptions = (availableRefs.length > 0 ? availableRefs : [\"$target\"]).map((ref) => ({\n    value: ref,\n    label: ref,\n  }));\n\n  return (\n    <div>\n      <div className=\"form-grid\">\n        <ReferenceDropdown\n          label=\"Selection Strategy\"\n          value={selection.strategy || \"by_kind\"}\n          onChange={(v) => updateSelection(\"strategy\", v)}\n          options={[\n            { value: \"by_kind\", label: \"By Entity Kind\" },\n            { value: \"by_preference_order\", label: \"By Subtype Preference\" },\n            { value: \"by_relationship\", label: \"By Relationship Presence\" },\n            { value: \"by_proximity\", label: \"By Proximity\" },\n            { value: \"by_prominence\", label: \"By Prominence\" },\n          ]}\n        />\n\n        {showPickStrategy && (\n          <ReferenceDropdown\n            label=\"Pick Strategy\"\n            value={selection.pickStrategy || \"random\"}\n            onChange={(v) => updateSelection(\"pickStrategy\", v)}\n            options={PICK_STRATEGIES}\n          />\n        )}\n\n        {showMaxResults && (\n          <div className=\"form-group\">\n            <label className=\"label\">Max Results\n            <NumberInput\n              value={selection.maxResults}\n              onChange={(v) => updateSelection(\"maxResults\", v)}\n              min={1}\n              integer\n              allowEmpty\n              placeholder=\"1\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      <div className=\"form-grid mt-xl\">\n        <ReferenceDropdown\n          label=\"Entity Kind\"\n          value={selection.kind || \"\"}\n          onChange={(v) =>\n            updateSelectionMultiple({\n              kind: v || undefined,\n              subtypes: undefined,\n              excludeSubtypes: undefined,\n            })\n          }\n          options={entityKindOptions}\n          placeholder=\"Any kind\"\n        />\n        <div className=\"form-group\">\n          <label htmlFor=\"status-optional\" className=\"label\">Status (optional)</label>\n          <input id=\"status-optional\"\n            type=\"text\"\n            value={selection.status || \"\"}\n            onChange={(e) => updateSelection(\"status\", e.target.value || undefined)}\n            className=\"input\"\n            placeholder=\"e.g., active\"\n          />\n        </div>\n        <div className=\"form-group\">\n          <label htmlFor=\"not-status-optional\" className=\"label\">Not Status (optional)</label>\n          <input id=\"not-status-optional\"\n            type=\"text\"\n            value={selection.notStatus || \"\"}\n            onChange={(e) => updateSelection(\"notStatus\", e.target.value || undefined)}\n            className=\"input\"\n            placeholder=\"e.g., dead\"\n          />\n        </div>\n      </div>\n\n      {selection.kind && selection.kind !== \"any\" && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Subtypes (optional)\"\n            value={selection.subtypes || []}\n            onChange={(v) => updateSelection(\"subtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(selection.kind)}\n            placeholder=\"Any subtype\"\n          />\n        </div>\n      )}\n\n      {selection.kind && selection.kind !== \"any\" && showExcludeSubtypes && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Exclude Subtypes (optional)\"\n            value={selection.excludeSubtypes || []}\n            onChange={(v) => updateSelection(\"excludeSubtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(selection.kind)}\n            placeholder=\"None\"\n          />\n        </div>\n      )}\n\n      {selection.strategy === \"by_preference_order\" && (\n        <div className=\"mt-xl\">\n          <label htmlFor=\"subtype-preferences-comma-separated\" className=\"label\">Subtype Preferences (comma-separated)</label>\n          <input id=\"subtype-preferences-comma-separated\"\n            type=\"text\"\n            value={(selection.subtypePreferences || []).join(\", \")}\n            onChange={(e) => {\n              const prefs = e.target.value\n                .split(\",\")\n                .map((s) => s.trim())\n                .filter(Boolean);\n              updateSelection(\"subtypePreferences\", prefs.length > 0 ? prefs : undefined);\n            }}\n            className=\"input\"\n            placeholder=\"e.g., noble, commoner\"\n          />\n        </div>\n      )}\n\n      {selection.strategy === \"by_relationship\" && (\n        <div className=\"form-grid mt-xl\">\n          <ReferenceDropdown\n            label=\"Relationship Kind\"\n            value={selection.relationshipKind || \"\"}\n            onChange={(v) => updateSelection(\"relationshipKind\", v)}\n            options={relationshipKindOptions}\n            placeholder=\"Select relationship...\"\n          />\n          <ReferenceDropdown\n            label=\"Direction\"\n            value={selection.direction || \"both\"}\n            onChange={(v) => updateSelection(\"direction\", v)}\n            options={[\n              { value: \"both\", label: \"Both\" },\n              { value: \"src\", label: \"Source (outgoing)\" },\n              { value: \"dst\", label: \"Destination (incoming)\" },\n            ]}\n          />\n          <div className=\"form-group\">\n            <label className=\"checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={selection.mustHave !== false}\n                onChange={(e) => updateSelection(\"mustHave\", e.target.checked)}\n                className=\"checkbox\"\n              />\n              Must Have Relationship\n            </label>\n          </div>\n        </div>\n      )}\n\n      {selection.strategy === \"by_proximity\" && (\n        <div className=\"form-grid mt-xl\">\n          <ReferenceDropdown\n            label=\"Reference Entity\"\n            value={selection.referenceEntity || \"\"}\n            onChange={(v) => updateSelection(\"referenceEntity\", v || undefined)}\n            options={referenceOptions}\n            placeholder={referenceOptions[0]?.value || \"\"}\n          />\n          <div className=\"form-group\">\n            <label className=\"label\">Max Distance\n            <NumberInput\n              value={selection.maxDistance}\n              onChange={(v) => updateSelection(\"maxDistance\", v)}\n              min={0}\n              allowEmpty\n              placeholder=\"50\"\n            />\n            </label>\n          </div>\n        </div>\n      )}\n\n      {selection.strategy === \"by_prominence\" && (\n        <div className=\"mt-xl\">\n          <ReferenceDropdown\n            label=\"Minimum Prominence\"\n            value={selection.minProminence || \"\"}\n            onChange={(v) => updateSelection(\"minProminence\", v || undefined)}\n            options={PROMINENCE_LEVELS.map((p) => ({ value: p.value, label: p.label }))}\n            placeholder=\"Any\"\n          />\n        </div>\n      )}\n\n      {showFilters && (\n        <div className=\"mt-2xl\">\n          <span className=\"label\">Selection Filters</span>\n          <div className=\"info-box-text mb-lg text-sm\">\n            Optional filters to narrow down which entities can be selected. All filters must pass.\n          </div>\n          <SelectionFiltersEditor\n            filters={selection.filters}\n            onChange={(filters) =>\n              updateSelection(\"filters\", filters.length > 0 ? filters : undefined)\n            }\n            schema={schema}\n            availableRefs={availableRefs}\n          />\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  showFilters = true,\n  allowAnyKind = false,\n  showExcludeSubtypes = false,\n}", "type": "{ value: any; onChange: any; schema: any; availableRefs?: any[]; showPickStrategy?: boolean; showMaxResults?: boolean; showFilters?: boolean; allowAnyKind?: boolean; showExcludeSubtypes?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["ReferenceDropdown", "NumberInput", "label", "input", "ChipSelect", "span", "div", "SelectionFiltersEditor"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput", "PROMINENCE_LEVELS"], "category": "internal"}, {"source": "../generators/constants", "specifiers": ["PICK_STRATEGIES"], "category": "internal"}, {"source": "../generators/filters", "specifiers": ["SelectionFiltersEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/shared/VariableSelectionEditor.jsx::VariableSelectionEditor", "name": "VariableSelectionEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/shared/VariableSelectionEditor.jsx", "sourceCode": "export function VariableSelectionEditor({\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  allowPreferFilters = true,\n}) {\n  const select = value || {};\n  const selectionMode = getSelectionMode(select);\n  const isRelatedMode = selectionMode === \"related\";\n  const isPathMode = selectionMode === \"path\";\n  const fromSpec = isRelatedMode ? select.from : null;\n  const pathSpec = isPathMode ? select.from : null;\n\n  const entityKindOptions = (schema?.entityKinds || []).map((ek) => ({\n    value: ek.kind,\n    label: ek.description || ek.kind,\n  }));\n\n  const relationshipKindOptions = (schema?.relationshipKinds || []).map((rk) => ({\n    value: rk.kind,\n    label: rk.description || rk.kind,\n  }));\n\n  const getSubtypeOptions = (kind) => {\n    const ek = (schema?.entityKinds || []).find((e) => e.kind === kind);\n    if (!ek?.subtypes) return [];\n    return ek.subtypes.map((st) => ({ value: st.id, label: st.name || st.id }));\n  };\n\n  const updateSelect = (field, fieldValue) => {\n    onChange({ ...select, [field]: fieldValue });\n  };\n\n  const updateSelectMultiple = (updates) => {\n    onChange({ ...select, ...updates });\n  };\n\n  const setMode = (mode) => {\n    if (mode === \"graph\") {\n      onChange({ ...select, from: \"graph\" });\n      return;\n    }\n    if (mode === \"path\") {\n      const startRef = availableRefs[0] || \"$self\";\n      onChange({\n        ...select,\n        from: {\n          path: [{ from: startRef, via: \"\", direction: \"both\" }],\n        },\n      });\n      return;\n    }\n    const relatedTo = availableRefs[0] || \"$target\";\n    onChange({\n      ...select,\n      from: { relatedTo, relationshipKind: \"\", direction: \"both\" },\n    });\n  };\n\n  const updatePathStep = (index, step) => {\n    const path = [...(pathSpec?.path || [])];\n    path[index] = step;\n    updateSelect(\"from\", { path });\n  };\n\n  const addPathStep = () => {\n    const path = [...(pathSpec?.path || [])];\n    path.push({ via: \"\", direction: \"both\" });\n    updateSelect(\"from\", { path });\n  };\n\n  const removePathStep = (index) => {\n    const path = (pathSpec?.path || []).filter((_, i) => i !== index);\n    if (path.length === 0) {\n      // Switch back to graph mode if no steps left\n      setMode(\"graph\");\n    } else {\n      updateSelect(\"from\", { path });\n    }\n  };\n\n  const updateFrom = (field, fieldValue) => {\n    const nextFrom = {\n      ...(fromSpec || {\n        relatedTo: availableRefs[0] || \"$target\",\n        relationshipKind: \"\",\n        direction: \"both\",\n      }),\n      [field]: fieldValue,\n    };\n    updateSelect(\"from\", nextFrom);\n  };\n\n  return (\n    <div>\n      <div className=\"form-grid\">\n        <ReferenceDropdown\n          label=\"Select From\"\n          value={selectionMode}\n          onChange={(v) => setMode(v)}\n          options={[\n            { value: \"graph\", label: \"Graph (by entity kind)\" },\n            { value: \"related\", label: \"Related Entities (single hop)\" },\n            { value: \"path\", label: \"Path Traversal (multi-hop)\" },\n          ]}\n        />\n\n        {selectionMode === \"graph\" && (\n          <ReferenceDropdown\n            label=\"Entity Kind\"\n            value={select.kind || \"\"}\n            onChange={(v) => updateSelectMultiple({ kind: v || undefined, subtypes: undefined })}\n            options={entityKindOptions}\n            placeholder=\"Any kind\"\n          />\n        )}\n\n        {isRelatedMode && (\n          <>\n            <ReferenceDropdown\n              label=\"Related To\"\n              value={fromSpec?.relatedTo || availableRefs[0] || \"$target\"}\n              onChange={(v) => updateFrom(\"relatedTo\", v)}\n              options={availableRefs.map((r) => ({ value: r, label: r }))}\n              placeholder=\"Select entity...\"\n            />\n            <ReferenceDropdown\n              label=\"Relationship Kind\"\n              value={fromSpec?.relationshipKind || \"\"}\n              onChange={(v) => updateFrom(\"relationshipKind\", v)}\n              options={relationshipKindOptions}\n              placeholder=\"Select relationship...\"\n            />\n            <ReferenceDropdown\n              label=\"Direction\"\n              value={fromSpec?.direction || \"both\"}\n              onChange={(v) => updateFrom(\"direction\", v)}\n              options={[\n                { value: \"both\", label: \"Both\" },\n                { value: \"src\", label: \"Source (outgoing)\" },\n                { value: \"dst\", label: \"Destination (incoming)\" },\n              ]}\n            />\n          </>\n        )}\n\n        {isPathMode && (\n          <div className=\"grid-col-full\">\n            <span className=\"label\">Path Steps</span>\n            <div className=\"info-box-text mb-lg text-sm\">\n              Multi-hop traversal from the starting entity through relationships.\n            </div>\n          </div>\n        )}\n\n        {showPickStrategy && (\n          <ReferenceDropdown\n            label=\"Pick Strategy\"\n            value={select.pickStrategy || \"\"}\n            onChange={(v) => updateSelect(\"pickStrategy\", v || undefined)}\n            options={VARIABLE_PICK_STRATEGIES}\n            placeholder=\"Select...\"\n          />\n        )}\n\n        {showMaxResults && (\n          <div className=\"form-group\">\n            <label className=\"label\">Max Results\n            <NumberInput\n              value={select.maxResults}\n              onChange={(v) => updateSelect(\"maxResults\", v)}\n              min={1}\n              integer\n              allowEmpty\n              placeholder=\"1\"\n            />\n            </label>\n          </div>\n        )}\n      </div>\n\n      {isPathMode && (\n        <div className=\"mt-xl\">\n          {(pathSpec?.path || []).map((step, index) => (\n            <div key={index} className=\"item-card mb-lg\">\n              <div className=\"item-card-header p-lg\">\n                <div className=\"item-card-icon\">\ud83d\udd17</div>\n                <div className=\"item-card-info\">\n                  <div className=\"item-card-title\">Step {index + 1}</div>\n                </div>\n                <button\n                  className=\"btn-icon btn-icon-danger\"\n                  onClick={() => removePathStep(index)}\n                  title=\"Remove step\"\n                >\n                  \u00d7\n                </button>\n              </div>\n              <div className=\"item-card-body\">\n                <div className=\"form-grid\">\n                  {index === 0 && (\n                    <ReferenceDropdown\n                      label=\"Start From\"\n                      value={step.from || availableRefs[0] || \"$self\"}\n                      onChange={(v) => updatePathStep(index, { ...step, from: v })}\n                      options={availableRefs.map((r) => ({ value: r, label: r }))}\n                      placeholder=\"Select entity...\"\n                    />\n                  )}\n                  <ReferenceDropdown\n                    label=\"Via Relationship\"\n                    value={step.via || \"\"}\n                    onChange={(v) => updatePathStep(index, { ...step, via: v })}\n                    options={relationshipKindOptions}\n                    placeholder=\"Select relationship...\"\n                  />\n                  <ReferenceDropdown\n                    label=\"Direction\"\n                    value={step.direction || \"both\"}\n                    onChange={(v) => updatePathStep(index, { ...step, direction: v })}\n                    options={[\n                      { value: \"both\", label: \"Both\" },\n                      { value: \"src\", label: \"Source (outgoing)\" },\n                      { value: \"dst\", label: \"Destination (incoming)\" },\n                    ]}\n                  />\n                  <ReferenceDropdown\n                    label=\"Target Kind (optional)\"\n                    value={step.targetKind || \"\"}\n                    onChange={(v) => updatePathStep(index, { ...step, targetKind: v || undefined })}\n                    options={entityKindOptions}\n                    placeholder=\"Any kind\"\n                  />\n                </div>\n              </div>\n            </div>\n          ))}\n          <button className=\"btn-add\" onClick={addPathStep}>\n            + Add Step\n          </button>\n        </div>\n      )}\n\n      {(isRelatedMode || isPathMode) && (\n        <div className=\"mt-xl\">\n          <ReferenceDropdown\n            label=\"Filter by Entity Kind (optional)\"\n            value={select.kind || \"\"}\n            onChange={(v) => updateSelectMultiple({ kind: v || undefined, subtypes: undefined })}\n            options={entityKindOptions}\n            placeholder=\"Any kind\"\n          />\n        </div>\n      )}\n\n      {select.kind && (\n        <div className=\"mt-xl\">\n          <ChipSelect\n            label=\"Subtypes (optional)\"\n            value={select.subtypes || []}\n            onChange={(v) => updateSelect(\"subtypes\", v.length > 0 ? v : undefined)}\n            options={getSubtypeOptions(select.kind)}\n            placeholder=\"Any subtype\"\n          />\n        </div>\n      )}\n\n      <div className=\"mt-xl\">\n        <label htmlFor=\"status-filter-optional\" className=\"label\">Status Filter (optional)</label>\n        <input id=\"status-filter-optional\"\n          type=\"text\"\n          value={select.status || \"\"}\n          onChange={(e) => updateSelect(\"status\", e.target.value || undefined)}\n          className=\"input\"\n          placeholder=\"e.g., active\"\n        />\n      </div>\n\n      <div className=\"mt-xl\">\n        <label htmlFor=\"not-status-optional\" className=\"label\">Not Status (optional)</label>\n        <input id=\"not-status-optional\"\n          type=\"text\"\n          value={select.notStatus || \"\"}\n          onChange={(e) => updateSelect(\"notStatus\", e.target.value || undefined)}\n          className=\"input\"\n          placeholder=\"e.g., dead\"\n        />\n      </div>\n\n      <div className=\"mt-2xl\">\n        <span className=\"label\">Selection Filters</span>\n        <div className=\"info-box-text mb-lg text-sm\">\n          Optional filters to narrow down which entities can be selected. All filters must pass.\n        </div>\n        <SelectionFiltersEditor\n          filters={select.filters}\n          onChange={(filters) => updateSelect(\"filters\", filters.length > 0 ? filters : undefined)}\n// ... (truncated)", "parameters": [{"name": "{\n  value,\n  onChange,\n  schema,\n  availableRefs = [],\n  showPickStrategy = true,\n  showMaxResults = true,\n  allowPreferFilters = true,\n}", "type": "{ value: any; onChange: any; schema: any; availableRefs?: any[]; showPickStrategy?: boolean; showMaxResults?: boolean; allowPreferFilters?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["ReferenceDropdown", "span", "div", "NumberInput", "button", "ChipSelect", "label", "input", "SelectionFiltersEditor"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./index", "specifiers": ["ReferenceDropdown", "ChipSelect", "NumberInput"], "category": "internal"}, {"source": "../generators/constants", "specifiers": ["VARIABLE_PICK_STRATEGIES"], "category": "internal"}, {"source": "../generators/filters", "specifiers": ["SelectionFiltersEditor"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/index.js::SystemsEditor", "name": "SystemsEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/index.js", "sourceCode": "export default function SystemsEditor({\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"systems:selected\");\n  const typePickerKey = buildStorageKey(projectId, \"systems:typePicker\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [showTypePicker, setShowTypePicker] = useState(\n    () => loadStoredValue(typePickerKey) === true\n  );\n\n  // Derive selectedSystem from index\n  const resolvedIndex = selectedId\n    ? systems.findIndex((system) => system.config?.id === selectedId)\n    : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedSystem = selectedIndex !== null ? systems[selectedIndex] : null;\n  const [expandedCategories, setExpandedCategories] = useState(() => {\n    // Start with all categories expanded\n    return Object.keys(SYSTEM_CATEGORIES).reduce((acc, cat) => {\n      acc[cat] = true;\n      return acc;\n    }, {});\n  });\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowTypePicker(false);\n    }\n  }, []);\n\n  // Group systems by category (framework systems grouped together)\n  const groupedSystems = useMemo(() => {\n    const groups = {};\n    systems.forEach((system) => {\n      const category = getSystemCategory(system.systemType || \"unknown\");\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(system);\n    });\n    return groups;\n  }, [systems]);\n\n  // Get ordered list of categories that have systems\n  const categories = useMemo(() => {\n    const usedCategories = Object.keys(groupedSystems);\n    // Sort by defined order in SYSTEM_CATEGORIES\n    return usedCategories.sort((a, b) => {\n      const orderA = SYSTEM_CATEGORIES[a]?.order ?? 999;\n      const orderB = SYSTEM_CATEGORIES[b]?.order ?? 999;\n      return orderA - orderB;\n    });\n  }, [groupedSystems]);\n\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  useEffect(() => {\n    setShowTypePicker(loadStoredValue(typePickerKey) === true);\n  }, [typePickerKey]);\n\n  useEffect(() => {\n    if (selectionKey) {\n      if (selectedId) {\n        saveStoredValue(selectionKey, selectedId);\n      } else {\n        clearStoredValue(selectionKey);\n      }\n    }\n  }, [selectionKey, selectedId]);\n\n  useEffect(() => {\n    if (typePickerKey) {\n      if (showTypePicker) {\n        saveStoredValue(typePickerKey, true);\n      } else {\n        clearStoredValue(typePickerKey);\n      }\n    }\n  }, [typePickerKey, showTypePicker]);\n\n  useEffect(() => {\n    if (selectedId && selectedIndex === null) {\n      setSelectedId(null);\n      clearStoredValue(selectionKey);\n    }\n  }, [selectedId, selectedIndex, selectionKey]);\n\n  const handleSystemChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex >= 0 && selectedIndex < systems.length) {\n        const newSystems = [...systems];\n        newSystems[selectedIndex] = updated;\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (system) => {\n      const index = systems.findIndex((s) => s.config?.id === system.config?.id);\n      if (index >= 0) {\n        const newSystems = [...systems];\n        newSystems[index] = { ...system, enabled: system.enabled === false ? true : false };\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedSystem &&\n      confirm(`Delete system \"${selectedSystem.config?.name || selectedSystem.config?.id}\"?`)\n    ) {\n      const newSystems = systems.filter((_, i) => i !== selectedIndex);\n      onChange(newSystems);\n      setSelectedId(null);\n    }\n  }, [systems, onChange, selectedIndex, selectedSystem]);\n\n  const handleAddSystem = useCallback(\n    (type) => {\n      const needsSelection = [\n        \"graphContagion\",\n        \"connectionEvolution\",\n        \"thresholdTrigger\",\n        \"clusterFormation\",\n        \"tagDiffusion\",\n        \"planeDiffusion\",\n      ].includes(type);\n      const newSystem = {\n        systemType: type,\n        config: {\n          id: `system_${Date.now()}`,\n          name: `New ${SYSTEM_TYPES[type]?.label || type}`,\n          description: \"\",\n          ...(needsSelection ? { selection: { strategy: \"by_kind\", kind: \"any\" } } : {}),\n        },\n      };\n      onChange([...systems, newSystem]);\n      setSelectedId(newSystem.config.id);\n      setShowTypePicker(false);\n    },\n    [systems, onChange]\n  );\n\n  const toggleCategoryExpand = useCallback((type) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [type]: !prev[type],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (category) => {\n      const categoryItems = groupedSystems[category] || [];\n      const allEnabled = categoryItems.every((s) => s.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of systems in this category\n      const categoryIds = new Set(categoryItems.map((s) => s.config?.id));\n\n      const newSystems = systems.map((s) => {\n        if (categoryIds.has(s.config?.id)) {\n          return { ...s, enabled: newEnabled };\n        }\n        return s;\n      });\n      onChange(newSystems);\n    },\n    [systems, groupedSystems, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Systems</h1>\n        <p className=\"subtitle\">\n          Configure simulation systems that run during the simulation phase. Click a system to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((category) => {\n        const categoryConfig = SYSTEM_CATEGORIES[category] || { icon: \"\u2699\ufe0f\", label: category };\n        const categoryItems = groupedSystems[category] || [];\n        const allEnabled = categoryItems.every((s) => s.enabled !== false);\n\n        return (\n          <CategorySection\n            key={category}\n            id={category}\n            icon={categoryConfig.icon}\n            label={categoryConfig.label}\n            items={categoryItems}\n            expanded={expandedCategories[category] !== false}\n            onToggleExpand={() => toggleCategoryExpand(category)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(category)}\n            gridClassName=\"list-grid\"\n            renderItem={(system) => {\n              const flatIndex = systems.findIndex((s) => s.config?.id === system.config?.id);\n              return (\n                <SystemListCard\n                  key={flatIndex}\n                  system={system}\n                  onClick={() => setSelectedId(system.config.id)}\n                  onToggle={() => handleToggle(system)}\n                  usageMap={usageMap}\n                />\n              );\n            }}\n          />\n        );\n      })}\n\n      {/* Add System button */}\n      <div className=\"mt-xl\">\n        <div\n          className=\"add-card se-add-card-wrap\"\n          onClick={() => setShowTypePicker(true)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"se-add-icon\">+</span>\n          <span>Add System</span>\n        </div>\n      </div>\n\n      {showTypePicker && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal se-type-picker-modal\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Choose System Type</div>\n              <button className=\"close-btn\" onClick={() => setShowTypePicker(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"se-type-picker-content\">\n              <div className=\"type-picker\">\n                {Object.entries(SYSTEM_TYPES).map(([type, config]) => (\n                  <div\n                    key={type}\n                    className=\"se-type-option type-option\"\n                    onClick={() => handleAddSystem(type)}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <div className=\"type-option-icon\">{config.icon}</div>\n                    <div className=\"type-option-label\">{config.label}</div>\n                    <div className=\"type-option-desc\">{config.desc}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {selectedSystem && (\n        <SystemModal\n          system={selectedSystem}\n          onChange={handleSystemChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; systems?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h1", "p", "CategorySection", "SystemListCard", "span", "div", "button", "SystemModal"], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 8}, {"name": "useMemo", "count": 2}, {"name": "useEffect", "count": 5}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/systems/SystemModal.jsx::SystemModal", "name": "SystemModal", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/SystemModal.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object} props.system - The system being edited\n * @param {Function} props.onChange - Called when system changes\n * @param {Function} props.onClose - Called to close the modal\n * @param {Function} props.onDelete - Called to delete the system\n * @param {Object} props.schema - Domain schema\n * @param {Array} props.pressures - Available pressure definitions\n */\nexport function SystemModal({ system, onChange, onClose, onDelete, schema, pressures }) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n  const typeConfig = SYSTEM_TYPES[system.systemType] || {};\n\n  const isFrameworkSystem = [\n    \"eraSpawner\",\n    \"eraTransition\",\n    \"universalCatalyst\",\n    \"relationshipMaintenance\",\n  ].includes(system.systemType);\n\n  // Build tabs dynamically based on system type\n  const tabs = useMemo(() => {\n    const result = [\n      { id: \"overview\", label: \"Overview\", icon: \"\ud83d\udccb\" },\n      { id: \"common\", label: \"Settings\", icon: \"\u2699\ufe0f\" },\n    ];\n\n    // Add type-specific tab\n    if (!isFrameworkSystem) {\n      switch (system.systemType) {\n        case \"graphContagion\":\n          result.push({ id: \"type\", label: \"Contagion\", icon: \"\ud83e\udda0\" });\n          break;\n        case \"connectionEvolution\":\n          result.push({ id: \"type\", label: \"Evolution\", icon: \"\ud83d\udd04\" });\n          break;\n        case \"thresholdTrigger\":\n          result.push({ id: \"type\", label: \"Trigger\", icon: \"\u26a1\" });\n          break;\n        case \"clusterFormation\":\n          result.push({ id: \"type\", label: \"Clustering\", icon: \"\ud83d\udd32\" });\n          break;\n        case \"tagDiffusion\":\n          result.push({ id: \"type\", label: \"Diffusion\", icon: \"\ud83c\udff7\ufe0f\" });\n          break;\n        case \"planeDiffusion\":\n          result.push({ id: \"type\", label: \"Plane\", icon: \"\ud83d\uddfa\ufe0f\" });\n          break;\n      }\n    } else {\n      result.push({ id: \"type\", label: \"Framework\", icon: \"\ud83d\udd27\" });\n    }\n\n    return result;\n  }, [system.systemType, isFrameworkSystem]);\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"overview\":\n        return <OverviewTab system={system} onChange={onChange} onDelete={onDelete} />;\n      case \"common\":\n        return (\n          <CommonSettingsTab\n            system={system}\n            onChange={onChange}\n            schema={schema}\n            pressures={pressures}\n          />\n        );\n      case \"type\":\n        if (isFrameworkSystem) {\n          return <FrameworkSystemTab system={system} onChange={onChange} />;\n        }\n        switch (system.systemType) {\n          case \"graphContagion\":\n            return <GraphContagionTab system={system} onChange={onChange} schema={schema} />;\n          case \"connectionEvolution\":\n            return <ConnectionEvolutionTab system={system} onChange={onChange} schema={schema} />;\n          case \"thresholdTrigger\":\n            return (\n              <ThresholdTriggerTab\n                system={system}\n                onChange={onChange}\n                schema={schema}\n                pressures={pressures}\n              />\n            );\n          case \"clusterFormation\":\n            return <ClusterFormationTab system={system} onChange={onChange} schema={schema} />;\n          case \"tagDiffusion\":\n            return <TagDiffusionTab system={system} onChange={onChange} schema={schema} />;\n          case \"planeDiffusion\":\n            return <PlaneDiffusionTab system={system} onChange={onChange} schema={schema} />;\n          default:\n            return null;\n        }\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <ModalShell\n      onClose={onClose}\n      icon={typeConfig.icon}\n      title={system.config?.name || system.config?.id}\n      disabled={system.enabled === false}\n      tabs={tabs}\n      activeTab={activeTab}\n      onTabChange={setActiveTab}\n      tabClassName=\"se-tab-btn\"\n    >\n      {renderTabContent()}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ system, onChange, onClose, onDelete, schema, pressures }", "type": "{ system: any; onChange: Function; onClose: Function; onDelete: Function; schema: any; pressures: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["OverviewTab"], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./constants", "specifiers": ["SYSTEM_TYPES"], "category": "internal"}, {"source": "../shared", "specifiers": ["ModalShell"], "category": "internal"}, {"source": "./tabs", "specifiers": ["OverviewTab", "CommonSettingsTab", "GraphContagionTab", "ConnectionEvolutionTab", "ThresholdTriggerTab", "ClusterFormationTab", "TagDiffusionTab", "PlaneDiffusionTab", "FrameworkSystemTab"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/systems/SystemsEditor.jsx::SystemsEditor", "name": "SystemsEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/systems/SystemsEditor.jsx", "sourceCode": "export default function SystemsEditor({\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}) {\n  const selectionKey = buildStorageKey(projectId, \"systems:selected\");\n  const typePickerKey = buildStorageKey(projectId, \"systems:typePicker\");\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStoredValue(selectionKey);\n    return typeof stored === \"string\" ? stored : null;\n  });\n  const [showTypePicker, setShowTypePicker] = useState(\n    () => loadStoredValue(typePickerKey) === true\n  );\n\n  // Derive selectedSystem from index\n  const resolvedIndex = selectedId\n    ? systems.findIndex((system) => system.config?.id === selectedId)\n    : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n  const selectedSystem = selectedIndex !== null ? systems[selectedIndex] : null;\n  const [expandedCategories, setExpandedCategories] = useState(() => {\n    // Start with all categories expanded\n    return Object.keys(SYSTEM_CATEGORIES).reduce((acc, cat) => {\n      acc[cat] = true;\n      return acc;\n    }, {});\n  });\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowTypePicker(false);\n    }\n  }, []);\n\n  // Group systems by category (framework systems grouped together)\n  const groupedSystems = useMemo(() => {\n    const groups = {};\n    systems.forEach((system) => {\n      const category = getSystemCategory(system.systemType || \"unknown\");\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(system);\n    });\n    return groups;\n  }, [systems]);\n\n  // Get ordered list of categories that have systems\n  const categories = useMemo(() => {\n    const usedCategories = Object.keys(groupedSystems);\n    // Sort by defined order in SYSTEM_CATEGORIES\n    return usedCategories.sort((a, b) => {\n      const orderA = SYSTEM_CATEGORIES[a]?.order ?? 999;\n      const orderB = SYSTEM_CATEGORIES[b]?.order ?? 999;\n      return orderA - orderB;\n    });\n  }, [groupedSystems]);\n\n  useEffect(() => {\n    const stored = loadStoredValue(selectionKey);\n    setSelectedId(typeof stored === \"string\" ? stored : null);\n  }, [selectionKey]);\n\n  useEffect(() => {\n    setShowTypePicker(loadStoredValue(typePickerKey) === true);\n  }, [typePickerKey]);\n\n  useEffect(() => {\n    if (selectionKey) {\n      if (selectedId) {\n        saveStoredValue(selectionKey, selectedId);\n      } else {\n        clearStoredValue(selectionKey);\n      }\n    }\n  }, [selectionKey, selectedId]);\n\n  useEffect(() => {\n    if (typePickerKey) {\n      if (showTypePicker) {\n        saveStoredValue(typePickerKey, true);\n      } else {\n        clearStoredValue(typePickerKey);\n      }\n    }\n  }, [typePickerKey, showTypePicker]);\n\n  useEffect(() => {\n    if (selectedId && selectedIndex === null) {\n      setSelectedId(null);\n      clearStoredValue(selectionKey);\n    }\n  }, [selectedId, selectedIndex, selectionKey]);\n\n  const handleSystemChange = useCallback(\n    (updated) => {\n      if (selectedIndex !== null && selectedIndex >= 0 && selectedIndex < systems.length) {\n        const newSystems = [...systems];\n        newSystems[selectedIndex] = updated;\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange, selectedIndex]\n  );\n\n  const handleToggle = useCallback(\n    (system) => {\n      const index = systems.findIndex((s) => s.config?.id === system.config?.id);\n      if (index >= 0) {\n        const newSystems = [...systems];\n        newSystems[index] = { ...system, enabled: system.enabled === false ? true : false };\n        onChange(newSystems);\n      }\n    },\n    [systems, onChange]\n  );\n\n  const handleDelete = useCallback(() => {\n    if (\n      selectedIndex !== null &&\n      selectedSystem &&\n      confirm(`Delete system \"${selectedSystem.config?.name || selectedSystem.config?.id}\"?`)\n    ) {\n      const newSystems = systems.filter((_, i) => i !== selectedIndex);\n      onChange(newSystems);\n      setSelectedId(null);\n    }\n  }, [systems, onChange, selectedIndex, selectedSystem]);\n\n  const handleAddSystem = useCallback(\n    (type) => {\n      const needsSelection = [\n        \"graphContagion\",\n        \"connectionEvolution\",\n        \"thresholdTrigger\",\n        \"clusterFormation\",\n        \"tagDiffusion\",\n        \"planeDiffusion\",\n      ].includes(type);\n      const newSystem = {\n        systemType: type,\n        config: {\n          id: `system_${Date.now()}`,\n          name: `New ${SYSTEM_TYPES[type]?.label || type}`,\n          description: \"\",\n          ...(needsSelection ? { selection: { strategy: \"by_kind\", kind: \"any\" } } : {}),\n        },\n      };\n      onChange([...systems, newSystem]);\n      setSelectedId(newSystem.config.id);\n      setShowTypePicker(false);\n    },\n    [systems, onChange]\n  );\n\n  const toggleCategoryExpand = useCallback((type) => {\n    setExpandedCategories((prev) => ({\n      ...prev,\n      [type]: !prev[type],\n    }));\n  }, []);\n\n  const toggleAllInCategory = useCallback(\n    (category) => {\n      const categoryItems = groupedSystems[category] || [];\n      const allEnabled = categoryItems.every((s) => s.enabled !== false);\n      const newEnabled = !allEnabled;\n\n      // Get IDs of systems in this category\n      const categoryIds = new Set(categoryItems.map((s) => s.config?.id));\n\n      const newSystems = systems.map((s) => {\n        if (categoryIds.has(s.config?.id)) {\n          return { ...s, enabled: newEnabled };\n        }\n        return s;\n      });\n      onChange(newSystems);\n    },\n    [systems, groupedSystems, onChange]\n  );\n\n  return (\n    <div className=\"editor-container\">\n      <div className=\"header\">\n        <h1 className=\"title\">Systems</h1>\n        <p className=\"subtitle\">\n          Configure simulation systems that run during the simulation phase. Click a system to edit.\n        </p>\n      </div>\n\n      {/* Category sections */}\n      {categories.map((category) => {\n        const categoryConfig = SYSTEM_CATEGORIES[category] || { icon: \"\u2699\ufe0f\", label: category };\n        const categoryItems = groupedSystems[category] || [];\n        const allEnabled = categoryItems.every((s) => s.enabled !== false);\n\n        return (\n          <CategorySection\n            key={category}\n            id={category}\n            icon={categoryConfig.icon}\n            label={categoryConfig.label}\n            items={categoryItems}\n            expanded={expandedCategories[category] !== false}\n            onToggleExpand={() => toggleCategoryExpand(category)}\n            allEnabled={allEnabled}\n            onToggleAll={() => toggleAllInCategory(category)}\n            gridClassName=\"list-grid\"\n            renderItem={(system) => {\n              const flatIndex = systems.findIndex((s) => s.config?.id === system.config?.id);\n              return (\n                <SystemListCard\n                  key={flatIndex}\n                  system={system}\n                  onClick={() => setSelectedId(system.config.id)}\n                  onToggle={() => handleToggle(system)}\n                  usageMap={usageMap}\n                />\n              );\n            }}\n          />\n        );\n      })}\n\n      {/* Add System button */}\n      <div className=\"mt-xl\">\n        <div\n          className=\"add-card se-add-card-wrap\"\n          onClick={() => setShowTypePicker(true)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"se-add-icon\">+</span>\n          <span>Add System</span>\n        </div>\n      </div>\n\n      {showTypePicker && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal se-type-picker-modal\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Choose System Type</div>\n              <button className=\"close-btn\" onClick={() => setShowTypePicker(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"se-type-picker-content\">\n              <div className=\"type-picker\">\n                {Object.entries(SYSTEM_TYPES).map(([type, config]) => (\n                  <div\n                    key={type}\n                    className=\"se-type-option type-option\"\n                    onClick={() => handleAddSystem(type)}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <div className=\"type-option-icon\">{config.icon}</div>\n                    <div className=\"type-option-label\">{config.label}</div>\n                    <div className=\"type-option-desc\">{config.desc}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {selectedSystem && (\n        <SystemModal\n          system={selectedSystem}\n          onChange={handleSystemChange}\n          onClose={() => setSelectedId(null)}\n          onDelete={handleDelete}\n          schema={schema}\n          pressures={pressures}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  systems = [],\n  onChange,\n  schema,\n  pressures = [],\n  usageMap,\n}", "type": "{ projectId: any; systems?: any[]; onChange: any; schema: any; pressures?: any[]; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h1", "p", "CategorySection", "SystemListCard", "span", "div", "button", "SystemModal"], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 8}, {"name": "useMemo", "count": 2}, {"name": "useEffect", "count": 5}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./constants", "specifiers": ["SYSTEM_TYPES", "SYSTEM_CATEGORIES", "getSystemCategory"], "category": "internal"}, {"source": "../shared", "specifiers": ["CategorySection"], "category": "internal"}, {"source": "./cards/SystemListCard", "specifiers": ["SystemListCard"], "category": "internal"}, {"source": "./SystemModal", "specifiers": ["SystemModal"], "category": "internal"}, {"source": "../../utils/persistence", "specifiers": ["buildStorageKey", "clearStoredValue", "loadStoredValue", "saveStoredValue"], "category": "internal"}, {"source": "./SystemsEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/validation/index.js::ValidationEditor", "name": "ValidationEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/validation/index.js", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "p", "button", "div", "IssueCard", "DependencyViewer", "NamingProfileMappingViewer", "strong"], "hookCalls": [{"name": "useMemo", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx::ValidationEditor", "name": "ValidationEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/validation/ValidationEditor.jsx", "sourceCode": "export default function ValidationEditor({\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}) {\n  const validationResults = useMemo(\n    () => runValidations(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Count orphans from usageMap for summary\n  const orphanCounts = useMemo(() => {\n    if (!usageMap?.validation?.orphans)\n      return { generators: 0, systems: 0, pressures: 0, total: 0 };\n    const orphans = usageMap.validation.orphans;\n    const generators = orphans.filter((o) => o.type === \"generator\").length;\n    const systems = orphans.filter((o) => o.type === \"system\").length;\n    const pressures = orphans.filter((o) => o.type === \"pressure\").length;\n    return { generators, systems, pressures, total: generators + systems + pressures };\n  }, [usageMap]);\n\n  const overallStatus = getOverallStatus(validationResults);\n  const totalIssues = validationResults.errors.length + validationResults.warnings.length;\n  const hasNamingProfiles = useMemo(\n    () => (schema.cultures || []).some((culture) => culture.naming?.profiles?.length),\n    [schema]\n  );\n\n  let statusModifier;\n  if (overallStatus === \"clean\") {\n    statusModifier = \"validation-status-clean\";\n  } else if (overallStatus === \"warning\") {\n    statusModifier = \"validation-status-warning\";\n  } else {\n    statusModifier = \"validation-status-error\";\n  }\n  const statusBadgeClass = `validation-status-badge ${statusModifier}`;\n\n  const handleItemClick = (itemId) => {\n    if (onNavigateToGenerator) {\n      onNavigateToGenerator(itemId);\n    }\n  };\n\n  // Count total affected items\n  const totalAffectedItems = [...validationResults.errors, ...validationResults.warnings].reduce(\n    (sum, issue) => sum + issue.affectedItems.length,\n    0\n  );\n\n  return (\n    <div className=\"validation-container\">\n      <div className=\"validation-header\">\n        <div className=\"flex-between items-start\">\n          <div>\n            <h1 className=\"validation-title\">\n              Validation\n              <span className={statusBadgeClass}>\n                {(() => {\n                  if (overallStatus === \"clean\") return \"All Clear\";\n                  const issueWord = totalIssues === 1 ? \"Issue\" : \"Issues\";\n                  return `${totalIssues} ${issueWord}`;\n                })()}\n              </span>\n            </h1>\n            <p className=\"validation-subtitle\">\n              Semantic validation: reference integrity, pressure balance, and dead code detection.\n              Structure validation runs automatically as a gate before simulation.\n            </p>\n          </div>\n          {totalIssues > 0 && (\n            <div className=\"validation-export-row\">\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsJson(validationResults)}\n                title=\"Export validation report as JSON\"\n              >\n                Export JSON\n              </button>\n              <button\n                className=\"validation-export-button\"\n                onClick={() => exportAsCsv(validationResults)}\n                title=\"Export validation report as CSV\"\n              >\n                Export CSV\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Summary Cards */}\n      <div className=\"validation-summary-cards validation-summary-cards-4\">\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-danger\">\n            {validationResults.errors.length}\n          </div>\n          <div className=\"validation-summary-label\">Errors</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-warning\">\n            {validationResults.warnings.length}\n          </div>\n          <div className=\"validation-summary-label\">Warnings</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div\n            className={`validation-summary-value ${orphanCounts.total > 0 ? \"text-muted\" : \"text-info\"}`}\n          >\n            {orphanCounts.total}\n          </div>\n          <div className=\"validation-summary-label\">Unused</div>\n        </div>\n        <div className=\"validation-summary-card\">\n          <div className=\"validation-summary-value text-info\">\n            {totalAffectedItems}\n          </div>\n          <div className=\"validation-summary-label\">Affected Items</div>\n        </div>\n      </div>\n\n      {/* Clean state */}\n      {overallStatus === \"clean\" && (\n        <div className=\"validation-clean-state\">\n          <div className=\"validation-clean-icon\">\u2713</div>\n          <div className=\"validation-clean-title\">All Validations Passed</div>\n          <div className=\"validation-clean-message\">\n            Your configuration looks good. No issues detected.\n          </div>\n        </div>\n      )}\n\n      {/* Errors section */}\n      {validationResults.errors.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u274c</span>\n              Errors\n            </div>\n            <span className=\"validation-section-count validation-status-error\">\n              {validationResults.errors.length}\n            </span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.errors.map((error) => (\n              <IssueCard key={error.id} issue={error} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Warnings section */}\n      {validationResults.warnings.length > 0 && (\n        <div className=\"validation-section\">\n          <div className=\"validation-section-header\">\n            <div className=\"validation-section-title\">\n              <span>\u26a0\ufe0f</span>\n              Warnings\n            </div>\n            <span className=\"validation-section-count\">{validationResults.warnings.length}</span>\n          </div>\n          <div className=\"validation-issue-list\">\n            {validationResults.warnings.map((warning) => (\n              <IssueCard key={warning.id} issue={warning} onItemClick={handleItemClick} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Dependency Viewer */}\n      {usageMap && (\n        <div className=\"mb-2xl\">\n          <DependencyViewer usageMap={usageMap} />\n        </div>\n      )}\n\n      {/* Naming Profile Mappings */}\n      {hasNamingProfiles && (\n        <div className=\"mb-2xl\">\n          <NamingProfileMappingViewer generators={generators} schema={schema} />\n        </div>\n      )}\n\n      {/* Rule info */}\n      <div className=\"validation-rule-info\">\n        <div className=\"validation-rule-title\">\n          Active Validation Rules ({Object.keys(validationRules).length})\n        </div>\n        <ul className=\"validation-rule-list\">\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-danger\">\u25cf</span>\n            <strong>Reference Validation:</strong> Entity kinds (generators, pressures, systems),\n            relationship kinds (generators, pressures, systems), pressure IDs (generators, systems,\n            eras, actions), era\u2192generator/system references\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Balance Validation:</strong> Pressure sources/sinks (feedback, homeostasis,\n            generators, systems), orphan generators/systems (not in any era)\n          </li>\n          <li className=\"validation-rule-item\">\n            <span className=\"validation-rule-bullet text-warning\">\u25cf</span>\n            <strong>Configuration Quality:</strong> Subtypes, statuses, cultures, tags, numeric\n            ranges\n          </li>\n        </ul>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema = DEFAULT_SCHEMA,\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions: _actions = [],\n  usageMap = null,\n  onNavigateToGenerator,\n}", "type": "{ schema?: Readonly<{ entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; }>; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; usageMap?: any; onNavigateToGenerator: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "p", "button", "div", "IssueCard", "DependencyViewer", "NamingProfileMappingViewer", "strong"], "hookCalls": [{"name": "useMemo", "count": 3}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../DependencyViewer", "specifiers": ["DependencyViewer"], "category": "internal"}, {"source": "../NamingProfileMappingViewer", "specifiers": ["NamingProfileMappingViewer"], "category": "internal"}, {"source": "./validation.css", "specifiers": [], "category": "internal"}, {"source": "./utils", "specifiers": ["exportAsJson", "exportAsCsv", "runValidations", "getOverallStatus", "validationRules"], "category": "internal"}, {"source": "./cards", "specifiers": ["IssueCard"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/weight-matrix/index.js::WeightMatrixEditor", "name": "WeightMatrixEditor", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/weight-matrix/index.js", "sourceCode": "export default function WeightMatrixEditor({\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}) {\n  const [viewMode, setViewMode] = useState(\"generators\"); // 'generators' | 'systems'\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [editingCell, setEditingCell] = useState(null); // shape: rowId + eraId\n  const [editValue, setEditValue] = useState(\"\");\n  const [selectedRows, setSelectedRows] = useState(new Set());\n  const [copiedRow, setCopiedRow] = useState(null); // { id, weights: { eraId: value } }\n  const inputRef = useRef(null);\n\n  // Get current items based on view mode\n  const items = useMemo(() => {\n    const source = viewMode === \"generators\" ? generators : systems;\n    return source.map(item => ({\n      id: viewMode === \"generators\" ? item.id : item.config.id,\n      name: viewMode === \"generators\" ? item.name || item.id : item.config.name || item.config.id,\n      type: viewMode === \"generators\" ? \"generator\" : item.systemType\n    }));\n  }, [viewMode, generators, systems]);\n\n  // Detect orphaned references - IDs in eras that don't exist in generators/systems\n  const orphanedReferences = useMemo(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const orphanedGenerators = [];\n    const orphanedSystems = [];\n    eras.forEach(era => {\n      // Check template weights\n      Object.keys(era.templateWeights || {}).forEach(id => {\n        if (!generatorIds.has(id)) {\n          orphanedGenerators.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n\n      // Check system modifiers\n      Object.keys(era.systemModifiers || {}).forEach(id => {\n        if (!systemIds.has(id)) {\n          orphanedSystems.push({\n            id,\n            eraId: era.id,\n            eraName: era.name\n          });\n        }\n      });\n    });\n    return {\n      generators: orphanedGenerators,\n      systems: orphanedSystems\n    };\n  }, [eras, generators, systems]);\n\n  // Count total orphans\n  const totalOrphans = orphanedReferences.generators.length + orphanedReferences.systems.length;\n\n  // Clean up all orphaned references\n  const cleanupOrphanedReferences = useCallback(() => {\n    const generatorIds = new Set(generators.map(g => g.id));\n    const systemIds = new Set(systems.map(s => s.config.id));\n    const newEras = eras.map(era => {\n      const newTemplateWeights = {\n        ...era.templateWeights\n      };\n      const newSystemModifiers = {\n        ...era.systemModifiers\n      };\n\n      // Remove orphaned generator references\n      Object.keys(newTemplateWeights).forEach(id => {\n        if (!generatorIds.has(id)) {\n          delete newTemplateWeights[id];\n        }\n      });\n\n      // Remove orphaned system references\n      Object.keys(newSystemModifiers).forEach(id => {\n        if (!systemIds.has(id)) {\n          delete newSystemModifiers[id];\n        }\n      });\n      return {\n        ...era,\n        templateWeights: newTemplateWeights,\n        systemModifiers: newSystemModifiers\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, generators, systems, onErasChange]);\n\n  // Filter items by search\n  const filteredItems = useMemo(() => {\n    if (!searchQuery) return items;\n    const query = searchQuery.toLowerCase();\n    return items.filter(item => item.id.toLowerCase().includes(query) || item.name.toLowerCase().includes(query));\n  }, [items, searchQuery]);\n\n  // Get weight for an item in an era\n  const getWeight = useCallback((itemId, eraId) => {\n    const era = eras.find(e => e.id === eraId);\n    if (!era) return null;\n    const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n    return weights?.[itemId] ?? null;\n  }, [eras, viewMode]);\n\n  // Set weight for an item in an era\n  const setWeight = useCallback((itemId, eraId, value) => {\n    const newEras = eras.map(era => {\n      if (era.id !== eraId) return era;\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === \"\" || value === undefined) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = parseFloat(value) || 0;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  }, [eras, viewMode, onErasChange]);\n\n  // Handle cell click to start editing\n  const handleCellClick = (rowId, eraId) => {\n    const currentValue = getWeight(rowId, eraId);\n    setEditingCell({\n      rowId,\n      eraId\n    });\n    setEditValue(currentValue !== null ? String(currentValue) : \"\");\n    setTimeout(() => inputRef.current?.select(), 0);\n  };\n\n  // Handle cell edit completion\n  const handleCellBlur = () => {\n    if (editingCell) {\n      const value = editValue.trim();\n      if (value === \"\") {\n        setWeight(editingCell.rowId, editingCell.eraId, null);\n      } else {\n        const numValue = parseFloat(value);\n        if (!isNaN(numValue)) {\n          setWeight(editingCell.rowId, editingCell.eraId, numValue);\n        }\n      }\n      setEditingCell(null);\n    }\n  };\n\n  // Handle keyboard navigation\n  const handleKeyDown = e => {\n    if (e.key === \"Enter\" || e.key === \"Tab\") {\n      e.preventDefault();\n      handleCellBlur();\n    } else if (e.key === \"Escape\") {\n      setEditingCell(null);\n    }\n  };\n\n  // Apply weight to all eras for a row\n  const applyToAllEras = (itemId, value) => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (value === null || value === 0) {\n        delete weights[itemId];\n      } else {\n        weights[itemId] = value;\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Copy row weights\n  const copyRow = itemId => {\n    const weights = {};\n    eras.forEach(era => {\n      const value = getWeight(itemId, era.id);\n      if (value !== null) {\n        weights[era.id] = value;\n      }\n    });\n    setCopiedRow({\n      id: itemId,\n      weights\n    });\n  };\n\n  // Paste row weights\n  const pasteRow = targetItemId => {\n    if (!copiedRow) return;\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      if (copiedRow.weights[era.id] !== undefined) {\n        weights[targetItemId] = copiedRow.weights[era.id];\n      } else {\n        delete weights[targetItemId];\n      }\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Remove from all eras\n  const removeFromAllEras = itemId => {\n    const newEras = eras.map(era => {\n      const weightsKey = viewMode === \"generators\" ? \"templateWeights\" : \"systemModifiers\";\n      const weights = {\n        ...era[weightsKey]\n      };\n      delete weights[itemId];\n      return {\n        ...era,\n        [weightsKey]: weights\n      };\n    });\n    onErasChange(newEras);\n  };\n\n  // Check if item is used in any era\n  const isUsedInAnyEra = itemId => {\n    return eras.some(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] !== undefined && weights[itemId] !== null;\n    });\n  };\n\n  // Count eras where item is active\n  const countActiveEras = itemId => {\n    return eras.filter(era => {\n      const weights = viewMode === \"generators\" ? era.templateWeights : era.systemModifiers;\n      return weights?.[itemId] > 0;\n    }).length;\n  };\n\n  // Quick set weight for bulk operations\n  const [quickSetValue, setQuickSetValue] = useState(1);\n  const handleQuickSetSelected = () => {\n    const value = quickSetValue ?? 0;\n    selectedRows.forEach(itemId => {\n      applyToAllEras(itemId, value);\n    });\n    setSelectedRows(new Set());\n  };\n  const toggleRowSelection = itemId => {\n    const newSelection = new Set(selectedRows);\n    if (newSelection.has(itemId)) {\n      newSelection.delete(itemId);\n    } else {\n      newSelection.add(itemId);\n    }\n    setSelectedRows(newSelection);\n  };\n  const selectAllRows = () => {\n    if (selectedRows.size === filteredItems.length) {\n      setSelectedRows(new Set());\n    } else {\n      setSelectedRows(new Set(filteredItems.map(i => i.id)));\n    }\n  };\n  return <div className=\"weight-matrix-editor\">\n      <div className=\"header\">\n        <h1 className=\"title\">Weight Matrix</h1>\n        <p className=\"subtitle\">\n          Manage {viewMode} weights across all eras in a spreadsheet view. Click any cell to edit,\n          or use row actions for bulk operations.\n        </p>\n      </div>\n\n      {/* Orphaned References Warning */}\n      {totalOrphans > 0 && <div className=\"orphan-warning\">\n          <div className=\"orphan-warning-content\">\n            <span className=\"orphan-warning-icon\">\u26a0\ufe0f</span>\n            <div className=\"orphan-warning-text\">\n              <strong>\n                {totalOrphans} orphaned reference{totalOrphans !== 1 ? \"s\" : \"\"} detected\n              </strong>\n              <span className=\"orphan-warning-details\">\n// ... (truncated)", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  eras = [],\n  onErasChange\n}", "type": "{ generators?: any[]; systems?: any[]; eras?: any[]; onErasChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h1", "p", "span", "strong", "button", "input", "NumberInput", "th", "td"], "hookCalls": [{"name": "useState", "count": 7}, {"name": "useRef", "count": 1}, {"name": "useMemo", "count": 3}, {"name": "useCallback", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/generator/index.js::GenerateTab", "name": "GenerateTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/generator/index.js", "sourceCode": "/**\n * Generate Tab - Full control over name generation\n *\n * Note: Conditions (entityKind, subtype, tags, prominence) are evaluated at the\n * strategy GROUP level within profiles, not at the profile level. The generator\n * filters which strategy groups apply based on the generation context.\n */\nfunction GenerateTab({ worldSchema, cultures, formState, onFormStateChange }) {\n  // Use lifted state if provided, otherwise use local state\n  const [localState, setLocalState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }], // Start with one empty row\n  });\n\n  // Use formState from parent if available\n  const state = formState || localState;\n  const setState = onFormStateChange || setLocalState;\n\n  // Destructure for convenience\n  const {\n    selectedCulture,\n    selectedProfile,\n    selectedKind,\n    selectedSubKind,\n    tags,\n    prominence,\n    count,\n    contextPairs,\n  } = state;\n\n  // Update helpers\n  const updateField = (field, value) => {\n    setState({ ...state, [field]: value });\n  };\n\n  // Results\n  const [generatedNames, setGeneratedNames] = useState([]);\n  const [debugInfo, setDebugInfo] = useState([]);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [generating, setGenerating] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Get available options from schema\n  const cultureIds = Object.keys(cultures || {});\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  // Get profiles for selected culture\n  const availableProfiles = useMemo(() => {\n    if (!selectedCulture) return [];\n    return cultures[selectedCulture]?.naming?.profiles || [];\n  }, [selectedCulture, cultures]);\n\n  // Auto-select first profile when culture changes\n  useMemo(() => {\n    if (availableProfiles.length > 0 && !selectedProfile) {\n      updateField(\"selectedProfile\", availableProfiles[0].id);\n    } else if (availableProfiles.length === 0 && selectedProfile) {\n      updateField(\"selectedProfile\", \"\");\n    }\n  }, [availableProfiles]);\n\n  // Get subkinds for selected entity kind\n  const subKinds = useMemo(() => {\n    if (!selectedKind || !worldSchema?.entityKinds) return [];\n    const entity = worldSchema.entityKinds.find((e) => e.kind === selectedKind);\n    return entity?.subtypes?.map((s) => s.id) || [];\n  }, [selectedKind, worldSchema]);\n\n  // Prominence levels\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  // Get the culture for generation\n  const getSelectedCulture = () => {\n    if (!selectedCulture) return null;\n    return cultures[selectedCulture] || null;\n  };\n\n  // Context pair handlers\n  const handleAddContextPair = () => {\n    updateField(\"contextPairs\", [...contextPairs, { key: \"\", value: \"\" }]);\n  };\n\n  const handleRemoveContextPair = (index) => {\n    const newPairs = contextPairs.filter((_, i) => i !== index);\n    // Always keep at least one row\n    updateField(\"contextPairs\", newPairs.length > 0 ? newPairs : [{ key: \"\", value: \"\" }]);\n  };\n\n  const handleUpdateContextPair = (index, field, value) => {\n    const updated = [...contextPairs];\n    updated[index] = { ...updated[index], [field]: value };\n    updateField(\"contextPairs\", updated);\n  };\n\n  const handleGenerate = async () => {\n    setError(null);\n    setGenerating(true);\n\n    try {\n      const culture = getSelectedCulture();\n\n      if (!culture) {\n        throw new Error(\"No culture selected.\");\n      }\n\n      if (!culture?.naming?.profiles || culture.naming.profiles.length === 0) {\n        throw new Error(\"No profile found. Create a profile in Workshop \u2192 Profiles.\");\n      }\n\n      // Parse tags for condition matching\n      const tagList = Array.isArray(tags) ? tags : [];\n\n      // Build context object from key-value pairs for grammar context:key slots\n      const userContext = {};\n      for (const pair of contextPairs) {\n        if (pair.key) {\n          userContext[pair.key] = pair.value;\n        }\n      }\n\n      // Add standard fields to context as well\n      if (selectedKind) userContext.entityKind = selectedKind;\n      if (selectedSubKind) userContext.subtype = selectedSubKind;\n      if (prominence) userContext.prominence = prominence;\n      if (tagList.length > 0) userContext.tags = tagList.join(\",\");\n\n      // Generate names - pass culture directly\n      const result = await generateTestNames({\n        culture,\n        profileId: selectedProfile || undefined,\n        count,\n        seed: `generate-${Date.now()}`,\n        context: userContext,\n        kind: selectedKind || undefined,\n        subtype: selectedSubKind || undefined,\n        prominence: prominence || undefined,\n        tags: tagList,\n      });\n\n      setGeneratedNames(result.names || []);\n      setDebugInfo(result.debugInfo || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setError(err.message);\n      setGeneratedNames([]);\n      setDebugInfo([]);\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  const handleCopy = () => {\n    navigator.clipboard.writeText(generatedNames.join(\"\\n\"));\n  };\n\n  const handleCopyJson = () => {\n    navigator.clipboard.writeText(JSON.stringify(generatedNames, null, 2));\n  };\n\n  // Check if we can generate\n  const canGenerate = selectedCulture;\n  const culture = canGenerate ? getSelectedCulture() : null;\n  const hasProfile = culture?.naming?.profiles?.length > 0;\n\n  return (\n    <div className=\"generate-container\">\n      <h2>Name Generator</h2>\n      <p className=\"text-muted intro\">\n        Generate names using configured profiles. Strategy groups with conditions will be filtered\n        based on entity type, subtype, tags, and prominence.\n      </p>\n\n      <div className=\"generate-layout\">\n        {/* Left: Controls */}\n        <div className=\"generate-controls\">\n          <div className=\"card mb-md\">\n            <h3 className=\"mt-0 mb-md\">Generation Settings</h3>\n\n            {/* Culture Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"culture\">Culture *</label>\n              <select id=\"culture\"\n                value={selectedCulture}\n                onChange={(e) => {\n                  setState({ ...state, selectedCulture: e.target.value, selectedProfile: \"\" });\n                }}\n              >\n                <option value=\"\">Select a culture...</option>\n                {cultureIds.map((id) => (\n                  <option key={id} value={id}>\n                    {cultures[id]?.name || id}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            {/* Profile Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"profile\">Profile</label>\n              <select id=\"profile\"\n                value={selectedProfile}\n                onChange={(e) => updateField(\"selectedProfile\", e.target.value)}\n                disabled={availableProfiles.length === 0}\n              >\n                {availableProfiles.length === 0 ? (\n                  <option value=\"\">No profiles available</option>\n                ) : (\n                  availableProfiles.map((p) => (\n                    <option key={p.id} value={p.id}>\n                      {p.id}\n                    </option>\n                  ))\n                )}\n              </select>\n            </div>\n\n            <div className=\"generate-section-divider\">\n              <div className=\"generate-section-header\">\n                Context (for conditional strategy groups)\n              </div>\n\n              {/* Entity Kind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"entity-kind\">Entity Kind</label>\n                <select id=\"entity-kind\"\n                  value={selectedKind}\n                  onChange={(e) => {\n                    setState({ ...state, selectedKind: e.target.value, selectedSubKind: \"\" });\n                  }}\n                >\n                  <option value=\"\">Any type</option>\n                  {entityKinds.map((kind) => (\n                    <option key={kind} value={kind}>\n                      {kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* SubKind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"subtype\">Subtype</label>\n                <select id=\"subtype\"\n                  value={selectedSubKind}\n                  onChange={(e) => updateField(\"selectedSubKind\", e.target.value)}\n                  disabled={subKinds.length === 0}\n                >\n                  <option value=\"\">Any subtype</option>\n                  {subKinds.map((sub) => (\n                    <option key={sub} value={sub}>\n                      {sub}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Tags */}\n              <div className=\"form-group\">\n                <label>Tags\n                <TagSelector\n                  value={tags || []}\n                  onChange={(vals) => updateField(\"tags\", vals)}\n                  tagRegistry={tagRegistry}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n\n              {/* Prominence */}\n              <div className=\"form-group\">\n                <label htmlFor=\"prominence\">Prominence</label>\n                <select id=\"prominence\"\n                  value={prominence}\n                  onChange={(e) => updateField(\"prominence\", e.target.value)}\n                >\n                  <option value=\"\">Any prominence</option>\n                  {prominenceLevels.map((level) => (\n                    <option key={level} value={level}>\n                      {level}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            {/* Context Key-Value Pairs */}\n            <div className=\"generate-section-divider\">\n              <div className=\"flex justify-between items-center mb-sm\">\n                <div className=\"generate-section-header mb-0\">\n                  Context Values\n                  <span className=\"hint\">(for context:key slots)</span>\n                </div>\n                <button type=\"button\" onClick={handleAddContextPair} className=\"add-row-btn\">\n// ... (truncated)", "parameters": [{"name": "{ worldSchema, cultures, formState, onFormStateChange }", "type": "{ worldSchema: any; cultures: any; formState: any; onFormStateChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h2", "p", "h3", "label", "option", "div", "TagSelector", "span", "button", "input", "small", "NumberInput", "h4", "strong"], "hookCalls": [{"name": "useState", "count": 6}, {"name": "useMemo", "count": 3}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/modals/index.js::ConditionsModal", "name": "ConditionsModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/modals/index.js", "sourceCode": "function ConditionsModal({ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }) {\n  const [localConditions, setLocalConditions] = useState(conditions || {});\n\n  useEffect(() => {\n    setLocalConditions(conditions || {});\n  }, [conditions, isOpen]);\n\n  const handleSave = () => {\n    // Clean up empty values\n    const cleaned = {};\n    if (localConditions.tags?.length > 0) cleaned.tags = localConditions.tags;\n    if (localConditions.requireAllTags) cleaned.requireAllTags = true;\n    if (localConditions.prominence?.length > 0) cleaned.prominence = localConditions.prominence;\n    if (localConditions.subtype?.length > 0) cleaned.subtype = localConditions.subtype;\n\n    onChange(Object.keys(cleaned).length > 0 ? cleaned : undefined);\n    onClose();\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <ModalShell onClose={onClose} title=\"Strategy Conditions\" className=\"conditions-modal\">\n      <p className=\"text-muted text-small mt-0\">\n        Define when this strategy should be used. Leave empty for unconditional use.\n      </p>\n\n      {/* Tags */}\n      <div className=\"form-group\">\n        <label>Entity Tags\n        <TagSelector\n          value={localConditions.tags || []}\n          onChange={(tags) =>\n            setLocalConditions({ ...localConditions, tags: tags.length > 0 ? tags : undefined })\n          }\n          tagRegistry={tagRegistry}\n          placeholder=\"Select tags...\"\n          matchAllEnabled={true}\n          matchAll={localConditions.requireAllTags || false}\n          onMatchAllChange={(val) =>\n            setLocalConditions({ ...localConditions, requireAllTags: val || undefined })\n          }\n          onAddToRegistry={onAddTag}\n        />\n        </label>\n        <small className=\"text-muted\">\n          Use tags from the shared registry; toggle match-all when needed.\n        </small>\n      </div>\n\n      {/* Prominence */}\n      <div className=\"form-group\">\n        <span>Prominence Levels</span>\n        <div className=\"flex flex-wrap gap-sm mt-xs\">\n          {PROMINENCE_LEVELS.map((level) => {\n            const isSelected = (localConditions.prominence || []).includes(level);\n            return (\n              <button\n                key={level}\n                type=\"button\"\n                onClick={() => {\n                  const current = localConditions.prominence || [];\n                  const updated = isSelected\n                    ? current.filter((l) => l !== level)\n                    : [...current, level];\n                  setLocalConditions({\n                    ...localConditions,\n                    prominence: updated.length > 0 ? updated : undefined,\n                  });\n                }}\n                className={`pill-button ${isSelected ? \"selected-gold\" : \"\"}`}\n              >\n                {level}\n              </button>\n            );\n          })}\n        </div>\n        <small className=\"text-muted mt-sm block\">\n          Only use this strategy for entities with selected prominence levels\n        </small>\n      </div>\n\n      {/* Subtype */}\n      <div className=\"form-group\">\n        <label htmlFor=\"entity-subtypes\">Entity Subtypes</label>\n        <input id=\"entity-subtypes\"\n          value={(localConditions.subtype || []).join(\", \")}\n          onChange={(e) => {\n            const subtypes = e.target.value\n              .split(\",\")\n              .map((t) => t.trim())\n              .filter((t) => t);\n            setLocalConditions({\n              ...localConditions,\n              subtype: subtypes.length > 0 ? subtypes : undefined,\n            });\n          }}\n          placeholder=\"e.g., merchant, artisan, warrior\"\n        />\n        <small className=\"text-muted\">Comma-separated list of subtypes to match</small>\n      </div>\n\n      {/* Summary */}\n      {(localConditions.tags?.length > 0 ||\n        localConditions.prominence?.length > 0 ||\n        localConditions.subtype?.length > 0) && (\n        <div className=\"conditions-preview\">\n          <strong className=\"text-gold\">Preview:</strong> This strategy will be used when entity has{\" \"}\n          {[\n            localConditions.tags?.length > 0 &&\n              `${localConditions.requireAllTags ? \"ALL\" : \"any\"} tags: ${localConditions.tags.join(\", \")}`,\n            localConditions.prominence?.length > 0 &&\n              `prominence: ${localConditions.prominence.join(\" or \")}`,\n            localConditions.subtype?.length > 0 &&\n              `subtype: ${localConditions.subtype.join(\" or \")}`,\n          ]\n            .filter(Boolean)\n            .join(\" AND \")}\n        </div>\n      )}\n\n      <div className=\"flex gap-md mt-lg justify-end\">\n        <button className=\"secondary\" onClick={onClose}>\n          Cancel\n        </button>\n        <button className=\"primary\" onClick={handleSave}>\n          Save Conditions\n        </button>\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }", "type": "{ isOpen: any; onClose: any; conditions: any; onChange: any; tagRegistry?: any[]; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["p", "TagSelector", "small", "span", "button", "label", "input", "strong"], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::OptimizerWorkshop", "name": "OptimizerWorkshop", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["DomainSelector", "OptimizerSettings", "ResultsModal"], "hookCalls": [{"name": "useState", "count": 11}, {"name": "useMemo", "count": 2}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::DomainSelector", "name": "DomainSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * DomainSelector - Left panel for selecting domains to optimize\n */\nexport default function DomainSelector({\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}) {\n  return (\n    <div className=\"optimizer-sidebar\">\n      <div className=\"optimizer-sidebar-header\">\n        <h3 className=\"mt-0 mb-sm text-small\">Select Domains</h3>\n        <div className=\"flex gap-sm\">\n          <button onClick={onSelectAll} className=\"secondary btn-xs\">\n            Select All\n          </button>\n          <button onClick={onDeselectAll} className=\"secondary btn-xs\">\n            Clear\n          </button>\n        </div>\n        <div className=\"mt-sm text-small text-muted\">\n          {selectedDomains.size} of {allDomains.length} selected\n        </div>\n      </div>\n\n      <div className=\"optimizer-sidebar-list\">\n        {Object.entries(domainsByCulture).map(([cultureId, { name, domains }]) => {\n          const isExpanded = expandedCultures.has(cultureId);\n          const allSelected = domains.every((d) => selectedDomains.has(d.id));\n          const someSelected = domains.some((d) => selectedDomains.has(d.id));\n\n          return (\n            <div key={cultureId} className=\"mb-sm\">\n              <div className=\"culture-row\">\n                <input\n                  type=\"checkbox\"\n                  checked={allSelected}\n                  ref={(el) => {\n                    if (el) el.indeterminate = someSelected && !allSelected;\n                  }}\n                  onChange={() => onToggleAllInCulture(cultureId)}\n                  onClick={(e) => e.stopPropagation()}\n                  className=\"accent-ice\"\n                />\n                <span onClick={() => onToggleCulture(cultureId)} className=\"culture-row-label\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  {isExpanded ? \"\u25bc\" : \"\u25b6\"} {name || cultureId}\n                  <span className=\"text-muted font-normal ml-sm\">({domains.length})</span>\n                </span>\n              </div>\n\n              {isExpanded && (\n                <div className=\"domain-list\">\n                  {domains.map((domain) => (\n                    <div\n                      key={domain.id}\n                      className={`domain-row ${selectedDomains.has(domain.id) ? \"selected\" : \"\"}`}\n                      onClick={() => onToggleDomain(domain.id)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedDomains.has(domain.id)}\n                        onChange={() => onToggleDomain(domain.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        className=\"accent-gold\"\n                      />\n                      <span>{domain.id}</span>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          );\n        })}\n\n        {allDomains.length === 0 && (\n          <div className=\"empty-message\">\n            No domains found. Create domains in the Workshop tab first.\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}", "type": "{ domainsByCulture: any; allDomains: any; selectedDomains: any; expandedCultures: any; onToggleDomain: any; onToggleCulture: any; onToggleAllInCulture: any; onSelectAll: any; onDeselectAll: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "div", "input", "span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::DomainDiff", "name": "DomainDiff", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Domain Diff Component - Shows what changed in a collapsible format\n */\nexport default function DomainDiff({ initial, optimized }) {\n  const changes = useMemo(() => computeDomainDiff(initial, optimized), [initial, optimized]);\n\n  if (changes.length === 0) {\n    return <div className=\"text-muted italic p-sm\">No changes detected</div>;\n  }\n\n  return (\n    <div className=\"text-small\">\n      {changes.map((change, i) => (\n        <div key={i} className={`diff-row ${i % 2 === 0 ? \"alt\" : \"\"}`}>\n          <div className=\"diff-path\">{change.path}</div>\n\n          {change.type === \"scalar\" && (\n            <div className=\"flex align-center gap-sm\">\n              <span className=\"diff-old\">{String(change.oldValue)}</span>\n              <span className=\"text-muted\">\u2192</span>\n              <span className=\"diff-new\">{String(change.newValue)}</span>\n            </div>\n          )}\n\n          {change.type === \"set\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.removed.map((item, j) => (\n                <span key={`r${j}`} className=\"diff-tag removed\">\n                  -{item}\n                </span>\n              ))}\n              {change.added.map((item, j) => (\n                <span key={`a${j}`} className=\"diff-tag added\">\n                  +{item}\n                </span>\n              ))}\n            </div>\n          )}\n\n          {change.type === \"weights\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.changes.slice(0, 8).map((c, j) => (\n                <span key={j} className=\"diff-weight\">\n                  <strong className=\"text-gold\">{c.label}</strong>: {c.oldVal}\u2192{c.newVal}\n                </span>\n              ))}\n              {change.changes.length > 8 && (\n                <span className=\"text-muted text-small\">+{change.changes.length - 8} more</span>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ initial, optimized }", "type": "{ initial: any; optimized: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div"], "hookCalls": [{"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::OptimizerSettings", "name": "OptimizerSettings", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * OptimizerSettings - Right panel for algorithm settings and optimization controls\n */\nexport default function OptimizerSettings({\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}) {\n  const handleAlgorithmParamChange = (key, defaultValue) => (v) => {\n    onAlgorithmParamsChange((prev) => ({ ...prev, [key]: v ?? defaultValue }));\n  };\n\n  // Render algorithm parameter inputs\n  const renderAlgorithmParams = () => {\n    const config = ALGORITHMS[algorithm];\n    if (!config?.params || Object.keys(config.params).length === 0) {\n      return (\n        <p className=\"text-muted text-small italic\">No additional parameters for this algorithm.</p>\n      );\n    }\n\n    return (\n      <div className=\"optimizer-param-grid\">\n        {Object.entries(config.params).map(([key, param]) => (\n          <div key={key} className=\"flex flex-col gap-xs\">\n            <label className=\"text-small\">{param.label}\n            <NumberInput\n              value={algorithmParams[key] ?? param.default}\n              onChange={handleAlgorithmParamChange(key, param.default)}\n              min={param.min}\n              max={param.max}\n              step={param.step || 1}\n              className=\"optimizer-input\"\n            />\n            </label>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"optimizer-main\">\n      {/* Settings */}\n      <div className=\"optimizer-settings-area\">\n        <h2 className=\"mt-0 mb-md\">Optimizer Settings</h2>\n\n        {/* Algorithm Selection */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm</h3>\n          <div className=\"algorithm-grid\">\n            {Object.entries(ALGORITHMS).map(([key, config]) => (\n              <div\n                key={key}\n                onClick={() => onAlgorithmChange(key)}\n                className={`algorithm-card ${algorithm === key ? \"selected\" : \"\"}`}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className={`algorithm-name ${algorithm === key ? \"selected\" : \"\"}`}>\n                  {config.name}\n                </div>\n                <div className=\"algorithm-desc\">{config.description}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Algorithm-Specific Parameters */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm Parameters</h3>\n          {renderAlgorithmParams()}\n        </div>\n\n        {/* Validation Settings */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Validation Settings</h3>\n          <div className=\"optimizer-param-grid-small\">\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Size\n              <NumberInput\n                value={validationSettings.requiredNames}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, requiredNames: v ?? 500 }))\n                }\n                min={100}\n                max={5000}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Factor\n              <NumberInput\n                value={validationSettings.sampleFactor}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, sampleFactor: v ?? 10 }))\n                }\n                min={1}\n                max={50}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        {/* Fitness Weights */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Fitness Weights</h3>\n          <div className=\"fitness-grid\">\n            {[\n              { key: \"capacity\", label: \"Capacity\", title: \"Entropy / collision rate\" },\n              { key: \"diffuseness\", label: \"Diffuseness\", title: \"Intra-domain variation\" },\n              { key: \"separation\", label: \"Separation\", title: \"Inter-domain distinctiveness\" },\n              { key: \"pronounceability\", label: \"Pronounce\", title: \"Phonetic naturalness\" },\n              { key: \"length\", label: \"Length\", title: \"Target length adherence\" },\n              { key: \"style\", label: \"Style\", title: \"LLM style judge (optional)\" },\n            ].map(({ key, label, title }) => (\n              <div key={key} className=\"flex flex-col gap-xs\">\n                <label className=\"text-small\" title={title}>\n                  {label}\n                </label>\n                <NumberInput\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  value={fitnessWeights[key]}\n                  onChange={(v) => onFitnessWeightsChange((prev) => ({ ...prev, [key]: v ?? 0 }))}\n                  title={title}\n                  disabled={key === \"separation\" && allDomains.length <= 1}\n                  className={`optimizer-input ${key === \"separation\" && allDomains.length <= 1 ? \"disabled\" : \"\"}`}\n                />\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Run Button */}\n        <div className=\"flex gap-md align-center flex-wrap\">\n          <button\n            onClick={onOptimize}\n            disabled={optimizing || selectedDomains.size === 0}\n            className={`optimize-button ${optimizing || selectedDomains.size === 0 ? \"disabled\" : \"\"}`}\n          >\n            {optimizing ? \"Optimizing...\" : `Optimize ${selectedDomains.size} Domain(s)`}\n          </button>\n\n          {results.length > 0 && results.some((r) => r.success) && (\n            <button onClick={onSaveResults} className=\"secondary optimize-action-button\">\n              Save Results\n            </button>\n          )}\n\n          {optimizing && (\n            <span className=\"text-small text-muted\">\n              {progress.current}/{progress.total}: {progress.currentDomain}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Status Bar - Shows when there are results */}\n      {results.length > 0 && !optimizing && (\n        <div className=\"optimizer-status-bar\">\n          <div className=\"flex align-center gap-md\">\n            <span className=\"text-small\">\n              Last run:{\" \"}\n              <strong className=\"text-success\">{results.filter((r) => r.success).length}</strong>{\" \"}\n              succeeded,{\" \"}\n              <strong className={results.some((r) => !r.success) ? \"text-danger\" : \"\"}>\n                {results.filter((r) => !r.success).length}\n              </strong>{\" \"}\n              failed\n            </span>\n            {results.filter((r) => r.success).length > 0 && (\n              <span className=\"text-gold font-bold text-small\">\n                Avg improvement: +\n                {(\n                  (results\n                    .filter((r) => r.success)\n                    .reduce((sum, r) => sum + (r.improvement || 0), 0) /\n                    results.filter((r) => r.success).length) *\n                  100\n                ).toFixed(1)}\n                %\n              </span>\n            )}\n          </div>\n          <button onClick={onShowModal} className=\"secondary text-small\">\n            View Details\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}", "type": "{ algorithm: any; onAlgorithmChange: any; algorithmParams: any; onAlgorithmParamsChange: any; validationSettings: any; onValidationSettingsChange: any; fitnessWeights: any; onFitnessWeightsChange: any; selectedDomains: any; allDomains: any; optimizing: any; progress: any; results: any; onOptimize: any; onSaveResults: any; onShowModal: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["p"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::ResultsModal", "name": "ResultsModal", "kind": "component", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * ResultsModal - Modal showing optimization progress and results\n */\nexport default function ResultsModal({\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}) {\n  const [expandedResults, setExpandedResults] = useState(new Set());\n  const toggleExpand = domainId => {\n    setExpandedResults(prev => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n  if (!show) return null;\n  return <div className=\"optimizer-modal-overlay\" onClick={e => {\n    if (e.target === e.currentTarget && !optimizing) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"optimizer-modal\">\n        {/* Modal Header */}\n        <div className=\"optimizer-modal-header\">\n          <h2 className=\"mt-0 mb-0\">\n            {optimizing ? \"Optimization in Progress...\" : \"Optimization Results\"}\n          </h2>\n          {!optimizing && <button onClick={onClose} className=\"modal-close-btn\">\n              \u00d7\n            </button>}\n        </div>\n\n        {/* Progress Bar (during optimization) */}\n        {optimizing && <div className=\"optimizer-progress-section\">\n            <div className=\"flex justify-between mb-sm\">\n              <span className=\"text-small\">\n                Processing: <strong>{progress.currentDomain}</strong>\n              </span>\n              <span className=\"text-small text-muted\">\n                {progress.current} / {progress.total}\n              </span>\n            </div>\n            <div className=\"progress-bar-track\">\n              <div className=\"progress-bar-fill rm-progress-bar-fill\" style={{\n            '--rm-progress-width': `${progress.total > 0 ? progress.current / progress.total * 100 : 0}%`\n          }} />\n            </div>\n          </div>}\n\n        {/* Modal Body - Log and Results */}\n        <div className=\"optimizer-modal-body\">\n          {/* Log Section */}\n          <div className=\"optimizer-log-section\">\n            <h3 className=\"section-title mt-0\">Optimization Log</h3>\n            <div className=\"optimizer-log\">\n              {logs.map((log, i) => <div key={i} className={`log-entry ${log.type}`}>\n                  {log.message}\n                </div>)}\n              {logs.length === 0 && <div className=\"text-muted italic\">Waiting for optimization to start...</div>}\n            </div>\n\n            {/* Results Table */}\n            {results.length > 0 && <div className=\"mt-lg\">\n                <h3 className=\"section-title mt-0\">Results Summary</h3>\n                <div className=\"results-table-container\">\n                  <table className=\"results-table\">\n                    <thead>\n                      <tr>\n                        <th className=\"col-expand\"></th>\n                        <th>Domain</th>\n                        <th className=\"text-right\">Initial</th>\n                        <th className=\"text-right\">Final</th>\n                        <th className=\"text-right\">Improvement</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {results.map((result, i) => <ResultRow key={result.domainId} result={result} index={i} isExpanded={expandedResults.has(result.domainId)} onToggle={toggleExpand} />)}\n                    </tbody>\n                  </table>\n                </div>\n              </div>}\n          </div>\n        </div>\n\n        {/* Modal Footer */}\n        <div className=\"optimizer-modal-footer\">\n          {results.length > 0 && results.some(r => r.success) && !optimizing && <button onClick={onSaveResults} className=\"optimize-button\">\n              Save Results\n            </button>}\n          <button onClick={onClose} disabled={optimizing} className={`secondary optimize-action-button ${optimizing ? \"disabled\" : \"\"}`}>\n            {optimizing ? \"Running...\" : \"Close\"}\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}", "type": "{ show: any; onClose: any; optimizing: any; progress: any; logs: any; results: any; onSaveResults: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h2", "button", "strong", "span", "div", "h3", "th", "ResultRow"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button", "div"], "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ExpandableCard", "name": "ExpandableCard", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::IconButton", "name": "IconButton", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button", "div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::FormGroup", "name": "FormGroup", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::FormRow", "name": "FormRow", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * FormRow - Horizontal layout for multiple form groups\n */\nexport function FormRow({ children, className = '' }) {\n  return (\n    <div className={`form-row ${className}`.trim()}>\n      {children}\n    </div>\n  );\n}", "parameters": [{"name": "{ children, className = '' }", "type": "{ children: any; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "button", "input", "div"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "option"], "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["rect", "input"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div", "span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::TagSelector", "name": "TagSelector", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export default function TagSelector({\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [highlightedIndex, setHighlightedIndex] = useState(0);\n  const [hoveredInvalidTag, setHoveredInvalidTag] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const tagLookup = useMemo(() => {\n    const lookup = {};\n    tagRegistry.forEach((tagDef) => {\n      lookup[tagDef.tag] = tagDef;\n    });\n    return lookup;\n  }, [tagRegistry]);\n\n  const groupedTags = useMemo(() => {\n    const groups = {};\n    const filtered = tagRegistry.filter((tagDef) => {\n      const normalizedQuery = searchQuery.toLowerCase();\n      const matchesSearch =\n        !searchQuery ||\n        tagDef.tag.toLowerCase().includes(normalizedQuery) ||\n        tagDef.description?.toLowerCase().includes(normalizedQuery);\n      return matchesSearch && !value.includes(tagDef.tag);\n    });\n\n    filtered.forEach((tagDef) => {\n      if (!groups[tagDef.category]) {\n        groups[tagDef.category] = [];\n      }\n      groups[tagDef.category].push(tagDef);\n    });\n\n    return groups;\n  }, [searchQuery, tagRegistry, value]);\n\n  const canCreateTag = useMemo(() => {\n    if (!searchQuery.trim()) return false;\n    const normalized = searchQuery.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');\n    if (!normalized) return false;\n    if (tagLookup[normalized]) return false;\n    if (value.includes(normalized)) return false;\n    return normalized;\n  }, [searchQuery, tagLookup, value]);\n\n  const flatOptions = useMemo(() => {\n    const result = [];\n    Object.entries(groupedTags).forEach(([_category, tags]) => {\n      tags.forEach((tagDef) => result.push({ type: 'existing', ...tagDef }));\n    });\n    if (canCreateTag) {\n      result.push({ type: 'create', tag: canCreateTag });\n    }\n    return result;\n  }, [groupedTags, canCreateTag]);\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (containerRef.current && !containerRef.current.contains(event.target)) {\n        setIsOpen(false);\n        setHoveredInvalidTag(null);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleKeyDown = (event) => {\n    if (!isOpen) {\n      if (event.key === 'Enter' || event.key === 'ArrowDown') {\n        event.preventDefault();\n        setIsOpen(true);\n      }\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.min(index + 1, flatOptions.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.max(index - 1, 0));\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (!flatOptions[highlightedIndex]) return;\n        if (flatOptions[highlightedIndex].type === 'create') {\n          handleCreateAndSelect(flatOptions[highlightedIndex].tag);\n        } else {\n          handleSelectTag(flatOptions[highlightedIndex].tag);\n        }\n        break;\n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        break;\n      case 'Backspace':\n        if (searchQuery === '' && value.length > 0) {\n          handleRemoveTag(value[value.length - 1]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleSelectTag = (tag) => {\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemoveTag = (tag) => {\n    onChange(value.filter((item) => item !== tag));\n  };\n\n  const handleCreateAndSelect = (tag) => {\n    if (onAddToRegistry) {\n      onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n    }\n\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleInvalidTagMouseEnter = (tag) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredInvalidTag(tag);\n  };\n\n  const handleInvalidTagMouseLeave = () => {\n    hoverTimeoutRef.current = setTimeout(() => {\n      setHoveredInvalidTag(null);\n    }, 150);\n  };\n\n  const handlePopupMouseEnter = () => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n  };\n\n  const renderRarityDots = (rarity) => {\n    const count = RARITY_DOTS[rarity] || RARITY_DOTS.common;\n    return (\n      <span className=\"tag-selector-rarity-dots\">\n        {Array.from({ length: count }).map((_, index) => (\n          <span key={index} className={`tag-selector-rarity-dot ${getRarityClass(rarity)}`} />\n        ))}\n      </span>\n    );\n  };\n\n  return (\n    <div ref={containerRef} className=\"tag-selector\">\n      <div\n        className={`tag-selector-input-wrapper ${isOpen ? 'tag-selector-input-wrapper-open' : 'tag-selector-input-wrapper-closed'}`}\n        onClick={() => {\n          setIsOpen(true);\n          inputRef.current?.focus();\n        }}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(event) => {\n          if (event.key === 'Enter' || event.key === ' ') {\n            event.currentTarget.click();\n          }\n        }}\n      >\n        {value.map((tag) => {\n          const tagMeta = tagLookup[tag];\n          const isInvalid = !tagMeta;\n          const categoryClass = isInvalid ? 'tag-selector-category-invalid' : getCategoryClass(tagMeta.category);\n\n          return (\n            <span\n              key={tag}\n              className={`tag-selector-chip ${categoryClass}`}\n              title={isInvalid ? 'Tag not in registry - hover to add' : tagMeta?.description}\n              onMouseEnter={() => isInvalid && onAddToRegistry && handleInvalidTagMouseEnter(tag)}\n              onMouseLeave={() => isInvalid && handleInvalidTagMouseLeave()}\n            >\n              {isInvalid && <span className=\"tag-selector-invalid-warning\">\u26a0</span>}\n              {tag}\n              {tagMeta?.isAxis && <span title=\"Semantic plane axis label\" className=\"tag-selector-axis-indicator\">\u2194</span>}\n              {tagMeta && renderRarityDots(tagMeta.rarity)}\n              <button\n                type=\"button\"\n                className=\"tag-selector-remove-button\"\n                onClick={(event) => {\n                  event.stopPropagation();\n                  handleRemoveTag(tag);\n                }}\n              >\n                \u00d7\n              </button>\n              {isInvalid && hoveredInvalidTag === tag && onAddToRegistry && (\n                <div\n                  className=\"tag-selector-invalid-popup\"\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n                    setHoveredInvalidTag(null);\n                  }}\n                  onMouseEnter={handlePopupMouseEnter}\n                  onMouseLeave={() => setHoveredInvalidTag(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(event) => {\n                    if (event.key === 'Enter' || event.key === ' ') {\n                      event.currentTarget.click();\n                    }\n                  }}\n                >\n                  + Add to registry\n                </div>\n              )}\n            </span>\n          );\n        })}\n\n        <input\n          ref={inputRef}\n          type=\"text\"\n          className=\"tag-selector-search-input\"\n          value={searchQuery}\n          onChange={(event) => {\n            setSearchQuery(event.target.value);\n            setHighlightedIndex(0);\n          }}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsOpen(true)}\n          placeholder={value.length === 0 ? placeholder : ''}\n        />\n      </div>\n\n      {matchAllEnabled && value.length > 1 && (\n        <div className=\"tag-selector-match-all\">\n          <label className=\"tag-selector-match-all-label\">\n            <input\n              type=\"checkbox\"\n              className=\"tag-selector-match-all-checkbox\"\n              checked={matchAll}\n              onChange={(event) => onMatchAllChange?.(event.target.checked)}\n            />\n            Match all tags (AND)\n          </label>\n          <span className=\"tag-selector-match-all-hint\">\n            {matchAll ? 'Entity must have all tags' : 'Entity must have any tag'}\n          </span>\n        </div>\n      )}\n\n      {isOpen && (\n        <div className=\"tag-selector-dropdown\">\n          {canCreateTag && onAddToRegistry && (\n            <div\n              className={`tag-selector-create-option ${highlightedIndex === flatOptions.length - 1 ? 'tag-selector-create-option-highlighted' : ''}`}\n              onClick={() => handleCreateAndSelect(canCreateTag)}\n              onMouseEnter={() => setHighlightedIndex(flatOptions.length - 1)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(event) => {\n                if (event.key === 'Enter' || event.key === ' ') {\n                  event.currentTarget.click();\n                }\n              }}\n            >\n// ... (truncated)", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}", "type": "{ value?: any[]; onChange: any; tagRegistry?: any[]; onAddToRegistry: any; placeholder?: string; matchAllEnabled?: boolean; matchAll?: boolean; onMatchAllChange: any; singleSelect?: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [{"name": "useState", "count": 4}, {"name": "useRef", "count": 3}, {"name": "useMemo", "count": 4}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::AddCard", "name": "AddCard", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {string} props.label - Button label (default \"Add Item\")\n * @param {string} props.className - Optional CSS class name\n */\nexport function AddCard({ onClick, label = 'Add Item', className = '' }) {\n  return (\n    <div\n      className={`add-card ${className}`.trim()}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <span className=\"add-card-icon\">+</span>\n      <span>{label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "span", "input", "button", "option"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/shared/index.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/sidebar/index.js::CultureSidebar", "name": "CultureSidebar", "kind": "component", "filePath": "apps/name-forge/webui/src/components/sidebar/index.js", "sourceCode": "function CultureSidebar({\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}) {\n  const [creatingCulture, setCreatingCulture] = useState(false);\n  const [newCultureId, setNewCultureId] = useState(\"\");\n  const [newCultureName, setNewCultureName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const handleCreateCulture = () => {\n    if (!newCultureId.trim()) {\n      setError(\"Culture ID is required\");\n      return;\n    }\n    if (!/^[a-z0-9_]+$/.test(newCultureId)) {\n      setError(\"Culture ID must be lowercase letters, numbers, and underscores only (no hyphens)\");\n      return;\n    }\n    if (cultures[newCultureId]) {\n      setError(\"Culture ID already exists\");\n      return;\n    }\n    const cultureName = newCultureName || newCultureId;\n\n    // Create new culture with culture-level resources\n    const newCulture = {\n      id: newCultureId,\n      name: cultureName,\n      naming: {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: []\n      }\n    };\n    const updatedCultures = {\n      ...cultures,\n      [newCultureId]: newCulture\n    };\n    onCulturesChange(updatedCultures);\n\n    // Select the new culture\n    onSelectCulture(newCultureId);\n\n    // Reset form\n    setNewCultureId(\"\");\n    setNewCultureName(\"\");\n    setCreatingCulture(false);\n    setError(null);\n  };\n\n  // Get resource counts for a culture\n  const getResourceCounts = culture => {\n    const naming = culture?.naming || {};\n    return {\n      domains: naming.domains?.length || 0,\n      lexemes: Object.keys(naming.lexemeLists || {}).length,\n      grammars: naming.grammars?.length || 0,\n      profiles: naming.profiles?.length || 0\n    };\n  };\n\n  // Calculate completion based on having at least one of each resource\n  const calculateCompletion = culture => {\n    const counts = getResourceCounts(culture);\n    let completed = 0;\n    if (counts.domains > 0) completed++;\n    if (counts.lexemes > 0) completed++;\n    if (counts.grammars > 0) completed++;\n    if (counts.profiles > 0) completed++;\n    return Math.round(completed / 4 * 100);\n  };\n  return <div className=\"culture-sidebar\">\n      <div className=\"culture-sidebar-header\">\n        <div className=\"culture-sidebar-header-row\">\n          <h4>Cultures</h4>\n          {!readOnly && !creatingCulture && <button className=\"primary sm\" onClick={() => setCreatingCulture(true)}>\n              + New\n            </button>}\n        </div>\n\n        {creatingCulture && <div className=\"culture-form\">\n            <div className=\"form-group\">\n              <label htmlFor=\"culture-id\">Culture ID</label>\n              <input id=\"culture-id\" type=\"text\" value={newCultureId} onChange={e => setNewCultureId(e.target.value)} placeholder=\"elven\" />\n            </div>\n            <div className=\"form-group\">\n              <label htmlFor=\"display-name\">Display Name</label>\n              <input id=\"display-name\" type=\"text\" value={newCultureName} onChange={e => setNewCultureName(e.target.value)} placeholder=\"Elven\" />\n            </div>\n\n            {error && <div className=\"error\">{error}</div>}\n\n            <div className=\"culture-form-buttons\">\n              <button className=\"primary\" onClick={handleCreateCulture}>\n                Create\n              </button>\n              <button className=\"secondary\" onClick={() => {\n            setCreatingCulture(false);\n            setError(null);\n            setNewCultureId(\"\");\n            setNewCultureName(\"\");\n          }}>\n                Cancel\n              </button>\n            </div>\n          </div>}\n      </div>\n\n      <div className=\"culture-list\">\n        {Object.keys(cultures).length === 0 ? <div className=\"culture-list-empty\">No cultures yet. Create one to get started.</div> : Object.values(cultures).map(culture => {\n        const completion = calculateCompletion(culture);\n        const counts = getResourceCounts(culture);\n        const isSelected = selectedCulture === culture.id;\n        return <div key={culture.id} onClick={() => onSelectCulture(culture.id)} className={`culture-card ${isSelected ? \"selected\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n                <div className=\"culture-card-content\">\n                  <div className=\"culture-card-name\">{culture.name || culture.id}</div>\n\n                  {/* Resource counts */}\n                  <div className=\"culture-resource-grid\">\n                    <span className={`culture-resource-item ${counts.domains > 0 ? \"has-domains\" : \"\"}`}>\n                      {counts.domains} dom\n                    </span>\n                    <span className={`culture-resource-item ${counts.lexemes > 0 ? \"has-lexemes\" : \"\"}`}>\n                      {counts.lexemes} lex\n                    </span>\n                    <span className={`culture-resource-item ${counts.grammars > 0 ? \"has-grammars\" : \"\"}`}>\n                      {counts.grammars} gram\n                    </span>\n                    <span className={`culture-resource-item ${counts.profiles > 0 ? \"has-profiles\" : \"\"}`}>\n                      {counts.profiles} prof\n                    </span>\n                  </div>\n\n                  {/* Progress bar */}\n                  <div className=\"culture-progress-bar\">\n                    <div className={`culture-progress-fill csb-progress-fill ${completion === 100 ? \"complete\" : \"\"}`} style={{\n                '--csb-progress-width': `${completion}%`\n              }} />\n                  </div>\n                </div>\n              </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}", "type": "{ cultures: any; selectedCulture: any; onSelectCulture: any; onCulturesChange: any; readOnly?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h4", "button", "label", "input", "div"], "hookCalls": [{"name": "useState", "count": 4}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::EntityWorkspace", "name": "EntityWorkspace", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function EntityWorkspace({\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}) {\n  const [error, setError] = useState(null);\n\n  // Use prop or fallback to local handling\n  const setActiveTab = onTabChange || (() => {});\n\n  if (!cultureId) {\n    return (\n      <div className=\"workspace-empty\">\n        <p className=\"text-muted\">Select a culture from the sidebar to begin</p>\n      </div>\n    );\n  }\n\n  // Handle domains change at culture level\n  const handleDomainsChange = (newDomains) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          domains: newDomains,\n        },\n      });\n    }\n  };\n\n  // Handle lexemes change at culture level\n  // Optional third param allows atomic update with grammars (for copy operations)\n  const handleLexemesChange = (newLexemeLists, newLexemeSpecs, newGrammars) => {\n    if (onCultureChange) {\n      const updates = {\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n        },\n      };\n      if (newLexemeLists !== undefined) updates.naming.lexemeLists = newLexemeLists;\n      if (newLexemeSpecs !== undefined) updates.naming.lexemeSpecs = newLexemeSpecs;\n      if (newGrammars !== undefined) updates.naming.grammars = newGrammars;\n      onCultureChange(updates);\n    }\n  };\n\n  // Handle grammars change at culture level\n  const handleGrammarsChange = (newGrammars) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          grammars: newGrammars,\n        },\n      });\n    }\n  };\n\n  // Handle profiles change at culture level\n  const handleProfilesChange = (newProfiles) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          profiles: newProfiles,\n        },\n      });\n    }\n  };\n\n  const getCompletionBadge = (key) => {\n    const naming = cultureConfig?.naming || {};\n    // Compute counts from culture-level data\n    if (key === \"domain\") {\n      const count = naming.domains?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"lexemes\") {\n      const count = Object.keys(naming.lexemeLists || {}).length;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"grammars\") {\n      const count = naming.grammars?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"profiles\") {\n      const count = naming.profiles?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className=\"workspace\">\n      {/* Header */}\n      <div className=\"workspace-header\">\n        <div className=\"workspace-header-row\">\n          <div>\n            <h3 className=\"workspace-title\">\n              <span className=\"workspace-title-name\">{cultureConfig?.name || cultureId}</span>\n              <span className=\"workspace-title-label\">Culture</span>\n            </h3>\n          </div>\n          <div className=\"workspace-autosave\">Auto-saved</div>\n        </div>\n\n        {error && (\n          <div className=\"error mt-sm\">\n            {error}\n            <button className=\"secondary ml-sm\" onClick={() => setError(null)}>\n              Dismiss\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"workspace-tabs\">\n        {[\"domain\", \"lexemes\", \"grammars\", \"profiles\"].map((tab) => (\n          <button\n            key={tab}\n            onClick={() => setActiveTab(tab)}\n            className={`workspace-tab ${activeTab === tab ? \"active\" : \"\"}`}\n          >\n            {tab} {getCompletionBadge(tab)}\n          </button>\n        ))}\n      </div>\n\n      {/* Content */}\n      <div className=\"workspace-content\">\n        {activeTab === \"domain\" && (\n          <DomainTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onDomainsChange={handleDomainsChange}\n          />\n        )}\n\n        {activeTab === \"lexemes\" && (\n          <LexemesTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onLexemesChange={handleLexemesChange}\n            apiKey={apiKey}\n          />\n        )}\n\n        {activeTab === \"grammars\" && (\n          <GrammarsTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onGrammarsChange={handleGrammarsChange}\n            onLexemesChange={handleLexemesChange}\n          />\n        )}\n\n        {activeTab === \"profiles\" && (\n          <ProfileTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            onProfilesChange={handleProfilesChange}\n            worldSchema={worldSchema}\n            onAddTag={onAddTag}\n            generators={generators}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}", "type": "{ worldSchema: any; cultureId: any; cultureConfig: any; allCultures: any; activeTab?: string; onTabChange: any; onCultureChange: any; onAddTag: any; apiKey: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["p"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::DomainTab", "name": "DomainTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "strong", "code", "div"], "hookCalls": [{"name": "useState", "count": 4}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::LexemesTab", "name": "LexemesTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "span", "div", "h4", "strong", "p", "CopyLexemeModal"], "hookCalls": [{"name": "useState", "count": 9}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::GrammarsTab", "name": "GrammarsTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "code", "p", "strong", "GrammarPreview", "GrammarHelpModal", "CopyGrammarModal"], "hookCalls": [{"name": "useState", "count": 8}, {"name": "useRef", "count": 3}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/webui/src/components/workspace/index.js::ProfileTab", "name": "ProfileTab", "kind": "component", "filePath": "apps/name-forge/webui/src/components/workspace/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "button", "p", "strong", "span", "ProfileModal"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/actions/cards/ActionListCard.jsx::ActionListCard", "name": "ActionListCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/actions/cards/ActionListCard.jsx", "sourceCode": "export function ActionListCard({ action, onClick, onToggle, usageMap }) {\n  const isEnabled = action.enabled !== false;\n  const pressureMods = action.probability?.pressureModifiers || [];\n\n  // Get validation info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"action\", action.id)\n        : { invalidRefs: [], compatibility: [], isOrphan: false },\n    [usageMap, action.id]\n  );\n\n  const hasErrors = validation.invalidRefs.length > 0;\n  const hasCompatibilityIssues = validation.compatibility?.length > 0;\n\n  const formatActorKinds = () => {\n    const selection = action.actor?.selection;\n    if (!selection) return \"any\";\n    if (selection.kind) return selection.kind;\n    if (selection.kinds?.length) return selection.kinds.join(\", \");\n    return selection.strategy || \"any\";\n  };\n\n  const formatTargetKind = () => {\n    const targeting = action.targeting;\n    if (!targeting) return \"none\";\n    if (targeting.kind) return targeting.kind;\n    if (targeting.kinds?.length) return targeting.kinds.join(\", \");\n    return targeting.strategy || \"none\";\n  };\n\n  const cardClasses = [\n    \"card card-clickable\",\n    !isEnabled && \"card-disabled\",\n    hasErrors && \"card-error\",\n    hasCompatibilityIssues && !hasErrors && \"card-warning\",\n  ]\n    .filter(Boolean)\n    .join(\" \");\n\n  return (\n    <div className={cardClasses} onClick={onClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }} >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{action.name || action.id}</span>\n            {hasErrors && (\n              <span className=\"badge badge-validation badge-error\">\n                {validation.invalidRefs.length} error\n                {validation.invalidRefs.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n            {hasCompatibilityIssues && !hasErrors && (\n              <span className=\"badge badge-validation badge-compatibility\">\n                {validation.compatibility.length} warning\n                {validation.compatibility.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n          </div>\n          <div className=\"card-id\">{action.id}</div>\n        </div>\n        <div\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n          className={isEnabled ? \"toggle toggle-on\" : \"toggle\"}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <div className=\"toggle-knob\" />\n        </div>\n      </div>\n\n      <div className=\"card-badges\">\n        <span className=\"badge badge-actor\">{formatActorKinds()}</span>\n        <span className=\"badge badge-target\">\u2192 {formatTargetKind()}</span>\n        {pressureMods.length > 0 && (\n          <span className=\"badge badge-pressure\">\n            {pressureMods.length} pressure{pressureMods.length !== 1 ? \"s\" : \"\"}\n          </span>\n        )}\n      </div>\n\n      {action.description && <div className=\"card-desc\">{action.description}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onClick, onToggle, usageMap }", "type": "{ action: any; onClick: any; onToggle: any; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../../shared", "specifiers": ["getElementValidation"], "category": "internal"}]}, {"id": "apps/coherence-engine/webui/src/components/actions/cards/index.js::ActionListCard", "name": "ActionListCard", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/actions/cards/index.js", "sourceCode": "export function ActionListCard({ action, onClick, onToggle, usageMap }) {\n  const isEnabled = action.enabled !== false;\n  const pressureMods = action.probability?.pressureModifiers || [];\n\n  // Get validation info\n  const validation = useMemo(\n    () =>\n      usageMap\n        ? getElementValidation(usageMap, \"action\", action.id)\n        : { invalidRefs: [], compatibility: [], isOrphan: false },\n    [usageMap, action.id]\n  );\n\n  const hasErrors = validation.invalidRefs.length > 0;\n  const hasCompatibilityIssues = validation.compatibility?.length > 0;\n\n  const formatActorKinds = () => {\n    const selection = action.actor?.selection;\n    if (!selection) return \"any\";\n    if (selection.kind) return selection.kind;\n    if (selection.kinds?.length) return selection.kinds.join(\", \");\n    return selection.strategy || \"any\";\n  };\n\n  const formatTargetKind = () => {\n    const targeting = action.targeting;\n    if (!targeting) return \"none\";\n    if (targeting.kind) return targeting.kind;\n    if (targeting.kinds?.length) return targeting.kinds.join(\", \");\n    return targeting.strategy || \"none\";\n  };\n\n  const cardClasses = [\n    \"card card-clickable\",\n    !isEnabled && \"card-disabled\",\n    hasErrors && \"card-error\",\n    hasCompatibilityIssues && !hasErrors && \"card-warning\",\n  ]\n    .filter(Boolean)\n    .join(\" \");\n\n  return (\n    <div className={cardClasses} onClick={onClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }} >\n      <div className=\"card-header\">\n        <div>\n          <div className=\"flex items-center gap-md\">\n            <span className=\"card-title\">{action.name || action.id}</span>\n            {hasErrors && (\n              <span className=\"badge badge-validation badge-error\">\n                {validation.invalidRefs.length} error\n                {validation.invalidRefs.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n            {hasCompatibilityIssues && !hasErrors && (\n              <span className=\"badge badge-validation badge-compatibility\">\n                {validation.compatibility.length} warning\n                {validation.compatibility.length !== 1 ? \"s\" : \"\"}\n              </span>\n            )}\n          </div>\n          <div className=\"card-id\">{action.id}</div>\n        </div>\n        <div\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggle();\n          }}\n          className={isEnabled ? \"toggle toggle-on\" : \"toggle\"}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <div className=\"toggle-knob\" />\n        </div>\n      </div>\n\n      <div className=\"card-badges\">\n        <span className=\"badge badge-actor\">{formatActorKinds()}</span>\n        <span className=\"badge badge-target\">\u2192 {formatTargetKind()}</span>\n        {pressureMods.length > 0 && (\n          <span className=\"badge badge-pressure\">\n            {pressureMods.length} pressure{pressureMods.length !== 1 ? \"s\" : \"\"}\n          </span>\n        )}\n      </div>\n\n      {action.description && <div className=\"card-desc\">{action.description}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{ action, onClick, onToggle, usageMap }", "type": "{ action: any; onClick: any; onToggle: any; usageMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/components/actions/modals/ActionModal.jsx::ActionModal", "name": "ActionModal", "kind": "component", "filePath": "apps/coherence-engine/webui/src/components/actions/modals/ActionModal.jsx", "sourceCode": "export function ActionModal({ action, onChange, onClose, onDelete, schema, pressures }) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"overview\":\n        return <OverviewTab action={action} onChange={onChange} onDelete={onDelete} />;\n      case \"actor\":\n        return (\n          <ActorTab action={action} onChange={onChange} schema={schema} pressures={pressures} />\n        );\n      case \"instigator\":\n        return <InstigatorTab action={action} onChange={onChange} schema={schema} />;\n      case \"targeting\":\n        return <TargetingTab action={action} onChange={onChange} schema={schema} />;\n      case \"variables\":\n        return <VariablesTab action={action} onChange={onChange} schema={schema} />;\n      case \"outcome\":\n        return (\n          <OutcomeTab action={action} onChange={onChange} schema={schema} pressures={pressures} />\n        );\n      case \"probability\":\n        return <ProbabilityTab action={action} onChange={onChange} pressures={pressures} />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <ModalShell\n      onClose={onClose}\n      icon=\"\ud83c\udfad\"\n      title={action.name || action.id}\n      disabled={action.enabled === false}\n      tabs={TABS}\n      activeTab={activeTab}\n      onTabChange={setActiveTab}\n      tabClassName=\"ae-tab-btn\"\n    >\n      {renderTabContent()}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ action, onChange, onClose, onDelete, schema, pressures }", "type": "{ action: any; onChange: any; onClose: any; onDelete: any; schema: any; pressures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["OverviewTab"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../constants", "specifiers": ["TABS"], "category": "internal"}, {"source": "../../shared", "specifiers": ["ModalShell"], "category": "internal"}, {"source": "../tabs", "specifiers": ["OverviewTab", "ActorTab", "InstigatorTab", "TargetingTab", "VariablesTab", "OutcomeTab", "ProbabilityTab"], "category": "internal"}]}]