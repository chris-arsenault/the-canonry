[{"id": "apps/cosmographer/lib/index.ts::generateManifold", "name": "generateManifold", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate a complete manifold configuration from input.\n *\n * This is the main entry point for the library.\n *\n * @param input - Domain specification with planes and hints\n * @returns Complete manifold configuration for lore-weave\n */\nexport function generateManifold(\n  input: CosmographerInput\n): CosmographerOutput {\n  const options = input.options ?? {};\n\n  // Register any custom categories\n  if (input.customCategories) {\n    for (const custom of input.customCategories) {\n      registerCustomCategory({\n        ...custom,\n        domainClass: input.spaceType === 'hybrid' ? 'conceptual' : input.spaceType\n      });\n    }\n  }\n\n  // Classify all planes\n  const classifications = classifyPlanes(input.planes, {\n    domainClass: input.spaceType,\n    keywordWeight: options.weights?.semantic ?? 0.5,\n    embeddingWeight: options.weights?.embedding ?? 0.3,\n    fuzzyWeight: 1 - (options.weights?.semantic ?? 0.5) - (options.weights?.embedding ?? 0.3)\n  });\n\n  // Generate hierarchy\n  const planeHierarchy = generateHierarchy(input, classifications);\n\n  // Generate distances\n  const crossPlaneDistances = generateDistances(input, classifications);\n\n  // Generate axis weights\n  const defaultAxisWeights = generateAxisWeights(input);\n\n  // Build classification metadata if requested\n  let classificationMetadata: Record<string, PlaneClassification> | undefined;\n\n  if (options.includeMetadata !== false) {\n    classificationMetadata = {};\n\n    for (const [planeId, result] of classifications) {\n      const matchedPatterns = getMatchedKeywords(\n        input.planes.find(p => p.id === planeId)!,\n        result.bestMatch\n      );\n\n      classificationMetadata[planeId] = {\n        category: result.bestMatch,\n        confidence: result.confidence,\n        matchedPatterns,\n        candidates: Array.from(result.scores.entries())\n          .sort((a, b) => b[1] - a[1])\n          .slice(0, 5)\n          .map(([category, score]) => ({ category, score }))\n      };\n    }\n  }\n\n  return {\n    domainId: input.domainId,\n    generatedAt: new Date().toISOString(),\n    generator: `cosmographer@${VERSION}`,\n    planeHierarchy,\n    defaultAxisWeights,\n    crossPlaneDistances,\n    saturationStrategy: options.saturationStrategy ?? 'density',\n    densityThreshold: options.densityThreshold ?? 0.7,\n    classifications: classificationMetadata\n  };\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "CosmographerOutput"}, {"id": "apps/cosmographer/lib/index.ts::analyzeTerm", "name": "analyzeTerm", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Analyze a single term and return its likely categories.\n *\n * Useful for exploring the ontology interactively.\n *\n * @param term - Term to analyze (e.g., \"underwater cavern\")\n * @param domainClass - Domain class to search within\n * @returns Array of category matches with confidence scores\n */\nexport function analyzeTerm(\n  term: string,\n  domainClass: import('./types/index.js').DomainClass = 'hybrid'\n): Array<{ category: string; confidence: number }> {\n  const fakeSpec = {\n    id: term.toLowerCase().replace(/\\s+/g, '_'),\n    label: term,\n    description: term\n  };\n\n  const result = classifyPlanes([fakeSpec], { domainClass });\n  const classification = result.get(fakeSpec.id);\n\n  if (!classification) {\n    return [];\n  }\n\n  return Array.from(classification.scores.entries())\n    .sort((a, b) => b[1] - a[1])\n    .map(([category, score]) => ({\n      category,\n      confidence: score\n    }));\n}", "parameters": [{"name": "term", "type": "string", "optional": false}, {"name": "domainClass", "type": "import('./types/index.js').DomainClass", "optional": true}], "returnType": "Array<{ category: string; confidence: number }>"}, {"id": "apps/cosmographer/lib/index.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined"}, {"id": "apps/cosmographer/lib/index.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]"}, {"id": "apps/cosmographer/lib/index.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]"}, {"id": "apps/cosmographer/lib/index.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void"}, {"id": "apps/cosmographer/lib/index.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult"}, {"id": "apps/cosmographer/lib/index.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>"}, {"id": "apps/cosmographer/lib/index.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]"}, {"id": "apps/cosmographer/lib/index.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]"}, {"id": "apps/cosmographer/lib/index.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>"}, {"id": "apps/cosmographer/lib/index.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}"}, {"id": "apps/cosmographer/lib/index.ts::hasEmbeddings", "name": "hasEmbeddings", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Check if embeddings are available.\n */\nexport function hasEmbeddings(): boolean {\n  loadEmbeddings();\n  return embeddings !== null;\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/cosmographer/lib/index.ts::getEmbedding", "name": "getEmbedding", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get the embedding vector for a word.\n */\nexport function getEmbedding(word: string): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const normalized = word.toLowerCase().replace(/[^a-z]/g, '');\n  return embeddings.words[normalized] ?? null;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number[] | null"}, {"id": "apps/cosmographer/lib/index.ts::getEmbeddingSimilarity", "name": "getEmbeddingSimilarity", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get similarity between two words (0-1).\n */\nexport function getEmbeddingSimilarity(word1: string, word2: string): number | null {\n  const v1 = getEmbedding(word1);\n  const v2 = getEmbedding(word2);\n\n  if (!v1 || !v2) return null;\n\n  // Cosine similarity returns -1 to 1, normalize to 0-1\n  const sim = cosineSimilarity(v1, v2);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word1", "type": "string", "optional": false}, {"name": "word2", "type": "string", "optional": false}], "returnType": "number | null"}, {"id": "apps/cosmographer/lib/index.ts::findMostSimilar", "name": "findMostSimilar", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Find the most similar word in vocabulary.\n */\nexport function findMostSimilar(word: string, topK: number = 5): Array<{ word: string; similarity: number }> {\n  loadEmbeddings();\n  if (!embeddings) return [];\n\n  const targetVec = getEmbedding(word);\n  if (!targetVec) return [];\n\n  const similarities: Array<{ word: string; similarity: number }> = [];\n\n  for (const [w, vec] of Object.entries(embeddings.words)) {\n    if (w === word.toLowerCase()) continue;\n\n    const sim = cosineSimilarity(targetVec, vec);\n    similarities.push({ word: w, similarity: (sim + 1) / 2 });\n  }\n\n  return [...similarities]\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, topK);\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "topK", "type": "number", "optional": true}], "returnType": "Array<{ word: string; similarity: number }>"}, {"id": "apps/cosmographer/lib/index.ts::getVocabularyStats", "name": "getVocabularyStats", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get vocabulary statistics.\n */\nexport function getVocabularyStats(): {\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n} {\n  loadEmbeddings();\n  return {\n    loaded: embeddings !== null,\n    wordCount: embeddings ? Object.keys(embeddings.words).length : 0,\n    dimensions: embeddings?.dimensions ?? 0\n  };\n}", "parameters": [], "returnType": "{\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n}"}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult"}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>"}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]"}, {"id": "apps/cosmographer/lib/analysis/index.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult"}, {"id": "apps/cosmographer/lib/analysis/index.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>"}, {"id": "apps/cosmographer/lib/analysis/index.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::hasEmbeddings", "name": "hasEmbeddings", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Check if embeddings are available.\n */\nexport function hasEmbeddings(): boolean {\n  loadEmbeddings();\n  return embeddings !== null;\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getEmbedding", "name": "getEmbedding", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get the embedding vector for a word.\n */\nexport function getEmbedding(word: string): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const normalized = word.toLowerCase().replace(/[^a-z]/g, '');\n  return embeddings.words[normalized] ?? null;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number[] | null"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getEmbeddingSimilarity", "name": "getEmbeddingSimilarity", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get similarity between two words (0-1).\n */\nexport function getEmbeddingSimilarity(word1: string, word2: string): number | null {\n  const v1 = getEmbedding(word1);\n  const v2 = getEmbedding(word2);\n\n  if (!v1 || !v2) return null;\n\n  // Cosine similarity returns -1 to 1, normalize to 0-1\n  const sim = cosineSimilarity(v1, v2);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word1", "type": "string", "optional": false}, {"name": "word2", "type": "string", "optional": false}], "returnType": "number | null"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::findMostSimilar", "name": "findMostSimilar", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Find the most similar word in vocabulary.\n */\nexport function findMostSimilar(word: string, topK: number = 5): Array<{ word: string; similarity: number }> {\n  loadEmbeddings();\n  if (!embeddings) return [];\n\n  const targetVec = getEmbedding(word);\n  if (!targetVec) return [];\n\n  const similarities: Array<{ word: string; similarity: number }> = [];\n\n  for (const [w, vec] of Object.entries(embeddings.words)) {\n    if (w === word.toLowerCase()) continue;\n\n    const sim = cosineSimilarity(targetVec, vec);\n    similarities.push({ word: w, similarity: (sim + 1) / 2 });\n  }\n\n  return [...similarities]\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, topK);\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "topK", "type": "number", "optional": true}], "returnType": "Array<{ word: string; similarity: number }>"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Calculate centroid of multiple words.\n */\nexport function calculateCentroid(words: string[]): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const vectors: number[][] = [];\n  for (const word of words) {\n    const vec = getEmbedding(word);\n    if (vec) vectors.push(vec);\n  }\n\n  if (vectors.length === 0) return null;\n\n  const dimensions = embeddings.dimensions;\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\n\n  for (const vec of vectors) {\n    for (let i = 0; i < dimensions; i++) {\n      centroid[i] += vec[i];\n    }\n  }\n\n  for (let i = 0; i < dimensions; i++) {\n    centroid[i] /= vectors.length;\n  }\n\n  return centroid;\n}", "parameters": [{"name": "words", "type": "string[]", "optional": false}], "returnType": "number[] | null"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::similarityToCentroid", "name": "similarityToCentroid", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get similarity between a word and a centroid.\n */\nexport function similarityToCentroid(word: string, centroid: number[]): number | null {\n  const vec = getEmbedding(word);\n  if (!vec) return null;\n\n  const sim = cosineSimilarity(vec, centroid);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "centroid", "type": "number[]", "optional": false}], "returnType": "number | null"}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getVocabularyStats", "name": "getVocabularyStats", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get vocabulary statistics.\n */\nexport function getVocabularyStats(): {\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n} {\n  loadEmbeddings();\n  return {\n    loaded: embeddings !== null,\n    wordCount: embeddings ? Object.keys(embeddings.words).length : 0,\n    dimensions: embeddings?.dimensions ?? 0\n  };\n}", "parameters": [], "returnType": "{\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n}"}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]"}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>"}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}"}, {"id": "apps/cosmographer/lib/generator/index.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]"}, {"id": "apps/cosmographer/lib/generator/index.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>"}, {"id": "apps/cosmographer/lib/generator/index.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::canBeChildOf", "name": "canBeChildOf", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Check if a category can be a child of another.\n */\nexport function canBeChildOf(childId: CategoryId, parentId: CategoryId): boolean {\n  const parent = CATEGORY_REGISTRY.get(parentId);\n  const child = CATEGORY_REGISTRY.get(childId);\n\n  if (!parent || !child) return false;\n\n  // Check if child is in parent's typical children\n  if (parent.typicalChildren.includes(childId)) return true;\n\n  // Check if parent is in child's typical parents\n  if (child.typicalParents.includes(parentId)) return true;\n\n  // Check incompatibility\n  if (parent.incompatibleWith.includes(childId)) return false;\n  if (child.incompatibleWith.includes(parentId)) return false;\n\n  // Default: allow if same domain class or parent is broader\n  return parent.domainClass === child.domainClass;\n}", "parameters": [{"name": "childId", "type": "CategoryId", "optional": false}, {"name": "parentId", "type": "CategoryId", "optional": false}], "returnType": "boolean"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getValidChildren", "name": "getValidChildren", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get valid children for a category.\n */\nexport function getValidChildren(categoryId: CategoryId): CategoryId[] {\n  const category = CATEGORY_REGISTRY.get(categoryId);\n  if (!category) return [];\n\n  const validChildren: CategoryId[] = [];\n\n  for (const [id] of CATEGORY_REGISTRY) {\n    if (id === categoryId) continue;\n    if (canBeChildOf(id, categoryId)) {\n      validChildren.push(id);\n    }\n  }\n\n  return validChildren;\n}", "parameters": [{"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "CategoryId[]"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::categoryDistance", "name": "categoryDistance", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Calculate semantic distance between two categories.\n * Lower = more similar.\n */\nexport function categoryDistance(cat1Id: CategoryId, cat2Id: CategoryId): number {\n  if (cat1Id === cat2Id) return 0;\n\n  const cat1 = CATEGORY_REGISTRY.get(cat1Id);\n  const cat2 = CATEGORY_REGISTRY.get(cat2Id);\n\n  if (!cat1 || !cat2) return Infinity;\n\n  let distance = 1.0;\n\n  // Same domain class = closer\n  if (cat1.domainClass !== cat2.domainClass) {\n    distance += 2.0;\n  }\n\n  // Typical parent-child relationship = closer\n  if (cat1.typicalChildren.includes(cat2Id) || cat2.typicalChildren.includes(cat1Id)) {\n    distance -= 0.5;\n  }\n\n  // Incompatible = farther\n  if (cat1.incompatibleWith.includes(cat2Id)) {\n    distance += 3.0;\n  }\n\n  // Priority difference affects distance\n  distance += Math.abs(cat1.basePriority - cat2.basePriority) * 0.2;\n\n  return Math.max(0, distance);\n}", "parameters": [{"name": "cat1Id", "type": "CategoryId", "optional": false}, {"name": "cat2Id", "type": "CategoryId", "optional": false}], "returnType": "number"}, {"id": "apps/cosmographer/lib/ontology/categories.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void"}, {"id": "apps/cosmographer/lib/ontology/index.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined"}, {"id": "apps/cosmographer/lib/ontology/index.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]"}, {"id": "apps/cosmographer/lib/ontology/index.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]"}, {"id": "apps/cosmographer/lib/ontology/index.ts::canBeChildOf", "name": "canBeChildOf", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Check if a category can be a child of another.\n */\nexport function canBeChildOf(childId: CategoryId, parentId: CategoryId): boolean {\n  const parent = CATEGORY_REGISTRY.get(parentId);\n  const child = CATEGORY_REGISTRY.get(childId);\n\n  if (!parent || !child) return false;\n\n  // Check if child is in parent's typical children\n  if (parent.typicalChildren.includes(childId)) return true;\n\n  // Check if parent is in child's typical parents\n  if (child.typicalParents.includes(parentId)) return true;\n\n  // Check incompatibility\n  if (parent.incompatibleWith.includes(childId)) return false;\n  if (child.incompatibleWith.includes(parentId)) return false;\n\n  // Default: allow if same domain class or parent is broader\n  return parent.domainClass === child.domainClass;\n}", "parameters": [{"name": "childId", "type": "CategoryId", "optional": false}, {"name": "parentId", "type": "CategoryId", "optional": false}], "returnType": "boolean"}, {"id": "apps/cosmographer/lib/ontology/index.ts::getValidChildren", "name": "getValidChildren", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get valid children for a category.\n */\nexport function getValidChildren(categoryId: CategoryId): CategoryId[] {\n  const category = CATEGORY_REGISTRY.get(categoryId);\n  if (!category) return [];\n\n  const validChildren: CategoryId[] = [];\n\n  for (const [id] of CATEGORY_REGISTRY) {\n    if (id === categoryId) continue;\n    if (canBeChildOf(id, categoryId)) {\n      validChildren.push(id);\n    }\n  }\n\n  return validChildren;\n}", "parameters": [{"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "CategoryId[]"}, {"id": "apps/cosmographer/lib/ontology/index.ts::categoryDistance", "name": "categoryDistance", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Calculate semantic distance between two categories.\n * Lower = more similar.\n */\nexport function categoryDistance(cat1Id: CategoryId, cat2Id: CategoryId): number {\n  if (cat1Id === cat2Id) return 0;\n\n  const cat1 = CATEGORY_REGISTRY.get(cat1Id);\n  const cat2 = CATEGORY_REGISTRY.get(cat2Id);\n\n  if (!cat1 || !cat2) return Infinity;\n\n  let distance = 1.0;\n\n  // Same domain class = closer\n  if (cat1.domainClass !== cat2.domainClass) {\n    distance += 2.0;\n  }\n\n  // Typical parent-child relationship = closer\n  if (cat1.typicalChildren.includes(cat2Id) || cat2.typicalChildren.includes(cat1Id)) {\n    distance -= 0.5;\n  }\n\n  // Incompatible = farther\n  if (cat1.incompatibleWith.includes(cat2Id)) {\n    distance += 3.0;\n  }\n\n  // Priority difference affects distance\n  distance += Math.abs(cat1.basePriority - cat2.basePriority) * 0.2;\n\n  return Math.max(0, distance);\n}", "parameters": [{"name": "cat1Id", "type": "CategoryId", "optional": false}, {"name": "cat2Id", "type": "CategoryId", "optional": false}], "returnType": "number"}, {"id": "apps/cosmographer/lib/ontology/index.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void"}, {"id": "apps/cosmographer/webui/src/CosmographerRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/CosmographerRemote.jsx", "sourceCode": "export default function CosmographerRemote({\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage,\n}) {\n  // Use passed-in section or default to 'axes'\n  const activeTab = activeSection || \"axes\";\n  const setActiveTab = onSectionChange || (() => {});\n\n  // Build internal project representation\n  const project = useMemo(\n    () => ({\n      entityKinds: schema?.entityKinds || [],\n      relationshipKinds: schema?.relationshipKinds || [],\n      cultures: schema?.cultures || [],\n      axisDefinitions: axisDefinitions || [],\n      seedEntities: seedEntities || [],\n      seedRelationships: seedRelationships || [],\n      tagRegistry: schema?.tagRegistry || [],\n    }),\n    [schema, axisDefinitions, seedEntities, seedRelationships]\n  );\n\n  // Handle save - route updates to appropriate callbacks\n  const handleSave = useCallback(\n    (updates) => {\n      if (updates.entityKinds && onEntityKindsChange) {\n        onEntityKindsChange(updates.entityKinds);\n      }\n\n      // Handle seed entity changes\n      if (updates.seedEntities && onSeedEntitiesChange) {\n        onSeedEntitiesChange(updates.seedEntities);\n      }\n\n      // Handle seed relationship changes\n      if (updates.seedRelationships && onSeedRelationshipsChange) {\n        onSeedRelationshipsChange(updates.seedRelationships);\n      }\n\n      if (updates.cultures && onCulturesChange) {\n        onCulturesChange(updates.cultures);\n      }\n    },\n    [onEntityKindsChange, onCulturesChange, onSeedEntitiesChange, onSeedRelationshipsChange]\n  );\n\n  const hasSchema = schema?.entityKinds?.length > 0 || schema?.cultures?.length > 0;\n\n  if (!hasSchema) {\n    return (\n      <div className=\"cosmo-container\">\n        <div className=\"cosmo-no-schema\">\n          <div className=\"cosmo-no-schema-title\">No Schema Defined</div>\n          <div>\n            Define entity kinds and cultures in the <strong>Enumerist</strong> tab first, then\n            return here to place entities and manage relationships.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const renderContent = () => {\n    switch (activeTab) {\n      case \"axes\":\n        return (\n          <AxisRegistryEditor\n            axisDefinitions={project.axisDefinitions}\n            entityKinds={project.entityKinds}\n            tagRegistry={project.tagRegistry}\n            onAxisDefinitionsChange={onAxisDefinitionsChange}\n            onTagRegistryChange={onTagRegistryChange}\n          />\n        );\n      case \"planes\":\n        return (\n          <SemanticPlaneEditor\n            project={project}\n            onSave={handleSave}\n            axisDefinitions={project.axisDefinitions}\n          />\n        );\n      case \"cultures\":\n        return <CultureEditor project={project} onSave={handleSave} />;\n      case \"entities\":\n        return (\n          <EntityEditor\n            project={project}\n            onSave={handleSave}\n            onAddTag={onAddTag}\n            schemaUsage={schemaUsage}\n          />\n        );\n      case \"relationships\":\n        return <RelationshipEditor project={project} onSave={handleSave} />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"cosmo-container\">\n      {/* Left sidebar with nav */}\n      <div className=\"cosmo-sidebar\">\n        <nav className=\"cosmo-nav\">\n          {TABS.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`cosmo-nav-button ${activeTab === tab.id ? \"cosmo-nav-button-active\" : \"cosmo-nav-button-inactive\"}`}\n            >\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"cosmo-main\">\n        <div className=\"cosmo-content\">{renderContent()}</div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage,\n}", "type": "{ schema: any; axisDefinitions: any; seedEntities: any; seedRelationships: any; onEntityKindsChange: any; onCulturesChange: any; onAxisDefinitionsChange: any; onTagRegistryChange: any; onSeedEntitiesChange: any; onSeedRelationshipsChange: any; onAddTag: any; activeSection: any; onSectionChange: any; schemaUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/AxisRegistry/index.jsx", "sourceCode": "export default function AxisRegistryEditor({\n  axisDefinitions = [],\n  entityKinds = [],\n  tagRegistry = [],\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n}) {\n  const [showModal, setShowModal] = useState(false);\n  const [editingAxis, setEditingAxis] = useState(null);\n  const [formData, setFormData] = useState({\n    id: \"\",\n    name: \"\",\n    description: \"\",\n    lowTag: \"\",\n    highTag: \"\",\n  });\n\n  // Compute which entity kinds use each axis\n  const axisUsage = useMemo(() => {\n    const usage = {};\n    for (const axis of axisDefinitions) {\n      usage[axis.id] = [];\n    }\n\n    for (const ek of entityKinds) {\n      const axes = ek.semanticPlane?.axes || {};\n      for (const [axisKey, axisConfig] of Object.entries(axes)) {\n        if (axisConfig.axisId && usage[axisConfig.axisId]) {\n          usage[axisConfig.axisId].push({\n            kind: ek.kind,\n            description: ek.description,\n            axis: axisKey.toUpperCase(),\n          });\n        }\n      }\n    }\n\n    return usage;\n  }, [axisDefinitions, entityKinds]);\n\n  const openNewModal = () => {\n    setEditingAxis(null);\n    setFormData({\n      id: \"\",\n      name: \"\",\n      description: \"\",\n      lowTag: \"\",\n      highTag: \"\",\n    });\n    setShowModal(true);\n  };\n\n  const openEditModal = (axis) => {\n    setEditingAxis(axis);\n    setFormData({\n      id: axis.id,\n      name: axis.name,\n      description: axis.description || \"\",\n      lowTag: axis.lowTag,\n      highTag: axis.highTag,\n    });\n    setShowModal(true);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setEditingAxis(null);\n  };\n\n  const generateId = (name) => {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"_\")\n      .replace(/^_|_$/g, \"\");\n  };\n\n  const handleNameChange = (name) => {\n    setFormData((prev) => ({\n      ...prev,\n      name,\n      // Auto-generate ID only if creating new or ID hasn't been manually edited\n      id: !editingAxis ? generateId(name) : prev.id,\n    }));\n  };\n\n  const ensureTagExists = (tagId, isAxis = true) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing) {\n      // Update existing tag to be an axis tag\n      if (!existing.isAxis) {\n        return { ...existing, isAxis: true };\n      }\n      return existing;\n    }\n    // Create new tag\n    return {\n      tag: tagId,\n      description: \"\",\n      category: \"trait\",\n      isAxis: true,\n    };\n  };\n\n  const saveAxis = () => {\n    if (!formData.name.trim() || !formData.lowTag.trim() || !formData.highTag.trim()) {\n      return;\n    }\n\n    if (!onAxisDefinitionsChange) {\n      return;\n    }\n\n    const axisId = formData.id || generateId(formData.name);\n    const newAxis = {\n      id: axisId,\n      name: formData.name.trim(),\n      description: formData.description.trim(),\n      lowTag: formData.lowTag.trim(),\n      highTag: formData.highTag.trim(),\n    };\n\n    // Update axis definitions\n    let newDefinitions;\n    if (editingAxis) {\n      newDefinitions = axisDefinitions.map((a) => (a.id === editingAxis.id ? newAxis : a));\n    } else {\n      newDefinitions = [...axisDefinitions, newAxis];\n    }\n\n    onAxisDefinitionsChange(newDefinitions);\n\n    // Auto-manage tags if callback is provided\n    if (onTagRegistryChange) {\n      const lowTagEntry = ensureTagExists(newAxis.lowTag);\n      const highTagEntry = ensureTagExists(newAxis.highTag);\n\n      // Set mutual exclusivity between the tags\n      const lowWithExclusive = {\n        ...lowTagEntry,\n        mutuallyExclusiveWith: [\n          ...new Set([...(lowTagEntry.mutuallyExclusiveWith || []), newAxis.highTag]),\n        ],\n      };\n      const highWithExclusive = {\n        ...highTagEntry,\n        mutuallyExclusiveWith: [\n          ...new Set([...(highTagEntry.mutuallyExclusiveWith || []), newAxis.lowTag]),\n        ],\n      };\n\n      // Update tag registry\n      let newRegistry = [...tagRegistry];\n\n      // Update or add low tag\n      const lowIdx = newRegistry.findIndex((t) => t.tag === newAxis.lowTag);\n      if (lowIdx >= 0) {\n        newRegistry[lowIdx] = lowWithExclusive;\n      } else {\n        newRegistry.push(lowWithExclusive);\n      }\n\n      // Update or add high tag\n      const highIdx = newRegistry.findIndex((t) => t.tag === newAxis.highTag);\n      if (highIdx >= 0) {\n        newRegistry[highIdx] = highWithExclusive;\n      } else {\n        newRegistry.push(highWithExclusive);\n      }\n\n      onTagRegistryChange(newRegistry);\n    }\n\n    closeModal();\n  };\n\n  const deleteAxis = (axisId) => {\n    const usage = axisUsage[axisId] || [];\n    if (usage.length > 0) {\n      const kindList = usage.map((u) => u.description || u.kind).join(\", \");\n      if (!window.confirm(`This axis is used by: ${kindList}. Delete anyway?`)) {\n        return;\n      }\n    }\n\n    const newDefinitions = axisDefinitions.filter((a) => a.id !== axisId);\n    onAxisDefinitionsChange(newDefinitions);\n  };\n\n  return (\n    <div className=\"axr-container\">\n      <div className=\"axr-header\">\n        <div className=\"axr-title\">Axis Registry</div>\n        <div className=\"axr-subtitle\">\n          Define reusable semantic axes. Tags are auto-configured when you save.\n        </div>\n      </div>\n\n      <div className=\"axr-toolbar\">\n        <span className=\"axr-count\">\n          {axisDefinitions.length} {axisDefinitions.length === 1 ? \"axis\" : \"axes\"} defined\n        </span>\n        <button className=\"axr-add-button\" onClick={openNewModal}>\n          + New Axis\n        </button>\n      </div>\n\n      {axisDefinitions.length === 0 ? (\n        <div className=\"axr-empty-state\">\n          No axes defined yet. Create your first axis to start building semantic planes.\n        </div>\n      ) : (\n        <div className=\"axr-axis-list\">\n          {axisDefinitions.map((axis) => {\n            const usage = axisUsage[axis.id] || [];\n            return (\n              <div key={axis.id} className=\"axr-axis-card\">\n                <div className=\"axr-axis-header\">\n                  <div>\n                    <div className=\"axr-axis-name\">{axis.name}</div>\n                    {axis.description && (\n                      <div className=\"axr-axis-description\">{axis.description}</div>\n                    )}\n                  </div>\n                  <div className=\"axr-actions\">\n                    <button className=\"axr-edit-button\" onClick={() => openEditModal(axis)}>\n                      Edit\n                    </button>\n                    <button className=\"axr-delete-button\" onClick={() => deleteAxis(axis.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"axr-axis-range\">\n                  <span className=\"axr-tag\">{axis.lowTag}</span>\n                  <span className=\"axr-arrow\">\u2190\u2015\u2015\u2015\u2192</span>\n                  <span className=\"axr-tag\">{axis.highTag}</span>\n                </div>\n\n                {usage.length > 0 && (\n                  <div className=\"axr-usage-info\">\n                    Used in:{\" \"}\n                    {usage.map((u, i) => (\n                      <span key={u.kind}>\n                        {i > 0 && \", \"}\n                        <span className=\"axr-usage-kind\">\n                          {u.description || u.kind} ({u.axis})\n                        </span>\n                      </span>\n                    ))}\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Create/Edit Modal */}\n      {showModal && (\n        <div className=\"axr-modal\" onClick={closeModal} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") closeModal(); }} >\n          <div className=\"axr-modal-content\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n            <div className=\"axr-modal-title\">\n              {editingAxis ? `Edit Axis: ${editingAxis.name}` : \"New Axis Definition\"}\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"name\" className=\"axr-label\">Name</label>\n              <input id=\"name\"\n                className=\"axr-input\"\n                placeholder=\"e.g., Power, Alignment, Element\"\n                value={formData.name}\n                onChange={(e) => handleNameChange(e.target.value)}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"id\" className=\"axr-label\">ID</label>\n              <input id=\"id\"\n                className=\"axr-input\"\n                placeholder=\"e.g., power, alignment, element\"\n                value={formData.id}\n                onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n                disabled={!!editingAxis}\n              />\n              <div className=\"axr-hint\">\n                {editingAxis ? \"ID cannot be changed\" : \"Auto-generated from name\"}\n              </div>\n            </div>\n\n            <div className=\"axr-form-group\">\n              <label htmlFor=\"description-optional\" className=\"axr-label\">Description (optional)</label>\n              <input id=\"description-optional\"\n                className=\"axr-input\"\n                placeholder=\"Brief description of this axis\"\n                value={formData.description}\n                onChange={(e) => setFormData({ ...formData, description: e.target.value })}\n              />\n// ... (truncated)", "parameters": [{"name": "{\n  axisDefinitions = [],\n  entityKinds = [],\n  tagRegistry = [],\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n}", "type": "{ axisDefinitions?: any[]; entityKinds?: any[]; tagRegistry?: any[]; onAxisDefinitionsChange: any; onTagRegistryChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/CultureEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/CultureEditor/index.jsx", "sourceCode": "export default function CultureEditor({ project, onSave }) {\n  const [expandedCultures, setExpandedCultures] = useState({});\n  // Track local slider value during drag to avoid expensive state updates\n  const [localSliderValue, setLocalSliderValue] = useState(null);\n  const draggingRef = useRef(null); // tracks cultureId, kindId, axis\n\n  const cultures = project?.cultures || [];\n  const entityKinds = project?.entityKinds || [];\n  const axisDefinitions = useMemo(() => project?.axisDefinitions || [], [project?.axisDefinitions]);\n  const axisById = useMemo(() => {\n    return new Map(axisDefinitions.map((axis) => [axis.id, axis]));\n  }, [axisDefinitions]);\n\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => ({ ...prev, [cultureId]: !prev[cultureId] }));\n  };\n\n  const updateCultures = (newCultures) => {\n    onSave({ cultures: newCultures });\n  };\n\n  const updateCulture = (cultureId, updates) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    updateCultures(cultures.map((c) => (c.id === cultureId ? { ...c, ...updates } : c)));\n  };\n\n  const commitAxisBias = (cultureId, kindId, axis, value) => {\n    const culture = cultures.find((c) => c.id === cultureId);\n    if (!culture) return;\n\n    const kindBiases = culture.axisBiases?.[kindId] || { x: 50, y: 50, z: 50 };\n\n    updateCulture(cultureId, {\n      axisBiases: {\n        ...culture.axisBiases,\n        [kindId]: {\n          ...kindBiases,\n          [axis]: parseInt(value, 10),\n        },\n      },\n    });\n  };\n\n  const handleSliderStart = (cultureId, kindId, axis, value) => {\n    draggingRef.current = { cultureId, kindId, axis };\n    setLocalSliderValue(parseInt(value, 10));\n  };\n\n  const handleSliderChange = (value) => {\n    if (draggingRef.current) {\n      setLocalSliderValue(parseInt(value, 10));\n    }\n  };\n\n  const handleSliderEnd = () => {\n    if (draggingRef.current && localSliderValue !== null) {\n      const { cultureId, kindId, axis } = draggingRef.current;\n      commitAxisBias(cultureId, kindId, axis, localSliderValue);\n    }\n    draggingRef.current = null;\n    setLocalSliderValue(null);\n  };\n\n  const getDisplayValue = (cultureId, kindId, axis, storedValue) => {\n    if (\n      draggingRef.current &&\n      draggingRef.current.cultureId === cultureId &&\n      draggingRef.current.kindId === kindId &&\n      draggingRef.current.axis === axis &&\n      localSliderValue !== null\n    ) {\n      return localSliderValue;\n    }\n    return storedValue;\n  };\n\n  const getBiasSummary = (culture) => {\n    const biasCount = Object.keys(culture.axisBiases || {}).length;\n    return `${biasCount} kind${biasCount !== 1 ? \"s\" : \"\"} configured`;\n  };\n\n  return (\n    <div className=\"cued-container\">\n      <div className=\"cued-header\">\n        <div className=\"cued-title\">Culture Biases</div>\n        <div className=\"cued-subtitle\">\n          Configure axis biases for each culture on each entity kind&apos;s semantic plane.\n        </div>\n      </div>\n\n      {cultures.length === 0 ? (\n        <div className=\"cued-empty-state\">\n          No cultures defined yet. Add cultures in the Enumerist tab first.\n        </div>\n      ) : (\n        <div className=\"cued-culture-list\">\n          {cultures.map((culture) => {\n            const isExpanded = expandedCultures[culture.id];\n            const isFramework = Boolean(culture.isFramework);\n\n            return (\n              <div key={culture.id} className=\"cued-culture-card\">\n                <div className=\"cued-culture-header\" onClick={() => toggleCulture(culture.id)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  <div className=\"cued-culture-header-left\">\n                    <span\n                      className=\"cued-expand-icon\"\n                      style={{ '--cued-expand-rotation': isExpanded ? \"rotate(90deg)\" : \"rotate(0deg)\" }}\n                    >\n                      \u25b6\n                    </span>\n                    <div className=\"cued-color-dot\" style={{ '--cued-color-dot-bg': culture.color }} />\n                    <span className=\"cued-culture-name\">{culture.name}</span>\n                    <span className=\"cued-culture-id\">({culture.id})</span>\n                    {isFramework && (\n                      <span className=\"cued-framework-badge\">framework</span>\n                    )}\n                  </div>\n                  <div className=\"cued-culture-summary\">{getBiasSummary(culture)}</div>\n                </div>\n\n                {isExpanded && (\n                  <div className=\"cued-culture-body\">\n                    {entityKinds.length === 0 ? (\n                      <div className=\"cued-no-kinds-warning\">\n                        Define entity kinds in the Enumerist tab first to configure axis biases.\n                      </div>\n                    ) : (\n                      <div className=\"cued-kinds-grid\">\n                        {entityKinds.map((kind) => (\n                          <KindBiasCard\n                            key={kind.kind}\n                            culture={culture}\n                            kind={kind}\n                            axisById={axisById}\n                            isFramework={isFramework}\n                            handleSliderStart={handleSliderStart}\n                            handleSliderChange={handleSliderChange}\n                            handleSliderEnd={handleSliderEnd}\n                            getDisplayValue={getDisplayValue}\n                            draggingRef={draggingRef}\n                          />\n                        ))}\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ project, onSave }", "type": "{ project: any; onSave: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/EntityEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/EntityEditor/index.jsx", "sourceCode": "export default function EntityEditor({ project, onSave, onAddTag, schemaUsage = {} }) {\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [filterKind, setFilterKind] = useState(\"\");\n  const [generating, setGenerating] = useState(false);\n  const [generateError, setGenerateError] = useState(null);\n\n  const entities = project?.seedEntities || [];\n  // Schema v2: entityKinds at project root\n  const entityKinds = project?.entityKinds || [];\n  const cultures = project?.cultures || [];\n  const tagRegistry = project?.tagRegistry || [];\n\n  const filteredEntities = filterKind ? entities.filter((e) => e.kind === filterKind) : entities;\n\n  const selectedEntity = entities.find((e) => e.id === selectedEntityId);\n  const selectedKindDef = entityKinds.find((k) => k.kind === selectedEntity?.kind);\n\n  const updateEntities = (newEntities) => {\n    onSave({ seedEntities: newEntities });\n  };\n\n  const addEntity = () => {\n    const defaultKind = entityKinds[0];\n    if (!defaultKind) {\n      alert(\"Define entity kinds in Schema first\");\n      return;\n    }\n\n    const newEntity = {\n      id: `entity_${Date.now()}`,\n      kind: defaultKind.kind,\n      subtype: defaultKind.subtypes[0]?.id || \"\",\n      name: \"New Entity\",\n      summary: \"\",\n      narrativeHint: \"\",\n      description: \"\",\n      status: defaultKind.statuses[0]?.id || \"active\",\n      prominence: \"recognized\",\n      culture: cultures[0]?.id || \"\",\n      tags: {}, // Key-value pairs for semantic tagging\n      links: [], // Relationships are stored separately, populated at load time\n      coordinates: { x: 50, y: 50, z: 50 },\n      createdAt: 0,\n      updatedAt: 0,\n    };\n\n    updateEntities([...entities, newEntity]);\n    setSelectedEntityId(newEntity.id);\n  };\n\n  const updateEntity = (updates) => {\n    if (!selectedEntity) return;\n\n    // If kind changed, reset subtype and status\n    if (updates.kind && updates.kind !== selectedEntity.kind) {\n      const newKind = entityKinds.find((k) => k.kind === updates.kind);\n      updates.subtype = newKind?.subtypes[0]?.id || \"\";\n      updates.status = newKind?.statuses[0]?.id || \"active\";\n    }\n\n    updateEntities(entities.map((e) => (e.id === selectedEntityId ? { ...e, ...updates } : e)));\n  };\n\n  const deleteEntity = () => {\n    if (!selectedEntity) return;\n    if (!confirm(`Delete \"${selectedEntity.name}\"?`)) return;\n\n    updateEntities(entities.filter((e) => e.id !== selectedEntityId));\n    setSelectedEntityId(null);\n  };\n\n  const getCultureColor = (cultureId) => {\n    return cultures.find((c) => c.id === cultureId)?.color || \"#707080\";\n  };\n\n  const handleGenerateName = async () => {\n    if (!selectedEntity) return;\n\n    const culture = cultures.find((c) => c.id === selectedEntity.culture);\n    if (!culture) {\n      setGenerateError(\"Select a culture first\");\n      return;\n    }\n\n    // Check if culture has naming profiles\n    if (!culture.naming?.profiles || culture.naming.profiles.length === 0) {\n      setGenerateError(\n        `Culture \"${culture.name || culture.id}\" has no naming profiles. Configure naming in Name Forge first.`\n      );\n      return;\n    }\n\n    setGenerating(true);\n    setGenerateError(null);\n\n    try {\n      const name = await generateEntityName(culture, {\n        kind: selectedEntity.kind,\n        subtype: selectedEntity.subtype,\n        prominence: selectedEntity.prominence,\n        tags: Object.keys(selectedEntity.tags || {}),\n      });\n      updateEntity({ name });\n    } catch (err) {\n      console.error(\"Name generation error:\", err);\n      setGenerateError(err.message || \"Failed to generate name\");\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  // Check if current entity can have names generated\n  const canGenerateName = () => {\n    if (!selectedEntity) return false;\n    const culture = cultures.find((c) => c.id === selectedEntity.culture);\n    return culture && culture.naming?.profiles && culture.naming.profiles.length > 0;\n  };\n\n  // Convert tags from object format { tag: true } to array format ['tag']\n  const getTagsAsArray = () => {\n    const tags = selectedEntity?.tags || {};\n    return Object.keys(tags);\n  };\n\n  // Update tags from array format back to object format\n  const handleTagsChange = (tagArray) => {\n    if (!selectedEntity) return;\n    const tagsObj = {};\n    tagArray.forEach((tag) => {\n      tagsObj[tag] = true;\n    });\n    updateEntity({ tags: tagsObj });\n  };\n\n  return (\n    <div className=\"ee-container\">\n      <div className=\"ee-list-panel\">\n        <div className=\"ee-header\">\n          <div className=\"ee-title\">Entities</div>\n          <div className=\"ee-subtitle\">Create seed entities to populate your world.</div>\n        </div>\n\n        <div className=\"ee-toolbar\">\n          <select\n            className=\"ee-filter-select\"\n            value={filterKind}\n            onChange={(e) => setFilterKind(e.target.value)}\n          >\n            <option value=\"\">All kinds ({entities.length})</option>\n            {entityKinds.map((k) => (\n              <option key={k.kind} value={k.kind}>\n                {k.description || k.kind} ({entities.filter((e) => e.kind === k.kind).length})\n              </option>\n            ))}\n          </select>\n          <button className=\"ee-add-button\" onClick={addEntity}>\n            + Add\n          </button>\n        </div>\n\n        <div className=\"ee-entity-list\">\n          {filteredEntities.length === 0 ? (\n            <div className=\"ee-empty-state\">\n              {entities.length === 0\n                ? \"No entities yet. Create one to get started.\"\n                : \"No entities match the filter.\"}\n            </div>\n          ) : (\n            filteredEntities.map((entity) => (\n              <div\n                key={entity.id}\n                className={`ee-entity-item${selectedEntityId === entity.id ? \" ee-entity-item-selected\" : \"\"}`}\n                onClick={() => setSelectedEntityId(entity.id)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div\n                  className=\"ee-entity-color\"\n                  style={{ '--ee-entity-color-bg': getCultureColor(entity.culture) }}\n                />\n                <div className=\"ee-entity-info\">\n                  <div className=\"ee-entity-name\">{entity.name}</div>\n                  <div className=\"ee-entity-meta-row\">\n                    <span className=\"ee-entity-meta\">\n                      {entity.kind} / {entity.subtype || \"no subtype\"}\n                    </span>\n                    <UsageBadges\n                      usage={getEntityKindUsageSummary(schemaUsage, entity.kind)}\n                      compact\n                    />\n                  </div>\n                </div>\n              </div>\n            ))\n          )}\n        </div>\n      </div>\n\n      <div className=\"ee-form-panel\">\n        {!selectedEntity ? (\n          <div className=\"ee-empty-form\">Select an entity to edit, or create a new one.</div>\n        ) : (\n          <>\n            <div className=\"ee-form-title\">Edit Entity</div>\n\n            <div className=\"ee-form-group\">\n              <span className=\"ee-label\">Name</span>\n              <div className=\"ee-name-row\">\n                <input\n                  className=\"ee-input ee-name-input\"\n                  value={selectedEntity.name}\n                  onChange={(e) => updateEntity({ name: e.target.value })}\n                />\n                <button\n                  className={`ee-generate-button${!canGenerateName() || generating ? \" ee-generate-button-disabled\" : \"\"}`}\n                  onClick={handleGenerateName}\n                  disabled={!canGenerateName() || generating}\n                  title={(() => {\n                    if (!selectedEntity.culture) return \"Select a culture first\";\n                    if (!canGenerateName()) return \"Configure naming in Name Forge first\";\n                    return \"Generate a culturally-appropriate name\";\n                  })()}\n                >\n                  {generating ? \"Generating...\" : \"Generate\"}\n                </button>\n              </div>\n              {generateError && (\n                <div className=\"ee-generate-error\">\n                  {generateError}\n                </div>\n              )}\n            </div>\n\n            <div className=\"ee-row\">\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"kind\" className=\"ee-label\">Kind</label>\n                <select id=\"kind\"\n                  className=\"ee-select\"\n                  value={selectedEntity.kind}\n                  onChange={(e) => updateEntity({ kind: e.target.value })}\n                >\n                  {entityKinds.map((k) => (\n                    <option key={k.kind} value={k.kind}>\n                      {k.description || k.kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"subtype\" className=\"ee-label\">Subtype</label>\n                <select id=\"subtype\"\n                  className=\"ee-select\"\n                  value={selectedEntity.subtype || \"\"}\n                  onChange={(e) => updateEntity({ subtype: e.target.value })}\n                >\n                  <option value=\"\">None</option>\n                  {selectedKindDef?.subtypes?.map((s) => (\n                    <option key={s.id} value={s.id}>\n                      {s.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            <div className=\"ee-row\">\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"status\" className=\"ee-label\">Status</label>\n                <select id=\"status\"\n                  className=\"ee-select\"\n                  value={selectedEntity.status}\n                  onChange={(e) => updateEntity({ status: e.target.value })}\n                >\n                  {selectedKindDef?.statuses?.map((s) => (\n                    <option key={s.id} value={s.id}>\n                      {s.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              <div className=\"ee-form-group-flex\">\n                <label htmlFor=\"culture\" className=\"ee-label\">Culture</label>\n                <select id=\"culture\"\n                  className=\"ee-select\"\n                  value={selectedEntity.culture || \"\"}\n                  onChange={(e) => updateEntity({ culture: e.target.value })}\n                >\n                  <option value=\"\">None</option>\n                  {cultures.map((c) => (\n                    <option key={c.id} value={c.id}>\n                      {c.name}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n// ... (truncated)", "parameters": [{"name": "{ project, onSave, onAddTag, schemaUsage = {} }", "type": "{ project: any; onSave: any; onAddTag: any; schemaUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/RelationshipEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/RelationshipEditor/index.jsx", "sourceCode": "export default function RelationshipEditor({ project, onSave }) {\n  const [showModal, setShowModal] = useState(false);\n  const [filterKind, setFilterKind] = useState(\"\");\n  const [newRel, setNewRel] = useState({ kind: \"\", src: \"\", dst: \"\", strength: 1 });\n\n  const relationships = project?.seedRelationships || [];\n  const entities = project?.seedEntities || [];\n  // Schema v2: relationshipKinds at project root\n  const relationshipKinds = project?.relationshipKinds || [];\n\n  const filteredRels = filterKind\n    ? relationships.filter((r) => r.kind === filterKind)\n    : relationships;\n\n  const updateRelationships = (newRels) => {\n    onSave({ seedRelationships: newRels });\n  };\n\n  const addRelationship = () => {\n    if (!newRel.kind || !newRel.src || !newRel.dst) {\n      alert(\"Please fill all required fields\");\n      return;\n    }\n\n    if (newRel.src === newRel.dst) {\n      alert(\"Source and destination must be different\");\n      return;\n    }\n\n    const rel = {\n      kind: newRel.kind,\n      src: newRel.src,\n      dst: newRel.dst,\n      strength: parseFloat(newRel.strength) || 1,\n    };\n\n    updateRelationships([...relationships, rel]);\n    setShowModal(false);\n    setNewRel({ kind: \"\", src: \"\", dst: \"\", strength: 1 });\n  };\n\n  const deleteRelationship = (rel) => {\n    if (!confirm(\"Delete this relationship?\")) return;\n    updateRelationships(\n      relationships.filter((r) => !(r.kind === rel.kind && r.src === rel.src && r.dst === rel.dst))\n    );\n  };\n\n  const getEntityName = (entityId) => {\n    const entity = entities.find((e) => e.id === entityId);\n    return entity?.name || entityId;\n  };\n\n  const getRelKindName = (kindId) => {\n    const kind = relationshipKinds.find((k) => k.kind === kindId);\n    return kind?.description || kind?.kind || kindId;\n  };\n\n  // Filter entities by allowed source/dest kinds for the selected relationship\n  const selectedRelKind = relationshipKinds.find((k) => k.kind === newRel.kind);\n  const allowedSrcEntities = selectedRelKind?.srcKinds?.length\n    ? entities.filter((e) => selectedRelKind.srcKinds.includes(e.kind))\n    : entities;\n  const allowedDstEntities = selectedRelKind?.dstKinds?.length\n    ? entities.filter((e) => selectedRelKind.dstKinds.includes(e.kind))\n    : entities;\n\n  return (\n    <div className=\"re-container\">\n      <div className=\"re-header\">\n        <div className=\"re-title\">Relationships</div>\n        <div className=\"re-subtitle\">Define connections between seed entities.</div>\n      </div>\n\n      <div className=\"re-toolbar\">\n        <select\n          className=\"re-filter-select\"\n          value={filterKind}\n          onChange={(e) => setFilterKind(e.target.value)}\n        >\n          <option value=\"\">All kinds ({relationships.length})</option>\n          {relationshipKinds.map((k) => (\n            <option key={k.kind} value={k.kind}>\n              {k.description || k.kind} ({relationships.filter((r) => r.kind === k.kind).length})\n            </option>\n          ))}\n        </select>\n        <button\n          className=\"re-add-button\"\n          onClick={() => setShowModal(true)}\n          disabled={entities.length < 2 || relationshipKinds.length === 0}\n        >\n          + Add Relationship\n        </button>\n        {entities.length < 2 && (\n          <span className=\"re-hint\">Need at least 2 entities</span>\n        )}\n        {relationshipKinds.length === 0 && (\n          <span className=\"re-hint\">\n            Define relationship kinds in Schema first\n          </span>\n        )}\n      </div>\n\n      {filteredRels.length === 0 ? (\n        <div className=\"re-empty-state\">\n          {relationships.length === 0\n            ? \"No relationships yet. Create one to connect entities.\"\n            : \"No relationships match the filter.\"}\n        </div>\n      ) : (\n        <table className=\"re-table\">\n          <thead>\n            <tr>\n              <th className=\"re-th\">Kind</th>\n              <th className=\"re-th\">Source</th>\n              <th className=\"re-th\"></th>\n              <th className=\"re-th\">Destination</th>\n              <th className=\"re-th\">Strength</th>\n              <th className=\"re-th\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {filteredRels.map((rel, idx) => (\n              <tr key={`${rel.kind}-${rel.src}-${rel.dst}-${idx}`}>\n                <td className=\"re-td\">\n                  <span className=\"re-kind-badge\">{getRelKindName(rel.kind)}</span>\n                </td>\n                <td className=\"re-td\">\n                  <span className=\"re-entity-link\">{getEntityName(rel.src)}</span>\n                </td>\n                <td className=\"re-td-arrow\">\n                  <span className=\"re-arrow\">\u2192</span>\n                </td>\n                <td className=\"re-td\">\n                  <span className=\"re-entity-link\">{getEntityName(rel.dst)}</span>\n                </td>\n                <td className=\"re-td\">{rel.strength}</td>\n                <td className=\"re-td-actions\">\n                  <button className=\"re-delete-button\" onClick={() => deleteRelationship(rel)}>\n                    Delete\n                  </button>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n\n      {/* Add Relationship Modal */}\n      {showModal && (\n        <div className=\"re-modal\" onClick={() => setShowModal(false)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <div className=\"re-modal-content\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n            <div className=\"re-modal-title\">Add Relationship</div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"relationship-kind\" className=\"re-label\">Relationship Kind</label>\n              <select id=\"relationship-kind\"\n                className=\"re-select\"\n                value={newRel.kind}\n                onChange={(e) => setNewRel({ ...newRel, kind: e.target.value, src: \"\", dst: \"\" })}\n              >\n                <option value=\"\">Select kind...</option>\n                {relationshipKinds.map((k) => (\n                  <option key={k.kind} value={k.kind}>\n                    {k.description || k.kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"source-entity\" className=\"re-label\">Source Entity</label>\n              <select id=\"source-entity\"\n                className=\"re-select\"\n                value={newRel.src}\n                onChange={(e) => setNewRel({ ...newRel, src: e.target.value })}\n                disabled={!newRel.kind}\n              >\n                <option value=\"\">Select source...</option>\n                {allowedSrcEntities.map((e) => (\n                  <option key={e.id} value={e.id}>\n                    {e.name} ({e.kind})\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label htmlFor=\"destination-entity\" className=\"re-label\">Destination Entity</label>\n              <select id=\"destination-entity\"\n                className=\"re-select\"\n                value={newRel.dst}\n                onChange={(e) => setNewRel({ ...newRel, dst: e.target.value })}\n                disabled={!newRel.kind}\n              >\n                <option value=\"\">Select destination...</option>\n                {allowedDstEntities\n                  .filter((e) => e.id !== newRel.src)\n                  .map((e) => (\n                    <option key={e.id} value={e.id}>\n                      {e.name} ({e.kind})\n                    </option>\n                  ))}\n              </select>\n            </div>\n\n            <div className=\"re-form-group\">\n              <label className=\"re-label\">Strength (0-1)\n              <NumberInput\n                className=\"re-input\"\n                min={0}\n                max={1}\n                step={0.1}\n                value={newRel.strength}\n                onChange={(v) => setNewRel({ ...newRel, strength: v ?? 0.5 })}\n              />\n              </label>\n            </div>\n\n            <div className=\"re-modal-actions\">\n              <button className=\"re-button\" onClick={() => setShowModal(false)}>\n                Cancel\n              </button>\n              <button className=\"re-add-button\" onClick={addRelationship}>\n                Add Relationship\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ project, onSave }", "type": "{ project: any; onSave: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/SemanticPlane/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/SemanticPlane/index.jsx", "sourceCode": "export default function SemanticPlaneEditor({ project, onSave, axisDefinitions = [] }) {\n  const [selectedKindId, setSelectedKindId] = useState(null);\n  const [showNewRegionModal, setShowNewRegionModal] = useState(false);\n  const [showAxisModal, setShowAxisModal] = useState(false);\n  const [showRegionModal, setShowRegionModal] = useState(false);\n  const [editingAxis, setEditingAxis] = useState(null);\n  const [editingRegion, setEditingRegion] = useState(null);\n  const [newRegion, setNewRegion] = useState({\n    label: \"\",\n    x: 50,\n    y: 50,\n    radius: 15,\n    culture: \"\",\n    tags: [],\n  });\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [selectedRegionId, setSelectedRegionId] = useState(null);\n\n  // Schema v2: entityKinds at project root\n  const entityKinds = project?.entityKinds || [];\n  const cultures = project?.cultures || [];\n  const tagRegistry = project?.tagRegistry || [];\n  const seedEntities = project?.seedEntities || [];\n\n  // Helper to resolve axis config - looks up from registry by axisId\n  const resolveAxis = (axisConfig) => {\n    if (!axisConfig?.axisId) return null;\n    const registeredAxis = axisDefinitions.find((a) => a.id === axisConfig.axisId);\n    if (!registeredAxis) return null;\n    return {\n      axisId: registeredAxis.id,\n      name: registeredAxis.name,\n      lowTag: registeredAxis.lowTag,\n      highTag: registeredAxis.highTag,\n    };\n  };\n\n  // Select first kind by default\n  const selectedKind = entityKinds.find((k) => k.kind === selectedKindId) || entityKinds[0];\n  const semanticPlane = selectedKind?.semanticPlane || {\n    axes: {},\n    regions: [],\n  };\n  const planeEntities = seedEntities.filter((e) => e.kind === selectedKind?.kind);\n  const isFrameworkKind = Boolean(selectedKind?.isFramework);\n\n  const updateEntityKind = (kindId, updates) => {\n    const target = entityKinds.find((k) => k.kind === kindId);\n    if (target?.isFramework) return;\n    const newKinds = entityKinds.map((k) => (k.kind === kindId ? { ...k, ...updates } : k));\n    onSave({ entityKinds: newKinds });\n  };\n\n  const addRegion = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !newRegion.label.trim()) return;\n\n    // Use culture color if culture is selected, otherwise random color\n    const selectedCulture = cultures.find((c) => c.id === newRegion.culture);\n    const regionColor =\n      selectedCulture?.color ||\n      \"#\" +\n        // eslint-disable-next-line sonarjs/pseudo-random -- non-security random color fallback\n        Math.floor(Math.random() * 16777215)\n          .toString(16)\n          .padStart(6, \"0\");\n\n    const region = {\n      id: `region_${Date.now()}`,\n      label: newRegion.label.trim(),\n      color: regionColor,\n      culture: newRegion.culture || null,\n      tags: newRegion.tags || [],\n      bounds: {\n        shape: \"circle\",\n        center: { x: parseFloat(newRegion.x), y: parseFloat(newRegion.y) },\n        radius: parseFloat(newRegion.radius),\n      },\n    };\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: [...(semanticPlane.regions || []), region],\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowNewRegionModal(false);\n    setNewRegion({ label: \"\", x: 50, y: 50, radius: 15, culture: \"\" });\n  };\n\n  const deleteRegion = (regionId) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: (semanticPlane.regions || []).filter((r) => r.id !== regionId),\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const handleMoveEntity = (entityId, coords) => {\n    const entities = project?.seedEntities || [];\n    const updated = entities.map((e) =>\n      e.id === entityId\n        ? {\n            ...e,\n            coordinates: {\n              x: Math.round(coords.x),\n              y: Math.round(coords.y),\n              z: e.coordinates?.z || 50,\n            },\n          }\n        : e\n    );\n    onSave({ seedEntities: updated });\n  };\n\n  const handleMoveRegion = (regionId, coords) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === regionId\n        ? {\n            ...r,\n            bounds: {\n              ...r.bounds,\n              center: { x: Math.round(coords.x), y: Math.round(coords.y) },\n            },\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const handleResizeRegion = (regionId, newRadius) => {\n    if (isFrameworkKind) return;\n    if (!selectedKind) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === regionId\n        ? {\n            ...r,\n            bounds: {\n              ...r.bounds,\n              radius: Math.round(newRadius),\n            },\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n  };\n\n  const getCultureColor = (cultureId) => {\n    return cultures.find((c) => c.id === cultureId)?.color || \"#888\";\n  };\n\n  const openRegionEditor = (region) => {\n    if (isFrameworkKind) return;\n    setEditingRegion({\n      ...region,\n      tags: region.tags || [],\n    });\n    setShowRegionModal(true);\n  };\n\n  const saveRegionConfig = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !editingRegion) return;\n\n    const updatedRegions = (semanticPlane.regions || []).map((r) =>\n      r.id === editingRegion.id\n        ? {\n            ...r,\n            label: editingRegion.label,\n            culture: editingRegion.culture || null,\n            tags: editingRegion.tags || [],\n          }\n        : r\n    );\n\n    const updatedPlane = {\n      ...semanticPlane,\n      regions: updatedRegions,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowRegionModal(false);\n    setEditingRegion(null);\n  };\n\n  const openAxisEditor = (axisKey) => {\n    if (isFrameworkKind) return;\n    const rawAxisConfig = semanticPlane.axes?.[axisKey];\n    const resolved = resolveAxis(rawAxisConfig);\n    setEditingAxis({\n      key: axisKey,\n      axisId: rawAxisConfig?.axisId || \"\",\n      name: resolved?.name || \"\",\n      lowTag: resolved?.lowTag || \"\",\n      highTag: resolved?.highTag || \"\",\n    });\n    setShowAxisModal(true);\n  };\n\n  const handleAxisSelect = (axisId) => {\n    const axis = axisDefinitions.find((a) => a.id === axisId);\n    if (axis) {\n      setEditingAxis({\n        ...editingAxis,\n        axisId: axis.id,\n        name: axis.name,\n        lowTag: axis.lowTag,\n        highTag: axis.highTag,\n      });\n    }\n  };\n\n  const saveAxisConfig = () => {\n    if (isFrameworkKind) return;\n    if (!selectedKind || !editingAxis?.axisId) return;\n\n    const updatedAxes = {\n      ...semanticPlane.axes,\n      [editingAxis.key]: { axisId: editingAxis.axisId },\n    };\n\n    const updatedPlane = {\n      ...semanticPlane,\n      axes: updatedAxes,\n    };\n\n    updateEntityKind(selectedKind.kind, { semanticPlane: updatedPlane });\n    setShowAxisModal(false);\n    setEditingAxis(null);\n  };\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"sp-container\">\n        <div className=\"sp-header\">\n          <div className=\"sp-title\">Semantic Planes</div>\n          <div className=\"sp-subtitle\">\n            View and edit the coordinate space for each entity kind.\n          </div>\n        </div>\n        <div className=\"sp-empty-state\">\n          Define entity kinds in the Enumerist tab first to view their semantic planes.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"sp-container\">\n      <div className=\"sp-header\">\n        <div className=\"sp-title\">Semantic Planes</div>\n        <div className=\"sp-subtitle\">\n          Drag entities to reposition. Scroll to zoom, drag background to pan.\n        </div>\n      </div>\n\n      <div className=\"sp-toolbar\">\n        <select\n          className=\"sp-select\"\n          value={selectedKind?.kind || \"\"}\n          onChange={(e) => {\n            setSelectedKindId(e.target.value);\n            setSelectedEntityId(null);\n            setSelectedRegionId(null);\n          }}\n        >\n          {entityKinds.map((k) => (\n            <option key={k.kind} value={k.kind}>\n              {k.description || k.kind} ({seedEntities.filter((e) => e.kind === k.kind).length}{\" \"}\n              entities)\n            </option>\n          ))}\n        </select>\n        <button\n          className={`sp-add-button${isFrameworkKind ? \" sp-add-button-disabled\" : \"\"}`}\n          onClick={() => setShowNewRegionModal(true)}\n          disabled={isFrameworkKind}\n        >\n          + Add Region\n        </button>\n// ... (truncated)", "parameters": [{"name": "{ project, onSave, axisDefinitions = [] }", "type": "{ project: any; onSave: any; axisDefinitions?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/cosmographer/webui/src/components/SemanticPlane/PlaneCanvas.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/components/SemanticPlane/PlaneCanvas.jsx", "sourceCode": "export default function PlaneCanvas({\n  plane,\n  regions = [],\n  entities = [],\n  cultures = [],\n  axisDefinitions = [],\n  selectedEntityId,\n  selectedRegionId,\n  onSelectEntity,\n  onSelectRegion,\n  onMoveEntity,\n  onMoveRegion,\n  onResizeRegion,\n}) {\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [size, setSize] = useState({ width: 600, height: 400 });\n  const [camera, setCamera] = useState({ x: 0, y: 0, zoom: 1 });\n  const [interaction, setInteraction] = useState({\n    type: null,\n    startX: 0,\n    startY: 0,\n    startCamera: null,\n  });\n\n  // Track dragged positions locally to avoid expensive React state updates during drag\n  const dragPositionRef = useRef(null);\n  const [renderTrigger, setRenderTrigger] = useState(0); // Force canvas redraw without parent re-render\n\n  // Resize observer to fill container\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const observer = new ResizeObserver((entries) => {\n      const { width, height } = entries[0].contentRect;\n      setSize({ width: Math.floor(width), height: Math.floor(height) });\n    });\n\n    observer.observe(container);\n    return () => observer.disconnect();\n  }, []);\n\n  // Calculate the drawable area (inside padding)\n  const drawArea = useMemo(() => ({\n    left: PADDING,\n    top: PADDING,\n    width: size.width - PADDING * 2,\n    height: size.height - PADDING * 2,\n  }), [size.width, size.height]);\n\n  // Base scale to fit world in draw area (maintaining aspect ratio)\n  const baseScale = Math.min(drawArea.width / WORLD_SIZE, drawArea.height / WORLD_SIZE);\n\n  // Convert world coordinates (0-100) to canvas pixel coordinates\n  const worldToCanvas = useCallback(\n    (wx, wy) => {\n      const scale = baseScale * camera.zoom;\n      // Center the world in the draw area\n      const worldPixelSize = WORLD_SIZE * scale;\n      const offsetX = drawArea.left + (drawArea.width - worldPixelSize) / 2;\n      const offsetY = drawArea.top + (drawArea.height - worldPixelSize) / 2;\n\n      return {\n        x: offsetX + (wx - WORLD_MIN) * scale + camera.x,\n        // Flip Y so 0 is at bottom\n        y: offsetY + (WORLD_MAX - wy) * scale + camera.y,\n      };\n    },\n    [baseScale, camera, drawArea]\n  );\n\n  // Convert canvas pixel coordinates to world coordinates\n  const canvasToWorld = useCallback(\n    (cx, cy) => {\n      const scale = baseScale * camera.zoom;\n      const worldPixelSize = WORLD_SIZE * scale;\n      const offsetX = drawArea.left + (drawArea.width - worldPixelSize) / 2;\n      const offsetY = drawArea.top + (drawArea.height - worldPixelSize) / 2;\n\n      return {\n        x: (cx - camera.x - offsetX) / scale + WORLD_MIN,\n        // Flip Y so 0 is at bottom\n        y: WORLD_MAX - (cy - camera.y - offsetY) / scale,\n      };\n    },\n    [baseScale, camera, drawArea]\n  );\n\n  // Draw the canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    const { width, height } = size;\n\n    // Clear\n    ctx.fillStyle = \"#0a0e14\";\n    ctx.fillRect(0, 0, width, height);\n\n    const scale = baseScale * camera.zoom;\n\n    // Get world corners in canvas space\n    const topLeft = worldToCanvas(WORLD_MIN, WORLD_MAX);\n    const bottomRight = worldToCanvas(WORLD_MAX, WORLD_MIN);\n    const worldWidth = bottomRight.x - topLeft.x;\n    const worldHeight = bottomRight.y - topLeft.y;\n\n    // Draw world background\n    ctx.fillStyle = \"#0d1117\";\n    ctx.fillRect(topLeft.x, topLeft.y, worldWidth, worldHeight);\n\n    // Draw grid\n    ctx.strokeStyle = \"#1a2332\";\n    ctx.lineWidth = 1;\n    const gridStep = 10;\n\n    for (let x = WORLD_MIN; x <= WORLD_MAX; x += gridStep) {\n      const { x: cx } = worldToCanvas(x, 0);\n      ctx.beginPath();\n      ctx.moveTo(cx, topLeft.y);\n      ctx.lineTo(cx, bottomRight.y);\n      ctx.stroke();\n    }\n    for (let y = WORLD_MIN; y <= WORLD_MAX; y += gridStep) {\n      const { y: cy } = worldToCanvas(0, y);\n      ctx.beginPath();\n      ctx.moveTo(topLeft.x, cy);\n      ctx.lineTo(bottomRight.x, cy);\n      ctx.stroke();\n    }\n\n    // Draw center crosshair\n    ctx.strokeStyle = \"#2a3a4a\";\n    ctx.lineWidth = 1;\n    const center = worldToCanvas(50, 50);\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, center.y);\n    ctx.lineTo(bottomRight.x, center.y);\n    ctx.moveTo(center.x, topLeft.y);\n    ctx.lineTo(center.x, bottomRight.y);\n    ctx.stroke();\n\n    // Draw world border\n    ctx.strokeStyle = \"#3a4a5a\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(topLeft.x, topLeft.y, worldWidth, worldHeight);\n\n    // Draw regions\n    regions.forEach((region) => {\n      drawPlaneRegion(ctx, region, selectedRegionId, dragPositionRef, worldToCanvas, scale);\n    });\n\n    // Draw entities\n    entities.forEach((entity) => {\n      if (!entity.coordinates) return;\n\n      // Check for drag override position\n      const drag = dragPositionRef.current;\n      let coordX = entity.coordinates.x;\n      let coordY = entity.coordinates.y;\n\n      if (drag && drag.type === \"entity\" && drag.id === entity.id) {\n        coordX = drag.position.x;\n        coordY = drag.position.y;\n      }\n\n      const { x: cx, y: cy } = worldToCanvas(coordX, coordY);\n      const culture = cultures.find((c) => c.id === entity.culture);\n      const color = culture?.color || \"#888\";\n      const isSelected = entity.id === selectedEntityId;\n\n      // Entity dot\n      ctx.beginPath();\n      ctx.arc(cx, cy, isSelected ? 10 : 7, 0, Math.PI * 2);\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      if (isSelected) {\n        ctx.strokeStyle = \"#fff\";\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n\n      // Entity label\n      ctx.fillStyle = \"#ccc\";\n      ctx.font = \"10px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(entity.name || entity.id, cx, cy - 12);\n    });\n\n    // Draw axis labels on the edges\n    const axes = plane?.axes || {};\n    const axisById = new Map((axisDefinitions || []).map((axis) => [axis.id, axis]));\n    const resolveAxis = (axisRef) => (axisRef?.axisId ? axisById.get(axisRef.axisId) : undefined);\n\n    ctx.fillStyle = \"#666\";\n    ctx.font = \"11px sans-serif\";\n\n    // X axis labels\n    if (axes.x) {\n      const axisRef = axes.x;\n      const axisDef = resolveAxis(axisRef);\n      const axisName = axisDef?.name || axisRef.axisId || \"X Axis\";\n      const lowLabel = axisDef?.lowTag || \"0\";\n      const highLabel = axisDef?.highTag || \"100\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(lowLabel, topLeft.x, bottomRight.y + 16);\n      ctx.textAlign = \"right\";\n      ctx.fillText(highLabel, bottomRight.x, bottomRight.y + 16);\n      ctx.textAlign = \"center\";\n      ctx.fillText(axisName, (topLeft.x + bottomRight.x) / 2, bottomRight.y + 28);\n    }\n\n    // Y axis labels\n    if (axes.y) {\n      const axisRef = axes.y;\n      const axisDef = resolveAxis(axisRef);\n      const axisName = axisDef?.name || axisRef.axisId || \"Y Axis\";\n      const lowLabel = axisDef?.lowTag || \"0\";\n      const highLabel = axisDef?.highTag || \"100\";\n      ctx.textAlign = \"right\";\n      ctx.fillText(lowLabel, topLeft.x - 6, bottomRight.y);\n      ctx.fillText(highLabel, topLeft.x - 6, topLeft.y + 4);\n\n      // Rotated Y axis name\n      ctx.save();\n      ctx.translate(topLeft.x - 28, (topLeft.y + bottomRight.y) / 2);\n      ctx.rotate(-Math.PI / 2);\n      ctx.textAlign = \"center\";\n      ctx.fillText(axisName, 0, 0);\n      ctx.restore();\n    }\n  }, [\n    plane,\n    regions,\n    entities,\n    cultures,\n    axisDefinitions,\n    selectedEntityId,\n    selectedRegionId,\n    size,\n    camera,\n    baseScale,\n    worldToCanvas,\n    renderTrigger,\n  ]);\n\n  // Find entity at canvas position\n  const findEntityAt = (cx, cy) => {\n    for (const entity of entities) {\n      if (!entity.coordinates) continue;\n      const { x: ex, y: ey } = worldToCanvas(entity.coordinates.x, entity.coordinates.y);\n      const dist = Math.sqrt((cx - ex) ** 2 + (cy - ey) ** 2);\n      if (dist < 12) return entity;\n    }\n    return null;\n  };\n\n  // Find region at canvas position (checks if click is within region bounds)\n  const findRegionAt = (cx, cy) => {\n    const scale = baseScale * camera.zoom;\n    // Check in reverse order so topmost (last drawn) regions are found first\n    for (let i = regions.length - 1; i >= 0; i--) {\n      const region = regions[i];\n      const bounds = region.bounds;\n      if (!bounds) continue;\n\n      if (bounds.shape === \"circle\" && bounds.center) {\n        const { x: rx, y: ry } = worldToCanvas(bounds.center.x, bounds.center.y);\n        const radius = (bounds.radius || 10) * scale;\n        const dist = Math.sqrt((cx - rx) ** 2 + (cy - ry) ** 2);\n        if (dist < radius) return region;\n      }\n    }\n    return null;\n  };\n\n  // Check if clicking on the edge of the selected region (for resizing)\n  const findRegionEdgeAt = (cx, cy) => {\n    if (!selectedRegionId) return null;\n\n    const region = regions.find((r) => r.id === selectedRegionId);\n    if (!region?.bounds?.center) return null;\n\n    const scale = baseScale * camera.zoom;\n    const { x: rx, y: ry } = worldToCanvas(region.bounds.center.x, region.bounds.center.y);\n    const radius = (region.bounds.radius || 10) * scale;\n\n    // Distance from click to center\n    const distToCenter = Math.sqrt((cx - rx) ** 2 + (cy - ry) ** 2);\n\n    // Check if near the edge (within 8px tolerance of the circle edge)\n    const edgeTolerance = 8;\n    if (Math.abs(distToCenter - radius) < edgeTolerance) {\n      return region;\n    }\n\n    return null;\n// ... (truncated)", "parameters": [{"name": "{\n  plane,\n  regions = [],\n  entities = [],\n  cultures = [],\n  axisDefinitions = [],\n  selectedEntityId,\n  selectedRegionId,\n  onSelectEntity,\n  onSelectRegion,\n  onMoveEntity,\n  onMoveRegion,\n  onResizeRegion,\n}", "type": "{ plane: any; regions?: any[]; entities?: any[]; cultures?: any[]; axisDefinitions?: any[]; selectedEntityId: any; selectedRegionId: any; onSelectEntity: any; onSelectRegion: any; onMoveEntity: any; onMoveRegion: any; onResizeRegion: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}]