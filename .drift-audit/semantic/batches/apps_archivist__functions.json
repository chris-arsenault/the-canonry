[{"id": "apps/archivist/webui/src/ArchivistRemote.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/ArchivistRemote.tsx", "sourceCode": "export default function ArchivistRemote({\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n}: Readonly<ArchivistRemoteProps>) {\n  const [worldDataState, setWorldDataState] = useState<WorldState | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [loadError, setLoadError] = useState<string | null>(null);\n\n  const effectiveWorldData = projectId ? worldDataState : null;\n  const effectiveLoading = projectId ? loading : false;\n  const effectiveLoadError = projectId ? loadError : null;\n  const schemaIssues = useMemo(\n    () => (effectiveWorldData ? validateWorldData(effectiveWorldData) : []),\n    [effectiveWorldData]\n  );\n\n  useEffect(() => {\n    if (!projectId) return;\n\n    let cancelled = false;\n    queueMicrotask(() => {\n      if (cancelled) return;\n      setLoading(true);\n      setLoadError(null);\n    });\n\n    buildWorldStateForSlot(projectId, activeSlotIndex)\n      .then((loaded) => {\n        if (cancelled) return;\n        setWorldDataState(loaded);\n      })\n      .catch((err: unknown) => {\n        if (cancelled) return;\n        console.error(\"[ArchivistRemote] Failed to load world data:\", err);\n        setWorldDataState(null);\n        setLoadError(err instanceof Error ? err.message : \"Failed to load world data from Dexie.\");\n      })\n      .finally(() => {\n        if (cancelled) return;\n        setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [activeSlotIndex, dexieSeededAt, projectId]);\n\n  if (effectiveLoading) {\n    return (\n      <div className=\"archivist-empty-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u23f3</div>\n          <div className=\"archivist-state-title\">Loading World Data</div>\n          <div className=\"archivist-state-message\">Reading from local storage\u2026</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (effectiveLoadError) {\n    return (\n      <div className=\"archivist-error-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u274c</div>\n          <div className=\"archivist-state-title\">World data unavailable</div>\n          <div className=\"archivist-state-message\">{effectiveLoadError}</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!effectiveWorldData) {\n    return (\n      <div className=\"archivist-empty-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\ud83d\udcdc</div>\n          <div className=\"archivist-state-title\">No World Data</div>\n          <div className=\"archivist-state-message\">\n            Run a simulation in Lore Weave and click &quot;View in Archivist&quot; to explore your world.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (schemaIssues.length > 0) {\n    return (\n      <div className=\"archivist-error-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u274c</div>\n          <div className=\"archivist-state-title\">World data is missing required schema fields</div>\n          <ul className=\"archivist-state-list\">\n            {schemaIssues.map((issue, index) => (\n              <li key={`${issue}-${index}`}>{issue}</li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    );\n  }\n\n  return <WorldExplorer worldData={effectiveWorldData} loreData={null} />;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n}", "type": "Readonly<ArchivistRemoteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/ChainLinkSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/ChainLinkSection.tsx", "sourceCode": "export default function ChainLinkSection({ lore }: Readonly<ChainLinkSectionProps>) {\n  // Parse the text which is formatted as \"observation | clue\"\n  const parts = lore.text.split(\"|\").map((p) => p.trim());\n  const observation = parts[0] || \"\";\n  const clue = parts[1] || \"\";\n\n  return (\n    <div className=\"chain-link-section\">\n      <div className=\"chain-link-header\">\n        <span className=\"chain-link-icon\">\ud83d\udd0d</span>\n        <span className=\"chain-link-title\">Mystery Clue</span>\n      </div>\n\n      <div className=\"chain-link-flow\">\n        <span className=\"chain-link-location\">{lore.metadata.sourceLocation}</span>\n        <span className=\"chain-link-arrow\">\u2192</span>\n        <span className=\"chain-link-location\">{lore.targetId}</span>\n      </div>\n\n      <div className=\"chain-link-theme\">\n        <span className=\"chain-link-theme-label\">Theme:</span>\n        <span className=\"chain-link-theme-badge\">\n          {lore.metadata.revealedTheme.replace(/_/g, \" \")}\n        </span>\n      </div>\n\n      <div className=\"chain-link-content\">\n        <div className=\"chain-link-observation\">\n          <div className=\"chain-link-section-label\">Observation</div>\n          <div className=\"chain-link-text\">{observation}</div>\n        </div>\n        <div className=\"chain-link-clue\">\n          <div className=\"chain-link-section-label\">Clue</div>\n          <div className=\"chain-link-text\">{clue}</div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore }", "type": "Readonly<ChainLinkSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/CoordinateMapView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/CoordinateMapView.tsx", "sourceCode": "export default function CoordinateMapView({\n  data,\n  selectedNodeId,\n  onNodeSelect\n}: Readonly<CoordinateMapViewProps>) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({\n    width: 800,\n    height: 600\n  });\n  const [mapKind, setMapKind] = useState<string>(() => {\n    const firstKind = data.schema.entityKinds.find(kind => kind.semanticPlane)?.kind;\n    return firstKind ?? \"\";\n  }); // Which entity kind's map to show\n  const [showRelatedKinds, setShowRelatedKinds] = useState<boolean>(true); // Show related entities from other kinds\n  const [visibleLayers, setVisibleLayers] = useState<Set<string>>(new Set([\"regions\", \"entities\", \"relationships\"]));\n  const [hoveredEntity, setHoveredEntity] = useState<HardState | null>(null);\n  const [hoveredRegion, setHoveredRegion] = useState<Region | null>(null);\n  const [mousePos, setMousePos] = useState<{\n    x: number;\n    y: number;\n  } | null>(null);\n\n  // Get entity kind schemas\n  const entityKindSchemas = data.schema.entityKinds;\n  const kindDisplayNames = useMemo(() => {\n    return new Map(entityKindSchemas.map(kind => [kind.kind, getKindDisplayName(kind)]));\n  }, [entityKindSchemas]);\n  const axisDefinitions = useMemo(() => data.schema.axisDefinitions || [], [data.schema.axisDefinitions]);\n  const axisById = useMemo(() => {\n    return new Map(axisDefinitions.map(axis => [axis.id, axis]));\n  }, [axisDefinitions]);\n  const mappableKindSchemas = useMemo(() => entityKindSchemas.filter(kind => kind.semanticPlane), [entityKindSchemas]);\n  const mappableKinds = mappableKindSchemas.map(kind => kind.kind);\n\n  // Derive effective map kind: if current selection is invalid, fall back to first available\n  const effectiveMapKind = mappableKinds.includes(mapKind) ? mapKind : mappableKinds[0] ?? mapKind;\n\n  // Get per-kind map config and regions (seed + emergent)\n  const activeKindDef = mappableKindSchemas.find(kind => kind.kind === effectiveMapKind);\n  if (!activeKindDef || !activeKindDef.semanticPlane) {\n    throw new Error(\"Archivist: map view requires a semantic plane on the selected entity kind.\");\n  }\n  const displayName = getKindDisplayName(activeKindDef);\n  const planeAxes = activeKindDef.semanticPlane.axes;\n  const xAxis = planeAxes?.x?.axisId ? axisById.get(planeAxes.x.axisId) : undefined;\n  const yAxis = planeAxes?.y?.axisId ? axisById.get(planeAxes.y.axisId) : undefined;\n  if (planeAxes?.x?.axisId && !xAxis) {\n    throw new Error(`Archivist: axis \"${planeAxes.x.axisId}\" not found in schema.axisDefinitions.`);\n  }\n  if (planeAxes?.y?.axisId && !yAxis) {\n    throw new Error(`Archivist: axis \"${planeAxes.y.axisId}\" not found in schema.axisDefinitions.`);\n  }\n  const mapDescription = `Coordinate space for ${displayName} entities`;\n  const seedRegions = activeKindDef.semanticPlane.regions ?? [];\n  const emergentRegions = data.coordinateState?.emergentRegions?.[effectiveMapKind] ?? [];\n  const regions = mergeRegions(seedRegions, emergentRegions);\n  const bounds = {\n    min: 0,\n    max: 100\n  };\n\n  // Filter entities for the current map - primary kind always shown, related kinds optionally\n  const mapEntities = useMemo(() => {\n    const primaryEntities = data.hardState.filter(e => e.kind === effectiveMapKind);\n    if (!showRelatedKinds) {\n      return primaryEntities;\n    }\n\n    // Find entities related to primary entities\n    const primaryIds = new Set(primaryEntities.map(e => e.id));\n    const relatedIds = new Set<string>();\n    data.relationships.forEach(rel => {\n      if (primaryIds.has(rel.src)) relatedIds.add(rel.dst);\n      if (primaryIds.has(rel.dst)) relatedIds.add(rel.src);\n    });\n    const relatedEntities = data.hardState.filter(e => relatedIds.has(e.id) && !primaryIds.has(e.id));\n    return [...primaryEntities, ...relatedEntities];\n  }, [data.hardState, data.relationships, effectiveMapKind, showRelatedKinds]);\n\n  // Build entity color map\n  const entityColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    entityKindSchemas.forEach(ek => {\n      if (!ek.style?.color) {\n        throw new Error(`Archivist: entity kind \"${ek.kind}\" is missing style.color.`);\n      }\n      map.set(ek.kind, ek.style.color);\n    });\n    return map;\n  }, [entityKindSchemas]);\n\n  // Calculate entity positions with force layout\n  const entityPositions = useMemo(() => {\n    const nodes: LayoutNode[] = [];\n\n    // All entities get coordinates\n    mapEntities.forEach(entity => {\n      const coords = getEntityCoords(entity);\n      nodes.push({\n        id: entity.id,\n        x: coords.x,\n        y: coords.y,\n        vx: 0,\n        vy: 0,\n        // Only anchor primary kind entities\n        anchored: entity.kind === effectiveMapKind,\n        entity\n      });\n    });\n\n    // Run force layout - only include relationships between visible entities\n    const visibleIds = new Set(mapEntities.map(e => e.id));\n    const relationships = data.relationships.filter(r => visibleIds.has(r.src) && visibleIds.has(r.dst)).map(r => ({\n      src: r.src,\n      dst: r.dst,\n      strength: r.strength\n    }));\n    runForceLayout(nodes, relationships);\n    return new Map(nodes.map(n => [n.id, {\n      x: n.x,\n      y: n.y,\n      anchored: n.anchored\n    }]));\n  }, [mapEntities, data.relationships, effectiveMapKind]);\n\n  // Use uniform scale to preserve aspect ratio (circles stay circular)\n  const padding = 40;\n  const worldRange = bounds.max - bounds.min || 1; // Prevent division by zero\n  const availableWidth = Math.max(1, dimensions.width - padding * 2);\n  const availableHeight = Math.max(1, dimensions.height - padding * 2);\n  // Use the smaller scale so everything fits\n  const uniformScale = Math.max(0.001, Math.min(availableWidth, availableHeight) / worldRange);\n  // Center the content in the larger dimension\n  const offsetX = padding + (availableWidth - worldRange * uniformScale) / 2;\n  const offsetY = padding + (availableHeight - worldRange * uniformScale) / 2;\n\n  // Convert world coordinates to canvas coordinates\n  const worldToCanvas = (x: number, y: number): {\n    x: number;\n    y: number;\n  } => {\n    return {\n      x: offsetX + (x - bounds.min) * uniformScale,\n      y: dimensions.height - offsetY - (y - bounds.min) * uniformScale // Flip Y for canvas\n    };\n  };\n\n  // Convert canvas coordinates to world coordinates\n  const canvasToWorld = (canvasX: number, canvasY: number): {\n    x: number;\n    y: number;\n  } => {\n    return {\n      x: bounds.min + (canvasX - offsetX) / uniformScale,\n      y: bounds.min + (dimensions.height - offsetY - canvasY) / uniformScale\n    };\n  };\n\n  // Convert world distance to canvas pixels (for radius calculations)\n  const worldToCanvasDistance = (worldDistance: number): number => {\n    return worldDistance * uniformScale;\n  };\n\n  // Handle resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        setDimensions({\n          width: containerRef.current.clientWidth,\n          height: containerRef.current.clientHeight\n        });\n      }\n    };\n    updateDimensions();\n    window.addEventListener(\"resize\", updateDimensions);\n    return () => window.removeEventListener(\"resize\", updateDimensions);\n  }, []);\n\n  // Draw the map\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.fillStyle = \"#0a1929\";\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw grid\n    ctx.strokeStyle = \"rgba(59, 130, 246, 0.1)\";\n    ctx.lineWidth = 1;\n    const gridStep = 10;\n    for (let i = bounds.min; i <= bounds.max; i += gridStep) {\n      const start = worldToCanvas(i, bounds.min);\n      const end = worldToCanvas(i, bounds.max);\n      ctx.beginPath();\n      ctx.moveTo(start.x, start.y);\n      ctx.lineTo(end.x, end.y);\n      ctx.stroke();\n      const hStart = worldToCanvas(bounds.min, i);\n      const hEnd = worldToCanvas(bounds.max, i);\n      ctx.beginPath();\n      ctx.moveTo(hStart.x, hStart.y);\n      ctx.lineTo(hEnd.x, hEnd.y);\n      ctx.stroke();\n    }\n\n    // Draw axis labels - semantic tags at ends, numeric in middle\n    // Draw semantic axis labels at ends\n    ctx.font = \"bold 11px sans-serif\";\n    ctx.textAlign = \"center\";\n\n    // X-axis labels (low on left, high on right)\n    if (xAxis) {\n      // Low tag (left side)\n      ctx.fillStyle = \"rgba(252, 107, 107, 0.8)\"; // Reddish for low\n      const xLowPos = worldToCanvas(bounds.min + 5, bounds.min);\n      ctx.fillText(`\u2190 ${xAxis.lowTag}`, xLowPos.x + 30, xLowPos.y + 25);\n\n      // Axis name (center bottom)\n      ctx.fillStyle = \"rgba(255, 255, 255, 0.6)\";\n      const xCenterPos = worldToCanvas((bounds.min + bounds.max) / 2, bounds.min);\n      ctx.fillText(xAxis.name, xCenterPos.x, xCenterPos.y + 25);\n\n      // High tag (right side)\n      ctx.fillStyle = \"rgba(107, 252, 156, 0.8)\"; // Greenish for high\n      const xHighPos = worldToCanvas(bounds.max - 5, bounds.min);\n      ctx.fillText(`${xAxis.highTag} \u2192`, xHighPos.x - 30, xHighPos.y + 25);\n    }\n\n    // Y-axis labels (low on bottom, high on top)\n    if (yAxis) {\n      ctx.save();\n\n      // Low tag (bottom)\n      ctx.fillStyle = \"rgba(252, 107, 107, 0.8)\";\n      const yLowPos = worldToCanvas(bounds.min, bounds.min + 5);\n      ctx.translate(yLowPos.x - 25, yLowPos.y - 20);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(`\u2190 ${yAxis.lowTag}`, 0, 0);\n      ctx.restore();\n\n      // Axis name (center left)\n      ctx.save();\n      ctx.fillStyle = \"rgba(255, 255, 255, 0.6)\";\n      const yCenterPos = worldToCanvas(bounds.min, (bounds.min + bounds.max) / 2);\n      ctx.translate(yCenterPos.x - 25, yCenterPos.y);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(yAxis.name, 0, 0);\n      ctx.restore();\n\n      // High tag (top)\n      ctx.save();\n      ctx.fillStyle = \"rgba(107, 252, 156, 0.8)\";\n      const yHighPos = worldToCanvas(bounds.min, bounds.max - 5);\n      ctx.translate(yHighPos.x - 25, yHighPos.y + 20);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(`${yAxis.highTag} \u2192`, 0, 0);\n      ctx.restore();\n    }\n\n    // Draw small numeric labels for reference\n    ctx.fillStyle = \"rgba(59, 130, 246, 0.3)\";\n    ctx.font = \"9px monospace\";\n    ctx.textAlign = \"center\";\n    for (let i = bounds.min + 20; i < bounds.max; i += 20) {\n      const pos = worldToCanvas(i, bounds.min);\n      ctx.fillText(i.toString(), pos.x, pos.y + 12);\n      ctx.textAlign = \"right\";\n      const posY = worldToCanvas(bounds.min, i);\n      ctx.fillText(i.toString(), posY.x - 5, posY.y + 3);\n      ctx.textAlign = \"center\";\n    }\n\n    // Parse selectedNodeId to check if a region is selected\n    const selectedRegionId = selectedNodeId?.startsWith(\"region:\") ? selectedNodeId.split(\":\")[2] : null;\n\n    // Draw regions if layer is visible\n    if (visibleLayers.has(\"regions\")) {\n      regions.forEach(region => {\n        drawRegion(ctx, region, hoveredRegion, selectedRegionId, worldToCanvas, worldToCanvasDistance);\n      });\n    }\n\n    // Draw relationships if layer is visible\n    if (visibleLayers.has(\"relationships\")) {\n      ctx.strokeStyle = \"rgba(255, 255, 255, 0.15)\";\n      ctx.lineWidth = 1;\n      data.relationships.forEach(rel => {\n        const srcPos = entityPositions.get(rel.src);\n        const dstPos = entityPositions.get(rel.dst);\n        if (!srcPos || !dstPos) return;\n        const start = worldToCanvas(srcPos.x, srcPos.y);\n        const end = worldToCanvas(dstPos.x, dstPos.y);\n        ctx.globalAlpha = (rel.strength ?? 0.5) * 0.5;\n        ctx.beginPath();\n        ctx.moveTo(start.x, start.y);\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect\n}", "type": "Readonly<CoordinateMapViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/DiscoveryStory.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/DiscoveryStory.tsx", "sourceCode": "export default function DiscoveryStory({\n  lore,\n  onExplorerClick,\n  onClose,\n  isModal = false,\n}: Readonly<DiscoveryStoryProps>) {\n  const [expandedSection, setExpandedSection] = useState<\"discovery\" | \"significance\" | null>(\n    \"discovery\"\n  );\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose?.();\n    }\n  };\n\n  const toggleSection = (section: \"discovery\" | \"significance\") => {\n    setExpandedSection(expandedSection === section ? null : section);\n  };\n\n  // Check if explorer is an entity ID (starts with known prefixes)\n  const isEntityId = lore.metadata.explorer.match(/^(npc_|faction_|location_)/);\n\n  const content = (\n    <div className={`discovery-story ${isModal ? \"discovery-story-modal-content\" : \"\"}`}>\n      <div className=\"discovery-story-header\">\n        <span className=\"discovery-story-icon\">\ud83e\udded</span>\n        <span className=\"discovery-story-title\">Discovery Story</span>\n      </div>\n\n      <div className=\"discovery-story-meta\">\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">Discovered by:</span>\n          {isEntityId && onExplorerClick ? (\n            <button\n              onClick={() => onExplorerClick(lore.metadata.explorer)}\n              className=\"discovery-story-explorer-link\"\n            >\n              {lore.metadata.explorer}\n            </button>\n          ) : (\n            <span className=\"discovery-story-meta-value\">{lore.metadata.explorer}</span>\n          )}\n        </div>\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">When:</span>\n          <span className=\"discovery-story-meta-value\">Tick {lore.metadata.tick}</span>\n        </div>\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">Method:</span>\n          <span\n            className={`discovery-story-type-badge discovery-story-type-${lore.metadata.discoveryType}`}\n          >\n            {lore.metadata.discoveryType}\n          </span>\n        </div>\n      </div>\n\n      {/* The Discovery */}\n      <div className=\"discovery-story-section\">\n        <button\n          onClick={() => toggleSection(\"discovery\")}\n          className=\"discovery-story-section-header\"\n        >\n          <span className=\"discovery-story-section-icon\">\n            {expandedSection === \"discovery\" ? \"\u25bc\" : \"\u25b6\"}\n          </span>\n          <span className=\"discovery-story-section-title\">The Discovery</span>\n        </button>\n        {expandedSection === \"discovery\" && (\n          <div className=\"discovery-story-section-content\">{lore.text}</div>\n        )}\n      </div>\n\n      {/* Why It Matters */}\n      <div className=\"discovery-story-section\">\n        <button\n          onClick={() => toggleSection(\"significance\")}\n          className=\"discovery-story-section-header\"\n        >\n          <span className=\"discovery-story-section-icon\">\n            {expandedSection === \"significance\" ? \"\u25bc\" : \"\u25b6\"}\n          </span>\n          <span className=\"discovery-story-section-title\">Why It Matters</span>\n        </button>\n        {expandedSection === \"significance\" && (\n          <div className=\"discovery-story-section-content\">{lore.metadata.significance}</div>\n        )}\n      </div>\n\n      {/* Close button for modal mode */}\n      {isModal && onClose && (\n        <div className=\"discovery-story-footer\">\n          <button onClick={onClose} className=\"discovery-story-close\">\n            Close\n          </button>\n        </div>\n      )}\n    </div>\n  );\n\n  // Wrap in modal overlay if in modal mode\n  if (isModal && onClose) {\n    return (\n      <div\n        className=\"discovery-story-overlay\"\n        onMouseDown={handleOverlayMouseDown}\n        onClick={handleOverlayClick}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n      >\n        <div>{content}</div>\n      </div>\n    );\n  }\n\n  return content;\n}", "parameters": [{"name": "{\n  lore,\n  onExplorerClick,\n  onClose,\n  isModal = false,\n}", "type": "Readonly<DiscoveryStoryProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/EntityDetail.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/EntityDetail.tsx", "sourceCode": "export default function EntityDetail({\n  entityId,\n  worldData,\n  loreData,\n  onRelatedClick,\n  prominenceScale,\n}: Readonly<EntityDetailProps>) {\n  // Hooks must be called before any early returns\n  const [selectedRelationshipLore, setSelectedRelationshipLore] =\n    useState<RelationshipBackstoryLore | null>(null);\n  const clearRelationshipLore = useCallback(() => setSelectedRelationshipLore(null), []);\n  const [expandedOutgoing, setExpandedOutgoing] = useState<Set<string>>(new Set());\n  const [expandedIncoming, setExpandedIncoming] = useState<Set<string>>(new Set());\n\n  // Look up entity to get imageId for the hook (must be before early returns)\n  const selection = entityId ? parseSelectionId(entityId) : null;\n  const entityForImage =\n    selection?.type === \"entity\" ? getEntityById(worldData, selection.id) : null;\n  const imageId = entityForImage?.enrichment?.image?.imageId;\n  const { url: imageUrl } = useImageUrl(imageId);\n\n  if (!entityId) {\n    return (\n      <div className=\"entity-detail empty\">\n        <div className=\"text-center\">\n          <div\n            className=\"text-5xl mb-4 ed-empty-icon\"\n          >\n            \ud83d\udc48\n          </div>\n          <div className=\"text-blue-300 font-medium\">Select a node to view details</div>\n        </div>\n      </div>\n    );\n  }\n\n  // selection is guaranteed non-null here because entityId is truthy\n  const sel = selection!;\n\n  if (sel.type === \"region\") {\n    const region = findRegion(worldData, sel.entityKind, sel.regionId);\n    if (!region) {\n      return (\n        <div className=\"entity-detail\">\n          <div className=\"text-red-400 font-medium\">Region not found</div>\n        </div>\n      );\n    }\n    return <RegionDetail region={region} entityKind={sel.entityKind} worldData={worldData} />;\n  }\n\n  const entity = getEntityById(worldData, sel.id);\n\n  if (!entity) {\n    return (\n      <div className=\"entity-detail\">\n        <div className=\"text-red-400 font-medium\">Entity not found</div>\n      </div>\n    );\n  }\n\n  const prominenceLabel = prominenceLabelFromScale(entity.prominence, prominenceScale);\n\n  const relatedEntities = getRelatedEntities(worldData, entityId);\n  const relationships = getRelationships(worldData, entityId);\n\n  // Look up culture info\n  const entityCulture = entity.culture\n    ? worldData.schema.cultures.find((c) => c.id === entity.culture)\n    : undefined;\n\n  // Find lore for this entity\n  const descriptionLore = loreData?.records.find(\n    (record) => record.type === \"description\" && record.targetId === entityId\n  ) as DescriptionLore | undefined;\n\n  const chainLinkLore = loreData?.records.find(\n    (record) => record.type === \"chain_link\" && record.targetId === entityId\n  ) as ChainLinkLore | undefined;\n\n  const discoveryEventLore = loreData?.records.find(\n    (record) => record.type === \"discovery_event\" && record.targetId === entityId\n  ) as DiscoveryEventLore | undefined;\n\n  // Image URL loaded via useImageUrl hook (called above, before early returns)\n\n  // Helper to find relationship lore\n  const findRelationshipLore = (\n    srcId: string,\n    dstId: string,\n    kind: string\n  ): RelationshipBackstoryLore | undefined => {\n    return loreData?.records.find((record) => {\n      if (record.type !== \"relationship_backstory\") return false;\n      const relLore = record;\n      return (\n        relLore.relationship.src === srcId &&\n        relLore.relationship.dst === dstId &&\n        relLore.relationship.kind === kind\n      );\n    }) as RelationshipBackstoryLore | undefined;\n  };\n\n  const outgoingRels = relationships.filter((r) => r.src === entityId);\n  const incomingRels = relationships.filter((r) => r.dst === entityId);\n\n  // Debug: Check if distance is present\n  const relsWithDistance = relationships.filter((r) => r.distance !== undefined);\n  if (relsWithDistance.length > 0) {\n    console.log(\n      `Entity ${entityId} has ${relsWithDistance.length} relationships with distance:`,\n      relsWithDistance[0]\n    );\n  }\n\n  const getRelatedEntity = (relId: string) => getEntityById(worldData, relId);\n\n  // Group relationships by kind\n  const groupByKind = (rels: typeof relationships) => {\n    const groups = new Map<string, typeof relationships>();\n    rels.forEach((rel) => {\n      const kind = rel.kind;\n      if (!groups.has(kind)) {\n        groups.set(kind, []);\n      }\n      groups.get(kind)!.push(rel);\n    });\n    return groups;\n  };\n\n  const outgoingGroups = groupByKind(outgoingRels);\n  const incomingGroups = groupByKind(incomingRels);\n\n  const toggleOutgoing = (kind: string) => {\n    const newExpanded = new Set(expandedOutgoing);\n    if (newExpanded.has(kind)) {\n      newExpanded.delete(kind);\n    } else {\n      newExpanded.add(kind);\n    }\n    setExpandedOutgoing(newExpanded);\n  };\n\n  const toggleIncoming = (kind: string) => {\n    const newExpanded = new Set(expandedIncoming);\n    if (newExpanded.has(kind)) {\n      newExpanded.delete(kind);\n    } else {\n      newExpanded.add(kind);\n    }\n    setExpandedIncoming(newExpanded);\n  };\n\n  return (\n    <div className=\"entity-detail\">\n      {/* Header */}\n      <div className=\"entity-detail-header\">\n        <h2 className=\"entity-detail-name\">{entity.name}</h2>\n        <div className=\"entity-detail-badges\">\n          <span className={`entity-badge prominence-${prominenceLabel}`}>{prominenceLabel}</span>\n          <span className=\"entity-badge entity-badge-kind\">{entity.kind}</span>\n          <span className=\"entity-badge entity-badge-subtype\">{entity.subtype}</span>\n          {entityCulture && (\n            <span\n              className=\"entity-badge entity-badge-culture ed-culture-badge\"\n              style={{ '--ed-culture-color': entityCulture.color } as React.CSSProperties}\n            >\n              {entityCulture.name}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Entity Image */}\n      {imageUrl && (\n        <div className=\"mb-6\">\n          <div className=\"entity-image-container\">\n            <img src={imageUrl} alt={entity.name} className=\"entity-image\" loading=\"lazy\" />\n          </div>\n        </div>\n      )}\n\n      {/* Summary or Lore */}\n      {descriptionLore ? (\n        <LoreSection lore={descriptionLore} />\n      ) : (\n        <div className=\"detail-card\">\n          <div className=\"section-header\">\n            Summary\n            <button\n              onClick={() => {\n                window.dispatchEvent(\n                  new CustomEvent(\"canonry:navigate\", {\n                    detail: { tab: \"chronicler\", pageId: entity.id },\n                  })\n                );\n              }}\n              className=\"chronicler-link\"\n              title=\"View full article in Chronicler\"\n            >\n              (view in chronicler)\n            </button>\n          </div>\n          <p className=\"text-sm text-blue-100 leading-relaxed break-words detail-card-content\">\n            {entity.summary || \"No summary available\"}\n          </p>\n        </div>\n      )}\n\n      {/* Chain Link */}\n      {chainLinkLore && <ChainLinkSection lore={chainLinkLore} />}\n\n      {/* Discovery Story */}\n      {discoveryEventLore && (\n        <DiscoveryStory lore={discoveryEventLore} onExplorerClick={onRelatedClick} />\n      )}\n\n      {/* Status & Timeline */}\n      <div className=\"entity-meta-grid\">\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Status</span>\n          <span className=\"entity-meta-value\">{entity.status}</span>\n        </div>\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Created</span>\n          <span className=\"entity-meta-value\">Tick {entity.createdAt}</span>\n        </div>\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Updated</span>\n          <span className=\"entity-meta-value\">Tick {entity.updatedAt}</span>\n        </div>\n      </div>\n\n      {/* Tags */}\n      {getTagsArray(entity.tags).length > 0 && (\n        <div className=\"entity-tags-section\">\n          <div className=\"section-header\">Tags</div>\n          <div className=\"tags-container\">\n            {getTagsArray(entity.tags).map((tag) => (\n              <span key={tag} className=\"tag\">\n                {tag}\n              </span>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Outgoing Relationships */}\n      {outgoingRels.length > 0 && (\n        <div className=\"mb-6\">\n          <div className=\"section-header\">Relationships ({outgoingRels.length})</div>\n          <div className=\"accordion-container\">\n            {Array.from(outgoingGroups.entries()).map(([kind, rels]) => {\n              const isExpanded = expandedOutgoing.has(kind);\n              return (\n                <div key={kind} className=\"accordion-item\">\n                  <button onClick={() => toggleOutgoing(kind)} className=\"accordion-header\">\n                    <div className=\"accordion-header-left\">\n                      <span className=\"accordion-icon\">{isExpanded ? \"\u2212\" : \"+\"}</span>\n                      <span className=\"accordion-title\">{kind.replace(/_/g, \" \")}</span>\n                    </div>\n                    <span className=\"accordion-badge\">{rels.length}</span>\n                  </button>\n                  {isExpanded && (\n                    <div className=\"accordion-content\">\n                      {rels.map((rel, i) => {\n                        const target = getRelatedEntity(rel.dst);\n                        const relLore = findRelationshipLore(rel.src, rel.dst, rel.kind);\n                        const strength = rel.strength ?? 0.5;\n                        const distance = rel.distance;\n                        const isHistorical = rel.status === \"historical\";\n                        return target ? (\n                          <div\n                            key={i}\n                            className={`accordion-row ${i % 2 === 0 ? \"even\" : \"odd\"} ${isHistorical ? \"historical\" : \"\"}`}\n                          >\n                            <button\n                              onClick={() => onRelatedClick(target.id)}\n                              className={`accordion-row-button ${isHistorical ? \"ed-row-historical\" : \"\"}`}\n                            >\n                              <div className=\"accordion-row-name\">\n                                {isHistorical && (\n                                  <span className=\"ed-historical-icon\">\n                                    \ud83d\udcdc\n                                  </span>\n                                )}\n                                {target.name}\n                              </div>\n                              <div className=\"accordion-row-kind\">\n                                ({target.kind}){\" \"}\n                                <span\n                                  className={isHistorical ? \"ed-rel-metric-historical\" : \"ed-rel-metric\"}\n                                >\n                                  [S:{strength.toFixed(2)}\n                                  {distance !== undefined ? ` D:${distance.toFixed(2)}` : \"\"}]\n                                </span>\n                                {isHistorical && rel.archivedAt && (\n                                  <span className=\"ed-archived-label\">\n                                    archived @{rel.archivedAt}\n                                  </span>\n// ... (truncated)", "parameters": [{"name": "{\n  entityId,\n  worldData,\n  loreData,\n  onRelatedClick,\n  prominenceScale,\n}", "type": "Readonly<EntityDetailProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/EraNarrative.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/EraNarrative.tsx", "sourceCode": "export default function EraNarrative({ lore, onClose }: Readonly<EraNarrativeProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n  // Extract title from the text (first sentence or before colon)\n  const titleMatch = lore.text.match(/^([^:.]+)[:.]/) || lore.text.match(/^(.{0,50})/);\n  const title = titleMatch ? titleMatch[1].trim() : \"Era Transition\";\n  const narrative = lore.text;\n\n  return (\n    <div\n      className=\"era-narrative-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"era-narrative-modal\">\n        <div className=\"era-narrative-header\">\n          <div className=\"era-narrative-icon\">\u2694\ufe0f</div>\n          <h2 className=\"era-narrative-title\">{title}</h2>\n          <div className=\"era-narrative-icon\">\u2694\ufe0f</div>\n        </div>\n\n        <div className=\"era-narrative-transition\">\n          <span className=\"era-narrative-era era-narrative-era-from\">{lore.metadata.from}</span>\n          <span className=\"era-narrative-arrow\">\u2192</span>\n          <span className=\"era-narrative-era era-narrative-era-to\">{lore.metadata.to}</span>\n        </div>\n\n        <div className=\"era-narrative-content\">{narrative}</div>\n\n        <div className=\"era-narrative-footer\">\n          <span className=\"era-narrative-tick\">Tick {lore.metadata.tick}</span>\n          <button onClick={onClose} className=\"era-narrative-close\">\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore, onClose }", "type": "Readonly<EraNarrativeProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/FilterPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/FilterPanel.tsx", "sourceCode": "export default function FilterPanel({\n  filters,\n  onChange,\n  worldData,\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}: Readonly<FilterPanelProps>) {\n  const allTags = getAllTags(worldData);\n  const relationshipTypeCounts = getRelationshipTypeCounts(worldData);\n  const maxTick = worldData.metadata.tick;\n\n  const allRelationshipTypes = worldData.schema.relationshipKinds.map((rel) => rel.kind);\n  // Sort relationship types by count (descending)\n  const sortedRelationshipTypes = [...allRelationshipTypes].sort((a, b) => {\n    return (relationshipTypeCounts[b] || 0) - (relationshipTypeCounts[a] || 0);\n  });\n\n  const [isRelTypesExpanded, setIsRelTypesExpanded] = useState(false);\n\n  const entityKindSchemas = worldData.schema.entityKinds;\n  const entityKinds: EntityKind[] = entityKindSchemas.map((ek) => ek.kind);\n\n  const prominenceLevels: Prominence[] = getProminenceLevels(worldData.schema);\n\n  // Build a map from kind to display name (from schema if available, otherwise use kind as-is)\n  const kindDisplayNames = Object.fromEntries(\n    entityKindSchemas.map((ek) => [ek.kind, ek.style?.displayName || ek.description || ek.kind])\n  );\n\n  const toggleKind = (kind: EntityKind) => {\n    const kinds = filters.kinds.includes(kind)\n      ? filters.kinds.filter((k) => k !== kind)\n      : [...filters.kinds, kind];\n    onChange({ ...filters, kinds });\n  };\n\n  const toggleTag = (tag: string) => {\n    const tags = filters.tags.includes(tag)\n      ? filters.tags.filter((t) => t !== tag)\n      : [...filters.tags, tag];\n    onChange({ ...filters, tags });\n  };\n\n  const toggleRelationshipType = (type: string) => {\n    let relationshipTypes: string[];\n\n    if (filters.relationshipTypes.length === 0) {\n      // Currently showing all - user wants to filter to ONLY this type\n      relationshipTypes = [type];\n    } else if (filters.relationshipTypes.includes(type)) {\n      // Type is selected, uncheck it\n      relationshipTypes = filters.relationshipTypes.filter((t) => t !== type);\n      // If nothing left selected, go back to showing all\n      // (empty array = no filter = show all)\n    } else {\n      // Type not selected, add it\n      relationshipTypes = [...filters.relationshipTypes, type];\n    }\n\n    onChange({ ...filters, relationshipTypes });\n  };\n\n  return (\n    <div className=\"filter-panel\">\n      {/* View Controls */}\n      <div className=\"view-controls\">\n        <div className=\"view-mode-buttons\">\n          <button\n            className={`view-mode-btn ${viewMode === \"graph3d\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"graph3d\")}\n            title=\"3D Graph View\"\n          >\n            3D\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"graph2d\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"graph2d\")}\n            title=\"2D Graph View\"\n          >\n            2D\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"map\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"map\")}\n            title=\"Coordinate Map View\"\n          >\n            Map\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"timeline\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"timeline\")}\n            title=\"Timeline View - Eras along axis\"\n          >\n            Time\n          </button>\n        </div>\n        <div className=\"view-actions\">\n          <button\n            className=\"view-action-btn\"\n            onClick={onRecalculateLayout}\n            title=\"Recalculate Layout\"\n          >\n            \u267b\ufe0f\n          </button>\n          <button className=\"view-action-btn\" onClick={onToggleStats} title=\"Toggle Stats Panel\">\n            \ud83d\udcca\n          </button>\n        </div>\n      </div>\n\n      {/* Edge Metric (for graph views) */}\n      {(viewMode === \"graph3d\" || viewMode === \"graph2d\") && (\n        <div className=\"edge-metric-section\">\n          <span className=\"filter-section-label\">Edge Spring</span>\n          <div className=\"edge-metric-buttons\">\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"strength\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"strength\")}\n            >\n              Strength\n            </button>\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"distance\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"distance\")}\n            >\n              Distance\n            </button>\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"none\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"none\")}\n            >\n              Equal\n            </button>\n          </div>\n        </div>\n      )}\n\n      <div className=\"filter-panel-divider\"></div>\n\n      {/* Search */}\n      <div className=\"filter-section\">\n        <label htmlFor=\"search\" className=\"filter-section-label\">Search</label>\n        <input id=\"search\"\n          type=\"text\"\n          value={filters.searchQuery}\n          onChange={(e) => onChange({ ...filters, searchQuery: e.target.value })}\n          placeholder=\"Search entities...\"\n          className=\"filter-search-input\"\n        />\n      </div>\n\n      {/* Entity Types */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">Entity Types</span>\n        <div className=\"filter-checkbox-group\">\n          {entityKinds.map((kind) => (\n            <label key={kind} className=\"filter-checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={filters.kinds.includes(kind)}\n                onChange={() => toggleKind(kind)}\n              />\n              <span>{kindDisplayNames[kind] ?? kind}</span>\n            </label>\n          ))}\n        </div>\n      </div>\n\n      {/* Relationship Types */}\n      <div className=\"filter-section\">\n        <div className=\"filter-accordion-container\">\n          <button\n            onClick={() => setIsRelTypesExpanded(!isRelTypesExpanded)}\n            className=\"filter-accordion-header\"\n          >\n            <div className=\"filter-accordion-header-left\">\n              <span className=\"filter-accordion-icon\">{isRelTypesExpanded ? \"\u2212\" : \"+\"}</span>\n              <span className=\"filter-accordion-title\">Relationship Types</span>\n            </div>\n            <span className=\"filter-accordion-badge\">\n              {filters.relationshipTypes.length === 0 ? \"All\" : filters.relationshipTypes.length}\n            </span>\n          </button>\n          {isRelTypesExpanded && (\n            <div className=\"filter-accordion-content\">\n              <div className=\"filter-accordion-controls\">\n                <button\n                  onClick={() => onChange({ ...filters, relationshipTypes: [] })}\n                  className=\"filter-accordion-control-btn\"\n                >\n                  Show All\n                </button>\n              </div>\n              {sortedRelationshipTypes.map((type) => {\n                // Empty array = show all (all appear checked)\n                // Non-empty = only selected types are checked\n                const isChecked =\n                  filters.relationshipTypes.length === 0\n                    ? true\n                    : filters.relationshipTypes.includes(type);\n                return (\n                  <label key={type} className=\"filter-checkbox-label\">\n                    <input\n                      type=\"checkbox\"\n                      checked={isChecked}\n                      onChange={() => toggleRelationshipType(type)}\n                    />\n                    <span>\n                      {type.replace(/_/g, \" \")} ({relationshipTypeCounts[type]})\n                    </span>\n                  </label>\n                );\n              })}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Minimum Prominence */}\n      <div className=\"filter-section\">\n        <label htmlFor=\"minimum-prominence\" className=\"filter-section-label\">Minimum Prominence</label>\n        <select id=\"minimum-prominence\"\n          value={filters.minProminence}\n          onChange={(e) => onChange({ ...filters, minProminence: e.target.value as Prominence })}\n          className=\"filter-select\"\n        >\n          {prominenceLevels.map((level) => (\n            <option key={level} value={level}>\n              {level}\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {/* Time Range */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">Time Range</span>\n        <div className=\"time-range-box\">\n          <div className=\"time-range-labels\">\n            <span className=\"time-range-label\">\n              Start: <span className=\"time-range-label-value\">{filters.timeRange[0]}</span>\n            </span>\n            <span className=\"time-range-label\">\n              End: <span className=\"time-range-label-value\">{filters.timeRange[1]}</span>\n            </span>\n          </div>\n          <div className=\"time-range-sliders\">\n            <input\n              type=\"range\"\n              min={0}\n              max={maxTick}\n              value={filters.timeRange[0]}\n              onChange={(e) =>\n                onChange({\n                  ...filters,\n                  timeRange: [parseInt(e.target.value), filters.timeRange[1]],\n                })\n              }\n            />\n            <input\n              type=\"range\"\n              min={0}\n              max={maxTick}\n              value={filters.timeRange[1]}\n              onChange={(e) =>\n                onChange({\n                  ...filters,\n                  timeRange: [filters.timeRange[0], parseInt(e.target.value)],\n                })\n              }\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Tags */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">\n          Tags <span className=\"text-blue-400 font-normal\">({filters.tags.length} selected)</span>\n        </span>\n        <div className=\"tags-box\">\n          {allTags.map((tag) => (\n            <label key={tag} className=\"filter-checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={filters.tags.includes(tag)}\n                onChange={() => toggleTag(tag)}\n              />\n              <span>{tag}</span>\n            </label>\n          ))}\n        </div>\n      </div>\n\n      {/* Minimum Relationship Strength */}\n      <div className=\"filter-section\">\n// ... (truncated)", "parameters": [{"name": "{\n  filters,\n  onChange,\n  worldData,\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}", "type": "Readonly<FilterPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/GraphView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/GraphView.tsx", "sourceCode": "export default function GraphView({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  onRecalculateLayoutRef,\n  prominenceScale,\n}: Readonly<GraphViewProps>) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const cyRef = useRef<Core | null>(null);\n  const isInitializedRef = useRef(false);\n\n  // Get entity kind schemas from canonical schema\n  const entityKindSchemas = useMemo(() => data.schema.entityKinds, [data.schema.entityKinds]);\n\n  // Stable ref for onNodeSelect so the init effect doesn't re-run when callback changes\n  const onNodeSelectRef = useRef(onNodeSelect);\n  useEffect(() => {\n    onNodeSelectRef.current = onNodeSelect;\n  }, [onNodeSelect]);\n\n  const handleRecalculateLayout = () => {\n    if (!cyRef.current) return;\n\n    const layout = cyRef.current.layout({\n      name: \"cose-bilkent\",\n      randomize: true, // Add jitter to break out of local minima\n      fit: true,\n      idealEdgeLength: 100,\n      // Non-linear edge strength \u2192 spring length mapping for dramatic clustering\n      edgeLength: (edge: EdgeSingular) => {\n        const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n        // Non-linear scaling: emphasizes extremes away from 0.5\n        // strength 1.0 \u2192 25px (extremely tight clustering)\n        // strength 0.7 \u2192 70px (moderate clustering)\n        // strength 0.5 \u2192 130px (neutral)\n        // strength 0.3 \u2192 230px (loose)\n        // strength 0.0 \u2192 400px (very loose, almost disconnected)\n        const invStrength = 1 - strength;\n        return 25 + Math.pow(invStrength, 1.8) * 375;\n      },\n      nodeRepulsion: 100000,\n      gravity: 0.25,\n      numIter: 2500,\n      tile: true,\n      tilingPaddingVertical: 10,\n      tilingPaddingHorizontal: 10,\n      animate: true,\n      animationDuration: 1000,\n    } as CoseBilkentLayoutOptions);\n\n    layout.run();\n  };\n\n  // Expose recalculate layout handler\n  useEffect(() => {\n    if (onRecalculateLayoutRef) {\n      onRecalculateLayoutRef(handleRecalculateLayout);\n    }\n  }, [onRecalculateLayoutRef]);\n\n  // Initialize graph once\n  useEffect(() => {\n    if (!containerRef.current || isInitializedRef.current) return;\n\n    // Generate entity kind styles dynamically from schema\n    const entityStyles = generateEntityKindStyles(entityKindSchemas);\n\n    const cy = cytoscape({\n      container: containerRef.current,\n      elements: [],\n      style: [\n        {\n          selector: \"node\",\n          style: {\n            label: \"data(name)\",\n            \"text-valign\": \"center\",\n            \"text-halign\": \"center\",\n            \"font-size\": \"10px\",\n            color: \"#fff\",\n            \"text-outline-color\": \"#000\",\n            \"text-outline-width\": 2,\n            width: \"mapData(prominence, 0, 4, 20, 60)\",\n            height: \"mapData(prominence, 0, 4, 20, 60)\",\n            \"background-color\": \"#666\",\n          },\n        },\n        // Dynamic entity kind styles from schema\n        ...entityStyles,\n        {\n          selector: \"node:selected\",\n          style: {\n            \"border-width\": 4,\n            \"border-color\": \"#FFD700\",\n            \"background-color\": \"#FFD700\",\n          },\n        },\n        {\n          // Edge strength visualization: strength values (0-1) control visual prominence\n          // - Width: 0.5-7px (stronger = much thicker)\n          // - Opacity: 0.2-1.0 (stronger = fully opaque, weak = nearly invisible)\n          // Note: mapData doesn't work with colors, so we use fixed color + opacity\n          selector: \"edge\",\n          style: {\n            width: \"mapData(strength, 0, 1, 0.5, 7)\" as unknown as number,\n            \"line-color\": \"#888\",\n            \"target-arrow-color\": \"#888\",\n            \"target-arrow-shape\": \"triangle\",\n            \"curve-style\": \"bezier\",\n            opacity: \"mapData(strength, 0, 1, 0.2, 1)\" as unknown as number,\n            label: \"data(label)\",\n            \"font-size\": \"8px\",\n            color: \"#999\",\n            \"text-rotation\": \"autorotate\",\n            \"text-margin-y\": -10,\n          },\n        },\n        {\n          selector: \"edge.highlighted\",\n          style: {\n            \"line-color\": \"#FFD700\",\n            \"target-arrow-color\": \"#FFD700\",\n            width: 3,\n          },\n        },\n        {\n          // Catalyzed edges - special styling to show meta-relationships\n          selector: \"edge.catalyzed\",\n          style: {\n            \"line-style\": \"dashed\" as cytoscape.Css.LineStyle,\n            \"line-dash-pattern\": [6, 3] as unknown as number[],\n            \"line-color\": \"#a78bfa\", // Purple color for catalyzed relationships\n            \"target-arrow-color\": \"#a78bfa\",\n            width: \"mapData(strength, 0, 1, 1, 4)\" as unknown as number,\n            opacity: 0.9,\n          },\n        },\n      ],\n      layout: {\n        name: \"cose-bilkent\",\n        randomize: true,\n        idealEdgeLength: 100,\n        edgeLength: (edge: EdgeSingular) => {\n          const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n          const invStrength = 1 - strength;\n          return 25 + Math.pow(invStrength, 1.8) * 375;\n        },\n        nodeRepulsion: 100000,\n        gravity: 0.25,\n        numIter: 2500,\n        tile: true,\n        tilingPaddingVertical: 10,\n        tilingPaddingHorizontal: 10,\n      } as CoseBilkentLayoutOptions,\n    });\n\n    // Handle node click\n    cy.on(\"tap\", \"node\", (evt) => {\n      const node = evt.target as NodeSingular;\n      onNodeSelectRef.current(node.id());\n    });\n\n    // Handle background click (deselect)\n    cy.on(\"tap\", (evt) => {\n      if (evt.target === cy) {\n        onNodeSelectRef.current(undefined);\n      }\n    });\n\n    cyRef.current = cy;\n    isInitializedRef.current = true;\n\n    return () => {\n      cy.destroy();\n      isInitializedRef.current = false;\n    };\n  }, [entityKindSchemas]);\n\n  // Update styles when entity kind schema changes\n  useEffect(() => {\n    if (!cyRef.current) return;\n    const entityStyles = generateEntityKindStyles(entityKindSchemas);\n    cyRef.current.style([\n      {\n        selector: \"node\",\n        style: {\n          label: \"data(name)\",\n          \"text-valign\": \"center\",\n          \"text-halign\": \"center\",\n          \"font-size\": \"10px\",\n          color: \"#fff\",\n          \"text-outline-color\": \"#000\",\n          \"text-outline-width\": 2,\n          width: \"mapData(prominence, 0, 4, 20, 60)\",\n          height: \"mapData(prominence, 0, 4, 20, 60)\",\n          \"background-color\": \"#666\",\n        },\n      },\n      ...entityStyles,\n      {\n        selector: \"node:selected\",\n        style: {\n          \"border-width\": 4,\n          \"border-color\": \"#FFD700\",\n          \"background-color\": \"#FFD700\",\n        },\n      },\n      {\n        selector: \"edge\",\n        style: {\n          width: \"mapData(strength, 0, 1, 0.5, 7)\" as unknown as number,\n          \"line-color\": \"#888\",\n          \"target-arrow-color\": \"#888\",\n          \"target-arrow-shape\": \"triangle\",\n          \"curve-style\": \"bezier\",\n          opacity: \"mapData(strength, 0, 1, 0.2, 1)\" as unknown as number,\n          label: \"data(label)\",\n          \"font-size\": \"8px\",\n          color: \"#999\",\n          \"text-rotation\": \"autorotate\",\n          \"text-margin-y\": -10,\n        },\n      },\n      {\n        selector: \"edge.highlighted\",\n        style: {\n          \"line-color\": \"#FFD700\",\n          \"target-arrow-color\": \"#FFD700\",\n          width: 3,\n        },\n      },\n      {\n        selector: \"edge.catalyzed\",\n        style: {\n          \"line-style\": \"dashed\" as cytoscape.Css.LineStyle,\n          \"line-dash-pattern\": [6, 3] as unknown as number[],\n          \"line-color\": \"#a78bfa\",\n          \"target-arrow-color\": \"#a78bfa\",\n          width: \"mapData(strength, 0, 1, 1, 4)\" as unknown as number,\n          opacity: 0.9,\n        },\n      },\n    ]);\n  }, [entityKindSchemas]);\n\n  // Update graph data incrementally when data changes\n  useEffect(() => {\n    if (!cyRef.current) return;\n\n    const cy = cyRef.current;\n    const newElements = transformWorldData(data, showCatalyzedBy, prominenceScale);\n\n    // Get current element IDs\n    const currentNodeIds = new Set(cy.nodes().map((n) => n.id()));\n    const currentEdgeIds = new Set(cy.edges().map((e) => e.id()));\n\n    // Get new element IDs\n    const newNodes = newElements.filter((e) => !(\"source\" in e.data));\n    const newEdges = newElements.filter((e) => \"source\" in e.data);\n    const newNodeIds = new Set(newNodes.map((n) => n.data.id));\n    const newEdgeIds = new Set(newEdges.map((e) => e.data.id));\n\n    // Remove elements that no longer exist\n    cy.nodes().forEach((node) => {\n      if (!newNodeIds.has(node.id())) {\n        cy.remove(node);\n      }\n    });\n    cy.edges().forEach((edge) => {\n      if (!newEdgeIds.has(edge.id())) {\n        cy.remove(edge);\n      }\n    });\n\n    // Add new elements\n    const elementsToAdd = newElements.filter((e) => {\n      const id = e.data.id;\n      if (\"source\" in e.data) {\n        return !currentEdgeIds.has(id);\n      } else {\n        return !currentNodeIds.has(id);\n      }\n    });\n\n    if (elementsToAdd.length > 0) {\n      cy.add(elementsToAdd);\n\n      // If we're adding many nodes or have few existing nodes, do a full randomized layout\n      const currentNodeCount = cy.nodes().length;\n      const shouldFullLayout =\n        elementsToAdd.filter((e) => !(\"source\" in e.data)).length > currentNodeCount * 0.3;\n\n      const layout = cy.layout({\n        name: \"cose-bilkent\",\n        randomize: shouldFullLayout,\n        fit: shouldFullLayout,\n        idealEdgeLength: 100,\n        edgeLength: (edge: EdgeSingular) => {\n          const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n          const invStrength = 1 - strength;\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  onRecalculateLayoutRef,\n  prominenceScale,\n}", "type": "Readonly<GraphViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/GraphView3D.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/GraphView3D.tsx", "sourceCode": "export default function GraphView3D({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}: Readonly<GraphView3DProps>) {\n  const fgRef = useRef<ForceGraphInstance>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  // Delay render by one frame to let any stale animation callbacks clear\n  const [isReady, setIsReady] = useState(false);\n  // Unique ID per mount to ensure ForceGraph gets a fresh instance\n  const [mountId] = useState(() => Date.now());\n\n  useEffect(() => {\n    if (!webglAvailable) return;\n    const frameId = requestAnimationFrame(() => {\n      setIsReady(true);\n    });\n    return () => cancelAnimationFrame(frameId);\n  }, []);\n\n  // Get container dimensions\n  useEffect(() => {\n    if (!webglAvailable) return;\n    if (containerRef.current) {\n      const updateDimensions = () => {\n        if (containerRef.current) {\n          setDimensions({\n            width: containerRef.current.clientWidth,\n            height: containerRef.current.clientHeight,\n          });\n        }\n      };\n\n      updateDimensions();\n\n      // Update on window resize\n      window.addEventListener(\"resize\", updateDimensions);\n      return () => window.removeEventListener(\"resize\", updateDimensions);\n    }\n  }, []);\n\n  // Transform data to force-graph format\n  // We need both useMemo (for sync computation) and imperative update (library mutates data)\n  const graphData = useMemo(() => {\n    const nodes: GraphNode[] = data.hardState.map((entity) => ({\n      id: entity.id,\n      name: entity.name,\n      kind: entity.kind,\n      prominence: prominenceToNumber(entity.prominence, data.schema, prominenceScale),\n      color: getKindColor(entity.kind, data.schema),\n      val: prominenceToNumber(entity.prominence, data.schema, prominenceScale) + 1, // Size multiplier (1-5)\n    }));\n\n    const links: GraphLink[] = data.relationships.map((rel) => {\n      const catalyzedBy = rel.catalyzedBy;\n      return {\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        strength: rel.strength ?? 0.5,\n        distance: rel.distance,\n        catalyzed: showCatalyzedBy && !!catalyzedBy,\n      };\n    });\n\n    return { nodes, links };\n  }, [data, showCatalyzedBy, prominenceScale]);\n\n  // Generate a stable key - includes mountId for fresh instance on remount,\n  // and entity count for clean reset when filters change\n  const graphKey = useMemo(() => {\n    return `graph-${mountId}-${data.hardState.length}`;\n  }, [mountId, data.hardState.length]);\n\n  const legendItems = useMemo(() => {\n    return data.schema.entityKinds.map((kind) => {\n      const label = kind.style?.displayName || kind.description || kind.kind;\n      return {\n        kind: kind.kind,\n        label,\n        color: getKindColor(kind.kind, data.schema),\n      };\n    });\n  }, [data.schema]);\n\n  // Calculate link distance based on selected metric\n  const linkDistance = useCallback(\n    (link: GraphLink) => {\n      if (edgeMetric === \"none\") {\n        return 100; // Equal distance for all links\n      } else if (edgeMetric === \"distance\") {\n        // Lower distance = more similar = shorter spring (pull closer together)\n        // distance is 0-1, so we scale it: 0 -> 30px, 1 -> 200px\n        const dist = link.distance ?? 0.5;\n        return 30 + dist * 170;\n      } else {\n        // strength metric (default)\n        // Higher strength = shorter spring (pull closer together)\n        // strength is 0-1, so we invert it: 1 -> 30px, 0 -> 200px\n        const strength = link.strength ?? 0.5;\n        return 30 + (1 - strength) * 170;\n      }\n    },\n    [edgeMetric]\n  );\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node: GraphNode) => {\n      onNodeSelect(node.id);\n    },\n    [onNodeSelect]\n  );\n\n  // Handle background click\n  const handleBackgroundClick = useCallback(() => {\n    onNodeSelect(undefined);\n  }, [onNodeSelect]);\n\n  // Custom node appearance with text label\n  const nodeThreeObject = useCallback(\n    (node: GraphNode) => {\n      const group = new THREE.Group();\n\n      // Node sphere\n      const geometry = new THREE.SphereGeometry(node.val * 2, 16, 16);\n      const material = new THREE.MeshLambertMaterial({\n        color: node.color,\n        transparent: true,\n        opacity: node.id === selectedNodeId ? 1 : 0.9,\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      group.add(mesh);\n\n      // Add glow for selected node\n      if (node.id === selectedNodeId) {\n        const glowGeometry = new THREE.SphereGeometry(node.val * 2.5, 16, 16);\n        const glowMaterial = new THREE.MeshBasicMaterial({\n          color: \"#FFD700\",\n          transparent: true,\n          opacity: 0.3,\n        });\n        const glow = new THREE.Mesh(glowGeometry, glowMaterial);\n        group.add(glow);\n      }\n\n      // Create text sprite\n      const canvas = document.createElement(\"canvas\");\n      const context = canvas.getContext(\"2d\");\n      if (context) {\n        canvas.width = 256;\n        canvas.height = 64;\n\n        context.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n\n        context.font = \"Bold 20px Arial\";\n        context.fillStyle = \"white\";\n        context.textAlign = \"center\";\n        context.textBaseline = \"middle\";\n        context.fillText(node.name, canvas.width / 2, canvas.height / 2);\n\n        const texture = new THREE.CanvasTexture(canvas);\n        const spriteMaterial = new THREE.SpriteMaterial({\n          map: texture,\n          transparent: true,\n          opacity: 0.9,\n        });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(20, 5, 1);\n        sprite.position.set(0, node.val * 2 + 5, 0); // Position above the node\n        group.add(sprite);\n      }\n\n      return group;\n    },\n    [selectedNodeId]\n  );\n\n  // Custom link appearance\n  const linkColor = useCallback((link: GraphLink) => {\n    if (link.catalyzed) {\n      return \"#a78bfa\"; // Purple for catalyzed\n    }\n    // Fade color based on strength\n    const opacity = Math.floor(link.strength * 255)\n      .toString(16)\n      .padStart(2, \"0\");\n    return `#ffffff${opacity}`;\n  }, []);\n\n  const linkWidth = useCallback((link: GraphLink) => {\n    return link.strength * 2; // 0-2px width based on strength\n  }, []);\n\n  // Set initial camera position and cleanup on unmount\n  useEffect(() => {\n    if (!fgRef.current) return;\n    const fg = fgRef.current;\n    const camera = fg.camera();\n    camera.position.set(0, 0, 500);\n\n    // Cleanup: pause animation when component unmounts to prevent stale tick errors\n    return () => {\n      fg.pauseAnimation?.();\n      // Also stop the d3 simulation\n      const simulation = fg.d3Force(\"simulation\");\n      simulation?.stop?.();\n    };\n  }, []);\n\n  // Configure d3 forces when metric changes\n  useEffect(() => {\n    if (fgRef.current) {\n      const fg = fgRef.current;\n\n      // Configure the d3 link force to use our distance function\n      const linkForce = fg.d3Force(\"link\");\n      if (linkForce) {\n        linkForce\n          .distance((link: GraphLink) => {\n            if (edgeMetric === \"none\") {\n              return 100;\n            } else if (edgeMetric === \"distance\") {\n              const dist = link.distance ?? 0.5;\n              return 30 + dist * 170;\n            } else {\n              const strength = link.strength ?? 0.5;\n              return 30 + (1 - strength) * 170;\n            }\n          })\n          .strength(2.0); // Higher strength so distances have stronger effect\n\n        // Restart the simulation to apply new forces\n        fg.d3ReheatSimulation();\n      }\n    }\n  }, [edgeMetric]);\n\n  if (!webglAvailable) {\n    return (\n      <div className=\"gv3d-no-webgl\">\n        <div className=\"gv3d-no-webgl-inner\">\n          <div className=\"gv3d-no-webgl-icon\">&#x1F4A0;</div>\n          <div className=\"gv3d-no-webgl-title\">\n            WebGL not available\n          </div>\n          <div className=\"gv3d-no-webgl-message\">\n            3D graph view requires WebGL. Switch to the <strong>2D Graph</strong> or{\" \"}\n            <strong>Map</strong> view instead.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className=\"gv3d-container\">\n      {isReady && (\n        <ForceGraph3D\n          key={graphKey}\n          ref={fgRef}\n          graphData={graphData}\n          width={dimensions.width}\n          height={dimensions.height}\n          nodeId=\"id\"\n          nodeLabel=\"name\"\n          nodeColor=\"color\"\n          nodeVal=\"val\"\n          nodeThreeObject={nodeThreeObject}\n          onNodeClick={handleNodeClick}\n          onBackgroundClick={handleBackgroundClick}\n          linkSource=\"source\"\n          linkTarget=\"target\"\n          linkColor={linkColor}\n          linkWidth={linkWidth}\n          linkOpacity={0.6}\n          // @ts-expect-error react-force-graph supports linkDistance\n          linkDistance={linkDistance}\n          linkDirectionalArrowLength={3}\n          linkDirectionalArrowRelPos={1}\n          enableNodeDrag={true}\n          enableNavigationControls={true}\n          showNavInfo={false}\n          backgroundColor=\"#0a1929\"\n          d3VelocityDecay={0.4}\n          d3AlphaDecay={0.015}\n          d3AlphaMin={0.001}\n          warmupTicks={200}\n          cooldownTicks={Infinity}\n          cooldownTime={20000}\n        />\n      )}\n\n      {/* Legend */}\n      <div\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}", "type": "Readonly<GraphView3DProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/HeaderMenu.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/HeaderMenu.tsx", "sourceCode": "export default function HeaderMenu({\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}: Readonly<HeaderMenuProps>) {\n  const [isOpen, setIsOpen] = useState(false);\n  const menuRef = useRef<HTMLDivElement>(null);\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }\n  }, [isOpen]);\n\n  const handleMenuItemClick = (action: () => void) => {\n    action();\n    setIsOpen(false);\n  };\n\n  return (\n    <div className=\"header-menu\" ref={menuRef}>\n      <button onClick={() => setIsOpen(!isOpen)} className=\"header-menu-button\" title=\"Menu\">\n        <span className=\"header-menu-icon\">\u2630</span>\n      </button>\n\n      {isOpen && (\n        <div className=\"header-menu-dropdown\">\n          <div className=\"header-menu-section\">\n            <div className=\"header-menu-section-title\">View Mode</div>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"graph3d\"))}\n              className={`header-menu-item ${viewMode === \"graph3d\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"graph3d\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>3D Graph</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"graph2d\"))}\n              className={`header-menu-item ${viewMode === \"graph2d\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"graph2d\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>2D Graph</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"map\"))}\n              className={`header-menu-item ${viewMode === \"map\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"map\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Coordinate Map</span>\n            </button>\n          </div>\n\n          <div className=\"header-menu-section\">\n            <div className=\"header-menu-section-title\">Edge Spring Metric</div>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"strength\"))}\n              className={`header-menu-item ${edgeMetric === \"strength\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"strength\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Strength</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"distance\"))}\n              className={`header-menu-item ${edgeMetric === \"distance\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"distance\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Distance</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"none\"))}\n              className={`header-menu-item ${edgeMetric === \"none\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"none\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>None (Equal)</span>\n            </button>\n          </div>\n\n          <button\n            onClick={() => handleMenuItemClick(onRecalculateLayout)}\n            className=\"header-menu-item\"\n          >\n            <span className=\"header-menu-item-icon\">\u267b\ufe0f</span>\n            <span>Recalculate Layout</span>\n          </button>\n\n          <button onClick={() => handleMenuItemClick(onToggleStats)} className=\"header-menu-item\">\n            <span className=\"header-menu-item-icon\">\ud83d\udcca</span>\n            <span>Toggle Stats</span>\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}", "type": "Readonly<HeaderMenuProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/LoreSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/LoreSection.tsx", "sourceCode": "export default function LoreSection({ lore }: Readonly<LoreSectionProps>) {\n  return (\n    <div className=\"lore-section\">\n      <div className=\"lore-header\">\n        <span className=\"lore-icon\">\ud83d\udcd6</span>\n        <span className=\"lore-title\">Lore</span>\n      </div>\n      <div className=\"lore-content\">{lore.text}</div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore }", "type": "Readonly<LoreSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/RelationshipStoryModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/RelationshipStoryModal.tsx", "sourceCode": "export default function RelationshipStoryModal({\n  lore,\n  worldData,\n  onClose,\n}: Readonly<RelationshipStoryModalProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n  const srcEntity = getEntityById(worldData, lore.relationship.src);\n  const dstEntity = getEntityById(worldData, lore.relationship.dst);\n\n  // Parse the text which is formatted as \"backstory | stakes | perception\"\n  const parts = lore.text.split(\"|\").map((p) => p.trim());\n  const backstory = parts[0] || \"\";\n  const stakes = parts[1]?.replace(/^Stakes:\\s*/i, \"\") || \"\";\n  const perception = parts[2]?.replace(/^Perception:\\s*/i, \"\") || \"\";\n\n  return (\n    <div\n      className=\"relationship-story-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"relationship-story-modal\">\n        {/* Header */}\n        <div className=\"relationship-story-header\">\n          <div className=\"relationship-story-entities\">\n            <span className=\"relationship-story-entity\">\n              {srcEntity?.name || lore.relationship.src}\n            </span>\n            <span className=\"relationship-story-kind\">\n              {lore.relationship.kind.replace(/_/g, \" \")}\n            </span>\n            <span className=\"relationship-story-entity\">\n              {dstEntity?.name || lore.relationship.dst}\n            </span>\n          </div>\n          <button onClick={onClose} className=\"relationship-story-close\">\n            \u00d7\n          </button>\n        </div>\n\n        {/* Backstory */}\n        <div className=\"relationship-story-section\">\n          <div className=\"relationship-story-section-header\">\n            <span className=\"relationship-story-section-icon\">\ud83d\udcd6</span>\n            <span className=\"relationship-story-section-title\">How It Began</span>\n          </div>\n          <div className=\"relationship-story-section-content\">{backstory}</div>\n        </div>\n\n        {/* Stakes */}\n        {stakes && (\n          <div className=\"relationship-story-section\">\n            <div className=\"relationship-story-section-header\">\n              <span className=\"relationship-story-section-icon\">\u26a0\ufe0f</span>\n              <span className=\"relationship-story-section-title\">What&apos;s at Stake</span>\n            </div>\n            <div className=\"relationship-story-section-content\">{stakes}</div>\n          </div>\n        )}\n\n        {/* Perception */}\n        {perception && (\n          <div className=\"relationship-story-section\">\n            <div className=\"relationship-story-section-header\">\n              <span className=\"relationship-story-section-icon\">\ud83d\udc41\ufe0f</span>\n              <span className=\"relationship-story-section-title\">Different Perspectives</span>\n            </div>\n            <div className=\"relationship-story-section-content\">{perception}</div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  lore,\n  worldData,\n  onClose,\n}", "type": "Readonly<RelationshipStoryModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/StatsPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/StatsPanel.tsx", "sourceCode": "export default function StatsPanel({ worldData, isOpen, onToggle }: Readonly<StatsPanelProps>) {\n  const { pressures, validation } = worldData;\n\n  // Get pressure entries and sort by value\n  const pressureEntries = Object.entries(pressures).sort((a, b) => b[1] - a[1]);\n\n  return (\n    <>\n      {/* Stats Panel */}\n      {isOpen && (\n        <div className=\"stats-panel\">\n          <div className=\"stats-panel-header\">\n            <h3 className=\"stats-panel-title\">World Statistics</h3>\n            <button onClick={onToggle} className=\"stats-panel-close\">\n              \u2715\n            </button>\n          </div>\n\n          <div className=\"stats-panel-content\">\n            {/* Validation Status */}\n            {validation && (\n              <div className=\"stats-section\">\n                <h4 className=\"stats-section-title\">Validation</h4>\n                <div className=\"validation-summary\">\n                  <div className=\"validation-stat\">\n                    <span className=\"validation-label\">Passed:</span>\n                    <span className=\"validation-value passed\">\n                      {validation.passed}/{validation.totalChecks}\n                    </span>\n                  </div>\n                  {validation.failed > 0 && (\n                    <div className=\"validation-stat\">\n                      <span className=\"validation-label\">Failed:</span>\n                      <span className=\"validation-value failed\">{validation.failed}</span>\n                    </div>\n                  )}\n                </div>\n                <div className=\"validation-results\">\n                  {validation.results.map((result, i) => (\n                    <div\n                      key={i}\n                      className={`validation-result ${result.passed ? \"passed\" : \"failed\"}`}\n                    >\n                      <div className=\"validation-result-header\">\n                        <span className=\"validation-result-icon\">{result.passed ? \"\u2713\" : \"\u2717\"}</span>\n                        <span className=\"validation-result-name\">{result.name}</span>\n                        {!result.passed && (\n                          <span className=\"validation-result-count\">({result.failureCount})</span>\n                        )}\n                      </div>\n                      {!result.passed && (\n                        <div className=\"validation-result-details\">{result.details}</div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Pressures */}\n            <div className=\"stats-section\">\n              <h4 className=\"stats-section-title\">World Pressures</h4>\n              <div className=\"pressures-grid\">\n                {pressureEntries.map(([name, value]) => {\n                  const clamped = Math.max(-100, Math.min(100, value));\n                  const percentage = (clamped + 100) / 2; // -100..100 \u2192 0..100\n                  const magnitude = Math.abs(clamped);\n                  let intensity: string;\n                  if (magnitude >= 75) {\n                    intensity = \"high\";\n                  } else if (magnitude >= 50) {\n                    intensity = \"medium\";\n                  } else if (magnitude >= 25) {\n                    intensity = \"low\";\n                  } else {\n                    intensity = \"minimal\";\n                  }\n                  return (\n                    <div key={name} className=\"pressure-item\">\n                      <div className=\"pressure-header\">\n                        <span className=\"pressure-name\">{name.replace(/_/g, \" \")}</span>\n                        <span className=\"pressure-value\">{value.toFixed(1)}</span>\n                      </div>\n                      <div className=\"pressure-bar\">\n                        <div\n                          className={`pressure-bar-fill ${intensity}`}\n                          style={{ '--sp-pressure-width': `${percentage}%` } as React.CSSProperties}\n                        />\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ worldData, isOpen, onToggle }", "type": "Readonly<StatsPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/TimelineControl.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/TimelineControl.tsx", "sourceCode": "export default function TimelineControl({\n  worldData,\n  loreData,\n  currentTick,\n  onTickChange\n}: Readonly<TimelineControlProps>) {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playSpeed, setPlaySpeed] = useState(1);\n  const [isExpanded, setIsExpanded] = useState(true);\n  const [selectedEraNarrative, setSelectedEraNarrative] = useState<EraNarrativeLore | null>(null);\n  const [selectedEraTransition, setSelectedEraTransition] = useState<EraTransitionMilestone | null>(null);\n  const [selectedDiscovery, setSelectedDiscovery] = useState<DiscoveryEventLore | null>(null);\n  const previousTickRef = useRef(currentTick);\n  const clearEraNarrative = useCallback(() => setSelectedEraNarrative(null), []);\n  const clearDiscovery = useCallback(() => setSelectedDiscovery(null), []);\n  const noopExplorerClick = useCallback(() => {}, []);\n  const maxTick = worldData.metadata.tick;\n  const minTick = 0;\n\n  // Get all era narratives from lore (if available)\n  const eraNarratives = useMemo(() => {\n    return loreData?.records?.filter(record => record.type === \"era_narrative\") as EraNarrativeLore[] || [];\n  }, [loreData]);\n\n  // Get all discovery events from lore (if available)\n  const discoveryEvents = useMemo(() => {\n    return loreData?.records?.filter(record => record.type === \"discovery_event\") as DiscoveryEventLore[] || [];\n  }, [loreData]);\n\n  // Get era transitions from narrativeHistory (fallback when no loreData)\n  const eraTransitions = useMemo(() => {\n    const history = worldData.narrativeHistory as NarrativeEvent[] | undefined;\n    if (!history) return [];\n    return history.filter(e => e.eventKind === \"era_transition\").map(e => ({\n      id: e.id,\n      tick: e.tick,\n      era: e.era,\n      description: e.description\n    }));\n  }, [worldData]);\n\n  // Use eraNarratives if available, otherwise use eraTransitions\n  const hasLoreNarratives = eraNarratives.length > 0;\n\n  // Get events at the current tick from narrativeHistory (significance > 0.75 only)\n  const currentEvents = useMemo(() => {\n    const history = worldData.narrativeHistory as NarrativeEvent[] | undefined;\n    if (!history) return [];\n\n    // Get high-significance events at exact tick, sorted by significance\n    return history.filter(e => e.tick === currentTick && e.eventKind !== \"era_transition\" && e.significance > 0.75).sort((a, b) => b.significance - a.significance).slice(0, 5) // Limit to 5 most significant events\n    .map(e => ({\n      type: e.eventKind,\n      description: e.description,\n      significance: e.significance\n    }));\n  }, [worldData, currentTick]);\n\n  // Detect when crossing era transition ticks\n  useEffect(() => {\n    const previousTick = previousTickRef.current;\n    previousTickRef.current = currentTick;\n\n    // Check if we crossed an era transition from lore\n    if (hasLoreNarratives) {\n      const crossedNarrative = eraNarratives.find(narrative => {\n        const tick = narrative.metadata.tick;\n        return previousTick < tick && currentTick >= tick || previousTick > tick && currentTick <= tick;\n      });\n      if (crossedNarrative && isPlaying) {\n        setSelectedEraNarrative(crossedNarrative);\n        setIsPlaying(false);\n      }\n    } else {\n      // Check narrativeHistory era transitions\n      const crossedTransition = eraTransitions.find(transition => {\n        const tick = transition.tick;\n        return previousTick < tick && currentTick >= tick || previousTick > tick && currentTick <= tick;\n      });\n      if (crossedTransition && isPlaying) {\n        setSelectedEraTransition(crossedTransition);\n        setIsPlaying(false);\n      }\n    }\n  }, [currentTick, eraNarratives, eraTransitions, hasLoreNarratives, isPlaying]);\n\n  // Auto-play functionality\n  useEffect(() => {\n    if (!isPlaying) return;\n    const interval = setInterval(() => {\n      const nextTick = currentTick + playSpeed;\n      if (nextTick >= maxTick) {\n        setIsPlaying(false);\n        onTickChange(maxTick);\n      } else {\n        onTickChange(nextTick);\n      }\n    }, 200);\n    return () => clearInterval(interval);\n  }, [isPlaying, playSpeed, maxTick, currentTick, onTickChange]);\n\n  // Determine the era at the current tick by finding the most recent era created before/at this tick\n  const currentEra = useMemo(() => {\n    const eras = worldData.hardState.filter(e => e.kind === \"era\").sort((a, b) => a.createdAt - b.createdAt);\n\n    // Find the last era that was created at or before the current tick\n    let activeEra = eras[0]?.name || \"unknown\";\n    for (const era of eras) {\n      if (era.createdAt <= currentTick) {\n        activeEra = era.name;\n      } else {\n        break;\n      }\n    }\n    return activeEra;\n  }, [worldData.hardState, currentTick]);\n\n  // Count entities and relationships at current tick\n  const entitiesAtTick = worldData.hardState.filter(e => e.createdAt <= currentTick).length;\n  const relationshipsAtTick = worldData.relationships.filter(r => {\n    const srcEntity = worldData.hardState.find(e => e.id === r.src);\n    const dstEntity = worldData.hardState.find(e => e.id === r.dst);\n    return srcEntity && dstEntity && srcEntity.createdAt <= currentTick && dstEntity.createdAt <= currentTick;\n  }).length;\n  const handlePlayPause = () => {\n    if (currentTick >= maxTick) {\n      onTickChange(minTick);\n    }\n    setIsPlaying(!isPlaying);\n  };\n  const handleReset = () => {\n    setIsPlaying(false);\n    onTickChange(minTick);\n  };\n  const handleToEnd = () => {\n    setIsPlaying(false);\n    onTickChange(maxTick);\n  };\n  return <div className={`timeline-control ${isExpanded ? \"expanded\" : \"collapsed\"}`}>\n      <div className=\"timeline-header\">\n        <button className=\"timeline-expand-btn\" onClick={() => setIsExpanded(!isExpanded)} title={isExpanded ? \"Collapse timeline\" : \"Expand timeline\"}>\n          {isExpanded ? \"\u25bc\" : \"\u25b2\"}\n        </button>\n        <div className=\"timeline-title\">\n          <span className=\"timeline-icon\">\u23f1\ufe0f</span>\n          <span>Timeline</span>\n        </div>\n        <div className=\"timeline-stats\">\n          <span className=\"timeline-stat\">Tick {currentTick}</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat era-badge\">{currentEra}</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat\">{entitiesAtTick} entities</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat\">{relationshipsAtTick} links</span>\n        </div>\n      </div>\n\n      {isExpanded && <>\n          <div className=\"timeline-slider-container\">\n            <input type=\"range\" min={minTick} max={maxTick} value={currentTick} onChange={e => {\n          setIsPlaying(false);\n          onTickChange(parseInt(e.target.value));\n        }} className=\"timeline-slider\" />\n            {/* Era Milestones - positioned over the slider */}\n            {(eraNarratives.length > 0 || eraTransitions.length > 0 || discoveryEvents.length > 0) && <div className=\"timeline-milestones\">\n                {/* Era Narratives from loreData */}\n                {eraNarratives.map(narrative => {\n            const tick = narrative.metadata.tick;\n            return <button key={narrative.id} className={`timeline-milestone timeline-milestone-era ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedEraNarrative(narrative)} title={`${narrative.metadata.from} \u2192 ${narrative.metadata.to} (Tick ${tick})`}>\n                      \ud83d\udcdc\n                    </button>;\n          })}\n                {/* Era Transitions from narrativeHistory (fallback) */}\n                {!hasLoreNarratives && eraTransitions.map(transition => {\n            const tick = transition.tick;\n            return <button key={transition.id} className={`timeline-milestone timeline-milestone-era ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedEraTransition(transition)} title={`Era: ${transition.era} (Tick ${tick})`}>\n                        \ud83c\udfdb\ufe0f\n                      </button>;\n          })}\n                {/* Discovery Events */}\n                {discoveryEvents.map(discovery => {\n            const tick = discovery.metadata.tick;\n            return <button key={discovery.id} className={`timeline-milestone timeline-milestone-discovery timeline-milestone-${discovery.metadata.discoveryType} ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedDiscovery(discovery)} title={`Discovery by ${discovery.metadata.explorer} (Tick ${tick})`}>\n                      \ud83e\udded\n                    </button>;\n          })}\n              </div>}\n            <div className=\"timeline-markers\">\n              <span>{minTick}</span>\n              <span>{maxTick}</span>\n            </div>\n          </div>\n\n          <div className=\"timeline-controls\">\n            <button onClick={handleReset} className=\"timeline-btn\" title=\"Reset to start\">\n              \u23ee\n            </button>\n            <button onClick={handlePlayPause} className=\"timeline-btn timeline-btn-play\">\n              {isPlaying ? \"\u23f8\" : \"\u25b6\"}\n            </button>\n            <button onClick={handleToEnd} className=\"timeline-btn\" title=\"Jump to end\">\n              \u23ed\n            </button>\n\n            <div className=\"timeline-speed\">\n              <label htmlFor=\"speed\">Speed:</label>\n              <select id=\"speed\" value={playSpeed} onChange={e => setPlaySpeed(Number(e.target.value))} className=\"timeline-speed-select\">\n                <option value={1}>1x</option>\n                <option value={2}>2x</option>\n                <option value={5}>5x</option>\n                <option value={10}>10x</option>\n              </select>\n            </div>\n          </div>\n\n          <div className=\"timeline-events\">\n            <div className=\"timeline-events-header\">\n              {currentEvents.length > 0 ? `Events at Tick ${currentTick}:` : \"No events at this tick\"}\n            </div>\n            <div className=\"timeline-events-ticker\">\n              {currentEvents.length > 0 ? currentEvents.map((event, idx) => <div key={idx} className={`timeline-event timeline-event-${event.type}`}>\n                    <span className=\"timeline-event-type\">{getEventIcon(event.type)}</span>\n                    <span className=\"timeline-event-desc\">{event.description}</span>\n                  </div>) : <div className=\"timeline-event-empty\">\n                  Scrub through time to see historical events unfold\n                </div>}\n            </div>\n          </div>\n        </>}\n\n      {/* Era Narrative Modal (from loreData) */}\n      {selectedEraNarrative && <EraNarrative lore={selectedEraNarrative} onClose={clearEraNarrative} />}\n\n      {/* Era Transition Modal (from narrativeHistory) */}\n      {selectedEraTransition && <div className=\"era-transition-modal\" onClick={() => setSelectedEraTransition(null)} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n          <div className=\"era-transition-content\" onClick={e => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={e => {\n        if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n      }}>\n            <div className=\"era-transition-header\">\n              <span className=\"era-transition-icon\">\ud83c\udfdb\ufe0f</span>\n              <h2>Era Transition</h2>\n              <button className=\"era-transition-close\" onClick={() => setSelectedEraTransition(null)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"era-transition-body\">\n              <div className=\"era-transition-era\">{selectedEraTransition.era}</div>\n              <div className=\"era-transition-tick\">Tick {selectedEraTransition.tick}</div>\n              <p className=\"era-transition-description\">{selectedEraTransition.description}</p>\n            </div>\n          </div>\n        </div>}\n\n      {/* Discovery Story Modal */}\n      {selectedDiscovery && <DiscoveryStory lore={selectedDiscovery} onExplorerClick={noopExplorerClick} onClose={clearDiscovery} isModal={true} />}\n    </div>;\n}", "parameters": [{"name": "{\n  worldData,\n  loreData,\n  currentTick,\n  onTickChange\n}", "type": "Readonly<TimelineControlProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/TimelineView3D.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/TimelineView3D.tsx", "sourceCode": "export default function TimelineView3D({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}: Readonly<TimelineView3DProps>) {\n  const fgRef = useRef<ForceGraphInstance>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  // Delay render by one frame to let any stale animation callbacks clear\n  const [isReady, setIsReady] = useState(false);\n  // Unique ID per mount to ensure ForceGraph gets a fresh instance\n  const [mountId] = useState(() => Date.now());\n\n  useEffect(() => {\n    if (!webglAvailable) return;\n    const frameId = requestAnimationFrame(() => {\n      setIsReady(true);\n    });\n    return () => cancelAnimationFrame(frameId);\n  }, []);\n\n  // Get container dimensions\n  useEffect(() => {\n    if (!webglAvailable) return;\n    if (containerRef.current) {\n      const updateDimensions = () => {\n        if (containerRef.current) {\n          setDimensions({\n            width: containerRef.current.clientWidth,\n            height: containerRef.current.clientHeight,\n          });\n        }\n      };\n\n      updateDimensions();\n      window.addEventListener(\"resize\", updateDimensions);\n      return () => window.removeEventListener(\"resize\", updateDimensions);\n    }\n  }, []);\n\n  // Identify eras and sort by createdAt\n  const { eraPositions, entityEraMap } = useMemo(() => {\n    const eras = data.hardState\n      .filter((e) => e.kind === \"era\")\n      .sort((a, b) => a.createdAt - b.createdAt);\n\n    const positions = new Map<string, number>();\n    eras.forEach((era, index) => {\n      // Center the timeline: first era at negative X, progressing to positive\n      const centerOffset = ((eras.length - 1) * ERA_SPACING) / 2;\n      positions.set(era.id, index * ERA_SPACING - centerOffset);\n    });\n\n    // Build entity -> era mapping\n    // Priority: 1. eraId field, 2. created_during relationship, 3. first era\n    const entityToEra = new Map<string, string>();\n    const firstEraId = eras.length > 0 ? eras[0].id : null;\n\n    // First pass: use eraId field directly\n    data.hardState.forEach((entity) => {\n      if (entity.kind !== \"era\" && entity.eraId) {\n        entityToEra.set(entity.id, entity.eraId);\n      }\n    });\n\n    // Second pass: use created_during relationships for entities without eraId\n    data.relationships.forEach((rel) => {\n      if (rel.kind === \"created_during\" && !entityToEra.has(rel.src)) {\n        // created_during: src is entity, dst is era\n        if (positions.has(rel.dst)) {\n          entityToEra.set(rel.src, rel.dst);\n        }\n      }\n    });\n\n    // Third pass: entities still without era get assigned to first era\n    data.hardState.forEach((entity) => {\n      if (entity.kind !== \"era\" && !entityToEra.has(entity.id) && firstEraId) {\n        entityToEra.set(entity.id, firstEraId);\n      }\n    });\n\n    return { eraPositions: positions, entityEraMap: entityToEra };\n  }, [data.hardState, data.relationships]);\n\n  const legendItems = useMemo(() => {\n    return data.schema.entityKinds\n      .filter((kind) => kind.kind !== \"era\")\n      .map((kind) => {\n        const label = kind.style?.displayName || kind.description || kind.kind;\n        return {\n          kind: kind.kind,\n          label,\n          color: getKindColor(kind.kind, data.schema),\n        };\n      });\n  }, [data.schema]);\n\n  // Transform data to force-graph format\n  const graphData = useMemo(() => {\n    const nodes: GraphNode[] = data.hardState.map((entity) => {\n      const isEra = entity.kind === \"era\";\n\n      // For eras: use their fixed position\n      // For entities: get their era's X position as a soft target (not fixed)\n      let eraX: number | undefined;\n      if (isEra) {\n        eraX = eraPositions.get(entity.id);\n      } else {\n        const entityEraId = entityEraMap.get(entity.id);\n        if (entityEraId) {\n          eraX = eraPositions.get(entityEraId);\n        }\n      }\n\n      return {\n        id: entity.id,\n        name: entity.name,\n        kind: entity.kind,\n        prominence: prominenceToNumber(entity.prominence, data.schema, prominenceScale),\n        color: isEra ? \"#FFD700\" : getKindColor(entity.kind, data.schema), // Gold for eras\n        val: isEra ? 6 : prominenceToNumber(entity.prominence, data.schema, prominenceScale) + 1, // Eras are larger\n        createdAt: entity.createdAt,\n        // Fix era positions along X-axis, but not entity positions\n        fx: isEra ? eraX : undefined,\n        fy: isEra ? ERA_Y_POSITION : undefined,\n        fz: isEra ? ERA_Z_POSITION : undefined,\n        // Store the target X position for non-era entities (used by force simulation)\n        _targetX: isEra ? undefined : eraX,\n      } as SimulationNode;\n    });\n\n    const links: GraphLink[] = data.relationships.map((rel) => {\n      const catalyzedBy = rel.catalyzedBy;\n      // Both active_during and created_during link entities to eras\n      const isEraLink = ERA_RELATIONSHIP_KINDS.includes(rel.kind);\n\n      return {\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        strength: rel.strength ?? 0.5,\n        distance: rel.distance,\n        catalyzed: showCatalyzedBy && !!catalyzedBy,\n        isCreatedDuring: isEraLink, // Renamed to isEraLink semantically, but keeping field name for compatibility\n      };\n    });\n\n    return { nodes, links };\n  }, [data, showCatalyzedBy, eraPositions, entityEraMap, prominenceScale]);\n\n  // Generate a stable key - includes mountId for fresh instance on remount,\n  // and entity count for clean reset when filters change\n  const graphKey = useMemo(() => {\n    return `timeline-${mountId}-${data.hardState.length}`;\n  }, [mountId, data.hardState.length]);\n\n  // Calculate link distance based on selected metric and relationship type\n  const linkDistance = useCallback(\n    (link: GraphLink) => {\n      // created_during links should be shorter to pull entities toward their era\n      if (link.isCreatedDuring) {\n        return 50; // Short distance to cluster near era\n      }\n\n      if (edgeMetric === \"none\") {\n        return 100;\n      } else if (edgeMetric === \"distance\") {\n        const dist = link.distance ?? 0.5;\n        return 30 + dist * 170;\n      } else {\n        const strength = link.strength ?? 0.5;\n        return 30 + (1 - strength) * 170;\n      }\n    },\n    [edgeMetric]\n  );\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node: GraphNode) => {\n      onNodeSelect(node.id);\n    },\n    [onNodeSelect]\n  );\n\n  // Handle background click\n  const handleBackgroundClick = useCallback(() => {\n    onNodeSelect(undefined);\n  }, [onNodeSelect]);\n\n  // Custom node appearance with text label\n  const nodeThreeObject = useCallback(\n    (node: GraphNode) => {\n      const group = new THREE.Group();\n      const isEra = node.kind === \"era\";\n      const isSelected = node.id === selectedNodeId;\n\n      addNodeMesh(group, node, isEra, isSelected);\n      if (isSelected) {\n        addSelectionGlow(group, node, isEra);\n      }\n      addTextSprite(group, node, isEra);\n\n      return group;\n    },\n    [selectedNodeId]\n  );\n\n  // Custom link appearance\n  const linkColor = useCallback((link: GraphLink) => {\n    if (link.isCreatedDuring) {\n      return \"#FFD70088\"; // Golden for created_during links\n    }\n    if (link.catalyzed) {\n      return \"#a78bfa\";\n    }\n    const opacity = Math.floor(link.strength * 255)\n      .toString(16)\n      .padStart(2, \"0\");\n    return `#ffffff${opacity}`;\n  }, []);\n\n  const linkWidth = useCallback((link: GraphLink) => {\n    if (link.isCreatedDuring) {\n      return 1; // Thinner for created_during to reduce visual clutter\n    }\n    return link.strength * 2;\n  }, []);\n\n  // Set initial camera position and cleanup on unmount\n  useEffect(() => {\n    if (!isReady || !fgRef.current) {\n      return;\n    }\n\n    const fg = fgRef.current;\n    const camera = fg.camera();\n    // Position camera to see timeline from the side\n    camera.position.set(0, 200, 500);\n\n    // Cleanup: pause animation when component unmounts to prevent stale tick errors\n    return () => {\n      fg.pauseAnimation?.();\n      // Also stop the d3 simulation\n      const simulation = fg.d3Force(\"simulation\");\n      simulation?.stop?.();\n    };\n  }, [isReady]);\n\n  // Configure d3 forces for timeline layout\n  useEffect(() => {\n    if (!isReady || !fgRef.current) {\n      return;\n    }\n\n    const fg = fgRef.current;\n\n    // Configure the d3 link force\n    const linkForce = fg.d3Force(\"link\");\n    if (linkForce) {\n      linkForce\n        .distance((link: GraphLink) => {\n          // Era links (active_during, created_during) are shorter to cluster near era\n          if (link.isCreatedDuring) {\n            return 50;\n          }\n          if (edgeMetric === \"none\") {\n            return 100;\n          } else if (edgeMetric === \"distance\") {\n            const dist = link.distance ?? 0.5;\n            return 30 + dist * 170;\n          } else {\n            const strength = link.strength ?? 0.5;\n            return 30 + (1 - strength) * 170;\n          }\n        })\n        .strength((link: GraphLink) => {\n          // Era links have higher strength to pull entities toward eras\n          if (link.isCreatedDuring) {\n            return 1.5;\n          }\n          return 0.5;\n        });\n\n      fg.d3ReheatSimulation();\n    }\n\n    // Add custom force to pull entities toward their era's X position\n    // This works even for entities without direct era relationships\n    fg.d3Force(\"eraX\", (alpha: number) => {\n      (graphData.nodes as SimulationNode[]).forEach((node) => {\n        if (node.kind !== \"era\" && node._targetX !== undefined && node.fx === undefined) {\n          // Pull toward era's X position\n          const dx = node._targetX - (node.x ?? 0);\n          node.vx = (node.vx || 0) + dx * alpha * 0.1;\n        }\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}", "type": "Readonly<TimelineView3DProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/components/WorldExplorer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/WorldExplorer.tsx", "sourceCode": "export default function WorldExplorer({ worldData, loreData }: Readonly<WorldExplorerProps>) {\n  // Initialize from hash on mount\n  const [selectedEntityId, setSelectedEntityId] = useState<string | undefined>(() =>\n    parseHashEntityId()\n  );\n  const [currentTick, setCurrentTick] = useState<number>(worldData.metadata.tick);\n  const [isStatsPanelOpen, setIsStatsPanelOpen] = useState(false);\n  const [viewMode, setViewMode] = useState<ViewMode>(webglAvailable ? \"graph3d\" : \"graph2d\");\n  const [edgeMetric, setEdgeMetric] = useState<EdgeMetric>(\"strength\");\n  const recalculateLayoutRef = useRef<(() => void) | null>(null);\n  const handleRecalculateLayout = useCallback(() => recalculateLayoutRef.current?.(), []);\n  const handleToggleStats = useCallback(() => setIsStatsPanelOpen(prev => !prev), []);\n  const handleRecalculateLayoutRef = useCallback(\n    (handler: (() => void) | null) => { recalculateLayoutRef.current = handler; },\n    []\n  );\n\n  // Sync hash changes to state (for back/forward buttons)\n  useEffect(() => {\n    const handleHashChange = () => {\n      const entityId = parseHashEntityId();\n      setSelectedEntityId(entityId);\n    };\n\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, []);\n\n  // Handle entity selection - updates hash which triggers state update via hashchange\n  const handleEntitySelect = useCallback((entityId: string | undefined) => {\n    const newHash = buildEntityHash(entityId);\n    if (window.location.hash !== newHash) {\n      window.location.hash = newHash;\n    }\n  }, []);\n\n  // Get UI configuration from schema\n  const entityKinds = worldData.schema.entityKinds.map((ek) => ek.kind);\n  const defaultMinProminence = getProminenceLevels(worldData.schema)[0];\n  const prominenceScale = useMemo<ProminenceScale>(() => {\n    const values = worldData.hardState\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [worldData]);\n\n  const [filters, setFilters] = useState<Filters>({\n    kinds: entityKinds,\n    minProminence: defaultMinProminence,\n    timeRange: [0, worldData.metadata.tick],\n    tags: [],\n    searchQuery: \"\",\n    relationshipTypes: [],\n    minStrength: 0.0,\n    showCatalyzedBy: false,\n    showHistoricalRelationships: false,\n  });\n\n  // Apply temporal filter first, then regular filters\n  const temporalData = applyTemporalFilter(worldData, currentTick);\n  const filteredData = applyFilters(temporalData, filters, prominenceScale);\n  const loadingFallback = useMemo(() => <div className=\"world-loading\">Loading view\u2026</div>, []);\n\n  return (\n    <div className=\"world-explorer\">\n      {/* Main Content */}\n      <div className=\"world-main\">\n        {/* Filter Panel */}\n        <FilterPanel\n          filters={filters}\n          onChange={setFilters}\n          worldData={worldData}\n          viewMode={viewMode}\n          edgeMetric={edgeMetric}\n          onViewModeChange={setViewMode}\n          onEdgeMetricChange={setEdgeMetric}\n          onRecalculateLayout={handleRecalculateLayout}\n          onToggleStats={handleToggleStats}\n        />\n\n        {/* Graph View */}\n        <main className=\"world-graph-container\">\n          <Suspense fallback={loadingFallback}>\n            {viewMode === \"graph3d\" && (\n              <GraphView3D\n                key={`3d-view-${edgeMetric}`}\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                edgeMetric={edgeMetric}\n                prominenceScale={prominenceScale}\n              />\n            )}\n            {viewMode === \"graph2d\" && (\n              <GraphView\n                key=\"2d-view\"\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                onRecalculateLayoutRef={handleRecalculateLayoutRef}\n                prominenceScale={prominenceScale}\n              />\n            )}\n            {viewMode === \"timeline\" && (\n              <TimelineView3D\n                key={`timeline-view-${edgeMetric}`}\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                edgeMetric={edgeMetric}\n                prominenceScale={prominenceScale}\n              />\n            )}\n          </Suspense>\n          {viewMode === \"map\" && (\n            <CoordinateMapView\n              key=\"map-view\"\n              data={filteredData}\n              selectedNodeId={selectedEntityId}\n              onNodeSelect={handleEntitySelect}\n            />\n          )}\n        </main>\n\n        {/* Entity Detail Panel */}\n        <EntityDetail\n          entityId={selectedEntityId}\n          worldData={worldData}\n          loreData={loreData}\n          onRelatedClick={handleEntitySelect}\n          prominenceScale={prominenceScale}\n        />\n      </div>\n\n      {/* Timeline Control */}\n      <TimelineControl\n        worldData={worldData}\n        loreData={loreData}\n        currentTick={currentTick}\n        onTickChange={setCurrentTick}\n      />\n\n      {/* Stats Panel */}\n      <StatsPanel\n        worldData={worldData}\n        isOpen={isStatsPanelOpen}\n        onToggle={handleToggleStats}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ worldData, loreData }", "type": "Readonly<WorldExplorerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getTagsArray", "name": "getTagsArray", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "// Helper to get tags as array (canonical KVP format)\nexport function getTagsArray(tags: Record<string, string | boolean>): string[] {\n  return Object.keys(tags);\n}", "parameters": [{"name": "tags", "type": "Record<string, string | boolean>", "optional": false}], "returnType": "string[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getProminenceLevels", "name": "getProminenceLevels", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "// Get prominence levels from schema (no fallbacks)\nexport function getProminenceLevels(schema?: Schema): Prominence[] {\n  const levels = schema?.uiConfig?.prominenceLevels;\n  if (!levels || levels.length === 0) {\n    throw new Error(\"Archivist: schema.uiConfig.prominenceLevels is required.\");\n  }\n  const invalidLevels = levels.filter((level) => !VALID_PROMINENCE_LEVELS.has(level as Prominence));\n  if (invalidLevels.length > 0) {\n    throw new Error(`Archivist: unsupported prominence levels: ${invalidLevels.join(\", \")}.`);\n  }\n  return levels as Prominence[];\n}", "parameters": [{"name": "schema", "type": "Schema", "optional": true}], "returnType": "Prominence[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getProminenceColor", "name": "getProminenceColor", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getProminenceColor(prominence: Prominence, schema?: Schema): string {\n  const colors = schema?.uiConfig?.prominenceColors;\n  if (!colors) {\n    throw new Error(\"Archivist: schema.uiConfig.prominenceColors is required.\");\n  }\n  const color = colors[prominence];\n  if (!color) {\n    throw new Error(`Archivist: prominence color missing for \"${prominence}\".`);\n  }\n  return color;\n}", "parameters": [{"name": "prominence", "type": "Prominence", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}], "returnType": "string"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::prominenceToNumber", "name": "prominenceToNumber", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function prominenceToNumber(\n  prominence: Prominence | number,\n  schema?: Schema,\n  prominenceScale?: ProminenceScale\n): number {\n  if (typeof prominence === \"number\" && Number.isFinite(prominence)) {\n    const scale = resolveProminenceScale(prominenceScale);\n    const label = prominenceLabelFromScale(prominence, scale);\n    const index = scale.labels.indexOf(label);\n    return index >= 0 ? index : 0;\n  }\n\n  const levels = getProminenceLevels(schema);\n  const index = levels.indexOf(prominence as Prominence);\n  if (index < 0) {\n    throw new Error(\n      `Archivist: prominence \"${String(prominence)}\" not found in schema.uiConfig.prominenceLevels.`\n    );\n  }\n  return index;\n}", "parameters": [{"name": "prominence", "type": "Prominence | number", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "number"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getKindColor", "name": "getKindColor", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getKindColor(kind: string, schema?: Schema): string {\n  const entityKind = schema?.entityKinds?.find((ek) => ek.kind === kind);\n  if (!entityKind) {\n    throw new Error(`Archivist: entity kind \"${kind}\" not found in schema.`);\n  }\n  if (!entityKind.style?.color) {\n    throw new Error(`Archivist: entity kind \"${kind}\" is missing style.color.`);\n  }\n  return entityKind.style.color;\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}], "returnType": "string"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::transformWorldData", "name": "transformWorldData", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function transformWorldData(\n  worldState: WorldState,\n  showCatalyzedBy: boolean = false,\n  prominenceScale?: ProminenceScale\n) {\n  const resolvedScale = resolveProminenceScale(prominenceScale);\n  const nodes = worldState.hardState.map((entity) => ({\n    data: {\n      id: entity.id,\n      name: entity.name,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      prominence: prominenceToNumber(entity.prominence, worldState.schema, resolvedScale),\n      prominenceLabel:\n        typeof entity.prominence === \"number\"\n          ? prominenceLabelFromScale(entity.prominence, resolvedScale)\n          : entity.prominence,\n      status: entity.status,\n      tags: entity.tags,\n      description: entity.description,\n      createdAt: entity.createdAt,\n      updatedAt: entity.updatedAt,\n    },\n    classes: `${entity.kind} ${entity.subtype} ${entity.prominence}`,\n  }));\n\n  const edges = worldState.relationships.map((rel) => {\n    // Check if this relationship was catalyzed by an event or entity\n    // In a full implementation, this would check for catalyzedBy metadata\n    const catalyzedBy = rel.catalyzedBy;\n    const hasCatalyst = !!catalyzedBy;\n\n    return {\n      data: {\n        id: `edge-${rel.src}-${rel.dst}-${rel.kind}`,\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        label: rel.kind.replace(/_/g, \" \"),\n        strength: rel.strength ?? 0.5,\n        catalyzedBy: catalyzedBy,\n        hasCatalyst: hasCatalyst,\n      },\n      classes: [rel.kind.replace(/_/g, \"-\"), hasCatalyst && showCatalyzedBy ? \"catalyzed\" : \"\"]\n        .filter(Boolean)\n        .join(\" \"),\n    };\n  });\n\n  return [...nodes, ...edges];\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "showCatalyzedBy", "type": "boolean", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "({ data: { id: string; name: string; kind: string; subtype: string; prominence: number; prominenceLabel: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").ProminenceLabel; status: string; tags: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").EntityTags; description: string; createdAt: number; updatedAt: number; }; classes: string; } | { data: { id: string; source: string; target: string; kind: string; label: string; strength: number; catalyzedBy: string | undefined; hasCatalyst: boolean; }; classes: string; })[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::applyFilters", "name": "applyFilters", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function applyFilters(\n  worldState: WorldState,\n  filters: Filters,\n  prominenceScale?: ProminenceScale\n): WorldState {\n  const prominenceOrder = getProminenceLevels(worldState.schema);\n  const minProminenceIndex = prominenceOrder.indexOf(filters.minProminence);\n  const resolvedScale = resolveProminenceScale(prominenceScale);\n\n  const filtered = worldState.hardState.filter((entity) => {\n    // Filter by kind\n    if (!filters.kinds.includes(entity.kind)) return false;\n\n    // Filter by prominence\n    const entityProminenceLabel =\n      typeof entity.prominence === \"number\"\n        ? prominenceLabelFromScale(entity.prominence, resolvedScale)\n        : entity.prominence;\n    const entityProminenceIndex = prominenceOrder.indexOf(entityProminenceLabel);\n    if (entityProminenceIndex < minProminenceIndex) return false;\n\n    // Filter by time range\n    if (entity.createdAt < filters.timeRange[0] || entity.createdAt > filters.timeRange[1]) {\n      return false;\n    }\n\n    // Filter by tags\n    if (filters.tags.length > 0) {\n      const entityTags = getTagsArray(entity.tags);\n      const hasMatchingTag = filters.tags.some((tag) => entityTags.includes(tag));\n      if (!hasMatchingTag) return false;\n    }\n\n    // Filter by search query\n    if (filters.searchQuery) {\n      const query = filters.searchQuery.toLowerCase();\n      const entityTags = getTagsArray(entity.tags);\n      const matches =\n        entity.name.toLowerCase().includes(query) ||\n        entity.description.toLowerCase().includes(query) ||\n        entityTags.some((tag) => tag.toLowerCase().includes(query));\n      if (!matches) return false;\n    }\n\n    return true;\n  });\n\n  // Get IDs of filtered entities\n  const filteredIds = new Set(filtered.map((e) => e.id));\n\n  // Get all unique relationship types for comparison\n  const allRelTypes = new Set(worldState.relationships.map((r) => r.kind));\n\n  // Filter relationships to only include those between filtered entities\n  // Also filter by relationship type and strength if specified\n  const filteredRelationships = worldState.relationships.filter((rel) => {\n    // Must be between visible entities\n    if (!filteredIds.has(rel.src) || !filteredIds.has(rel.dst)) return false;\n\n    // Filter by minimum strength\n    const strength = rel.strength ?? 0.5;\n    if (strength < filters.minStrength) return false;\n\n    // If relationship type filter has ALL types selected, show none (special \"clear all\" case)\n    if (\n      filters.relationshipTypes.length === allRelTypes.size &&\n      filters.relationshipTypes.length > 0\n    ) {\n      return false;\n    }\n\n    // If relationship type filter is active and not empty, check if this type is included\n    if (filters.relationshipTypes.length > 0) {\n      return filters.relationshipTypes.includes(rel.kind);\n    }\n\n    // Filter historical relationships unless explicitly shown\n    if (!filters.showHistoricalRelationships && rel.status === \"historical\") {\n      return false;\n    }\n\n    // Empty array means show all\n    return true;\n  });\n\n  return {\n    ...worldState,\n    hardState: filtered,\n    relationships: filteredRelationships,\n    metadata: {\n      ...worldState.metadata,\n      entityCount: filtered.length,\n      relationshipCount: filteredRelationships.length,\n    },\n  };\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "filters", "type": "Filters", "optional": false}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "WorldState"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getAllTags", "name": "getAllTags", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getAllTags(worldState: WorldState): string[] {\n  const tagSet = new Set<string>();\n  worldState.hardState.forEach((entity) => {\n    getTagsArray(entity.tags).forEach((tag) => tagSet.add(tag));\n  });\n  return Array.from(tagSet).sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "string[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getAllRelationshipTypes", "name": "getAllRelationshipTypes", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getAllRelationshipTypes(worldState: WorldState): string[] {\n  const typeSet = new Set<string>();\n  worldState.relationships.forEach((rel) => {\n    typeSet.add(rel.kind);\n  });\n  return Array.from(typeSet).sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "string[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelationshipTypeCounts", "name": "getRelationshipTypeCounts", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelationshipTypeCounts(worldState: WorldState): Record<string, number> {\n  const counts: Record<string, number> = {};\n  worldState.relationships.forEach((rel) => {\n    counts[rel.kind] = (counts[rel.kind] || 0) + 1;\n  });\n  return counts;\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "Record<string, number>"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getEntityById", "name": "getEntityById", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getEntityById(worldState: WorldState, id: string): HardState | undefined {\n  return worldState.hardState.find((e) => e.id === id);\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "HardState | undefined"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelatedEntities", "name": "getRelatedEntities", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelatedEntities(worldState: WorldState, entityId: string): HardState[] {\n  const relatedIds = new Set<string>();\n\n  worldState.relationships.forEach((rel) => {\n    if (rel.src === entityId) {\n      relatedIds.add(rel.dst);\n    }\n    if (rel.dst === entityId) {\n      relatedIds.add(rel.src);\n    }\n  });\n\n  return worldState.hardState.filter((e) => relatedIds.has(e.id));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelationships", "name": "getRelationships", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelationships(worldState: WorldState, entityId: string) {\n  return worldState.relationships.filter((rel) => rel.src === entityId || rel.dst === entityId);\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").WorldRelationship[]"}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::applyTemporalFilter", "name": "applyTemporalFilter", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function applyTemporalFilter(worldState: WorldState, maxTick: number): WorldState {\n  // Filter entities created at or before maxTick\n  const filteredEntities = worldState.hardState.filter((entity) => entity.createdAt <= maxTick);\n\n  // Filter relationships where both source and destination entities exist at maxTick\n  const filteredRelationships = worldState.relationships.filter((rel) => {\n    const srcEntity = worldState.hardState.find((e) => e.id === rel.src);\n    const dstEntity = worldState.hardState.find((e) => e.id === rel.dst);\n    return (\n      srcEntity && dstEntity && srcEntity.createdAt <= maxTick && dstEntity.createdAt <= maxTick\n    );\n  });\n\n  return {\n    ...worldState,\n    hardState: filteredEntities,\n    relationships: filteredRelationships,\n    metadata: {\n      ...worldState.metadata,\n      tick: maxTick,\n      entityCount: filteredEntities.length,\n      relationshipCount: filteredRelationships.length,\n    },\n  };\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "maxTick", "type": "number", "optional": false}], "returnType": "WorldState"}, {"id": "apps/archivist/webui/src/utils/schemaValidation.ts::validateWorldData", "name": "validateWorldData", "kind": "function", "filePath": "apps/archivist/webui/src/utils/schemaValidation.ts", "sourceCode": "export function validateWorldData(worldData: WorldState): string[] {\n  const issues: string[] = [];\n  let overflow = 0;\n\n  const addIssue = (message: string) => {\n    if (issues.length < MAX_ISSUES) {\n      issues.push(message);\n    } else {\n      overflow += 1;\n    }\n  };\n\n  if (!worldData?.schema) {\n    addIssue(\"World data is missing schema.\");\n    return issues;\n  }\n\n  const { schema } = worldData;\n\n  if (!schema.entityKinds || schema.entityKinds.length === 0) {\n    addIssue(\"Schema requires entityKinds.\");\n  }\n\n  if (!schema.relationshipKinds || schema.relationshipKinds.length === 0) {\n    addIssue(\"Schema requires relationshipKinds.\");\n  }\n\n  if (!schema.cultures || schema.cultures.length === 0) {\n    addIssue(\"Schema requires cultures.\");\n  }\n\n  if (!schema.uiConfig) {\n    addIssue(\"Schema requires uiConfig.\");\n  }\n\n  const prominenceLevels = schema.uiConfig?.prominenceLevels;\n  const prominenceColors = schema.uiConfig?.prominenceColors;\n\n  if (!prominenceLevels || prominenceLevels.length === 0) {\n    addIssue(\"Schema.uiConfig.prominenceLevels is required.\");\n  }\n\n  if (!prominenceColors || Object.keys(prominenceColors).length === 0) {\n    addIssue(\"Schema.uiConfig.prominenceColors is required.\");\n  }\n\n  if (prominenceLevels && prominenceColors) {\n    prominenceLevels.forEach((level) => {\n      if (!prominenceColors[level]) {\n        addIssue(`Schema.uiConfig.prominenceColors missing \"${level}\".`);\n      }\n    });\n  }\n\n  const axisIds = new Set((schema.axisDefinitions || []).map((axis) => axis.id));\n  const kindById = new Map(schema.entityKinds?.map((kind) => [kind.kind, kind]));\n  const cultureIds = new Set(schema.cultures?.map((culture) => culture.id));\n  const relationshipKinds = new Set(schema.relationshipKinds?.map((kind) => kind.kind));\n\n  schema.entityKinds?.forEach((kind) => {\n    if (!kind.style?.color) {\n      addIssue(`Entity kind \"${kind.kind}\" is missing style.color.`);\n    }\n\n    kind.requiredRelationships?.forEach((rule) => {\n      if (!relationshipKinds.has(rule.kind)) {\n        addIssue(`Entity kind \"${kind.kind}\" requires unknown relationship \"${rule.kind}\".`);\n      }\n    });\n\n    const axes = kind.semanticPlane?.axes;\n    const axisRefs = [axes?.x?.axisId, axes?.y?.axisId, axes?.z?.axisId].filter(\n      Boolean\n    ) as string[];\n    axisRefs.forEach((axisId) => {\n      if (!axisIds.has(axisId)) {\n        addIssue(\n          `Axis \"${axisId}\" referenced by kind \"${kind.kind}\" is missing in schema.axisDefinitions.`\n        );\n      }\n    });\n\n    kind.semanticPlane?.regions?.forEach((region) => {\n      if (!region.color) {\n        addIssue(`Region \"${region.id}\" in kind \"${kind.kind}\" is missing color.`);\n      }\n    });\n  });\n\n  schema.cultures?.forEach((culture) => {\n    if (!culture.color) {\n      addIssue(`Culture \"${culture.id}\" is missing color.`);\n    }\n  });\n\n  if (worldData.coordinateState?.emergentRegions) {\n    Object.entries(worldData.coordinateState.emergentRegions).forEach(([kind, regions]) => {\n      regions.forEach((region) => {\n        if (!region.color) {\n          addIssue(`Emergent region \"${region.id}\" for kind \"${kind}\" is missing color.`);\n        }\n      });\n    });\n  }\n\n  worldData.hardState.forEach((entity) => {\n    if (!kindById.has(entity.kind)) {\n      addIssue(`Entity \"${entity.id}\" references unknown kind \"${entity.kind}\".`);\n    }\n\n    if (entity.culture && !cultureIds.has(entity.culture)) {\n      addIssue(`Entity \"${entity.id}\" references unknown culture \"${entity.culture}\".`);\n    }\n\n    if (prominenceLevels) {\n      const prom: unknown = entity.prominence;\n      if (typeof prom === \"string\") {\n        if (!prominenceLevels.includes(prom)) {\n          addIssue(\n            `Entity \"${entity.id}\" uses prominence \"${prom}\" not in schema.uiConfig.prominenceLevels.`\n          );\n        }\n      } else if (typeof prom === \"number\") {\n        if (!Number.isFinite(prom) || prom < 0 || prom > 5) {\n          addIssue(`Entity \"${entity.id}\" has invalid numeric prominence \"${String(prom)}\".`);\n        }\n      } else {\n        addIssue(`Entity \"${entity.id}\" has invalid prominence \"${String(prom)}\".`);\n      }\n    }\n\n    const coords = entity.coordinates;\n    if (\n      !coords ||\n      typeof coords.x !== \"number\" ||\n      typeof coords.y !== \"number\" ||\n      typeof coords.z !== \"number\"\n    ) {\n      addIssue(`Entity \"${entity.id}\" is missing valid coordinates.`);\n    }\n  });\n\n  worldData.relationships.forEach((rel) => {\n    if (rel.kind && !relationshipKinds.has(rel.kind)) {\n      addIssue(`Relationship \"${rel.kind}\" is not defined in schema.relationshipKinds.`);\n    }\n  });\n\n  if (overflow > 0) {\n    issues.push(`...and ${overflow} more issues.`);\n  }\n\n  return issues;\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}], "returnType": "string[]"}]