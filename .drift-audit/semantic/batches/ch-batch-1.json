[{"id": "packages/shared-components/src/components/AddItemButton.jsx::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "packages/shared-components/src/components/AddItemButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/CategorySection.jsx::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "packages/shared-components/src/components/CategorySection.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button", "div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ChipSelect.jsx::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "packages/shared-components/src/components/ChipSelect.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "button", "input", "div"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::ExpandableSeedSection", "name": "ExpandableSeedSection", "kind": "component", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * Expandable wrapper for use in validation UI\r\n *\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {boolean} [props.defaultExpanded]\r\n */\r\nexport function ExpandableSeedSection({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}) {\r\n  const [expanded, setExpanded] = useState(defaultExpanded);\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-expandable-container\"\r\n    >\r\n      <button\r\n        onClick={() => setExpanded(!expanded)}\r\n        className=\"csv-expandable-button\"\r\n      >\r\n        <span>Generation Context</span>\r\n        <span className=\"csv-expandable-meta\">\r\n          {expanded ? \"\\u25BC\" : \"\\u25B6\"} {seed.roleAssignments.length} roles, {seed.selectedEventIds.length}{\" \"}\r\n          events\r\n        </span>\r\n      </button>\r\n      {expanded && (\r\n        <div className=\"csv-expandable-content\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; defaultExpanded?: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "ChronicleSeedViewer"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleSeedViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::SeedModal", "name": "SeedModal", "kind": "component", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * Modal wrapper for use in chronicler wiki pages\r\n *\r\n * @param {Object} props\r\n * @param {boolean} props.isOpen\r\n * @param {Function} props.onClose\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {string} [props.title]\r\n */\r\nexport function SeedModal({\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}) {\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-modal-overlay\"\r\n      onClick={onClose}\r\n      role=\"button\"\r\n      tabIndex={0}\r\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClose(e); }}\r\n    >\r\n      <div\r\n        className=\"csv-modal-dialog\"\r\n        onClick={(e) => e.stopPropagation()}\r\n        role=\"button\"\r\n        tabIndex={0}\r\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n      >\r\n        {/* Header */}\r\n        <div className=\"csv-modal-header\">\r\n          <h3 className=\"csv-modal-title\">{title}</h3>\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-close-button\"\r\n          >\r\n            &times;\r\n          </button>\r\n        </div>\r\n\r\n        {/* Content */}\r\n        <div className=\"csv-modal-body\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n\r\n        {/* Footer */}\r\n        <div className=\"csv-modal-footer\">\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-footer-button\"\r\n          >\r\n            Close\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}", "type": "{ isOpen: boolean; onClose: Function; seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; title?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["h3", "button", "ChronicleSeedViewer"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleSeedViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "packages/shared-components/src/components/EmptyState.jsx::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "packages/shared-components/src/components/EmptyState.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/EnableToggle.jsx::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "packages/shared-components/src/components/EnableToggle.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div", "span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/EraBadges.jsx::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "packages/shared-components/src/components/EraBadges.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ExpandableCard.jsx::ExpandableCard", "name": "ExpandableCard", "kind": "component", "filePath": "packages/shared-components/src/components/ExpandableCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "div"], "hookCalls": [{"name": "useCallback", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/FormGroup.jsx::FormGroup", "name": "FormGroup", "kind": "component", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/FormGroup.jsx::FormRow", "name": "FormRow", "kind": "component", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * FormRow - Horizontal layout for multiple form groups\n */\nexport function FormRow({ children, className = '' }) {\n  return (\n    <div className={`form-row ${className}`.trim()}>\n      {children}\n    </div>\n  );\n}", "parameters": [{"name": "{ children, className = '' }", "type": "{ children: any; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/IconButton.jsx::IconButton", "name": "IconButton", "kind": "component", "filePath": "packages/shared-components/src/components/IconButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/InfoBox.jsx::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "packages/shared-components/src/components/InfoBox.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ItemRow.jsx::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "packages/shared-components/src/components/ItemRow.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/LevelSelector.jsx::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "packages/shared-components/src/components/LevelSelector.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["rect", "input"], "hookCalls": [{"name": "useState", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/LocalTextArea.jsx::LocalTextArea", "name": "LocalTextArea", "kind": "component", "filePath": "packages/shared-components/src/components/LocalTextArea.jsx", "sourceCode": "export function LocalTextArea({\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}) {\n  const externalValue = value || '';\n  const [localValue, setLocalValue] = useState(externalValue);\n  // Track focus in state so render can safely choose between local draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalValue);\n    setIsFocused(true);\n  }, [externalValue]);\n\n  // Call onChange on blur if value changed\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n    if (localValue !== externalValue) {\n      onChange(localValue);\n    }\n  }, [externalValue, localValue, onChange]);\n\n  return (\n    <textarea\n      value={isFocused ? localValue : externalValue}\n      onChange={(e) => setLocalValue(e.target.value)}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\n      placeholder={placeholder}\n      rows={rows}\n      {...rest}\n    />\n  );\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}", "type": "{ [x: string]: any; value: any; onChange: any; className?: string; placeholder: any; rows: any; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["textarea"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ModalShell.jsx::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "packages/shared-components/src/components/ModalShell.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "button", "div"], "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useRef", "useEffect", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/NumberInput.jsx::NumberInput", "name": "NumberInput", "kind": "component", "filePath": "packages/shared-components/src/components/NumberInput.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["input"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 4}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/PressureChangesEditor.jsx::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "packages/shared-components/src/components/PressureChangesEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "span", "input", "button", "option"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ReferenceDropdown.jsx::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/ReferenceDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["label", "option"], "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect", "useId"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/SearchableDropdown.jsx::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/SearchableDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/SectionHeader.jsx::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "packages/shared-components/src/components/SectionHeader.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span", "div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": ["span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkProgressBar", "name": "BulkProgressBar", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared progress bar component for bulk operations\n */\nexport function BulkProgressBar({\n  processed,\n  total,\n  status\n}) {\n  const pct = total > 0 ? Math.round(processed / total * 100) : 0;\n  let fillClass = \"bulk-progress-fill-ok\";\n  if (status === \"failed\") fillClass = \"bulk-progress-fill-failed\";else if (status === \"cancelled\") fillClass = \"bulk-progress-fill-cancelled\";\n  return <div className=\"bulk-progress-section\">\n      <div className=\"bulk-progress-header\">\n        <span className=\"bulk-progress-label\">\n          {Math.min(processed + 1, total)} / {total}\n        </span>\n        <span className=\"bulk-progress-pct\">{pct}%</span>\n      </div>\n      <div className=\"bulk-progress-track\">\n        <div className={`bulk-progress-fill ${fillClass}`} style={{\n        \"--bulk-progress-width\": `${pct}%`\n      }} />\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  processed,\n  total,\n  status\n}", "type": "{ processed: any; total: any; status: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkTerminalMessage", "name": "BulkTerminalMessage", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared terminal message component for bulk operations\n */\nexport function BulkTerminalMessage({\n  status,\n  children\n}) {\n  return <div className={`bulk-terminal-msg bulk-terminal-msg-${status}`}>\n      {children}\n    </div>;\n}", "parameters": [{"name": "{\n  status,\n  children\n}", "type": "{ status: any; children: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkFailedList", "name": "BulkFailedList", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared failed items list component for bulk operations\n */\nexport function BulkFailedList({\n  items,\n  labelKey = \"title\",\n  errorKey = \"error\"\n}) {\n  if (!items || items.length === 0) return null;\n  return <div className=\"bulk-failed-section\">\n      <div className=\"bulk-failed-label\">Failed ({items.length})</div>\n      <div className=\"bulk-failed-list\">\n        {items.map((item, i) => <div key={item.id || item.chronicleId || item.entityId || i} className=\"bulk-failed-item\">\n            <span className=\"bulk-failed-item-title\">{item[labelKey]}</span>\n            <span className=\"bulk-failed-item-error\">{item[errorKey]}</span>\n          </div>)}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  items,\n  labelKey = \"title\",\n  errorKey = \"error\"\n}", "type": "{ items: any; labelKey?: string; errorKey?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "span"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::BulkCost", "name": "BulkCost", "kind": "component", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "/**\n * Shared cost display for bulk operations\n */\nexport function BulkCost({\n  cost\n}) {\n  if (!cost || cost <= 0) return null;\n  return <div className=\"bulk-cost\">Cost: ${cost.toFixed(4)}</div>;\n}", "parameters": [{"name": "{\n  cost\n}", "type": "{ cost: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/CoverImageControls.jsx::CoverImagePreview", "name": "CoverImagePreview", "kind": "component", "filePath": "apps/illuminator/webui/src/components/CoverImageControls.jsx", "sourceCode": "export function CoverImagePreview({\n  imageId,\n  onImageClick\n}) {\n  const {\n    url,\n    loading,\n    error\n  } = useImageUrl(imageId);\n  if (!imageId) return null;\n  if (loading) {\n    return <div className=\"cic-loading\">Loading image...</div>;\n  }\n  if (error || !url) {\n    return <div className=\"cic-error\">Failed to load image{error ? `: ${error}` : \"\"}</div>;\n  }\n  return <div className=\"cic-preview-wrapper\">\n      <img src={url} alt=\"Cover\" onClick={onImageClick ? () => onImageClick(imageId, \"Cover Image\") : undefined} className={`cic-preview-img${onImageClick ? \" cic-preview-img-clickable\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }} />\n    </div>;\n}", "parameters": [{"name": "{\n  imageId,\n  onImageClick\n}", "type": "{ imageId: any; onImageClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div"], "hookCalls": [{"name": "useImageUrl", "count": 1}], "customHookCalls": ["useImageUrl"], "imports": [{"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CoverImageControls.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/CoverImageControls.jsx::CoverImageControls", "name": "CoverImageControls", "kind": "component", "filePath": "apps/illuminator/webui/src/components/CoverImageControls.jsx", "sourceCode": "export function CoverImageControls({\n  item,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  isGenerating,\n  labelWeight = 500\n}) {\n  return <div className=\"cic-layout\">\n      <div className=\"cic-info\">\n        <div className=\"cic-label\" style={{\n        \"--cic-label-weight\": labelWeight\n      }}>\n          Cover Image\n        </div>\n        <div className=\"cic-description\">\n          Generate a montage-style cover image for this chronicle.\n        </div>\n        {!item.coverImage && <div className=\"cic-status cic-status-empty\">Not run yet</div>}\n        {item.coverImage && item.coverImage.status === \"pending\" && <div className=\"cic-status cic-status-pending\">\n            Scene ready - click Generate Image to create\n          </div>}\n        {item.coverImage && item.coverImage.status === \"generating\" && <div className=\"cic-status cic-status-generating\">Generating image...</div>}\n        {item.coverImage && item.coverImage.status === \"complete\" && <div className=\"cic-status cic-status-complete\">Complete</div>}\n        {item.coverImage && item.coverImage.status === \"failed\" && <div className=\"cic-status cic-status-failed\">\n            Failed{item.coverImage.error ? `: ${item.coverImage.error}` : \"\"}\n          </div>}\n        {item.coverImage?.sceneDescription && <div className=\"cic-scene-description\">{item.coverImage.sceneDescription}</div>}\n        <CoverImagePreview imageId={item.coverImage?.generatedImageId} onImageClick={onImageClick} />\n      </div>\n      <div className=\"cic-actions\">\n        <div className=\"cic-button-row\">\n          {onGenerateCoverImageScene && <button onClick={onGenerateCoverImageScene} disabled={isGenerating} className=\"cic-action-btn\">\n              {item.coverImage ? \"Regen Scene\" : \"Gen Scene\"}\n            </button>}\n          {onGenerateCoverImage && item.coverImage && (item.coverImage.status === \"pending\" || item.coverImage.status === \"complete\" || item.coverImage.status === \"failed\") && <button onClick={onGenerateCoverImage} disabled={isGenerating} className=\"cic-action-btn\">\n                {item.coverImage.status === \"complete\" ? \"Regen Image\" : \"Gen Image\"}\n              </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  isGenerating,\n  labelWeight = 500\n}", "type": "{ item: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; isGenerating: any; labelWeight?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["div", "CoverImagePreview", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./CoverImageControls.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/FloatingPills.tsx::FloatingPills", "name": "FloatingPills", "kind": "component", "filePath": "apps/illuminator/webui/src/components/FloatingPills.tsx", "sourceCode": "export function FloatingPills({ onNavigate }: Readonly<{ onNavigate?: (tabId: string) => void }>) {\n  const pills = useFloatingPillStore((s) => s.pills);\n\n  if (pills.size === 0) return null;\n\n  return (\n    <div className=\"fp-container\">\n      {Array.from(pills.values()).map((pill) => (\n        <Pill key={pill.id} pill={pill} onNavigate={onNavigate} />\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ onNavigate }", "type": "Readonly<{ onNavigate?: (tabId: string) => void }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["Pill"], "hookCalls": [{"name": "useFloatingPillStore", "count": 1}], "customHookCalls": ["useFloatingPillStore"], "imports": [{"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore", "FloatingPill"], "category": "internal"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./FloatingPills.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::ImageSettingsSummary", "name": "ImageSettingsSummary", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Summary line component (used by EntityBrowser / ChronicleImagePanel) \u2500\n\nexport function ImageSettingsSummary({\n  settings,\n  styleLibrary,\n  onOpenSettings\n}: Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onOpenSettings: () => void;\n}>) {\n  const resolve = (id: string, list: Array<{\n    id: string;\n    name: string;\n  }> | undefined) => {\n    if (id === RANDOM_ID) return \"Random\";\n    if (id === NONE_ID) return \"None\";\n    return list?.find(s => s.id === id)?.name || id;\n  };\n  const artistic = resolve(settings.artisticStyleId, styleLibrary?.artisticStyles);\n  const composition = resolve(settings.compositionStyleId, styleLibrary?.compositionStyles);\n  const palette = resolve(settings.colorPaletteId, styleLibrary?.colorPalettes);\n\n  // Find swatch colors for current palette\n  const currentPalette = styleLibrary?.colorPalettes.find(p => p.id === settings.colorPaletteId);\n  const swatchColors = currentPalette?.swatchColors;\n  return <div className=\"isd-summary\">\n      <span className=\"isd-summary-label\">Image:</span>\n      <span className=\"isd-summary-value\">\n        {artistic} &middot; {composition} &middot; {palette}\n      </span>\n      {swatchColors && swatchColors.length > 0 && <SwatchStrip colors={swatchColors} />}\n      <button onClick={onOpenSettings} className=\"isd-summary-settings-btn\">\n        Settings\n      </button>\n    </div>;\n}", "parameters": [{"name": "{\n  settings,\n  styleLibrary,\n  onOpenSettings\n}", "type": "Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onOpenSettings: () => void;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "SwatchStrip", "button"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/imageSettings", "specifiers": ["getSizeOptions", "getQualityOptions"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS", "filterStylesForComposition", "filterCompositionsForStyle"], "category": "external"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./ImageSettingsDrawer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::ImageSettingsTrigger", "name": "ImageSettingsTrigger", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Sidebar trigger button \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport function ImageSettingsTrigger({\n  settings,\n  styleLibrary,\n  onClick\n}: Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onClick: () => void;\n}>) {\n  const resolve = (id: string, list: Array<{\n    id: string;\n    name: string;\n  }> | undefined) => {\n    if (id === RANDOM_ID) return \"Random\";\n    if (id === NONE_ID) return \"\\u2014\";\n    return list?.find(s => s.id === id)?.name || id;\n  };\n  const artistic = resolve(settings.artisticStyleId, styleLibrary?.artisticStyles);\n  const palette = resolve(settings.colorPaletteId, styleLibrary?.colorPalettes);\n  const currentPalette = styleLibrary?.colorPalettes.find(p => p.id === settings.colorPaletteId);\n  const swatchColors = currentPalette?.swatchColors;\n  return <button onClick={onClick} className=\"isd-trigger\" title=\"Open image generation settings\">\n      <div className=\"isd-trigger-header\">\n        <span className=\"isd-trigger-title\">Image Settings</span>\n      </div>\n      <div className=\"isd-trigger-detail\">\n        {swatchColors && settings.colorPaletteId !== RANDOM_ID && settings.colorPaletteId !== NONE_ID ? <SwatchStrip colors={swatchColors.slice(0, 3)} /> : null}\n        <span className=\"isd-trigger-text\">\n          {artistic} &middot; {palette}\n        </span>\n      </div>\n    </button>;\n}", "parameters": [{"name": "{\n  settings,\n  styleLibrary,\n  onClick\n}", "type": "Readonly<{\n  settings: ImageGenSettings;\n  styleLibrary: StyleLibrary | null;\n  onClick: () => void;\n}>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["span", "SwatchStrip"], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/imageSettings", "specifiers": ["getSizeOptions", "getQualityOptions"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS", "filterStylesForComposition", "filterCompositionsForStyle"], "category": "external"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./ImageSettingsDrawer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ThinkingViewer.tsx::ThinkingViewer", "name": "ThinkingViewer", "kind": "component", "filePath": "apps/illuminator/webui/src/components/ThinkingViewer.tsx", "sourceCode": "export function ThinkingViewer() {\n  const viewingTaskId = useThinkingStore((s) => s.viewingTaskId);\n  const entry = useThinkingStore((s) => (viewingTaskId ? s.entries.get(viewingTaskId) : undefined));\n  const closeViewer = useThinkingStore((s) => s.closeViewer);\n  const [activeTab, setActiveTab] = useState<ViewerTab>(\"thinking\");\n  const preRef = useRef<HTMLPreElement>(null);\n  const mouseDownOnOverlay = useRef(false);\n\n  const content = activeTab === \"thinking\" ? entry?.thinking : entry?.text;\n\n  // Auto-scroll to bottom when new content arrives\n  useEffect(() => {\n    if (preRef.current && entry?.isActive) {\n      preRef.current.scrollTop = preRef.current.scrollHeight;\n    }\n  }, [content, entry?.isActive]);\n\n  // Auto-switch to response tab when thinking finishes but text is still streaming\n  useEffect(() => {\n    if (entry && !entry.thinking && entry.text && activeTab === \"thinking\") {\n      setActiveTab(\"response\");\n    }\n  }, [entry?.thinking, entry?.text, activeTab]);\n\n  const handleCopy = useCallback(() => {\n    if (content) {\n      void navigator.clipboard.writeText(content);\n    }\n  }, [content]);\n\n  const handleOverlayMouseDown = useCallback((e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n        closeViewer();\n      }\n    },\n    [closeViewer]\n  );\n\n  if (!viewingTaskId || !entry) return null;\n\n  const thinkingLen = entry.thinking.length;\n  const textLen = entry.text.length;\n\n  return (\n    <div\n      className=\"tv-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div\n        className=\"tv-dialog\"\n      >\n        {/* Header */}\n        <div\n          className=\"tv-header\"\n        >\n          <div className=\"tv-header-left\">\n            <h3 className=\"tv-header-title\">LLM Stream</h3>\n            {entry.isActive && (\n              <span\n                className=\"tv-streaming-label\"\n              >\n                streaming...\n              </span>\n            )}\n          </div>\n          <div className=\"tv-header-actions\">\n            <button\n              onClick={handleCopy}\n              className=\"illuminator-button tv-copy-button\"\n              disabled={!content}\n            >\n              Copy\n            </button>\n            <button\n              onClick={closeViewer}\n              className=\"illuminator-button tv-close-button\"\n            >\n              &times;\n            </button>\n          </div>\n        </div>\n\n        {/* Subtitle + tabs */}\n        <div\n          className=\"tv-subtitle-bar\"\n        >\n          <span className=\"tv-subtitle-label\">\n            {entry.entityName} &middot; {entry.taskType}\n          </span>\n          <div className=\"tv-tab-group\">\n            <button\n              onClick={() => setActiveTab(\"thinking\")}\n              className={`tv-tab-button ${activeTab === \"thinking\" ? \"tv-tab-button-active\" : \"tv-tab-button-inactive\"}`}\n            >\n              Thinking{\" \"}\n              {thinkingLen > 0 && <span className=\"tv-size-label\">({formatSize(thinkingLen)})</span>}\n            </button>\n            <button\n              onClick={() => setActiveTab(\"response\")}\n              className={`tv-tab-button ${activeTab === \"response\" ? \"tv-tab-button-active\" : \"tv-tab-button-inactive\"}`}\n            >\n              Response{\" \"}\n              {textLen > 0 && <span className=\"tv-size-label\">({formatSize(textLen)})</span>}\n            </button>\n          </div>\n        </div>\n\n        {/* Body */}\n        <pre\n          ref={preRef}\n          className=\"tv-body\"\n        >\n          {content || (() => {\n            if (entry.isActive) {\n              return activeTab === \"thinking\"\n                ? \"Waiting for thinking content...\"\n                : \"Waiting for response text...\";\n            }\n            return activeTab === \"thinking\"\n              ? \"No thinking content (thinking may be disabled for this call type).\"\n              : \"No response text received.\";\n          })()}\n        </pre>\n      </div>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": ["h3", "span", "button", "pre"], "hookCalls": [{"name": "useThinkingStore", "count": 3}, {"name": "useState", "count": 1}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 3}], "customHookCalls": ["useThinkingStore"], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useCallback", "useEffect"], "category": "framework"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "./ThinkingViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useBackportFlow.js::useBackportFlow", "name": "useBackportFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBackportFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useBackportFlow({\n  projectId,\n  simulationRunId,\n  getEntityContextsForRevision,\n  reloadEntities,\n  setChronicleRefreshTrigger,\n}) {\n  const {\n    run: backportRun,\n    isActive: isBackportActive,\n    chronicleId: backportChronicleId,\n    startBackport,\n    togglePatchDecision: toggleBackportPatchDecision,\n    updateAnchorPhrase: updateBackportAnchorPhrase,\n    applyAccepted: applyAcceptedBackportPatches,\n    cancelBackport,\n  } = useChronicleLoreBackport(getEntityContextsForRevision);\n\n  const assembleContextForChronicle = useCallback(\n    (chronicleId) =>\n      assembleChronicleContext(\n        projectId,\n        simulationRunId,\n        chronicleId,\n        getEntityContextsForRevision\n      ),\n    [projectId, simulationRunId, getEntityContextsForRevision]\n  );\n\n  const [backportConfig, setBackportConfig] = useState(null);\n  const backportSentEntityIdsRef = useRef(null);\n\n  const handleBackportLore = useCallback(\n    async (chronicleId) => {\n      const context = await assembleContextForChronicle(chronicleId);\n      if (!context) {\n        console.warn(\"[Backport] Could not assemble context for chronicle:\", chronicleId);\n        return;\n      }\n      setBackportConfig(context);\n    },\n    [assembleContextForChronicle]\n  );\n\n  const handleBackportConfigStart = useCallback(\n    (selectedEntityIds, customInstructions) => {\n      runBackportConfigStart(\n        backportConfig,\n        projectId,\n        simulationRunId,\n        selectedEntityIds,\n        customInstructions,\n        backportSentEntityIdsRef,\n        startBackport,\n        setBackportConfig\n      );\n    },\n    [backportConfig, projectId, simulationRunId, startBackport]\n  );\n\n  const handleAcceptBackport = useCallback(async () => {\n    await runAcceptBackport(\n      backportChronicleId,\n      applyAcceptedBackportPatches,\n      reloadEntities,\n      backportSentEntityIdsRef,\n      setChronicleRefreshTrigger\n    );\n  }, [\n    applyAcceptedBackportPatches,\n    backportChronicleId,\n    reloadEntities,\n    setChronicleRefreshTrigger,\n  ]);\n\n  const handleMarkEntityNotNeeded = useCallback(\n    async (entityIds) => {\n      await runMarkEntityNotNeeded(\n        backportConfig,\n        entityIds,\n        setBackportConfig,\n        setChronicleRefreshTrigger\n      );\n    },\n    [backportConfig, setChronicleRefreshTrigger]\n  );\n\n  const {\n    bulkBackportProgress,\n    isBulkBackportActive,\n    showBulkBackportModal,\n    handleStartBulkBackport,\n    handleConfirmBulkBackport,\n    handleCancelBulkBackport,\n    handleCloseBulkBackport,\n  } = useBulkBackportSetup({\n    assembleContextForChronicle,\n    reloadEntities,\n    setChronicleRefreshTrigger,\n    simulationRunId,\n    projectId,\n  });\n\n  return {\n    backportRun,\n    isBackportActive,\n    backportChronicleId,\n    toggleBackportPatchDecision,\n    updateBackportAnchorPhrase,\n    cancelBackport,\n    backportConfig,\n    setBackportConfig,\n    handleBackportLore,\n    handleBackportConfigStart,\n    handleAcceptBackport,\n    handleMarkEntityNotNeeded,\n    bulkBackportProgress,\n    isBulkBackportActive,\n    showBulkBackportModal,\n    handleStartBulkBackport,\n    handleConfirmBulkBackport,\n    handleCancelBulkBackport,\n    handleCloseBulkBackport,\n    assembleContextForChronicle,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  getEntityContextsForRevision,\n  reloadEntities,\n  setChronicleRefreshTrigger,\n}", "type": "{ projectId: any; simulationRunId: any; getEntityContextsForRevision: any; reloadEntities: any; setChronicleRefreshTrigger: any; }", "optional": false}], "returnType": "{ backportRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isBackportActive: boolean; backportChronicleId: string; toggleBackportPatchDecision: (entityId: string, accepted: boolean) => Promise<void>; updateBackportAnchorPhrase: (entityId: string, anchorPhrase: string) => Promise<void>; cancelBackport: () => void; backportConfig: any; setBackportConfig: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<any>; handleBackportLore: (chronicleId: any) => Promise<void>; handleBackportConfigStart: (selectedEntityIds: any, customInstructions: any) => void; handleAcceptBackport: () => Promise<void>; handleMarkEntityNotNeeded: (entityIds: any) => Promise<void>; bulkBackportProgress: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useBulkBackport\").BulkBackportProgress; isBulkBackportActive: boolean; showBulkBackportModal: boolean; handleStartBulkBackport: () => Promise<void>; handleConfirmBulkBackport: () => void; handleCancelBulkBackport: () => void; handleCloseBulkBackport: () => void; assembleContextForChronicle: (chronicleId: any) => Promise<{ chronicleId: any; chronicleTitle: string; entities: any[]; chronicleText: string; perspectiveSynthesisJson: string; perEntityStatus: {}; }>; }", "jsxLeafElements": [], "hookCalls": [{"name": "useChronicleLoreBackport", "count": 1}, {"name": "useCallback", "count": 5}, {"name": "useState", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useBulkBackportSetup", "count": 1}], "customHookCalls": ["useBulkBackportSetup", "useChronicleLoreBackport"], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "./useChronicleLoreBackport", "specifiers": ["useChronicleLoreBackport"], "category": "internal"}, {"source": "./useBulkBackport", "specifiers": ["useBulkBackport"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "getChroniclesForSimulation", "updateChronicleEntityBackportStatus"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["computeBackportProgress"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useBulkBackport.ts::useBulkBackport", "name": "useBulkBackport", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBulkBackport.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useBulkBackport(deps: {\n  assembleContextForChronicle: (chronicleId: string) => Promise<BackportContext | null>;\n  applyPatches: (\n    patches: SummaryRevisionPatch[],\n    chronicleId: string,\n    sentEntityIds: string[]\n  ) => Promise<void>;\n  getEligibleChronicleIds: (\n    simulationRunId: string\n  ) => Promise<Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>>;\n}): UseBulkBackportReturn {\n  const [progress, setProgress] = useState<BulkBackportProgress>(IDLE_PROGRESS);\n  const cancelledRef = useRef(false);\n  const activeRef = useRef(false);\n\n  // Keep a ref to deps so the async loop always calls the latest callbacks\n  const depsRef = useRef(deps);\n  useEffect(() => {\n    depsRef.current = deps;\n  }, [deps]);\n\n  // Stash scan results so confirmBulkBackport can use them\n  const scanRef = useRef<{\n    simulationRunId: string;\n    projectId: string;\n    eligible: Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>;\n    chronicleContexts: Array<{\n      context: BackportContext;\n      pendingEntities: RevisionEntityContext[];\n    }>;\n  } | null>(null);\n\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__chronicle_lore_backport__\",\n        name: \"Chronicle Lore Backport\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"chronicleLoreBackport\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  const pollForCompletion = useCallback(\n    async (runId: string): Promise<{ patches: SummaryRevisionPatch[]; cost: number } | null> => {\n      while (true) {\n        if (cancelledRef.current) return null;\n        await sleep(POLL_INTERVAL_MS);\n        if (cancelledRef.current) return null;\n\n        const run = await getRevisionRun(runId);\n        if (!run) return null;\n\n        if (run.status === \"run_reviewing\" || run.status === \"batch_reviewing\") {\n          const patches: SummaryRevisionPatch[] = [];\n          for (const batch of run.batches) {\n            for (const patch of batch.patches) {\n              patches.push(patch);\n            }\n          }\n          const cost = run.totalActualCost || 0;\n          await deleteRevisionRun(runId);\n          return { patches, cost };\n        }\n\n        if (run.status === \"failed\") {\n          const error = run.batches[0]?.error || \"Unknown error\";\n          await deleteRevisionRun(runId);\n          throw new Error(error);\n        }\n      }\n    },\n    []\n  );\n\n  // Phase 1: Scan all eligible chronicles and build entity summary for confirmation\n  const prepareBulkBackport = useCallback(async (simulationRunId: string, projectId: string) => {\n    if (activeRef.current) return;\n\n    const eligible = await depsRef.current.getEligibleChronicleIds(simulationRunId);\n    if (eligible.length === 0) return;\n\n    // Scan each chronicle to get actual pending entities\n    const entityChronicleCount = new Map<\n      string,\n      { entity: RevisionEntityContext; count: number }\n    >();\n    const chronicleContexts: Array<{\n      context: BackportContext;\n      pendingEntities: RevisionEntityContext[];\n    }> = [];\n\n    for (const { chronicleId } of eligible) {\n      const context = await depsRef.current.assembleContextForChronicle(chronicleId);\n      if (!context) continue;\n\n      const pendingEntities = context.entities.filter((e) => !context.perEntityStatus[e.id]);\n      if (pendingEntities.length === 0) continue;\n\n      chronicleContexts.push({ context, pendingEntities });\n\n      for (const entity of pendingEntities) {\n        const existing = entityChronicleCount.get(entity.id);\n        if (existing) {\n          existing.count++;\n        } else {\n          entityChronicleCount.set(entity.id, { entity, count: 1 });\n        }\n      }\n    }\n\n    if (chronicleContexts.length === 0) return;\n\n    // Build entity summary sorted by chronicle count (descending), then name\n    const entitySummary: BulkBackportEntitySummary[] = Array.from(entityChronicleCount.values())\n      .map(({ entity, count }) => ({\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n        entitySubtype: entity.subtype,\n        chronicleCount: count,\n      }))\n      .sort(\n        (a, b) => b.chronicleCount - a.chronicleCount || a.entityName.localeCompare(b.entityName)\n      );\n\n    const chronicleProgress: BulkBackportChronicleProgress[] = chronicleContexts.map(\n      ({ context, pendingEntities }) => ({\n        chronicleId: context.chronicleId,\n        chronicleTitle: context.chronicleTitle,\n        totalEntities: pendingEntities.length,\n        processedEntities: 0,\n        totalBatches: Math.ceil(pendingEntities.length / MAX_BATCH_SIZE),\n        completedBatches: 0,\n        status: \"pending\" as const,\n      })\n    );\n\n    const totalEntities = chronicleProgress.reduce((sum, c) => sum + c.totalEntities, 0);\n\n    // Stash for confirmBulkBackport\n    scanRef.current = { simulationRunId, projectId, eligible, chronicleContexts };\n\n    setProgress({\n      status: \"confirming\",\n      chronicles: chronicleProgress,\n      currentChronicleIndex: 0,\n      totalEntities,\n      processedEntities: 0,\n      totalCost: 0,\n      entitySummary,\n    });\n  }, []);\n\n  // Phase 2: User confirmed \u2014 run the processing loop\n  const confirmBulkBackport = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    // Clear entity summary and transition to running\n    setProgress((p) => ({ ...p, status: \"running\", entitySummary: undefined }));\n\n    // Run the async processing loop\n    void (async () => {\n      try {\n        const { simulationRunId, projectId, chronicleContexts } = scan;\n\n        // Re-read progress for chronicle list (was set in prepare)\n        const chronicleProgress: BulkBackportChronicleProgress[] = chronicleContexts.map(\n          ({ context, pendingEntities }) => ({\n            chronicleId: context.chronicleId,\n            chronicleTitle: context.chronicleTitle,\n            totalEntities: pendingEntities.length,\n            processedEntities: 0,\n            totalBatches: Math.ceil(pendingEntities.length / MAX_BATCH_SIZE),\n            completedBatches: 0,\n            status: \"pending\" as const,\n          })\n        );\n\n        let globalProcessed = 0;\n        let globalCost = 0;\n\n        for (let ci = 0; ci < chronicleContexts.length; ci++) {\n          if (cancelledRef.current) break;\n\n          const { context: originalContext } = chronicleContexts[ci];\n          const chronicleId = originalContext.chronicleId;\n\n          // Assemble fresh context (entity descriptions may have been updated by prior batches)\n          const context = await depsRef.current.assembleContextForChronicle(chronicleId);\n          if (!context) {\n            chronicleProgress[ci] = {\n              ...chronicleProgress[ci],\n              status: \"complete\",\n              totalEntities: 0,\n              totalBatches: 0,\n            };\n            setProgress((p) => ({\n              ...p,\n              chronicles: [...chronicleProgress],\n              currentChronicleIndex: ci,\n            }));\n            continue;\n          }\n\n          const pendingEntities = context.entities.filter((e) => !context.perEntityStatus[e.id]);\n          if (pendingEntities.length === 0) {\n            chronicleProgress[ci] = {\n              ...chronicleProgress[ci],\n              status: \"complete\",\n              totalEntities: 0,\n              totalBatches: 0,\n            };\n            setProgress((p) => ({\n              ...p,\n              chronicles: [...chronicleProgress],\n              currentChronicleIndex: ci,\n            }));\n            continue;\n          }\n\n          const chunks = chunkEntities(pendingEntities, MAX_BATCH_SIZE);\n\n          chronicleProgress[ci] = {\n            ...chronicleProgress[ci],\n            status: \"running\",\n            totalEntities: pendingEntities.length,\n            totalBatches: chunks.length,\n            completedBatches: 0,\n            processedEntities: 0,\n          };\n          setProgress((p) => ({\n            ...p,\n            chronicles: [...chronicleProgress],\n            currentChronicleIndex: ci,\n          }));\n\n          let chronicleFailed = false;\n\n          for (let bi = 0; bi < chunks.length; bi++) {\n            if (cancelledRef.current) break;\n\n            const chunk = chunks[bi];\n            const runId = generateRevisionRunId();\n\n            await createRevisionRun(\n              runId,\n              projectId,\n              simulationRunId,\n              [\n                {\n                  culture: \"cast\",\n                  entityIds: chunk.map((e) => e.id),\n                  status: \"pending\" as const,\n                  patches: [],\n                },\n              ],\n              {\n                worldDynamicsContext: context.chronicleText,\n                staticPagesContext: context.perspectiveSynthesisJson,\n                schemaContext: \"\",\n                revisionGuidance: \"\",\n              }\n            );\n\n            dispatchBatch(runId, chunk);\n\n            try {\n              const result = await pollForCompletion(runId);\n              if (cancelledRef.current || !result) break;\n\n              const batchEntityIds = chunk.map((e) => e.id);\n              if (result.patches.length > 0) {\n                await depsRef.current.applyPatches(result.patches, chronicleId, batchEntityIds);\n              } else {\n                await depsRef.current.applyPatches([], chronicleId, batchEntityIds);\n              }\n\n// ... (truncated)", "parameters": [{"name": "deps", "type": "{\n  assembleContextForChronicle: (chronicleId: string) => Promise<BackportContext | null>;\n  applyPatches: (\n    patches: SummaryRevisionPatch[],\n    chronicleId: string,\n    sentEntityIds: string[]\n  ) => Promise<void>;\n  getEligibleChronicleIds: (\n    simulationRunId: string\n  ) => Promise<Array<{ chronicleId: string; chronicleTitle: string; pendingCount: number }>>;\n}", "optional": false}], "returnType": "UseBulkBackportReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 4}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 5}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useBulkHistorian.ts::useBulkHistorian", "name": "useBulkHistorian", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useBulkHistorian.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useBulkHistorian(deps: {\n  buildReviewContext: (\n    entityId: string,\n    tone: HistorianTone\n  ) => Promise<HistorianReviewConfig | null>;\n  buildEditionContext: (\n    entityId: string,\n    tone: HistorianTone,\n    reEdition?: boolean\n  ) => Promise<HistorianEditionConfig | null>;\n  applyReviewNotes: (entityId: string, notes: HistorianNote[]) => Promise<void>;\n  applyEditionPatches: (patches: SummaryRevisionPatch[]) => Promise<string[]>;\n  reloadEntities: (entityIds: string[]) => Promise<void>;\n  getEntityNav: (entityId: string) => EntityNavItem | undefined;\n}): UseBulkHistorianReturn {\n  const [progress, setProgress] = useState<BulkHistorianProgress>(IDLE_PROGRESS);\n  const cancelledRef = useRef(false);\n  const activeRef = useRef(false);\n\n  const depsRef = useRef(deps);\n  useEffect(() => {\n    depsRef.current = deps;\n  }, [deps]);\n\n  // Stash scan results so confirmBulkHistorian can use them\n  const scanRef = useRef<{\n    operation: BulkHistorianOperation;\n    tone: HistorianTone;\n    entities: BulkHistorianEntitySummary[];\n    reEdition?: boolean;\n  } | null>(null);\n\n  // Cancellation check for shared poll helper\n  const isCancelled = useCallback(() => cancelledRef.current, []);\n\n  // Dispatch a historian edition task\n  const dispatchEditionTask = useCallback((runId: string) => {\n    getEnqueue()([\n      {\n        entity: {\n          id: \"__historian_edition__\",\n          name: \"Historian Edition\",\n          kind: \"system\",\n          subtype: \"\",\n          prominence: \"\",\n          culture: \"\",\n          status: \"active\",\n          description: \"\",\n          tags: {},\n        },\n        type: \"historianEdition\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: runId,\n      },\n    ]);\n  }, []);\n\n  // Poll edition run for completion\n  const pollEditionCompletion = useCallback(\n    async (runId: string): Promise<{ patches: SummaryRevisionPatch[]; cost: number } | null> => {\n      while (true) {\n        if (cancelledRef.current) return null;\n        await sleep(POLL_INTERVAL_MS);\n        if (cancelledRef.current) return null;\n\n        const run = await getRevisionRun(runId);\n        if (!run) return null;\n\n        if (run.status === \"run_reviewing\" || run.status === \"batch_reviewing\") {\n          const patches: SummaryRevisionPatch[] = [];\n          for (const batch of run.batches) {\n            for (const patch of batch.patches) {\n              patches.push(patch);\n            }\n          }\n          const cost = run.totalActualCost || 0;\n          await deleteRevisionRun(runId);\n          return { patches, cost };\n        }\n\n        if (run.status === \"failed\") {\n          const error = run.batches[0]?.error || \"Unknown error\";\n          await deleteRevisionRun(runId);\n          throw new Error(error);\n        }\n      }\n    },\n    []\n  );\n\n  // Phase 1: Build entity summary for confirmation\n  const prepareBulkHistorian = useCallback(\n    (\n      operation: BulkHistorianOperation,\n      tone: HistorianTone,\n      entityIds: string[],\n      reEdition?: boolean\n    ) => {\n      if (activeRef.current) return;\n\n      // Resolve nav items and build summary\n      const resolved: Array<{ nav: EntityNavItem; summary: BulkHistorianEntitySummary }> = [];\n      for (const id of entityIds) {\n        const nav = depsRef.current.getEntityNav(id);\n        if (!nav) continue;\n        // Clear: needs historian notes. Review/edition: needs a description.\n        if (operation === \"clear\" ? !nav.hasHistorianNotes : !nav.hasDescription) continue;\n        resolved.push({\n          nav,\n          summary: {\n            entityId: nav.id,\n            entityName: nav.name,\n            entityKind: nav.kind,\n            entitySubtype: nav.subtype,\n            tokenEstimate:\n              operation === \"edition\"\n                ? Math.ceil((nav.descriptionWordCount || 0) * 1.35)\n                : undefined,\n          },\n        });\n      }\n\n      // For review: assign tones via stratified cycling.\n      // Sort by (kind, culture, prominence) so similar entities are adjacent,\n      // then cycle tones globally \u2014 each stratum starts where the previous left off,\n      // preventing any tone from being over-represented within a stratum.\n      if (operation === \"review\") {\n        resolved.sort(\n          (a, b) =>\n            a.nav.kind.localeCompare(b.nav.kind) ||\n            a.nav.culture.localeCompare(b.nav.culture) ||\n            a.nav.prominence - b.nav.prominence\n        );\n        for (let i = 0; i < resolved.length; i++) {\n          resolved[i].summary.tone = TONE_CYCLE[i % TONE_CYCLE.length];\n        }\n      }\n\n      const entities = resolved.map((r) => r.summary);\n\n      if (entities.length === 0) return;\n\n      scanRef.current = { operation, tone, entities, reEdition };\n\n      setProgress({\n        status: \"confirming\",\n        operation,\n        tone,\n        entities,\n        totalEntities: entities.length,\n        processedEntities: 0,\n        currentEntityName: \"\",\n        totalCost: 0,\n        failedEntities: [],\n      });\n    },\n    []\n  );\n\n  // Allow tone change during confirmation (edition mode)\n  const setTone = useCallback((tone: HistorianTone) => {\n    if (scanRef.current) {\n      scanRef.current.tone = tone;\n    }\n    setProgress((p) => (p.status === \"confirming\" ? { ...p, tone } : p));\n  }, []);\n\n  // Phase 2: Process all entities sequentially\n  const confirmBulkHistorian = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    setProgress((p) => ({ ...p, status: \"running\" }));\n\n    void (async () => {\n      try {\n        const { operation, tone, entities, reEdition } = scan;\n\n        let globalProcessed = 0;\n        let globalCost = 0;\n        const failedEntities: Array<{ entityId: string; entityName: string; error: string }> = [];\n\n        if (operation === \"clear\") {\n          // Clear all historian notes \u2014 no enrichment dispatch, just DB writes\n          for (const entity of entities) {\n            if (cancelledRef.current) break;\n\n            setProgress((p) => ({ ...p, currentEntityName: entity.entityName }));\n\n            try {\n              await depsRef.current.applyReviewNotes(entity.entityId, []);\n              await depsRef.current.reloadEntities([entity.entityId]);\n              globalProcessed++;\n              setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n            } catch (err) {\n              globalProcessed++;\n              failedEntities.push({\n                entityId: entity.entityId,\n                entityName: entity.entityName,\n                error: err instanceof Error ? err.message : String(err),\n              });\n              setProgress((p) => ({\n                ...p,\n                processedEntities: globalProcessed,\n                failedEntities: [...failedEntities],\n              }));\n            }\n          }\n        } else {\n          // Review or edition \u2014 shuffle then process sequentially\n          const shuffled = [...entities];\n          for (let s = shuffled.length - 1; s > 0; s--) {\n            // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for processing order\n            const j = Math.floor(Math.random() * (s + 1));\n            [shuffled[s], shuffled[j]] = [shuffled[j], shuffled[s]];\n          }\n\n          for (let i = 0; i < shuffled.length; i++) {\n            if (cancelledRef.current) break;\n\n            const entity = shuffled[i];\n            const entityTone = operation === \"review\" && entity.tone ? entity.tone : tone;\n\n            setProgress((p) => ({\n              ...p,\n              currentEntityName: entity.entityName,\n              currentEntityTone: entityTone,\n            }));\n\n            try {\n              if (operation === \"review\") {\n                const config = await depsRef.current.buildReviewContext(\n                  entity.entityId,\n                  entityTone\n                );\n                if (!config) {\n                  globalProcessed++;\n                  setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n                  continue;\n                }\n\n                const runId = generateHistorianRunId();\n                const now = Date.now();\n\n                await createHistorianRun({\n                  runId,\n                  projectId: config.projectId,\n                  simulationRunId: config.simulationRunId,\n                  status: \"pending\",\n                  tone: config.tone,\n                  targetType: config.targetType,\n                  targetId: config.targetId,\n                  targetName: config.targetName,\n                  sourceText: config.sourceText,\n                  notes: [],\n                  noteDecisions: {},\n                  contextJson: config.contextJson,\n                  previousNotesJson: config.previousNotesJson,\n                  historianConfigJson: JSON.stringify(config.historianConfig),\n                  inputTokens: 0,\n                  outputTokens: 0,\n                  actualCost: 0,\n                  createdAt: now,\n                  updatedAt: now,\n                });\n\n                sharedDispatchReview(runId);\n\n                const result = await sharedPollReview(runId, isCancelled);\n                if (cancelledRef.current || !result) break;\n\n                if (result.notes.length > 0) {\n                  await depsRef.current.applyReviewNotes(entity.entityId, result.notes);\n                }\n                globalCost += result.cost;\n              } else {\n                // edition\n                const config = await depsRef.current.buildEditionContext(\n                  entity.entityId,\n                  entityTone,\n                  reEdition\n                );\n                if (!config) {\n                  globalProcessed++;\n                  setProgress((p) => ({ ...p, processedEntities: globalProcessed }));\n                  continue;\n                }\n\n                const runId = generateRevisionRunId();\n\n                await createRevisionRun(\n                  runId,\n                  config.projectId,\n// ... (truncated)", "parameters": [{"name": "deps", "type": "{\n  buildReviewContext: (\n    entityId: string,\n    tone: HistorianTone\n  ) => Promise<HistorianReviewConfig | null>;\n  buildEditionContext: (\n    entityId: string,\n    tone: HistorianTone,\n    reEdition?: boolean\n  ) => Promise<HistorianEditionConfig | null>;\n  applyReviewNotes: (entityId: string, notes: HistorianNote[]) => Promise<void>;\n  applyEditionPatches: (patches: SummaryRevisionPatch[]) => Promise<string[]>;\n  reloadEntities: (entityIds: string[]) => Promise<void>;\n  getEntityNav: (e...", "optional": false}], "returnType": "UseBulkHistorianReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 4}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 7}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/entityNav", "specifiers": ["EntityNavItem"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianTone", "HistorianNote"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}, {"source": "./useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionPatch"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "generateHistorianRunId"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}, {"source": "../lib/db/historianRunHelpers", "specifiers": ["dispatchReviewTask as sharedDispatchReview", "pollReviewCompletion as sharedPollReview", "sleep", "POLL_INTERVAL_MS"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useChronicleActions.ts::useChronicleActions", "name": "useChronicleActions", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleActions.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useChronicleActions() {\n  const getChronicle = useCallback(\n    (chronicleId: string): ChronicleRecord | undefined =>\n      useChronicleStore.getState().cache.get(chronicleId),\n    []\n  );\n\n  const generateV2 = useCallback(\n    (\n      chronicleId: string,\n      context: ChronicleGenerationContext,\n      metadata: ChronicleMetadata | undefined\n    ) => {\n      if (!context.focus) {\n        console.error(\"[Chronicle V2] Focus context required\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle V2] Narrative style required for generation\");\n        return;\n      }\n\n      const chronicle = getChronicle(chronicleId);\n      const entity = buildEntityRefFromContext(chronicleId, context, chronicle);\n\n      getEnqueue()([\n        {\n          entity,\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"generate_v2\",\n          chronicleId: metadata?.chronicleId || chronicleId,\n          chronicleMetadata: metadata,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateSummary = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent) {\n        console.error(\"[Chronicle] Summary refinements are only available before acceptance\");\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to summarize\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required to generate summary\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromContext(chronicleId, context, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"summary\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateTitle = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      const content = chronicle.finalContent || chronicle.assembledContent;\n      if (!content) {\n        console.error(\"[Chronicle] No content to generate title from\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"title\" as ChronicleStep,\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const generateImageRefs = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent) {\n        console.error(\"[Chronicle] Image refs are only available before acceptance\");\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to draft image refs\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required to generate image refs\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromContext(chronicleId, context, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleContext: context,\n          chronicleStep: \"image_refs\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const regenerateWithSampling = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent || chronicle.status === \"complete\") {\n        console.error(\"[Chronicle] Sampling regeneration is only available before acceptance\");\n        return;\n      }\n      if (!chronicle.generationSystemPrompt || !chronicle.generationUserPrompt) {\n        console.error(\"[Chronicle] Stored prompts missing; cannot regenerate\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"regenerate_temperature\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const compareVersions = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to compare\");\n        return;\n      }\n      const historyCount = chronicle.generationHistory?.length || 0;\n      if (historyCount < 2) {\n        console.error(\"[Chronicle] Need at least 2 versions to compare\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"compare\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const combineVersions = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to combine\");\n        return;\n      }\n      const historyCount = chronicle.generationHistory?.length || 0;\n      if (historyCount < 2) {\n        console.error(\"[Chronicle] Need at least 2 versions to combine\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"combine\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const copyEdit = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content to copy-edit\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"copy_edit\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  const temporalCheck = useCallback(\n    (chronicleId: string) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (!chronicle.assembledContent) {\n        console.error(\"[Chronicle] No assembled content for temporal check\");\n        return;\n      }\n      if (!chronicle.perspectiveSynthesis?.temporalNarrative) {\n        console.error(\"[Chronicle] No temporal narrative available for temporal check\");\n        return;\n      }\n\n      getEnqueue()([\n        {\n          entity: buildEntityRefFromRecord(chronicleId, chronicle),\n          type: \"entityChronicle\" as EnrichmentType,\n          prompt: \"\",\n          chronicleStep: \"temporal_check\",\n          chronicleId,\n        },\n      ]);\n    },\n    [getChronicle]\n  );\n\n  /**\n   * Full regeneration with new perspective synthesis.\n   * Creates a new version by running the complete generation pipeline.\n   * Unlike sampling regeneration, this generates fresh perspective synthesis.\n   */\n  const regenerateFull = useCallback(\n    (chronicleId: string, context: ChronicleGenerationContext) => {\n      const chronicle = getChronicle(chronicleId);\n      if (!chronicle) {\n        console.error(\"[Chronicle] No chronicle found for chronicleId\", chronicleId);\n        return;\n      }\n      if (chronicle.finalContent || chronicle.status === \"complete\") {\n        console.error(\"[Chronicle] Full regeneration requires unpublishing first\");\n        return;\n      }\n      if (!context.narrativeStyle) {\n        console.error(\"[Chronicle] Narrative style required for full regeneration\");\n        return;\n// ... (truncated)", "parameters": [], "returnType": "{ generateV2: (chronicleId: string, context: ChronicleGenerationContext, metadata: ChronicleMetadata | undefined) => void; generateSummary: (chronicleId: string, context: ChronicleGenerationContext) => void; generateTitle: (chronicleId: string) => void; generateImageRefs: (chronicleId: string, context: ChronicleGenerationContext) => void; regenerateWithSampling: (chronicleId: string) => void; regenerateFull: (chronicleId: string, context: ChronicleGenerationContext) => void; regenerateCreative: (chronicleId: string, context: ChronicleGenerationContext) => void; compareVersions: (chronicleId: string) => void; combineVersions: (chronicleId: string) => void; copyEdit: (chronicleId: string) => void; temporalCheck: (chronicleId: string) => void; quickCheck: (chronicleId: string) => void; }", "jsxLeafElements": [], "hookCalls": [{"name": "useCallback", "count": 13}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/chronicleTypes", "specifiers": ["ChronicleGenerationContext", "ChronicleSampling"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType", "ChronicleStep"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["ChronicleRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useChronicleLoreBackport.ts::useChronicleLoreBackport", "name": "useChronicleLoreBackport", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleLoreBackport.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useChronicleLoreBackport(\n  getEntityContexts: (entityIds: string[]) => RevisionEntityContext[]\n): UseChronicleLoreBackportReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const [chronicleId, setChronicleId] = useState<string | null>(null);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for the single batch\n  const dispatchBatch = useCallback(\n    (runId: string, batchEntityContexts: RevisionEntityContext[]) => {\n      const sentinelEntity = {\n        id: \"__chronicle_lore_backport__\",\n        name: \"Chronicle Lore Backport\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      getEnqueue()([\n        {\n          entity: sentinelEntity,\n          type: \"chronicleLoreBackport\" as EnrichmentType,\n          prompt: JSON.stringify(batchEntityContexts),\n          chronicleId: runId,\n        },\n      ]);\n    },\n    []\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new backport session\n  const startBackport = useCallback(\n    async (config: ChronicleLoreBackportConfig) => {\n      const runId = generateRevisionRunId();\n\n      // Single batch with all cast entity IDs\n      const batches = [\n        {\n          culture: \"cast\",\n          entityIds: config.entities.map((e) => e.id),\n          status: \"pending\" as const,\n          patches: [],\n        },\n      ];\n\n      // Create run in IndexedDB\n      // Repurpose context fields: worldDynamicsContext = chronicle text, staticPagesContext = perspective JSON\n      // revisionGuidance = custom user instructions for the backport\n      const newRun = await createRevisionRun(\n        runId,\n        config.projectId,\n        config.simulationRunId,\n        batches,\n        {\n          worldDynamicsContext: config.chronicleText,\n          staticPagesContext: config.perspectiveSynthesisJson,\n          schemaContext: \"\",\n          revisionGuidance: config.customInstructions || \"\",\n        }\n      );\n\n      setRun(newRun);\n      setIsActive(true);\n      setChronicleId(config.chronicleId);\n\n      // Dispatch the single batch \u2014 use config.entities directly to preserve isLens flags\n      dispatchBatch(runId, config.entities);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchBatch, startPolling, getEntityContexts]\n  );\n\n  // Toggle accept/reject for a specific entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Update anchor phrase for a patch (user override)\n  const updateAnchorPhrase = useCallback(\n    async (entityId: string, anchorPhrase: string) => {\n      if (!run) return;\n\n      // Update the patch in the batch\n      const updatedBatches = run.batches.map((batch) => ({\n        ...batch,\n        patches: batch.patches.map((p) => (p.entityId === entityId ? { ...p, anchorPhrase } : p)),\n      }));\n      await updateRevisionRun(run.runId, { batches: updatedBatches });\n      setRun((prev) => (prev ? { ...prev, batches: updatedBatches } : null));\n    },\n    [run]\n  );\n\n  // Apply all accepted patches and return them\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect all patches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    setChronicleId(null);\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelBackport = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    setChronicleId(null);\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    chronicleId,\n    startBackport,\n    togglePatchDecision,\n    updateAnchorPhrase,\n    applyAccepted,\n    cancelBackport,\n  };\n}", "parameters": [{"name": "getEntityContexts", "type": "(entityIds: string[]) => RevisionEntityContext[]", "optional": false}], "returnType": "UseChronicleLoreBackportReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 3}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 8}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionPatch", "RevisionEntityContext"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useChronicleQueueWatcher.ts::useChronicleQueueWatcher", "name": "useChronicleQueueWatcher", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useChronicleQueueWatcher.ts", "sourceCode": "export function useChronicleQueueWatcher(queue: QueueItem[]): void {\n  const processedRef = useRef<Map<string, ProcessedStatus>>(new Map());\n  const activeRef = useRef(true);\n\n  useEffect(() => {\n    activeRef.current = true;\n    return () => {\n      activeRef.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const processed = processedRef.current;\n\n    // Clear processed markers if task is retried (queued/running again).\n    for (const item of queue) {\n      if ((item.status === \"queued\" || item.status === \"running\") && processed.has(item.id)) {\n        processed.delete(item.id);\n      }\n    }\n\n    // Prune processed entries for tasks no longer in queue.\n    const queueIds = new Set(queue.map((item) => item.id));\n    for (const id of processed.keys()) {\n      if (!queueIds.has(id)) processed.delete(id);\n    }\n\n    const chronicleTasks = queue.filter(\n      (item) =>\n        item.type === \"entityChronicle\" ||\n        item.type === \"historianPrep\" ||\n        (item.type === \"image\" &&\n          (item.imageType === \"chronicle\" || item.imageType === \"era_narrative\"))\n    );\n\n    const completedTasks = chronicleTasks.filter(\n      (item) =>\n        (item.status === \"complete\" || item.status === \"error\") &&\n        processed.get(item.id) !== item.status\n    );\n\n    if (completedTasks.length > 0) {\n      console.log(\n        \"[ChronicleQueueWatcher] Processing\",\n        completedTasks.length,\n        \"completed tasks:\",\n        completedTasks.map((t) => ({\n          id: t.id,\n          type: t.type,\n          step: t.chronicleStep,\n          chronicleId: t.chronicleId,\n          resultChronicleId: t.result?.chronicleId,\n        }))\n      );\n      const chronicleIds = new Set<string>();\n      const updates: Promise<unknown>[] = [];\n      let refreshAll = false;\n\n      for (const task of completedTasks) {\n        processed.set(task.id, task.status as ProcessedStatus);\n\n        if (task.type === \"image\" && task.imageType === \"chronicle\") {\n          if (!task.chronicleId || !task.imageRefId) continue;\n          const chronicleId = task.chronicleId;\n          const isCover = task.imageRefId === \"__cover_image__\";\n          const imageId = task.result?.imageId || \"\";\n\n          if (task.status === \"complete\") {\n            if (!imageId) {\n              const error = \"Image generation returned no image id\";\n              if (isCover) {\n                updates.push(\n                  updateChronicleCoverImageStatus(chronicleId, {\n                    status: \"failed\",\n                    error,\n                  })\n                );\n              } else {\n                updates.push(\n                  updateChronicleImageRef(chronicleId, task.imageRefId, {\n                    status: \"failed\",\n                    error,\n                  })\n                );\n              }\n            } else if (isCover) {\n              updates.push(\n                updateChronicleCoverImageStatus(chronicleId, {\n                  status: \"complete\",\n                  generatedImageId: imageId,\n                })\n              );\n            } else {\n              updates.push(\n                updateChronicleImageRef(chronicleId, task.imageRefId, {\n                  status: \"complete\",\n                  generatedImageId: imageId,\n                })\n              );\n            }\n          } else {\n            const error = task.error || \"Image generation failed\";\n            if (isCover) {\n              updates.push(\n                updateChronicleCoverImageStatus(chronicleId, {\n                  status: \"failed\",\n                  error,\n                })\n              );\n            } else {\n              updates.push(\n                updateChronicleImageRef(chronicleId, task.imageRefId, {\n                  status: \"failed\",\n                  error,\n                })\n              );\n            }\n          }\n\n          chronicleIds.add(chronicleId);\n          continue;\n        }\n\n        // Era narrative images \u2014 chronicleId is repurposed as narrativeId\n        if (task.type === \"image\" && task.imageType === \"era_narrative\") {\n          const narrativeId = task.chronicleId;\n          if (!narrativeId || !task.imageRefId) continue;\n          const isCover = task.imageRefId === \"__cover_image__\";\n          const imageId = task.result?.imageId || \"\";\n\n          if (task.status === \"complete\") {\n            if (!imageId) {\n              const error = \"Image generation returned no image id\";\n              if (isCover) {\n                updates.push(\n                  updateEraNarrativeCoverImageStatus(narrativeId, \"failed\", undefined, error)\n                );\n              } else {\n                updates.push(\n                  updateEraNarrativeImageRefStatus(\n                    narrativeId,\n                    task.imageRefId,\n                    \"failed\",\n                    undefined,\n                    error\n                  )\n                );\n              }\n            } else if (isCover) {\n              updates.push(updateEraNarrativeCoverImageStatus(narrativeId, \"complete\", imageId));\n            } else {\n              updates.push(\n                updateEraNarrativeImageRefStatus(narrativeId, task.imageRefId, \"complete\", imageId)\n              );\n            }\n          } else {\n            const error = task.error || \"Image generation failed\";\n            if (isCover) {\n              updates.push(\n                updateEraNarrativeCoverImageStatus(narrativeId, \"failed\", undefined, error)\n              );\n            } else {\n              updates.push(\n                updateEraNarrativeImageRefStatus(\n                  narrativeId,\n                  task.imageRefId,\n                  \"failed\",\n                  undefined,\n                  error\n                )\n              );\n            }\n          }\n          // No chronicle refresh needed \u2014 EraNarrativeViewer polls directly\n          continue;\n        }\n\n        if (task.type === \"historianPrep\") {\n          if (task.chronicleId) chronicleIds.add(task.chronicleId);\n          continue;\n        }\n\n        if (task.type === \"entityChronicle\") {\n          // Prefer result's chronicleId (the actual ID that was updated) over input chronicleId\n          const chronicleId = task.result?.chronicleId || task.chronicleId;\n          if (chronicleId) {\n            chronicleIds.add(chronicleId);\n          } else {\n            console.log(\n              \"[ChronicleQueueWatcher] No chronicleId found on task, triggering refreshAll\"\n            );\n            refreshAll = true;\n          }\n        }\n      }\n\n      const store = useChronicleStore.getState();\n      const refresh = () => {\n        if (!activeRef.current) {\n          console.log(\"[ChronicleQueueWatcher] Skipping refresh - component inactive\");\n          return;\n        }\n        console.log(\"[ChronicleQueueWatcher] Refreshing:\", {\n          refreshAll,\n          chronicleIds: Array.from(chronicleIds),\n        });\n        if (refreshAll) {\n          void store.refreshAll();\n        }\n        for (const id of chronicleIds) {\n          console.log(\"[ChronicleQueueWatcher] Calling refreshChronicle for:\", id);\n          void store.refreshChronicle(id);\n        }\n      };\n\n      if (updates.length > 0) {\n        void Promise.allSettled(updates).then(refresh);\n      } else {\n        refresh();\n      }\n    }\n  }, [queue]);\n}", "parameters": [{"name": "queue", "type": "QueueItem[]", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [{"name": "useRef", "count": 2}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useEffect", "useRef"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["QueueItem"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["updateChronicleCoverImageStatus", "updateChronicleImageRef"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["updateEraNarrativeCoverImageStatus", "updateEraNarrativeImageRefStatus"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useDataSync.js::useDataSync", "name": "useDataSync", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDataSync.js", "sourceCode": "// --- Main hook ---\n\nexport function useDataSync({\n  projectId,\n  activeSlotIndex,\n  worldData,\n  hasHardState,\n  slotRecord,\n  setSlotRecord,\n  simulationRunId,\n  eraTemporalInfo,\n}) {\n  const [dataSyncStatus, setDataSyncStatus] = useState(null);\n  const [isDataSyncing, setIsDataSyncing] = useState(false);\n\n  const reloadEntities = useCallback(\n    (invalidateIds, overrideRunId) =>\n      createReloadEntities(simulationRunId)(invalidateIds, overrideRunId),\n    [simulationRunId]\n  );\n  const reloadEntitiesAndEvents = useCallback(\n    (invalidateIds, overrideRunId) =>\n      createReloadEntitiesAndEvents(simulationRunId)(invalidateIds, overrideRunId),\n    [simulationRunId]\n  );\n\n  const handleDataSync = useCallback(\n    async (mode) => {\n      const result = validateDataSyncPreconditions(mode, worldData, hasHardState, slotRecord);\n      if (result.error) {\n        setDataSyncStatus({ type: \"error\", message: result.error });\n        return;\n      }\n      if (result.cancelled) return;\n      setIsDataSyncing(true);\n      setDataSyncStatus(null);\n      try {\n        const message =\n          mode === \"overwrite\"\n            ? await performOverwriteSync(result.hardRunId, worldData)\n            : await performPatchSync(result.hardRunId, worldData);\n        setDataSyncStatus({ type: \"success\", message });\n        await syncAncillaryData(result.hardRunId, projectId, worldData);\n        const nextSlot = buildNextSlotRecord(\n          result.hardRunId,\n          projectId,\n          activeSlotIndex,\n          worldData,\n          slotRecord\n        );\n        await slotRepo.upsertSlot(nextSlot);\n        setSlotRecord(nextSlot);\n        await reinitializeStoresAfterSync(result.hardRunId);\n      } catch (err) {\n        setDataSyncStatus({\n          type: \"error\",\n          message: err instanceof Error ? err.message : String(err),\n        });\n      } finally {\n        setIsDataSyncing(false);\n      }\n    },\n    [activeSlotIndex, hasHardState, projectId, slotRecord, worldData, setSlotRecord]\n  );\n\n  const handleEntityUpdate = useCallback(\n    async (entityId, output) => {\n      await applyEntityEnrichment(entityId, output);\n      await reloadEntities([entityId]);\n    },\n    [reloadEntities]\n  );\n\n  const handleRefreshEraSummaries = useCallback(async () => {\n    if (!simulationRunId || !eraTemporalInfo.length) return 0;\n    const count = await refreshEraSummariesInChronicles(simulationRunId, eraTemporalInfo);\n    if (count > 0) await useChronicleStore.getState().refreshAll();\n    return count;\n  }, [simulationRunId, eraTemporalInfo]);\n\n  useEffect(() => {\n    const handler = (event) => {\n      if (!simulationRunId) return;\n      reloadEntities(event?.detail?.entityIds);\n    };\n    window.addEventListener(\"entities-updated\", handler);\n    return () => window.removeEventListener(\"entities-updated\", handler);\n  }, [reloadEntities, simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n    initializeStoresForRun(simulationRunId).catch((err) =>\n      console.warn(\"[Illuminator] DAL load failed:\", err)\n    );\n  }, [simulationRunId]);\n\n  return {\n    dataSyncStatus,\n    isDataSyncing,\n    handleDataSync,\n    handleEntityUpdate,\n    handleRefreshEraSummaries,\n    reloadEntities,\n    reloadEntitiesAndEvents,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  worldData,\n  hasHardState,\n  slotRecord,\n  setSlotRecord,\n  simulationRunId,\n  eraTemporalInfo,\n}", "type": "{ projectId: any; activeSlotIndex: any; worldData: any; hasHardState: any; slotRecord: any; setSlotRecord: any; simulationRunId: any; eraTemporalInfo: any; }", "optional": false}], "returnType": "{ dataSyncStatus: any; isDataSyncing: boolean; handleDataSync: (mode: any) => Promise<void>; handleEntityUpdate: (entityId: any, output: any) => Promise<void>; handleRefreshEraSummaries: () => Promise<number>; reloadEntities: (invalidateIds: any, overrideRunId: any) => Promise<void>; reloadEntitiesAndEvents: (invalidateIds: any, overrideRunId: any) => Promise<void>; }", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 5}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/eventRepository", "specifiers": ["* as eventRepo"], "category": "internal"}, {"source": "../lib/db/relationshipRepository", "specifiers": ["* as relationshipRepo"], "category": "internal"}, {"source": "../lib/db/slotRepository", "specifiers": ["* as slotRepo"], "category": "internal"}, {"source": "../lib/db/schemaRepository", "specifiers": ["* as schemaRepo"], "category": "internal"}, {"source": "../lib/db/coordinateStateRepository", "specifiers": ["* as coordinateStateRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "../lib/db/narrativeEventStore", "specifiers": ["useNarrativeEventStore"], "category": "internal"}, {"source": "../lib/db/relationshipStore", "specifiers": ["useRelationshipStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["refreshEraSummariesInChronicles"], "category": "internal"}, {"source": "../lib/db/indexComputation", "specifiers": ["computeRunIndexes"], "category": "internal"}, {"source": "../lib/db/indexRepository", "specifiers": ["upsertRunIndexes"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useDynamicsFlow.js::useDynamicsFlow", "name": "useDynamicsFlow", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDynamicsFlow.js", "sourceCode": "// --- Main hook ---\n\nexport function useDynamicsFlow({\n  projectId,\n  simulationRunId,\n  worldContext,\n  worldSchema,\n  entityNavMap,\n  relationships,\n  updateWorldContext,\n}) {\n  // Handle accepted dynamics from LLM\n  const handleDynamicsAccepted = useCallback(\n    (proposedDynamics) => {\n      if (!proposedDynamics?.length) return;\n      const newDynamics = mapProposedDynamics(proposedDynamics);\n      const existing = worldContext?.worldDynamics || [];\n      updateWorldContext({ worldDynamics: [...existing, ...newDynamics] });\n    },\n    [worldContext, updateWorldContext]\n  );\n\n  const {\n    run: dynamicsRun,\n    isActive: isDynamicsActive,\n    startGeneration: startDynamicsGeneration,\n    submitFeedback: submitDynamicsFeedback,\n    acceptDynamics,\n    cancelGeneration: cancelDynamicsGeneration,\n  } = useDynamicsGeneration(handleDynamicsAccepted);\n\n  // Launch dynamics generation with full world context\n  const handleGenerateDynamics = useCallback(async () => {\n    if (!projectId || !simulationRunId) return;\n\n    const staticPagesContext = await loadStaticPagesContext(projectId);\n    const schemaContext = buildSchemaContext(worldSchema);\n\n    // Build entity context -- load full entities from Dexie (needs description, tags)\n    const allEntities = await entityRepo.getEntitiesForRun(simulationRunId);\n    const entityContexts = buildEntityContexts(allEntities);\n    const relationshipsPayload = buildRelationshipsPayload(relationships, entityNavMap);\n\n    startDynamicsGeneration({\n      projectId,\n      simulationRunId,\n      staticPagesContext,\n      schemaContext,\n      entities: entityContexts,\n      relationships: relationshipsPayload,\n    });\n  }, [\n    projectId,\n    simulationRunId,\n    worldSchema,\n    entityNavMap,\n    relationships,\n    startDynamicsGeneration,\n  ]);\n\n  return {\n    dynamicsRun,\n    isDynamicsActive,\n    handleGenerateDynamics,\n    submitDynamicsFeedback,\n    acceptDynamics,\n    cancelDynamicsGeneration,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  worldContext,\n  worldSchema,\n  entityNavMap,\n  relationships,\n  updateWorldContext,\n}", "type": "{ projectId: any; simulationRunId: any; worldContext: any; worldSchema: any; entityNavMap: any; relationships: any; updateWorldContext: any; }", "optional": false}], "returnType": "{ dynamicsRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/dynamicsGenerationTypes\").DynamicsRun; isDynamicsActive: boolean; handleGenerateDynamics: () => Promise<void>; submitDynamicsFeedback: (feedback: string) => Promise<void>; acceptDynamics: () => void; cancelDynamicsGeneration: () => void; }", "jsxLeafElements": [], "hookCalls": [{"name": "useCallback", "count": 2}, {"name": "useDynamicsGeneration", "count": 1}], "customHookCalls": ["useDynamicsGeneration"], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "./useDynamicsGeneration", "specifiers": ["useDynamicsGeneration"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getPublishedStaticPagesForProject"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useDynamicsGeneration.ts::useDynamicsGeneration", "name": "useDynamicsGeneration", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useDynamicsGeneration.ts", "sourceCode": "export function useDynamicsGeneration(\n  onDynamicsAccepted?: (dynamics: DynamicsRun[\"proposedDynamics\"]) => void\n): UseDynamicsGenerationReturn {\n  const [run, setRun] = useState<DynamicsRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getDynamicsRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on terminal states\n          if (\n            updated.status === \"awaiting_review\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Dispatch a worker task for one LLM turn\n  const dispatchWorkerTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__dynamics__\",\n      name: \"World Dynamics\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"dynamicsGeneration\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: runId, // Repurpose chronicleId for runId\n      },\n    ]);\n  }, []);\n\n  // Start a new generation session\n  const startGeneration = useCallback(\n    async (config: DynamicsGenerationConfig) => {\n      const runId = generateRunId();\n\n      // Create run with full world context as system message\n      const initialMessage: DynamicsMessage = {\n        role: \"system\",\n        content: buildInitialContext(config),\n        timestamp: Date.now(),\n      };\n\n      const newRun = await createDynamicsRun(runId, config.projectId, config.simulationRunId);\n      await updateDynamicsRun(runId, {\n        messages: [initialMessage],\n        status: \"pending\",\n      });\n\n      const updatedRun = await getDynamicsRun(runId);\n      setRun(updatedRun || newRun);\n      setIsActive(true);\n\n      // Dispatch first worker turn\n      dispatchWorkerTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchWorkerTask, startPolling]\n  );\n\n  // Submit user feedback and trigger next turn\n  const submitFeedback = useCallback(\n    async (feedback: string) => {\n      if (!run) return;\n\n      await updateDynamicsRun(run.runId, {\n        userFeedback: feedback,\n        status: \"pending\",\n      });\n\n      // Dispatch next worker turn\n      dispatchWorkerTask(run.runId);\n\n      // Resume polling\n      startPolling(run.runId);\n    },\n    [run, dispatchWorkerTask, startPolling]\n  );\n\n  // Accept proposed dynamics\n  const acceptDynamics = useCallback(() => {\n    if (!run?.proposedDynamics) return;\n\n    onDynamicsAccepted?.(run.proposedDynamics);\n    setIsActive(false);\n    stopPolling();\n\n    // Clean up the run record\n    if (run.runId) {\n      deleteDynamicsRun(run.runId).catch(() => {});\n    }\n  }, [run, onDynamicsAccepted, stopPolling]);\n\n  // Cancel\n  const cancelGeneration = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteDynamicsRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startGeneration,\n    submitFeedback,\n    acceptDynamics,\n    cancelGeneration,\n  };\n}", "parameters": [{"name": "onDynamicsAccepted", "type": "(dynamics: DynamicsRun[\"proposedDynamics\"]) => void", "optional": true}], "returnType": "UseDynamicsGenerationReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/dynamicsGenerationTypes", "specifiers": ["DynamicsRun", "DynamicsMessage"], "category": "internal"}, {"source": "../lib/db/dynamicsRepository", "specifiers": ["createDynamicsRun", "getDynamicsRun", "updateDynamicsRun", "generateRunId", "deleteDynamicsRun"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useEnrichmentQueue.ts::useEnrichmentQueue", "name": "useEnrichmentQueue", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEnrichmentQueue.ts", "sourceCode": "export function useEnrichmentQueue(\n  onEntityUpdate: (entityId: string, output: ApplyEnrichmentOutput) => void,\n  projectId?: string,\n  simulationRunId?: string\n): UseEnrichmentQueueReturn {\n  const [queue, setQueue] = useState<QueueItem[]>([]);\n  const [isWorkerReady, setIsWorkerReady] = useState(false);\n  const workersRef = useRef<WorkerState[]>([]);\n  const configRef = useRef<WorkerConfig | null>(null);\n  const numWorkersRef = useRef<number>(4);\n  const projectIdRef = useRef<string | undefined>(projectId);\n  const simulationRunIdRef = useRef<string | undefined>(simulationRunId);\n  const reconnectInProgressRef = useRef(false);\n  const autoReconnectAttemptsRef = useRef<Map<string, number>>(new Map());\n  const pendingAutoRetryRef = useRef<Set<string>>(new Set());\n  // Track tasks currently executing in the browser (not on a worker).\n  // Prevents re-entry: queueRef.current is stale until React re-renders,\n  // so without this guard the same task can be picked up multiple times.\n  const browserRunningTasksRef = useRef<Set<string>>(new Set());\n\n  // Keep projectId ref in sync\n  useEffect(() => {\n    projectIdRef.current = projectId;\n  }, [projectId]);\n\n  // Keep simulationRunId ref in sync\n  useEffect(() => {\n    simulationRunIdRef.current = simulationRunId;\n  }, [simulationRunId]);\n\n  // Track which tasks are assigned to which worker\n  const taskWorkerMapRef = useRef<Map<string, number>>(new Map());\n\n  // Refs for accessing latest values in callbacks (avoid stale closures)\n  const queueRef = useRef<QueueItem[]>([]);\n  const onEntityUpdateRef = useRef(onEntityUpdate);\n  const initializeRef = useRef<((config: WorkerConfig) => void) | null>(null);\n\n  // Keep refs in sync\n  useEffect(() => {\n    queueRef.current = queue;\n  }, [queue]);\n\n  useEffect(() => {\n    onEntityUpdateRef.current = onEntityUpdate;\n  }, [onEntityUpdate]);\n\n  // Calculate stats\n  const stats: QueueStats = {\n    queued: queue.filter((item) => item.status === \"queued\").length,\n    running: queue.filter((item) => item.status === \"running\").length,\n    completed: queue.filter((item) => item.status === \"complete\").length,\n    errored: queue.filter((item) => item.status === \"error\").length,\n    total: queue.length,\n  };\n\n  // Process next item for a specific worker (uses refs to avoid stale closures)\n  const processNextForWorker = useCallback(\n    (workerId: number) => {\n      const workerState = workersRef.current.find((w) => w.workerId === workerId);\n      if (!workerState || !workerState.isReady || workerState.currentTaskId) return;\n\n      // Use ref to get latest queue\n      const currentQueue = queueRef.current;\n\n      // Find next queued task assigned to this worker\n      // Also exclude tasks already running in the browser \u2014 queueRef is stale\n      // until React re-renders, so status may still read 'queued'.\n      const nextItem = currentQueue.find(\n        (item) =>\n          item.status === \"queued\" &&\n          taskWorkerMapRef.current.get(item.id) === workerId &&\n          !browserRunningTasksRef.current.has(item.id)\n      );\n\n      if (!nextItem) return;\n\n      workerState.currentTaskId = nextItem.id;\n      workerState.pendingTaskIds.delete(nextItem.id);\n\n      // Update status to running\n      setQueue((prev) =>\n        prev.map((item) =>\n          item.id === nextItem.id\n            ? { ...item, status: \"running\" as const, startedAt: Date.now() }\n            : item\n        )\n      );\n\n      // Build task payload \u2014 strip runtime-only fields via rest destructuring\n      /* eslint-disable @typescript-eslint/no-unused-vars, sonarjs/no-unused-vars, sonarjs/no-dead-store */\n      const {\n        status: _status,\n        queuedAt: _queuedAt,\n        startedAt: _startedAt,\n        completedAt: _completedAt,\n        result: _result,\n        error: _error,\n        debug: _debug,\n        estimatedCost: _estimatedCost,\n        ...taskPayload\n      } = nextItem;\n      /* eslint-enable @typescript-eslint/no-unused-vars, sonarjs/no-unused-vars, sonarjs/no-dead-store */\n      const latestLlmSettings = getResolvedLLMCallSettings();\n      if (configRef.current) {\n        configRef.current = { ...configRef.current, llmCallSettings: latestLlmSettings };\n      }\n      const task: WorkerTask = {\n        ...taskPayload,\n        projectId: projectIdRef.current || \"unknown\",\n        llmCallSettings: latestLlmSettings,\n      };\n\n      // Check if this task should run in the browser instead of the service worker\n      if (shouldRunInBrowser(task.type, latestLlmSettings) && configRef.current) {\n        // Release the worker slot \u2014 this task runs in the main thread\n        workerState.currentTaskId = null;\n        browserRunningTasksRef.current.add(nextItem.id);\n\n        console.log(\"[EnrichmentQueue] Executing in browser\", { taskId: task.id, type: task.type });\n\n        // Initialize thinking entry (same as 'started' message handler)\n        useThinkingStore.getState().startTask(task.id, nextItem.entityName, nextItem.type);\n\n        void executeBrowserTask(task, configRef.current, {\n          onThinkingDelta: (taskId, delta) =>\n            useThinkingStore.getState().appendDelta(taskId, delta),\n          onTextDelta: (taskId, delta) =>\n            useThinkingStore.getState().appendTextDelta(taskId, delta),\n        }).then((taskResult) => {\n          browserRunningTasksRef.current.delete(task.id);\n          taskWorkerMapRef.current.delete(task.id);\n          if (taskResult.success) {\n            setQueue(patchQueueItem(task.id, {\n              status: \"complete\" as const,\n              completedAt: Date.now(),\n              result: taskResult.result,\n              debug: taskResult.debug,\n            }));\n            if (taskResult.result) {\n              const queueItem = queueRef.current.find((item) => item.id === task.id);\n              const isChronicleImage = queueItem?.imageType === \"chronicle\";\n              if (!isChronicleImage) {\n                const output = applyEnrichmentResult(\n                  {},\n                  task.type,\n                  taskResult.result,\n                  queueItem?.entityLockedSummary\n                );\n                onEntityUpdateRef.current(task.entityId, output);\n              }\n            }\n          } else {\n            setQueue(patchQueueItem(task.id, {\n              status: \"error\" as const,\n              completedAt: Date.now(),\n              error: taskResult.error,\n              debug: taskResult.debug,\n            }));\n          }\n          useThinkingStore.getState().finishTask(task.id);\n          // Process next tasks \u2014 browser execution freed this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n        });\n\n        // Process next task for this worker immediately (it's not blocked)\n        setTimeout(() => processNextForWorker(workerId), 0);\n        return;\n      }\n\n      workerState.worker.postMessage({ type: \"execute\", task });\n    },\n    [] // No dependencies - uses refs\n  );\n\n  // Handle worker messages (uses refs to avoid stale closures)\n  const handleMessage = useCallback(\n    (workerId: number) => (event: MessageEvent<WorkerOutbound>) => {\n      const message = event.data;\n      const workerState = workersRef.current.find((w) => w.workerId === workerId);\n\n      switch (message.type) {\n        case \"ready\":\n          if (workerState) {\n            workerState.isReady = true;\n          }\n          // Check if all workers are ready\n          if (workersRef.current.every((w) => w.isReady)) {\n            setIsWorkerReady(true);\n          }\n          break;\n\n        case \"started\": {\n          // Already updated status when we sent the task\n          // Initialize thinking entry for this task\n          const startedItem = queueRef.current.find((item) => item.id === message.taskId);\n          if (startedItem) {\n            useThinkingStore\n              .getState()\n              .startTask(message.taskId, startedItem.entityName, startedItem.type);\n          }\n          break;\n        }\n\n        case \"thinking_delta\":\n          useThinkingStore.getState().appendDelta(message.taskId, message.delta);\n          break;\n\n        case \"text_delta\":\n          useThinkingStore.getState().appendTextDelta(message.taskId, message.delta);\n          break;\n\n        case \"complete\": {\n          const result = message.result;\n\n          if (workerState) {\n            workerState.currentTaskId = null;\n          }\n\n          autoReconnectAttemptsRef.current.delete(result.id);\n          pendingAutoRetryRef.current.delete(result.id);\n\n          // Clean up task-worker mapping\n          taskWorkerMapRef.current.delete(result.id);\n\n          // Worker already saved image to IndexedDB, just update queue and notify parent\n          setQueue(patchQueueItem(result.id, {\n            status: \"complete\" as const,\n            completedAt: Date.now(),\n            result: result.result,\n            debug: result.debug,\n          }));\n\n          // Notify parent to update entity (skip for chronicle images - they have their own storage)\n          if (result.result) {\n            const queueItem = queueRef.current.find((item) => item.id === result.id);\n            const isChronicleImage = queueItem?.imageType === \"chronicle\";\n            if (!isChronicleImage) {\n              const output = applyEnrichmentResult(\n                {},\n                result.type,\n                result.result,\n                queueItem?.entityLockedSummary\n              );\n              onEntityUpdateRef.current(result.entityId, output);\n            }\n          }\n\n          useThinkingStore.getState().finishTask(result.id);\n\n          // Process next task for this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n          break;\n        }\n\n        case \"error\": {\n          if (workerState) {\n            workerState.currentTaskId = null;\n          }\n\n          // Clean up task-worker mapping\n          taskWorkerMapRef.current.delete(message.taskId);\n\n          setQueue(patchQueueItem(message.taskId, {\n            status: \"error\" as const,\n            completedAt: Date.now(),\n            error: message.error,\n            debug: message.debug,\n          }));\n\n          useThinkingStore.getState().finishTask(message.taskId);\n\n          if (message.error?.includes(\"Worker not initialized\")) {\n            const attempts = autoReconnectAttemptsRef.current.get(message.taskId) || 0;\n            if (attempts < MAX_AUTO_RECONNECT_ATTEMPTS) {\n              autoReconnectAttemptsRef.current.set(message.taskId, attempts + 1);\n              pendingAutoRetryRef.current.add(message.taskId);\n              if (workerState) {\n                workerState.isReady = false;\n              }\n              const config = configRef.current;\n              if (config && !reconnectInProgressRef.current) {\n                reconnectInProgressRef.current = true;\n                resetWorkerPool();\n                initializeRef.current?.(config);\n              }\n            }\n          }\n\n          // Process next task for this worker\n          setTimeout(() => processNextForWorker(workerId), 0);\n          break;\n        }\n      }\n    },\n    [processNextForWorker] // Only depends on processNextForWorker (which has no deps)\n  );\n\n  // Process queue when it changes - try to start work on idle workers\n  useEffect(() => {\n// ... (truncated)", "parameters": [{"name": "onEntityUpdate", "type": "(entityId: string, output: ApplyEnrichmentOutput) => void", "optional": false}, {"name": "projectId", "type": "string", "optional": true}, {"name": "simulationRunId", "type": "string", "optional": true}], "returnType": "UseEnrichmentQueueReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 13}, {"name": "useEffect", "count": 8}, {"name": "useCallback", "count": 9}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["QueueItem", "EnrichmentTaskPayload", "WorkerTask", "EntityEnrichment", "ApplyEnrichmentOutput"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["applyEnrichmentResult"], "category": "internal"}, {"source": "../workers/enrichment.worker", "specifiers": ["WorkerConfig", "WorkerOutbound"], "category": "internal"}, {"source": "../lib/workerFactory", "specifiers": ["createWorkerPool", "resetWorkerPool", "WorkerHandle"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getResolvedLLMCallSettings", "ResolvedLLMCallSettings"], "category": "internal"}, {"source": "../lib/llmCallTypes", "specifiers": ["LLMCallType"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "../lib/browserTaskExecutor", "specifiers": ["executeBrowserTask"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useEntityCrud.ts::useEntityCrud", "name": "useEntityCrud", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEntityCrud.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useEntityCrud() {\n  const handleAssignImage = useCallback(\n    async (\n      entityId: string,\n      imageId: string,\n      imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string }\n    ) => {\n      await entityRepo.assignImage(entityId, imageId, imageMetadata);\n      await reloadEntities([entityId]);\n    },\n    []\n  );\n\n  const handleUpdateBackrefs = useCallback(\n    async (entityId: string, updatedBackrefs: Parameters<typeof entityRepo.updateBackrefs>[1]) => {\n      await entityRepo.updateBackrefs(entityId, updatedBackrefs);\n      await reloadEntities([entityId]);\n    },\n    []\n  );\n\n  const handleUndoDescription = useCallback(async (entityId: string) => {\n    await entityRepo.undoDescription(entityId);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateAliases = useCallback(async (entityId: string, aliases: string[]) => {\n    await entityRepo.updateAliases(entityId, aliases);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateDescription = useCallback(async (entityId: string, description: string) => {\n    await entityRepo.updateDescriptionManual(entityId, description);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleUpdateSummary = useCallback(async (entityId: string, summary: string) => {\n    await entityRepo.updateSummaryManual(entityId, summary);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleClearNotes = useCallback(async (entityId: string) => {\n    await entityRepo.setHistorianNotes(entityId, []);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleRestoreDescription = useCallback(async (entityId: string, historyIndex: number) => {\n    await entityRepo.restoreDescriptionFromHistory(entityId, historyIndex);\n    await reloadEntities([entityId]);\n  }, []);\n\n  const handleDeleteEntity = useCallback(async (entity: { id: string; name: string }) => {\n    if (!entity.id.startsWith(\"manual_\")) return;\n    if (!confirm(`Delete \"${entity.name}\"? This cannot be undone.`)) return;\n    try {\n      await entityRepo.deleteEntity(entity.id);\n      await reloadEntities([entity.id]);\n    } catch (err) {\n      console.error(\"[Illuminator] Delete entity failed:\", err);\n    }\n  }, []);\n\n  return {\n    handleAssignImage,\n    handleUpdateBackrefs,\n    handleUndoDescription,\n    handleUpdateAliases,\n    handleUpdateDescription,\n    handleUpdateSummary,\n    handleClearNotes,\n    handleRestoreDescription,\n    handleDeleteEntity,\n  };\n}", "parameters": [], "returnType": "{ handleAssignImage: (entityId: string, imageId: string, imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string; }) => Promise<void>; handleUpdateBackrefs: (entityId: string, updatedBackrefs: Parameters<typeof entityRepo.updateBackrefs>[1]) => Promise<void>; handleUndoDescription: (entityId: string) => Promise<void>; handleUpdateAliases: (entityId: string, aliases: string[]) => Promise<void>; handleUpdateDescription: (entityId: string, description: string) => Promise<void>; handleUpdateSummary: (entityId: string, summary: string) => Promise<void>; handleClearNotes: (entityId: string) => Promise<void>; handleRestoreDescription: (entityId: string, historyIndex: number) => Promise<void>; handleDeleteEntity: (entity: { id: string; name: string; }) => Promise<void>; }", "jsxLeafElements": [], "hookCalls": [{"name": "useCallback", "count": 9}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useCallback"], "category": "framework"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useEraNarrative.ts::useEraNarrative", "name": "useEraNarrative", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useEraNarrative.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useEraNarrative(\n  onEnqueue: (\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void\n): UseEraNarrativeReturn {\n  const [narrative, setNarrative] = useState<EraNarrativeRecord | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const headlessRef = useRef(false);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback(\n    (narrativeId: string) => {\n      const sentinelEntity = {\n        id: \"__era_narrative__\",\n        name: \"Era Narrative\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      onEnqueue([\n        {\n          entity: sentinelEntity,\n          type: \"eraNarrative\" as EnrichmentType,\n          prompt: \"\",\n          chronicleId: narrativeId, // Repurposed for narrativeId\n        },\n      ]);\n    },\n    [onEnqueue]\n  );\n\n  // Advance a narrative to its next step (shared by interactive and headless)\n  const advanceRecord = useCallback(\n    async (narrativeId: string, currentStep: EraNarrativeStep) => {\n      const nextStep = NEXT_STEP[currentStep];\n      if (!nextStep) return;\n\n      await updateEraNarrative(narrativeId, {\n        status: \"pending\",\n        currentStep: nextStep,\n      });\n\n      setNarrative((prev) =>\n        prev\n          ? {\n              ...prev,\n              status: \"pending\",\n              currentStep: nextStep,\n            }\n          : null\n      );\n\n      dispatchTask(narrativeId);\n    },\n    [dispatchTask]\n  );\n\n  // Ref to break circular dependency between startPolling and handlePollTick\n  const startPollingRef = useRef<(narrativeId: string) => void>(() => {});\n\n  // Extracted polling tick logic to reduce nesting depth\n  const handlePollTick = useCallback(\n    async (narrativeId: string) => {\n      const updated = await getEraNarrative(narrativeId);\n      if (!updated) return;\n\n      setNarrative(updated);\n\n      // Terminal states always stop polling\n      if (\n        updated.status === \"complete\" ||\n        updated.status === \"failed\" ||\n        updated.status === \"cancelled\"\n      ) {\n        stopPolling();\n        return;\n      }\n\n      if (updated.status === \"step_complete\") {\n        if (headlessRef.current) {\n          // Headless: auto-advance without user interaction (skips edit)\n          stopPolling();\n\n          const nextStep = NEXT_STEP[updated.currentStep];\n          if (!nextStep || updated.currentStep === \"generate\") {\n            // Final step (or generate in headless \u2014 skip edit): mark complete\n            await updateEraNarrative(updated.narrativeId, { status: \"complete\" });\n            setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n          } else {\n            // Intermediate step: advance and restart polling\n            await advanceRecord(updated.narrativeId, updated.currentStep);\n            startPollingRef.current(updated.narrativeId);\n          }\n        } else {\n          // Interactive: stop polling, wait for user action\n          stopPolling();\n        }\n      }\n    },\n    [stopPolling, advanceRecord]\n  );\n\n  // Poll IndexedDB for state changes\n  const startPolling = useCallback(\n    (narrativeId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void handlePollTick(narrativeId);\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling, handlePollTick]\n  );\n\n  // Keep ref in sync\n  useEffect(() => {\n    startPollingRef.current = startPolling;\n  }, [startPolling]);\n\n  // Create a record and start\n  const createAndStart = useCallback(\n    async (config: EraNarrativeConfig, headless: boolean) => {\n      const narrativeId = generateEraNarrativeId();\n      const now = Date.now();\n\n      const newRecord: EraNarrativeRecord = {\n        narrativeId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        eraId: config.eraId,\n        eraName: config.eraName,\n        status: \"pending\",\n        tone: config.tone,\n        arcDirection: config.arcDirection || undefined,\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        currentStep: \"threads\",\n        prepBriefs: config.prepBriefs,\n        worldContext: config.worldContext,\n        totalInputTokens: 0,\n        totalOutputTokens: 0,\n        totalActualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      headlessRef.current = headless;\n      await createEraNarrative(newRecord);\n      setNarrative(newRecord);\n      setIsActive(true);\n\n      dispatchTask(narrativeId);\n      startPolling(narrativeId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Start interactive session\n  const startNarrative = useCallback(\n    async (config: EraNarrativeConfig) => {\n      await createAndStart(config, false);\n    },\n    [createAndStart]\n  );\n\n  // Start headless session (all steps, no pauses)\n  const startHeadless = useCallback(\n    async (config: EraNarrativeConfig) => {\n      await createAndStart(config, true);\n    },\n    [createAndStart]\n  );\n\n  // Resume an existing narrative from IndexedDB\n  const resumeNarrative = useCallback(\n    async (narrativeId: string) => {\n      const record = await getEraNarrative(narrativeId);\n      if (!record) return;\n\n      headlessRef.current = false;\n      setNarrative(record);\n      setIsActive(true);\n\n      if (record.status === \"pending\" || record.status === \"generating\") {\n        // After a page refresh, the worker that was processing this step is gone.\n        // Reset to pending and re-dispatch so the step actually runs again.\n        await updateEraNarrative(narrativeId, { status: \"pending\" });\n        setNarrative((prev) => (prev ? { ...prev, status: \"pending\" } : null));\n        dispatchTask(narrativeId);\n        startPolling(narrativeId);\n      }\n      // step_complete, failed, complete: just show current state, no polling needed\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Advance to the next step, or mark complete if at the final step\n  const advanceStep = useCallback(async () => {\n    if (!narrative) return;\n    const nextStep = NEXT_STEP[narrative.currentStep];\n    if (!nextStep) {\n      // Final step \u2014 mark complete\n      await updateEraNarrative(narrative.narrativeId, { status: \"complete\" });\n      setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n      stopPolling();\n      return;\n    }\n    await advanceRecord(narrative.narrativeId, narrative.currentStep);\n    startPolling(narrative.narrativeId);\n  }, [narrative, advanceRecord, startPolling, stopPolling]);\n\n  // Skip edit step and mark complete\n  const skipEdit = useCallback(async () => {\n    if (!narrative) return;\n\n    await updateEraNarrative(narrative.narrativeId, { status: \"complete\" });\n    setNarrative((prev) => (prev ? { ...prev, status: \"complete\" } : null));\n    stopPolling();\n  }, [narrative, stopPolling]);\n\n  // Re-run copy edit on the latest version of a completed narrative\n  const rerunCopyEdit = useCallback(async () => {\n    if (!narrative) return;\n\n    // Reset to edit step + pending so the worker picks it up\n    await updateEraNarrative(narrative.narrativeId, {\n      status: \"pending\",\n      currentStep: \"edit\",\n    });\n\n    setNarrative((prev) =>\n      prev\n        ? {\n            ...prev,\n            status: \"pending\",\n            currentStep: \"edit\",\n          }\n        : null\n    );\n\n    headlessRef.current = false;\n    dispatchTask(narrative.narrativeId);\n    startPolling(narrative.narrativeId);\n  }, [narrative, dispatchTask, startPolling]);\n\n  // Delete a content version (cannot delete the generate version)\n  const deleteVersion = useCallback(\n    async (versionId: string) => {\n      if (!narrative) return;\n      const updated = await deleteEraNarrativeVersion(narrative.narrativeId, versionId);\n      setNarrative(updated);\n    },\n    [narrative]\n  );\n\n  // Set the active content version\n  const setActiveVersion = useCallback(\n    async (versionId: string) => {\n      if (!narrative) return;\n      const updated = await setEraNarrativeActiveVersion(narrative.narrativeId, versionId);\n      setNarrative(updated);\n    },\n    [narrative]\n  );\n\n  // Cancel\n// ... (truncated)", "parameters": [{"name": "onEnqueue", "type": "(\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void", "optional": false}], "returnType": "UseEraNarrativeReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 3}, {"name": "useCallback", "count": 15}, {"name": "useEffect", "count": 2}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianConfig"], "category": "internal"}, {"source": "../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "EraNarrativeStep", "EraNarrativePrepBrief", "EraNarrativeWorldContext", "EraNarrativeTone"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["createEraNarrative", "getEraNarrative", "updateEraNarrative", "deleteEraNarrative", "generateEraNarrativeId", "deleteEraNarrativeVersion", "setEraNarrativeActiveVersion"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useFactCoverage.ts::useFactCoverage", "name": "useFactCoverage", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useFactCoverage.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useFactCoverage(): UseFactCoverageReturn {\n  const [progress, setProgress] = useState<FactCoverageProgress>(IDLE_PROGRESS);\n\n  const activeRef = useRef(false);\n  const cancelledRef = useRef(false);\n  const scanRef = useRef<{\n    chronicles: FactCoverageChronicleSummary[];\n    facts: Array<{ id: string; text: string }>;\n  } | null>(null);\n\n  const isActive = progress.status === \"running\" || progress.status === \"confirming\";\n\n  // Phase 1: Prepare\n  const prepareFactCoverage = useCallback((chronicleItems: ChronicleNavItem[]) => {\n    if (activeRef.current) return;\n\n    // Filter to eligible chronicles (have content)\n    const eligible = chronicleItems.filter(\n      (c) => (c.status === \"complete\" || c.status === \"assembly_ready\") && c.wordCount > 0\n    );\n\n    const chronicles: FactCoverageChronicleSummary[] = eligible.map((c) => ({\n      chronicleId: c.chronicleId,\n      title: c.title || c.name,\n    }));\n\n    // Load canon facts from config store\n    const worldContext = useIlluminatorConfigStore.getState().worldContext;\n    const rawFacts = worldContext?.canonFactsWithMetadata ?? [];\n    const facts = rawFacts\n      .filter((f: Record<string, unknown>) => !f.disabled)\n      .map((f: Record<string, unknown>) => ({\n        id: (f.id as string) || (typeof f.text === 'string' ? f.text : String(f.text)).slice(0, 20),\n        text: f.text as string,\n      }));\n\n    if (facts.length === 0) {\n      setProgress({\n        ...IDLE_PROGRESS,\n        status: \"failed\",\n        error: \"No canon facts configured\",\n      });\n      return;\n    }\n\n    scanRef.current = { chronicles, facts };\n\n    setProgress({\n      ...IDLE_PROGRESS,\n      status: \"confirming\",\n      chronicles,\n      totalChronicles: chronicles.length,\n    });\n  }, []);\n\n  // Phase 2: Confirm and run\n  const confirmFactCoverage = useCallback(() => {\n    const scan = scanRef.current;\n    if (!scan || activeRef.current) return;\n\n    activeRef.current = true;\n    cancelledRef.current = false;\n\n    setProgress((p) => ({ ...p, status: \"running\" }));\n\n    void (async () => {\n      try {\n        const { chronicles, facts } = scan;\n        let globalProcessed = 0;\n        let globalCost = 0;\n        const failedChronicles: Array<{ chronicleId: string; title: string; error: string }> = [];\n\n        for (let i = 0; i < chronicles.length; i++) {\n          if (cancelledRef.current) break;\n\n          const chron = chronicles[i];\n\n          setProgress((p) => ({\n            ...p,\n            currentTitle: chron.title,\n          }));\n\n          try {\n            // Load full chronicle record\n            const record = await getChronicle(chron.chronicleId);\n            const narrativeText = record?.assembledContent || record?.finalContent;\n\n            if (!narrativeText) {\n              globalProcessed++;\n              setProgress((p) => ({ ...p, processedChronicles: globalProcessed }));\n              continue;\n            }\n\n            // Build payload\n            const payload = {\n              chronicleId: chron.chronicleId,\n              narrativeText,\n              facts,\n            };\n\n            // Create synthetic entity for queue dispatch (same pattern as temporal check)\n            const primaryRole =\n              record?.roleAssignments?.find((r) => r.isPrimary) || record?.roleAssignments?.[0];\n            const syntheticEntity = {\n              id: primaryRole?.entityId || chron.chronicleId,\n              name: primaryRole?.entityName || chron.title,\n              kind: primaryRole?.entityKind || \"chronicle\",\n              subtype: \"\",\n              prominence: \"recognized\",\n              culture: \"\",\n              status: \"active\",\n              description: \"\",\n              tags: {},\n            };\n\n            // Clear any previous report timestamp so we can detect the new one\n            const prevTimestamp = record?.factCoverageReportGeneratedAt ?? 0;\n\n            // Dispatch\n            getEnqueue()([\n              {\n                entity: syntheticEntity as never,\n                type: \"factCoverage\" as const,\n                prompt: JSON.stringify(payload),\n                chronicleId: chron.chronicleId,\n              },\n            ]);\n\n            // Poll for completion\n            let result: { cost: number } | null = null;\n            while (!cancelledRef.current) {\n              await sleep(1500);\n              if (cancelledRef.current) break;\n\n              const updated = await getChronicle(chron.chronicleId);\n              if (\n                updated?.factCoverageReportGeneratedAt &&\n                updated.factCoverageReportGeneratedAt > prevTimestamp\n              ) {\n                result = { cost: updated.factCoverageReport?.actualCost ?? 0 };\n                break;\n              }\n            }\n\n            if (cancelledRef.current || !result) break;\n            globalCost += result.cost;\n          } catch (err) {\n            console.error(`[Fact Coverage] Chronicle \"${chron.title}\" failed:`, err);\n            failedChronicles.push({\n              chronicleId: chron.chronicleId,\n              title: chron.title,\n              error: err instanceof Error ? err.message : String(err),\n            });\n          }\n\n          globalProcessed++;\n          setProgress((p) => ({\n            ...p,\n            processedChronicles: globalProcessed,\n            totalCost: globalCost,\n            failedChronicles: [...failedChronicles],\n          }));\n        }\n\n        if (cancelledRef.current) {\n          setProgress((p) => ({ ...p, status: \"cancelled\", currentTitle: \"\" }));\n        } else {\n          setProgress((p) => ({ ...p, status: \"complete\", currentTitle: \"\" }));\n        }\n      } catch (err) {\n        console.error(\"[Fact Coverage] Fatal error:\", err);\n        setProgress((p) => ({\n          ...p,\n          status: \"failed\",\n          currentTitle: \"\",\n          error: err instanceof Error ? err.message : String(err),\n        }));\n      } finally {\n        activeRef.current = false;\n        scanRef.current = null;\n      }\n    })();\n  }, []);\n\n  // Cancel\n  const cancelFactCoverage = useCallback(() => {\n    cancelledRef.current = true;\n    scanRef.current = null;\n    setProgress((p) => {\n      if (p.status === \"confirming\") return IDLE_PROGRESS;\n      return p; // running \u2192 let the loop handle it\n    });\n  }, []);\n\n  // Close (reset from terminal state)\n  const closeFactCoverage = useCallback(() => {\n    setProgress(IDLE_PROGRESS);\n  }, []);\n\n  return {\n    progress,\n    isActive,\n    prepareFactCoverage,\n    confirmFactCoverage,\n    cancelFactCoverage,\n    closeFactCoverage,\n  };\n}", "parameters": [], "returnType": "UseFactCoverageReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 1}, {"name": "useRef", "count": 3}, {"name": "useCallback", "count": 4}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef"], "category": "framework"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/chronicleNav", "specifiers": ["ChronicleNavItem"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianActions.ts::useHistorianActions", "name": "useHistorianActions", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianActions.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianActions() {\n  const historianConfig = useIlluminatorConfigStore((s) => s.historianConfig);\n  const historianConfigured = isHistorianConfigured(historianConfig);\n  const isHistorianEditionActive = useIlluminatorConfigStore((s) => s.isHistorianEditionActive);\n  const isHistorianActive = useIlluminatorConfigStore((s) => s.isHistorianActive);\n\n  // Edition preview state (compression check before starting)\n  const [editionPreview, setEditionPreview] = useState<EditionPreview | null>(null);\n\n  const handleHistorianEdition = useCallback(\n    async (entityId: string, tone: string, reEdition?: boolean) => {\n      const config = await buildHistorianEditionContext(entityId, tone, reEdition);\n      if (!config) return;\n\n      const history = config.descriptionHistory || [];\n      if (history.length > COMPRESSION_FLOOR) {\n        const compressed = compressDescriptionHistory(history);\n        if (compressed.length < history.length) {\n          setEditionPreview({\n            config,\n            entityName: config.entityName,\n            originalCount: history.length,\n            compressed,\n          });\n          return;\n        }\n      }\n      getStarters().startHistorianEdition(config);\n    },\n    []\n  );\n\n  const handleEditionPreviewProceed = useCallback(() => {\n    if (editionPreview?.config) getStarters().startHistorianEdition(editionPreview.config);\n    setEditionPreview(null);\n  }, [editionPreview]);\n\n  const handleEditionPreviewCancel = useCallback(() => {\n    setEditionPreview(null);\n  }, []);\n\n  const handleHistorianReview = useCallback(async (entityId: string, tone: string) => {\n    const config = await buildHistorianReviewContext(entityId, tone);\n    if (config) getStarters().startHistorianReview(config);\n  }, []);\n\n  const handleUpdateHistorianNote = useCallback(\n    async (\n      targetType: string,\n      targetId: string,\n      noteId: string,\n      updates: Record<string, unknown>\n    ) => {\n      if (targetType === \"entity\" && targetId) {\n        const entity = await useEntityStore.getState().loadEntity(targetId);\n        if (!entity?.enrichment?.historianNotes) return;\n        const updatedNotes = entity.enrichment.historianNotes.map((n) =>\n          n.noteId === noteId ? { ...n, ...updates } : n\n        );\n        await entityRepo.setHistorianNotes(targetId, updatedNotes);\n        await reloadEntities([targetId]);\n      } else if (targetType === \"chronicle\" && targetId) {\n        try {\n          const chronicle = await getChronicle(targetId);\n          if (!chronicle?.historianNotes) return;\n          const updatedNotes = chronicle.historianNotes.map((n: { noteId: string }) =>\n            n.noteId === noteId ? { ...n, ...updates } : n\n          );\n          await updateChronicleHistorianNotes(targetId, updatedNotes);\n          await useChronicleStore.getState().refreshChronicle(targetId);\n        } catch (err) {\n          console.error(\"[Historian] Failed to update note:\", err);\n        }\n      }\n    },\n    []\n  );\n\n  return {\n    historianConfigured,\n    isHistorianEditionActive,\n    isHistorianActive,\n    handleHistorianEdition,\n    handleHistorianReview,\n    handleUpdateHistorianNote,\n    editionPreview,\n    handleEditionPreviewProceed,\n    handleEditionPreviewCancel,\n  };\n}", "parameters": [], "returnType": "{ historianConfigured: boolean; isHistorianEditionActive: boolean; isHistorianActive: boolean; handleHistorianEdition: (entityId: string, tone: string, reEdition?: boolean) => Promise<void>; handleHistorianReview: (entityId: string, tone: string) => Promise<void>; handleUpdateHistorianNote: (targetType: string, targetId: string, noteId: string, updates: Record<string, unknown>) => Promise<void>; editionPreview: EditionPreview; handleEditionPreviewProceed: () => void; handleEditionPreviewCancel: () => void; }", "jsxLeafElements": [], "hookCalls": [{"name": "useIlluminatorConfigStore", "count": 3}, {"name": "useState", "count": 1}, {"name": "useCallback", "count": 5}], "customHookCalls": ["useIlluminatorConfigStore"], "imports": [{"source": "react", "specifiers": ["useState", "useCallback"], "category": "framework"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/historianContextBuilders", "specifiers": ["buildHistorianEditionContext", "buildHistorianReviewContext"], "category": "internal"}, {"source": "../lib/descriptionHistoryCompression", "specifiers": ["compressDescriptionHistory", "COMPRESSION_FLOOR"], "category": "internal"}, {"source": "./useEntityCrud", "specifiers": ["reloadEntities"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "updateChronicleHistorianNotes"], "category": "internal"}, {"source": "./useHistorianEdition", "specifiers": ["HistorianEditionConfig"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["HistorianReviewConfig"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianCallbacks.js::useHistorianCallbacks", "name": "useHistorianCallbacks", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianCallbacks.js", "sourceCode": "// --- Main hook ---\n\nexport function useHistorianCallbacks({\n  projectId,\n  simulationRunId,\n  worldContext,\n  historianConfig,\n  reloadEntities,\n  entityNavMap,\n}) {\n  const {\n    run: historianEditionRun,\n    isActive: isHistorianEditionActive,\n    startHistorianEdition,\n    togglePatchDecision: toggleHistorianEditionPatchDecision,\n    applyAccepted: applyAcceptedHistorianEditionPatches,\n    cancelHistorianEdition,\n  } = useHistorianEdition();\n  const {\n    run: historianRun,\n    isActive: isHistorianActive,\n    startReview: startHistorianReview,\n    toggleNoteDecision: toggleHistorianNoteDecision,\n    applyAccepted: applyAcceptedHistorianNotes,\n    cancelReview: cancelHistorianReview,\n  } = useHistorianReview();\n\n  registerHistorianStarters({ startHistorianEdition, startHistorianReview });\n  useEffect(() => {\n    useIlluminatorConfigStore.getState().setConfig({ isHistorianEditionActive, isHistorianActive });\n  }, [isHistorianEditionActive, isHistorianActive]);\n\n  const handleAcceptHistorianEdition = useCallback(\n    () => runAcceptHistorianEdition(applyAcceptedHistorianEditionPatches, reloadEntities),\n    [applyAcceptedHistorianEditionPatches, reloadEntities]\n  );\n\n  const corpusStrengthCacheRef = useRef({ runId: null, strength: null });\n  const handleChronicleHistorianReview = useCallback(\n    (chronicleId, tone) =>\n      runChronicleHistorianReview({\n        projectId,\n        simulationRunId,\n        chronicleId,\n        tone,\n        worldContext,\n        historianConfig,\n        corpusStrengthCacheRef,\n        startHistorianReview,\n      }),\n    [projectId, simulationRunId, worldContext, historianConfig, startHistorianReview]\n  );\n\n  const {\n    bulkHistorianProgress,\n    isBulkHistorianActive,\n    showBulkHistorianModal,\n    editionMaxTokens,\n    setBulkHistorianTone,\n    handleStartBulkHistorianReview,\n    handleStartBulkHistorianEdition,\n    handleStartBulkHistorianClear,\n    handleConfirmBulkHistorian,\n    handleCancelBulkHistorian,\n    handleCloseBulkHistorian,\n  } = useBulkHistorianSetup({\n    applyReviewNotesForEntity,\n    applyEditionPatchesForEntity,\n    reloadEntities,\n    entityNavMap,\n  });\n\n  const handleAcceptHistorianNotes = useCallback(\n    () => runAcceptHistorianNotes(historianRun, applyAcceptedHistorianNotes, reloadEntities),\n    [applyAcceptedHistorianNotes, historianRun, reloadEntities]\n  );\n  const handleUpdateHistorianNote = useCallback(\n    (targetType, targetId, noteId, updates) =>\n      runUpdateHistorianNote(targetType, targetId, noteId, updates, reloadEntities),\n    [reloadEntities]\n  );\n  const handleEditHistorianNoteText = useCallback(\n    (noteId, newText) => runEditHistorianNoteText(historianRun, noteId, newText),\n    [historianRun]\n  );\n\n  return {\n    historianEditionRun,\n    isHistorianEditionActive,\n    startHistorianEdition,\n    toggleHistorianEditionPatchDecision,\n    handleAcceptHistorianEdition,\n    cancelHistorianEdition,\n    historianRun,\n    isHistorianActive,\n    startHistorianReview,\n    toggleHistorianNoteDecision,\n    cancelHistorianReview,\n    handleAcceptHistorianNotes,\n    handleUpdateHistorianNote,\n    handleEditHistorianNoteText,\n    handleChronicleHistorianReview,\n    bulkHistorianProgress,\n    isBulkHistorianActive,\n    showBulkHistorianModal,\n    editionMaxTokens,\n    setBulkHistorianTone,\n    handleStartBulkHistorianReview,\n    handleStartBulkHistorianEdition,\n    handleStartBulkHistorianClear,\n    handleConfirmBulkHistorian,\n    handleCancelBulkHistorian,\n    handleCloseBulkHistorian,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  simulationRunId,\n  worldContext,\n  historianConfig,\n  reloadEntities,\n  entityNavMap,\n}", "type": "{ projectId: any; simulationRunId: any; worldContext: any; historianConfig: any; reloadEntities: any; entityNavMap: any; }", "optional": false}], "returnType": "{ historianEditionRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/summaryRevisionTypes\").SummaryRevisionRun; isHistorianEditionActive: boolean; startHistorianEdition: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useHistorianEdition\").HistorianEditionConfig) => Promise<void>; toggleHistorianEditionPatchDecision: (entityId: string, accepted: boolean) => Promise<void>; handleAcceptHistorianEdition: () => Promise<void>; cancelHistorianEdition: () => void; historianRun: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/historianTypes\").HistorianRun; isHistorianActive: boolean; startHistorianReview: (config: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useHistorianReview\").HistorianReviewConfig) => Promise<void>; toggleHistorianNoteDecision: (noteId: string, accepted: boolean) => Promise<void>; cancelHistorianReview: () => void; handleAcceptHistorianNotes: () => Promise<void>; handleUpdateHistorianNote: (targetType: any, targetId: any, noteId: any, updates: any) => Promise<void>; handleEditHistorianNoteText: (noteId: any, newText: any) => void; handleChronicleHistorianReview: (chronicleId: any, tone: any) => Promise<void>; bulkHistorianProgress: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useBulkHistorian\").BulkHistorianProgress; isBulkHistorianActive: boolean; showBulkHistorianModal: boolean; editionMaxTokens: number; setBulkHistorianTone: (tone: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/historianTypes\").HistorianTone) => void; handleStartBulkHistorianReview: (eligibleEntityIds: any) => void; handleStartBulkHistorianEdition: (eligibleEntityIds: any, reEdition: any) => void; handleStartBulkHistorianClear: (eligibleEntityIds: any) => void; handleConfirmBulkHistorian: () => void; handleCancelBulkHistorian: () => void; handleCloseBulkHistorian: () => void; }", "jsxLeafElements": [], "hookCalls": [{"name": "useHistorianEdition", "count": 1}, {"name": "useHistorianReview", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 5}, {"name": "useRef", "count": 1}, {"name": "useBulkHistorianSetup", "count": 1}], "customHookCalls": ["useBulkHistorianSetup", "useHistorianEdition", "useHistorianReview"], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "./useHistorianEdition", "specifiers": ["useHistorianEdition"], "category": "internal"}, {"source": "./useHistorianReview", "specifiers": ["useHistorianReview"], "category": "internal"}, {"source": "./useBulkHistorian", "specifiers": ["useBulkHistorian"], "category": "internal"}, {"source": "./useHistorianActions", "specifiers": ["registerHistorianStarters"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getCallConfig as getLLMCallConfig"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "updateChronicleHistorianNotes", "computeCorpusFactStrength"], "category": "internal"}, {"source": "../lib/db/historianRunHelpers", "specifiers": ["extractReinforcedFactIds"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/historianContextBuilders", "specifiers": ["buildHistorianEditionContext", "buildHistorianReviewContext", "collectPreviousNotes", "buildFactCoverageGuidance"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["updateHistorianRun as updateHistorianRunRecord"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianChronology.ts::useHistorianChronology", "name": "useHistorianChronology", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianChronology.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianChronology(\n  onEnqueue: (\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void\n): UseHistorianChronologyReturn {\n  const [run, setRun] = useState<HistorianRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback(\n    (runId: string) => {\n      const sentinelEntity = {\n        id: \"__historian_chronology__\",\n        name: \"Historian Chronology\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      onEnqueue([\n        {\n          entity: sentinelEntity,\n          type: \"historianChronology\" as EnrichmentType,\n          prompt: \"\", // All data is in IndexedDB run context\n          chronicleId: runId, // Repurpose chronicleId field for runId\n        },\n      ]);\n    },\n    [onEnqueue]\n  );\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getHistorianRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new chronology session\n  const startChronology = useCallback(\n    async (config: ChronologyConfig) => {\n      const runId = generateHistorianRunId();\n      const now = Date.now();\n\n      const newRun: HistorianRun = {\n        runId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        status: \"pending\",\n        tone: config.tone,\n        targetType: \"chronology\",\n        targetId: config.eraId,\n        targetName: config.eraName,\n        sourceText: \"\", // Not used for chronology\n        notes: [],\n        noteDecisions: {},\n        contextJson: config.contextJson,\n        previousNotesJson: \"[]\",\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        inputTokens: 0,\n        outputTokens: 0,\n        actualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await createHistorianRun(newRun);\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Adjust a year for a specific chronicle before applying\n  const adjustYear = useCallback(\n    async (chronicleId: string, year: number) => {\n      if (!run?.chronologyAssignments) return;\n\n      const updated = run.chronologyAssignments.map((a) =>\n        a.chronicleId === chronicleId ? { ...a, year } : a\n      );\n\n      await updateHistorianRun(run.runId, { chronologyAssignments: updated });\n      setRun((prev) => (prev ? { ...prev, chronologyAssignments: updated } : null));\n    },\n    [run]\n  );\n\n  // Apply all assignments and return them\n  const applyChronology = useCallback((): ChronologyAssignment[] => {\n    if (!run?.chronologyAssignments) return [];\n\n    const assignments = [...run.chronologyAssignments];\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return assignments;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelChronology = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startChronology,\n    adjustYear,\n    applyChronology,\n    cancelChronology,\n  };\n}", "parameters": [{"name": "onEnqueue", "type": "(\n    items: Array<{\n      entity: {\n        id: string;\n        name: string;\n        kind: string;\n        subtype: string;\n        prominence: string;\n        culture: string;\n        status: string;\n        description: string;\n        tags: Record<string, unknown>;\n      };\n      type: EnrichmentType;\n      prompt: string;\n      chronicleId?: string;\n    }>\n  ) => void", "optional": false}], "returnType": "UseHistorianChronologyReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianRun", "HistorianConfig", "HistorianTone", "ChronologyAssignment"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "getHistorianRun", "updateHistorianRun", "deleteHistorianRun", "generateHistorianRunId"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianEdition.ts::useHistorianEdition", "name": "useHistorianEdition", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianEdition.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianEdition(): UseHistorianEditionReturn {\n  const [run, setRun] = useState<SummaryRevisionRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task for the single entity\n  const dispatchTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__historian_edition__\",\n      name: \"Historian Edition\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"historianEdition\" as EnrichmentType,\n        prompt: \"\", // All data is in IndexedDB run context\n        chronicleId: runId, // Repurpose chronicleId field for runId\n      },\n    ]);\n  }, []);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getRevisionRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"batch_reviewing\" ||\n            updated.status === \"run_reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new historian edition session\n  const startHistorianEdition = useCallback(\n    async (cfg: HistorianEditionConfig) => {\n      const runId = generateRevisionRunId();\n\n      // Single batch with one entity ID\n      const batches = [\n        {\n          culture: \"historian-edition\",\n          entityIds: [cfg.entityId],\n          status: \"pending\" as const,\n          patches: [],\n        },\n      ];\n\n      // Pack all context into staticPagesContext as JSON\n      const contextJson = JSON.stringify({\n        entityId: cfg.entityId,\n        entityName: cfg.entityName,\n        entityKind: cfg.entityKind,\n        entitySubtype: cfg.entitySubtype,\n        entityCulture: cfg.entityCulture,\n        entityProminence: cfg.entityProminence,\n        summary: cfg.summary,\n        descriptionHistory: cfg.descriptionHistory,\n        chronicleSummaries: cfg.chronicleSummaries,\n        relationships: cfg.relationships,\n        neighborSummaries: cfg.neighborSummaries,\n        canonFacts: cfg.canonFacts,\n        worldDynamics: cfg.worldDynamics,\n        previousNotes: cfg.previousNotes,\n        historianConfig: cfg.historianConfig,\n        tone: cfg.tone,\n      });\n\n      // Create run in IndexedDB\n      // worldDynamicsContext = current description, staticPagesContext = everything else\n      const newRun = await createRevisionRun(runId, cfg.projectId, cfg.simulationRunId, batches, {\n        worldDynamicsContext: cfg.description,\n        staticPagesContext: contextJson,\n        schemaContext: \"\",\n        revisionGuidance: \"\",\n      });\n\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Toggle accept/reject for the entity patch\n  const togglePatchDecision = useCallback(\n    async (entityId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.patchDecisions, [entityId]: accepted };\n      await updateRevisionRun(run.runId, { patchDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, patchDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply the accepted patch and return it\n  const applyAccepted = useCallback((): SummaryRevisionPatch[] => {\n    if (!run) return [];\n\n    // Collect patches where the entity was accepted\n    const acceptedPatches: SummaryRevisionPatch[] = [];\n    for (const batch of run.batches) {\n      for (const patch of batch.patches) {\n        const decision = run.patchDecisions[patch.entityId];\n        // Default to accepted if no explicit decision\n        if (decision !== false) {\n          acceptedPatches.push(patch);\n        }\n      }\n    }\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedPatches;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelHistorianEdition = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteRevisionRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startHistorianEdition,\n    togglePatchDecision,\n    applyAccepted,\n    cancelHistorianEdition,\n  };\n}", "parameters": [], "returnType": "UseHistorianEditionReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianConfig", "HistorianTone"], "category": "internal"}, {"source": "../lib/summaryRevisionTypes", "specifiers": ["SummaryRevisionRun", "SummaryRevisionPatch"], "category": "internal"}, {"source": "../lib/db/summaryRevisionRepository", "specifiers": ["createRevisionRun", "getRevisionRun", "updateRevisionRun", "generateRevisionRunId", "deleteRevisionRun"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useHistorianReview.ts::useHistorianReview", "name": "useHistorianReview", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useHistorianReview.ts", "sourceCode": "// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useHistorianReview(): UseHistorianReviewReturn {\n  const [run, setRun] = useState<HistorianRun | null>(null);\n  const [isActive, setIsActive] = useState(false);\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Stop polling\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Dispatch a worker task\n  const dispatchTask = useCallback((runId: string) => {\n    const sentinelEntity = {\n      id: \"__historian_review__\",\n      name: \"Historian Review\",\n      kind: \"system\",\n      subtype: \"\",\n      prominence: \"\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {},\n    };\n\n    getEnqueue()([\n      {\n        entity: sentinelEntity,\n        type: \"historianReview\" as EnrichmentType,\n        prompt: \"\", // All data is in IndexedDB run context\n        chronicleId: runId, // Repurpose chronicleId field for runId\n      },\n    ]);\n  }, []);\n\n  // Poll IndexedDB for run state changes\n  const startPolling = useCallback(\n    (runId: string) => {\n      stopPolling();\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getHistorianRun(runId);\n          if (!updated) return;\n\n          setRun(updated);\n\n          // Stop polling on review/terminal states\n          if (\n            updated.status === \"reviewing\" ||\n            updated.status === \"complete\" ||\n            updated.status === \"failed\" ||\n            updated.status === \"cancelled\"\n          ) {\n            stopPolling();\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [stopPolling]\n  );\n\n  // Start a new historian review session\n  const startReview = useCallback(\n    async (config: HistorianReviewConfig) => {\n      const runId = generateHistorianRunId();\n      const now = Date.now();\n\n      const newRun: HistorianRun = {\n        runId,\n        projectId: config.projectId,\n        simulationRunId: config.simulationRunId,\n        status: \"pending\",\n        tone: config.tone,\n        targetType: config.targetType,\n        targetId: config.targetId,\n        targetName: config.targetName,\n        sourceText: config.sourceText,\n        notes: [],\n        noteDecisions: {},\n        contextJson: config.contextJson,\n        previousNotesJson: config.previousNotesJson,\n        historianConfigJson: JSON.stringify(config.historianConfig),\n        inputTokens: 0,\n        outputTokens: 0,\n        actualCost: 0,\n        createdAt: now,\n        updatedAt: now,\n      };\n\n      await createHistorianRun(newRun);\n      setRun(newRun);\n      setIsActive(true);\n\n      // Dispatch the worker task\n      dispatchTask(runId);\n\n      // Start polling\n      startPolling(runId);\n    },\n    [dispatchTask, startPolling]\n  );\n\n  // Toggle accept/reject for a note\n  const toggleNoteDecision = useCallback(\n    async (noteId: string, accepted: boolean) => {\n      if (!run) return;\n\n      const newDecisions = { ...run.noteDecisions, [noteId]: accepted };\n      await updateHistorianRun(run.runId, { noteDecisions: newDecisions });\n\n      setRun((prev) => (prev ? { ...prev, noteDecisions: newDecisions } : null));\n    },\n    [run]\n  );\n\n  // Apply accepted notes and return them\n  const applyAccepted = useCallback((): HistorianNote[] => {\n    if (!run) return [];\n\n    // Collect notes where accepted (default to accepted if no explicit decision)\n    const acceptedNotes: HistorianNote[] = run.notes.filter(\n      (note) => run.noteDecisions[note.noteId] !== false\n    );\n\n    // Clean up\n    setIsActive(false);\n    stopPolling();\n    if (run.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n\n    return acceptedNotes;\n  }, [run, stopPolling]);\n\n  // Cancel\n  const cancelReview = useCallback(() => {\n    setIsActive(false);\n    stopPolling();\n    if (run?.runId) {\n      deleteHistorianRun(run.runId).catch(() => {});\n    }\n    setRun(null);\n  }, [run, stopPolling]);\n\n  return {\n    run,\n    isActive,\n    startReview,\n    toggleNoteDecision,\n    applyAccepted,\n    cancelReview,\n  };\n}", "parameters": [], "returnType": "UseHistorianReviewReturn", "jsxLeafElements": [], "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useCallback", "count": 7}, {"name": "useEffect", "count": 1}], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianRun", "HistorianNote", "HistorianConfig", "HistorianTargetType", "HistorianTone"], "category": "internal"}, {"source": "../lib/db/historianRepository", "specifiers": ["createHistorianRun", "getHistorianRun", "updateHistorianRun", "deleteHistorianRun", "generateHistorianRunId"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/hooks/useIlluminatorSetup.js::useIlluminatorSetup", "name": "useIlluminatorSetup", "kind": "hook", "filePath": "apps/illuminator/webui/src/hooks/useIlluminatorSetup.js", "sourceCode": "// --- Main hook ---\n\nexport function useIlluminatorSetup({\n  projectId,\n  worldData,\n  schema,\n  onStyleSelectionChange,\n  config,\n  apiKeys,\n  slotRecord,\n  currentEra,\n  simulationRunId,\n  handleEntityUpdate,\n  reloadEntities,\n  reloadEntitiesAndEvents,\n  worldContext,\n  historianConfig,\n  entityGuidance,\n  cultureIdentities,\n  navEntities,\n  setChronicleRefreshTrigger,\n}) {\n  // Style library\n  const styleLib = useStyleLibrary();\n\n  // Image gen settings\n  const [imageGenSettings, updateImageGenSettings] = useImageGenSettings(\n    onStyleSelectionChange\n      ? (s) =>\n          onStyleSelectionChange({\n            artisticStyleId: s.artisticStyleId,\n            compositionStyleId: s.compositionStyleId,\n            colorPaletteId: s.colorPaletteId,\n          })\n      : undefined\n  );\n  const styleSelection = useMemo(\n    () => ({\n      artisticStyleId: imageGenSettings.artisticStyleId,\n      compositionStyleId: imageGenSettings.compositionStyleId,\n      colorPaletteId: imageGenSettings.colorPaletteId,\n    }),\n    [\n      imageGenSettings.artisticStyleId,\n      imageGenSettings.compositionStyleId,\n      imageGenSettings.colorPaletteId,\n    ]\n  );\n\n  // World schema + simulation metadata\n  const worldSchema = useMemo(() => computeWorldSchema(worldData, schema), [worldData, schema]);\n  const simulationMetadata = useMemo(\n    () => computeSimulationMetadata(slotRecord, currentEra),\n    [slotRecord, currentEra]\n  );\n\n  // Derived state\n  const hasHardState = Boolean(worldData?.hardState?.length);\n  const hardStateSummary = useMemo(() => computeHardStateSummary(worldData), [worldData]);\n  const canImport = hasHardState;\n  const hasWorldData = navEntities.length > 0;\n  const isTemporarySlot = slotRecord?.isTemporary ?? false;\n\n  // Subtypes\n  const subtypesByKind = useMemo(() => computeSubtypesByKind(worldSchema), [worldSchema]);\n\n  // Era entities (wrapped in async IIFE to satisfy set-state-in-effect rule)\n  const [eraEntities, setEraEntities] = useState([]);\n  useEffect(() => {\n    (async () => {\n      const eraNavs = navEntities.filter((e) => e.kind === \"era\");\n      if (eraNavs.length === 0) {\n        setEraEntities([]);\n        return;\n      }\n      const full = await useEntityStore.getState().loadEntities(eraNavs.map((e) => e.id));\n      setEraEntities(full.map((e) => ({ id: e.id, name: e.name, description: e.description })));\n    })();\n  }, [navEntities]);\n\n  // Queue\n  const {\n    queue,\n    isWorkerReady,\n    stats,\n    initialize: initializeWorker,\n    enqueue,\n    cancel,\n    cancelAll,\n    retry,\n    clearCompleted,\n  } = useEnrichmentQueue(handleEntityUpdate, projectId, simulationRunId);\n  registerQueue(enqueue, cancel);\n  useEffect(() => {\n    useEnrichmentQueueStore.getState().setQueue(queue, stats);\n  }, [queue, stats]);\n  useChronicleQueueWatcher(queue);\n  useEffect(() => {\n    if (apiKeys.anthropicApiKey || apiKeys.openaiApiKey)\n      initializeWorker(buildWorkerConfig(apiKeys, config, imageGenSettings));\n  }, [apiKeys, config, imageGenSettings, initializeWorker]);\n\n  // Config store sync\n  useEffect(() => {\n    useIlluminatorConfigStore.getState().setConfig({\n      projectId: projectId || null,\n      simulationRunId: simulationRunId || null,\n      worldContext,\n      historianConfig,\n      entityGuidance,\n      cultureIdentities,\n    });\n  }, [\n    projectId,\n    simulationRunId,\n    worldContext,\n    historianConfig,\n    entityGuidance,\n    cultureIdentities,\n  ]);\n\n  // Entity CRUD\n  const editEntityModal = useIlluminatorModals((s) => s.editEntityModal);\n  const handleRenameApplied = useCallback(\n    (args) =>\n      handleRenameApply(args, simulationRunId, reloadEntitiesAndEvents, setChronicleRefreshTrigger),\n    [simulationRunId, reloadEntitiesAndEvents, setChronicleRefreshTrigger]\n  );\n  const handleCreateEntity = useCallback(\n    (entityData) => handleCreateApply(entityData, simulationRunId, reloadEntities),\n    [simulationRunId, reloadEntities]\n  );\n  const handleEditEntity = useCallback(\n    (entityData) => handleEditApply(entityData, editEntityModal, reloadEntities),\n    [editEntityModal, reloadEntities]\n  );\n\n  return {\n    ...styleLib,\n    imageGenSettings,\n    updateImageGenSettings,\n    styleSelection,\n    worldSchema,\n    simulationMetadata,\n    hasHardState,\n    hardStateSummary,\n    canImport,\n    hasWorldData,\n    isTemporarySlot,\n    subtypesByKind,\n    eraEntities,\n    queue,\n    isWorkerReady,\n    stats,\n    enqueue,\n    cancel,\n    cancelAll,\n    retry,\n    clearCompleted,\n    handleRenameApplied,\n    handleCreateEntity,\n    handleEditEntity,\n  };\n}", "parameters": [{"name": "{\n  projectId,\n  worldData,\n  schema,\n  onStyleSelectionChange,\n  config,\n  apiKeys,\n  slotRecord,\n  currentEra,\n  simulationRunId,\n  handleEntityUpdate,\n  reloadEntities,\n  reloadEntitiesAndEvents,\n  worldContext,\n  historianConfig,\n  entityGuidance,\n  cultureIdentities,\n  navEntities,\n  setChronicleRefreshTrigger,\n}", "type": "{ projectId: any; worldData: any; schema: any; onStyleSelectionChange: any; config: any; apiKeys: any; slotRecord: any; currentEra: any; simulationRunId: any; handleEntityUpdate: any; reloadEntities: any; reloadEntitiesAndEvents: any; worldContext: any; historianConfig: any; entityGuidance: any; cultureIdentities: any; navEntities: any; setChronicleRefreshTrigger: any; }", "optional": false}], "returnType": "{ imageGenSettings: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useImageGenSettings\").ImageGenSettings; updateImageGenSettings: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useImageGenSettings\").ImageGenSettingsUpdater; styleSelection: { artisticStyleId: string; compositionStyleId: string; colorPaletteId: string; }; worldSchema: any; simulationMetadata: { currentTick: any; currentEra: any; }; hasHardState: boolean; hardStateSummary: string; canImport: boolean; hasWorldData: boolean; isTemporarySlot: any; subtypesByKind: {}; eraEntities: any[]; queue: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/enrichmentTypes\").QueueItem[]; isWorkerReady: boolean; stats: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useEnrichmentQueue\").QueueStats; enqueue: (items: (Omit<import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/enrichmentTypes\").EnrichmentTaskPayload, \"id\" | \"simulationRunId\" | \"entityName\" | \"entityKind\" | \"entityCulture\" | \"entityId\" | \"entitySubtype\"> & { entity: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/hooks/useEnrichmentQueue\").EnrichedEntity; })[]) => void; cancel: (itemId: string) => void; cancelAll: () => void; retry: (itemId: string) => void; clearCompleted: () => void; handleRenameApplied: (args: any) => Promise<void>; handleCreateEntity: (entityData: any) => Promise<void>; handleEditEntity: (entityData: any) => Promise<void>; styleLibrary: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").StyleLibrary; loading: boolean; isCustom: boolean; save: (library: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").StyleLibrary) => Promise<void>; reset: () => Promise<void>; addArtisticStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/artisticStyles\").ArtisticStyle) => Promise<void>; updateArtisticStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/artisticStyles\").ArtisticStyle>) => Promise<void>; deleteArtisticStyle: (id: string) => Promise<void>; addCompositionStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/compositionStyles\").CompositionStyle) => Promise<void>; updateCompositionStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/compositionStyles\").CompositionStyle>) => Promise<void>; deleteCompositionStyle: (id: string) => Promise<void>; addNarrativeStyle: (style: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").NarrativeStyle) => Promise<void>; updateNarrativeStyle: (id: string, updates: Partial<import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/style\").NarrativeStyle>) => Promise<void>; deleteNarrativeStyle: (id: string) => Promise<void>; }", "jsxLeafElements": [], "hookCalls": [{"name": "useStyleLibrary", "count": 1}, {"name": "useImageGenSettings", "count": 1}, {"name": "useMemo", "count": 5}, {"name": "useState", "count": 1}, {"name": "useEffect", "count": 4}, {"name": "useEnrichmentQueue", "count": 1}, {"name": "useChronicleQueueWatcher", "count": 1}, {"name": "useIlluminatorModals", "count": 1}, {"name": "useCallback", "count": 3}], "customHookCalls": ["useChronicleQueueWatcher", "useEnrichmentQueue", "useIlluminatorModals", "useImageGenSettings", "useStyleLibrary"], "imports": [{"source": "react", "specifiers": ["useState", "useMemo", "useEffect", "useCallback"], "category": "framework"}, {"source": "./useStyleLibrary", "specifiers": ["useStyleLibrary"], "category": "internal"}, {"source": "./useImageGenSettings", "specifiers": ["useImageGenSettings"], "category": "internal"}, {"source": "./useEnrichmentQueue", "specifiers": ["useEnrichmentQueue"], "category": "internal"}, {"source": "./useChronicleQueueWatcher", "specifiers": ["useChronicleQueueWatcher"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["registerQueue"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getResolvedLLMCallSettings"], "category": "internal"}, {"source": "../lib/db/indexComputation", "specifiers": ["computeRunIndexes"], "category": "internal"}, {"source": "../lib/db/indexRepository", "specifiers": ["upsertRunIndexes"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/eventRepository", "specifiers": ["* as eventRepo"], "category": "internal"}]}]