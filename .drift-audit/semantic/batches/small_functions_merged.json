[{"id": "packages/world-store/src/index.ts::getSlotRecord", "name": "getSlotRecord", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getSlotRecord(\n  projectId: string,\n  slotIndex: number,\n): Promise<SimulationSlotRecord | null> {\n  const db = await openDb();\n  const record = await getRecord<SimulationSlotRecord>(db, SLOTS_STORE, [projectId, slotIndex]);\n  db.close();\n  return record;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<SimulationSlotRecord | null>"}, {"id": "packages/world-store/src/index.ts::getWorldSchema", "name": "getWorldSchema", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getWorldSchema(projectId: string): Promise<CanonrySchemaSlice | null> {\n  const db = await openDb();\n  const record = await getRecord<WorldSchemaRecord>(db, SCHEMAS_STORE, projectId);\n  db.close();\n  return record?.schema ?? null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<CanonrySchemaSlice | null>"}, {"id": "packages/world-store/src/index.ts::getCoordinateState", "name": "getCoordinateState", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getCoordinateState(simulationRunId: string): Promise<CoordinateState | null> {\n  const db = await openDb();\n  const record = await getRecord<CoordinateStateRecord>(db, COORDINATE_STORE, simulationRunId);\n  db.close();\n  return record?.coordinateState ?? null;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CoordinateState | null>"}, {"id": "packages/world-store/src/index.ts::getEntities", "name": "getEntities", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getEntities(simulationRunId: string): Promise<WorldEntity[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<WorldEntity & { simulationRunId?: string }>(\n    db,\n    ENTITIES_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as WorldEntity[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<WorldEntity[]>"}, {"id": "packages/world-store/src/index.ts::getRelationships", "name": "getRelationships", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getRelationships(simulationRunId: string): Promise<WorldRelationship[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<WorldRelationship & { simulationRunId?: string }>(\n    db,\n    RELATIONSHIPS_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as WorldRelationship[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<WorldRelationship[]>"}, {"id": "packages/world-store/src/index.ts::getNarrativeEvents", "name": "getNarrativeEvents", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getNarrativeEvents(simulationRunId: string): Promise<NarrativeEvent[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<NarrativeEvent & { simulationRunId?: string }>(\n    db,\n    EVENTS_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as NarrativeEvent[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<NarrativeEvent[]>"}, {"id": "packages/world-store/src/index.ts::getChronicles", "name": "getChronicles", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getChronicles(simulationRunId: string): Promise<ChronicleRecord[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<ChronicleRecord>(\n    db,\n    CHRONICLES_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>"}, {"id": "packages/world-store/src/index.ts::getStaticPages", "name": "getStaticPages", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getStaticPages(projectId: string): Promise<StaticPageRecord[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<StaticPageRecord>(\n    db,\n    STATIC_PAGES_STORE,\n    'projectId',\n    projectId,\n  );\n  db.close();\n  return records;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPageRecord[]>"}, {"id": "packages/world-store/src/index.ts::buildWorldStateForSlot", "name": "buildWorldStateForSlot", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function buildWorldStateForSlot(\n  projectId: string,\n  slotIndex: number,\n): Promise<WorldOutput | null> {\n  const slot = await getSlotRecord(projectId, slotIndex);\n  if (!slot?.simulationRunId) return null;\n\n  const [schema, entities, relationships, narrativeHistory, coordinateState] = await Promise.all([\n    getWorldSchema(projectId),\n    getEntities(slot.simulationRunId),\n    getRelationships(slot.simulationRunId),\n    getNarrativeEvents(slot.simulationRunId),\n    getCoordinateState(slot.simulationRunId),\n  ]);\n\n  const eraName = resolveEraName(entities, slot.finalEraId);\n\n  return {\n    schema: schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    metadata: {\n      simulationRunId: slot.simulationRunId,\n      tick: typeof slot.finalTick === 'number' ? slot.finalTick : 0,\n      epoch: 0,\n      era: eraName,\n      entityCount: entities.length,\n      relationshipCount: relationships.length,\n    },\n    hardState: entities,\n    relationships,\n    pressures: {},\n    narrativeHistory: narrativeHistory.length > 0 ? narrativeHistory : undefined,\n    coordinateState: coordinateState || undefined,\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<WorldOutput | null>"}, {"id": "apps/viewer/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/App.jsx", "sourceCode": "export default function App() {\n  const {\n    bundle,\n    status,\n    error,\n    bundleRequestUrl,\n    loadBundle,\n    dexieSeededAt,\n    preloadedChronicles,\n    preloadedStaticPages,\n    preloadedEraNarratives,\n  } = useBundleLoader();\n  const [chroniclerRequestedPage, setChroniclerRequestedPage] = useState(null);\n  const clearChroniclerRequestedPage = useCallback(() => setChroniclerRequestedPage(null), []);\n\n  if (status !== \"ready\" || !bundle?.worldData) {\n    return (\n      <StatusScreen\n        status={status}\n        error={error}\n        bundleRequestUrl={bundleRequestUrl}\n        onRetry={loadBundle}\n        worldData={bundle?.worldData}\n      />\n    );\n  }\n\n  return (\n    <div className=\"app\">\n      <header className=\"app-header\">\n        <button\n          type=\"button\"\n          className=\"brand\"\n          onClick={() => {\n            setChroniclerRequestedPage(\"home\");\n            window.location.hash = \"#/\";\n          }}\n        >\n          <span className=\"brand-icon\" aria-hidden=\"true\">\n            &#x2756;\n          </span>\n          <span className=\"brand-title\">The Ice Remembers</span>\n        </button>\n        <HeaderSearch\n          projectId={bundle.projectId}\n          slotIndex={bundle.slot?.index ?? 0}\n          dexieSeededAt={dexieSeededAt}\n          onNavigate={setChroniclerRequestedPage}\n        />\n        <div className=\"header-spacer\" />\n      </header>\n      <main className=\"app-main\">\n        <div className=\"panel chronicler-scope\">\n          <ChroniclerRemote\n            projectId={bundle.projectId}\n            activeSlotIndex={bundle.slot?.index ?? 0}\n            requestedPageId={chroniclerRequestedPage}\n            onRequestedPageConsumed={clearChroniclerRequestedPage}\n            dexieSeededAt={dexieSeededAt}\n            preloadedWorldData={bundle.worldData}\n            preloadedChronicles={preloadedChronicles}\n            preloadedStaticPages={preloadedStaticPages}\n            preloadedEraNarratives={preloadedEraNarratives}\n            prebakedParchmentUrl={parchmentTileUrl}\n            precomputedPageIndex={bundle.precomputedPageIndex}\n          />\n        </div>\n      </main>\n      <footer className=\"app-footer\">\n        <span>Copyright \u00a9 2026</span>\n        <a href=\"https://ahara.io\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <img src=\"/tsonu-combined.png\" alt=\"tsonu\" height=\"14\" />\n        </a>\n      </footer>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleUrl", "name": "resolveBundleUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleUrl() {\n  return new URL(DEFAULT_BUNDLE_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string"}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleManifestUrl", "name": "resolveBundleManifestUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleManifestUrl() {\n  return new URL(DEFAULT_BUNDLE_MANIFEST_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string"}, {"id": "apps/viewer/webui/src/bundleLoader.js::normalizeBundle", "name": "normalizeBundle", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function normalizeBundle(raw, bundleUrl) {\n  if (!raw || typeof raw !== \"object\") return null;\n\n  const baseUrl = new URL(\".\", bundleUrl).toString();\n  const resolveUrl = (value) => resolveAssetUrl(value, baseUrl);\n\n  return {\n    ...raw,\n    chronicles: Array.isArray(raw.chronicles) ? raw.chronicles : [],\n    staticPages: Array.isArray(raw.staticPages) ? raw.staticPages : [],\n    images: resolveImageMap(raw.images, resolveUrl),\n    imageData: resolveImageData(raw.imageData, resolveUrl),\n  };\n}", "parameters": [{"name": "raw", "type": "any", "optional": false}, {"name": "bundleUrl", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleViaManifest", "name": "loadBundleViaManifest", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleViaManifest(manifestUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(manifestUrl);\n  const manifest = await fetchJson(manifestUrl, { cache: \"no-store\" });\n  if (!manifest || manifest.format !== \"viewer-bundle-manifest\") {\n    throw new Error(\"Bundle manifest missing or invalid.\");\n  }\n\n  const manifestBaseUrl = new URL(\".\", manifestUrl).toString();\n  const corePath = manifest.core;\n  if (typeof corePath !== \"string\") {\n    throw new Error(\"Bundle manifest is missing core path.\");\n  }\n  const coreUrl = resolveAssetUrl(corePath, manifestBaseUrl);\n  setBundleRequestUrl(coreUrl);\n  const data = await fetchJson(coreUrl);\n\n  const normalized = validateAndNormalizeBundle(data, coreUrl);\n  configureNarrativeBackend(\n    manifest,\n    manifestBaseUrl,\n    normalized.worldData?.metadata?.simulationRunId\n  );\n  return normalized;\n}", "parameters": [{"name": "manifestUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleFallback", "name": "loadBundleFallback", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleFallback(fallbackUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(fallbackUrl);\n  const data = await fetchJson(fallbackUrl, { cache: \"no-store\" });\n  const normalized = validateAndNormalizeBundle(data, fallbackUrl);\n  const totalEvents = normalized.worldData.narrativeHistory.length;\n\n  if (totalEvents > 0) {\n    useNarrativeStore.getState().ingestChunk(normalized.worldData.narrativeHistory);\n  }\n  useNarrativeStore.getState().setStatus({\n    loading: false,\n    totalExpected: totalEvents,\n    chunksLoaded: totalEvents ? 1 : 0,\n    chunksTotal: totalEvents ? 1 : 0,\n  });\n\n  return normalized;\n}", "parameters": [{"name": "fallbackUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/viewer/webui/src/HeaderSearch.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/HeaderSearch.jsx", "sourceCode": "export default function HeaderSearch({ projectId, slotIndex, dexieSeededAt, onNavigate }) {\n  const [query, setQuery] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const containerRef = useRef(null);\n  const { pages, isIndexLoading } = useSearchIndex(projectId, slotIndex, dexieSeededAt);\n\n  const fuse = useMemo(\n    () =>\n      new Fuse(pages, {\n        keys: [\n          { name: \"title\", weight: 2 },\n          { name: \"content.summary\", weight: 1 },\n        ],\n        threshold: 0.3,\n        includeScore: true,\n        minMatchCharLength: 2,\n      }),\n    [pages]\n  );\n\n  const results = useMemo(() => {\n    if (!query || query.length < 2) return [];\n    return fuse.search(query).slice(0, 8);\n  }, [fuse, query]);\n\n  const handleSelect = useCallback(\n    (id) => {\n      if (id) onNavigate(id);\n      setIsOpen(false);\n      setQuery(\"\");\n    },\n    [onNavigate]\n  );\n\n  const handleKeyDown = useKeyboardNavigation(\n    results,\n    selectedIndex,\n    setSelectedIndex,\n    handleSelect\n  );\n\n  useEffect(() => {\n    const onClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) setIsOpen(false);\n    };\n    document.addEventListener(\"mousedown\", onClickOutside);\n    return () => document.removeEventListener(\"mousedown\", onClickOutside);\n  }, []);\n\n  return (\n    <div className=\"header-search\" ref={containerRef}>\n      <input\n        type=\"text\"\n        className=\"header-search-input\"\n        placeholder=\"Search wiki...\"\n        value={query}\n        onChange={(e) => {\n          setQuery(e.target.value);\n          setSelectedIndex(0);\n          setIsOpen(true);\n        }}\n        onFocus={() => setIsOpen(true)}\n        onKeyDown={(e) => {\n          if (isOpen) handleKeyDown(e);\n        }}\n      />\n      {isOpen && query.length >= 2 && (\n        <div className=\"header-search-dropdown\">\n          {results.length > 0 ? (\n            results.map((result, index) => (\n              <button\n                key={result.item.id}\n                type=\"button\"\n                className={`header-search-result ${index === selectedIndex ? \"selected\" : \"\"}`}\n                onClick={() => handleSelect(result.item.id)}\n                onMouseEnter={() => setSelectedIndex(index)}\n              >\n                <span className=\"header-search-result-title\">{result.item.title}</span>\n                <span className=\"header-search-result-type\">{result.item.type}</span>\n              </button>\n            ))\n          ) : (\n            <div className=\"header-search-no-results\">\n              {isIndexLoading ? \"Indexing pages...\" : \"No results found\"}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, slotIndex, dexieSeededAt, onNavigate }", "type": "{ projectId: any; slotIndex: any; dexieSeededAt: any; onNavigate: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/StatusScreen.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/StatusScreen.jsx", "sourceCode": "export default function StatusScreen({ status, error, bundleRequestUrl, onRetry, worldData }) {\n  if (status === \"loading\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Loading viewer bundle...</div>\n            <div className=\"state-detail\">Fetching {bundleRequestUrl}</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (status === \"error\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title state-error\">Bundle unavailable</div>\n            <div className=\"state-detail\">\n              {error?.message || \"Failed to load the viewer bundle.\"}\n            </div>\n            <div className=\"state-detail\">Expected at: {bundleRequestUrl}</div>\n            <div className=\"state-actions\">\n              <button className=\"button\" onClick={onRetry} type=\"button\">\n                Retry\n              </button>\n              <button\n                className=\"button secondary\"\n                onClick={() => window.location.reload()}\n                type=\"button\"\n              >\n                Reload page\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!worldData) {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Bundle is empty</div>\n            <div className=\"state-detail\">No world data found in {bundleRequestUrl}.</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{ status, error, bundleRequestUrl, onRetry, worldData }", "type": "{ status: any; error: any; bundleRequestUrl: any; onRetry: any; worldData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/useBundleLoader.js::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/useBundleLoader.js", "sourceCode": "export default function useBundleLoader() {\n  const { bundle, status, error, bundleRequestUrl, loadBundle } = useLoadBundle();\n  const dexieSeededAt = useDexiePersistence(bundle);\n  const preloads = useBundlePreloads(bundle);\n\n  return { bundle, status, error, bundleRequestUrl, loadBundle, dexieSeededAt, ...preloads };\n}", "parameters": [], "returnType": "{ preloadedChronicles: any; preloadedStaticPages: any; preloadedEraNarratives: any; bundle: any; status: string; error: any; bundleRequestUrl: string; loadBundle: () => Promise<void>; dexieSeededAt: number; }"}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::overwriteWorldDataInDexie", "name": "overwriteWorldDataInDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "export async function overwriteWorldDataInDexie({\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}: {\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}) {\n  if (!projectId || !worldData) return;\n\n  const simulationRunId = worldData?.metadata?.simulationRunId;\n  if (!simulationRunId) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    // Determine which stores to include in the transaction\n    const storeNames = [\n      \"entities\",\n      \"relationships\",\n      \"narrativeEvents\",\n      \"simulationSlots\",\n      \"worldSchemas\",\n      \"coordinateStates\",\n      \"chronicles\",\n      \"staticPages\",\n    ];\n    const hasEraNarrativesStore = db.objectStoreNames.contains(\"eraNarratives\");\n    if (hasEraNarrativesStore) {\n      storeNames.push(\"eraNarratives\");\n    }\n\n    const tx = db.transaction(storeNames, \"readwrite\");\n\n    const entitiesStore = tx.objectStore(\"entities\");\n    const relationshipsStore = tx.objectStore(\"relationships\");\n    const eventsStore = tx.objectStore(\"narrativeEvents\");\n    const slotsStore = tx.objectStore(\"simulationSlots\");\n    const schemasStore = tx.objectStore(\"worldSchemas\");\n    const coordinateStore = tx.objectStore(\"coordinateStates\");\n    const chroniclesStore = tx.objectStore(\"chronicles\");\n    const staticPagesStore = tx.objectStore(\"staticPages\");\n    const eraNarrativesStore = hasEraNarrativesStore ? tx.objectStore(\"eraNarratives\") : null;\n\n    const deleteOps = [\n      deleteByIndex(entitiesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(relationshipsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(eventsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(chroniclesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(staticPagesStore, \"projectId\", projectId),\n    ];\n    if (eraNarrativesStore) {\n      deleteOps.push(deleteByIndex(eraNarrativesStore, \"simulationRunId\", simulationRunId));\n    }\n    await Promise.all(deleteOps);\n\n    const entities = Array.isArray(worldData.hardState)\n      ? worldData.hardState.map((entity: any) => ({ ...entity, simulationRunId }))\n      : [];\n    const relationships = Array.isArray(worldData.relationships)\n      ? worldData.relationships.map((rel: any) => ({ ...rel, simulationRunId }))\n      : [];\n    const narrativeEvents = Array.isArray(worldData.narrativeHistory)\n      ? worldData.narrativeHistory.map((event: any) => ({ ...event, simulationRunId }))\n      : [];\n\n    const slotRecord = {\n      projectId,\n      slotIndex,\n      simulationRunId,\n      finalTick: Number.isFinite(worldData.metadata?.tick) ? worldData.metadata.tick : null,\n      finalEraId: worldData.metadata?.era ?? null,\n      label: null,\n      isTemporary: slotIndex === 0,\n      updatedAt: Date.now(),\n    };\n\n    await Promise.all([\n      bulkPut(entitiesStore, entities),\n      bulkPut(relationshipsStore, relationships),\n      bulkPut(eventsStore, narrativeEvents),\n      requestToPromise(slotsStore.put(slotRecord)),\n      worldData.schema\n        ? requestToPromise(\n            schemasStore.put({ projectId, schema: worldData.schema, updatedAt: Date.now() })\n          )\n        : Promise.resolve(),\n      worldData.coordinateState\n        ? requestToPromise(\n            coordinateStore.put({\n              simulationRunId,\n              coordinateState: worldData.coordinateState,\n              updatedAt: Date.now(),\n            })\n          )\n        : Promise.resolve(),\n    ]);\n\n    if (Array.isArray(chronicles) && chronicles.length > 0) {\n      const normalizedChronicles = chronicles.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(chroniclesStore, normalizedChronicles);\n    }\n\n    if (Array.isArray(staticPages) && staticPages.length > 0) {\n      const normalizedPages = staticPages.map((page: any) => ({\n        ...page,\n        projectId: page.projectId || projectId,\n      }));\n      await bulkPut(staticPagesStore, normalizedPages);\n    }\n\n    if (eraNarrativesStore && Array.isArray(eraNarratives) && eraNarratives.length > 0) {\n      const normalizedNarratives = eraNarratives.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(eraNarrativesStore, normalizedNarratives);\n    }\n\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}", "type": "{\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::appendNarrativeEventsToDexie", "name": "appendNarrativeEventsToDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function appendNarrativeEventsToDexie(simulationRunId: string, events: any[]) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    const tx = db.transaction([\"narrativeEvents\"], \"readwrite\");\n    const store = tx.objectStore(\"narrativeEvents\");\n    const records = events.map((event) => ({ ...event, simulationRunId }));\n    await bulkPut(store, records);\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "any[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "packages/canonry-dsl/src/compile.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl/src/compile.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl/src/index.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/parser.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/parser.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl-v2/src/compile.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/compile.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl-v2/src/compile.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/compile.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl-v2/src/index.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl-v2/src/index.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>"}, {"id": "packages/canonry-dsl-v2/src/index.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult"}, {"id": "packages/canonry-dsl-v2/src/index.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl-v2/src/index.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl-v2/src/parser.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/parser.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]"}, {"id": "packages/canonry-dsl-v2/src/serialize.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/serialize.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "packages/canonry-dsl-v2/src/serialize.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/serialize.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]"}, {"id": "tools/drift-semantic/extractor/src/behaviorMarkers.ts::analyzeBehavior", "name": "analyzeBehavior", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/behaviorMarkers.ts", "sourceCode": "/**\n * Walk the AST subtree rooted at `node` and detect behavioral markers.\n */\nexport function analyzeBehavior(node: Node): BehaviorMarkers {\n  const markers: BehaviorMarkers = {\n    isAsync: false,\n    hasErrorHandling: false,\n    hasLoadingState: false,\n    hasEmptyState: false,\n    hasRetryLogic: false,\n    rendersIteration: false,\n    rendersConditional: false,\n    sideEffects: false,\n  };\n\n  // Check if the function itself is async\n  if (Node.isFunctionDeclaration(node) || Node.isMethodDeclaration(node)) {\n    markers.isAsync = node.isAsync();\n  } else if (Node.isVariableDeclaration(node)) {\n    const init = node.getInitializer();\n    if (init && Node.isArrowFunction(init)) {\n      markers.isAsync = init.isAsync();\n    } else if (init && Node.isFunctionExpression(init)) {\n      markers.isAsync = init.isAsync();\n    }\n  }\n\n  // Walk the full subtree once and check patterns\n  node.forEachDescendant(desc => {\n    const kindNum = desc.getKind();\n\n    // hasErrorHandling: try/catch or .catch()\n    if (kindNum === SyntaxKind.TryStatement) {\n      markers.hasErrorHandling = true;\n    }\n    if (Node.isPropertyAccessExpression(desc) && desc.getName() === 'catch') {\n      markers.hasErrorHandling = true;\n    }\n\n    // hasLoadingState: variable/state named loading/isLoading/pending\n    if (Node.isIdentifier(desc)) {\n      const name = desc.getText();\n      if (/^(loading|isLoading|isPending|pending|isSubmitting)$/.test(name)) {\n        markers.hasLoadingState = true;\n      }\n      // hasRetryLogic: retry/attempt/MAX_RETRIES identifiers\n      if (/^(retry|retryCount|attempt|attempts|MAX_RETRIES|maxRetries|retries)$/i.test(name)) {\n        markers.hasRetryLogic = true;\n      }\n    }\n\n    // hasEmptyState: checks for .length === 0 or !data patterns\n    if (Node.isBinaryExpression(desc)) {\n      const text = desc.getText();\n      if (/\\.length\\s*===?\\s*0/.test(text) || /\\.length\\s*!==?\\s*[^0]/.test(text) === false && /\\.length\\s*<\\s*1/.test(text)) {\n        markers.hasEmptyState = true;\n      }\n    }\n    if (Node.isPrefixUnaryExpression(desc) && desc.getOperatorToken() === SyntaxKind.ExclamationToken) {\n      const operand = desc.getOperand();\n      if (Node.isIdentifier(operand)) {\n        const name = operand.getText();\n        if (/^(data|items|results|entries|records|list|rows)$/i.test(name)) {\n          markers.hasEmptyState = true;\n        }\n      }\n    }\n\n    // rendersIteration: .map() in JSX context\n    if (Node.isCallExpression(desc)) {\n      const expr = desc.getExpression();\n      if (Node.isPropertyAccessExpression(expr) && expr.getName() === 'map') {\n        // Check if ancestor is a JSX expression\n        let ancestor: Node | undefined = desc.getParent();\n        while (ancestor) {\n          if (ancestor.getKind() === SyntaxKind.JsxExpression) {\n            markers.rendersIteration = true;\n            break;\n          }\n          if (ancestor.getKind() === SyntaxKind.ReturnStatement) {\n            markers.rendersIteration = true;\n            break;\n          }\n          ancestor = ancestor.getParent();\n        }\n      }\n\n      // sideEffects: useEffect, addEventListener, setTimeout, setInterval\n      const callText = desc.getExpression().getText();\n      if (/^(useEffect|useLayoutEffect)$/.test(callText)) {\n        markers.sideEffects = true;\n      }\n      if (/addEventListener|setTimeout|setInterval|requestAnimationFrame/.test(callText)) {\n        markers.sideEffects = true;\n      }\n    }\n\n    // rendersConditional: && or ternary in JSX return context\n    if (kindNum === SyntaxKind.JsxExpression) {\n      const exprChild = desc.getChildAtIndex(1); // The expression inside { }\n      if (exprChild) {\n        const exprText = exprChild.getText();\n        // Pattern: condition && <Jsx> or condition ? <A> : <B>\n        if (exprChild.getKind() === SyntaxKind.BinaryExpression) {\n          const opToken = exprChild.getChildAtIndex(1);\n          if (opToken && opToken.getKind() === SyntaxKind.AmpersandAmpersandToken) {\n            markers.rendersConditional = true;\n          }\n        }\n        if (exprChild.getKind() === SyntaxKind.ConditionalExpression) {\n          markers.rendersConditional = true;\n        }\n        // Also handle nested ternaries/&& in the text\n        if (!markers.rendersConditional && (/&&/.test(exprText) || /\\?.*:/.test(exprText))) {\n          markers.rendersConditional = true;\n        }\n      }\n    }\n  });\n\n  return markers;\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "BehaviorMarkers"}, {"id": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts::analyzeCallGraph", "name": "analyzeCallGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts", "sourceCode": "/**\n * Analyze outbound call graph for a function/component/hook.\n *\n * Walks the function body, finds all CallExpression nodes, resolves targets,\n * classifies call context, and detects method chain patterns.\n */\nexport function analyzeCallGraph(node: Node, _sourceFile: SourceFile): CallGraphInfo {\n  const callees: CalleeEntry[] = [];\n  const calleesByContext = new Map<string, string[]>();\n  const chainPatterns = new Set<string>();\n  let maxChainDepth = 0;\n  const uniqueTargets = new Set<string>();\n\n  // Get the function body to analyze\n  const body = getFunctionBody(node);\n  if (!body) {\n    return {\n      callees: [],\n      calleeSequence: {},\n      callDepth: 0,\n      uniqueCallees: 0,\n      chainPatterns: [],\n    };\n  }\n\n  // Find all call expressions\n  body.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    // Skip if this call is inside a nested function definition (not our scope)\n    // unless it's inside useEffect/useCallback/useMemo callbacks which ARE our scope\n    if (isInsideNestedFunctionDef(desc, body)) return;\n\n    const target = resolveCallTarget(desc);\n    const context = classifyCallContext(desc, body);\n\n    callees.push({ target, context });\n    uniqueTargets.add(target);\n\n    // Add to context-grouped sequence\n    if (!calleesByContext.has(context)) {\n      calleesByContext.set(context, []);\n    }\n    calleesByContext.get(context)!.push(target);\n\n    // Detect method chain patterns\n    const chainDepth = detectChainPattern(desc, chainPatterns);\n    if (chainDepth > maxChainDepth) maxChainDepth = chainDepth;\n  });\n\n  // Build calleeSequence record\n  const calleeSequence: Record<string, string[]> = {};\n  for (const [ctx, targets] of calleesByContext) {\n    calleeSequence[ctx] = targets;\n  }\n\n  return {\n    callees,\n    calleeSequence,\n    callDepth: maxChainDepth,\n    uniqueCallees: uniqueTargets.size,\n    chainPatterns: [...chainPatterns],\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}, {"name": "_sourceFile", "type": "SourceFile", "optional": false}], "returnType": "CallGraphInfo"}, {"id": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts::buildConsumerGraph", "name": "buildConsumerGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts", "sourceCode": "/**\n * Build the consumer graph across all extracted units (second pass).\n *\n * For each unit, looks at its imports. For each internal import that resolves\n * to a file with known exported units, adds this unit as a consumer of those\n * target units. Then computes consumer counts, kinds, directories, and\n * co-occurrence data.\n *\n * Mutates units in place.\n */\nexport function buildConsumerGraph(units: CodeUnit[]): void {\n  // Build lookup maps\n  const unitById = new Map<string, CodeUnit>();\n  const unitsByFile = new Map<string, string[]>(); // filePath \u2192 list of unit IDs\n\n  for (const unit of units) {\n    unitById.set(unit.id, unit);\n\n    if (!unitsByFile.has(unit.filePath)) {\n      unitsByFile.set(unit.filePath, []);\n    }\n    unitsByFile.get(unit.filePath)!.push(unit.id);\n  }\n\n  // First pass: build consumer lists\n  // For each unit, look at its internal imports and link to target units\n  for (const unit of units) {\n    for (const imp of unit.imports) {\n      if (imp.category !== 'internal') continue;\n\n      // Resolve the import source relative to the unit's file\n      const resolvedTargets = resolveImportToFile(unit.filePath, imp.source, unitsByFile);\n\n      for (const targetUnitId of resolvedTargets) {\n        const targetUnit = unitById.get(targetUnitId);\n        if (!targetUnit) continue;\n        if (targetUnit.id === unit.id) continue; // Don't self-reference\n\n        // Check if any of the imported specifiers match the target unit name\n        const targetName = targetUnit.name;\n        const specifierMatch = imp.specifiers.length === 0 || // default import or namespace\n          imp.specifiers.some(spec => {\n            // Handle \"Name as Alias\" patterns\n            const baseName = spec.includes(' as ') ? spec.split(' as ')[0].trim() : spec;\n            return baseName === targetName || baseName === 'default' || spec.startsWith('* as');\n          });\n\n        if (specifierMatch) {\n          if (!targetUnit.consumers.includes(unit.id)) {\n            targetUnit.consumers.push(unit.id);\n          }\n        }\n      }\n    }\n  }\n\n  // Second pass: compute consumer metadata\n  for (const unit of units) {\n    unit.consumerCount = unit.consumers.length;\n\n    // Consumer kinds: set of kinds that consume this unit\n    const kindSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) kindSet.add(consumer.kind);\n    }\n    unit.consumerKinds = [...kindSet].sort();\n\n    // Consumer directories: set of directory prefixes\n    const dirSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) {\n        // Use the first two path segments as directory prefix\n        const parts = consumer.filePath.split('/');\n        if (parts.length >= 2) {\n          dirSet.add(parts.slice(0, 2).join('/'));\n        } else {\n          dirSet.add(parts[0]);\n        }\n      }\n    }\n    unit.consumerDirectories = [...dirSet].sort();\n  }\n\n  // Third pass: build co-occurrence data\n  buildCoOccurrences(units, unitById, unitsByFile);\n}", "parameters": [{"name": "units", "type": "CodeUnit[]", "optional": false}], "returnType": "void"}, {"id": "tools/drift-semantic/extractor/src/hookAnalyzer.ts::analyzeHooks", "name": "analyzeHooks", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/hookAnalyzer.ts", "sourceCode": "/**\n * Analyze hook usage within a function/component body.\n *\n * Finds all call expressions where the callee name starts with `use` (React convention).\n * Counts occurrences, categorizes built-in vs custom, and counts state variables.\n */\nexport function analyzeHooks(node: Node): HookInfo {\n  const hookCounts = new Map<string, number>();\n  const customHookSet = new Set<string>();\n  let stateVariableCount = 0;\n\n  node.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    const expr = desc.getExpression();\n    let hookName: string | null = null;\n\n    // Direct call: useFoo()\n    if (Node.isIdentifier(expr)) {\n      const name = expr.getText();\n      if (name.startsWith('use') && name.length > 3 && name[3] === name[3].toUpperCase()) {\n        hookName = name;\n      }\n    }\n\n    // Namespaced call: React.useState()\n    if (Node.isPropertyAccessExpression(expr)) {\n      const propName = expr.getName();\n      if (propName.startsWith('use') && propName.length > 3 && propName[3] === propName[3].toUpperCase()) {\n        hookName = propName;\n      }\n    }\n\n    if (!hookName) return;\n\n    // Count occurrences\n    hookCounts.set(hookName, (hookCounts.get(hookName) ?? 0) + 1);\n\n    // Classify as custom if not a React built-in\n    if (!REACT_BUILT_IN_HOOKS.has(hookName)) {\n      customHookSet.add(hookName);\n    }\n\n    // Count state variables from useState destructuring:\n    // const [value, setValue] = useState(...)\n    if (hookName === 'useState') {\n      const parent = desc.getParent();\n      if (parent && Node.isVariableDeclaration(parent)) {\n        const nameNode = parent.getNameNode();\n        if (Node.isArrayBindingPattern(nameNode)) {\n          // Each element with a \"set\" prefix is a setter\n          const elements = nameNode.getElements();\n          // Count the number of state values (the non-setter elements, typically first)\n          // Standard pattern: [value, setValue] = one state variable\n          stateVariableCount += 1;\n        }\n      }\n    }\n  });\n\n  // Build ordered hookCalls list (ordered by first appearance - Map preserves insertion order)\n  const hookCalls: HookCallEntry[] = [];\n  for (const [name, count] of hookCounts) {\n    hookCalls.push({ name, count });\n  }\n\n  return {\n    hookCalls,\n    customHookCalls: [...customHookSet].sort(),\n    stateVariableCount,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "HookInfo"}, {"id": "tools/drift-semantic/extractor/src/importAnalyzer.ts::analyzeImports", "name": "analyzeImports", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/importAnalyzer.ts", "sourceCode": "/**\n * Analyze all imports in a source file.\n * Also detects store access patterns and data source access.\n */\nexport function analyzeImports(sourceFile: SourceFile, _projectRoot: string): ImportInfo {\n  const imports: ImportEntry[] = [];\n  const storeAccess: string[] = [];\n  const dataSourceAccess: string[] = [];\n\n  // Process import declarations\n  for (const decl of sourceFile.getImportDeclarations()) {\n    const source = decl.getModuleSpecifierValue();\n    const specifiers: string[] = [];\n\n    // Default import\n    const defaultImport = decl.getDefaultImport();\n    if (defaultImport) {\n      specifiers.push(defaultImport.getText());\n    }\n\n    // Named imports\n    for (const named of decl.getNamedImports()) {\n      const alias = named.getAliasNode();\n      specifiers.push(alias ? `${named.getName()} as ${alias.getText()}` : named.getName());\n    }\n\n    // Namespace import\n    const nsImport = decl.getNamespaceImport();\n    if (nsImport) {\n      specifiers.push(`* as ${nsImport.getText()}`);\n    }\n\n    imports.push({\n      source,\n      specifiers,\n      category: categorizeImport(source),\n    });\n  }\n\n  // Detect store access patterns in the full file text\n  const fullText = sourceFile.getFullText();\n\n  // useXxxStore() calls\n  const storeCallPattern = /\\buse(\\w+Store)\\s*\\(/g;\n  let match: RegExpExecArray | null;\n  const seenStores = new Set<string>();\n  while ((match = storeCallPattern.exec(fullText)) !== null) {\n    const storeName = `use${match[1]}`;\n    if (!seenStores.has(storeName)) {\n      seenStores.add(storeName);\n      storeAccess.push(storeName);\n    }\n  }\n\n  // store.getState() / store.setState() patterns\n  const storeGetSetPattern = /\\b(\\w+Store)\\.(getState|setState|subscribe)\\s*\\(/g;\n  while ((match = storeGetSetPattern.exec(fullText)) !== null) {\n    const access = `${match[1]}.${match[2]}`;\n    if (!seenStores.has(access)) {\n      seenStores.add(access);\n      storeAccess.push(access);\n    }\n  }\n\n  // Data source access patterns\n  const seenDataSources = new Set<string>();\n\n  // Dexie: db.tableName patterns\n  const dbTablePattern = /\\bdb\\.(\\w+)\\b/g;\n  while ((match = dbTablePattern.exec(fullText)) !== null) {\n    const access = `db.${match[1]}`;\n    if (!seenDataSources.has(access)) {\n      seenDataSources.add(access);\n      dataSourceAccess.push(access);\n    }\n  }\n\n  // useLiveQuery calls\n  if (/\\buseLiveQuery\\s*\\(/.test(fullText)) {\n    if (!seenDataSources.has('useLiveQuery')) {\n      seenDataSources.add('useLiveQuery');\n      dataSourceAccess.push('useLiveQuery');\n    }\n  }\n\n  // fetch() calls\n  sourceFile.forEachDescendant(node => {\n    if (Node.isCallExpression(node)) {\n      const expr = node.getExpression();\n      if (Node.isIdentifier(expr) && expr.getText() === 'fetch') {\n        if (!seenDataSources.has('fetch')) {\n          seenDataSources.add('fetch');\n          dataSourceAccess.push('fetch');\n        }\n      }\n    }\n  });\n\n  return { imports, storeAccess, dataSourceAccess };\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "_projectRoot", "type": "string", "optional": false}], "returnType": "ImportInfo"}, {"id": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts::analyzeJsx", "name": "analyzeJsx", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts", "sourceCode": "/**\n * Analyze JSX structure in a component function.\n *\n * Returns null for non-component functions (no JSX return).\n * Builds a nested tree of JSX elements with map/conditional markers.\n * Strips attributes/props -- we only care about structural nesting.\n */\nexport function analyzeJsx(node: Node): JsxInfo | null {\n  // Find return statements that contain JSX\n  const returnStatements = node.getDescendantsOfKind(SyntaxKind.ReturnStatement);\n\n  let jsxRoot: Node | null = null;\n\n  for (const ret of returnStatements) {\n    const expr = ret.getExpression();\n    if (!expr) continue;\n\n    // Check if the return expression is JSX or a parenthesized JSX\n    if (isJsxNode(expr)) {\n      jsxRoot = expr;\n      break;\n    }\n\n    // Check inside parenthesized expression\n    if (Node.isParenthesizedExpression(expr)) {\n      const inner = expr.getExpression();\n      if (isJsxNode(inner)) {\n        jsxRoot = inner;\n        break;\n      }\n    }\n  }\n\n  // Also handle arrow functions with expression bodies (no explicit return):\n  // const Foo = () => <div>...</div>\n  if (!jsxRoot) {\n    if (Node.isArrowFunction(node)) {\n      const body = node.getBody();\n      if (body && isJsxNode(body)) {\n        jsxRoot = body;\n      } else if (body && Node.isParenthesizedExpression(body)) {\n        const inner = body.getExpression();\n        if (isJsxNode(inner)) {\n          jsxRoot = inner;\n        }\n      }\n    }\n    // For VariableDeclaration wrapping an arrow function\n    if (!jsxRoot && Node.isVariableDeclaration(node)) {\n      const init = node.getInitializer();\n      if (init && Node.isArrowFunction(init)) {\n        const body = init.getBody();\n        if (body && isJsxNode(body)) {\n          jsxRoot = body;\n        } else if (body && Node.isParenthesizedExpression(body)) {\n          const inner = body.getExpression();\n          if (isJsxNode(inner)) {\n            jsxRoot = inner;\n          }\n        }\n      }\n    }\n  }\n\n  if (!jsxRoot) return null;\n\n  const tree = buildJsxTree(jsxRoot, false, false);\n  if (!tree) return null;\n\n  const leafElements: string[] = [];\n  const depth = computeDepthAndLeaves(tree, leafElements);\n\n  return {\n    jsxTree: tree,\n    jsxLeafElements: [...new Set(leafElements)],\n    jsxDepth: depth,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "JsxInfo | null"}, {"id": "tools/drift-semantic/extractor/src/projectLoader.ts::loadProjects", "name": "loadProjects", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/projectLoader.ts", "sourceCode": "/**\n * Load all TypeScript/JavaScript projects from the monorepo.\n *\n * - Creates a ts-morph Project for each tsconfig.json / tsconfig.app.json\n * - For webui directories not covered by any tsconfig, creates an ad-hoc Project\n *   with allowJs + JSX support\n * - Returns projects and a set of seen absolute file paths for deduplication\n */\nexport function loadProjects(projectRoot: string): LoadedProjects {\n  const tsconfigPaths = findTsconfigFiles(projectRoot);\n  const seenFiles = new Set<string>();\n  const projects: Project[] = [];\n\n  // Prefer tsconfig.app.json over tsconfig.json when both exist in same dir\n  const byDir = new Map<string, string[]>();\n  for (const tc of tsconfigPaths) {\n    const dir = path.dirname(tc);\n    if (!byDir.has(dir)) byDir.set(dir, []);\n    byDir.get(dir)!.push(tc);\n  }\n\n  const selectedTsconfigs: string[] = [];\n  for (const [, configs] of byDir) {\n    const appConfig = configs.find(c => path.basename(c) === 'tsconfig.app.json');\n    // If tsconfig.app.json exists, prefer it (it's the actual source config);\n    // otherwise use tsconfig.json\n    selectedTsconfigs.push(appConfig ?? configs[0]);\n  }\n\n  for (const tsconfigPath of selectedTsconfigs) {\n    try {\n      const project = new Project({ tsConfigFilePath: tsconfigPath });\n      const sourceFiles = project.getSourceFiles();\n\n      // Track which files this project covers\n      for (const sf of sourceFiles) {\n        seenFiles.add(sf.getFilePath());\n      }\n\n      projects.push(project);\n      process.stderr.write(`  tsconfig: ${path.relative(projectRoot, tsconfigPath)} \u2192 ${sourceFiles.length} files\\n`);\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to load ${path.relative(projectRoot, tsconfigPath)}: ${err}\\n`);\n    }\n  }\n\n  // Find and create ad-hoc projects for uncovered webui directories\n  const uncoveredWebuis = findUncoveredWebuis(projectRoot, selectedTsconfigs);\n\n  for (const webuiDir of uncoveredWebuis) {\n    try {\n      const project = new Project({\n        compilerOptions: {\n          target: ts.ScriptTarget.ES2022,\n          module: ts.ModuleKind.ESNext,\n          moduleResolution: ts.ModuleResolutionKind.Bundler,\n          allowJs: true,\n          jsx: ts.JsxEmit.ReactJSX,\n          strict: false,\n          noEmit: true,\n          esModuleInterop: true,\n          skipLibCheck: true,\n        },\n      });\n\n      // Add all .js/.jsx/.ts/.tsx files from the webui/src directory\n      const srcDir = path.join(webuiDir, 'src');\n      if (fs.existsSync(srcDir)) {\n        addSourceFilesRecursively(project, srcDir, seenFiles);\n      }\n\n      const sourceFiles = project.getSourceFiles();\n      if (sourceFiles.length > 0) {\n        projects.push(project);\n        process.stderr.write(`  ad-hoc:   ${path.relative(projectRoot, webuiDir)}/src \u2192 ${sourceFiles.length} files\\n`);\n      }\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to create ad-hoc project for ${path.relative(projectRoot, webuiDir)}: ${err}\\n`);\n    }\n  }\n\n  return { projects, seenFiles };\n}", "parameters": [{"name": "projectRoot", "type": "string", "optional": false}], "returnType": "LoadedProjects"}, {"id": "tools/drift-semantic/extractor/src/unitExtractor.ts::extractUnits", "name": "extractUnits", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/unitExtractor.ts", "sourceCode": "/**\n * Extract all exported code units from a source file.\n *\n * Iterates over all exported declarations, determines their kind,\n * runs all analyzers, and returns an array of CodeUnit records.\n */\nexport function extractUnits(sourceFile: SourceFile, projectRoot: string): CodeUnit[] {\n  const units: CodeUnit[] = [];\n  const relativePath = path.relative(projectRoot, sourceFile.getFilePath());\n\n  // Import analysis is per-file (shared across all units in the file)\n  const importInfo = analyzeImports(sourceFile, projectRoot);\n\n  let exportedDeclarations: ReadonlyMap<string, Node[]>;\n  try {\n    exportedDeclarations = sourceFile.getExportedDeclarations();\n  } catch {\n    process.stderr.write(`  WARN: failed to get exports from ${relativePath}\\n`);\n    return units;\n  }\n\n  if (exportedDeclarations.size === 0) return units;\n\n  for (const [exportName, declarations] of exportedDeclarations) {\n    for (const decl of declarations) {\n      try {\n        const unit = extractSingleUnit(decl, exportName, relativePath, sourceFile, projectRoot, importInfo);\n        if (unit) units.push(unit);\n      } catch (err) {\n        process.stderr.write(`  WARN: failed to extract ${exportName} from ${relativePath}: ${err}\\n`);\n      }\n    }\n  }\n\n  return units;\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "projectRoot", "type": "string", "optional": false}], "returnType": "CodeUnit[]"}, {"id": "config/federation.js::federationOnWarn", "name": "federationOnWarn", "kind": "function", "filePath": "config/federation.js", "sourceCode": "/**\r\n * Shared Module Federation configuration utilities.\r\n *\r\n * All MFE vite configs should import from this module to avoid\r\n * duplicating boilerplate (onwarn handlers, shared dep declarations).\r\n */\r\n\r\n/**\r\n * Rollup onwarn handler that silences benign eval warnings from\r\n * @module-federation/sdk. Without this, every MFE build emits\r\n * dozens of EVAL warnings that are not actionable.\r\n */\r\nexport function federationOnWarn(warning, warn) {\r\n  const isModuleFederationEval =\r\n    warning.code === 'EVAL' &&\r\n    (warning.id?.includes('@module-federation/sdk') ||\r\n      warning.message.includes('@module-federation/sdk'));\r\n  if (isModuleFederationEval) return;\r\n  warn(warning);\r\n}", "parameters": [{"name": "warning", "type": "any", "optional": false}, {"name": "warn", "type": "any", "optional": false}], "returnType": "void"}, {"id": "config/federation.js::sharedDeps", "name": "sharedDeps", "kind": "function", "filePath": "config/federation.js", "sourceCode": "/**\r\n * Build a shared deps object by picking from the extended set.\r\n * Only declare what the app actually uses.\r\n *\r\n * @param {...string} keys - Package names to include beyond base deps\r\n * @returns {Record<string, object>} Shared dependency config\r\n *\r\n * @example\r\n * // Just react/react-dom\r\n * sharedDeps()\r\n *\r\n * @example\r\n * // react/react-dom + zustand + image-store\r\n * sharedDeps('zustand', '@the-canonry/image-store')\r\n */\r\nexport function sharedDeps(...keys) {\r\n  if (keys.length === 0) return { ...sharedDepsBase };\r\n  const result = { ...sharedDepsBase };\r\n  for (const key of keys) {\r\n    if (sharedDepsExtended[key]) {\r\n      result[key] = sharedDepsExtended[key];\r\n    } else {\r\n      result[key] = { singleton: true };\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "keys", "type": "string[]", "optional": false}], "returnType": "Record<string, any>"}]