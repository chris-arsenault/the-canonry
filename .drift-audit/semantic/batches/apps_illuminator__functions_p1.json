[{"id": "apps/illuminator/webui/src/IlluminatorRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/IlluminatorRemote.jsx", "sourceCode": "export default function IlluminatorRemote({\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}) {\n  const activeTab = activeSection || \"entities\";\n  const setActiveTab = onSectionChange || (() => {});\n  const [chronicleRefreshTrigger, setChronicleRefreshTrigger] = useState(0);\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominenceScale = useProminenceScale();\n  const apiKeys = useApiKeys();\n  const { config, updateConfig } = useConfigSync({\n    externalEnrichmentConfig,\n    onEnrichmentConfigChange,\n  });\n  const { worldContext, updateWorldContext } = useWorldContextSync({\n    externalWorldContext,\n    onWorldContextChange,\n  });\n  const guidance = useEntityGuidanceSync({\n    externalEntityGuidance,\n    onEntityGuidanceChange,\n    externalCultureIdentities,\n    onCultureIdentitiesChange,\n  });\n  const { historianConfig, updateHistorianConfig } = useHistorianConfigSync({\n    externalHistorianConfig,\n    onHistorianConfigChange,\n  });\n  const slot = useSlotManagement({ projectId, activeSlotIndex, navEntities });\n  const dataSync = useDataSync({\n    projectId,\n    activeSlotIndex,\n    worldData,\n    hasHardState: Boolean(worldData?.hardState?.length),\n    slotRecord: slot.slotRecord,\n    setSlotRecord: slot.setSlotRecord,\n    simulationRunId: slot.simulationRunId,\n    eraTemporalInfo: slot.eraTemporalInfo,\n  });\n  const setup = useIlluminatorSetup({\n    projectId,\n    worldData,\n    schema,\n    onStyleSelectionChange,\n    config,\n    apiKeys,\n    slotRecord: slot.slotRecord,\n    currentEra: slot.currentEra,\n    simulationRunId: slot.simulationRunId,\n    handleEntityUpdate: dataSync.handleEntityUpdate,\n    reloadEntities: dataSync.reloadEntities,\n    reloadEntitiesAndEvents: dataSync.reloadEntitiesAndEvents,\n    worldContext,\n    historianConfig,\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    navEntities,\n    setChronicleRefreshTrigger,\n  });\n  const { buildPrompt, getVisualConfig } = usePromptBuilder({\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    worldContext,\n    relationshipsByEntity,\n    entityNavMap,\n    currentEra: slot.currentEra,\n    narrativeEvents,\n    prominentByCulture: slot.prominentByCulture,\n    styleSelection: setup.styleSelection,\n    worldSchema: setup.worldSchema,\n    config,\n    prominenceScale,\n    styleLibrary: setup.styleLibrary,\n    eraTemporalInfo: slot.eraTemporalInfo,\n    eraTemporalInfoByKey: slot.eraTemporalInfoByKey,\n  });\n  const flows = useIlluminatorFlows({\n    projectId,\n    simulationRunId: slot.simulationRunId,\n    navEntities,\n    entityNavMap,\n    relationshipsByEntity,\n    relationships,\n    prominenceScale,\n    worldContext,\n    worldSchema: setup.worldSchema,\n    entityGuidance: guidance.entityGuidance,\n    reloadEntities: dataSync.reloadEntities,\n    setChronicleRefreshTrigger,\n    historianConfig,\n    updateWorldContext,\n  });\n  if (!setup.hasWorldData) {\n    return (\n      <EmptyState\n        icon=\"\u2728\"\n        title={setup.canImport ? \"No Local Data Loaded\" : \"No World Data\"}\n        className=\"illuminator-empty-state\"\n      >\n        <div className=\"empty-state-desc\">\n          {setup.canImport ? (\n            \"Dexie is empty for this slot. Import from hard state to begin.\"\n          ) : (\n            <>\n              Run a simulation in <strong>Lore Weave</strong> first, then return here to enrich your\n              world with LLM-generated descriptions and images.\n            </>\n          )}\n        </div>\n        {setup.canImport && (\n          <div className=\"ies-import-actions\">\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-primary\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"patch\")}\n            >\n              {dataSync.isDataSyncing ? \"Importing...\" : \"Patch from Hard State\"}\n            </button>\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-danger\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"overwrite\")}\n            >\n              Overwrite from Hard State\n            </button>\n          </div>\n        )}\n        {dataSync.dataSyncStatus && (\n          <div\n            className={`ies-sync-status ${dataSync.dataSyncStatus.type === \"error\" ? \"ies-sync-status-error\" : \"ies-sync-status-success\"}`}\n          >\n            {dataSync.dataSyncStatus.message}\n          </div>\n        )}\n      </EmptyState>\n    );\n  }\n  const sharedProps = buildSharedProps({\n    activeTab,\n    setActiveTab,\n    worldData,\n    updateWorldContext,\n    guidance,\n    updateHistorianConfig,\n    config,\n    updateConfig,\n    buildPrompt,\n    getVisualConfig,\n    chronicleRefreshTrigger,\n    setChronicleRefreshTrigger,\n    setup,\n    dataSync,\n    flows,\n    apiKeys,\n  });\n  return (\n    <div className=\"illuminator-container\">\n      <IlluminatorSidebar\n        activeTab={activeTab}\n        setActiveTab={setActiveTab}\n        stats={setup.stats}\n        imageGenSettings={setup.imageGenSettings}\n        styleLibrary={setup.styleLibrary}\n        {...apiKeys}\n      />\n      <div className=\"illuminator-main\">\n        {setup.isTemporarySlot && (\n          <div className=\"illuminator-temp-slot-warning\">\n            <span className=\"illuminator-temp-slot-warning-icon\">&#x26A0;</span>\n            <span>\n              You are enriching data in a <strong>temporary slot</strong>, which will be\n              automatically deleted when a new Lore Weave simulation is run.\n            </span>\n          </div>\n        )}\n        {!apiKeys.hasRequiredKeys && activeTab === \"entities\" && (\n          <div className=\"ilr-api-key-warning\">\n            Set your API keys in the sidebar to enable enrichment.\n          </div>\n        )}\n        <IlluminatorTabContent {...sharedProps} />\n      </div>\n      <IlluminatorModals {...sharedProps} />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ActivityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ActivityPanel.jsx", "sourceCode": "export default function ActivityPanel({\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}) {\n  const [debugItem, setDebugItem] = useState(null);\n  const mouseDownOnOverlay = useRef(false);\n  const handleOverlayMouseDown = useCallback(e => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n  const handleOverlayClick = useCallback(e => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setDebugItem(null);\n    }\n  }, []);\n\n  // Split queue into categories\n  const {\n    running,\n    queued,\n    completed,\n    errored\n  } = useMemo(() => {\n    const running = queue.filter(item => item.status === \"running\");\n    const queued = queue.filter(item => item.status === \"queued\");\n    const completed = queue.filter(item => item.status === \"complete\").sort((a, b) => (b.completedAt || 0) - (a.completedAt || 0)).slice(0, 20);\n    const errored = queue.filter(item => item.status === \"error\");\n    return {\n      running,\n      queued,\n      completed,\n      errored\n    };\n  }, [queue]);\n  const debugRequest = debugItem?.debug?.request || \"\";\n  const debugResponse = debugItem?.debug?.response || \"\";\n  return <div>\n      {/* Stats header */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Activity</h2>\n          <div className=\"ap-header-actions\">\n            {queue.length > 0 && <button onClick={onCancelAll} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Cancel All\n              </button>}\n            {stats.completed > 0 && <button onClick={onClearCompleted} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Clear Completed\n              </button>}\n          </div>\n        </div>\n\n        {/* Stats */}\n        <div className=\"ap-stats-row\">\n          <div>\n            <span className=\"ap-stat-value\">{stats.queued}</span>\n            <span className=\"ap-stat-label\">queued</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-running\">{stats.running}</span>\n            <span className=\"ap-stat-label\">running</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-completed\">{stats.completed}</span>\n            <span className=\"ap-stat-label\">completed</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-errors\">{stats.errored}</span>\n            <span className=\"ap-stat-label\">errors</span>\n          </div>\n        </div>\n      </div>\n\n      {/* Currently Running */}\n      {running.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Currently Running</div>\n          {running.map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Queued */}\n      {queued.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Queued ({queued.length})</div>\n          {queued.slice(0, 10).map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n          {queued.length > 10 && <div className=\"ap-more-indicator\">... and {queued.length - 10} more</div>}\n        </div>}\n\n      {/* Errors */}\n      {errored.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header ap-section-header-errors\">\n            Errors ({errored.length})\n          </div>\n          {errored.map(item => {\n        const activityError = formatActivityError(item);\n        return <div key={item.id}>\n                <TaskRow item={item} onRetry={onRetry} onViewDebug={setDebugItem} />\n                {activityError && <div className=\"ap-error-detail\">{activityError}</div>}\n              </div>;\n      })}\n        </div>}\n\n      {/* Recent Completed */}\n      {completed.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Recent Completed</div>\n          {completed.map(item => <TaskRow key={item.id} item={item} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Empty state */}\n      {queue.length === 0 && <div className=\"illuminator-card\">\n          <div className=\"ap-empty-state\">\n            No activity yet. Queue some enrichment tasks from the Entities tab.\n          </div>\n        </div>}\n\n      {debugItem && <div className=\"illuminator-modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e);\n    }}>\n          <div className=\"illuminator-modal ap-debug-modal\">\n            <div className=\"illuminator-modal-header\">\n              <h3>Network Debug</h3>\n              <button onClick={() => setDebugItem(null)} className=\"illuminator-modal-close\">\n                &times;\n              </button>\n            </div>\n            <div className=\"illuminator-modal-body ap-debug-body\">\n              <div className=\"ap-debug-entity-info\">\n                {debugItem.entityName}\n                {(() => {\n              if (debugItem.type === \"description\") return \" \u00b7 Description\";\n              if (debugItem.type === \"image\") return \" \u00b7 Image\";\n              return \" \u00b7 Chronicle\";\n            })()}\n              </div>\n              <div>\n                <label htmlFor=\"request-raw\" className=\"ap-debug-label\">Request (raw)</label>\n                <textarea id=\"request-raw\" className=\"illuminator-textarea ap-debug-request-textarea\" value={debugRequest} readOnly />\n              </div>\n              <div>\n                <label htmlFor=\"response-raw\" className=\"ap-debug-label\">Response (raw)</label>\n                <textarea id=\"response-raw\" className=\"illuminator-textarea ap-debug-response-textarea\" value={debugResponse} readOnly />\n              </div>\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}", "type": "{ queue: any; stats: any; onCancel: any; onRetry: any; onCancelAll: any; onClearCompleted: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BackportConfigModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackportConfigModal.jsx", "sourceCode": "export default function BackportConfigModal({\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}) {\n  const statusMap = useMemo(() => perEntityStatus || {}, [perEntityStatus]);\n\n  // Only pending entities are selectable\n  const pendingEntities = useMemo(() => entities.filter(e => !statusMap[e.id]), [entities, statusMap]);\n  const [selectedIds, setSelectedIds] = useState(() => new Set(pendingEntities.map(e => e.id)));\n  const [customInstructions, setCustomInstructions] = useState(\"\");\n\n  // Reset selections when entities or status change (new modal open)\n  const entityKey = entities.map(e => e.id).join(\",\");\n  const statusKey = Object.keys(statusMap).sort().join(\",\");\n  const resetKey = `${entityKey}|${statusKey}`;\n  const [prevKey, setPrevKey] = useState(resetKey);\n  if (resetKey !== prevKey) {\n    setPrevKey(resetKey);\n    setSelectedIds(new Set(entities.filter(e => !statusMap[e.id]).map(e => e.id)));\n    setCustomInstructions(\"\");\n  }\n  const castEntities = useMemo(() => entities.filter(e => !e.isLens && !e.isTertiary), [entities]);\n  const lensEntities = useMemo(() => entities.filter(e => e.isLens), [entities]);\n  const tertiaryEntities = useMemo(() => entities.filter(e => e.isTertiary), [entities]);\n  const doneCount = entities.filter(e => statusMap[e.id]).length;\n  const selectedCount = selectedIds.size;\n  const allPendingSelected = selectedCount === pendingEntities.length && pendingEntities.length > 0;\n  if (!isOpen) return null;\n  const toggleEntity = id => {\n    if (statusMap[id]) return; // locked\n    setSelectedIds(prev => {\n      const next = new Set(prev);\n      if (next.has(id)) next.delete(id);else next.add(id);\n      return next;\n    });\n  };\n  const toggleAllPending = () => {\n    if (allPendingSelected) {\n      setSelectedIds(new Set());\n    } else {\n      setSelectedIds(new Set(pendingEntities.map(e => e.id)));\n    }\n  };\n  const selectTertiaryOnly = () => {\n    setSelectedIds(new Set(tertiaryEntities.filter(e => !statusMap[e.id]).map(e => e.id)));\n  };\n  const handleMarkNotNeeded = entityId => {\n    onMarkNotNeeded([entityId]);\n  };\n  let progressColor;\n  if (doneCount === entities.length) progressColor = \"#10b981\";else if (doneCount > 0) progressColor = \"#f59e0b\";else progressColor = \"var(--text-muted)\";\n  const renderEntityRow = e => {\n    const status = statusMap[e.id];\n    const isLocked = !!status;\n    return <div key={e.id} className={`bcm-entity-row ${isLocked ? \"bcm-entity-row-locked\" : \"\"}`}>\n        {isLocked ? <span className={`bcm-status-icon ${status === \"backported\" ? \"bcm-status-icon-done\" : \"bcm-status-icon-skipped\"}`}>\n            {status === \"backported\" ? \"\\u2713\" : \"\\u2014\"}\n          </span> : <input type=\"checkbox\" checked={selectedIds.has(e.id)} onChange={() => toggleEntity(e.id)} className=\"bcm-checkbox\" />}\n        <span className={`bcm-entity-name ${isLocked ? \"bcm-entity-name-locked\" : \"bcm-entity-name-clickable\"}`} onClick={() => !isLocked && toggleEntity(e.id)} role=\"button\" tabIndex={0} onKeyDown={e => {\n        if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n      }}>\n          {e.name}\n          <span className=\"bcm-entity-kind\">\n            {e.kind}\n            {e.subtype ? ` / ${e.subtype}` : \"\"}\n          </span>\n        </span>\n        {/* Status / action tags */}\n        {status === \"backported\" && <span className=\"bcm-tag bcm-tag-done\">Done</span>}\n        {status === \"not_needed\" && <span className=\"bcm-tag bcm-tag-skipped\">Skipped</span>}\n        {!status && <button onClick={ev => {\n        ev.stopPropagation();\n        handleMarkNotNeeded(e.id);\n      }} title=\"Mark as no backport needed\" className=\"bcm-skip-btn\">\n            Skip\n          </button>}\n        {e.isLens && <span className=\"bcm-tag bcm-tag-lens\">Lens</span>}\n        {e.isTertiary && <span className=\"bcm-tag bcm-tag-tertiary\">Tertiary</span>}\n      </div>;\n  };\n  return <div className=\"bcm-overlay\">\n      <div className=\"bcm-dialog\">\n        {/* Header */}\n        <div className=\"bcm-header\">\n          <h2 className=\"bcm-title\">Backport Lore to Cast</h2>\n          <div className=\"bcm-subtitle-row\">\n            <p className=\"bcm-chronicle-title\">{chronicleTitle}</p>\n            <span className=\"bcm-progress\"\n          style={{\n            \"--bcm-progress-color\": progressColor\n          }}>\n              {doneCount}/{entities.length} complete\n            </span>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className=\"bcm-body\">\n          {/* Entity selection */}\n          <div className=\"bcm-section\">\n            <div className=\"bcm-section-header\">\n              <span className=\"bcm-section-label\">\n                Entities ({selectedCount} selected\n                {pendingEntities.length < entities.length ? `, ${doneCount} done` : \"\"})\n              </span>\n              <span className=\"bcm-action-group\">\n                {tertiaryEntities.length > 0 && <button onClick={selectTertiaryOnly} className=\"bcm-text-btn bcm-text-btn-tertiary\">\n                    Tertiary only\n                  </button>}\n                {pendingEntities.length > 0 && <button onClick={toggleAllPending} className=\"bcm-text-btn bcm-text-btn-accent\">\n                    {allPendingSelected ? \"Deselect all\" : \"Select all pending\"}\n                  </button>}\n              </span>\n            </div>\n\n            <div className=\"bcm-entity-list\">\n              {castEntities.map(renderEntityRow)}\n              {lensEntities.length > 0 && castEntities.length > 0 && <div className=\"bcm-divider\" />}\n              {lensEntities.map(renderEntityRow)}\n              {tertiaryEntities.length > 0 && (castEntities.length > 0 || lensEntities.length > 0) && <div className=\"bcm-divider\">\n                    <div className=\"bcm-tertiary-label\">Tertiary Cast</div>\n                  </div>}\n              {tertiaryEntities.map(renderEntityRow)}\n            </div>\n          </div>\n\n          {/* Custom instructions */}\n          <div>\n            <label htmlFor=\"custom-instructions-optional\" className=\"bcm-instructions-label\">Custom Instructions (optional)</label>\n            <textarea id=\"custom-instructions-optional\" value={customInstructions} onChange={e => setCustomInstructions(e.target.value)} placeholder={'e.g. \"This chronicle is a fable \\u2014 treat its events as in-universe fiction, not canonical history. Backported lore should reference these events as legends, myths, or disputed accounts.\"'} rows={3} className=\"bcm-textarea\" />\n            <p className=\"bcm-instructions-hint\">\n              These instructions will be injected as critical directives into the backport prompt.\n              Use this for non-canonical chronicles (fables, prophecies, dreamscapes) or any special\n              handling.\n            </p>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"bcm-footer\">\n          <button onClick={onCancel} className=\"illuminator-button illuminator-button-secondary bcm-footer-btn\">\n            Cancel\n          </button>\n          <button onClick={() => onStart(Array.from(selectedIds), customInstructions.trim())} disabled={selectedCount === 0} className=\"illuminator-button illuminator-button-primary bcm-footer-btn\">\n            Start Backport ({selectedCount} {selectedCount === 1 ? \"entity\" : \"entities\"})\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}", "type": "{ isOpen: any; chronicleTitle: any; entities: any; perEntityStatus: any; onStart: any; onMarkNotNeeded: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx", "sourceCode": "/**\n * BackrefImageEditor - Main editor component\n *\n * Props:\n * - entity: Entity with enrichment.chronicleBackrefs\n * - entities: All entities (for resolving entity portraits)\n * - onUpdateBackrefs: (entityId, updatedBackrefs) => void\n */\nexport default function BackrefImageEditor({\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}) {\n  const [chronicles, setChronicles] = useState(new Map());\n  const [expanded, setExpanded] = useState(alwaysExpanded);\n  const backrefs = useMemo(\n    () => entity?.enrichment?.chronicleBackrefs || [],\n    [entity?.enrichment?.chronicleBackrefs]\n  );\n\n  // Stable key for chronicle IDs to use as dependency\n  const backrefChronicleKey = useMemo(\n    () => backrefs.map((b) => b.chronicleId).join(\",\"),\n    [backrefs]\n  );\n\n  // Load chronicle records for all backrefs\n  useEffect(() => {\n    if (backrefs.length === 0) return;\n\n    const chronicleIds = [...new Set(backrefs.map((b) => b.chronicleId))];\n    let cancelled = false;\n\n    Promise.all(chronicleIds.map((id) => getChronicle(id).then((c) => [id, c]))).then((results) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const [id, chronicle] of results) {\n        if (chronicle) map.set(id, chronicle);\n      }\n      setChronicles(map);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [backrefs, backrefChronicleKey]);\n\n  // Collect all image IDs we need to load\n  const allImageIds = useMemo(() => {\n    const ids = [];\n    for (const chronicle of chronicles.values()) {\n      // Cover image\n      if (chronicle.coverImage?.generatedImageId) {\n        ids.push(chronicle.coverImage.generatedImageId);\n      }\n      // Scene images\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.generatedImageId) {\n            ids.push(ref.generatedImageId);\n          }\n        }\n      }\n      // Entity portraits from cast\n      for (const role of chronicle.roleAssignments || []) {\n        const ent = entities.find((e) => e.id === role.entityId);\n        if (ent?.enrichment?.image?.imageId) {\n          ids.push(ent.enrichment.image.imageId);\n        }\n      }\n    }\n    return [...new Set(ids)];\n  }, [chronicles, entities]);\n\n  // Only load blobs when the editor is visible (expanded or alwaysExpanded)\n  const { urls: imageUrls } = useImageUrls(expanded ? allImageIds : []);\n\n  const handleBackrefChange = useCallback(\n    (updatedBackref) => {\n      const updated = backrefs.map((b) =>\n        b.chronicleId === updatedBackref.chronicleId &&\n        b.anchorPhrase === updatedBackref.anchorPhrase\n          ? updatedBackref\n          : b\n      );\n      onUpdateBackrefs(entity.id, updated);\n    },\n    [backrefs, entity.id, onUpdateBackrefs]\n  );\n\n  if (backrefs.length === 0) return null;\n\n  const rowsContent = (\n    <div\n      className={alwaysExpanded ? \"bie-rows-container-expanded\" : \"bie-rows-container-collapsed\"}\n    >\n      {backrefs.map((backref, i) => (\n        <BackrefRow\n          key={`${backref.chronicleId}-${i}`}\n          backref={backref}\n          chronicle={chronicles.get(backref.chronicleId) || null}\n          entities={entities}\n          imageUrls={imageUrls}\n          onChange={handleBackrefChange}\n        />\n      ))}\n    </div>\n  );\n\n  if (alwaysExpanded) {\n    return (\n      <div className=\"bie-wrapper\">\n        <div className=\"bie-heading\">Chronicle Images ({backrefs.length})</div>\n        {rowsContent}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bie-wrapper\">\n      <button onClick={() => setExpanded(!expanded)} className=\"bie-toggle-btn\">\n        <span\n          className={`bie-toggle-arrow ${expanded ? \"bie-toggle-arrow-expanded\" : \"bie-toggle-arrow-collapsed\"}`}\n        >\n          \u25b6\n        </span>\n        <span className=\"bie-toggle-label\">Chronicle Images ({backrefs.length})</span>\n      </button>\n      {expanded && rowsContent}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}", "type": "{ entity: any; entities: any; onUpdateBackrefs: any; alwaysExpanded?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkBackportModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkBackportModal.jsx", "sourceCode": "export default function BulkBackportModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const chronicles = progress?.chronicles;\n  const realTotal = useMemo(() => chronicles ? chronicles.reduce((sum, c) => sum + c.totalEntities, 0) : 0, [chronicles]);\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const currentChronicle = progress?.chronicles?.[progress.currentChronicleIndex];\n  const globalPercent = progress?.totalEntities > 0 ? Math.round(progress.processedEntities / progress.totalEntities * 100) : 0;\n  const completedChronicles = progress?.chronicles?.filter(c => c.status === \"complete\").length ?? 0;\n  const failedChronicles = progress?.chronicles?.filter(c => c.status === \"failed\").length ?? 0;\n  let progressFillModifier;\n  if (progress?.status === \"failed\") progressFillModifier = \"bbm-progress-fill-failed\";else if (progress?.status === \"cancelled\") progressFillModifier = \"bbm-progress-fill-cancelled\";else progressFillModifier = \"bbm-progress-fill-ok\";\n  const progressFillClass = `bbm-progress-fill ${progressFillModifier}`;\n\n  // Header status text\n  let statusText;\n  if (isConfirming) statusText = `${progress?.chronicles?.length ?? 0} chronicles`;else if (progress?.status === \"running\") statusText = \"Processing...\";else if (progress?.status === \"complete\") statusText = \"Complete\";else if (progress?.status === \"cancelled\") statusText = \"Cancelled\";else if (progress?.status === \"failed\") statusText = \"Failed\";\n\n  // Pill status text when minimized\n  const pillStatusText = progress?.status === \"running\" ? `${progress.processedEntities}/${progress.totalEntities}` : progress?.status;\n  return <BulkOperationShell pillId={PILL_ID} title=\"Bulk Backport\" tabId=\"chronicle\" progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={`Start Backport (${progress?.totalEntities ?? 0} entities)`} statusText={statusText} pillStatusText={pillStatusText} confirmWidth=\"540px\" processWidth=\"480px\">\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && progress.entitySummary && <div className=\"bbm-entity-section\">\n          <div className=\"bbm-entity-header\">\n            <span className=\"bbm-section-label\">\n              Entities ({progress.entitySummary.length})\n            </span>\n            <span className=\"bbm-section-meta\">\n              {progress.totalEntities} updates across {progress.chronicles.length} chronicles\n            </span>\n          </div>\n\n          <div className=\"bbm-entity-list\">\n            {progress.entitySummary.map((entity, i) => <div key={entity.entityId} className={`bbm-entity-row ${i < progress.entitySummary.length - 1 ? \"bbm-entity-row-bordered\" : \"\"}`}>\n                <div className=\"bbm-entity-info\">\n                  <span className=\"bbm-entity-name\">{entity.entityName}</span>\n                  <span className=\"bbm-entity-kind\">\n                    {entity.entityKind}\n                    {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                  </span>\n                </div>\n                <span className=\"bbm-entity-chr\" title={`${entity.chronicleCount} chronicle${entity.chronicleCount !== 1 ? \"s\" : \"\"} will update this entity`}>\n                  {entity.chronicleCount} chr\n                </span>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* ---- Processing screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <div className=\"bbm-progress-section\">\n            <div className=\"bbm-progress-header\">\n              <span className=\"bbm-progress-label\">\n                Chronicle{\" \"}\n                {Math.min(progress.currentChronicleIndex + 1, progress.chronicles.length)} /{\" \"}\n                {progress.chronicles.length}\n              </span>\n              <span className=\"bbm-progress-percent\">{globalPercent}%</span>\n            </div>\n\n            {/* Global progress bar */}\n            <div className=\"bbm-progress-track\">\n              <div className={progressFillClass}\n          style={{\n            \"--bbm-progress-width\": `${globalPercent}%`\n          }} />\n            </div>\n\n            <div className=\"bbm-progress-stats\">\n              <span>\n                {progress.processedEntities} / {realTotal || progress.totalEntities} entities\n              </span>\n              <span>\n                {completedChronicles} / {progress.chronicles.length} chronicles\n              </span>\n            </div>\n          </div>\n\n          {/* Current chronicle detail */}\n          {currentChronicle && !isTerminal && <div className=\"bbm-chronicle-detail\">\n              <div className=\"bbm-chronicle-title\">{currentChronicle.chronicleTitle}</div>\n\n              {currentChronicle.totalBatches > 1 && <div className=\"bbm-chronicle-batch-info\">\n                  <span>\n                    Batch{\" \"}\n                    {Math.min(currentChronicle.completedBatches + 1, currentChronicle.totalBatches)}{\" \"}\n                    / {currentChronicle.totalBatches}\n                  </span>\n                  <span>\n                    {currentChronicle.processedEntities} / {currentChronicle.totalEntities}{\" \"}\n                    entities\n                  </span>\n                </div>}\n\n              {currentChronicle.totalBatches <= 1 && <div className=\"bbm-chronicle-entity-count\">\n                  {currentChronicle.totalEntities} entities\n                </div>}\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              Backported {progress.processedEntities} entities across {completedChronicles}{\" \"}\n              chronicles.\n              {failedChronicles > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {failedChronicles} chronicle(s) failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} entities across{\" \"}\n              {completedChronicles} chronicles.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx", "sourceCode": "export default function BulkChronicleAnnotationModal({ progress, onConfirm, onCancel, onClose }) {\n  const isClear = progress?.operation === \"clear\";\n  const title = isClear ? \"Clear Annotations\" : \"Run Annotations\";\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  const withNotes = progress?.chronicles?.filter((c) => c.hasNotes).length || 0;\n  const withTones = progress?.chronicles?.filter((c) => c.assignedTone).length || 0;\n\n  const confirmLabel = isClear\n    ? `Clear (${progress?.totalChronicles || 0} chronicles)`\n    : `Annotate (${progress?.totalChronicles || 0} chronicles)`;\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-chronicle-annotation\"\n      title={title}\n      tabId=\"chronicle\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={confirmLabel}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            {isClear ? (\n              <>\n                This will clear all historian annotations from {progress.totalChronicles}{\" \"}\n                chronicle{progress.totalChronicles !== 1 ? \"s\" : \"\"}. Annotations cannot be\n                recovered after clearing.\n              </>\n            ) : (\n              <>\n                Each chronicle gets a historian review using its assigned tone. Results are\n                auto-applied (no manual review step). Chronicles processed sequentially \u2014 one\n                LLM call each.\n                {withTones < progress.totalChronicles && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {progress.totalChronicles - withTones} chronicle\n                    {progress.totalChronicles - withTones !== 1 ? \"s\" : \"\"} have no assigned\n                    tone and will default to &quot;weary&quot;.\n                  </span>\n                )}\n                {withNotes > 0 && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {withNotes} chronicle{withNotes !== 1 ? \"s\" : \"\"} already have annotations \u2014\n                    they will be replaced.\n                  </span>\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Chronicle list */}\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bcam-chronicle-item\">\n                  <span className=\"bcam-chronicle-title\">{chron.title}</span>\n                  {!isClear && (\n                    <span className=\"bcam-chronicle-tone\">\n                      {chron.assignedTone || \"weary\"}\n                      {chron.hasNotes ? \" \u270e\" : \"\"}\n                    </span>\n                  )}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <>\n              <div className=\"bcam-current-title\">\n                {progress.currentTitle || (isClear ? \"Clearing...\" : \"Annotating...\")}\n              </div>\n\n              <BulkProgressBar\n                processed={progress.processedChronicles}\n                total={progress.totalChronicles}\n                status={progress.status}\n              />\n\n              <div className=\"bcam-progress-stats\">\n                <span>\n                  {progress.processedChronicles} / {progress.totalChronicles}{\" \"}\n                  {isClear ? \"cleared\" : \"annotated\"}\n                </span>\n                {!isClear && progress.currentTone && (\n                  <span>tone: {progress.currentTone}</span>\n                )}\n              </div>\n            </>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              {isClear\n                ? `Cleared annotations from ${progress.processedChronicles} chronicle${progress.processedChronicles !== 1 ? \"s\" : \"\"}.`\n                : `Annotated ${progress.processedChronicles} of ${progress.totalChronicles} chronicles.`}\n              {progress.failedChronicles.length > 0 &&\n                ` (${progress.failedChronicles.length} failed)`}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx", "sourceCode": "export default function BulkEraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}) {\n  const progress = useBulkEraNarrativeStore(s => s.progress);\n  const prepareBulk = useBulkEraNarrativeStore(s => s.prepareBulk);\n  const confirmBulk = useBulkEraNarrativeStore(s => s.confirmBulk);\n  const cancelBulk = useBulkEraNarrativeStore(s => s.cancelBulk);\n  const closeBulk = useBulkEraNarrativeStore(s => s.closeBulk);\n  const setEraTone = useBulkEraNarrativeStore(s => s.setEraTone);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Build narrative weight map from style library\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Find the active eraNarrative task in the queue for streaming\n  const activeTaskId = useEnrichmentQueueStore(s => {\n    const item = s.queue.find(q => q.type === \"eraNarrative\" && q.status === \"running\");\n    return item?.id || null;\n  });\n\n  // Subscribe to streaming text for the active task\n  const streamEntry = useThinkingStore(s => activeTaskId ? s.entries.get(activeTaskId) : undefined);\n\n  // Refs for values used in the prepare effect that shouldn't trigger re-run\n  const prepareDepsRef = useRef({\n    chronicleItems,\n    wizardEras,\n    eraTemporalInfo,\n    projectId,\n    simulationRunId,\n    narrativeWeightMap,\n    prepareBulk,\n    progress\n  });\n  useEffect(() => {\n    prepareDepsRef.current = {\n      chronicleItems,\n      wizardEras,\n      eraTemporalInfo,\n      projectId,\n      simulationRunId,\n      narrativeWeightMap,\n      prepareBulk,\n      progress\n    };\n  }, [chronicleItems, wizardEras, eraTemporalInfo, projectId, simulationRunId, narrativeWeightMap, prepareBulk, progress]);\n\n  // Prepare when opening\n  useEffect(() => {\n    const {\n      chronicleItems: ci,\n      wizardEras: we,\n      eraTemporalInfo: eti,\n      projectId: pid,\n      simulationRunId: sid,\n      narrativeWeightMap: nwm,\n      prepareBulk: pb,\n      progress: p\n    } = prepareDepsRef.current;\n    if (isOpen && p.status === \"idle\" && ci?.length > 0 && we?.length > 0) {\n      pb(ci, we, eti, pid, sid, \"witty\", nwm);\n    }\n  }, [isOpen]);\n  const progressStatus = progress?.status;\n  const processedEras = progress?.processedEras;\n  const totalEras = progress?.totalEras;\n\n  // Update pill while minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedEras}/${totalEras}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedEras, totalEras]);\n\n  // Remove pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!isOpen) return null;\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isRunning = progress.status === \"running\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalEras > 0 ? Math.round(progress.processedEras / progress.totalEras * 100) : 0;\n  const handleConfirm = () => {\n    confirmBulk();\n  };\n  const handleCancel = () => {\n    cancelBulk();\n    if (progress.status === \"confirming\") {\n      onClose();\n    }\n  };\n  const handleClose = () => {\n    closeBulk();\n    onClose();\n  };\n  let statusColor;\n  if (progress.status === \"complete\") statusColor = \"#10b981\";else if (progress.status === \"failed\") statusColor = \"#ef4444\";else if (progress.status === \"cancelled\") statusColor = \"#f59e0b\";else statusColor = \"var(--text-muted)\";\n  let progressFillModifier;\n  if (progress.status === \"failed\") progressFillModifier = \"benm-progress-fill-failed\";else if (progress.status === \"cancelled\") progressFillModifier = \"benm-progress-fill-cancelled\";else progressFillModifier = \"benm-progress-fill-complete\";\n  const progressFillClass = `benm-progress-fill ${progressFillModifier}`;\n  return <div className=\"benm-overlay\">\n      <div className=\"benm-modal\"\n    style={{\n      \"--benm-modal-width\": isConfirming ? \"540px\" : \"560px\"\n    }}>\n        {/* Header */}\n        <div className=\"benm-header\">\n          <div className=\"benm-header-row\">\n            <h2 className=\"benm-title\">Bulk Era Narrative</h2>\n            <div className=\"benm-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Bulk Era Narrative\",\n              statusText: progress.status === \"running\" ? `${progress.processedEras}/${progress.totalEras}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })(),\n              tabId: \"chronicle\"\n            })} className=\"illuminator-button benm-minimize-btn\" title=\"Minimize to pill\">\n                  {\"\\u2015\"}\n                </button>}\n              <span className=\"benm-status-label\"\n            style={{\n              \"--benm-status-color\": statusColor\n            }}>\n                {isConfirming && `${progress.totalEras} eras`}\n                {isRunning && \"Processing...\"}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`benm-body ${isConfirming ? \"benm-body-confirming\" : \"benm-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              {/* Era list with per-era tone */}\n              <div className=\"benm-era-section\">\n                <div className=\"benm-section-label\">Eras ({progress.eras.length})</div>\n                <div className=\"benm-era-list\">\n                  {progress.eras.map((era, i) => {\n                return <div key={era.eraId} className={`benm-era-row ${i < progress.eras.length - 1 ? \"benm-era-row-bordered\" : \"\"}`}>\n                        <div className=\"benm-era-row-info\">\n                          <span className=\"benm-era-name\">{era.eraName}</span>\n                        </div>\n                        <div className=\"benm-era-row-actions\">\n                          <span className=\"benm-era-prepped\">\n                            {era.preppedCount}/{era.totalCount} prepped\n                          </span>\n                          {era.hasExisting && <span className=\"benm-era-existing\" title=\"Has existing completed narrative\">\n                              {\"\\u2713\"}\n                            </span>}\n                          {/* Per-era tone selector */}\n                          <div className=\"benm-tone-selector\">\n                            {TONE_OPTIONS.map(t => {\n                        const meta = TONE_META[t];\n                        const selected = era.tone === t;\n                        return <button key={t} onClick={() => setEraTone(era.eraId, t)} title={meta?.label} className={`benm-tone-btn ${selected ? \"benm-tone-btn-selected\" : \"benm-tone-btn-default\"}`}>\n                                  {meta?.symbol}\n                                </button>;\n                      })}\n                          </div>\n                        </div>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing + terminal ---- */}\n          {!isConfirming && <>\n              {/* Progress bar */}\n              <div className=\"benm-progress-section\">\n                <div className=\"benm-progress-header\">\n                  <span className=\"benm-progress-era-label\">\n                    Era {Math.min(progress.processedEras + 1, progress.totalEras)} /{\" \"}\n                    {progress.totalEras}\n                  </span>\n                  <span className=\"benm-progress-percent\">{globalPercent}%</span>\n                </div>\n                <div className=\"benm-progress-track\">\n                  <div className={progressFillClass}\n              style={{\n                \"--benm-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n                <div className=\"benm-progress-counts\">\n                  {progress.processedEras} / {progress.totalEras} eras\n                </div>\n              </div>\n\n              {/* Current era \u2014 step progress with live word counts */}\n              {progress.currentEraName && !isTerminal && (() => {\n            const currentEra = progress.eras.find(e => e.eraName === progress.currentEraName);\n            const currentToneMeta = currentEra ? TONE_META[currentEra.tone] : null;\n            const stepOrder = [\"threads\", \"generate\", \"edit\"];\n            const activeIdx = stepOrder.indexOf(progress.currentStep);\n\n            // Live word counts from streaming deltas\n            const thinkingWords = streamEntry?.thinking ? streamEntry.thinking.split(/\\s+/).filter(Boolean).length : 0;\n            const outputWords = streamEntry?.text ? streamEntry.text.split(/\\s+/).filter(Boolean).length : 0;\n            return <div className=\"benm-current-era\">\n                      {/* Era name + tone */}\n                      <div className=\"benm-current-era-name\">\n                        {currentToneMeta && <span className=\"benm-current-era-tone\" title={currentToneMeta.label}>\n                            {currentToneMeta.symbol}\n                          </span>}\n                        {progress.currentEraName}\n                      </div>\n\n                      {/* Step rows */}\n                      <div className=\"benm-steps\">\n                        {stepOrder.map((step, idx) => {\n                  const isDone = idx < activeIdx;\n                  const isActive = idx === activeIdx;\n                  const isPending = idx > activeIdx;\n                  let icon;\n                  if (isDone) icon = \"\\u2713\";else if (isActive) icon = \"\\u25B8\";else icon = \"\\u25CB\";\n                  let iconColor;\n                  if (isDone) iconColor = \"#10b981\";else if (isActive) iconColor = \"#f59e0b\";else iconColor = \"var(--text-muted)\";\n\n                  // Word count bar caps for visual scaling\n                  let barMax;\n                  if (step === \"generate\") barMax = 4000;else if (step === \"threads\") barMax = 2000;else barMax = 3000;\n                  const barPercent = isActive ? Math.min(100, outputWords / barMax * 100) : 0;\n                  return <div key={step}>\n                              <div className=\"benm-step-row\">\n                                <span className=\"benm-step-icon\"\n                      style={{\n                        \"--benm-step-color\": iconColor\n                      }}>\n                                  {icon}\n                                </span>\n                                <span className={`benm-step-label ${isActive ? \"benm-step-label-active\" : \"\"} ${isPending ? \"benm-step-label-pending\" : \"\"}`}>\n                                  {STEP_LABEL[step]}\n                                </span>\n\n                                {isActive && <div className=\"benm-step-active-content\">\n                                    {/* Mini progress bar */}\n                                    <div className=\"benm-step-bar-track\">\n                                      <div className=\"benm-step-bar-fill\"\n                          style={{\n                            \"--benm-bar-width\": `${barPercent}%`\n                          }} />\n                                    </div>\n                                    {/* Live counters */}\n                                    <span className=\"benm-step-counters\">\n                                      {thinkingWords > 0 && <span title=\"Thinking words received\">\n                                          <span className=\"benm-counter-thinking-label\">T</span>{\" \"}\n                                          {thinkingWords.toLocaleString()}\n                                        </span>}\n                                      {thinkingWords > 0 && outputWords > 0 && <span className=\"benm-counter-separator\">/</span>}\n                                      {outputWords > 0 && <span title=\"Output words received\">\n                                          <span className=\"benm-counter-output-label\">O</span>{\" \"}\n                                          {outputWords.toLocaleString()}\n                                        </span>}\n                                    </span>\n                                  </div>}\n\n                                {isDone && <span className=\"benm-step-done\">done</span>}\n                              </div>\n                            </div>;\n                })}\n                      </div>\n                    </div>;\n          })()}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"benm-terminal-msg benm-terminal-msg-complete\">\n                  Generated {progress.processedEras} era narratives.\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; eraTemporalInfo: any; projectId: any; simulationRunId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx", "sourceCode": "export default function BulkFactCoverageModal({ progress, onConfirm, onCancel, onClose }) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-fact-coverage\"\n      title=\"Fact Coverage Analysis\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Analyze (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            Analyze each chronicle&apos;s narrative against all canon facts using Haiku. Results are\n            stored per-chronicle and visible in the Reference tab.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">Chronicles ({progress.chronicles.length})</div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          <BulkProgressBar\n            processed={progress.processedChronicles}\n            total={progress.totalChronicles}\n            status={progress.status}\n          />\n\n          <div className=\"bulk-progress-detail\">\n            {progress.processedChronicles} / {progress.totalChronicles} chronicles\n            {progress.failedChronicles?.length > 0 && (\n              <span className=\"bulk-failed-inline\">\n                {\" \"}{progress.failedChronicles.length} failed\n              </span>\n            )}\n          </div>\n\n          {/* Current chronicle */}\n          {progress.currentTitle && !isTerminal && (\n            <div className=\"bulk-current-item\">\n              <div className=\"bulk-current-item-title\">{progress.currentTitle}</div>\n              <div className=\"bulk-current-item-sub\">Analyzing fact coverage...</div>\n            </div>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Analyzed {progress.processedChronicles} chronicles.\n              {progress.failedChronicles?.length > 0 && (\n                <span className=\"bulk-failed-inline\">\n                  {\" \"}{progress.failedChronicles.length} failed.\n                </span>\n              )}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx", "sourceCode": "export default function BulkHistorianModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const isReview = progress?.operation === \"review\";\n  const isClear = progress?.operation === \"clear\";\n  const title = progress ? getTitle(progress) : \"\";\n  return <BulkOperationShell pillId=\"bulk-historian\" title={title} progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={progress ? getConfirmLabel(progress) : \"\"} statusText={progress ? getStatusText(progress) : \"\"} pillStatusText={progress ? getPillText(progress) : \"\"}>\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && <>\n          {/* Tone section (not for clear) */}\n          {!isClear && isReview && (/* Review mode: show tone cycling info */\n      <div className=\"bhm-tone-cycle-box\">\n              <span className=\"bhm-tone-cycle-label\">Tones cycle:</span>\n              {TONE_CYCLE_ORDER.map((t, i) => {\n          const meta = TONE_META[t];\n          return <span key={t}>\n                    {i > 0 && <span className=\"bhm-tone-cycle-arrow\">&rarr;</span>}\n                    <span className=\"bhm-tone-cycle-symbol\">{meta?.symbol}</span> {meta?.label}\n                  </span>;\n        })}\n            </div>)}\n          {!isClear && !isReview && (/* Edition mode: tone picker */\n      <div className=\"bhm-tone-picker\">\n              <div className=\"bhm-section-label\">Historian Tone</div>\n              <div className=\"bhm-tone-options\">\n                {TONE_CYCLE_ORDER.map(t => {\n            const meta = TONE_META[t];\n            const isSelected = progress.tone === t;\n            return <button key={t} onClick={() => onChangeTone(t)} className={`bhm-tone-btn ${isSelected ? \"bhm-tone-btn-selected\" : \"bhm-tone-btn-default\"}`}>\n                      <span className=\"bhm-tone-btn-symbol\">{meta?.symbol}</span>\n                      {meta?.label}\n                    </button>;\n          })}\n              </div>\n            </div>)}\n\n          {/* Entity list */}\n          <div className=\"bhm-entity-section\">\n            <div className=\"bhm-entity-section-label\">\n              Entities ({progress.entities.length})\n            </div>\n\n            <div className=\"bhm-entity-list\">\n              {progress.entities.map((entity, i) => <div key={entity.entityId} className={`bhm-entity-row ${i < progress.entities.length - 1 ? \"bhm-entity-row-bordered\" : \"\"}`}>\n                  <div className=\"bhm-entity-row-info\">\n                    {isReview && entity.tone && <span className=\"bhm-entity-tone-symbol\" title={TONE_META[entity.tone]?.label || entity.tone}>\n                        {TONE_META[entity.tone]?.symbol}\n                      </span>}\n                    <span className=\"bhm-entity-name\">{entity.entityName}</span>\n                    <span className=\"bhm-entity-kind\">\n                      {entity.entityKind}\n                      {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                    </span>\n                  </div>\n                  {!isReview && entity.tokenEstimate > 0 && <span className={`bhm-entity-tokens ${editionMaxTokens && entity.tokenEstimate > editionMaxTokens ? \"bhm-entity-tokens-over\" : \"\"}`} title={`~${entity.tokenEstimate} tokens estimated from word count`}>\n                      ~{entity.tokenEstimate.toLocaleString()}t\n                    </span>}\n                </div>)}\n            </div>\n          </div>\n\n          {/* Token estimate summary for edition mode */}\n          {!isReview && !isClear && (() => {\n        const estimates = progress.entities.map(e => e.tokenEstimate || 0).filter(t => t > 0);\n        if (estimates.length === 0) return null;\n        const maxEst = Math.max(...estimates);\n        const overCount = editionMaxTokens ? estimates.filter(t => t > editionMaxTokens).length : 0;\n        return <div className={`bhm-token-summary ${overCount > 0 ? \"bhm-token-summary-over\" : \"bhm-token-summary-ok\"}`}>\n                  <div>\n                    Largest description: <strong>~{maxEst.toLocaleString()} tokens</strong>\n                    {editionMaxTokens > 0 && <span className=\"bhm-token-limit-note\">\n                        (output limit: <strong>{editionMaxTokens.toLocaleString()}</strong>)\n                      </span>}\n                  </div>\n                  {overCount > 0 && <div className=\"bhm-token-over-warning\">\n                      {overCount} {overCount === 1 ? \"entity exceeds\" : \"entities exceed\"} the\n                      current output token limit \u2014 results may be truncated.\n                    </div>}\n                </div>;\n      })()}\n        </>}\n\n      {/* ---- Processing / Terminal screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <BulkProgressBar processed={progress.processedEntities} total={progress.totalEntities} status={progress.status} />\n\n          <div className=\"bhm-progress-counts\">\n            {progress.processedEntities} / {progress.totalEntities} entities\n            {progress.failedEntities.length > 0 && <span className=\"bhm-progress-failed-count\">\n                {progress.failedEntities.length} failed\n              </span>}\n          </div>\n\n          {/* Current entity detail */}\n          {progress.currentEntityName && !isTerminal && <div className=\"bhm-current-entity\">\n              <div className=\"bhm-current-entity-name\">\n                {progress.currentEntityTone && TONE_META[progress.currentEntityTone] && <span className=\"bhm-current-entity-tone\">\n                    {TONE_META[progress.currentEntityTone].symbol}\n                  </span>}\n                {progress.currentEntityName}\n              </div>\n              <div className=\"bhm-current-entity-status\">\n                {(() => {\n            if (isClear) return \"Clearing annotations...\";\n            if (isReview) return \"Generating annotations...\";\n            return \"Generating copy edit...\";\n          })()}\n              </div>\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              {(() => {\n          if (isClear) return `Cleared annotations from ${progress.processedEntities} entities.`;\n          if (isReview) return `Annotated ${progress.processedEntities} entities.`;\n          return `Copy-edited ${progress.processedEntities} entities.`;\n        })()}\n              {progress.failedEntities.length > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {progress.failedEntities.length} failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} of{\" \"}\n              {progress.totalEntities} entities.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Failed entities list */}\n          {isTerminal && <BulkFailedList items={progress.failedEntities} labelKey=\"entityName\" errorKey=\"error\" />}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; onChangeTone: any; editionMaxTokens: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "export default function BulkOperationShell({\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(pillId));\n  const progressStatus = progress?.status;\n\n  // Update pill when minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    useFloatingPillStore.getState().updatePill(pillId, {\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus)\n    });\n  }, [isMinimized, progress, progressStatus, pillId, pillStatusText]);\n\n  // Clean up pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(pillId);\n    }\n  }, [progress, progressStatus, pillId]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const handleMinimize = () => {\n    useFloatingPillStore.getState().minimize({\n      id: pillId,\n      label: title,\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus),\n      tabId\n    });\n  };\n  return <div className=\"bulk-overlay\">\n      <div className=\"bulk-dialog\" style={{\n      \"--bulk-dialog-width\": isConfirming ? confirmWidth : processWidth\n    }}>\n        {/* Header */}\n        <div className=\"bulk-header\">\n          <div className=\"bulk-header-row\">\n            <h2 className=\"bulk-title\">{title}</h2>\n            <div className=\"bulk-header-actions\">\n              {!isConfirming && <button onClick={handleMinimize} className=\"illuminator-button bulk-minimize-btn\" title=\"Minimize to pill\">\n                  \u2015\n                </button>}\n              <span className={`bulk-status bulk-status-${progress.status}`}>\n                {statusText}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`bulk-body ${isConfirming ? \"bulk-body-confirming\" : \"bulk-body-processing\"}`}>\n          {children}\n        </div>\n\n        {/* Footer */}\n        <div className=\"bulk-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary bulk-footer-btn\">\n                {confirmLabel}\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button bulk-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}", "type": "{ pillId: any; title: any; tabId?: string; progress: any; onConfirm: any; onCancel: any; onClose: any; confirmLabel: any; statusText: any; pillStatusText: any; confirmWidth?: string; processWidth?: string; children: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx", "sourceCode": "export default function BulkToneRankingModal({ progress, onConfirm, onCancel, onClose }) {\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-tone-ranking\"\n      title=\"Tone Ranking\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Rank (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {progress?.status === \"confirming\" && (\n        <>\n          <div className=\"bulk-info-box\">\n            Chronicles are split into batches of ~35-45. Each batch gets its own LLM call so the\n            model maintains attention across all entries.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {progress?.status !== \"confirming\" && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <BulkProgressBar\n              processed={progress.processedChronicles}\n              total={progress.totalChronicles}\n              status={progress.status}\n            />\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Ranked {progress.processedChronicles} of {progress.totalChronicles} chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx", "sourceCode": "export default function ChronicleImagePanel({\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}: Readonly<ChronicleImagePanelProps>) {\n  // Use external style selection directly (managed globally by ImageSettingsDrawer)\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Image modal state\n  const [imageModal, setImageModal] = useState<{ open: boolean; imageId: string; title: string }>({\n    open: false,\n    imageId: \"\",\n    title: \"\",\n  });\n  const handleImageClick = useCallback((imageId: string, title: string) => {\n    setImageModal({ open: true, imageId, title });\n  }, []);\n\n  // Image picker state\n  const [pickerRef, setPickerRef] = useState<PromptRequestRef | null>(null);\n  const handleOpenPicker = useCallback((ref: PromptRequestRef) => {\n    setPickerRef(ref);\n  }, []);\n  const handleClosePicker = useCallback(() => {\n    setPickerRef(null);\n  }, []);\n  const handleSelectImage = useCallback(\n    (imageId: string) => {\n      if (pickerRef && onSelectExistingImage) {\n        onSelectExistingImage(pickerRef, imageId);\n      }\n      setPickerRef(null);\n    },\n    [pickerRef, onSelectExistingImage]\n  );\n\n  // Culture selection from global settings\n  const selectedCultureId = imageGenSettings?.selectedCultureId || \"\";\n\n  // Derive primary culture from chronicle entities if not manually selected\n  const derivedCultureId = useMemo(() => {\n    if (selectedCultureId) return selectedCultureId;\n\n    // Try to find dominant culture from entities involved in the chronicle\n    const cultureCounts = new Map<string, number>();\n    for (const entity of entities.values()) {\n      if (entity.culture && entity.culture !== \"universal\") {\n        cultureCounts.set(entity.culture, (cultureCounts.get(entity.culture) || 0) + 1);\n      }\n    }\n\n    let maxCulture = \"\";\n    let maxCount = 0;\n    for (const [culture, count] of cultureCounts) {\n      if (count > maxCount) {\n        maxCulture = culture;\n        maxCount = count;\n      }\n    }\n\n    return maxCulture;\n  }, [selectedCultureId, entities]);\n\n  // Separate entity refs and prompt requests\n  const { entityRefs, promptRequests } = useMemo(() => {\n    if (!imageRefs?.refs) return { entityRefs: [], promptRequests: [] };\n\n    const entityRefs: EntityImageRef[] = [];\n    const promptRequests: PromptRequestRef[] = [];\n\n    for (const ref of imageRefs.refs) {\n      if (ref.type === \"entity_ref\") {\n        entityRefs.push(ref);\n      } else {\n        promptRequests.push(ref);\n      }\n    }\n\n    return { entityRefs, promptRequests };\n  }, [imageRefs]);\n\n  // Count by status\n  const stats = useMemo(() => {\n    const pending = promptRequests.filter((r) => r.status === \"pending\").length;\n    const generating = promptRequests.filter((r) => r.status === \"generating\").length;\n    const complete = promptRequests.filter((r) => r.status === \"complete\").length;\n    const failed = promptRequests.filter((r) => r.status === \"failed\").length;\n\n    return { pending, generating, complete, failed };\n  }, [promptRequests]);\n\n  // Build style info for image generation\n  const buildStyleInfo = useCallback((): StyleInfo => {\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityCultureId: derivedCultureId,\n      entityKind: DEFAULT_VISUAL_IDENTITY_KIND,\n      cultures: cultures || [],\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n\n    // Get visual identity for the selected culture\n    const cultureVisualIdentity = cultureIdentities?.visual?.[derivedCultureId] || {};\n    const allowedKeys =\n      cultureIdentities?.visualKeysByKind?.[DEFAULT_VISUAL_IDENTITY_KIND] ||\n      Object.keys(cultureVisualIdentity); // Use all keys if no kind-specific filtering\n\n    const filteredVisualIdentity: Record<string, string> = {};\n    for (const key of allowedKeys) {\n      if (cultureVisualIdentity[key]) {\n        filteredVisualIdentity[key] = cultureVisualIdentity[key];\n      }\n    }\n\n    return {\n      artisticPromptFragment: (resolved.artisticStyle as { promptFragment?: string } | null)?.promptFragment,\n      compositionPromptFragment: (resolved.compositionStyle as { promptFragment?: string } | null)?.promptFragment,\n      colorPalettePromptFragment: (resolved.colorPalette as { promptFragment?: string } | null)?.promptFragment,\n    };\n  }, [styleSelection, derivedCultureId, cultures, styleLibrary, cultureIdentities]);\n\n  // Handle generating a single image\n  const handleGenerateImage = useCallback(\n    (ref: PromptRequestRef) => {\n      if (!onGenerateImage) return;\n\n      const styleInfo = buildStyleInfo();\n\n      const prompt = buildChronicleScenePrompt(\n        {\n          sceneDescription: ref.sceneDescription,\n          size: ref.size,\n          chronicleTitle,\n          world: worldContext\n            ? {\n                name: worldContext.name || \"Unknown World\",\n                description: worldContext.description,\n                speciesConstraint: worldContext.speciesConstraint,\n              }\n            : undefined,\n        },\n        styleInfo\n      );\n\n      onGenerateImage(ref, prompt, styleInfo);\n    },\n    [onGenerateImage, buildStyleInfo, chronicleTitle, worldContext]\n  );\n\n  // No image refs yet\n  if (!imageRefs) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references generated yet. Use the &quot;Generate&quot; button above to create image\n        placement suggestions.\n      </div>\n    );\n  }\n\n  const totalRefs = entityRefs.length + promptRequests.length;\n\n  if (totalRefs === 0) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references in this chronicle.\n      </div>\n    );\n  }\n\n  const hasSceneImages = promptRequests.length > 0;\n\n  return (\n    <div>\n      {/* Header with stats */}\n      <div className=\"cip-header-row\">\n        <div className=\"cip-header-title\">Image References ({totalRefs})</div>\n        <div className=\"cip-header-stats\">\n          <span className=\"cip-stat-muted\">Entity refs: {entityRefs.length}</span>\n          <span className=\"cip-stat-muted\">Scenes: {promptRequests.length}</span>\n          {stats.pending > 0 && <span className=\"cip-stat-pending\">Pending: {stats.pending}</span>}\n          {stats.complete > 0 && (\n            <span className=\"cip-stat-complete\">Complete: {stats.complete}</span>\n          )}\n        </div>\n      </div>\n\n      {/* Image Settings Summary - show when there are scene images */}\n      {hasSceneImages && imageGenSettings && onOpenImageSettings && (\n        <ImageSettingsSummary\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary || null}\n          onOpenSettings={onOpenImageSettings}\n        />\n      )}\n\n      {/* Entity Refs Section */}\n      {entityRefs.length > 0 && (\n        <div className=\"cip-section\">\n          <div className=\"cip-section-title\">\n            Entity Images ({entityRefs.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {entityRefs.map((ref) => (\n              <EntityImageRefCard\n                key={ref.refId}\n                imageRef={ref}\n                entity={entities.get(ref.entityId)}\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Prompt Requests Section */}\n      {promptRequests.length > 0 && (\n        <div>\n          <div className=\"cip-section-title\">\n            Scene Images ({promptRequests.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {promptRequests.map((ref) => (\n              <PromptRequestCard\n                key={ref.refId}\n                imageRef={ref}\n                onGenerate={() => handleGenerateImage(ref)}\n                onReset={onResetImage ? () => onResetImage(ref) : undefined}\n                onRegenerateDescription={\n                  onRegenerateDescription ? () => onRegenerateDescription(ref) : undefined\n                }\n                onSelectExisting={\n                  onSelectExistingImage && projectId ? () => handleOpenPicker(ref) : undefined\n                }\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n                entities={entities}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Metadata footer */}\n      <div className=\"cip-metadata-footer\">\n        Generated: {new Date(imageRefs.generatedAt).toLocaleString()} \u2022 Model: {imageRefs.model}\n      </div>\n\n      <ImageModal\n        isOpen={imageModal.open}\n        imageId={imageModal.imageId}\n// ... (truncated)", "parameters": [{"name": "{\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}", "type": "Readonly<ChronicleImagePanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx", "sourceCode": "export default function ChronicleImagePicker({\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n\n  // Filter state - both default ON\n  const [filterByRef, setFilterByRef] = useState(true);\n  const [filterByChronicle, setFilterByChronicle] = useState(true);\n\n  const mouseDownOnOverlay = useRef(false);\n\n  // Reset state when opening\n  useEffect(() => {\n    if (isOpen) {\n      setImages([]);\n      setSelectedImageId(null);\n      setFilterByRef(true);\n      setFilterByChronicle(true);\n      setHasMore(false);\n      setTotal(0);\n    }\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen || !projectId) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {\n          projectId,\n          limit: PAGE_SIZE,\n          offset: 0,\n        };\n\n        // Apply filters based on checkbox state\n        // If filterByRef is ON, filter by imageRefId (most specific)\n        // If filterByRef is OFF but filterByChronicle is ON, filter by chronicleId\n        // If both OFF, show all chronicle images for project\n        if (filterByRef && imageRefId) {\n          filters.imageRefId = imageRefId;\n          // When filtering by ref, also filter by chronicle for efficiency\n          if (chronicleId) filters.chronicleId = chronicleId;\n        } else if (filterByChronicle && chronicleId) {\n          filters.chronicleId = chronicleId;\n        }\n\n        const result = await searchChronicleImages(filters);\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n      } catch (err) {\n        console.error(\"Failed to load chronicle images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, projectId, chronicleId, imageRefId, filterByRef, filterByChronicle]);\n\n  // Load more handler\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const filters = {\n        projectId,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      };\n\n      if (filterByRef && imageRefId) {\n        filters.imageRefId = imageRefId;\n        if (chronicleId) filters.chronicleId = chronicleId;\n      } else if (filterByChronicle && chronicleId) {\n        filters.chronicleId = chronicleId;\n      }\n\n      const result = await searchChronicleImages(filters);\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [\n    loading,\n    hasMore,\n    projectId,\n    chronicleId,\n    imageRefId,\n    filterByRef,\n    filterByChronicle,\n    images.length,\n  ]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    onClose();\n  }, [onClose]);\n\n  // Overlay click handling\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n\n  // Close on escape\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") handleClose();\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal cip-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Existing Image</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body cip-body\">\n          {/* Filters */}\n          <div className=\"cip-filters\">\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByRef}\n                onChange={(e) => setFilterByRef(e.target.checked)}\n              />\n              This ref only\n            </label>\n\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByChronicle}\n                onChange={(e) => setFilterByChronicle(e.target.checked)}\n              />\n              This chronicle only\n            </label>\n\n            <span className=\"cip-filter-count\">\n              {total} image{total !== 1 ? \"s\" : \"\"}\n            </span>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"cip-grid-area\">\n            {loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">\n                No images found. Try unchecking filters to see more.\n              </div>\n            )}\n            {images.length > 0 && (\n              <>\n                <div className=\"cip-grid\">\n                  {images.map((img) => {\n                    const isSelected = selectedImageId === img.imageId;\n                    const isCurrent = currentImageId === img.imageId;\n\n                    return (\n                      <div\n                        key={img.imageId}\n                        onClick={() => setSelectedImageId(img.imageId)}\n                        className={(() => {\n                          if (isSelected) return \"cip-image-card cip-image-card-selected\";\n                          if (isCurrent) return \"cip-image-card cip-image-card-current\";\n                          return \"cip-image-card\";\n                        })()}\n                        role=\"button\"\n                        tabIndex={0}\n                        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                      >\n                        <LazyThumbnail\n                          imageId={img.imageId}\n                          alt={img.sceneDescription || \"Chronicle image\"}\n                          className=\"cip-thumb-container\"\n                        />\n\n                        {/* Current indicator */}\n                        {isCurrent && <div className=\"cip-current-badge\">Current</div>}\n\n                        {/* Date overlay */}\n                        <div className=\"cip-date-overlay\">{formatDate(img.generatedAt)}</div>\n                      </div>\n                    );\n                  })}\n                </div>\n\n                {/* Load more button */}\n                {hasMore && (\n                  <div className=\"cip-load-more-wrapper\">\n                    <button\n                      onClick={() => void handleLoadMore()}\n                      disabled={loading}\n                      className=\"cip-load-more-btn\"\n                    >\n                      {loading ? \"Loading...\" : `Load More (${total - images.length} remaining)`}\n                    </button>\n                  </div>\n                )}\n              </>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer cip-footer\">\n          <button onClick={handleClose} className=\"cip-cancel-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId}\n            className={`cip-select-btn ${selectedImageId ? \"cip-select-btn-active\" : \"cip-select-btn-disabled\"}`}\n          >\n            Select Image\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; projectId: any; chronicleId: any; imageRefId: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChroniclePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePanel.jsx", "sourceCode": "export default function ChroniclePanel({\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}) {\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  // Full entities from Dexie for generation context (tags, description, coordinates, etc.)\n  const [fullEntities, setFullEntities] = useState([]);\n  const fullEntityMapRef = useRef(new Map());\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const [selectedItemId, setSelectedItemId] = useState(() => {\n    const saved = localStorage.getItem(\"illuminator:chronicle:selectedItemId\");\n    return saved || null;\n  });\n  const [groupByType, setGroupByType] = useState(false);\n  const [sortMode, setSortMode] = useState(\"era_asc\");\n  const [statusFilter, setStatusFilter] = useState(\"all\");\n  const [focusFilter, setFocusFilter] = useState(\"all\");\n  const [entitySearchQuery, setEntitySearchQuery] = useState(\"\");\n  const [entitySearchSelectedId, setEntitySearchSelectedId] = useState(null);\n  const [showEntitySuggestions, setShowEntitySuggestions] = useState(false);\n  const [navVisibleCount, setNavVisibleCount] = useState(NAV_PAGE_SIZE);\n  const navListRef = useRef(null);\n  const navLoadMoreRef = useRef(null);\n  // Load full entities from Dexie for generation operations (tags, description, coordinates, etc.)\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    getEntitiesForRun(simulationRunId).then(ents => {\n      if (cancelled) return;\n      setFullEntities(ents);\n      fullEntityMapRef.current = new Map(ents.map(e => [e.id, e]));\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const chronicleWorldData = useMemo(() => ({\n    entities: fullEntities,\n    relationships: relationships || [],\n    narrativeHistory: narrativeEvents || []\n  }), [fullEntities, relationships, narrativeEvents]);\n  useEffect(() => {\n    if (selectedItemId) {\n      localStorage.setItem(\"illuminator:chronicle:selectedItemId\", selectedItemId);\n    } else {\n      localStorage.removeItem(\"illuminator:chronicle:selectedItemId\");\n    }\n  }, [selectedItemId]);\n\n  // State for restart confirmation modal\n  const [showRestartModal, setShowRestartModal] = useState(false);\n  const [pendingRestartChronicleId, setPendingRestartChronicleId] = useState(null);\n\n  // State for reset backport flags modal\n  const [showResetBackportModal, setShowResetBackportModal] = useState(false);\n  const [resetBackportResult, setResetBackportResult] = useState(null);\n\n  // State for reconcile backport status\n  const [reconcileBackportResult, setReconcileBackportResult] = useState(null);\n\n  // State for era summary refresh\n  const [eraSummaryRefreshResult, setEraSummaryRefreshResult] = useState(null);\n\n  // State for bulk temporal check\n  const [temporalCheckResult, setTemporalCheckResult] = useState(null);\n\n  // State for bulk tertiary re-detect\n  const [tertiaryDetectResult, setTertiaryDetectResult] = useState(null);\n\n  // State for bulk summary generation\n  const [bulkSummaryResult, setBulkSummaryResult] = useState(null);\n\n  // Collapsible bulk actions panel\n  const [showBulkActions, setShowBulkActions] = useState(false);\n\n  // State for chronology modal\n  const [showChronologyModal, setShowChronologyModal] = useState(false);\n\n  // Era narrative modal \u2014 state lives in Zustand store to survive tab switches\n  const eraNarrativeModal = useIlluminatorModals(s => s.eraNarrativeModal);\n\n  // Bulk historian prep: skip chronicles that already have prep\n  const [skipCompletedPrep, setSkipCompletedPrep] = useState(true);\n\n  // Bulk era narrative modal\n  const [showBulkEraNarrative, setShowBulkEraNarrative] = useState(false);\n  const bulkEraNarrativeProgress = useBulkEraNarrativeStore(s => s.progress);\n\n  // Era narrative nav items (loaded from IndexedDB, merged into chronicle list)\n  const [eraNarrativeNavItems, setEraNarrativeNavItems] = useState([]);\n\n  // Fact coverage bulk analysis\n  const {\n    progress: factCoverageProgress,\n    isActive: isFactCoverageActive,\n    prepareFactCoverage,\n    confirmFactCoverage,\n    cancelFactCoverage,\n    closeFactCoverage\n  } = useFactCoverage();\n\n  // Tone ranking & assignment\n  const {\n    progress: toneRankingProgress,\n    isActive: isToneRankingActive,\n    prepareToneRanking,\n    prepareAssignment\n  } = useToneRanking();\n\n  // Bulk chronicle annotations (clear / run)\n  const bulkAnnotationProgress = useBulkChronicleAnnotationStore(s => s.progress);\n  const prepareBulkAnnotation = useBulkChronicleAnnotationStore(s => s.prepareAnnotation);\n  const isBulkAnnotationActive = bulkAnnotationProgress.status === \"running\" || bulkAnnotationProgress.status === \"confirming\";\n\n  // Interleaved annotation (chronicle + entity)\n  const prepareInterleaved = useInterleavedAnnotationStore(s => s.prepareInterleaved);\n  const interleavedProgress = useInterleavedAnnotationStore(s => s.progress);\n  const isInterleavedActive = interleavedProgress.status === \"running\" || interleavedProgress.status === \"confirming\";\n  const entityNavItems = useEntityStore(s => s.navItems);\n\n  // State for wizard modal\n  const [showWizard, setShowWizard] = useState(false);\n  // Seed for restarting with previous settings\n  const [wizardSeed, setWizardSeed] = useState(null);\n\n  // Derive style/size/quality from global imageGenSettings\n  const chronicleImageSize = imageGenSettings.imageSize;\n  const chronicleImageQuality = imageGenSettings.imageQuality;\n  const chronicleStyleSelection = useMemo(() => ({\n    artisticStyleId: imageGenSettings.artisticStyleId,\n    compositionStyleId: imageGenSettings.compositionStyleId,\n    colorPaletteId: imageGenSettings.colorPaletteId\n  }), [imageGenSettings.artisticStyleId, imageGenSettings.compositionStyleId, imageGenSettings.colorPaletteId]);\n\n  // Name bank for invented characters (culture ID -> array of names)\n  const [nameBank, setNameBank] = useState({});\n\n  // Style library loading state (derived from prop)\n  const stylesLoading = !styleLibrary;\n\n  // Initialize chronicle store when simulation changes\n  useEffect(() => {\n    if (simulationRunId) {\n      useChronicleStore.getState().initialize(simulationRunId);\n    }\n  }, [simulationRunId]);\n\n  // Enqueue-dependent actions (generate, compare, combine)\n  const {\n    generateV2,\n    generateSummary,\n    generateTitle,\n    regenerateWithSampling,\n    regenerateFull,\n    regenerateCreative,\n    compareVersions,\n    combineVersions,\n    copyEdit,\n    temporalCheck,\n    quickCheck\n  } = useChronicleActions();\n\n  // Lifecycle actions from store (no queue dependency)\n  const acceptChronicle = useChronicleStore(s => s.acceptChronicle);\n  const cancelChronicle = useChronicleStore(s => s.cancelChronicle);\n  const restartChronicle = useChronicleStore(s => s.restartChronicle);\n\n  // Scope the \"generating\" lock to the selected chronicle so other chronicles remain interactive.\n  const isGenerating = Boolean(selectedItemId) && queue.some(item => item.type === \"entityChronicle\" && item.chronicleId === selectedItemId && (item.status === \"queued\" || item.status === \"running\"));\n\n  // Refresh helpers\n  const refresh = useCallback(() => useChronicleStore.getState().refreshAll(), []);\n  const refreshChronicle = useCallback(id => useChronicleStore.getState().refreshChronicle(id), []);\n\n  // Assign tone to a chronicle without triggering annotation\n  const handleSetAssignedTone = useCallback(async (chronicleId, tone) => {\n    await updateChronicleAssignedTone(chronicleId, tone);\n    refreshChronicle(chronicleId);\n  }, [refreshChronicle]);\n\n  // Detect tone for a single chronicle via LLM\n  const handleDetectTone = useCallback(async (chronicleId, title) => {\n    const record = await getChronicle(chronicleId);\n    if (!record?.summary) return;\n    const payload = {\n      chronicleId,\n      summary: record.summary,\n      format: record.format || \"story\",\n      narrativeStyleName: record.narrativeStyle?.name,\n      brief: record.perspectiveSynthesis?.brief\n    };\n    const entity = {\n      id: chronicleId,\n      name: title || \"Chronicle\",\n      kind: \"chronicle\",\n      subtype: \"\",\n      prominence: \"recognized\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {}\n    };\n    onEnqueue([{\n      entity,\n      type: \"toneRanking\",\n      prompt: JSON.stringify(payload),\n      chronicleId\n    }]);\n  }, [onEnqueue]);\n\n  // External refresh trigger (e.g. after lore backport)\n  useEffect(() => {\n    if (refreshTrigger > 0) refresh();\n  }, [refreshTrigger, refresh]);\n  const entitySuggestions = useMemo(() => {\n    const query = entitySearchQuery.trim().toLowerCase();\n    if (!query || !navEntities?.length) return [];\n    return navEntities.filter(entity => entity.name?.toLowerCase().includes(query)).slice(0, 8);\n  }, [navEntities, entitySearchQuery]);\n  const narrativeStyleNameMap = useMemo(() => {\n    const map = new Map();\n    const styles = styleLibrary?.narrativeStyles || [];\n    for (const style of styles) {\n      if (style?.id) {\n        map.set(style.id, style.name || style.id);\n      }\n    }\n    return map;\n  }, [styleLibrary?.narrativeStyles]);\n\n  // Helper to get status considering both IndexedDB and queue state\n  const getEffectiveStatus = useCallback((chronicleId, baseStatus) => {\n    // First check queue for running/queued tasks for this chronicle\n    const queueTask = queue.find(item => item.type === \"entityChronicle\" && item.chronicleId === chronicleId && !REFINEMENT_STEPS.has(item.chronicleStep || \"\"));\n    if (queueTask) {\n      if (queueTask.status === \"running\") {\n        // Map chronicleStep to status\n        switch (queueTask.chronicleStep) {\n          case \"validate\":\n            return \"validating\";\n          case \"edit\":\n            return \"editing\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n      if (queueTask.status === \"queued\") {\n        switch (queueTask.chronicleStep) {\n          case \"edit\":\n            return \"editing\";\n          case \"validate\":\n            return \"validating\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n    }\n\n    // Fall back to IndexedDB-derived status\n    return baseStatus;\n  }, [queue]);\n\n  // Lightweight nav items from Zustand store (shallow-compared, only re-renders on nav-relevant changes)\n  const chronicleItems = useChronicleNavItems(getEffectiveStatus);\n  const getChronicleTypeLabel = useCallback(item => {\n    if (item?.itemType === \"era_narrative\") return \"Era Narrative\";\n    if (item?.narrativeStyleName) return item.narrativeStyleName;\n// ... (truncated)", "parameters": [{"name": "{\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}", "type": "{ worldData: any; queue: any; onEnqueue: any; onCancel: any; worldContext: any; projectId: any; simulationRunId: any; buildPrompt: any; styleLibrary: any; imageGenSettings: any; entityGuidance: any; cultureIdentities: any; onBackportLore: any; onStartBulkBackport: any; isBulkBackportActive: any; refreshTrigger: any; imageModel: any; onOpenImageSettings: any; onHistorianReview: any; isHistorianActive: any; historianConfigured: any; historianConfig: any; onUpdateHistorianNote: any; onRefreshEra...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx", "sourceCode": "export default function ChroniclePlanEditor({\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}) {\n  const sectionCount = plan.sections?.length || 0;\n\n  const eventStats = useMemo(() => {\n    const eventIds = new Set();\n    plan.sections?.forEach((section) => {\n      section.eventIds?.forEach((id) => eventIds.add(id));\n    });\n    return eventIds.size;\n  }, [plan.sections]);\n\n  return (\n    <div className=\"cpe-root\">\n      <PlanHeader plan={plan} />\n      <OutlineSummary plan={plan} />\n      <FocusSummary plan={plan} entityMap={entityMap} />\n      <PlotSummary plan={plan} />\n      <EntityRoleList plan={plan} entityMap={entityMap} />\n\n      <div className=\"cpe-stats-row\">\n        <div className=\"cpe-stat-box\">\n          <strong>Sections:</strong> {sectionCount}\n        </div>\n        <div className=\"cpe-stat-box\">\n          <strong>Referenced Events:</strong> {eventStats}\n        </div>\n      </div>\n\n      <SectionsList plan={plan} entityMap={entityMap} eventMap={eventMap} />\n\n      <div className=\"cpe-action-bar\">\n        <button\n          onClick={onRegenerate}\n          disabled={isGenerating}\n          className={`illuminator-button cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Regenerate Plan\n        </button>\n        <button\n          onClick={onApprove}\n          disabled={isGenerating}\n          className={`illuminator-button illuminator-button-primary cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Approve Plan\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}", "type": "{ plan: any; entityMap: any; eventMap: any; onRegenerate: any; onApprove: any; isGenerating?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function ChronicleReviewPanel({\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  if (!item) return null;\n\n  // ---------------------------------------------------------------------------\n  // Assembly Ready & Complete \u2192 Tabbed Workspace\n  // ---------------------------------------------------------------------------\n  if (\n    (item.status === \"assembly_ready\" && item.assembledContent) ||\n    (item.status === \"complete\" && item.finalContent)\n  ) {\n    return (\n      <ChronicleWorkspace\n        item={item}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onRegenerateFull={onRegenerateFull}\n        onRegenerateCreative={onRegenerateCreative}\n        onCompareVersions={onCompareVersions}\n        onCombineVersions={onCombineVersions}\n        onCopyEdit={onCopyEdit}\n        onTemporalCheck={onTemporalCheck}\n        onQuickCheck={onQuickCheck}\n        onValidate={onValidate}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateTitle={onGenerateTitle}\n        onAcceptPendingTitle={onAcceptPendingTitle}\n        onRejectPendingTitle={onRejectPendingTitle}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onRegenerateDescription={onRegenerateDescription}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleTemporalContext={onUpdateChronicleTemporalContext}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        onUpdateCombineInstructions={onUpdateCombineInstructions}\n        onUnpublish={onUnpublish}\n        onGenerateCoverImageScene={onGenerateCoverImageScene}\n        onGenerateCoverImage={onGenerateCoverImage}\n        styleSelection={styleSelection}\n        imageSize={imageSize}\n        imageQuality={imageQuality}\n        imageModel={imageModel}\n        imageGenSettings={imageGenSettings}\n        onOpenImageSettings={onOpenImageSettings}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onApplyImageRefSelections={onApplyImageRefSelections}\n        onSelectExistingImage={onSelectExistingImage}\n        onSelectExistingCoverImage={onSelectExistingCoverImage}\n        onExport={onExport}\n        onBackportLore={onBackportLore}\n        onHistorianReview={onHistorianReview}\n        onSetAssignedTone={onSetAssignedTone}\n        onDetectTone={onDetectTone}\n        isHistorianActive={isHistorianActive}\n        onUpdateHistorianNote={onUpdateHistorianNote}\n        onGeneratePrep={onGeneratePrep}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        simulationRunId={simulationRunId}\n        worldSchema={worldSchema}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n        eras={eras}\n        events={events}\n        onNavigateToTab={onNavigateToTab}\n      />\n    );\n  }\n\n  // ---------------------------------------------------------------------------\n  // Validation Ready \u2192 Inline layout (not tabbed)\n  // ---------------------------------------------------------------------------\n  if (item.status === \"validation_ready\") {\n    return (\n      <ValidationReadyView\n        item={item}\n        onExport={onExport}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onCorrectSuggestions={onCorrectSuggestions}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onRevalidate={onRevalidate}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n      />\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onContinueToValidation: any; onValidate: any; onAddImages: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onRevalidate: any; onGenerateChronicleImage: a...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronologyModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronologyModal.jsx", "sourceCode": "export default function ChronologyModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [expandedReasoning, setExpandedReasoning] = useState({});\n\n  const { run, isActive, startChronology, adjustYear, applyChronology, cancelChronology } =\n    useHistorianChronology(onEnqueue);\n\n  // Build era options from wizardEras\n  const eraOptions = useMemo(() => {\n    return wizardEras.map((era) => {\n      const eraChronicles = chronicleItems.filter((c) => c.focalEraName === era.name);\n      return {\n        id: era.id,\n        name: era.name,\n        startTick: era.startTick,\n        endTick: era.endTick,\n        count: eraChronicles.length,\n        preppedCount: eraChronicles.filter((c) => c.hasHistorianPrep).length,\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n\n  // Get chronicles for the selected era\n  const selectedEra = eraOptions.find((e) => e.id === selectedEraId);\n\n  // Chronicles in the selected era for the list display\n  const selectedEraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems\n      .filter((c) => c.focalEraName === era.name)\n      .sort((a, b) => (a.eraYear || 0) - (b.eraYear || 0) || a.name.localeCompare(b.name));\n  }, [selectedEra, selectedEraId, wizardEras, chronicleItems]);\n\n  // Build context and start\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return;\n\n    // Get chronicles in this era\n    const eraChronicles = chronicleItems.filter((item) => item.focalEraName === era.name);\n\n    // Load full records for summaries\n    const store = useChronicleStore.getState();\n    const chronicleEntries = [];\n\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record) continue;\n\n      // Resolve event headlines for this chronicle\n      const chronicleEventIds = new Set(record.selectedEventIds || []);\n      const events = (wizardEvents || [])\n        .filter((e) => chronicleEventIds.has(e.id))\n        .map((e) => ({ tick: e.tick, headline: e.headline }));\n\n      // Cast from role assignments\n      const cast = (record.roleAssignments || []).map((r) => ({\n        entityName: r.entityName,\n        role: r.roleName || (r.isPrimary ? \"primary\" : \"supporting\"),\n        kind: r.entityKind || \"\",\n      }));\n\n      // Prefer historian prep, then summary, then opening text\n      const content = record.finalContent || record.assembledContent || \"\";\n      const openingText = content.slice(0, 300).split(/\\n\\n/).slice(0, 2).join(\"\\n\\n\");\n\n      chronicleEntries.push({\n        chronicleId: record.chronicleId,\n        title: record.title || item.name,\n        tickRange: record.temporalContext?.chronicleTickRange || [0, 0],\n        temporalScope: record.temporalContext?.temporalScope || \"unknown\",\n        isMultiEra: record.temporalContext?.isMultiEra || false,\n        cast,\n        events,\n        prep: record.historianPrep || undefined,\n        summary: record.historianPrep ? undefined : record.summary,\n        openingText: record.historianPrep || record.summary ? undefined : openingText,\n      });\n    }\n\n    // Previous eras for context\n    const previousEras = wizardEras\n      .filter((e) => e.order < era.order)\n      .sort((a, b) => a.order - b.order)\n      .map((e) => ({\n        name: e.name,\n        startTick: e.startTick,\n        endTick: e.endTick,\n        summary: e.summary,\n      }));\n\n    const contextJson = JSON.stringify({\n      era: {\n        eraId: era.id,\n        eraName: era.name,\n        eraSummary: era.summary,\n        startTick: era.startTick,\n        endTick: era.endTick,\n      },\n      previousEras,\n      chronicles: chronicleEntries,\n    });\n\n    startChronology({\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      contextJson,\n      historianConfig,\n      tone: \"scholarly\",\n    });\n  }, [\n    selectedEra,\n    selectedEraId,\n    wizardEras,\n    chronicleItems,\n    wizardEvents,\n    projectId,\n    simulationRunId,\n    historianConfig,\n    startChronology,\n  ]);\n\n  // Apply assignments to chronicle records\n  const handleApply = useCallback(async () => {\n    const assignments = applyChronology();\n    if (assignments.length === 0) return;\n\n    await batchUpdateChronicleEraYears(\n      assignments.map((a) => ({\n        chronicleId: a.chronicleId,\n        eraYear: a.year,\n        eraYearReasoning: a.reasoning,\n      }))\n    );\n\n    onApplied();\n  }, [applyChronology, onApplied]);\n\n  // Cancel\n  const handleCancel = useCallback(() => {\n    cancelChronology();\n  }, [cancelChronology]);\n\n  // Close modal (cancel if active)\n  const handleClose = useCallback(() => {\n    if (isActive) cancelChronology();\n    onClose();\n  }, [isActive, cancelChronology, onClose]);\n\n  if (!isOpen) return null;\n\n  const isGenerating = run?.status === \"pending\" || run?.status === \"generating\";\n  const isReviewing = run?.status === \"reviewing\";\n  const isFailed = run?.status === \"failed\";\n  const assignments = run?.chronologyAssignments || [];\n  const sortedAssignments = [...assignments].sort((a, b) => a.year - b.year);\n\n  // Find chronicle title by ID\n  const titleMap = {};\n  for (const item of chronicleItems) {\n    titleMap[item.chronicleId] = item.name;\n  }\n\n  const canStart = selectedEraId && selectedEra?.count > 0;\n\n  return (\n    <div\n      className=\"chm-overlay\"\n      onClick={(e) => {\n        if (e.target === e.currentTarget) handleClose();\n      }}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      <div className=\"chm-dialog\">\n        {/* Header */}\n        <div className=\"chm-header\">\n          <span className=\"chm-header-title\">\n            {isReviewing ? `Chronology: ${run?.targetName}` : \"Historian Chronology\"}\n          </span>\n          <button onClick={handleClose} className=\"chm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Body */}\n        <div className=\"chm-body\">\n          {/* Setup state */}\n          {!isActive && !isReviewing && !isFailed && (\n            <>\n              <div className=\"chm-field\">\n                <label htmlFor=\"era\" className=\"chm-field-label\">Era</label>\n                <select id=\"era\"\n                  className=\"illuminator-select chm-era-select\"\n                  value={selectedEraId}\n                  onChange={(e) => setSelectedEraId(e.target.value)}\n                >\n                  <option value=\"\">Select an era...</option>\n                  {eraOptions.map((era) => (\n                    <option key={era.id} value={era.id}>\n                      {era.name} ({era.count} chronicles, Y{era.startTick}\n                      {\"\\u2013\"}Y{era.endTick})\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Chronicle list for selected era */}\n              {selectedEra && selectedEraChronicles.length > 0 && (\n                <div className=\"chm-field\">\n                  <div className=\"chm-list-header\">\n                    <span>Chronicles ({selectedEraChronicles.length})</span>\n                    <span className=\"chm-list-header-right\">\n                      {selectedEra.preppedCount}/{selectedEraChronicles.length} prepped\n                    </span>\n                  </div>\n                  <div className=\"chm-chronicle-list\">\n                    {selectedEraChronicles.map((c, i) => (\n                      <div\n                        key={c.chronicleId}\n                        className={`chm-chronicle-row ${i < selectedEraChronicles.length - 1 ? \"chm-chronicle-row-bordered\" : \"\"}`}\n                      >\n                        <span\n                          className={`chm-prep-icon ${c.hasHistorianPrep ? \"chm-prep-icon-ready\" : \"chm-prep-icon-none\"}`}\n                          title={\n                            c.hasHistorianPrep ? \"Historian prep available\" : \"No historian prep\"\n                          }\n                        >\n                          {c.hasHistorianPrep ? \"\\u25C6\" : \"\\u25C7\"}\n                        </span>\n                        <span className=\"chm-chronicle-name\">{c.name}</span>\n                        {c.eraYear != null && <span className=\"chm-era-year\">Y{c.eraYear}</span>}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n\n              <button\n                onClick={() => void handleStart()}\n                disabled={!canStart}\n                className={`illuminator-button chm-start-btn ${canStart ? \"chm-start-btn-active\" : \"chm-start-btn-disabled\"}`}\n              >\n                Assign Years\n              </button>\n            </>\n          )}\n\n          {/* Generating state */}\n          {isGenerating && (\n            <div className=\"chm-generating\">\n              <div className=\"chm-generating-msg\">The historian is ordering chronicles...</div>\n              <div className=\"chm-generating-target\">{run?.targetName}</div>\n            </div>\n          )}\n\n          {/* Failed state */}\n          {isFailed && (\n            <div className=\"chm-failed\">\n              <div className=\"chm-failed-msg\">Chronology failed</div>\n              <div className=\"chm-failed-error\">{run?.error}</div>\n              <button onClick={handleCancel} className=\"illuminator-button\">\n                Dismiss\n              </button>\n            </div>\n          )}\n\n          {/* Review state */}\n          {isReviewing && sortedAssignments.length > 0 && (\n            <>\n              <div className=\"chm-review-hint\">\n                {sortedAssignments.length} chronicles ordered. Adjust years if needed, then apply.\n              </div>\n\n              <div className=\"chm-assignments\">\n                {sortedAssignments.map((a) => (\n                  <div key={a.chronicleId} className=\"chm-assignment-card\">\n                    <div className=\"chm-assignment-row\">\n                      <input\n                        type=\"number\"\n                        value={a.year}\n                        min={selectedEra?.startTick}\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; wizardEvents: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; onApplied: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx", "sourceCode": "export default function CohesionReportViewer({\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}) {\n  const [activeTab, setActiveTab] = useState(\"summary\");\n\n  // Calculate assessment\n  const assessment = useMemo(() => {\n    if (!report) return null;\n    const criticalIssues = report.issues.filter(i => i.severity === \"critical\");\n    const minorIssues = report.issues.filter(i => i.severity === \"minor\");\n    const failedChecks = [];\n    if (!report.checks.plotStructure.pass) failedChecks.push(\"Structure\");\n    if (!report.checks.entityConsistency.pass) failedChecks.push(\"Entity Consistency\");\n    if (!report.checks.resolution.pass) failedChecks.push(\"Resolution\");\n    if (!report.checks.factualAccuracy.pass) failedChecks.push(\"Factual Accuracy\");\n    if (!report.checks.themeExpression.pass) failedChecks.push(\"Theme Expression\");\n    const failedSectionGoals = report.checks.sectionGoals.filter(sg => !sg.pass);\n    let status;\n    if (report.overallScore >= 90) status = \"excellent\";else if (report.overallScore >= 75) status = \"good\";else if (report.overallScore >= 60) status = \"acceptable\";else status = \"needs_revision\";\n    return {\n      status,\n      criticalIssueCount: criticalIssues.length,\n      minorIssueCount: minorIssues.length,\n      failedChecks,\n      failedSectionGoals\n    };\n  }, [report]);\n  if (!report) {\n    return <div className=\"crv-empty\">No validation report available.</div>;\n  }\n  const statusStyle = STATUS_STYLES[assessment?.status || \"needs_revision\"];\n  const resolveSectionLabel = sectionId => sectionId;\n  const hasIssues = report.issues.length > 0;\n  const formatTimestamp = timestamp => new Date(timestamp).toLocaleString();\n  const summaryState = refinements?.summary || {};\n  const imageRefsState = refinements?.imageRefs || {};\n  const disabledClass = condition => condition ? \"crv-btn-disabled\" : \"\";\n  return <div className=\"crv\">\n      {/* Header with score and actions */}\n      <div className=\"crv-header\">\n        <div className=\"crv-header-left\">\n          <ScoreGauge score={report.overallScore} />\n          <div>\n            {}\n            <div className={`crv-status-badge crv-status-badge-${assessment?.status || \"needs_revision\"}`}>\n              {statusStyle.label}\n            </div>\n            <div className=\"crv-issue-count\">\n              {assessment?.criticalIssueCount || 0} critical issues \u2022{\" \"}\n              {assessment?.minorIssueCount || 0} minor issues\n            </div>\n            <div className=\"crv-edit-version\">Edit version: {editVersion}</div>\n            {assessment?.failedChecks.length > 0 && <div className=\"crv-failed-checks\">Failed: {assessment.failedChecks.join(\", \")}</div>}\n          </div>\n        </div>\n\n        <div className=\"crv-actions\">\n          {onCorrectSuggestions && <button onClick={onCorrectSuggestions} disabled={isGenerating || !hasIssues} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating || !hasIssues)}`} title={!hasIssues ? \"No issues to correct\" : \"Apply remediation suggestions\"}>\n              \u270e Correct Suggestions\n            </button>}\n          <button onClick={onRegenerate} disabled={isGenerating} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating)}`}>\n            \u27f3 Regenerate All\n          </button>\n          <button onClick={onAccept} disabled={isGenerating} className={`crv-btn crv-btn-primary ${report.overallScore >= 60 ? \"crv-btn-accept-ready\" : \"crv-btn-accept-warning\"} ${disabledClass(isGenerating)}`}>\n            {report.overallScore >= 60 ? \"Accept Chronicle \u2713\" : \"Accept with Issues \u26a0\"}\n          </button>\n        </div>\n      </div>\n\n      {isValidationStale && <div className=\"crv-stale-warning\">\n          <div className=\"crv-stale-text\">\n            Validation is stale after edits. Revalidate to refresh the report.\n          </div>\n          {onRevalidate && <button onClick={onRevalidate} disabled={isGenerating} className={`crv-btn crv-btn-small ${disabledClass(isGenerating)}`}>\n              Revalidate\n            </button>}\n        </div>}\n\n      <div className=\"crv-refinements\">\n        <div className=\"crv-refinements-title\">Optional Refinements</div>\n        <div className=\"crv-refinements-list\">\n          {/* Summary */}\n          <div className=\"crv-refinement-row\">\n            <div>\n              <div className=\"crv-refinement-name\">Add Summary</div>\n              <div className=\"crv-refinement-desc\">\n                Generate a short summary for chronicle listings.\n              </div>\n              {summaryState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(summaryState.generatedAt)}\n                  {summaryState.model ? ` - ${summaryState.model}` : \"\"}\n                </div>}\n              {summaryIndicator && summaryState.generatedAt && <div className=\"crv-refinement-status-tight\">{summaryIndicator}</div>}\n              {!summaryState.generatedAt && !summaryState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {summaryState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateSummary && <button onClick={onGenerateSummary} disabled={isGenerating || summaryState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || summaryState.running)}`}>\n                {summaryState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* 3. Image Refs - finds image placement opportunities in the narrative */}\n          <div className=\"crv-refinement-row\">\n            <div className=\"crv-refinement-content\">\n              <div className=\"crv-refinement-name\">Add Image Refs</div>\n              <div className=\"crv-refinement-desc\">\n                Generate image placement suggestions for this chronicle.\n              </div>\n              {imageRefsState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(imageRefsState.generatedAt)}\n                  {imageRefsState.model ? ` - ${imageRefsState.model}` : \"\"}\n                </div>}\n              {imageRefsIndicator && imageRefsState.generatedAt && <div className=\"crv-refinement-status-tight\">{imageRefsIndicator}</div>}\n              {!imageRefsState.generatedAt && !imageRefsState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {imageRefsState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateImageRefs && <button onClick={onGenerateImageRefs} disabled={isGenerating || imageRefsState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || imageRefsState.running)}`}>\n                {imageRefsState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* Show ChronicleImagePanel when imageRefs are available */}\n          {imageRefs && entityMap && <div className=\"crv-image-panel-wrap\">\n              <ChronicleImagePanel imageRefs={imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} chronicleText={chronicleText || undefined} isGenerating={isGenerating} styleLibrary={styleLibrary} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={chronicleTitle} />\n            </div>}\n        </div>\n      </div>\n\n      {/* Generation Context (expandable) */}\n      {seedData && <ExpandableSeedSection seed={seedData} defaultExpanded={false} />}\n\n      {/* Tabs */}\n      <div className=\"crv-tabs\">\n        {[\"summary\", \"checks\", \"issues\"].map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`crv-tab ${activeTab === tab ? \"crv-tab-active\" : \"\"}`}>\n            {tab}\n            {tab === \"issues\" && report.issues.length > 0 && <span className={`crv-tab-badge ${assessment?.criticalIssueCount > 0 ? \"crv-tab-badge-critical\" : \"crv-tab-badge-minor\"}`}>\n                {report.issues.length}\n              </span>}\n          </button>)}\n      </div>\n\n      {/* Tab content */}\n      {activeTab === \"summary\" && <div className=\"crv-panel\">\n          <h3 className=\"crv-panel-title\">Validation Summary</h3>\n\n          <div className=\"crv-summary-grid\">\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.plotStructure.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.plotStructure.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Structure</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.entityConsistency.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.entityConsistency.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Entity Consistency</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.resolution.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.resolution.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Resolution</div>\n            </div>\n          </div>\n\n          {report.checks.plotStructure.notes && <div className=\"crv-notes-section\">\n              <div className=\"crv-notes-label\">Structure Notes:</div>\n              <div className=\"crv-notes-text\">{report.checks.plotStructure.notes}</div>\n            </div>}\n\n          {report.checks.themeExpression.notes && <div>\n              <div className=\"crv-notes-label\">Theme Expression:</div>\n              <div className=\"crv-notes-text\">{report.checks.themeExpression.notes}</div>\n            </div>}\n        </div>}\n\n      {activeTab === \"checks\" && <div className=\"crv-checks-panel\">\n          <CheckItem label=\"Structure\" check={report.checks.plotStructure} />\n          <CheckItem label=\"Entity Consistency\" check={report.checks.entityConsistency} />\n          <CheckItem label=\"Resolution\" check={report.checks.resolution} />\n          <CheckItem label=\"Factual Accuracy\" check={report.checks.factualAccuracy} />\n          <CheckItem label=\"Theme Expression\" check={report.checks.themeExpression} />\n\n          <div className=\"crv-section-goals-header\">\n            Section Goals ({report.checks.sectionGoals.filter(sg => sg.pass).length}/\n            {report.checks.sectionGoals.length} passed)\n          </div>\n          {report.checks.sectionGoals.map(sg => <div key={sg.sectionId} className=\"crv-section-goal-row\">\n              <div className=\"crv-section-goal-check\">\n                <CheckItem label={resolveSectionLabel(sg.sectionId)} check={sg} isSection />\n              </div>\n              {!sg.pass && <span className=\"crv-section-goal-label\">Needs revision</span>}\n            </div>)}\n        </div>}\n\n      {activeTab === \"issues\" && <div>\n          {report.issues.length === 0 ? <div className=\"crv-no-issues\">\n              <div className=\"crv-no-issues-icon\">\ud83c\udf89</div>\n              <div className=\"crv-no-issues-text\">No issues found!</div>\n            </div> : <>\n              {/* Critical issues first */}\n              {report.issues.filter(i => i.severity === \"critical\").length > 0 && <div className=\"crv-issues-group\">\n                  <h4 className=\"crv-issues-heading crv-issues-heading-critical\">\n                    Critical Issues ({report.issues.filter(i => i.severity === \"critical\").length}\n                    )\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"critical\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n\n              {/* Minor issues */}\n              {report.issues.filter(i => i.severity === \"minor\").length > 0 && <div>\n                  <h4 className=\"crv-issues-heading crv-issues-heading-minor\">\n                    Minor Issues ({report.issues.filter(i => i.severity === \"minor\").length})\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"minor\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n            </>}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}", "type": "{ report: any; seedData?: any; onAccept: any; onRegenerate: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateImageRefs: any; onRevalidate: any; refinements: any; isValidationStale?: boolean; editVersion?: number; isGenerating?: boolean; imageRefs?: any; entityMap?: any; onGenerateChronicleImage?: any; onResetChronicleImage?: any; onUpdateChronicleAnchorText?: any; onUpdateChronicleImageSize?: any; onUpdateChronicleImageJustification?: any; chronicleText?: any; summaryIndicato...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ConfigPanel.jsx", "sourceCode": "export default function ConfigPanel({ config, onConfigChange }) {\n  const handleModelChange = (newModel) => {\n    onConfigChange({ imageModel: newModel });\n  };\n\n  return (\n    <div>\n      {/* LLM Call Configuration - per-call model and thinking settings */}\n      <LLMCallConfigPanel />\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Generation</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"model-openai\" className=\"illuminator-label\">Model (OpenAI)</label>\n          <select id=\"model-openai\"\n            value={config.imageModel}\n            onChange={(e) => handleModelChange(e.target.value)}\n            className=\"illuminator-select\"\n          >\n            {IMAGE_MODELS.map((model) => (\n              <option key={model.value} value={model.value}>\n                {model.label}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <p className=\"cfgp-hint\">\n          Size and quality settings are in the Image Settings panel (sidebar).\n        </p>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Multishot Prompting</h2>\n        </div>\n        <p className=\"cfgp-section-desc\">Improve image generation by chaining multiple AI calls.</p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"requireDescription\"\n            checked={config.requireDescription || false}\n            onChange={(e) => onConfigChange({ requireDescription: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"requireDescription\">Require description before image</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint\">\n          Enforces description generation before image generation. The description will be included\n          in the image prompt.\n        </p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"useClaudeForImagePrompt\"\n            checked={config.useClaudeForImagePrompt || false}\n            onChange={(e) => onConfigChange({ useClaudeForImagePrompt: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"useClaudeForImagePrompt\">Use Claude to format image prompt</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint-tight\">\n          Sends the image prompt through Claude first to optimize it for the image model.\n        </p>\n\n        {config.useClaudeForImagePrompt && (\n          <>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Global Image Rules\n              <LocalTextArea\n                value={config.globalImageRules || \"\"}\n                onChange={(value) => onConfigChange({ globalImageRules: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder=\"SPECIES RULE: This world contains only [species]. Any figures depicted must be explicitly described as [species], never as humans or generic figures.\"\n                rows={4}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Domain-specific rules injected into all image prompts. Use this to enforce species,\n                setting constraints, or other world-specific requirements.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Entity image prompt template\n              <LocalTextArea\n                value={config.claudeImagePromptTemplate || DEFAULT_IMAGE_PROMPT_TEMPLATE}\n                onChange={(value) => onConfigChange({ claudeImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for entity portrait images. Use {\"{{modelName}}\"} for the image model name,{\" \"}\n                {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the global\n                rules above.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Chronicle image prompt template\n              <LocalTextArea\n                value={\n                  config.claudeChronicleImagePromptTemplate ||\n                  DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE\n                }\n                onChange={(value) => onConfigChange({ claudeChronicleImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for chronicle cover and scene images. Use {\"{{modelName}}\"} for the image model\n                name, {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the\n                global rules above.\n              </p>\n            </div>\n          </>\n        )}\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Performance</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <span className=\"illuminator-label\">Parallel workers</span>\n          <div className=\"cfgp-workers-row\">\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"8\"\n              value={config.numWorkers || 4}\n              onChange={(e) => onConfigChange({ numWorkers: parseInt(e.target.value, 10) })}\n              className=\"cfgp-range-input\"\n            />\n            <span className=\"cfgp-worker-count\">{config.numWorkers || 4}</span>\n          </div>\n          <p className=\"cfgp-hint\">\n            Number of concurrent API calls. Higher = faster but may hit rate limits.\n          </p>\n        </div>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">About</h2>\n        </div>\n        <p className=\"cfgp-about-text\">\n          Illuminator enriches your world simulation with LLM-generated content. Use the{\" \"}\n          <strong>Entities</strong> tab to generate descriptions and images for entities. Use the{\" \"}\n          <strong>Chronicle</strong> tab to generate multi-entity narratives and in-world documents.\n        </p>\n        <p className=\"cfgp-about-text-spaced\">\n          All enrichments are saved automatically to your current world slot.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onConfigChange }", "type": "{ config: any; onConfigChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function CorpusFindReplace() {\n  const navEntities = useEntityNavList();\n  const chronicleNavItems = useChronicleStore((s) => s.navItems);\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [find, setFind] = useState(\"\");\n  const [replace, setReplace] = useState(\"\");\n  const [caseSensitive, setCaseSensitive] = useState(true);\n  const [contexts, setContexts] = useState<Set<SearchContext>>(\n    new Set([\n      \"chronicleContent\",\n      \"chronicleTitles\",\n      \"chronicleAnnotations\",\n      \"entityAnnotations\",\n      \"eraNarrativeContent\",\n    ])\n  );\n  const [llmMode, setLlmMode] = useState(false);\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [matches, setMatches] = useState<CorpusMatch[]>([]);\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const [scanProgress, setScanProgress] = useState(\"\");\n\n  // LLM mode state\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const dispatchTimeRef = useRef<number>(0);\n  const expectedBatchCountRef = useRef<number>(0);\n  const matchesRef = useRef<CorpusMatch[]>([]);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) inputRef.current.focus();\n  }, [phase]);\n\n  useEffect(() => {\n    matchesRef.current = matches;\n  }, [matches]);\n\n  const hasAnnotationContext =\n    contexts.has(\"chronicleAnnotations\") || contexts.has(\"entityAnnotations\");\n\n  const toggleContext = useCallback((ctx: SearchContext) => {\n    setContexts((prev) => {\n      const next = new Set(prev);\n      if (next.has(ctx)) next.delete(ctx);\n      else next.add(ctx);\n      return next;\n    });\n  }, []);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    if (!find || contexts.size === 0) return;\n    setPhase(\"scanning\");\n    setError(null);\n    const allMatches: CorpusMatch[] = [];\n\n    // 1. Chronicle content\n    if (contexts.has(\"chronicleContent\")) {\n      const completeIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.status === \"complete\")\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < completeIds.length; i++) {\n        setScanProgress(`Chronicle content ${i + 1}/${completeIds.length}`);\n        const record = await getChronicle(completeIds[i]);\n        if (!record) continue;\n        const name = record.title || chronicleNavItems[completeIds[i]]?.name || \"Untitled\";\n\n        if (record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.finalContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"final\",\n              \"Published\",\n              undefined,\n              undefined\n            )\n          );\n        }\n        if (record.assembledContent && record.assembledContent !== record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.assembledContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"assembled\",\n              \"Current Draft\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    // 2. Chronicle titles\n    if (contexts.has(\"chronicleTitles\")) {\n      const allIds = Object.values(chronicleNavItems).map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < allIds.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Chronicle titles ${i + 1}/${allIds.length}`);\n        const record = await getChronicle(allIds[i]);\n        if (!record?.title) continue;\n        allMatches.push(\n          ...scanText(\n            record.title,\n            find,\n            caseSensitive,\n            record.title,\n            \"chronicleTitles\",\n            allIds[i],\n            \"title\",\n            \"Title\",\n            undefined,\n            undefined\n          )\n        );\n      }\n    }\n\n    // 3. Chronicle annotations\n    if (contexts.has(\"chronicleAnnotations\")) {\n      const annotatedIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.historianNoteCount > 0)\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < annotatedIds.length; i++) {\n        setScanProgress(`Chronicle annotations ${i + 1}/${annotatedIds.length}`);\n        const record = await getChronicle(annotatedIds[i]);\n        if (!record?.historianNotes) continue;\n        const name = record.title || chronicleNavItems[annotatedIds[i]]?.name || \"Untitled\";\n\n        for (const note of record.historianNotes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleAnnotations\",\n              annotatedIds[i],\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          // Also scan anchor phrases\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                name + \" (anchor)\",\n                \"chronicleAnnotations\",\n                annotatedIds[i],\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 4. Entity annotations\n    if (contexts.has(\"entityAnnotations\")) {\n      const annotatedNavs = navEntities.filter((n) => n.hasHistorianNotes);\n      setScanProgress(`Entity annotations: loading ${annotatedNavs.length} entities`);\n\n      const fullEntities = await useEntityStore\n        .getState()\n        .loadEntities(annotatedNavs.map((n) => n.id));\n\n      for (let i = 0; i < fullEntities.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Entity annotations ${i + 1}/${fullEntities.length}`);\n        const entity = fullEntities[i];\n        const notes = entity.enrichment?.historianNotes;\n        if (!notes) continue;\n\n        for (const note of notes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              entity.name,\n              \"entityAnnotations\",\n              entity.id,\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                entity.name + \" (anchor)\",\n                \"entityAnnotations\",\n                entity.id,\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 5. Era narrative content\n    if (contexts.has(\"eraNarrativeContent\")) {\n      const simRunId = useChronicleStore.getState().simulationRunId;\n      if (simRunId) {\n        const allNarratives = await getEraNarrativesForSimulation(simRunId);\n        const completedNarratives = allNarratives.filter(\n          (n) => n.status === \"complete\" || n.status === \"step_complete\"\n        );\n\n        for (let i = 0; i < completedNarratives.length; i++) {\n          setScanProgress(`Era narratives ${i + 1}/${completedNarratives.length}`);\n          const record = completedNarratives[i];\n          const { content } = resolveActiveContent(record);\n          if (!content) continue;\n          allMatches.push(\n            ...scanText(\n              content,\n              find,\n              caseSensitive,\n              record.eraName,\n              \"eraNarrativeContent\",\n              record.narrativeId,\n              \"activeContent\",\n              \"Active Version\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    setScanProgress(\"\");\n    setMatches(allMatches);\n\n    const initial: Record<string, boolean> = {};\n    for (const m of allMatches) initial[m.id] = true;\n    setDecisions(initial);\n\n    // Expand first group per context\n    const firstKeys = new Set<string>();\n    const seen = new Set<SearchContext>();\n    for (const m of allMatches) {\n      if (!seen.has(m.context)) {\n        firstKeys.add(`${m.context}:${m.sourceId}`);\n        seen.add(m.context);\n      }\n    }\n    setExpandedGroups(firstKeys);\n\n    setPhase(allMatches.length > 0 ? \"preview\" : \"empty\");\n  }, [find, caseSensitive, contexts, chronicleNavItems, navEntities]);\n\n  // --- Generate LLM Variants ---\n  const handleGenerate = useCallback(() => {\n    setPhase(\"generating\");\n    setError(null);\n\n    // Only annotation matches go through LLM\n    const annotationMatches = matches.filter(\n      (m) => m.context === \"chronicleAnnotations\" || m.context === \"entityAnnotations\"\n    );\n\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CostsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CostsPanel.jsx", "sourceCode": "export default function CostsPanel({ queue, projectId, simulationRunId }) {\n  // Cost data from IndexedDB\n  const [simulationCosts, setSimulationCosts] = useState(null);\n  const [projectCosts, setProjectCosts] = useState(null);\n  const [allTimeCosts, setAllTimeCosts] = useState(null);\n  const [refreshTrigger, setRefreshTrigger] = useState(0);\n\n  // Track running tasks to know when to refresh\n  const runningTaskCount = useMemo(() => {\n    return queue.filter((item) => item.status === \"queued\" || item.status === \"running\").length;\n  }, [queue]);\n\n  // Fetch costs from IndexedDB\n  const fetchCosts = useCallback(async () => {\n    try {\n      // All-time costs\n      const allRecords = await getAllCosts();\n      setAllTimeCosts(summarizeCosts(allRecords));\n\n      // Project costs\n      if (projectId) {\n        const projectRecords = await getCostsForProject(projectId);\n        setProjectCosts(summarizeCosts(projectRecords));\n      } else {\n        setProjectCosts(null);\n      }\n\n      // Simulation costs\n      if (simulationRunId) {\n        const simRecords = await getCostsForSimulation(simulationRunId);\n        setSimulationCosts(summarizeCosts(simRecords));\n      } else {\n        setSimulationCosts(null);\n      }\n    } catch (err) {\n      console.error(\"[CostsPanel] Failed to fetch costs:\", err);\n    }\n  }, [projectId, simulationRunId]);\n\n  // Fetch on mount and when dependencies change\n  useEffect(() => {\n    fetchCosts();\n  }, [fetchCosts, refreshTrigger]);\n\n  // Refresh when queue changes (tasks complete)\n  useEffect(() => {\n    // Only refresh when queue length decreases (task completed)\n    const timer = setTimeout(() => {\n      setRefreshTrigger((prev) => prev + 1);\n    }, 500);\n    return () => clearTimeout(timer);\n  }, [queue.length, runningTaskCount]);\n\n  // Calculate pending queue costs (estimated)\n  const queueCosts = useMemo(() => {\n    let textEstimated = 0;\n    let imageEstimated = 0;\n    let chronicleEstimated = 0;\n\n    for (const item of queue) {\n      if (item.status === \"complete\") continue;\n      if (item.estimatedCost) {\n        if (item.type === \"image\") {\n          imageEstimated += item.estimatedCost;\n        } else if (item.type === \"entityChronicle\") {\n          chronicleEstimated += item.estimatedCost;\n        } else {\n          textEstimated += item.estimatedCost;\n        }\n      } else if (item.type === \"entityChronicle\" && item.status !== \"complete\") {\n        // Estimate chronicle cost if not available (~$0.05-0.15 per chronicle depending on length)\n        chronicleEstimated += 0.08;\n      }\n    }\n\n    return {\n      textEstimated,\n      imageEstimated,\n      chronicleEstimated,\n      total: textEstimated + imageEstimated + chronicleEstimated,\n    };\n  }, [queue]);\n\n  // Categorize costs for display\n  const simCategorized = simulationCosts ? categorizeCosts(simulationCosts) : null;\n  const projCategorized = projectCosts ? categorizeCosts(projectCosts) : null;\n  const allCategorized = allTimeCosts ? categorizeCosts(allTimeCosts) : null;\n\n  const handleClearHistory = async () => {\n    if (confirm(\"Clear all cost history? This cannot be undone.\")) {\n      await clearAllCosts();\n      setRefreshTrigger((prev) => prev + 1);\n    }\n  };\n\n  return (\n    <div>\n      {/* Current Simulation */}\n      {simCategorized && (\n        <CostCard title=\"Current Simulation\">\n          <div className=\"cpanel-section-hint\">Costs from this simulation run.</div>\n          <CostRow label=\"Text generations\" value={simCategorized.text.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.text.count} requests`}\n            value={simCategorized.text.actual}\n          />\n          <CostRow label=\"Image generations\" value={simCategorized.image.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.image.count} images`}\n            value={simCategorized.image.actual}\n          />\n          <CostRow label=\"Chronicle generations\" value={simCategorized.chronicle.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.chronicle.count} steps`}\n            value={simCategorized.chronicle.actual}\n          />\n          <CostRow label=\"Dynamics generation\" value={simCategorized.dynamics.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.dynamics.count} turns`}\n            value={simCategorized.dynamics.actual}\n          />\n          <CostRow label=\"Summary revision\" value={simCategorized.revision.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.revision.count} batches`}\n            value={simCategorized.revision.actual}\n          />\n          <CostRow label=\"Simulation Total\" value={simulationCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* Pending Queue */}\n      {queueCosts.total > 0 && (\n        <CostCard title=\"Pending Queue (Estimated)\">\n          <div className=\"cpanel-section-hint\">\n            Estimated costs for queued tasks not yet completed.\n          </div>\n          <CostRow label=\"Text generations\" value={queueCosts.textEstimated} isEstimated />\n          <CostRow label=\"Image generations\" value={queueCosts.imageEstimated} isEstimated />\n          <CostRow\n            label=\"Chronicle generations\"\n            value={queueCosts.chronicleEstimated}\n            isEstimated\n          />\n          <CostRow label=\"Queue Total\" value={queueCosts.total} isTotal isEstimated />\n        </CostCard>\n      )}\n\n      {/* By Model */}\n      {simulationCosts && Object.keys(simulationCosts.byModel).length > 0 && (\n        <CostCard title=\"By Model (Simulation)\">\n          <div className=\"cpanel-section-hint\">Cost breakdown by model used.</div>\n          {Object.entries(simulationCosts.byModel)\n            .sort((a, b) => b[1].actual - a[1].actual)\n            .map(([model, data]) => (\n              <CostRow key={model} label={model} value={data.actual} />\n            ))}\n        </CostCard>\n      )}\n\n      {/* Project Total */}\n      {projCategorized && (\n        <CostCard title=\"Project Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs for this project across all simulations.\n          </div>\n          <CostRow label=\"Text generations\" value={projCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={projCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={projCategorized.chronicle.actual} />\n          <CostRow label=\"Project Total\" value={projectCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* All Time */}\n      {allCategorized && (\n        <CostCard title=\"All Time Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs across all projects and sessions.\n          </div>\n          <CostRow label=\"Text generations\" value={allCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={allCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={allCategorized.chronicle.actual} />\n          <CostRow label=\"All Time Total\" value={allTimeCosts.totalActual} isTotal />\n          <CostRow\n            label={`  \\u2514 ${allTimeCosts.count} total records`}\n            value={allTimeCosts.totalActual}\n          />\n\n          <button\n            onClick={() => void handleClearHistory()}\n            className=\"illuminator-button-link cpanel-clear-button\"\n          >\n            Clear History\n          </button>\n        </CostCard>\n      )}\n\n      {/* Empty state */}\n      {!simulationCosts && !allTimeCosts && queueCosts.total === 0 && (\n        <CostCard title=\"Cost Tracking\">\n          <div className=\"cpanel-empty-hint\">\n            No costs recorded yet. Costs will appear here as you generate content.\n          </div>\n        </CostCard>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ queue, projectId, simulationRunId }", "type": "{ queue: any; projectId: any; simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CoveragePanel.jsx", "sourceCode": "export default function CoveragePanel({\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}) {\n  const [chronicles, setChronicles] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [expanded, setExpanded] = useState(true);\n  const [disabledChronicles, setDisabledChronicles] = useState(() => {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (!raw) return {};\n      const parsed = JSON.parse(raw);\n      if (parsed && typeof parsed === \"object\") return parsed;\n    } catch {}\n    return {};\n  });\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(disabledChronicles));\n    } catch {}\n  }, [disabledChronicles]);\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    setLoading(true);\n    getChroniclesForSimulation(simulationRunId).then(records => {\n      if (!cancelled) setChronicles(records);\n    }).catch(err => {\n      console.error(\"[Coverage] Failed to load chronicles:\", err);\n      if (!cancelled) setChronicles([]);\n    }).finally(() => {\n      if (!cancelled) setLoading(false);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const toggleChronicle = useCallback(chronicleId => {\n    setDisabledChronicles(prev => ({\n      ...prev,\n      [chronicleId]: !prev[chronicleId]\n    }));\n  }, []);\n  const toggleFact = useCallback(factId => {\n    if (!onWorldContextChange) return;\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const updated = rawFacts.map(f => f.id === factId ? {\n      ...f,\n      disabled: !f.disabled,\n      required: !f.disabled ? false : f.required\n    } : f);\n    onWorldContextChange({\n      canonFactsWithMetadata: updated\n    });\n  }, [onWorldContextChange, worldContext?.canonFactsWithMetadata]);\n  const analysis = useMemo(() => {\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const normalizedWorldFacts = rawFacts.map((fact, index) => normalizeFact(fact, index)).filter(Boolean);\n    const chronicleList = [...(chronicles || [])].sort(sortChronicles);\n    const facts = normalizedWorldFacts.filter(fact => fact.type !== \"generation_constraint\");\n    const enabledFacts = facts.filter(fact => !fact.disabled);\n    const allFactIdSet = new Set(facts.map(fact => fact.id));\n    const rows = chronicleList.map(chronicle => {\n      const synthesis = chronicle.perspectiveSynthesis || null;\n      const facetIds = new Set();\n      let unparsedCount = 0;\n      for (const facet of synthesis?.facets || []) {\n        if (!facet?.factId) continue;\n        if (allFactIdSet.has(facet.factId)) {\n          facetIds.add(facet.factId);\n        } else {\n          unparsedCount += 1;\n        }\n      }\n      return {\n        chronicle,\n        synthesis,\n        facetIds,\n        unparsedCount,\n        isIncluded: !disabledChronicles[chronicle.chronicleId]\n      };\n    });\n    const factTotals = new Map(facts.map(fact => [fact.id, 0]));\n    const disabledFactIds = new Set(facts.filter(f => f.disabled).map(f => f.id));\n    let totalSelections = 0;\n    let unparsedTotal = 0;\n    let includedCount = 0;\n    const processedRows = rows.map(row => {\n      if (row.isIncluded) {\n        includedCount += 1;\n        for (const factId of row.facetIds) {\n          factTotals.set(factId, (factTotals.get(factId) || 0) + 1);\n        }\n        let enabledHits = 0;\n        for (const factId of row.facetIds) {\n          if (!disabledFactIds.has(factId)) enabledHits += 1;\n        }\n        totalSelections += enabledHits;\n        unparsedTotal += row.unparsedCount || 0;\n      }\n      let rowEnabledTotal = 0;\n      for (const factId of row.facetIds) {\n        if (!disabledFactIds.has(factId)) rowEnabledTotal += 1;\n      }\n      return {\n        ...row,\n        rowTotal: rowEnabledTotal\n      };\n    });\n    const chroniclesWithSynthesis = processedRows.filter(row => row.synthesis).length;\n    const unusedFacts = enabledFacts.filter(fact => (factTotals.get(fact.id) || 0) === 0).length;\n    const disabledFactCount = facts.filter(fact => fact.disabled).length;\n    const constraintCount = normalizedWorldFacts.filter(fact => fact.type === \"generation_constraint\").length;\n    return {\n      facts,\n      factTotals,\n      rows: processedRows,\n      totalSelections,\n      unparsedTotal,\n      includedCount,\n      chroniclesWithSynthesis,\n      chronicleCount: processedRows.length,\n      unusedFacts,\n      disabledFactCount,\n      constraintCount\n    };\n  }, [chronicles, worldContext, disabledChronicles]);\n  const {\n    facts,\n    factTotals,\n    rows,\n    totalSelections,\n    unparsedTotal,\n    includedCount,\n    chroniclesWithSynthesis,\n    chronicleCount,\n    unusedFacts,\n    disabledFactCount,\n    constraintCount\n  } = analysis;\n\n  // Fact coverage analysis stats (from LLM ratings)\n  const coverageStats = useMemo(() => {\n    const chroniclesWithReport = chronicles.filter(c => c.factCoverageReport?.entries?.length);\n    if (!chroniclesWithReport.length || !facts.length) return null;\n\n    // Per-fact aggregation: count how many chronicles rated each fact at each level\n    const perFact = new Map();\n    for (const fact of facts) {\n      perFact.set(fact.id, {\n        integral: 0,\n        prevalent: 0,\n        mentioned: 0,\n        missing: 0,\n        total: 0\n      });\n    }\n    for (const chronicle of chroniclesWithReport) {\n      for (const entry of chronicle.factCoverageReport.entries) {\n        const agg = perFact.get(entry.factId);\n        if (agg && entry.rating) {\n          if (agg[entry.rating] !== undefined) agg[entry.rating]++;\n          agg.total++;\n        }\n      }\n    }\n\n    // Global totals\n    let totalEntries = 0;\n    const globalCounts = {\n      integral: 0,\n      prevalent: 0,\n      mentioned: 0,\n      missing: 0\n    };\n    for (const [, agg] of perFact) {\n      for (const r of [\"integral\", \"prevalent\", \"mentioned\", \"missing\"]) {\n        globalCounts[r] += agg[r];\n      }\n      totalEntries += agg.total;\n    }\n    return {\n      chroniclesAnalyzed: chroniclesWithReport.length,\n      totalEntries,\n      globalCounts,\n      perFact\n    };\n  }, [chronicles, facts]);\n  const disableAll = useCallback(() => {\n    const next = {};\n    for (const row of rows) {\n      next[row.chronicle.chronicleId] = true;\n    }\n    setDisabledChronicles(next);\n  }, [rows]);\n  const enableAll = useCallback(() => {\n    setDisabledChronicles({});\n  }, []);\n  if (!simulationRunId) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">No active simulation run.</div>\n      </div>;\n  }\n  if (loading && chronicleCount === 0) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">Loading chronicles...</div>\n      </div>;\n  }\n  if (!facts.length) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n          <span className=\"illuminator-card-subtitle\">Perspective synthesis fact coverage</span>\n        </div>\n        <div className=\"cvp-empty-msg\">\n          No canon facts configured. Add facts in the Context tab to enable coverage tracking.\n        </div>\n      </div>;\n  }\n  return <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header cvp-header-clickable\" onClick={() => setExpanded(prev => !prev)} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        <span className=\"cvp-expand-icon\">{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <h2 className=\"illuminator-card-title\">Lore Coverage</h2>\n        {!expanded && <span className=\"illuminator-card-subtitle cvp-collapsed-subtitle\">\n            {chronicleCount} chronicles, {facts.length - disabledFactCount} facts\n            {unusedFacts > 0 ? `, ${unusedFacts} unused` : \"\"}\n          </span>}\n      </div>\n\n      {expanded && <>\n          <div className=\"illuminator-coverage-summary\">\n            <div>\n              <strong>Chronicles</strong>: {chronicleCount} total, {includedCount} counted,{\" \"}\n              {chroniclesWithSynthesis} with synthesis\n            </div>\n            <div>\n              <strong>Facts</strong>: {facts.length - disabledFactCount} active ({unusedFacts}{\" \"}\n              unused){disabledFactCount > 0 && `, ${disabledFactCount} disabled`}\n            </div>\n            <div>\n              <strong>Total selections</strong>: {totalSelections}\n            </div>\n            <div>\n              <strong>Unparsed facets</strong>: {unparsedTotal}\n            </div>\n            {constraintCount > 0 && <div>\n                <strong>Constraints excluded</strong>: {constraintCount}\n              </div>}\n            <div className=\"cvp-summary-controls\">\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={enableAll}>\n                Count all\n              </button>\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={disableAll}>\n                Count none\n              </button>\n            </div>\n          </div>\n\n          <div className=\"illuminator-coverage-table\">\n            <table>\n              <thead>\n                <tr>\n                  <th className=\"illuminator-coverage-sticky\">Chronicle</th>\n                  <th className=\"illuminator-coverage-toggle-col\">Counted</th>\n                  {facts.map(fact => {\n                const factText = fact.text ? `: ${fact.text}` : \"\";\n                const requiredLabel = fact.required ? \" (required)\" : \"\";\n                const disabledLabel = fact.disabled ? \" (disabled \\u2014 click to enable)\" : \" (click to disable)\";\n                const factTitle = `${fact.id}${factText}${requiredLabel}${disabledLabel}`;\n                return <th key={fact.id} title={factTitle} onClick={onWorldContextChange ? () => toggleFact(fact.id) : undefined} className={onWorldContextChange ? \"cvp-fact-header-clickable\" : undefined}>\n                      <div className={`illuminator-coverage-fact-header ${fact.disabled ? \"cvp-fact-header-disabled\" : \"\"}`}>\n                        <span className=\"illuminator-coverage-fact-id\">{fact.id}</span>\n                        {fact.required && <span className=\"illuminator-coverage-required\">R</span>}\n                        {fact.disabled && <span className=\"cvp-fact-disabled-label\">off</span>}\n                      </div>\n                    </th>;\n              })}\n                  <th className=\"illuminator-coverage-unparsed-col\">Unparsed</th>\n                  <th className=\"illuminator-coverage-total-col\">Total</th>\n                </tr>\n              </thead>\n              <tbody>\n                <tr className=\"illuminator-coverage-total-row\">\n                  <td className=\"illuminator-coverage-sticky\">Total usage</td>\n                  <td className=\"illuminator-coverage-toggle-col\">{includedCount}</td>\n                  {facts.map(fact => <td key={`total-${fact.id}`} className={fact.disabled ? \"cvp-cell-disabled\" : undefined}>\n                      {factTotals.get(fact.id) || 0}\n                    </td>)}\n                  <td className=\"illuminator-coverage-unparsed-col\">{unparsedTotal}</td>\n                  <td className=\"illuminator-coverage-total-col\">{totalSelections}</td>\n                </tr>\n// ... (truncated)", "parameters": [{"name": "{\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}", "type": "{ worldContext: any; simulationRunId: any; onWorldContextChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CreateEntityModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CreateEntityModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Component\n// ---------------------------------------------------------------------------\n\nexport default function CreateEntityModal({\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}: Readonly<CreateEntityModalProps>) {\n  const isEdit = Boolean(editEntity);\n  const entityKinds = useMemo(\n    () => (worldSchema.entityKinds || []).filter((k) => !k.isFramework),\n    [worldSchema.entityKinds]\n  );\n  const cultures = worldSchema.cultures || [];\n  const d = isEdit ? undefined : defaults; // ignore defaults in edit mode\n\n  // Form state \u2014 initialized from editEntity (edit mode) or defaults (create mode)\n  const [kind, setKind] = useState(() => editEntity?.kind || d?.kind || entityKinds[0]?.kind || \"\");\n  const [name] = useState(() => editEntity?.name || \"\");\n  const [nameInput, setNameInput] = useState(() => editEntity?.name || d?.name || \"\");\n  const [culture, setCulture] = useState(\n    () => editEntity?.culture || d?.culture || cultures[0]?.id || \"\"\n  );\n  const [prominence, setProminence] = useState(() => editEntity?.prominence ?? 1);\n  const [description, setDescription] = useState(() => editEntity?.description || \"\");\n  const [eraId, setEraId] = useState(() => editEntity?.eraId || d?.eraId || \"\");\n  const [startTick, setStartTick] = useState(() => {\n    if (editEntity?.temporal?.startTick != null) return String(editEntity.temporal.startTick);\n    if (d?.startTick != null) return String(d.startTick);\n    return \"\";\n  });\n  const [endTick, setEndTick] = useState(() => {\n    if (editEntity?.temporal?.endTick != null) return String(editEntity.temporal.endTick);\n    if (d?.endTick != null) return String(d.endTick);\n    return \"\";\n  });\n  const [tags, setTags] = useState<Record<string, string>>(() =>\n    tagsToStringRecord(editEntity?.tags)\n  );\n  const [tagKey, setTagKey] = useState(\"\");\n  const [tagValue, setTagValue] = useState(\"\");\n\n  // Derived from selected kind\n  const kindDef = useMemo(() => entityKinds.find((k) => k.kind === kind), [entityKinds, kind]);\n  const subtypes = kindDef?.subtypes || [];\n  const statuses = kindDef?.statuses || [];\n  const defaultStatus = kindDef?.defaultStatus || statuses[0]?.id || \"active\";\n\n  const [subtype, setSubtype] = useState(\n    () => editEntity?.subtype || d?.subtype || subtypes[0]?.id || \"\"\n  );\n  const [status, setStatus] = useState(() => editEntity?.status || defaultStatus);\n\n  // Cascade subtype and status when kind changes (only in create mode or explicit change)\n  const handleKindChange = useCallback(\n    (newKind: string) => {\n      setKind(newKind);\n      const def = entityKinds.find((k) => k.kind === newKind);\n      setSubtype(def?.subtypes[0]?.id || \"\");\n      setStatus(def?.defaultStatus || def?.statuses[0]?.id || \"active\");\n    },\n    [entityKinds]\n  );\n\n  // Tag management\n  const addTag = useCallback(() => {\n    const k = tagKey.trim();\n    if (!k) return;\n    setTags((prev) => ({ ...prev, [k]: tagValue }));\n    setTagKey(\"\");\n    setTagValue(\"\");\n  }, [tagKey, tagValue]);\n\n  const removeTag = useCallback((key: string) => {\n    setTags((prev) => {\n      const next = { ...prev };\n      delete next[key];\n      return next;\n    });\n  }, []);\n\n  // Submit\n  const effectiveName = isEdit ? name : nameInput;\n  const canSubmit = effectiveName.trim().length > 0 && kind;\n\n  const handleSubmit = useCallback(() => {\n    if (!canSubmit) return;\n    const entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\"> = {\n      kind,\n      subtype,\n      name: effectiveName.trim(),\n      culture,\n      status,\n      prominence,\n      description,\n      tags,\n      coordinates: editEntity?.coordinates || { x: 0, y: 0, z: 0 },\n    };\n    if (eraId) entity.eraId = eraId;\n    const parsedStart = Number(startTick);\n    const parsedEnd = endTick ? Number(endTick) : null;\n    if (Number.isFinite(parsedStart)) {\n      entity.temporal = { startTick: parsedStart, endTick: parsedEnd };\n    }\n    onSubmit(entity);\n  }, [\n    canSubmit,\n    kind,\n    subtype,\n    effectiveName,\n    culture,\n    status,\n    prominence,\n    description,\n    tags,\n    eraId,\n    startTick,\n    endTick,\n    editEntity,\n    onSubmit,\n  ]);\n\n  const title = isEdit ? \"Edit Entity\" : \"Create Entity\";\n  const submitLabel = isEdit ? \"Save Changes\" : \"Create Entity\";\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"cem-backdrop\">\n        <div className=\"cem-card\">\n          <div className=\"cem-header\">\n            <h2 className=\"cem-title\">{title}</h2>\n          </div>\n          <div className=\"cem-empty-body\">\n            No entity kinds available in the schema.\n          </div>\n          <div className=\"cem-footer\">\n            <button onClick={onClose} className=\"illuminator-button illuminator-button-secondary\">\n              Close\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"cem-backdrop\">\n      <div className=\"cem-card\">\n        {/* Header */}\n        <div className=\"cem-header\">\n          <h2 className=\"cem-title\">{title}</h2>\n          {isEdit && (\n            <p className=\"cem-edit-subtitle\">\n              {name}\n            </p>\n          )}\n        </div>\n\n        {/* Body */}\n        <div className=\"cem-body\">\n          {/* Kind + Subtype row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"kind\" className=\"cem-label\">Kind</label>\n              <select id=\"kind\"\n                value={kind}\n                onChange={(e) => handleKindChange(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {entityKinds.map((k) => (\n                  <option key={k.kind} value={k.kind}>\n                    {k.description || k.kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"subtype\" className=\"cem-label\">Subtype</label>\n              <select id=\"subtype\"\n                value={subtype}\n                onChange={(e) => setSubtype(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n                disabled={subtypes.length === 0}\n              >\n                {subtypes.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n                {subtypes.length === 0 && <option value=\"\">None</option>}\n              </select>\n            </div>\n          </div>\n\n          {/* Name \u2014 only editable in create mode */}\n          {!isEdit && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"name\" className=\"cem-label\">Name *</label>\n              <input id=\"name\"\n                type=\"text\"\n                value={nameInput}\n                onChange={(e) => setNameInput(e.target.value)}\n                placeholder=\"Entity name\"\n                className=\"illuminator-select cem-full-width-box\"\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n\n          {/* Culture + Status row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"culture\" className=\"cem-label\">Culture</label>\n              <select id=\"culture\"\n                value={culture}\n                onChange={(e) => setCulture(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {cultures.map((c) => (\n                  <option key={c.id} value={c.id}>\n                    {c.name || c.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"status\" className=\"cem-label\">Status</label>\n              <select id=\"status\"\n                value={status}\n                onChange={(e) => setStatus(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {statuses.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          </div>\n\n          {/* Prominence */}\n          <div className=\"cem-field-group\">\n            <label htmlFor=\"prominence\" className=\"cem-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={prominence}\n              onChange={(e) => setProminence(Number(e.target.value))}\n              className=\"illuminator-select cem-full-width\"\n            >\n              {PROMINENCE_OPTIONS.map((opt) => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.label}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          {/* Era */}\n          {eras.length > 0 && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"era\" className=\"cem-label\">Era</label>\n              <select id=\"era\"\n                value={eraId}\n                onChange={(e) => setEraId(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                <option value=\"\">None</option>\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name || era.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          )}\n\n          {/* Temporal */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"start-tick\" className=\"cem-label\">Start Tick</label>\n              <input id=\"start-tick\"\n                type=\"number\"\n                value={startTick}\n                onChange={(e) => setStartTick(e.target.value)}\n                placeholder=\"Optional\"\n                className=\"illuminator-select cem-full-width-box\"\n              />\n            </div>\n            <div>\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}", "type": "Readonly<CreateEntityModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx", "sourceCode": "// ============================================================================\n// Modal\n// ============================================================================\n\nexport default function DescriptionMotifWeaver({ onClose }: Readonly<{ onClose: () => void }>) {\n  const navEntities = useEntityNavList();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [phase, setPhase] = useState<Phase>(\"scan\");\n  const [candidates, setCandidates] = useState<WeaveCandidate[]>([]);\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n\n  const dispatchTimeRef = useRef<number>(0);\n  const candidatesRef = useRef<WeaveCandidate[]>([]);\n\n  useEffect(() => {\n    candidatesRef.current = candidates;\n  }, [candidates]);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    setPhase(\"scanning\");\n    setError(null);\n\n    // Load all entities with descriptions\n    const allNavs = navEntities.filter((n) => n.kind !== \"era\" && n.kind !== \"occurrence\");\n    if (allNavs.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    const fullEntities = await useEntityStore.getState().loadEntities(allNavs.map((n) => n.id));\n\n    let globalIndex = 0;\n    const allCandidates: WeaveCandidate[] = [];\n\n    for (const entity of fullEntities) {\n      if (!entity.description) continue;\n      const entityCandidates = scanDescriptionForConcepts(\n        entity.id,\n        entity.name,\n        entity.description,\n        globalIndex\n      );\n      allCandidates.push(...entityCandidates);\n      globalIndex += entityCandidates.length;\n    }\n\n    if (allCandidates.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    setCandidates(allCandidates);\n    // Default: reject all (light touch \u2014 user opts in)\n    const initial: Record<string, boolean> = {};\n    for (const c of allCandidates) initial[c.id] = false;\n    setDecisions(initial);\n    if (allCandidates.length > 0) {\n      setExpandedGroups(new Set([allCandidates[0].entityId]));\n    }\n\n    // Stop for confirmation before LLM calls\n    setPhase(\"confirm\");\n  }, [navEntities]);\n\n  // --- Generate ---\n  const handleGenerate = useCallback((scanCandidates: WeaveCandidate[]) => {\n    setPhase(\"generating\");\n\n    const batches: WeaveCandidate[][] = [];\n    for (let i = 0; i < scanCandidates.length; i += BATCH_SIZE) {\n      batches.push(scanCandidates.slice(i, i + BATCH_SIZE));\n    }\n\n    const dispatchTime = Date.now();\n    dispatchTimeRef.current = dispatchTime;\n\n    for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {\n      const batch = batches[batchIdx];\n      const payload: MotifWeavePayload = {\n        mode: \"weave\",\n        targetPhrase: TARGET_PHRASE,\n        instances: batch.map((c) => ({\n          index: c.batchIndex,\n          entityName: c.entityName,\n          sentence: c.sentence,\n          surroundingContext: c.contextBefore + c.contextAfter,\n        })),\n      };\n\n      const syntheticEntity = {\n        id: `weave_batch_${dispatchTime}_${batchIdx}`,\n        name: `Weave: ${TARGET_PHRASE} (batch ${batchIdx + 1})`,\n        kind: \"motif\" as string,\n        subtype: \"weave\" as string,\n        prominence: \"marginal\" as unknown as string,\n        culture: \"\" as string,\n        status: \"active\" as string,\n        description: \"\" as string,\n        tags: {} as Record<string, unknown>,\n      };\n\n      try {\n        getEnqueue()([\n          {\n            entity: syntheticEntity,\n            type: \"motifVariation\" as const,\n            prompt: JSON.stringify(payload),\n          },\n        ]);\n      } catch (err) {\n        setError(`Failed to dispatch batch ${batchIdx + 1}: ${err}`);\n        setPhase(\"scan\");\n        return;\n      }\n    }\n  }, []);\n\n  // --- Watch queue for completion ---\n  useEffect(() => {\n    if (phase !== \"generating\") return;\n    const dispatchTime = dispatchTimeRef.current;\n    if (!dispatchTime) return;\n\n    const motifItems = queue.filter(\n      (item) => item.type === \"motifVariation\" && item.queuedAt >= dispatchTime\n    );\n    if (motifItems.length === 0) return;\n\n    const running = motifItems.filter(\n      (item) => item.status === \"running\" || item.status === \"queued\"\n    );\n    const completed = motifItems.filter((item) => item.status === \"complete\");\n    const errored = motifItems.filter((item) => item.status === \"error\");\n\n    if (running.length === 0 && (completed.length > 0 || errored.length > 0)) {\n      if (errored.length > 0) {\n        setError(`${errored.length} batch(es) failed: ${errored[0].error || \"Unknown error\"}`);\n      }\n\n      const variantMap = new Map<string, string>();\n      const currentCandidates = candidatesRef.current;\n\n      for (const item of completed) {\n        if (!item.result?.description) continue;\n        try {\n          const results: MotifVariationResult[] = JSON.parse(item.result.description);\n          for (const r of results) {\n            const candidate = currentCandidates.find((c) => c.batchIndex === r.index);\n            if (candidate) {\n              variantMap.set(candidate.id, r.variant);\n            }\n          }\n        } catch {\n          // Skip unparseable results\n        }\n      }\n\n      setVariants(variantMap);\n      setPhase(variantMap.size > 0 ? \"review\" : \"empty\");\n    }\n  }, [phase, queue]);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    setPhase(\"applying\");\n\n    // Group accepted changes by entity\n    const changesByEntity = new Map<\n      string,\n      Array<{ sentenceStart: number; sentenceEnd: number; original: string; rewritten: string }>\n    >();\n\n    for (const c of candidates) {\n      if (!decisions[c.id]) continue;\n      const variant = variants.get(c.id);\n      if (!variant) continue;\n\n      if (!changesByEntity.has(c.entityId)) {\n        changesByEntity.set(c.entityId, []);\n      }\n      changesByEntity.get(c.entityId).push({\n        sentenceStart: c.sentenceStart,\n        sentenceEnd: c.sentenceEnd,\n        original: c.sentence,\n        rewritten: variant,\n      });\n    }\n\n    // Build patches by applying sentence replacements to descriptions\n    const patches: Array<{ entityId: string; description: string }> = [];\n    const updatedEntityIds: string[] = [];\n    let total = 0;\n\n    for (const [entityId, changes] of changesByEntity) {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity?.description) continue;\n\n      // Sort changes descending by position (apply from end to preserve earlier positions)\n      const sorted = [...changes].sort((a, b) => b.sentenceStart - a.sentenceStart);\n      let description = entity.description;\n      for (const change of sorted) {\n        // Verify the original sentence still exists at the expected position\n        const actual = description.slice(change.sentenceStart, change.sentenceEnd);\n        if (actual === change.original) {\n          description =\n            description.slice(0, change.sentenceStart) +\n            change.rewritten +\n            description.slice(change.sentenceEnd);\n          total++;\n        }\n      }\n\n      if (description !== entity.description) {\n        patches.push({ entityId, description });\n        updatedEntityIds.push(entityId);\n      }\n    }\n\n    if (patches.length > 0) {\n      await applyRevisionPatches(patches, \"motif-weave\");\n      await reloadEntities(updatedEntityIds);\n    }\n\n    setResultCount(total);\n    setPhase(\"done\");\n  }, [candidates, decisions, variants]);\n\n  // --- Decision helpers ---\n  const toggleDecision = useCallback((id: string) => {\n    setDecisions((prev) => ({ ...prev, [id]: !prev[id] }));\n  }, []);\n\n  const acceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) {\n        if (variants.has(c.id)) next[c.id] = true;\n      }\n      return next;\n    });\n  }, [candidates, variants]);\n\n  const rejectAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) next[c.id] = false;\n      return next;\n    });\n  }, [candidates]);\n\n  const acceptGroup = useCallback(\n    (groupCandidates: WeaveCandidate[]) => {\n      setDecisions((prev) => {\n        const next = { ...prev };\n        for (const c of groupCandidates) {\n          if (variants.has(c.id)) next[c.id] = true;\n        }\n        return next;\n      });\n    },\n    [variants]\n  );\n\n  const rejectGroup = useCallback((groupCandidates: WeaveCandidate[]) => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of groupCandidates) next[c.id] = false;\n      return next;\n    });\n  }, []);\n\n  const toggleExpand = useCallback((key: string) => {\n    setExpandedGroups((prev) => {\n      const next = new Set(prev);\n      if (next.has(key)) next.delete(key);\n      else next.add(key);\n      return next;\n    });\n  }, []);\n\n  // --- Stats ---\n  const acceptCount = useMemo(() => Object.values(decisions).filter(Boolean).length, [decisions]);\n\n  // --- Groups (by entity) ---\n  const groups = useMemo(() => {\n    const map = new Map<\n      string,\n      { entityId: string; entityName: string; candidates: WeaveCandidate[] }\n    >();\n    for (const c of candidates) {\n      if (!map.has(c.entityId)) {\n        map.set(c.entityId, { entityId: c.entityId, entityName: c.entityName, candidates: [] });\n      }\n      map.get(c.entityId).candidates.push(c);\n// ... (truncated)", "parameters": [{"name": "{ onClose }", "type": "Readonly<{ onClose: () => void }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function DynamicsGenerationModal({\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}) {\n  const [feedback, setFeedback] = useState(\"\");\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to bottom on new messages\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.messages?.length, run?.proposedDynamics?.length]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isReviewable = run.status === \"awaiting_review\";\n  const isFailed = run.status === \"failed\";\n\n  const handleSubmitFeedback = () => {\n    if (!feedback.trim()) return;\n    onSubmitFeedback(feedback.trim());\n    setFeedback(\"\");\n  };\n\n  const handleKeyDown = (e) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmitFeedback();\n    }\n  };\n\n  const displayMessages = run.messages || [];\n\n  return (\n    <div className=\"dgm-overlay\">\n      <div className=\"dgm-dialog\">\n        {/* Header */}\n        <div className=\"dgm-header\">\n          <div>\n            <h2 className=\"dgm-title\">Generate World Dynamics</h2>\n            <p className=\"dgm-subtitle\">\n              Multi-turn conversation with the LLM to synthesize dynamics from lore\n            </p>\n          </div>\n          <div className=\"dgm-header-actions\">\n            {run.totalActualCost > 0 && (\n              <span className=\"dgm-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary dgm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content area: messages + proposed dynamics */}\n        <div className=\"dgm-content\">\n          {displayMessages.map((msg, i) => (\n            <MessageBubble key={i} message={msg} />\n          ))}\n\n          {isGenerating && <div className=\"dgm-generating\">Generating...</div>}\n\n          {isFailed && <div className=\"dgm-failed\">{run.error || \"Generation failed\"}</div>}\n\n          {/* Proposed dynamics inside scrollable area */}\n          {isReviewable && run.proposedDynamics && (\n            <ProposedDynamicsList dynamics={run.proposedDynamics} />\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Footer: feedback input + actions (always visible) */}\n        <div className=\"dgm-footer\">\n          {/* Feedback input */}\n          {(isReviewable || isFailed) && (\n            <div className=\"dgm-feedback-row\">\n              <textarea\n                value={feedback}\n                onChange={(e) => setFeedback(e.target.value)}\n                onKeyDown={handleKeyDown}\n                placeholder={\n                  isFailed\n                    ? \"Provide feedback and retry...\"\n                    : 'Steer the dynamics (e.g., \"focus more on trade conflicts\", \"add era-specific tensions\")...'\n                }\n                className=\"illuminator-input dgm-feedback-input\"\n              />\n            </div>\n          )}\n\n          {/* Action buttons */}\n          <div className=\"dgm-actions\">\n            {(isReviewable || isFailed) && (\n              <button\n                onClick={handleSubmitFeedback}\n                disabled={!feedback.trim()}\n                className=\"illuminator-button illuminator-button-secondary dgm-action-btn\"\n              >\n                {isFailed ? \"Retry with Feedback\" : \"Refine\"}\n              </button>\n            )}\n            {isReviewable && (\n              <button\n                onClick={onAccept}\n                className=\"illuminator-button illuminator-button-primary dgm-action-btn\"\n              >\n                Accept Dynamics ({run.proposedDynamics?.length || 0})\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}", "type": "{ run: any; isActive: any; onSubmitFeedback: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx", "sourceCode": "export default function EnrichmentQueue({\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}) {\n  const [selectedTasks, setSelectedTasks] = useState(new Set());\n  const [expandedEntities, setExpandedEntities] = useState(new Set());\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterProminence, setFilterProminence] = useState(\"all\");\n  const [filterStatus, setFilterStatus] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    if (prominenceScale) return prominenceScale;\n    const values = tasks\n      .map((task) => task.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [prominenceScale, tasks]);\n\n  // Group tasks by entity\n  const groupedTasks = useMemo(() => {\n    const groups = new Map();\n\n    for (const task of tasks) {\n      if (!groups.has(task.entityId)) {\n        groups.set(task.entityId, {\n          entityId: task.entityId,\n          entityName: task.entityName,\n          entityKind: task.entityKind,\n          entitySubtype: task.entitySubtype,\n          prominence: task.prominence,\n          tasks: [],\n        });\n      }\n      groups.get(task.entityId).tasks.push(task);\n    }\n\n    return Array.from(groups.values());\n  }, [tasks]);\n\n  // Apply filters\n  const filteredGroups = useMemo(() => {\n    return groupedTasks.filter((group) => {\n      if (filterKind !== \"all\" && group.entityKind !== filterKind) return false;\n      if (filterProminence !== \"all\") {\n        // Filter to entities with at least the selected prominence level\n        const entityProminence = typeof group.prominence === \"number\" ? group.prominence : 0;\n        const filterThreshold = prominenceThresholdFromScale(\n          filterProminence,\n          effectiveProminenceScale\n        );\n        if (entityProminence < filterThreshold) return false;\n      }\n      if (filterStatus !== \"all\") {\n        const hasMatchingTask = group.tasks.some((t) => t.status === filterStatus);\n        if (!hasMatchingTask) return false;\n      }\n      return true;\n    });\n  }, [groupedTasks, filterKind, filterProminence, filterStatus, effectiveProminenceScale]);\n\n  // Get unique entity kinds\n  const entityKinds = useMemo(() => {\n    const kinds = new Set(tasks.map((t) => t.entityKind));\n    return Array.from(kinds);\n  }, [tasks]);\n\n  const toggleTask = (taskId) => {\n    setSelectedTasks((prev) => {\n      const next = new Set(prev);\n      if (next.has(taskId)) {\n        next.delete(taskId);\n      } else {\n        next.add(taskId);\n      }\n      return next;\n    });\n  };\n\n  const toggleEntity = (entityId) => {\n    setExpandedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const runSelected = () => {\n    onRunTasks(Array.from(selectedTasks));\n  };\n\n  const totalPending = tasks.filter((t) => t.status === \"pending\").length;\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Queue</h2>\n          <div className=\"eq-header-actions\">\n            <button\n              onClick={onRunAll}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys || totalPending === 0}\n            >\n              Run All ({totalPending})\n            </button>\n          </div>\n        </div>\n\n        {!hasRequiredKeys && (\n          <div className=\"eq-api-warning\">Set API keys in the sidebar to run enrichment tasks</div>\n        )}\n\n        {/* Filters */}\n        <div className=\"eq-filters\">\n          <div>\n            <label htmlFor=\"entity-kind\" className=\"eq-filter-label\">Entity Kind</label>\n            <select id=\"entity-kind\"\n              value={filterKind}\n              onChange={(e) => setFilterKind(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {entityKinds.map((kind) => (\n                <option key={kind} value={kind}>\n                  {kind}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"prominence\" className=\"eq-filter-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={filterProminence}\n              onChange={(e) => setFilterProminence(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {PROMINENCE_LEVELS.map((level) => (\n                <option key={level} value={level}>\n                  {level}+\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"status\" className=\"eq-filter-label\">Status</label>\n            <select id=\"status\"\n              value={filterStatus}\n              onChange={(e) => setFilterStatus(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              <option value=\"pending\">Pending</option>\n              <option value=\"complete\">Complete</option>\n              <option value=\"error\">Error</option>\n            </select>\n          </div>\n\n          <div className=\"eq-filter-summary\">\n            <span className=\"eq-filter-summary-text\">\n              {filteredGroups.length} entities, {tasks.length} tasks\n            </span>\n          </div>\n        </div>\n\n        {/* Task groups */}\n        <div>\n          {filteredGroups.map((group) => (\n            <EntityTaskGroup\n              key={group.entityId}\n              {...group}\n              selectedTasks={selectedTasks}\n              onToggleTask={toggleTask}\n              onRunTask={(taskId) => onRunTasks([taskId])}\n              expanded={expandedEntities.has(group.entityId)}\n              onToggleExpand={() => toggleEntity(group.entityId)}\n              prominenceScale={effectiveProminenceScale}\n            />\n          ))}\n\n          {filteredGroups.length === 0 && (\n            <div className=\"eq-empty\">No tasks match current filters</div>\n          )}\n        </div>\n      </div>\n\n      {/* Selection actions */}\n      {selectedTasks.size > 0 && (\n        <div className=\"eq-selection-bar\">\n          <span className=\"eq-selection-count\">\n            {selectedTasks.size} task{selectedTasks.size !== 1 ? \"s\" : \"\"} selected\n          </span>\n          <div className=\"eq-selection-actions\">\n            <button\n              onClick={() => setSelectedTasks(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button\n              onClick={runSelected}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys}\n            >\n              Run Selected\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}", "type": "{ tasks: any; onRunTasks: any; onRunAll: any; worldSchema: any; hasRequiredKeys: any; prominenceScale: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityBrowser.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityBrowser.jsx", "sourceCode": "export default function EntityBrowser({\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}) {\n  const navEntities = useEntityNavList();\n  const { handleAssignImage, handleDeleteEntity } = useEntityCrud();\n  const { historianConfigured } = useHistorianActions();\n  const { openCreateEntity, openEditEntity, openImageSettings } =\n    useIlluminatorModals();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [searchOpen, setSearchOpen] = useState(false);\n  const [searchText, setSearchText] = useState(false);\n  const searchInputRef = useRef(null);\n  const [filters, setFilters] = useState({\n    kind: \"all\",\n    prominence: \"all\",\n    status: \"all\",\n    culture: \"all\",\n    chronicleImage: \"all\",\n  });\n  const prominenceScale = useProminenceScale();\n  const [hideCompleted, setHideCompleted] = useState(false);\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [imagePickerEntity, setImagePickerEntity] = useState(null);\n  const [showMotifWeaver, setShowMotifWeaver] = useState(false);\n  // Get unique values for filters\n  const filterOptions = useMemo(() => {\n    const kinds = new Set();\n    const cultures = new Set();\n\n    for (const entity of navEntities) {\n      kinds.add(entity.kind);\n      if (entity.culture) cultures.add(entity.culture);\n    }\n\n    return {\n      kinds: Array.from(kinds).sort(),\n      cultures: Array.from(cultures).sort(),\n    };\n  }, [navEntities]);\n\n  // Entity search \u2014 partial match on name, aliases, and optionally summary text\n  const searchResults = useMemo(() => {\n    const q = searchQuery.trim().toLowerCase();\n    if (!q || q.length < 2) return [];\n    const results = [];\n    for (const entity of navEntities) {\n      const matches = [];\n      // Name match\n      const nameIdx = entity.name.toLowerCase().indexOf(q);\n      if (nameIdx !== -1) {\n        matches.push({ field: \"name\", value: entity.name, matchIndex: nameIdx });\n      }\n      // Alias matches\n      for (const alias of entity.aliases) {\n        if (typeof alias !== \"string\") continue;\n        const aliasIdx = alias.toLowerCase().indexOf(q);\n        if (aliasIdx !== -1) {\n          matches.push({ field: \"alias\", value: alias, matchIndex: aliasIdx });\n        }\n      }\n      // Slug alias matches\n      for (const slug of entity.slugAliases) {\n        if (typeof slug !== \"string\") continue;\n        const slugIdx = slug.toLowerCase().indexOf(q);\n        if (slugIdx !== -1) {\n          matches.push({ field: \"slug alias\", value: slug, matchIndex: slugIdx });\n        }\n      }\n      // Summary text matches (only when searchText enabled)\n      if (searchText && entity.summary) {\n        const sumIdx = entity.summary.toLowerCase().indexOf(q);\n        if (sumIdx !== -1) {\n          matches.push({ field: \"summary\", value: entity.summary, matchIndex: sumIdx });\n        }\n      }\n      if (matches.length > 0) {\n        results.push({ entity, matches });\n      }\n    }\n    // Sort: name matches first, then by name alphabetically\n    results.sort((a, b) => {\n      const aHasName = a.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      const bHasName = b.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      if (aHasName !== bHasName) return aHasName - bHasName;\n      return a.entity.name.localeCompare(b.entity.name);\n    });\n    return results;\n  }, [navEntities, searchQuery, searchText]);\n\n  const handleSearchSelect = useCallback((entityId) => {\n    setSelectedEntityId(entityId);\n    setSearchOpen(false);\n    setSearchQuery(\"\");\n  }, []);\n\n  // Get enrichment status for a nav item\n  const getStatus = useCallback(\n    (nav, type) => {\n      // Check queue first\n      const queueItem = queue.find((item) => item.entityId === nav.id && item.type === type);\n      if (queueItem) {\n        return queueItem.status;\n      }\n\n      // Check nav item flags\n      if (type === \"description\" && nav.hasDescription) return \"complete\";\n      if (type === \"visualThesis\" && nav.hasVisualThesis) return \"complete\";\n      if (type === \"image\" && nav.imageId) return \"complete\";\n\n      return \"missing\";\n    },\n    [queue]\n  );\n\n  // Filter entities via nav items\n  const filteredNavItems = useMemo(() => {\n    return navEntities.filter((nav) => {\n      if (filters.kind !== \"all\" && nav.kind !== filters.kind) return false;\n      if (\n        filters.prominence !== \"all\" &&\n        prominenceLabelFromScale(nav.prominence, prominenceScale) !== filters.prominence\n      ) {\n        return false;\n      }\n      if (filters.culture !== \"all\" && nav.culture !== filters.culture) return false;\n\n      const descStatus = getStatus(nav, \"description\");\n      const imgStatus = getStatus(nav, \"image\");\n\n      // Hide completed filter\n      if (hideCompleted && descStatus === \"complete\" && imgStatus === \"complete\") {\n        return false;\n      }\n\n      if (filters.status !== \"all\") {\n        if (filters.status === \"missing\" && descStatus !== \"missing\" && imgStatus !== \"missing\") {\n          return false;\n        }\n        if (filters.status === \"complete\" && descStatus !== \"complete\") {\n          return false;\n        }\n        if (filters.status === \"queued\" && descStatus !== \"queued\" && imgStatus !== \"queued\") {\n          return false;\n        }\n        if (filters.status === \"running\" && descStatus !== \"running\" && imgStatus !== \"running\") {\n          return false;\n        }\n        if (filters.status === \"error\" && descStatus !== \"error\" && imgStatus !== \"error\") {\n          return false;\n        }\n      }\n\n      // Chronicle image filter\n      if (filters.chronicleImage !== \"all\") {\n        if (filters.chronicleImage === \"none\" && nav.backrefCount > 0) return false;\n        if (filters.chronicleImage === \"unconfigured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount === 0) return false;\n        }\n        if (filters.chronicleImage === \"configured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount > 0) return false;\n        }\n      }\n\n      return true;\n    });\n  }, [navEntities, filters, hideCompleted, getStatus, prominenceScale]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((entityId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredNavItems.map((e) => e.id)));\n  }, [filteredNavItems]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  // Queue single item \u2014 load full entity from store for prompt building\n  const queueItem = useCallback(\n    async (entityId, type) => {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity) return;\n      const prompt = buildPrompt(entity, type === \"visualThesis\" ? \"description\" : type);\n      const visualConfig =\n        (type === \"description\" || type === \"visualThesis\") && getVisualConfig\n          ? getVisualConfig(entity)\n          : {};\n      const imageOverrides =\n        type === \"image\"\n          ? { imageSize: imageGenSettings.imageSize, imageQuality: imageGenSettings.imageQuality }\n          : {};\n      getEnqueue()([{ entity, type, prompt, ...visualConfig, ...imageOverrides }]);\n    },\n    [buildPrompt, getVisualConfig, imageGenSettings.imageSize, imageGenSettings.imageQuality]\n  );\n\n  // Cancel single item\n  const cancelItem = useCallback(\n    (entityId, type) => {\n      const queueItem = queue.find((item) => item.entityId === entityId && item.type === type);\n      if (queueItem) {\n        getCancel()(queueItem.id);\n      }\n    },\n    [queue]\n  );\n\n  // Queue all missing descriptions for selected \u2014 filter on nav items, load full for prompt\n  const queueSelectedDescriptions = useCallback(async () => {\n    const missingIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (nav && getStatus(nav, \"description\") === \"missing\") {\n        missingIds.push(entityId);\n      }\n    }\n    if (missingIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(missingIds);\n    const items = fullEntities.map((entity) => {\n      const visualConfig = getVisualConfig ? getVisualConfig(entity) : {};\n      return {\n        entity,\n        type: \"description\",\n        prompt: buildPrompt(entity, \"description\"),\n        ...visualConfig,\n      };\n    });\n    if (items.length > 0) getEnqueue()(items);\n  }, [selectedIds, navEntities, getStatus, buildPrompt, getVisualConfig]);\n\n  // Queue all missing images for selected\n  const queueSelectedImages = useCallback(async () => {\n    const eligibleIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (\n        nav &&\n        prominenceAtLeast(nav.prominence, config.minProminenceForImage, prominenceScale) &&\n        getStatus(nav, \"image\") === \"missing\" &&\n        (!config.requireDescription || nav.hasDescription)\n      ) {\n        eligibleIds.push(entityId);\n      }\n    }\n    if (eligibleIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(eligibleIds);\n    const items = fullEntities.map((entity) => ({\n      entity,\n      type: \"image\",\n      prompt: buildPrompt(entity, \"image\"),\n      imageSize: imageGenSettings.imageSize,\n      imageQuality: imageGenSettings.imageQuality,\n    }));\n    if (items.length > 0) getEnqueue()(items);\n  }, [\n    selectedIds,\n    navEntities,\n    getStatus,\n    buildPrompt,\n    config.minProminenceForImage,\n    config.requireDescription,\n    imageGenSettings.imageSize,\n    imageGenSettings.imageQuality,\n    prominenceScale,\n  ]);\n\n  // Regenerate all descriptions for selected\n  const regenSelectedDescriptions = useCallback(async () => {\n    const completeIds = [];\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}", "type": "{ worldSchema: any; config: any; onConfigChange: any; buildPrompt: any; getVisualConfig: any; styleLibrary: any; imageGenSettings: any; onStartRevision: any; isRevising: any; onBulkHistorianReview: any; onBulkHistorianEdition: any; onBulkHistorianClear: any; isBulkHistorianActive: any; onNavigateToTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx", "sourceCode": "export default function EntityCoveragePanel({\n  simulationRunId\n}) {\n  // Events and relationships are always in memory (simple store pattern, no nav/detail split)\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n\n  // Full entity + chronicle data loaded on demand when user clicks \"Calculate\"\n  const [analysisData, setAnalysisData] = useState(null);\n  const [calculating, setCalculating] = useState(false);\n  const [expandedSections, setExpandedSections] = useState(new Set());\n\n  // Reset when simulation run changes\n  useEffect(() => {\n    setAnalysisData(null);\n  }, [simulationRunId]);\n  const handleCalculate = useCallback(async () => {\n    if (!simulationRunId) return;\n    setCalculating(true);\n    try {\n      const [fullEntities, chronicles] = await Promise.all([getEntitiesForRun(simulationRunId), getChroniclesForSimulation(simulationRunId)]);\n      const safeEvents = narrativeEvents || [];\n      const safeRelationships = relationships || [];\n      const analysis = computeCoreAnalysis(fullEntities, chronicles, safeEvents, safeRelationships);\n      setAnalysisData({\n        fullEntities,\n        chronicles,\n        analysis,\n        events: safeEvents,\n        relationships: safeRelationships\n      });\n    } catch (err) {\n      console.error(\"[EntityCoverage] Failed to calculate:\", err);\n    } finally {\n      setCalculating(false);\n    }\n  }, [simulationRunId, narrativeEvents, relationships]);\n  const toggleSection = useCallback(sectionId => {\n    setExpandedSections(prev => {\n      const next = new Set(prev);\n      if (next.has(sectionId)) next.delete(sectionId);else next.add(sectionId);\n      return next;\n    });\n  }, []);\n  if (!simulationRunId) return null;\n\n  // Before calculation \u2014 show button\n  if (!analysisData) {\n    return <div className=\"ecp-pre-calc\">\n        <div className=\"illuminator-card\">\n          <div className=\"ecp-pre-calc-inner\">\n            <div className=\"ecp-pre-calc-header\">\n              <span className=\"ecp-pre-calc-title\">Entity Coverage Analysis</span>\n            </div>\n            <p className=\"ecp-pre-calc-desc\">\n              Analyzes coverage gaps across entities, chronicles, events, and relationships. Loads\n              full entity data on demand.\n            </p>\n            <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-btn-pad-sm\">\n              {calculating ? \"Calculating...\" : \"Calculate Statistics\"}\n            </button>\n          </div>\n        </div>\n      </div>;\n  }\n  const {\n    fullEntities,\n    analysis,\n    events: safeEvents,\n    relationships: safeRelationships\n  } = analysisData;\n\n  // Compute underutil counts for collapsed section headers\n  const sectionUnderutilCounts = {};\n  for (const sectionId of SECTION_IDS) {\n    if (!expandedSections.has(sectionId)) {\n      switch (sectionId) {\n        case \"suggestions\":\n          sectionUnderutilCounts[sectionId] = (() => {\n            const groupsWithUncovered = new Set();\n            for (const e of safeEvents) {\n              if ((analysis.eventCoverage.get(e.id) ?? 0) <= 0) {\n                groupsWithUncovered.add(eventGroupKey(e));\n              }\n            }\n            return groupsWithUncovered.size;\n          })();\n          break;\n        case \"backrefs\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            const expected = expectedForProminence(e.prominence);\n            if (expected === 0) return false;\n            const count = e.enrichment?.chronicleBackrefs?.length ?? 0;\n            return count / expected < 1;\n          }).length;\n          break;\n        case \"history\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            return (e.enrichment?.chronicleBackrefs?.length ?? 0) > 0 && (e.enrichment?.descriptionHistory?.length ?? 0) === 0;\n          }).length;\n          break;\n        case \"culture\":\n          sectionUnderutilCounts[sectionId] = [...(analysis.cultureEntities?.entries() || [])].filter(([, data]) => {\n            if (data.count < 3) return false;\n            let appeared = 0;\n            for (const id of data.entityIds) {\n              if (analysis.entityUsage.has(id)) appeared++;\n            }\n            return appeared / data.count < 0.3;\n          }).length;\n          break;\n        case \"events\":\n          sectionUnderutilCounts[sectionId] = safeEvents.filter(e => {\n            return e.significance >= 0.7 && (e.participantEffects?.length ?? 0) >= 3 && (analysis.eventCoverage.get(e.id) ?? 0) <= 0;\n          }).length;\n          break;\n        case \"potential\":\n          sectionUnderutilCounts[sectionId] = null; // expensive, skip for collapsed\n          break;\n        case \"eras\":\n          {\n            const allEraIds = new Set([...analysis.eraChronicles.keys(), ...analysis.eraEntityCounts.keys(), ...analysis.eraEventCounts.keys()]);\n            sectionUnderutilCounts[sectionId] = [...allEraIds].filter(eraId => {\n              return (analysis.eraChronicles.get(eraId)?.total ?? 0) <= 0 && ((analysis.eraEntityCounts.get(eraId) || 0) > 0 || (analysis.eraEventCounts.get(eraId) || 0) > 0);\n            }).length;\n            break;\n          }\n        case \"integration\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            if ((Number(e.prominence) || 0) < 2) return false;\n            let gaps = 0;\n            if (!e.description) gaps++;\n            if ((e.enrichment?.chronicleBackrefs?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.descriptionHistory?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.historianNotes?.length ?? 0) <= 0) gaps++;\n            if (!e.enrichment?.image?.imageId) gaps++;\n            return gaps >= 3;\n          }).length;\n          break;\n      }\n    }\n  }\n  const sectionProps = {\n    suggestions: {\n      Component: SuggestionsSection,\n      props: {\n        events: safeEvents,\n        entities: fullEntities,\n        eventCoverage: analysis.eventCoverage,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    backrefs: {\n      Component: BackrefsSection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    history: {\n      Component: HistorySection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    culture: {\n      Component: CultureSection,\n      props: {\n        entities: fullEntities,\n        cultureRoles: analysis.cultureRoles,\n        cultureEntities: analysis.cultureEntities,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    events: {\n      Component: EventsSection,\n      props: {\n        events: safeEvents,\n        eventCoverage: analysis.eventCoverage\n      }\n    },\n    potential: {\n      Component: PotentialSection,\n      props: {\n        entities: fullEntities,\n        narrativeEvents: safeEvents,\n        relationships: safeRelationships,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    eras: {\n      Component: ErasSection,\n      props: {\n        entities: fullEntities,\n        events: safeEvents,\n        eraChronicles: analysis.eraChronicles,\n        eraEntityCounts: analysis.eraEntityCounts,\n        eraEventCounts: analysis.eraEventCounts\n      }\n    },\n    integration: {\n      Component: IntegrationSection,\n      props: {\n        entities: fullEntities,\n        entityBackportedCount: analysis.entityBackportedCount\n      }\n    }\n  };\n  return <div className=\"ecp-wrapper\">\n      <div className=\"illuminator-card ecp-header-card\">\n        <div className=\"ecp-header-bar\">\n          <span className=\"ecp-header-title\">Entity Coverage Analysis</span>\n          <span className=\"ecp-header-stats\">\n            {analysis.nonEraEntities.length} entities, {analysis.activeChronicles.length}{\" \"}\n            chronicles, {safeEvents.length} events\n          </span>\n          <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-recalc-btn\" title=\"Reload data from database and recalculate all statistics\">\n            {calculating ? \"Recalculating...\" : \"Recalculate\"}\n          </button>\n        </div>\n      </div>\n\n      <div className=\"ec-grid\">\n        {SECTION_IDS.map(sectionId => {\n        const isExpanded = expandedSections.has(sectionId);\n        const underutil = sectionUnderutilCounts[sectionId];\n        const {\n          Component,\n          props\n        } = sectionProps[sectionId];\n        return <div key={sectionId} className=\"illuminator-card ec-grid-cell\">\n              <SectionHeader sectionId={sectionId} expanded={isExpanded} onToggle={() => toggleSection(sectionId)} label={SECTION_LABELS[sectionId]} description={SECTION_DESCRIPTIONS[sectionId]} underutilCount={underutil} />\n              {isExpanded && <Component {...props} expanded={true} />}\n            </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  simulationRunId\n}", "type": "{ simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityDetailView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityDetailView.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// EntityDetailView\n// ---------------------------------------------------------------------------\n\nexport default function EntityDetailView({ entity, entities, onBack }: Readonly<EntityDetailViewProps>) {\n  const prominenceScale = useProminenceScale();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const {\n    handleUpdateBackrefs,\n    handleUndoDescription,\n    handleUpdateAliases,\n    handleUpdateDescription,\n    handleUpdateSummary,\n    handleClearNotes,\n    handleRestoreDescription,\n  } = useEntityCrud();\n  const {\n    historianConfigured,\n    isHistorianEditionActive,\n    isHistorianActive,\n    handleHistorianEdition,\n    handleHistorianReview,\n    handleUpdateHistorianNote,\n    editionPreview,\n    handleEditionPreviewProceed,\n    handleEditionPreviewCancel,\n  } = useHistorianActions();\n  const { openRename, openPatchEvents } = useIlluminatorModals();\n\n  const enrichment = entity.enrichment;\n  const textEnrichment = enrichment?.text;\n\n  // Inline editing state\n  const [editingSummary, setEditingSummary] = useState(false);\n  const [summaryDraft, setSummaryDraft] = useState(\"\");\n  const [editingDescription, setEditingDescription] = useState(false);\n  const [descriptionDraft, setDescriptionDraft] = useState(\"\");\n\n  const startEditSummary = useCallback(() => {\n    setSummaryDraft(entity.summary || \"\");\n    setEditingSummary(true);\n  }, [entity.summary]);\n\n  const saveSummary = useCallback(() => {\n    const trimmed = summaryDraft.trim();\n    if (trimmed && trimmed !== entity.summary) {\n      void handleUpdateSummary(entity.id, trimmed);\n    }\n    setEditingSummary(false);\n  }, [handleUpdateSummary, summaryDraft, entity.summary, entity.id]);\n\n  const cancelSummary = useCallback(() => {\n    setEditingSummary(false);\n    setSummaryDraft(\"\");\n  }, []);\n\n  const startEditDescription = useCallback(() => {\n    setDescriptionDraft(entity.description || \"\");\n    setEditingDescription(true);\n  }, [entity.description]);\n\n  const saveDescription = useCallback(() => {\n    const trimmed = descriptionDraft.trim();\n    if (trimmed && trimmed !== entity.description) {\n      void handleUpdateDescription(entity.id, trimmed);\n    }\n    setEditingDescription(false);\n  }, [handleUpdateDescription, descriptionDraft, entity.description, entity.id]);\n\n  const cancelDescription = useCallback(() => {\n    setEditingDescription(false);\n    setDescriptionDraft(\"\");\n  }, []);\n\n  // Chain debug (narrative -> thesis -> traits)\n  const chainDebug: DescriptionChainDebug | undefined = textEnrichment?.chainDebug;\n\n  // Legacy single debug\n  let legacyDebug: NetworkDebugInfo | undefined = textEnrichment?.debug;\n  if (!legacyDebug && !chainDebug) {\n    const descriptionQueueItem = queue.find(\n      (item) => item.entityId === entity.id && item.type === \"description\" && item.debug\n    );\n    legacyDebug = descriptionQueueItem?.debug;\n  }\n\n  // Escape key goes back (unless editing inline)\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === \"Escape\" && !editingSummary && !editingDescription) onBack();\n    },\n    [onBack, editingSummary, editingDescription]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Description history\n  const historyLen = enrichment?.descriptionHistory?.length || 0;\n  const lastEntry = historyLen > 0 ? enrichment.descriptionHistory[historyLen - 1] : null;\n\n  return (\n    <>\n      <div className=\"edv\">\n        {/* Header bar */}\n        <div className=\"edv-header\">\n          <button onClick={onBack} className=\"edv-back-btn\">\n            \u2190 Back\n          </button>\n          <div className=\"edv-header-info\">\n            <div className=\"edv-entity-name\">{entity.name}</div>\n            <div className=\"edv-entity-meta\">\n              {entity.kind}/{entity.subtype} \u00b7{\" \"}\n              {prominenceLabelFromScale(entity.prominence, prominenceScale)}\n              {entity.culture && ` \u00b7 ${entity.culture}`}\n            </div>\n          </div>\n          <div className=\"edv-esc-hint\">Esc to go back</div>\n        </div>\n\n        {/* Two-column body */}\n        <div className=\"edv-body\">\n          {/* Main content */}\n          <div className=\"edv-main\">\n            {/* Summary */}\n            {(entity.summary || handleUpdateSummary) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label\">\n                  Summary\n                  {handleUpdateSummary && !editingSummary && (\n                    <button\n                      onClick={startEditSummary}\n                      title=\"Edit summary\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                </div>\n                {editingSummary ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={summaryDraft}\n                    onChange={(e) => setSummaryDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveSummary();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelSummary();\n                      }\n                    }}\n                    onBlur={saveSummary}\n                    className=\"edv-summary-textarea\"\n                  />\n                ) : (\n                  <p className=\"edv-summary-text\">\n                    {entity.summary || <span className=\"edv-placeholder\">No summary</span>}\n                  </p>\n                )}\n              </div>\n            )}\n\n            {/* Visual Thesis */}\n            {textEnrichment?.visualThesis && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-visual-thesis\">\n                  Visual Thesis\n                </div>\n                <p className=\"edv-visual-thesis\">{textEnrichment.visualThesis}</p>\n              </div>\n            )}\n\n            {/* Full Description */}\n            {(entity.description || handleUpdateDescription) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-wrap\">\n                  Full Description\n                  {historyLen > 0 && (\n                    <span className=\"edv-version-hint\">\n                      v{historyLen + 1} ({historyLen} previous)\n                    </span>\n                  )}\n                  {historyLen > 0 && handleUndoDescription && (\n                    <button\n                      onClick={() => void handleUndoDescription(entity.id)}\n                      title={`Revert to previous version (from ${lastEntry?.source || \"unknown\"}, ${lastEntry?.replacedAt ? new Date(lastEntry.replacedAt).toLocaleDateString() : \"unknown\"})`}\n                      className=\"edv-inline-btn\"\n                    >\n                      \u21a9 Undo\n                    </button>\n                  )}\n                  {handleUpdateDescription && !editingDescription && (\n                    <button\n                      onClick={startEditDescription}\n                      title=\"Edit description\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                  <button\n                    onClick={() => openRename(entity.id)}\n                    title=\"Rename this entity with full propagation across all references\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Rename\n                  </button>\n                  <button\n                    onClick={() => openPatchEvents(entity.id)}\n                    title=\"Repair stale names in narrative event history for this entity\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Patch Events\n                  </button>\n                </div>\n                {historianConfigured && (\n                  <>\n                    <div className=\"edv-section-label\">\n                      Historian\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone)}\n                        disabled={isHistorianEditionActive}\n                        label=\"Copy Edit\"\n                        hasNotes={false}\n                      />\n                      {enrichment?.descriptionHistory?.some(\n                        (h: { source?: string }) => h.source === \"historian-edition\"\n                      ) && (\n                        <HistorianToneSelector\n                          onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone, true)}\n                          disabled={isHistorianEditionActive}\n                          label=\"Re-Edit\"\n                          hasNotes={false}\n                        />\n                      )}\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianReview(entity.id, tone)}\n                        disabled={isHistorianActive}\n                        label=\"Annotate\"\n                        hasNotes={\n                          enrichment?.historianNotes && enrichment.historianNotes.length > 0\n                        }\n                      />\n                      {handleClearNotes &&\n                        enrichment?.historianNotes &&\n                        enrichment.historianNotes.length > 0 && (\n                          <button\n                            onClick={() => void handleClearNotes(entity.id)}\n                            title=\"Remove all annotations from this entity\"\n                            className=\"edv-inline-btn-ghost\"\n                          >\n                            Clear Notes\n                          </button>\n                        )}\n                    </div>\n                    {enrichment?.descriptionHistory?.some(\n                      (h: { source?: string }) =>\n                        h.source === \"historian-edition\" || h.source === \"legacy-copy-edit\"\n                    ) &&\n                      entity.description && (\n                        <HistorianEditionComparison\n                          entityId={entity.id}\n                          currentDescription={entity.description}\n                          descriptionHistory={enrichment.descriptionHistory}\n                          historianNotes={enrichment.historianNotes}\n                          onRestoreVersion={(entityId, historyIndex) => void handleRestoreDescription(entityId, historyIndex)}\n                        />\n                      )}\n                  </>\n                )}\n                {editingDescription ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={descriptionDraft}\n                    onChange={(e) => setDescriptionDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveDescription();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelDescription();\n                      }\n                    }}\n                    onBlur={saveDescription}\n                    className=\"edv-desc-textarea\"\n                  />\n                ) : (\n                  <>\n                    {entity.description ? (\n                      <div className=\"edv-description entity-description-md\">\n                        <ReactMarkdown\n// ... (truncated)", "parameters": [{"name": "{ entity, entities, onBack }", "type": "Readonly<EntityDetailViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx", "sourceCode": "export default function EntityGuidanceEditor({\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}) {\n  const entities = useEntityNavList();\n  const entityNavItems = useEntityNavItems();\n  const [selectedType, setSelectedType] = useState(\"description\");\n  const [selectedKind, setSelectedKind] = useState(\"npc\");\n  const [selectedEntityId, setSelectedEntityId] = useState(\"\");\n  const [showVisualSteps, setShowVisualSteps] = useState(false);\n  const [selectedFullEntity, setSelectedFullEntity] = useState(null);\n\n  // Use external entity guidance or default\n  const entityGuidance = useMemo(\n    () => externalEntityGuidance || createDefaultEntityGuidance(),\n    [externalEntityGuidance]\n  );\n\n  // Empty culture identities for preview (editing happens in VisualIdentityPanel)\n  const cultureIdentities = useMemo(() => createDefaultCultureIdentities(), []);\n\n  // Get entity kinds from schema\n  const entityKinds = useMemo(() => {\n    return worldSchema?.entityKinds || [];\n  }, [worldSchema]);\n\n  // Auto-select first kind if none selected\n  useMemo(() => {\n    if (!selectedKind && entityKinds.length > 0) {\n      setSelectedKind(entityKinds[0].kind);\n    }\n  }, [selectedKind, entityKinds]);\n\n  const prominenceScale = useProminenceScale();\n  const notableThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"recognized\", prominenceScale),\n    [prominenceScale]\n  );\n  const renownedThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"renowned\", prominenceScale),\n    [prominenceScale]\n  );\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominentByCulture = useMemo(() => {\n    const map = new Map();\n    for (const entity of entities) {\n      if (!entity.culture) continue;\n      if (entity.prominence < notableThreshold) continue;\n      const entry = { id: entity.id, name: entity.name };\n      const existing = map.get(entity.culture);\n      if (existing) {\n        existing.push(entry);\n      } else {\n        map.set(entity.culture, [entry]);\n      }\n    }\n    return map;\n  }, [entities, notableThreshold]);\n\n  // Get example entities for preview, filtered by selected kind\n  const exampleEntities = useMemo(() => {\n    if (!entities || entities.length === 0) return [];\n    return entities.filter((e) => e.kind === selectedKind).slice(0, 10);\n  }, [entities, selectedKind]);\n\n  const selectedNavEntity = useMemo(() => {\n    if (!selectedEntityId) return exampleEntities[0] || null;\n    return entities.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, entities, exampleEntities]);\n\n  // Load full entity for preview (needs description, tags, visualThesis, etc.)\n  useEffect(() => {\n    const entityId = selectedNavEntity?.id;\n    if (entityId) {\n      useEntityStore.getState().loadEntity(entityId).then(setSelectedFullEntity);\n    } else {\n      setSelectedFullEntity(null);\n    }\n  }, [selectedNavEntity?.id]);\n\n  // Use full entity for context building, fall back to nav entity for display\n  const selectedEntity = selectedFullEntity || selectedNavEntity;\n\n  const selectedRelationships = useMemo(() => {\n    if (!selectedEntity) return [];\n    return resolveRelationships(selectedEntity, entityNavItems, relationshipsByEntity);\n  }, [selectedEntity, entityNavItems, relationshipsByEntity]);\n\n  // Get current guidance for selected kind\n  const currentGuidance = useMemo(() => {\n    return entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n  }, [entityGuidance, selectedKind]);\n\n  // Build live preview\n  const preview = useMemo(() => {\n    // Derive flat values from structured fields for entity description prompts\n    const wc = {\n      name: worldContext?.name || \"[World Name]\",\n      description: worldContext?.description || \"[World description not set]\",\n      toneFragments: worldContext?.toneFragments || { core: \"\" },\n      canonFactsWithMetadata: worldContext?.canonFactsWithMetadata || [],\n    };\n\n    const entityContext = buildEntityContext(\n      selectedEntity,\n      prominentByCulture,\n      entityNavItems,\n      relationshipsByEntity,\n      simulationMetadata,\n      renownedThreshold\n    );\n\n    if (selectedType === \"description\") {\n      return buildDescriptionPromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext\n      );\n    } else {\n      return buildImagePromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext,\n        {} // No style info for preview\n      );\n    }\n  }, [\n    entityGuidance,\n    cultureIdentities,\n    selectedType,\n    selectedKind,\n    selectedEntity,\n    worldContext,\n    prominentByCulture,\n    entityNavItems,\n    relationshipsByEntity,\n    simulationMetadata,\n    renownedThreshold,\n  ]);\n\n  // Handle guidance changes\n  const handleSectionChange = useCallback(\n    (sectionKey, value) => {\n      if (!onEntityGuidanceChange) return;\n\n      // Get current guidance or create default\n      const currentKindGuidance =\n        entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n\n      // Update the specific field (handles nested paths like 'visualThesis.domain')\n      const updatedKindGuidance = setNestedValue(currentKindGuidance, sectionKey, value);\n\n      // Update the full entity guidance\n      const newEntityGuidance = {\n        ...entityGuidance,\n        [selectedKind]: updatedKindGuidance,\n      };\n\n      onEntityGuidanceChange(newEntityGuidance);\n    },\n    [entityGuidance, selectedKind, onEntityGuidanceChange]\n  );\n\n  // Reset when switching kinds - use entity of that kind for preview\n  const handleKindSelect = useCallback((kind) => {\n    setSelectedKind(kind);\n    setSelectedEntityId(\"\"); // Reset to first entity of new kind\n  }, []);\n\n  return (\n    <div className=\"illuminator-template-editor\">\n      {/* Header Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Entity Guidance</h2>\n          <span className=\"illuminator-card-subtitle\">\n            Configure per-kind instructions for entity descriptions and images\n          </span>\n        </div>\n\n        {/* Task Type Tabs */}\n        <div className=\"illuminator-prompt-tabs\">\n          {TASK_TYPES.map((type) => (\n            <button\n              key={type.id}\n              onClick={() => setSelectedType(type.id)}\n              className={`illuminator-prompt-tab ${selectedType === type.id ? \"active\" : \"\"}`}\n            >\n              <span>{type.icon}</span>\n              <span>{type.label}</span>\n            </button>\n          ))}\n        </div>\n\n        {/* Kind Selector */}\n        {entityKinds.length > 0 && (\n          <div className=\"illuminator-template-kind-section\">\n            <div className=\"illuminator-template-kind-header\">\n              <span className=\"illuminator-label\">Entity Kind</span>\n            </div>\n            <KindSelector\n              kinds={entityKinds}\n              selectedKind={selectedKind}\n              onSelectKind={handleKindSelect}\n            />\n          </div>\n        )}\n      </div>\n\n      {/* Editor Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            {selectedKind} {selectedType === \"description\" ? \"Description\" : \"Image\"} Settings\n          </h2>\n        </div>\n\n        {selectedType === \"description\" ? (\n          // Description editing - Focus + Relationship Guidance + Prose Hint\n          <div className=\"illuminator-template-sections\">\n            {DESCRIPTION_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Info about world tone */}\n            <div className=\"illuminator-template-info-box\">\n              <strong>Note:</strong> The world&apos;s tone and style guidance from the Context tab is\n              automatically included in all description prompts. The Focus field above should\n              contain only entity-specific instructions.\n            </div>\n          </div>\n        ) : (\n          // Image editing\n          <div className=\"illuminator-template-sections\">\n            {IMAGE_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Visual Step Overrides */}\n            <div className=\"illuminator-template-visual-steps\">\n              <button\n                className=\"illuminator-template-visual-steps-toggle\"\n                onClick={() => setShowVisualSteps(!showVisualSteps)}\n              >\n                <span>{showVisualSteps ? \"\\u25BC\" : \"\\u25B6\"}</span>\n                <span>Visual Generation Steps</span>\n                <span className=\"illuminator-template-visual-steps-hint\">\n                  Configure thesis/traits prompts for this kind\n                </span>\n              </button>\n              {showVisualSteps && (\n                <div className=\"illuminator-template-visual-steps-content\">\n                  {VISUAL_STEP_SECTIONS.map((section) => (\n                    <TemplateSection\n                      key={section.key}\n                      section={section}\n                      value={getNestedValue(currentGuidance, section.key)}\n                      onChange={handleSectionChange}\n                    />\n                  ))}\n                  <div className=\"illuminator-template-visual-steps-info\">\n                    These prompts control the 3-step visual generation chain: Description \u2192 Visual\n                    Thesis \u2192 Visual Traits. The thesis provides the primary silhouette feature;\n                    traits add supporting details.\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Live Preview Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Live Preview</h2>\n          {exampleEntities.length > 0 && (\n            <select\n              value={selectedEntityId}\n              onChange={(e) => setSelectedEntityId(e.target.value)}\n              className=\"illuminator-select ege-preview-select\"\n            >\n              <option value=\"\">\n                {exampleEntities[0]?.name || \"Example\"} ({exampleEntities[0]?.subtype})\n              </option>\n// ... (truncated)", "parameters": [{"name": "{\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}", "type": "{ entityGuidance: any; onEntityGuidanceChange: any; worldContext: any; worldSchema: any; simulationMetadata: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx", "sourceCode": "export default function EntityLinkPicker({ onSelect, onClose }) {\n  const entities = useEntityNavList();\n  const [search, setSearch] = useState(\"\");\n\n  const filteredEntities = useMemo(() => {\n    if (!entities?.length) return [];\n\n    const searchLower = search.toLowerCase();\n    return entities\n      .filter((entity) => {\n        if (!search) return true;\n        return (\n          entity.name.toLowerCase().includes(searchLower) ||\n          entity.kind.toLowerCase().includes(searchLower) ||\n          (entity.subtype && entity.subtype.toLowerCase().includes(searchLower))\n        );\n      })\n      .slice(0, 50); // Limit results for performance\n  }, [entities, search]);\n\n  const handleSelect = (entity) => {\n    onSelect(`[[${entity.name}]]`);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Entity Link\" className=\"entity-link-picker-modal\">\n      <input\n        type=\"text\"\n        value={search}\n        onChange={(e) => setSearch(e.target.value)}\n        placeholder=\"Search entities...\"\n        className=\"static-page-search-input\"\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus\n      />\n\n      <div className=\"entity-link-list\">\n        {filteredEntities.length === 0 ? (\n          <div className=\"entity-link-empty\">\n            {search ? \"No entities match your search\" : \"No entities available\"}\n          </div>\n        ) : (\n          filteredEntities.map((entity) => (\n            <button\n              key={entity.id}\n              className=\"entity-link-item\"\n              onClick={() => handleSelect(entity)}\n            >\n              <span className=\"entity-link-name\">{entity.name}</span>\n              <span className=\"entity-link-meta\">\n                {entity.subtype || entity.kind}\n                {entity.culture && ` \u2022 ${entity.culture}`}\n              </span>\n            </button>\n          ))\n        )}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ onSelect, onClose }", "type": "{ onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityRenameModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityRenameModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Main Modal\n// ---------------------------------------------------------------------------\n\nexport default function EntityRenameModal({\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}: Readonly<EntityRenameModalProps>) {\n  const navEntities = useEntityNavList();\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const entity = useMemo(() => navEntities.find((e) => e.id === entityId), [navEntities, entityId]);\n\n  const isPatch = mode === \"patch\";\n\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [addOldNameAsAlias, setAddOldNameAsAlias] = useState(true);\n  // In patch mode: newName = entity.name (current, correct), oldNameInput = user-entered stale name\n  const [newName, setNewName] = useState(isPatch ? entity?.name || \"\" : \"\");\n  const [oldNameInput, setOldNameInput] = useState(\n    isPatch ? entityId.replace(/-/g, \" \").replace(/\\b\\w/g, (c) => c.toUpperCase()) : \"\"\n  );\n  const [scanResult, setScanResult] = useState<RenameScanResult | null>(null);\n  const [decisions, setDecisions] = useState<Map<string, DecisionState>>(new Map());\n  const [expandedSources, setExpandedSources] = useState<Set<string>>(new Set());\n  const [applyProgress, setApplyProgress] = useState(\"\");\n  const [applyResult, setApplyResult] = useState(\"\");\n  const [isRolling, setIsRolling] = useState(false);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [phase]);\n\n  // --- Name rolling ---\n  const handleRollName = useCallback(async () => {\n    if (!entity?.culture) return;\n    const cultureDef = cultures.find((c) => c.id === entity.culture);\n    if (!cultureDef) return;\n    const culture = toCulture(cultureDef);\n    if (!culture) return;\n\n    setIsRolling(true);\n    try {\n      const result = await generate(culture, {\n        kind: entity.kind,\n        subtype: entity.subtype,\n        count: 1,\n        seed: `rename-${Date.now()}`,\n      });\n      if (result.names.length > 0) {\n        setNewName(result.names[0]);\n      }\n    } catch (err) {\n      console.warn(\"[EntityRename] Name generation failed:\", err);\n    } finally {\n      setIsRolling(false);\n    }\n  }, [entity, cultures]);\n\n  // --- Scanning ---\n  const scanOldName = isPatch ? oldNameInput.trim() : entity.name;\n\n  const handleScan = useCallback(async () => {\n    if (isPatch ? !oldNameInput.trim() : !newName.trim()) return;\n    setPhase(\"scanning\");\n\n    console.log(\"[EntityRenameModal] handleScan starting\", {\n      scanOldName,\n      newName,\n      narrativeEventCount: narrativeEvents?.length ?? 0,\n    });\n\n    // Sample a narrative event to check if it has patched or original text\n    if (narrativeEvents && narrativeEvents.length > 0) {\n      const sample = narrativeEvents[0];\n      console.log(\"[EntityRenameModal] Sample narrative event\", {\n        id: sample.id,\n        description: sample.description?.substring(0, 200),\n        action: sample.action?.substring(0, 200),\n        hasSimulationRunId: \"simulationRunId\" in sample,\n      });\n    }\n\n    try {\n      const [chronicles, fullEntities] = await Promise.all([\n        getChroniclesForSimulation(simulationRunId),\n        entityRepo.getEntitiesForRun(simulationRunId),\n      ]);\n      const result = scanForReferences(\n        entityId,\n        scanOldName,\n        fullEntities,\n        chronicles,\n        relationships,\n        narrativeEvents\n      );\n      // Filter out no-op matches where the matched text already equals the new name\n      const effectiveName = isPatch ? entity.name : newName;\n      result.matches = result.matches.filter(\n        (m) => m.matchType === \"id_slug\" || m.matchedText !== effectiveName\n      );\n\n      console.log(\"[EntityRenameModal] Scan result\", {\n        totalMatches: result.matches.length,\n        eventMatches: result.matches.filter((m) => m.sourceType === \"event\").length,\n      });\n      setScanResult(result);\n\n      // Initialize decisions: accept for full+metadata, reject for partial.\n      // id_slug matches are informational only \u2014 no decision needed.\n      const initial = new Map<string, DecisionState>();\n      for (const match of result.matches) {\n        if (match.matchType === \"id_slug\") continue;\n        initial.set(match.id, {\n          action: match.matchType === \"partial\" ? \"reject\" : \"accept\",\n          editText: newName,\n        });\n      }\n      setDecisions(initial);\n\n      // Self entity starts expanded\n      setExpandedSources(new Set([entityId]));\n      setPhase(\"preview\");\n    } catch (err) {\n      console.error(\"[EntityRename] Scan failed:\", err);\n      setPhase(\"input\");\n    }\n  }, [\n    newName,\n    oldNameInput,\n    isPatch,\n    scanOldName,\n    entity,\n    entityId,\n    simulationRunId,\n    relationships,\n    narrativeEvents,\n  ]);\n\n  // --- Decision handling ---\n  const handleChangeAction = useCallback(\n    (matchId: string, action: DecisionAction) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"reject\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, action });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  const handleChangeEditText = useCallback(\n    (matchId: string, text: string) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"edit\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, editText: text });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  // --- Bulk actions (global) ---\n  const handleAcceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const [id, state] of next) {\n        next.set(id, { ...state, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectAllPartials = useCallback(() => {\n    if (!scanResult) return;\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const match of scanResult.matches) {\n        if (match.matchType === \"partial\") {\n          const current = next.get(match.id);\n          if (current) {\n            next.set(match.id, { ...current, action: \"reject\" });\n          }\n        }\n      }\n      return next;\n    });\n  }, [scanResult]);\n\n  // --- Bulk actions (per-source) ---\n  const handleAcceptSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"reject\" });\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Expand/collapse ---\n  const toggleSource = useCallback((sourceId: string) => {\n    setExpandedSources((prev) => {\n      const next = new Set(prev);\n      if (next.has(sourceId)) {\n        next.delete(sourceId);\n      } else {\n        next.add(sourceId);\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    if (!scanResult) return;\n    setPhase(\"applying\");\n\n    try {\n      const decisionArray: MatchDecision[] = [];\n      for (const [matchId, state] of decisions) {\n        decisionArray.push({\n          matchId,\n          action: state.action,\n          editText: state.action === \"edit\" ? state.editText : undefined,\n        });\n      }\n\n      setApplyProgress(\"Building patches...\");\n      const patches = buildRenamePatches(scanResult, newName, decisionArray);\n      console.log(\"[EntityRenameModal] Built patches\", {\n        entityPatchCount: patches.entityPatches.length,\n        eventPatchCount: patches.eventPatches.length,\n        chroniclePatchCount: patches.chroniclePatches.length,\n        eventPatchIds: patches.eventPatches.map((p) => p.eventId),\n        eventPatchKeys: patches.eventPatches.map((p) => Object.keys(p.changes)),\n      });\n\n      // Apply chronicle patches directly (chronicles have their own IDB store)\n      let chronicleCount = 0;\n      if (patches.chroniclePatches.length > 0) {\n        setApplyProgress(`Updating ${patches.chroniclePatches.length} chronicles...`);\n        chronicleCount = await applyChroniclePatches(\n          patches.chroniclePatches,\n          getChronicle,\n          putChronicle\n        );\n      }\n\n      setApplyProgress(`Persisting ${patches.entityPatches.length} entity patches...`);\n\n      const parts = [`${patches.entityPatches.length} entities`, `${chronicleCount} chronicles`];\n      if (patches.eventPatches.length > 0) {\n        parts.push(`${patches.eventPatches.length} events`);\n      }\n      setApplyResult(`Updated ${parts.join(\", \")}.`);\n\n      // Pass patch manifest to parent \u2014 parent handles Dexie persistence\n      onApply({\n        entityPatches: patches.entityPatches,\n        eventPatches: patches.eventPatches,\n        targetEntityId: isPatch ? null : entityId,\n        newName,\n        addOldNameAsAlias: isPatch ? false : addOldNameAsAlias,\n      });\n      setPhase(\"done\");\n    } catch (err) {\n      console.error(\"[EntityRename] Apply failed:\", err);\n      setApplyProgress(`Error: ${err}`);\n    }\n  }, [scanResult, decisions, newName, entityId, onApply, isPatch, addOldNameAsAlias]);\n\n// ... (truncated)", "parameters": [{"name": "{\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}", "type": "Readonly<EntityRenameModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx", "sourceCode": "export default function EraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [tone, setTone] = useState(\"witty\");\n  const [arcDirection, setArcDirection] = useState(\"\");\n  const [existingNarratives, setExistingNarratives] = useState([]);\n  const [previousEraThesis, setPreviousEraThesis] = useState(null);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const {\n    narrative,\n    isActive,\n    startNarrative,\n    startHeadless,\n    resumeNarrative,\n    advanceStep,\n    skipEdit,\n    rerunCopyEdit,\n    deleteVersion,\n    setActiveVersion,\n    cancel\n  } = useEraNarrative(onEnqueue);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Access world context stores (must be before effects that reference it)\n  const eraTemporalInfo = useEraTemporalInfo();\n\n  // Check for existing narratives when era selection changes + look up previous era thesis\n  useEffect(() => {\n    if (!selectedEraId || !simulationRunId) {\n      setExistingNarratives([]);\n      setPreviousEraThesis(null);\n      return;\n    }\n    getEraNarrativesForEra(simulationRunId, selectedEraId).then(records => {\n      // Show non-complete records (resumable) and recent completed ones\n      const resumable = records.filter(r => r.status !== \"cancelled\").sort((a, b) => b.updatedAt - a.updatedAt);\n      setExistingNarratives(resumable);\n    });\n\n    // Look up thesis from previous era's completed narrative\n    const focalInfo = eraTemporalInfo.find(e => e.id === selectedEraId);\n    const focalOrder = focalInfo?.order ?? -1;\n    const prevInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    if (prevInfo) {\n      getEraNarrativesForEra(simulationRunId, prevInfo.id).then(prevRecords => {\n        const completed = prevRecords.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n        setPreviousEraThesis(completed.length > 0 ? {\n          eraName: prevInfo.name,\n          thesis: completed[0].threadSynthesis.thesis\n        } : null);\n      });\n    } else {\n      setPreviousEraThesis(null);\n    }\n  }, [selectedEraId, simulationRunId, eraTemporalInfo]);\n\n  // Group chronicles by era and count prep coverage\n  const eraOptions = useMemo(() => {\n    return wizardEras.map(era => {\n      const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n      const preppedCount = eraChronicles.filter(c => c.hasHistorianPrep).length;\n      return {\n        id: era.id,\n        name: era.name,\n        count: eraChronicles.length,\n        preppedCount\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n  const selectedEra = eraOptions.find(e => e.id === selectedEraId);\n\n  // Build a weight lookup from the live style library (record snapshots may be stale)\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Chronicles for the selected era \u2014 for the setup enumeration\n  const eraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems.filter(c => c.focalEraName === era.name).sort((a, b) => (a.eraYear ?? Infinity) - (b.eraYear ?? Infinity));\n  }, [chronicleItems, wizardEras, selectedEraId, selectedEra]);\n\n  // Build the narrative config (shared by interactive and headless start)\n  const buildConfig = useCallback(async () => {\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return null;\n\n    // Load prep briefs from chronicles in this era\n    const store = useChronicleStore.getState();\n    const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n    const prepBriefs = [];\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record?.historianPrep) continue;\n      prepBriefs.push({\n        chronicleId: record.chronicleId,\n        chronicleTitle: record.title || item.name,\n        eraYear: record.eraYear,\n        weight: record.narrativeStyle?.eraNarrativeWeight || narrativeWeightMap[record.narrativeStyleId] || undefined,\n        prep: record.historianPrep\n      });\n    }\n\n    // Build world-level context\n    const configStore = useIlluminatorConfigStore.getState();\n    const worldDynamics = configStore.worldContext?.worldDynamics || [];\n    const cultureIds = configStore.cultureIdentities || {};\n\n    // Resolve dynamics for focal era \u2014 only include dynamics that have an override for this era\n    const resolvedDynamics = worldDynamics.filter(d => d.eraOverrides?.[era.id]).map(d => {\n      const override = d.eraOverrides[era.id];\n      return override.replace ? override.text : `${d.text || \"\"} ${override.text}`;\n    }).filter(Boolean);\n\n    // Find focal + adjacent eras from temporal info\n    const focalEraInfo = eraTemporalInfo.find(e => e.id === era.id);\n    const focalOrder = focalEraInfo?.order ?? -1;\n    const previousEraInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    const nextEraInfo = eraTemporalInfo.find(e => e.order === focalOrder + 1);\n    const toSummary = info => info ? {\n      id: info.id,\n      name: info.name,\n      summary: info.summary || \"\"\n    } : undefined;\n\n    // Look up the previous era's completed narrative thesis for continuity\n    let previousEraThesis;\n    if (previousEraInfo) {\n      const prevNarratives = await getEraNarrativesForEra(simulationRunId, previousEraInfo.id);\n      const completedPrev = prevNarratives.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n      if (completedPrev.length > 0) {\n        previousEraThesis = completedPrev[0].threadSynthesis.thesis;\n      }\n    }\n    const worldContext = focalEraInfo ? {\n      focalEra: toSummary(focalEraInfo),\n      previousEra: toSummary(previousEraInfo),\n      nextEra: toSummary(nextEraInfo),\n      previousEraThesis,\n      resolvedDynamics,\n      culturalIdentities: cultureIds\n    } : undefined;\n    return {\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      tone,\n      arcDirection: arcDirection.trim() || undefined,\n      historianConfig,\n      prepBriefs,\n      worldContext\n    };\n  }, [selectedEraId, wizardEras, chronicleItems, projectId, simulationRunId, historianConfig, tone, arcDirection, eraTemporalInfo]);\n\n  // Start interactive narrative\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startNarrative(config);\n  }, [selectedEra, buildConfig, startNarrative]);\n\n  // Start headless narrative (all steps, no pauses)\n  const handleStartHeadless = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startHeadless(config);\n  }, [selectedEra, buildConfig, startHeadless]);\n\n  // Resume an existing narrative\n  const handleResume = useCallback(async narrativeId => {\n    await resumeNarrative(narrativeId);\n  }, [resumeNarrative]);\n\n  // Delete an existing narrative from the list\n  const handleDeleteExisting = useCallback(async narrativeId => {\n    await deleteEraNarrative(narrativeId);\n    setExistingNarratives(prev => prev.filter(r => r.narrativeId !== narrativeId));\n  }, []);\n  const handleClose = useCallback(() => {\n    if (isActive && narrative?.status !== \"complete\") {\n      if (narrative?.status === \"generating\" || narrative?.status === \"pending\") {\n        // Minimize instead of closing \u2014 keep isOpen true so pill can restore\n        useFloatingPillStore.getState().minimize({\n          id: PILL_ID,\n          label: `Era: ${narrative?.eraName || \"Narrative\"}`,\n          statusText: narrative?.currentStep || \"Working\",\n          statusColor: \"#f59e0b\",\n          tabId: \"chronicle\"\n        });\n        return;\n      }\n      cancel();\n    }\n    onClose();\n  }, [isActive, narrative, cancel, onClose]);\n\n  // Update pill status when state changes while minimized\n  useEffect(() => {\n    if (!isMinimized || !narrative) return;\n    const stepLabel = {\n      threads: \"Threads\",\n      generate: \"Writing\",\n      edit: \"Editing\"\n    };\n    let statusColor;\n    if (narrative.status === \"generating\" || narrative.status === \"pending\") statusColor = \"#f59e0b\";else if (narrative.status === \"step_complete\") statusColor = \"#3b82f6\";else if (narrative.status === \"complete\") statusColor = \"#10b981\";else if (narrative.status === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    let statusText;\n    if (narrative.status === \"complete\") statusText = \"Complete\";else if (narrative.status === \"failed\") statusText = \"Failed\";else statusText = stepLabel[narrative.currentStep] || narrative.currentStep;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, narrative?.status, narrative?.currentStep]);\n\n  // Clean up pill when process reaches terminal state\n  useEffect(() => {\n    if (!narrative || narrative.status === \"complete\" || narrative.status === \"failed\" || narrative.status === \"cancelled\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [narrative?.status]);\n\n  // Sync narrativeId to modal store so it survives ChroniclePanel unmount\n  useEffect(() => {\n    if (narrative?.narrativeId) {\n      useIlluminatorModals.getState().setEraNarrativeId(narrative.narrativeId);\n    }\n  }, [narrative?.narrativeId]);\n\n  // Auto-resume from store when modal re-mounts with a stored narrativeId\n  useEffect(() => {\n    if (isOpen && resumeNarrativeId && !isActive && !narrative) {\n      resumeNarrative(resumeNarrativeId);\n    }\n  }, [isOpen, resumeNarrativeId, isActive, narrative, resumeNarrative]);\n\n  // Resolve thread names for movement display (must be before early return)\n  const synthesis = narrative?.threadSynthesis;\n  const threadNameMap = useMemo(() => {\n    if (!synthesis) return {};\n    const map = {};\n    for (const t of synthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [synthesis]);\n\n  // Resolve versioned content from the narrative record\n  const resolved = useMemo(() => {\n    if (!narrative) return {\n      content: undefined,\n      versions: [],\n      activeVersionId: undefined\n    };\n    return resolveActiveContent(narrative);\n  }, [narrative]);\n\n  // Sync selectedVersionId to activeVersionId when versions change\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      // Reset selection when active version changes (e.g., after re-run edit completes)\n      // or when no version is selected yet\n      if (!selectedVersionId || !resolved.versions.some(v => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n  if (!isOpen) return null;\n  if (isMinimized) return null;\n  const isGenerating = narrative?.status === \"pending\" || narrative?.status === \"generating\";\n  const isStepComplete = narrative?.status === \"step_complete\";\n  const isFailed = narrative?.status === \"failed\";\n  const isComplete = narrative?.status === \"complete\";\n  const narrativeContent = narrative?.narrative;\n\n  // Currently viewed version (for version selector)\n  const viewedVersion = resolved.versions.find(v => v.versionId === selectedVersionId) || resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // Determine what to show\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; resumeNarrativeId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx", "sourceCode": "export default function EraNarrativeViewer({\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}: Readonly<EraNarrativeViewerProps>) {\n  const [record, setRecord] = useState<EraNarrativeRecord | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [showThreads, setShowThreads] = useState(false);\n  const [showBriefs, setShowBriefs] = useState(false);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState<string | null>(null);\n  const [showInsertion, setShowInsertion] = useState(false);\n  const [insertionText, setInsertionText] = useState(\"\");\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const pollReasonRef = useRef<\"edit\" | \"cover_image\" | \"image_refs\" | null>(null);\n\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Load record from IndexedDB\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getEraNarrative(narrativeId).then((r) => {\n      if (cancelled) return;\n      setRecord(r ?? null);\n      setLoading(false);\n      setSelectedVersionId(\"\");\n      setConfirmingDeleteId(null);\n      setInsertionText(r?.editInsertion || \"\");\n      // Resume polling if record is stuck in a generating state\n      if (r && (r.status === \"pending\" || r.status === \"generating\")) {\n        startPolling(\"edit\");\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [narrativeId]);\n\n  // Stop polling helper\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Poll while generating (for re-run copy edit, cover image, image refs)\n  const startPolling = useCallback(\n    (reason: \"edit\" | \"cover_image\" | \"image_refs\" = \"edit\") => {\n      stopPolling();\n      pollReasonRef.current = reason;\n      const snapshotCoverImage = record?.coverImage;\n      const snapshotImageRefs = record?.imageRefs;\n\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getEraNarrative(narrativeId);\n          if (!updated) return;\n          setRecord(updated);\n\n          const r = pollReasonRef.current;\n\n          // Edit polling: stop on terminal states or step_complete\n          if (r === \"edit\") {\n            if (\n              updated.status === \"complete\" ||\n              updated.status === \"failed\" ||\n              updated.status === \"step_complete\"\n            ) {\n              if (updated.status === \"step_complete\" && updated.currentStep === \"edit\") {\n                await updateEraNarrative(updated.narrativeId, { status: \"complete\" });\n                const final = await getEraNarrative(narrativeId);\n                if (final) setRecord(final);\n              }\n              stopPolling();\n            }\n            return;\n          }\n\n          // Cover image polling: stop when coverImage appears or changes\n          if (r === \"cover_image\") {\n            const hasCover = updated.coverImage?.sceneDescription;\n            const hadCover = snapshotCoverImage?.sceneDescription;\n            if (hasCover && hasCover !== hadCover) {\n              stopPolling();\n            }\n            return;\n          }\n\n          // Image refs polling: stop when imageRefs appears or changes\n          if (r === \"image_refs\") {\n            const hasRefs = updated.imageRefs?.generatedAt;\n            const hadRefs = snapshotImageRefs?.generatedAt;\n            if (hasRefs && hasRefs !== hadRefs) {\n              stopPolling();\n            }\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [narrativeId, stopPolling, record?.coverImage, record?.imageRefs]\n  );\n\n  const threadNameMap = useMemo(() => {\n    if (!record?.threadSynthesis) return {};\n    const map: Record<string, string> = {};\n    for (const t of record.threadSynthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [record?.threadSynthesis]);\n\n  // Resolve versioned content\n  const resolved = useMemo(() => {\n    if (!record) return { content: undefined, versions: [], activeVersionId: undefined };\n    return resolveActiveContent(record);\n  }, [record]);\n\n  // Sync selectedVersionId to activeVersionId\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      if (!selectedVersionId || !resolved.versions.some((v) => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n\n  const viewedVersion =\n    resolved.versions.find((v) => v.versionId === selectedVersionId) ||\n    resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // =========================================================================\n  // Actions\n  // =========================================================================\n\n  const handleExport = useCallback(() => {\n    if (!record) return;\n    try {\n      downloadEraNarrativeExport(record);\n    } catch (err) {\n      console.error(\"[EraNarrativeViewer] Export failed:\", err);\n    }\n  }, [record]);\n\n  const handleRerunCopyEdit = useCallback(async () => {\n    if (!record) return;\n    await updateEraNarrative(record.narrativeId, {\n      status: \"pending\",\n      currentStep: \"edit\",\n      editInsertion: insertionText || undefined,\n    });\n    setSelectedVersionId(\"\");\n\n    onEnqueue([\n      {\n        entity: SENTINEL_ENTITY,\n        type: \"eraNarrative\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: record.narrativeId,\n      },\n    ]);\n\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n    startPolling();\n  }, [record, onEnqueue, startPolling, insertionText]);\n\n  const handleForceComplete = useCallback(async () => {\n    if (!record) return;\n    stopPolling();\n    await updateEraNarrative(record.narrativeId, { status: \"complete\" });\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n  }, [record, stopPolling]);\n\n  const handleDeleteVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await deleteEraNarrativeVersion(record.narrativeId, versionId);\n      setRecord(updated);\n      setConfirmingDeleteId(null);\n      if (updated.activeVersionId) setSelectedVersionId(updated.activeVersionId);\n    },\n    [record]\n  );\n\n  const handleSetActiveVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await setEraNarrativeActiveVersion(record.narrativeId, versionId);\n      setRecord(updated);\n    },\n    [record]\n  );\n\n  // =========================================================================\n  // Era Narrative Sub-Step Dispatch\n  // =========================================================================\n\n  const dispatchEraNarrativeStep = useCallback(\n    (step: string, extras?: Record<string, unknown>) => {\n      if (!record) return;\n      onEnqueue([\n        {\n          entity: SENTINEL_ENTITY,\n          type: \"eraNarrative\" as EnrichmentType,\n          prompt: \"\",\n          chronicleId: record.narrativeId,\n          eraNarrativeStep: step,\n          ...extras,\n        },\n      ]);\n    },\n    [record, onEnqueue]\n  );\n\n  // =========================================================================\n  // Cover Image Handlers\n  // =========================================================================\n\n  const handleGenerateCoverImageScene = useCallback(() => {\n    dispatchEraNarrativeStep(\"cover_image_scene\");\n    startPolling(\"cover_image\");\n  }, [dispatchEraNarrativeStep, startPolling]);\n\n  const handleGenerateCoverImage = useCallback(() => {\n    if (!record?.coverImage?.sceneDescription) return;\n\n    // Mark as generating\n    void updateEraNarrativeCoverImageStatus(record.narrativeId, \"generating\")\n      .then(() => getEraNarrative(record.narrativeId))\n      .then((updated) => {\n        if (updated) setRecord(updated);\n      });\n\n    // Build style info\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityKind: \"chronicle\",\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n    const styleInfo: StyleInfo = {\n      compositionPromptFragment:\n        \"cinematic montage composition, overlapping character silhouettes and scene elements, layered movie-poster layout, multiple focal points at different scales, dramatic depth layering, figures and settings blending into each other, NO TEXT NO TITLES NO LETTERING\",\n      artisticPromptFragment: resolved.artisticStyle?.promptFragment,\n      colorPalettePromptFragment: resolved.colorPalette?.promptFragment,\n    };\n\n    const prompt = buildChronicleScenePrompt(\n      {\n        sceneDescription: record.coverImage.sceneDescription,\n        size: \"medium\",\n        chronicleTitle: record.eraName,\n        world: worldContext\n          ? {\n              name: worldContext.name || \"Unknown World\",\n              description: worldContext.description,\n              speciesConstraint: worldContext.speciesConstraint,\n            }\n          : undefined,\n      },\n      styleInfo\n    );\n\n    onEnqueue([\n      {\n        entity: { id: \"__era_narrative__\", name: record.eraName, kind: \"era_narrative\" },\n        type: \"image\" as EnrichmentType,\n        prompt,\n        chronicleId: record.narrativeId,\n        imageRefId: \"__cover_image__\",\n        sceneDescription: record.coverImage.sceneDescription,\n        imageType: \"era_narrative\",\n        imageSize: imageSize || \"1024x1024\",\n        imageQuality: imageQuality || \"standard\",\n      },\n    ]);\n// ... (truncated)", "parameters": [{"name": "{\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}", "type": "Readonly<EraNarrativeViewerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EventsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EventsPanel.jsx", "sourceCode": "export default function EventsPanel({\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}) {\n  const [significanceFilter, setSignificanceFilter] = useState(0);\n  const [kindFilter, setKindFilter] = useState(\"all\");\n  const [eraFilter, setEraFilter] = useState(\"all\");\n  const [tagFilter, setTagFilter] = useState(\"\");\n  const [expandedEvents, setExpandedEvents] = useState(new Set());\n  const [displayLimit, setDisplayLimit] = useState(DEFAULT_DISPLAY_LIMIT);\n  const events = narrativeEvents || [];\n\n  // Get unique values for filters\n  const {\n    uniqueKinds,\n    uniqueEras,\n    uniqueTags\n  } = useMemo(() => {\n    const kinds = new Set();\n    const eras = new Set();\n    const tags = new Set();\n    for (const event of events) {\n      kinds.add(event.eventKind);\n      if (event.era) eras.add(event.era);\n      for (const tag of event.narrativeTags || []) {\n        tags.add(tag);\n      }\n    }\n    return {\n      uniqueKinds: Array.from(kinds).sort(),\n      uniqueEras: Array.from(eras).sort(),\n      uniqueTags: Array.from(tags).sort()\n    };\n  }, [events]);\n\n  // Filter events\n  const filteredEvents = useMemo(() => {\n    return events.filter(event => {\n      if (event.significance < significanceFilter) return false;\n      if (kindFilter !== \"all\" && event.eventKind !== kindFilter) return false;\n      if (eraFilter !== \"all\" && event.era !== eraFilter) return false;\n      if (tagFilter && !event.narrativeTags?.includes(tagFilter)) return false;\n      return true;\n    });\n  }, [events, significanceFilter, kindFilter, eraFilter, tagFilter]);\n\n  // Sort by significance (highest first)\n  const sortedEvents = useMemo(() => {\n    return [...filteredEvents].sort((a, b) => b.significance - a.significance);\n  }, [filteredEvents]);\n\n  // Limit displayed events for performance\n  const displayedEvents = useMemo(() => {\n    return sortedEvents.slice(0, displayLimit);\n  }, [sortedEvents, displayLimit]);\n  const hasMoreEvents = sortedEvents.length > displayLimit;\n  const handleLoadMore = () => {\n    setDisplayLimit(prev => prev + LOAD_MORE_INCREMENT);\n  };\n\n  // Reset display limit when filters change\n  useEffect(() => {\n    setDisplayLimit(DEFAULT_DISPLAY_LIMIT);\n  }, [significanceFilter, kindFilter, eraFilter, tagFilter]);\n  const toggleExpanded = eventId => {\n    setExpandedEvents(prev => {\n      const next = new Set(prev);\n      if (next.has(eventId)) {\n        next.delete(eventId);\n      } else {\n        next.add(eventId);\n      }\n      return next;\n    });\n  };\n  const handleExportEvents = () => {\n    if (events.length === 0) return;\n    const json = JSON.stringify(events, null, 2);\n    const blob = new Blob([json], {\n      type: \"application/json\"\n    });\n    const url = URL.createObjectURL(blob);\n    const anchor = document.createElement(\"a\");\n    const safeRunId = simulationRunId ? simulationRunId.replace(/[^a-zA-Z0-9_-]+/g, \"_\") : \"all\";\n    anchor.href = url;\n    anchor.download = `narrative-events-${safeRunId}.json`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    anchor.remove();\n    URL.revokeObjectURL(url);\n  };\n  if (events.length === 0) {\n    return <div className=\"events-panel-empty\">\n        <div className=\"events-panel-empty-icon\">\n          <span role=\"img\" aria-label=\"events\">\n            &#x1F4DC;\n          </span>\n        </div>\n        <h3 className=\"events-panel-empty-title\">No Narrative Events</h3>\n        <p className=\"events-panel-empty-text\">\n          Narrative events are captured during simulation when &quot;Enable event tracking&quot; is turned on\n          in the Lore Weave simulation parameters.\n        </p>\n        <div className=\"events-panel-empty-instructions\">\n          <div className=\"events-panel-empty-instructions-title\">To enable event tracking:</div>\n          <ol className=\"events-panel-empty-instructions-list\">\n            <li>Go to the Lore Weave tab</li>\n            <li>Open &quot;Run Simulation&quot;</li>\n            <li>Enable &quot;Narrative Events&quot; in parameters</li>\n            <li>Run a new simulation</li>\n          </ol>\n        </div>\n      </div>;\n  }\n  return <div className=\"events-panel-root\">\n      {/* Filter bar */}\n      <div className=\"events-panel-filter-bar\">\n        <div className=\"events-panel-filter-header\">\n          <div className=\"events-panel-filter-count\">\n            {displayedEvents.length === filteredEvents.length ? `${filteredEvents.length} of ${events.length} events` : `Showing ${displayedEvents.length} of ${filteredEvents.length} filtered (${events.length} total)`}\n          </div>\n          <div className=\"events-panel-filter-actions\">\n            <div className=\"events-panel-filter-sort-label\">Sorted by significance</div>\n            <button onClick={handleExportEvents} disabled={events.length === 0} className=\"events-panel-export-btn\">\n              Export JSON\n            </button>\n          </div>\n        </div>\n\n        <div className=\"events-panel-filters-row\">\n          {/* Significance slider */}\n          <div className=\"events-panel-significance-filter\">\n            <label htmlFor=\"min-significance\" className=\"events-panel-filter-label\">Min significance:</label>\n            <input id=\"min-significance\" type=\"range\" min={0} max={1} step={0.1} value={significanceFilter} onChange={e => setSignificanceFilter(parseFloat(e.target.value))} className=\"events-panel-significance-slider\" />\n            <span className=\"events-panel-significance-value\">\n              {Math.round(significanceFilter * 100)}%\n            </span>\n          </div>\n\n          {/* Kind filter */}\n          <select value={kindFilter} onChange={e => setKindFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All kinds</option>\n            {uniqueKinds.map(kind => <option key={kind} value={kind}>\n                {kind.replace(/_/g, \" \")}\n              </option>)}\n          </select>\n\n          {/* Era filter */}\n          <select value={eraFilter} onChange={e => setEraFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All eras</option>\n            {uniqueEras.map(era => <option key={era} value={era}>\n                {entityMap?.get(era)?.name || era}\n              </option>)}\n          </select>\n\n          {/* Tag filter */}\n          {uniqueTags.length > 0 && <select value={tagFilter} onChange={e => setTagFilter(e.target.value)} className=\"events-panel-filter-select\">\n              <option value=\"\">All tags</option>\n              {uniqueTags.map(tag => <option key={tag} value={tag}>\n                  {tag}\n                </option>)}\n            </select>}\n\n          {/* Clear filters */}\n          {(significanceFilter > 0 || kindFilter !== \"all\" || eraFilter !== \"all\" || tagFilter) && <button onClick={() => {\n          setSignificanceFilter(0);\n          setKindFilter(\"all\");\n          setEraFilter(\"all\");\n          setTagFilter(\"\");\n        }} className=\"events-panel-clear-filters-btn\">\n              Clear filters\n            </button>}\n        </div>\n      </div>\n\n      {/* Events list */}\n      <div className=\"events-panel-list\">\n        {sortedEvents.length === 0 ? <div className=\"events-panel-no-match\">No events match the current filters</div> : <>\n            {displayedEvents.map(event => <EventCard key={event.id} event={event} entityMap={entityMap} expanded={expandedEvents.has(event.id)} onToggle={() => toggleExpanded(event.id)} />)}\n\n            {/* Load more button */}\n            {hasMoreEvents && <div className=\"events-panel-load-more-row\">\n                <button onClick={handleLoadMore} className=\"events-panel-load-more-btn\">\n                  Load {Math.min(LOAD_MORE_INCREMENT, sortedEvents.length - displayLimit)} more\n                  <span className=\"events-panel-load-more-remaining\">\n                    ({sortedEvents.length - displayLimit} remaining)\n                  </span>\n                </button>\n              </div>}\n          </>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}", "type": "{ narrativeEvents?: any[]; simulationRunId: any; entityMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/FinalEditTab.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/FinalEditTab.tsx", "sourceCode": "export default function FinalEditTab() {\n  return (\n    <div>\n      <div className=\"fet-section\">\n        <h3 className=\"fet-heading\">Corpus Find & Replace</h3>\n        <p className=\"fet-subtitle\">\n          Search and replace across chronicle content, chronicle annotations, and entity annotations\n        </p>\n      </div>\n      <CorpusFindReplace />\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx", "sourceCode": "// ============================================================================\n// Main Editor\n// ============================================================================\n\nexport default function HistorianConfigEditor({ config, onChange }) {\n  const update = useCallback(\n    (field, value) => {\n      onChange({ ...config, [field]: value });\n    },\n    [config, onChange]\n  );\n\n  const [reloadStatus, setReloadStatus] = useState(null); // null | 'confirm' | 'loading' | 'done' | 'error'\n\n  const handleReloadFromDefaults = useCallback(async () => {\n    try {\n      setReloadStatus(\"loading\");\n      const response = await fetch(\"/default-project/historianConfig.json\");\n      if (!response.ok) throw new Error(`HTTP ${response.status}`);\n      const defaultConfig = await response.json();\n      onChange(defaultConfig);\n      setReloadStatus(\"done\");\n      setTimeout(() => setReloadStatus(null), 2000);\n    } catch (err) {\n      setReloadStatus(\"error\");\n      console.error(\"Failed to reload historian config:\", err);\n      setTimeout(() => setReloadStatus(null), 3000);\n    }\n  }, [onChange]);\n\n  const isConfigured = config.name.trim().length > 0 && config.background.trim().length > 0;\n\n  return (\n    <div className=\"hce-root\">\n      {/* Header */}\n      <div className=\"hce-header\">\n        <div className=\"hce-header-top\">\n          <div className=\"hce-header-title\">Historian Persona</div>\n          <button\n            onClick={() => setReloadStatus(\"confirm\")}\n            disabled={reloadStatus === \"loading\"}\n            className=\"illuminator-button illuminator-button-secondary hce-reload-btn\"\n            title=\"Reload historian config from the default project template\"\n          >\n            {(() => {\n              if (reloadStatus === \"loading\") return \"Loading...\";\n              if (reloadStatus === \"done\") return \"Reloaded \\u2713\";\n              if (reloadStatus === \"error\") return \"Failed \\u2717\";\n              return \"Reload Defaults\";\n            })()}\n          </button>\n        </div>\n        <div className=\"hce-header-description\">\n          Define the scholarly voice behind both <strong>annotations</strong> (margin notes \u2014\n          corrections, observations, asides) and <strong>copy edits</strong> (full description\n          rewrites synthesized from the description archive). The same persona drives both\n          operations in a consistent voice across all content.\n        </div>\n        {!isConfigured && (\n          <div className=\"hce-unconfigured-notice\">\n            Configure at least a name and background to enable historian annotations and copy edits.\n          </div>\n        )}\n      </div>\n\n      {/* Fields */}\n      <div className=\"hce-fields\">\n        {/* Name */}\n        <div>\n          <FieldLabel\n            label=\"Name & Title\"\n            description='e.g., \"Aldric Fenworth, Third Archivist of the Pale Library\"'\n          />\n          <input\n            type=\"text\"\n            value={config.name}\n            onChange={(e) => update(\"name\", e.target.value)}\n            placeholder=\"Enter the historian's name and title\"\n            className=\"hce-full-input\"\n          />\n        </div>\n\n        {/* Background */}\n        <div>\n          <FieldLabel\n            label=\"Background\"\n            description=\"Credentials, institutional affiliation, era they're writing from\"\n          />\n          <textarea\n            value={config.background}\n            onChange={(e) => update(\"background\", e.target.value)}\n            placeholder=\"A seasoned archivist who has spent forty years cataloguing the histories of the realm. Has outlived most of the people described in these texts. Still shows up to work.\"\n            className=\"hce-textarea hce-textarea-bg\"\n          />\n        </div>\n\n        {/* Personality Traits */}\n        <div>\n          <FieldLabel\n            label=\"Personality Traits\"\n            description=\"Short phrases that define the historian's character \u2014 think weary, not wacky\"\n          />\n          <TagInput\n            value={config.personalityTraits}\n            onChange={(v) => update(\"personalityTraits\", v)}\n            placeholder='e.g., \"world-weary\", \"quietly compassionate\"'\n          />\n        </div>\n\n        {/* Biases */}\n        <div>\n          <FieldLabel\n            label=\"Biases & Blind Spots\"\n            description=\"What they trust, distrust, or have given up arguing about\"\n          />\n          <TagInput\n            value={config.biases}\n            onChange={(v) => update(\"biases\", v)}\n            placeholder='e.g., \"distrusts oral histories\"'\n          />\n        </div>\n\n        {/* Stance */}\n        <div>\n          <FieldLabel\n            label=\"Stance Toward Source Material\"\n            description=\"Their overall relationship to the texts they're working with\"\n          />\n          <textarea\n            value={config.stance}\n            onChange={(e) => update(\"stance\", e.target.value)}\n            placeholder='e.g., \"Has read too many of these accounts to be surprised, but still occasionally moved by the human cost of events others reduce to dates and outcomes\"'\n            className=\"hce-textarea hce-textarea-stance\"\n          />\n        </div>\n\n        {/* Private Facts */}\n        <div>\n          <FieldLabel\n            label=\"Private Facts\"\n            description=\"Things the historian knows that aren't in the canon facts. May surface in annotations and shape editorial choices in copy edits.\"\n          />\n          <ListEditor\n            value={config.privateFacts}\n            onChange={(v) => update(\"privateFacts\", v)}\n            placeholder=\"Add a fact\"\n            itemPlaceholder='e.g., \"The real cause of the Great Fire was arson, not the dragon\"'\n          />\n        </div>\n\n        {/* Running Gags */}\n        <div>\n          <FieldLabel\n            label=\"Recurring Preoccupations\"\n            description=\"Refrains, motifs, or things the historian keeps circling back to \u2014 not jokes, but patterns they can't stop noticing\"\n          />\n          <ListEditor\n            value={config.runningGags}\n            onChange={(v) => update(\"runningGags\", v)}\n            placeholder=\"Add a preoccupation\"\n            itemPlaceholder='e.g., \"The way institutions always outlive the people who built them\"'\n          />\n        </div>\n      </div>\n\n      {/* Reload confirmation modal */}\n      {reloadStatus === \"confirm\" && (\n        <div\n          className=\"hce-modal-overlay\"\n          onClick={(e) => {\n            if (e.target === e.currentTarget) setReloadStatus(null);\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <div className=\"hce-modal-box\">\n            <div className=\"hce-modal-title\">Reload from Defaults?</div>\n            <div className=\"hce-modal-body\">\n              This will overwrite your current historian configuration with the default project\n              template. Any edits you&apos;ve made will be lost.\n            </div>\n            <div className=\"hce-modal-actions\">\n              <button\n                onClick={() => setReloadStatus(null)}\n                className=\"illuminator-button illuminator-button-secondary hce-modal-btn\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={() => handleReloadFromDefaults()}\n                className=\"illuminator-button hce-modal-btn\"\n              >\n                Reload\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onChange }", "type": "{ config: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx", "sourceCode": "export default function HistorianEditionComparison({\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}: Readonly<HistorianEditionComparisonProps>) {\n  const [expanded, setExpanded] = useState(false);\n\n  const versions = useMemo(() => {\n    // Find all historian-edition and legacy-copy-edit entries with their original indices\n    const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n    const historianEntries = descriptionHistory\n      .map((entry, index) => ({ ...entry, historyIndex: index }))\n      .filter((entry) => editionSources.has(entry.source || \"\"));\n\n    if (historianEntries.length === 0) return [];\n\n    const editionVersions: EditionVersion[] = [];\n\n    // First entry = pre-historian baseline\n    const baseline = historianEntries[0];\n    editionVersions.push({\n      label: \"Pre-Historian\",\n      description: baseline.description,\n      historyIndex: baseline.historyIndex,\n      isCurrent: false,\n      wordCount: baseline.description.split(/\\s+/).length,\n      date: baseline.replacedAt ? new Date(baseline.replacedAt).toLocaleDateString() : undefined,\n    });\n\n    // Subsequent entries = prior historian/legacy outputs pushed to history when replaced\n    for (let i = 1; i < historianEntries.length; i++) {\n      const entry = historianEntries[i];\n      const isLegacy = entry.source === \"legacy-copy-edit\";\n      editionVersions.push({\n        label: `Edition ${i}${isLegacy ? \" (legacy)\" : \"\"}`,\n        description: entry.description,\n        historyIndex: entry.historyIndex,\n        isCurrent: false,\n        wordCount: entry.description.split(/\\s+/).length,\n        date: entry.replacedAt ? new Date(entry.replacedAt).toLocaleDateString() : undefined,\n      });\n    }\n\n    // Current description = latest edition\n    editionVersions.push({\n      label: `Edition ${historianEntries.length} (active)`,\n      description: currentDescription,\n      historyIndex: -1,\n      isCurrent: true,\n      wordCount: currentDescription.split(/\\s+/).length,\n    });\n\n    return editionVersions;\n  }, [descriptionHistory, currentDescription]);\n\n  // Exportable when we have 3+ versions: pre-historian baseline, at least one prior edition, and active.\n  // versions[0] = pre-historian, versions[last] = active, everything in between = prior editions.\n  const exportData = useMemo(() => {\n    if (versions.length < 3) return null;\n    const active = versions[versions.length - 1];\n    if (!active?.isCurrent) return null;\n    const data: Record<string, unknown> = {\n      preHistorian: versions[0].description,\n      legacyCopyEdit: versions[versions.length - 2].description,\n      active: active.description,\n    };\n    // Include non-disabled annotations when present\n    const activeNotes = historianNotes?.filter((n) => n.display !== \"disabled\");\n    if (activeNotes && activeNotes.length > 0) {\n      data.annotations = activeNotes.map((n) => ({\n        type: n.type,\n        display: n.display || \"full\",\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      }));\n    }\n    return data;\n  }, [versions, historianNotes]);\n\n  const [selectedIdx, setSelectedIdx] = useState(() => versions.length - 1);\n  const [compareIdx, setCompareIdx] = useState(() =>\n    versions.length > 1 ? versions.length - 2 : -1\n  );\n\n  if (versions.length < 2) return null;\n\n  const selected = versions[selectedIdx] || versions[versions.length - 1];\n  const compare = compareIdx >= 0 ? versions[compareIdx] : null;\n\n  const wordDelta = compare ? selected.wordCount - compare.wordCount : 0;\n  const deltaSign = wordDelta >= 0 ? \"+\" : \"\";\n\n  return (\n    <div className=\"hec-wrapper\">\n      <div\n        onClick={() => setExpanded(!expanded)}\n        className=\"hec-toggle\"\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <span>{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <span className=\"hec-toggle-label\">\n          Edition Comparison\n        </span>\n        <span\n          title={`${versions.length - 1} historian edition${versions.length - 1 !== 1 ? \"s\" : \"\"} + pre-historian baseline`}\n        >\n          {\"\\u25C7\"} {versions.length} versions\n        </span>\n      </div>\n\n      {expanded && (\n        <div className=\"hec-expanded\">\n          {/* Version selectors */}\n          <div className=\"hec-selector-row\">\n            <select\n              value={selectedIdx}\n              onChange={(e) => setSelectedIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-select\"\n            >\n              {versions.map((v, i) => (\n                <option key={i} value={i}>\n                  {v.label} ({v.wordCount}w){v.date ? ` \u2014 ${v.date}` : \"\"}\n                </option>\n              ))}\n            </select>\n            <select\n              value={compareIdx}\n              onChange={(e) => setCompareIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-compare-select\"\n              title=\"Select a version to diff against\"\n            >\n              <option value={-1}>Compare to...</option>\n              {versions\n                .filter((_, i) => i !== selectedIdx)\n                .map((v) => {\n                  const realIdx = versions.indexOf(v);\n                  return (\n                    <option key={realIdx} value={realIdx}>\n                      {v.label} ({v.wordCount}w)\n                    </option>\n                  );\n                })}\n            </select>\n            {selected.isCurrent ? (\n              <span className=\"hec-active-badge\">\n                Active\n              </span>\n            ) : (\n              <button\n                onClick={() => onRestoreVersion(entityId, selected.historyIndex)}\n                className=\"hec-make-active-btn\"\n              >\n                Make Active\n              </button>\n            )}\n            {exportData && (\n              <button\n                onClick={() => {\n                  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                    type: \"application/json\",\n                  });\n                  const url = URL.createObjectURL(blob);\n                  const ts = new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, 19);\n                  const a = document.createElement(\"a\");\n                  a.href = url;\n                  a.download = `edition-comparison-${entityId}-${ts}.json`;\n                  a.click();\n                  URL.revokeObjectURL(url);\n                }}\n                className=\"hec-export-btn\"\n                title=\"Export pre-historian, legacy, and active versions as JSON\"\n              >\n                Export\n              </button>\n            )}\n          </div>\n\n          {/* Word count summary */}\n          {compare && (\n            <div className=\"hec-word-summary\">\n\n              <span>\n                {\"\\u25C6\"} {selected.label}: {selected.wordCount.toLocaleString()}w\n              </span>\n              <span>\n                {\"\\u25C6\"} {compare.label}: {compare.wordCount.toLocaleString()}w\n              </span>\n              <span\n                className=\"hec-word-delta\"\n                style={{\n                  \"--hec-delta-color\":\n                    wordDelta < 0 ? \"#22c55e\" : wordDelta > 0 ? \"#f59e0b\" : \"var(--text-muted)\",\n                } as React.CSSProperties}\n              >\n                {deltaSign}\n                {wordDelta.toLocaleString()}w ({deltaSign}\n                {compare.wordCount > 0 ? Math.round((wordDelta / compare.wordCount) * 100) : 0}%)\n              </span>\n            </div>\n          )}\n\n          {/* Diff view */}\n          {compare ? (\n            <DiffView older={compare.description} newer={selected.description} />\n          ) : (\n            <div className=\"hec-text-view\">\n\n              {selected.description}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}", "type": "Readonly<HistorianEditionComparisonProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function HistorianMarginNotes({\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}) {\n  const counts = useMemo(() => {\n    if (!notes || notes.length === 0) return {\n      full: 0,\n      popout: 0,\n      disabled: 0\n    };\n    let full = 0,\n      popout = 0,\n      disabled = 0;\n    for (const n of notes) {\n      const d = noteDisplayMode(n);\n      if (d === \"full\") full++;else if (d === \"popout\") popout++;else disabled++;\n    }\n    return {\n      full,\n      popout,\n      disabled\n    };\n  }, [notes]);\n  if (!notes || notes.length === 0) return null;\n  const summaryParts = [];\n  if (counts.full > 0) summaryParts.push(`${counts.full} full`);\n  if (counts.popout > 0) summaryParts.push(`${counts.popout} popout`);\n  if (counts.disabled > 0) summaryParts.push(`${counts.disabled} disabled`);\n  return (\n    <div className={className || undefined}>\n      <div className=\"hmn-header\">\n        <span className=\"hmn-title\">Historian Notes</span>\n        <span className=\"hmn-summary\">{summaryParts.join(\", \")}</span>\n      </div>\n\n      {/* All notes in original order \u2014 no regrouping */}\n      {notes.map(note => <NoteItem key={note.noteId} note={note} sourceText={sourceText} onUpdateNote={onUpdateNote} />)}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}", "type": "{ notes: any; sourceText: any; className: any; onUpdateNote: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function HistorianReviewModal({\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}) {\n  if (!isActive || !run) return null;\n  const isGenerating = run.status === \"pending\" || run.status === \"generating\";\n  const isReviewing = run.status === \"reviewing\";\n  const isFailed = run.status === \"failed\";\n  const notes = run.notes || [];\n  const acceptedCount = notes.filter(n => run.noteDecisions[n.noteId] !== false).length;\n  return <div className=\"hrm-overlay\">\n      <div className=\"hrm-modal\">\n        {/* Header */}\n        <div className=\"hrm-modal-header\">\n          <div>\n            <div className=\"hrm-modal-title\">Historian Review &mdash; {run.targetName}</div>\n            <div className=\"hrm-modal-subtitle\">\n              {run.targetType === \"entity\" ? \"Entity Description\" : \"Chronicle Narrative\"}\n              {run.tone && TONE_META[run.tone] && <span className=\"hrm-modal-tone\">\n                  {TONE_META[run.tone].symbol} {TONE_META[run.tone].label}\n                </span>}\n              {isReviewing && ` \\u00b7 ${acceptedCount}/${notes.length} notes accepted`}\n            </div>\n          </div>\n          <button onClick={onCancel} className=\"hrm-modal-cancel-btn\">\n            Cancel\n          </button>\n        </div>\n\n        {/* Content */}\n        <div className=\"hrm-modal-content\">\n          {isGenerating && <div className=\"hrm-generating-message\">The historian is reviewing the text\\u2026</div>}\n\n          {isFailed && <div className=\"hrm-failed-message\">Review failed: {run.error || \"Unknown error\"}</div>}\n\n          {isReviewing && <div className=\"hrm-review-layout\">\n              {/* Annotated source text */}\n              <div>\n                <div className=\"hrm-section-label\">Source Text (annotations highlighted)</div>\n                <AnnotatedText sourceText={run.sourceText} notes={notes} noteDecisions={run.noteDecisions} />\n              </div>\n\n              {/* Notes list */}\n              <div>\n                <div className=\"hrm-section-label\">Historian Notes ({notes.length})</div>\n                {notes.map(note => <NoteCard key={note.noteId} note={note} accepted={run.noteDecisions[note.noteId]} onToggle={onToggleNote} onEditText={onEditNoteText} />)}\n              </div>\n            </div>}\n        </div>\n\n        {/* Footer */}\n        {isReviewing && <div className=\"hrm-modal-footer\">\n            <button onClick={onCancel} className=\"hrm-discard-btn\">\n              Discard All\n            </button>\n            <button onClick={onAccept} disabled={acceptedCount === 0} className={`hrm-apply-btn ${acceptedCount > 0 ? \"hrm-apply-btn-active\" : \"hrm-apply-btn-disabled\"}`}>\n              Apply {acceptedCount} Note{acceptedCount !== 1 ? \"s\" : \"\"}\n            </button>\n          </div>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}", "type": "{ run: any; isActive: any; onToggleNote: any; onEditNoteText: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx", "sourceCode": "// ============================================================================\n// Component\n// ============================================================================\n\nexport default function HistorianToneSelector({\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const containerRef = useRef(null);\n\n  // Close on outside click\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleClickOutside = e => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [isOpen]);\n  const handleSelect = tone => {\n    setIsOpen(false);\n    onSelect(tone);\n  };\n  return <div ref={containerRef} className={`htsel-container${className ? ` ${className}` : \"\"}`}>\n      <button onClick={() => setIsOpen(!isOpen)} disabled={disabled} title=\"Select historian tone and generate annotations\" className={`htsel-trigger ${disabled ? \"htsel-trigger-disabled\" : \"\"}`}>\n        {label || (hasNotes ? \"Re-annotate\" : \"Historian\")} \u25be\n      </button>\n\n      {isOpen && <div className=\"htsel-dropdown\">\n          <div className=\"htsel-dropdown-header\">Historian Tone</div>\n          {TONE_OPTIONS.map(option => <button key={option.value} onClick={() => handleSelect(option.value)} className=\"htsel-option\">\n              <span className=\"htsel-option-symbol\">{option.symbol}</span>\n              <div className=\"htsel-option-content\">\n                <div className=\"htsel-option-label\">{option.label}</div>\n                <div className=\"htsel-option-description\">{option.description}</div>\n              </div>\n            </button>)}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}", "type": "{ onSelect: any; disabled: any; hasNotes: any; className: any; label: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx", "sourceCode": "export default function HistoryCompressionPreviewModal({\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}) {\n  if (!compressed || compressed.length === 0) return null;\n\n  const removedCount = originalCount - compressed.length;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary hcpm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={onProceed}\n        className=\"illuminator-button illuminator-button-primary hcpm-footer-btn\"\n      >\n        Proceed with Copy Edit\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Description Archive\" className=\"hcpm-dialog\" footer={footer}>\n      <div className=\"hcpm-meta\">\n        <span className=\"hcpm-entity-name\">{entityName}</span>\n        <p className=\"hcpm-subtitle\">\n          {removedCount > 0\n            ? `${originalCount} versions \u2192 ${compressed.length} milestones (${removedCount} near-duplicate passes consolidated)`\n            : `${originalCount} versions \u2014 no compression needed`}\n        </p>\n      </div>\n\n      {/* Scrollable content */}\n      <div className=\"hcpm-content\">\n        {compressed.map((entry, i) => {\n          const date = new Date(entry.replacedAt).toISOString().split(\"T\")[0];\n          const isConsolidated = entry.consolidatedCount > 1;\n          const earliestDate = entry.earliestDate\n            ? new Date(entry.earliestDate).toISOString().split(\"T\")[0]\n            : null;\n\n          return (\n            <div\n              key={i}\n              className={`hcpm-entry ${isConsolidated ? \"hcpm-entry-consolidated\" : \"hcpm-entry-normal\"}`}\n            >\n              {/* Header */}\n              <div className=\"hcpm-entry-header\">\n                <div className=\"hcpm-entry-header-left\">\n                  <span className=\"hcpm-entry-index\">[{i + 1}]</span>\n                  <span className=\"hcpm-entry-source\">{entry.source}</span>\n                  {isConsolidated && (\n                    <span className=\"hcpm-entry-consolidated-label\">\n                      {entry.consolidatedCount} passes consolidated\n                    </span>\n                  )}\n                </div>\n                <span className=\"hcpm-entry-date\">\n                  {isConsolidated && earliestDate ? `${earliestDate} \u2192 ${date}` : date}\n                </span>\n              </div>\n\n              {/* Preview */}\n              <div className=\"hcpm-entry-preview\">{entry.description.slice(0, 300)}</div>\n            </div>\n          );\n        })}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}", "type": "{ entityName: any; originalCount: any; compressed: any; onProceed: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorModals.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorModals.jsx", "sourceCode": "/**\n * Orchestrator component for all Illuminator modal dialogs.\n *\n * Flow objects (revisionFlow, backportFlow, etc.) are passed as grouped props\n * rather than flat-spreading ~100 properties.\n */\nexport default function IlluminatorModals({\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}) {\n  return (\n    <>\n      <ImageSettingsSection\n        imageGenSettings={props.imageGenSettings}\n        updateImageGenSettings={props.updateImageGenSettings}\n        styleLibrary={props.styleLibrary}\n        worldSchema={props.worldSchema}\n        config={props.config}\n      />\n      <DynamicsSection dynamicsFlow={dynamicsFlow} />\n      <RevisionSection revisionFlow={revisionFlow} />\n      <BackportSection backportFlow={backportFlow} revisionFlow={revisionFlow} />\n      <HistorianSection historianFlow={historianFlow} revisionFlow={revisionFlow} />\n      <EntityModals\n        worldSchema={props.worldSchema}\n        handleRenameApplied={props.handleRenameApplied}\n        handleCreateEntity={props.handleCreateEntity}\n        handleEditEntity={props.handleEditEntity}\n      />\n      <ToneAndAnnotationModals />\n      <ThinkingViewer />\n      <FloatingPills onNavigate={props.setActiveTab} />\n    </>\n  );\n}", "parameters": [{"name": "{\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}", "type": "{ [x: string]: any; revisionFlow: any; backportFlow: any; historianFlow: any; dynamicsFlow: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx", "sourceCode": "export default function IlluminatorSidebar({\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}) {\n  return (\n    <div className=\"illuminator-sidebar\">\n      <nav className=\"illuminator-nav\">\n        {TABS.map((tab) => (\n          <NavButton\n            key={tab.id}\n            tab={tab}\n            activeTab={activeTab}\n            setActiveTab={setActiveTab}\n            stats={stats}\n          />\n        ))}\n      </nav>\n\n      <div className=\"isb-spacer\" />\n\n      {/* Image Settings trigger */}\n      <div className=\"isb-image-settings\">\n        <ImageSettingsTrigger\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary}\n          onClick={() => useIlluminatorModals.getState().openImageSettings()}\n        />\n      </div>\n\n      {/* API Key section */}\n      <ApiKeySection\n        showApiKeyInput={showApiKeyInput}\n        setShowApiKeyInput={setShowApiKeyInput}\n        hasRequiredKeys={hasRequiredKeys}\n        anthropicApiKey={anthropicApiKey}\n        setAnthropicApiKey={setAnthropicApiKey}\n        openaiApiKey={openaiApiKey}\n        setOpenaiApiKey={setOpenaiApiKey}\n        persistApiKeys={persistApiKeys}\n        setPersistApiKeys={setPersistApiKeys}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}", "type": "{ activeTab: any; setActiveTab: any; stats: any; imageGenSettings: any; styleLibrary: any; showApiKeyInput: any; setShowApiKeyInput: any; hasRequiredKeys: any; anthropicApiKey: any; setAnthropicApiKey: any; openaiApiKey: any; setOpenaiApiKey: any; persistApiKeys: any; setPersistApiKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx", "sourceCode": "export default function IlluminatorTabContent({ activeTab, ...props }) {\n  const TabComponent = TAB_COMPONENTS[activeTab];\n  return TabComponent ? <TabComponent {...props} /> : null;\n}", "parameters": [{"name": "{ activeTab, ...props }", "type": "{ [x: string]: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageModal.jsx", "sourceCode": "export default function ImageModal({ isOpen, imageId, title, onClose }) {\n  const { url: imageUrl, loading, error, metadata } = useImageUrl(isOpen ? imageId : null);\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  // Close on escape key\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener(\"keydown\", handleKeyDown);\n      // Prevent body scroll when modal is open\n      document.body.style.overflow = \"hidden\";\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen) return null;\n\n  const hasSidebar = sidebarOpen && metadata;\n\n  return (\n    <div className=\"imod-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      {/* Header with title and close button */}\n      <div\n        className={`imod-header ${hasSidebar ? \"imod-header-sidebar-open\" : \"imod-header-sidebar-closed\"}`}\n        onClick={(e) => e.stopPropagation()}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <h3 className=\"imod-title\">{title}</h3>\n        <button onClick={onClose} className=\"imod-close-btn\">\n          Close (Esc)\n        </button>\n      </div>\n\n      {/* Image container - adjusted for sidebar */}\n      <div\n        className={`imod-image-container ${hasSidebar ? \"imod-image-container-sidebar-open\" : \"imod-image-container-sidebar-closed\"}`}\n      >\n        {loading && (\n          <div className=\"imod-loading\">Loading image...</div>\n        )}\n        {!loading && (error || !imageUrl) && (\n          <div className=\"imod-error\">\n            <div className=\"imod-error-title\">Image not available</div>\n            <div className=\"imod-error-detail\">{error || \"Image not found in storage\"}</div>\n          </div>\n        )}\n        {!loading && !error && imageUrl && (\n          <img\n            src={imageUrl}\n            alt={title}\n            className=\"imod-full-image\"\n            onClick={(e) => e.stopPropagation()}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          />\n        )}\n      </div>\n\n      {/* Metadata sidebar */}\n      <MetadataSidebar\n        metadata={metadata}\n        isOpen={sidebarOpen}\n        onToggle={() => setSidebarOpen(!sidebarOpen)}\n      />\n\n      {/* Hint at bottom */}\n      <div\n        className={`imod-hint ${hasSidebar ? \"imod-hint-sidebar-open\" : \"imod-hint-sidebar-closed\"}`}\n      >\n        Click anywhere or press Escape to close\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, imageId, title, onClose }", "type": "{ isOpen: any; imageId: any; title: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImagePickerModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImagePickerModal.jsx", "sourceCode": "export default function ImagePickerModal({\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n  const [loading, setLoading] = useState(true);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterCulture, setFilterCulture] = useState(\"all\");\n  const [filterModel, setFilterModel] = useState(\"all\");\n  const [searchText, setSearchText] = useState(\"\");\n  const [expandedPrompt, setExpandedPrompt] = useState(null);\n  const [filterOptions, setFilterOptions] = useState({ kinds: [], cultures: [], models: [] });\n\n  // Load filter options when modal opens\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadFilterOptions() {\n      try {\n        const [kinds, cultures, models] = await Promise.all([\n          getImageFilterOptions(\"entity-kind\"),\n          getImageFilterOptions(\"entityCulture\"),\n          getImageFilterOptions(\"model\"),\n        ]);\n        setFilterOptions({ kinds, cultures, models });\n      } catch (err) {\n        console.error(\"Failed to load filter options:\", err);\n      }\n    }\n\n    loadFilterOptions();\n    // Reset filters on open\n    setFilterKind(\"all\");\n    setFilterCulture(\"all\");\n    setFilterModel(\"all\");\n    setSearchText(\"\");\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {};\n        if (filterKind !== \"all\") filters.entityKind = filterKind;\n        if (filterCulture !== \"all\") filters.entityCulture = filterCulture;\n        if (filterModel !== \"all\") filters.model = filterModel;\n        if (searchText.trim()) filters.searchText = searchText.trim();\n\n        const results = await searchImages(filters);\n        setImages(results);\n      } catch (err) {\n        console.error(\"Failed to load images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, filterKind, filterCulture, filterModel, searchText]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      // Find the selected image to get its metadata\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    setExpandedPrompt(null);\n    onClose();\n  }, [onClose]);\n\n  // Close on escape key\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") {\n        handleClose();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal ipm-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Image from Library</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body ipm-body\">\n          {/* Filters */}\n          <div className=\"ipm-filters\">\n            <div>\n              <label htmlFor=\"search\" className=\"ipm-filter-label\">Search</label>\n              <input id=\"search\"\n                type=\"text\"\n                value={searchText}\n                onChange={(e) => setSearchText(e.target.value)}\n                placeholder=\"Name or prompt...\"\n                className=\"illuminator-input ipm-search-input\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"entity-kind\" className=\"ipm-filter-label\">Entity Kind</label>\n              <select id=\"entity-kind\"\n                value={filterKind}\n                onChange={(e) => setFilterKind(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Kinds</option>\n                {filterOptions.kinds.map((kind) => (\n                  <option key={kind} value={kind}>\n                    {kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"culture\" className=\"ipm-filter-label\">Culture</label>\n              <select id=\"culture\"\n                value={filterCulture}\n                onChange={(e) => setFilterCulture(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Cultures</option>\n                {filterOptions.cultures.map((culture) => (\n                  <option key={culture} value={culture}>\n                    {culture}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"model\" className=\"ipm-filter-label\">Model</label>\n              <select id=\"model\"\n                value={filterModel}\n                onChange={(e) => setFilterModel(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Models</option>\n                {filterOptions.models.map((model) => (\n                  <option key={model} value={model}>\n                    {model}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"ipm-filter-count-wrapper\">\n              <span className=\"ipm-filter-count\">{images.length} images</span>\n            </div>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"ipm-grid-container\">\n            {loading && (\n              <div className=\"ipm-loading\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"ipm-empty\">\n                No images found. Try adjusting the filters or generate some images first.\n              </div>\n            )}\n            {!loading && images.length > 0 && (\n              <div className=\"ipm-grid\">\n                {images.map((img) => {\n                  const isSelected = selectedImageId === img.imageId;\n                  const isCurrent = currentImageId === img.imageId;\n\n                  return (\n                    <div\n                      key={img.imageId}\n                      onClick={() => setSelectedImageId(img.imageId)}\n                      className={`ipm-card ${isSelected ? \"ipm-card-selected\" : \"\"} ${isCurrent ? \"ipm-card-current\" : \"\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {/* Current badge */}\n                      {isCurrent && <div className=\"ipm-current-badge\">CURRENT</div>}\n\n                      {/* Thumbnail \u2014 lazy-loaded via IntersectionObserver */}\n                      <LazyThumbnail\n                        imageId={img.imageId}\n                        alt={img.entityName || img.imageId}\n                        className=\"ipm-thumbnail-wrapper\"\n                      />\n\n                      {/* Info */}\n                      <div className=\"ipm-card-info\">\n                        <div className=\"ipm-card-name\" title={img.entityName}>\n                          {img.entityName || \"Unknown\"}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {img.entityKind}\n                          {img.entityCulture && ` \u00b7 ${img.entityCulture}`}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {formatDate(img.generatedAt)} \u00b7 {formatBytes(img.size || 0)}\n                        </div>\n\n                        {/* Prompt preview */}\n                        {(img.finalPrompt || img.originalPrompt) && (\n                          <div\n                            className={`ipm-card-prompt ${expandedPrompt === img.imageId ? \"ipm-card-prompt-expanded\" : \"ipm-card-prompt-collapsed\"}`}\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              setExpandedPrompt(\n                                expandedPrompt === img.imageId ? null : img.imageId\n                              );\n                            }}\n                            title=\"Click to expand/collapse prompt\"\n                            role=\"button\"\n                            tabIndex={0}\n                            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                          >\n                            {img.finalPrompt || img.originalPrompt}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer ipm-footer\">\n          <button onClick={handleClose} className=\"illuminator-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId || selectedImageId === currentImageId}\n            className=\"illuminator-btn illuminator-btn-primary\"\n          >\n            {selectedImageId === currentImageId ? \"Already Assigned\" : \"Assign Image\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; entityKind: any; entityCulture: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageRefPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageRefPicker.jsx", "sourceCode": "export default function ImageRefPicker({ projectId, onSelect, onClose }) {\n  const [images, setImages] = useState([]);\n  const [imageUrls, setImageUrls] = useState({}); // imageId -> dataUrl cache\n  const [loading, setLoading] = useState(false);\n  const [search, setSearch] = useState(\"\");\n  const [debouncedSearch, setDebouncedSearch] = useState(\"\");\n  const [caption, setCaption] = useState(\"\");\n  const [selectedImage, setSelectedImage] = useState(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const searchTimeoutRef = useRef(null);\n\n  // Debounce search input\n  useEffect(() => {\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n    searchTimeoutRef.current = setTimeout(() => {\n      setDebouncedSearch(search);\n    }, 300);\n\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, [search]);\n\n  // Load images when search changes\n  useEffect(() => {\n    let cancelled = false;\n\n    async function loadImages() {\n      setLoading(true);\n      try {\n        const result = await searchImages({\n          projectId,\n          search: debouncedSearch || undefined,\n          limit: PAGE_SIZE,\n          offset: 0,\n        });\n\n        if (cancelled) return;\n\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n        setSelectedImage(null);\n        setCaption(\"\");\n      } catch (err) {\n        console.error(\"Failed to search images:\", err);\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    }\n\n    loadImages();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, debouncedSearch]);\n\n  // Load more images (pagination)\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const result = await searchImages({\n        projectId,\n        search: debouncedSearch || undefined,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      });\n\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [projectId, debouncedSearch, images.length, loading, hasMore]);\n\n  // Lazy load image thumbnail when it comes into view\n  const loadImageUrl = useCallback(\n    async (imageId) => {\n      if (imageUrls[imageId]) return; // Already loaded\n\n      try {\n        const dataUrl = await getImageDataUrl(imageId);\n        if (dataUrl) {\n          setImageUrls((prev) => ({ ...prev, [imageId]: dataUrl }));\n        }\n      } catch (err) {\n        console.warn(`Failed to load image ${imageId}:`, err);\n      }\n    },\n    [imageUrls]\n  );\n\n  const handleInsert = () => {\n    if (!selectedImage) return;\n    const imageRef = caption\n      ? `![${caption}](image:${selectedImage.imageId})`\n      : `![](image:${selectedImage.imageId})`;\n    onSelect(imageRef);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Image\" className=\"image-picker-modal\">\n      <div className=\"image-picker-toolbar\">\n        <input\n          type=\"text\"\n          value={search}\n          onChange={(e) => setSearch(e.target.value)}\n          placeholder=\"Search by entity name...\"\n          className=\"static-page-search-input\"\n          // eslint-disable-next-line jsx-a11y/no-autofocus\n          autoFocus\n        />\n        {total > 0 && <span className=\"image-picker-count\">{total} images</span>}\n      </div>\n\n      {loading && images.length === 0 && (\n        <div className=\"image-picker-loading\">Searching images...</div>\n      )}\n      {!(loading && images.length === 0) && images.length === 0 && (\n        <div className=\"image-picker-empty\">\n          {search ? \"No images match your search\" : \"No images available\"}\n        </div>\n      )}\n      {images.length > 0 && (\n        <>\n          <div className=\"image-picker-grid\">\n            {images.map((img) => (\n              <ImageThumbnail\n                key={img.imageId}\n                image={img}\n                dataUrl={imageUrls[img.imageId]}\n                isSelected={selectedImage?.imageId === img.imageId}\n                onSelect={() => setSelectedImage(img)}\n                onVisible={() => loadImageUrl(img.imageId)}\n              />\n            ))}\n          </div>\n\n          {hasMore && (\n            <button\n              className=\"static-page-button image-picker-load-more\"\n              onClick={() => void handleLoadMore()}\n              disabled={loading}\n            >\n              {loading ? \"Loading...\" : `Load more (${images.length} of ${total})`}\n            </button>\n          )}\n        </>\n      )}\n\n      {selectedImage && (\n        <div className=\"image-picker-caption-section\">\n          <label className=\"image-picker-caption-label\">\n            Caption (optional):\n            <input\n              type=\"text\"\n              value={caption}\n              onChange={(e) => setCaption(e.target.value)}\n              placeholder=\"Enter image caption...\"\n              className=\"static-page-search-input\"\n            />\n          </label>\n          <button className=\"static-page-button primary\" onClick={handleInsert}>\n            Insert Image\n          </button>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ projectId, onSelect, onClose }", "type": "{ projectId: any; onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ImageSettingsDrawer({\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}: ImageSettingsDrawerProps) {\n  const drawerRef = useRef<HTMLDivElement>(null);\n\n  // Local copy of settings for instant UI feedback.\n  // Changes render immediately here, then propagate to parent via rAF.\n  const [settings, setLocalSettings] = useState(externalSettings);\n  const pendingFlush = useRef<number | null>(null);\n\n  // Sync local state when external settings change (e.g. on mount or external update)\n  useEffect(() => {\n    setLocalSettings(externalSettings);\n  }, [externalSettings]);\n\n  // Debounced push to parent \u2014 renders locally first, then flushes\n  const onSettingsChange = useCallback((partial: Partial<ImageGenSettings>) => {\n    setLocalSettings(prev => ({\n      ...prev,\n      ...partial\n    }));\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n    pendingFlush.current = requestAnimationFrame(() => {\n      pendingFlush.current = null;\n      externalOnChange(partial);\n    });\n  }, [externalOnChange]);\n\n  // Cleanup on unmount\n  useEffect(() => () => {\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n  }, []);\n\n  // Close on Escape\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") onClose();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [isOpen, onClose]);\n\n  // Section collapse state\n  const collapsedSet = useMemo(() => new Set(settings.collapsedSections), [settings.collapsedSections]);\n  const toggleSection = useCallback((key: string) => {\n    const next = new Set(collapsedSet);\n    if (next.has(key)) next.delete(key);else next.add(key);\n    onSettingsChange({\n      collapsedSections: Array.from(next)\n    });\n  }, [collapsedSet, onSettingsChange]);\n\n  // Group compositions by category\n  const groupedCompositions = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.compositionStyles>();\n    const map = new Map<string, typeof styleLibrary.compositionStyles>();\n    for (const style of styleLibrary.compositionStyles) {\n      const cat = style.targetCategory || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Group artistic styles by category\n  const groupedArtisticStyles = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.artisticStyles>();\n    const map = new Map<string, typeof styleLibrary.artisticStyles>();\n    for (const style of styleLibrary.artisticStyles) {\n      const cat = style.category || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Derive initial category tab from current selection\n  const selectedCompositionCategory = useMemo(() => {\n    if (!styleLibrary) return COMPOSITION_CATEGORY_ORDER[0];\n    const selected = styleLibrary.compositionStyles.find(s => s.id === settings.compositionStyleId);\n    return selected?.targetCategory || COMPOSITION_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.compositionStyleId]);\n  const selectedArtisticCategory = useMemo(() => {\n    if (!styleLibrary) return ARTISTIC_CATEGORY_ORDER[0];\n    const selected = styleLibrary.artisticStyles.find(s => s.id === settings.artisticStyleId);\n    return selected?.category || ARTISTIC_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.artisticStyleId]);\n\n  // Active category tabs \u2014 initialized from selection, then user-controllable\n  const [activeCompositionCategory, setActiveCompositionCategory] = useState(selectedCompositionCategory);\n  const [activeArtisticCategory, setActiveArtisticCategory] = useState(selectedArtisticCategory);\n\n  // Sync tab when selection changes to a different category (e.g. picking from a different tab)\n  useEffect(() => {\n    setActiveCompositionCategory(selectedCompositionCategory);\n  }, [selectedCompositionCategory]);\n  useEffect(() => {\n    setActiveArtisticCategory(selectedArtisticCategory);\n  }, [selectedArtisticCategory]);\n\n  // Available category tabs (only those with styles)\n  const availableCompositionCategories = useMemo(() => {\n    return COMPOSITION_CATEGORY_ORDER.filter(cat => groupedCompositions.has(cat));\n  }, [groupedCompositions]);\n  const availableArtisticCategories = useMemo(() => {\n    return ARTISTIC_CATEGORY_ORDER.filter(cat => groupedArtisticStyles.has(cat));\n  }, [groupedArtisticStyles]);\n\n  // Resolve display names for badge\n  const artisticName = useMemo(() => {\n    if (settings.artisticStyleId === RANDOM_ID) return \"Random\";\n    if (settings.artisticStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.artisticStyles.find(s => s.id === settings.artisticStyleId)?.name || settings.artisticStyleId;\n  }, [settings.artisticStyleId, styleLibrary]);\n  const compositionName = useMemo(() => {\n    if (settings.compositionStyleId === RANDOM_ID) return \"Random\";\n    if (settings.compositionStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.compositionStyles.find(s => s.id === settings.compositionStyleId)?.name || settings.compositionStyleId;\n  }, [settings.compositionStyleId, styleLibrary]);\n  const paletteName = useMemo(() => {\n    if (settings.colorPaletteId === RANDOM_ID) return \"Random\";\n    if (settings.colorPaletteId === NONE_ID) return \"None\";\n    return styleLibrary?.colorPalettes.find(s => s.id === settings.colorPaletteId)?.name || settings.colorPaletteId;\n  }, [settings.colorPaletteId, styleLibrary]);\n\n  // Group palettes by pre-defined groups\n  const palettesByGroup = useMemo(() => {\n    if (!styleLibrary) return [];\n    const paletteMap = new Map(styleLibrary.colorPalettes.map(p => [p.id, p]));\n    return PALETTE_GROUPS.map(group => ({\n      label: group.label,\n      palettes: group.ids.map(id => paletteMap.get(id)).filter(Boolean)\n    })).filter(g => g.palettes.length > 0);\n  }, [styleLibrary]);\n\n  // Size/quality options for current model\n  const sizeOptions = useMemo(() => getSizeOptions(imageModel), [imageModel]);\n  const qualityOptions = useMemo(() => getQualityOptions(imageModel), [imageModel]);\n\n  // Is the current selection a special value?\n  const isSpecialArtistic = settings.artisticStyleId === RANDOM_ID || settings.artisticStyleId === NONE_ID;\n  const isSpecialComposition = settings.compositionStyleId === RANDOM_ID || settings.compositionStyleId === NONE_ID;\n  const isSpecialPalette = settings.colorPaletteId === RANDOM_ID || settings.colorPaletteId === NONE_ID;\n\n  // Pool count info for random selection with exclusion filtering\n  const artisticPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialComposition) return undefined;\n    const total = styleLibrary.artisticStyles.length;\n    const filtered = filterStylesForComposition(styleLibrary.artisticStyles as any, settings.compositionStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.compositionStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.compositionStyleId, isSpecialComposition]);\n  const compositionPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialArtistic) return undefined;\n    const total = styleLibrary.compositionStyles.length;\n    const filtered = filterCompositionsForStyle(styleLibrary.compositionStyles as any, settings.artisticStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.artisticStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.artisticStyleId, isSpecialArtistic]);\n  if (!isOpen) return null;\n  return createPortal(<>\n      {/* Backdrop */}\n      <div onClick={onClose} className=\"isd-backdrop\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") onClose(e);\n    }} />\n\n      {/* Drawer */}\n      <div ref={drawerRef} onClick={e => e.stopPropagation()} className=\"isd-drawer\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        {/* Header */}\n        <div className=\"isd-header\">\n          <span className=\"isd-header-title\">Image Settings</span>\n          <button onClick={onClose} className=\"isd-close-btn\">\n            &#10005;\n          </button>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"isd-scroll\">\n          {!styleLibrary ? <div className=\"isd-loading\">Loading styles...</div> : <>\n              {/* \u2500\u2500\u2500 Visual Style \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Visual Style\" sectionKey=\"artistic\" collapsed={collapsedSet.has(\"artistic\")} onToggle={toggleSection} badge={artisticName}>\n                <SpecialToggle value={isSpecialArtistic ? settings.artisticStyleId : \"\"} onChange={id => onSettingsChange({\n              artisticStyleId: id\n            })} poolInfo={artisticPoolInfo} />\n\n                {/* Artistic category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableArtisticCategories.map(cat => <button key={cat} onClick={() => setActiveArtisticCategory(cat)} className=\"isd-category-tab\" data-active={activeArtisticCategory === cat}>\n                      {ARTISTIC_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Artistic style list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedArtisticStyles.get(activeArtisticCategory) || []).map(style => {\n                const isSelected = settings.artisticStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  artisticStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Composition \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Composition\" sectionKey=\"composition\" collapsed={collapsedSet.has(\"composition\")} onToggle={toggleSection} badge={compositionName}>\n                <SpecialToggle value={isSpecialComposition ? settings.compositionStyleId : \"\"} onChange={id => onSettingsChange({\n              compositionStyleId: id\n            })} poolInfo={compositionPoolInfo} />\n\n                {/* Category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableCompositionCategories.map(cat => <button key={cat} onClick={() => setActiveCompositionCategory(cat)} className=\"isd-category-tab\" data-active={activeCompositionCategory === cat}>\n                      {COMPOSITION_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Composition list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedCompositions.get(activeCompositionCategory) || []).map(style => {\n                const isSelected = settings.compositionStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  compositionStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name-composition\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Color Palette \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Color Palette\" sectionKey=\"palette\" collapsed={collapsedSet.has(\"palette\")} onToggle={toggleSection} badge={paletteName}>\n                <SpecialToggle value={isSpecialPalette ? settings.colorPaletteId : \"\"} onChange={id => onSettingsChange({\n              colorPaletteId: id\n            })} />\n\n                {palettesByGroup.map(group => <div key={group.label} className=\"isd-palette-group\">\n                    <div className=\"isd-palette-group-label\">{group.label}</div>\n                    <div className=\"isd-palette-grid\">\n                      {group.palettes.map(palette => {\n                  const isSelected = settings.colorPaletteId === palette.id;\n                  return <button key={palette.id} onClick={() => onSettingsChange({\n                    colorPaletteId: palette.id\n                  })} title={palette.description} className=\"isd-palette-btn\" data-selected={isSelected}>\n                            {palette.swatchColors && palette.swatchColors.length > 0 && <div className=\"isd-palette-swatch-row\">\n                                <SwatchStrip colors={palette.swatchColors} />\n                              </div>}\n                            <div className=\"isd-palette-name\">{palette.name}</div>\n                          </button>;\n                })}\n                    </div>\n                  </div>)}\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Output Settings \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Output\" sectionKey=\"output\" collapsed={collapsedSet.has(\"output\")} onToggle={toggleSection}>\n                {/* Size - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Size</div>\n                  <div className=\"isd-output-btns\">\n                    {sizeOptions.map(opt => {\n                  const isSelected = settings.imageSize === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageSize: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n                })}\n                  </div>\n                </div>\n\n                {/* Quality - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Quality</div>\n                  <div className=\"isd-output-btns\">\n                    {qualityOptions.map(opt => {\n                  const isSelected = settings.imageQuality === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageQuality: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}", "type": "ImageSettingsDrawerProps", "optional": false}], "returnType": "React.ReactPortal"}, {"id": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx", "sourceCode": "export default function InterleavedAnnotationModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n  const progressStatus = progress?.status;\n  const processedItems = progress?.processedItems;\n  const totalItems = progress?.totalItems;\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedItems}/${totalItems}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedItems, totalItems]);\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalItems > 0 ? Math.round(progress.processedItems / progress.totalItems * 100) : 0;\n  return <div className=\"iam-overlay\">\n      <div className=\"iam-dialog\" style={{\n      \"--iam-dialog-width\": isConfirming ? \"560px\" : \"480px\"\n    }}>\n        {/* Header */}\n        <div className=\"iam-header\">\n          <div className=\"iam-header-row\">\n            <h2 className=\"iam-title\">Interleaved Annotation</h2>\n            <div className=\"iam-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Interleaved Annotation\",\n              statusText: progress.status === \"running\" ? `${progress.processedItems}/${progress.totalItems}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })()\n            })} className=\"illuminator-button iam-minimize-btn\" title=\"Minimize to pill\">\n                  \u2014\n                </button>}\n              <span className=\"iam-status-text\" style={{\n              \"--iam-status-color\": (() => {\n                if (progress.status === \"complete\") return \"#10b981\";\n                if (progress.status === \"failed\") return \"#ef4444\";\n                if (progress.status === \"cancelled\") return \"#f59e0b\";\n                return \"var(--text-muted)\";\n              })()\n            }}>\n                {isConfirming && `${progress.totalItems} items`}\n                {progress.status === \"running\" && `${progress.processedItems}/${progress.totalItems}`}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`iam-body ${isConfirming ? \"iam-body-confirming\" : \"iam-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              <div className=\"iam-confirm-info\">\n                Chronicles in chronological order, each followed by its referenced entities. Results\n                auto-applied. Voice digest accumulates across both types.\n                <div className=\"iam-confirm-summary\">\n                  {progress.chronicleCount} chronicles + {progress.entityCount} entities ={\" \"}\n                  {progress.totalItems} total\n                </div>\n              </div>\n\n              {/* Work list \u2014 grouped */}\n              <div className=\"iam-worklist-section\">\n                <div className=\"iam-section-label\">Work List</div>\n\n                <div className=\"iam-worklist\">\n                  {progress.workItems.map(item => {\n                const isChronicle = item.type === \"chronicle\";\n                const toneMeta = TONE_META[item.tone];\n                return <div key={isChronicle ? `c-${item.chronicleId}` : `e-${item.entityId}`} className={`iam-work-item ${isChronicle ? \"iam-work-item-chronicle\" : \"iam-work-item-entity\"}`}>\n                        <div className=\"iam-work-item-left\">\n                          <span className={`iam-work-item-icon ${isChronicle ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                            {isChronicle ? \"\\u25a0\" : \"\\u25cb\"}\n                          </span>\n                          <span className={`iam-work-item-name ${isChronicle ? \"iam-work-item-name-chronicle\" : \"iam-work-item-name-entity\"}`}>\n                            {isChronicle ? item.title : item.entityName}\n                          </span>\n                          {!isChronicle && <span className=\"iam-work-item-kind\">{item.entityKind}</span>}\n                        </div>\n                        <span className=\"iam-work-item-tone\" title={toneMeta?.label || item.tone}>\n                          {toneMeta?.symbol || item.tone}\n                        </span>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing screen ---- */}\n          {!isConfirming && <>\n              <div className=\"iam-progress-section\">\n                <div className=\"iam-progress-header\">\n                  <span className=\"iam-progress-label\">\n                    Item {Math.min(progress.processedItems + 1, progress.totalItems)} /{\" \"}\n                    {progress.totalItems}\n                  </span>\n                  <span className=\"iam-progress-percent\">{globalPercent}%</span>\n                </div>\n\n                {/* Progress bar */}\n                <div className=\"iam-progress-track\">\n                  <div className=\"iam-progress-fill\" style={{\n                \"--iam-progress-bg\": (() => {\n                  if (progress.status === \"failed\") return \"#ef4444\";\n                  if (progress.status === \"cancelled\") return \"#f59e0b\";\n                  return \"#10b981\";\n                })(),\n                \"--iam-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n\n                <div className=\"iam-progress-detail\">\n                  <span>\n                    Chronicles: {progress.processedChronicles}/{progress.chronicleCount}\n                    {\" \\u00b7 \"}\n                    Entities: {progress.processedEntities}/{progress.entityCount}\n                  </span>\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-count\">{progress.failedItems.length} failed</span>}\n                </div>\n              </div>\n\n              {/* Current item */}\n              {progress.currentItem && !isTerminal && <div className=\"iam-current-item\">\n                  <div className=\"iam-current-item-header\">\n                    <span className={`iam-current-item-icon ${progress.currentItem.type === \"chronicle\" ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                      {progress.currentItem.type === \"chronicle\" ? \"\\u25a0\" : \"\\u25cb\"}\n                    </span>\n                    {progress.currentItem.type === \"chronicle\" ? progress.currentItem.title : progress.currentItem.entityName}\n                    {TONE_META[progress.currentItem.tone] && <span className=\"iam-current-item-tone\">\n                        {TONE_META[progress.currentItem.tone].symbol}\n                      </span>}\n                  </div>\n                  <div className=\"iam-current-item-sub\">\n                    {progress.currentItem.type === \"chronicle\" ? \"Annotating chronicle...\" : \"Annotating entity...\"}\n                  </div>\n                </div>}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"iam-terminal-complete\">\n                  Annotated {progress.processedChronicles} chronicles and{\" \"}\n                  {progress.processedEntities} entities.\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-inline\">\n                      {\" \"}\n                      {progress.failedItems.length} failed.\n                    </span>}\n                </div>}\n\n              {progress.status === \"cancelled\" && <div className=\"iam-terminal-cancelled\">\n                  Cancelled after {progress.processedItems} of {progress.totalItems} items (\n                  {progress.processedChronicles} chronicles, {progress.processedEntities} entities).\n                </div>}\n\n              {progress.status === \"failed\" && <div className=\"iam-terminal-failed\">\n                  {progress.error || \"An unexpected error occurred.\"}\n                </div>}\n\n              {/* Failed items list */}\n              {isTerminal && progress.failedItems.length > 0 && <div className=\"iam-failed-section\">\n                  <div className=\"iam-failed-label\">Failed ({progress.failedItems.length})</div>\n                  {progress.failedItems.map((f, i) => <div key={i} className=\"iam-failed-item\">\n                      {f.item.type === \"chronicle\" ? f.item.title : f.item.entityName}: {f.error}\n                    </div>)}\n                </div>}\n\n              {/* Cost */}\n              {progress.totalCost > 0 && <div className=\"iam-cost\">Cost: ${progress.totalCost.toFixed(4)}</div>}\n            </>}\n        </div>\n\n        {/* Footer */}\n        <div className=\"iam-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary iam-footer-btn\">\n                Start ({progress.totalItems} items)\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button iam-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx", "sourceCode": "export default function LLMCallConfigPanel() {\n  const [settings, setSettings] = useState(() => getLLMModelSettings());\n  const [, forceUpdate] = useState(0);\n\n  const overrideCount = getOverrideCount();\n  const callTypesByCategory = getCallTypesByCategory();\n\n  const handleUpdate = useCallback(\n    (callType, config) => {\n      const next = {\n        ...settings,\n        callOverrides: {\n          ...settings.callOverrides,\n        },\n      };\n\n      if (\n        !config.model &&\n        config.thinkingBudget === undefined &&\n        config.maxTokens === undefined &&\n        config.streamTimeout === undefined &&\n        config.disableStreaming === undefined &&\n        config.runInBrowser === undefined\n      ) {\n        delete next.callOverrides[callType];\n      } else {\n        next.callOverrides[callType] = config;\n      }\n\n      setSettings(next);\n      saveLLMModelSettings(next);\n      forceUpdate((n) => n + 1);\n    },\n    [settings]\n  );\n\n  const handleResetAll = useCallback(() => {\n    resetToDefaults();\n    setSettings(getLLMModelSettings());\n    forceUpdate((n) => n + 1);\n  }, []);\n\n  const categories = [\n    \"description\",\n    \"perspective\",\n    \"chronicle\",\n    \"image\",\n    \"palette\",\n    \"dynamics\",\n    \"revision\",\n    \"historian\",\n  ];\n\n  return (\n    <div className=\"illuminator-card llm-config-panel\">\n      <div className=\"llm-config-header\">\n        <div className=\"llm-config-title-row\">\n          <h2 className=\"illuminator-card-title\">LLM Call Configuration</h2>\n          {overrideCount > 0 && (\n            <span className=\"llm-config-override-count\">{overrideCount} modified</span>\n          )}\n        </div>\n        <div className=\"llm-config-actions\">\n          {overrideCount > 0 && (\n            <button onClick={handleResetAll} className=\"llm-config-reset-all\">\n              Reset All\n            </button>\n          )}\n        </div>\n      </div>\n\n      <div className=\"llm-table-container\">\n        <table className=\"llm-table\">\n          <thead>\n            <tr className=\"llm-table-header\">\n              <th className=\"llm-table-th llm-table-th-label\">Call Type</th>\n              <th className=\"llm-table-th llm-table-th-model\">Model</th>\n              <th className=\"llm-table-th llm-table-th-thinking\">Thinking</th>\n              <th className=\"llm-table-th llm-table-th-temp\">Temp</th>\n              <th className=\"llm-table-th llm-table-th-top-p\">Low P</th>\n              <th className=\"llm-table-th llm-table-th-max\">Max Tokens</th>\n              <th className=\"llm-table-th llm-table-th-timeout\">Timeout</th>\n              <th className=\"llm-table-th llm-table-th-sync\">No Stream</th>\n              <th className=\"llm-table-th llm-table-th-browser\">Browser</th>\n              <th className=\"llm-table-th llm-table-th-action\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {categories.map((category) => {\n              const callTypes = callTypesByCategory[category];\n              return [\n                <CategoryHeader key={`cat-${category}`} category={category} />,\n                ...callTypes.map((callType, idx) => {\n                  const resolved = getCallConfig(callType);\n                  const isDefault = !hasOverrides(callType);\n                  return (\n                    <CallTypeRow\n                      key={callType}\n                      callType={callType}\n                      config={resolved}\n                      isDefault={isDefault}\n                      onUpdate={handleUpdate}\n                      isLast={idx === callTypes.length - 1}\n                    />\n                  );\n                }),\n              ];\n            })}\n          </tbody>\n        </table>\n      </div>\n\n      <div className=\"llm-config-footer\">\n        <span className=\"llm-config-hint\">* = default</span>\n        <span className=\"llm-config-hint\">Hover call type for description</span>\n      </div>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/PrePrintPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/PrePrintPanel.tsx", "sourceCode": "export default function PrePrintPanel({ projectId, simulationRunId }: Readonly<PrePrintPanelProps>) {\n  const navEntities = useEntityNavList();\n  const [activeSubTab, setActiveSubTab] = useState<SubTab>(\"stats\");\n  const [fullEntities, setFullEntities] = useState<PersistedEntity[]>([]);\n  const [chronicles, setChronicles] = useState<ChronicleRecord[]>([]);\n  const [allImages, setAllImages] = useState<ImageMetadataRecord[]>([]);\n  const [staticPages, setStaticPages] = useState<StaticPage[]>([]);\n  const [eraNarratives, setEraNarratives] = useState<EraNarrativeRecord[]>([]);\n  const [treeState, setTreeState] = useState<ContentTreeState | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (!projectId || !simulationRunId) {\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    void Promise.all([\n      getChroniclesForSimulation(simulationRunId),\n      getAllImages(),\n      getStaticPagesForProject(projectId),\n      loadTree(projectId, simulationRunId),\n      getEntitiesForRun(simulationRunId),\n      getEraNarrativesForSimulation(simulationRunId),\n    ]).then(([chrons, allImgs, pages, tree, ents, narrs]) => {\n      if (cancelled) return;\n      setChronicles(chrons);\n      // Keep project-scoped images; further filtering happens in memo below.\n      setAllImages(allImgs.filter((img) => img.projectId === projectId));\n      setStaticPages(pages);\n      setTreeState(tree);\n      setFullEntities(ents);\n      setEraNarratives(narrs);\n      setLoading(false);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, simulationRunId]);\n\n  const handleTreeChange = useCallback((newTree: ContentTreeState) => {\n    setTreeState(newTree);\n    void saveTree(newTree);\n  }, []);\n\n  // Era order map: eraId \u2192 sort index (by startTick)\n  const eraOrderMap = useMemo(() => {\n    const eraEntities = fullEntities.filter((e) => e.kind === \"era\" && (e as any).temporal);\n    const sorted = [...eraEntities].sort(\n      (a, b) => ((a as any).temporal.startTick || 0) - ((b as any).temporal.startTick || 0)\n    );\n    const map = new Map<string, number>();\n    sorted.forEach((era, index) => {\n      const eraId = (era as any).eraId || era.id;\n      map.set(eraId, index);\n    });\n    return map;\n  }, [fullEntities]);\n\n  const images = useMemo(() => {\n    if (allImages.length === 0) return [];\n\n    const referencedIds = new Set<string>();\n\n    for (const entity of navEntities) {\n      if (entity.imageId) referencedIds.add(entity.imageId);\n    }\n\n    const publishableChronicles = chronicles.filter(\n      (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n    );\n\n    for (const chronicle of publishableChronicles) {\n      const coverId = chronicle.coverImage?.generatedImageId;\n      if (coverId && chronicle.coverImage?.status === \"complete\") {\n        referencedIds.add(coverId);\n      }\n\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    // Era narrative images\n    for (const narr of eraNarratives) {\n      if (narr.coverImage?.status === \"complete\" && narr.coverImage.generatedImageId) {\n        referencedIds.add(narr.coverImage.generatedImageId);\n      }\n      if (narr.imageRefs?.refs) {\n        for (const ref of narr.imageRefs.refs) {\n          if (ref.type === \"chronicle_ref\") {\n            referencedIds.add(ref.imageId);\n          } else if (\n            ref.type === \"prompt_request\" &&\n            ref.status === \"complete\" &&\n            ref.generatedImageId\n          ) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    if (referencedIds.size === 0) return [];\n    return allImages.filter((img) => referencedIds.has(img.imageId));\n  }, [allImages, navEntities, chronicles, eraNarratives]);\n\n  if (loading) {\n    return (\n      <div className=\"ppp-empty-state\">\n        Loading pre-print data...\n      </div>\n    );\n  }\n\n  if (!projectId || !simulationRunId) {\n    return (\n      <div className=\"ppp-empty-state\">\n        No active project. Load a simulation run to use pre-print features.\n      </div>\n    );\n  }\n\n  const subTabs: { id: SubTab; label: string }[] = [\n    { id: \"stats\", label: \"Stats\" },\n    { id: \"tree\", label: \"Content Tree\" },\n    { id: \"export\", label: \"Export\" },\n  ];\n\n  return (\n    <div className=\"preprint-panel\">\n      <div className=\"preprint-subtabs\">\n        {subTabs.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => setActiveSubTab(tab.id)}\n            className={`preprint-subtab ${activeSubTab === tab.id ? \"active\" : \"\"}`}\n          >\n            {tab.label}\n          </button>\n        ))}\n      </div>\n\n      <div className=\"preprint-content\">\n        {activeSubTab === \"stats\" && (\n          <StatsView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n          />\n        )}\n\n        {activeSubTab === \"tree\" && (\n          <ContentTreeView\n            entities={fullEntities}\n            chronicles={chronicles}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            eraOrderMap={eraOrderMap}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n            onTreeChange={handleTreeChange}\n          />\n        )}\n\n        {activeSubTab === \"export\" && (\n          <ExportView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, simulationRunId }", "type": "Readonly<PrePrintPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ProgressPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ProgressPanel.jsx", "sourceCode": "export default function ProgressPanel({\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}) {\n  const isRunning = status === \"running\";\n  const isPaused = status === \"paused\";\n  const isIdle = status === \"idle\";\n  const isComplete = status === \"complete\";\n  const completedTasks = useMemo(() => tasks.filter(t => t.status === \"complete\"), [tasks]);\n  const errorTasks = useMemo(() => tasks.filter(t => t.status === \"error\"), [tasks]);\n  const runningTasks = useMemo(() => tasks.filter(t => t.status === \"running\"), [tasks]);\n  const pendingTasks = useMemo(() => tasks.filter(t => t.status === \"pending\"), [tasks]);\n  const progressPercent = progress.total > 0 ? Math.round(progress.completed / progress.total * 100) : 0;\n  return <div>\n      {/* Status card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Progress</h2>\n          <div className=\"pp-button-group\">\n            {isIdle && <button onClick={onRunAll} className=\"illuminator-button\" disabled={!hasRequiredKeys || pendingTasks.length === 0}>\n                Start Enrichment\n              </button>}\n            {isRunning && <button onClick={onPause} className=\"illuminator-button illuminator-button-secondary\">\n                Pause\n              </button>}\n            {isPaused && <button onClick={onResume} className=\"illuminator-button\">\n                Resume\n              </button>}\n            {(isRunning || isPaused) && <button onClick={onAbort} className=\"pp-abort-btn\">\n                Abort\n              </button>}\n          </div>\n        </div>\n\n        {!hasRequiredKeys && isIdle && <div className=\"pp-key-warning\">Set API keys in the sidebar to start enrichment</div>}\n\n        {/* Progress bar */}\n        <div className=\"pp-progress-section\">\n          <div className=\"pp-progress-header\">\n            <span className=\"pp-progress-completed\">\n              {progress.completed} / {progress.total} tasks\n            </span>\n            <span className=\"pp-progress-percent\">{progressPercent}%</span>\n          </div>\n          <div className=\"illuminator-progress\">\n            <div className=\"illuminator-progress-bar\" style={{\n            \"--pp-bar-width\": `${progressPercent}%`\n          }} />\n          </div>\n        </div>\n\n        {/* Current task */}\n        {runningTasks.length > 0 && <div className=\"pp-current-task\">\n            <div className=\"pp-current-task-label\">Currently processing:</div>\n            {runningTasks.map(task => <div key={task.id} className=\"pp-current-task-item\">\n                {task.entityName} - {task.type}\n              </div>)}\n          </div>}\n\n        {/* Stats */}\n        <div className=\"pp-stats-grid\">\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{completedTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-completed\">Completed</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{runningTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-running\">Running</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{pendingTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-pending\">Pending</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className={`pp-stat-value${errorTasks.length > 0 ? \" pp-stat-value-danger\" : \"\"}`}>\n              {errorTasks.length}\n            </div>\n            <div className=\"pp-stat-label pp-stat-label-errors\">Errors</div>\n          </div>\n        </div>\n      </div>\n\n      {/* Error log */}\n      {errorTasks.length > 0 && <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title pp-error-title\">Errors ({errorTasks.length})</h2>\n          </div>\n          <div className=\"pp-error-list\">\n            {errorTasks.map(task => <div key={task.id} className=\"pp-error-item\">\n                <div className=\"pp-error-item-name\">\n                  {task.entityName} - {task.type}\n                </div>\n                <div className=\"pp-error-item-message\">{task.error || \"Unknown error\"}</div>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* Completion message */}\n      {isComplete && <div className=\"illuminator-card\">\n          <div className=\"pp-complete-section\">\n            <div className=\"pp-complete-icon\">&#x2728;</div>\n            <div className=\"pp-complete-title\">Enrichment Complete!</div>\n            <div className=\"pp-complete-summary\">\n              {completedTasks.length} tasks completed\n              {errorTasks.length > 0 && `, ${errorTasks.length} errors`}\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}", "type": "{ status: any; progress: any; tasks: any; onPause: any; onResume: any; onAbort: any; onRunAll: any; hasRequiredKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/QuickCheckModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/QuickCheckModal.jsx", "sourceCode": "// ---------------------------------------------------------------------------\n// QuickCheckModal\n// ---------------------------------------------------------------------------\n\nexport default function QuickCheckModal({\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}) {\n  if (!report) return null;\n  const {\n    suspects,\n    assessment,\n    summary\n  } = report;\n  return <div className=\"qcm-overlay\" onClick={e => {\n    if (e.target === e.currentTarget) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"qcm-dialog\">\n        {/* Header */}\n        <div className=\"qcm-header\">\n          <div>\n            <div className=\"qcm-header-title\">Quick Check \u2014 Unanchored References</div>\n            <div className=\"qcm-header-subtitle\">\n              <span className=\"qcm-assessment-label\"\n            style={{\n              \"--qcm-assessment-color\": ASSESSMENT_COLORS[assessment] || \"var(--text-muted)\"\n            }}>\n                {ASSESSMENT_LABELS[assessment] || assessment}\n              </span>{\" \"}\n              &bull; {suspects.length} suspect{suspects.length !== 1 ? \"s\" : \"\"}\n            </div>\n          </div>\n          <button onClick={onClose} className=\"qcm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Summary */}\n        <div className=\"qcm-summary\">{summary}</div>\n\n        {/* Suspects list */}\n        <div className=\"qcm-suspects-list\">\n          {suspects.length === 0 ? <div className=\"qcm-empty-message\">No unanchored references detected.</div> : suspects.map((suspect, i) => <SuspectCard key={i} suspect={suspect} entities={entities} onCreateEntity={onCreateEntity} />)}\n        </div>\n\n        {/* Footer */}\n        <div className=\"qcm-footer\">\n          <button onClick={onClose} className=\"illuminator-button qcm-footer-btn\">\n            Dismiss\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}", "type": "{ report: any; entities: any; onCreateEntity: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ResultsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ResultsPanel.jsx", "sourceCode": "export default function ResultsPanel({ tasks, entities = [], onRegenerateTask }) {\n  const [selectedEntities, setSelectedEntities] = useState(new Set());\n  const [previewImage, setPreviewImage] = useState(null);\n  const [filterType, setFilterType] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    const values = (entities || [])\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [entities]);\n\n  // Get entities with completed tasks\n  const enrichedEntities = useMemo(() => {\n    const entityMap = new Map();\n\n    // Build entity map from world data\n    for (const entity of entities || []) {\n      entityMap.set(entity.id, { ...entity, tasks: [] });\n    }\n\n    // Add tasks to entities\n    for (const task of tasks) {\n      if (task.status === \"complete\" && entityMap.has(task.entityId)) {\n        entityMap.get(task.entityId).tasks.push(task);\n      }\n    }\n\n    // Filter to only entities with completed tasks\n    return Array.from(entityMap.values()).filter((e) => e.tasks.length > 0);\n  }, [entities, tasks]);\n\n  // Apply filter\n  const filteredEntities = useMemo(() => {\n    if (filterType === \"all\") return enrichedEntities;\n    return enrichedEntities.filter((e) => e.tasks.some((t) => t.type === filterType));\n  }, [enrichedEntities, filterType]);\n\n  const toggleSelect = (entityId) => {\n    setSelectedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const regenerateSelected = () => {\n    const taskIds = [];\n    for (const entityId of selectedEntities) {\n      const entity = enrichedEntities.find((e) => e.id === entityId);\n      if (entity) {\n        for (const task of entity.tasks) {\n          taskIds.push(task.id);\n        }\n      }\n    }\n    if (taskIds.length > 0) {\n      onRegenerateTask(taskIds);\n    }\n  };\n\n  const totalImages = tasks.filter((t) => t.type === \"image\" && t.status === \"complete\").length;\n  const totalDescriptions = tasks.filter(\n    (t) => t.type === \"description\" && t.status === \"complete\"\n  ).length;\n\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Results</h2>\n          <span className=\"rp-autosave-note\">Changes auto-save to current slot</span>\n        </div>\n\n        {enrichedEntities.length === 0 ? (\n          <div className=\"rp-empty-state\">\n            No enrichment results yet. Run some tasks to see results here.\n          </div>\n        ) : (\n          <>\n            {/* Stats */}\n            <div className=\"rp-stats-bar\">\n              <div>\n                <span className=\"rp-stat-value\">{enrichedEntities.length}</span>\n                <span className=\"rp-stat-label\">entities</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalDescriptions}</span>\n                <span className=\"rp-stat-label\">descriptions</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalImages}</span>\n                <span className=\"rp-stat-label\">images</span>\n              </div>\n\n              <div className=\"rp-filter-wrapper\">\n                <select\n                  value={filterType}\n                  onChange={(e) => setFilterType(e.target.value)}\n                  className=\"illuminator-select rp-filter-select\"\n                >\n                  <option value=\"all\">All Types</option>\n                  <option value=\"description\">Descriptions</option>\n                  <option value=\"image\">Images</option>\n                </select>\n              </div>\n            </div>\n\n            {/* Entity cards */}\n            <div>\n              {filteredEntities.map((entity) => (\n                <EntityResultCard\n                  key={entity.id}\n                  entity={entity}\n                  tasks={entity.tasks}\n                  selected={selectedEntities.has(entity.id)}\n                  onToggleSelect={() => toggleSelect(entity.id)}\n                  onRegenerate={onRegenerateTask}\n                  onPreviewImage={setPreviewImage}\n                  prominenceScale={effectiveProminenceScale}\n                />\n              ))}\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Selection actions */}\n      {selectedEntities.size > 0 && (\n        <div className=\"rp-selection-bar\">\n          <span className=\"rp-selection-count\">\n            {selectedEntities.size} entit{selectedEntities.size !== 1 ? \"ies\" : \"y\"} selected\n          </span>\n          <div className=\"rp-selection-actions\">\n            <button\n              onClick={() => setSelectedEntities(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button onClick={regenerateSelected} className=\"illuminator-button\">\n              Regenerate Selected\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Image preview modal */}\n      <ImagePreviewModal imageUrl={previewImage} onClose={() => setPreviewImage(null)} />\n    </div>\n  );\n}", "parameters": [{"name": "{ tasks, entities = [], onRegenerateTask }", "type": "{ tasks: any; entities?: any[]; onRegenerateTask: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx", "sourceCode": "export default function RevisionFilterModal({\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}) {\n  const [excludeChronicle, setExcludeChronicle] = useState(true);\n\n  if (!isOpen) return null;\n\n  const available = excludeChronicle ? totalEligible - usedInChronicles : totalEligible;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary rfm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={() => onStart(excludeChronicle)}\n        disabled={available === 0}\n        className=\"illuminator-button illuminator-button-primary rfm-footer-btn\"\n      >\n        Start Revision ({available} entities)\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Revise Entity Summaries\" className=\"rfm-dialog\" footer={footer}>\n      <p className=\"rfm-subtitle\">\n        Rewrite summaries and descriptions with full world context.\n      </p>\n\n      {/* Counts */}\n      <div className=\"rfm-counts-grid\">\n        <span className=\"rfm-count-label\">Total eligible entities</span>\n        <span className=\"rfm-count-value\">{totalEligible}</span>\n\n        <span className=\"rfm-count-label\">Used in chronicles</span>\n        <span\n          className={`rfm-count-value ${usedInChronicles > 0 ? \"rfm-count-value-warning\" : \"rfm-count-value-muted\"}`}\n        >\n          {usedInChronicles}\n        </span>\n\n        <span className=\"rfm-count-label rfm-count-label-total\">Available for revision</span>\n        <span className=\"rfm-count-value\">{available}</span>\n      </div>\n\n      {/* Chronicle filter toggle */}\n      {usedInChronicles > 0 && (\n        // eslint-disable-next-line jsx-a11y/label-has-associated-control\n        <label className=\"rfm-filter-toggle\">\n          <input\n            type=\"checkbox\"\n            checked={excludeChronicle}\n            onChange={(e) => setExcludeChronicle(e.target.checked)}\n            className=\"rfm-filter-checkbox\"\n          />\n          <div>\n            <div className=\"rfm-filter-title\">Exclude entities used in chronicles</div>\n            <div className=\"rfm-filter-description\">\n              Recommended. Prevents inconsistency between rewritten descriptions and existing\n              chronicle text.\n            </div>\n          </div>\n        </label>\n      )}\n\n      {available === 0 && (\n        <div className=\"rfm-warning\">\n          No entities available for revision with current filters.\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}", "type": "{ isOpen: any; totalEligible: any; usedInChronicles: any; onStart: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StaticPageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPageEditor.jsx", "sourceCode": "export default function StaticPageEditor({ page, projectId, onSave, onDelete, onPublishToggle }) {\n  const [title, setTitle] = useState(page?.title || \"\");\n  const [content, setContent] = useState(page?.content || \"\");\n  const [summary, setSummary] = useState(page?.summary || \"\");\n  const [showEntityPicker, setShowEntityPicker] = useState(false);\n  const [showImagePicker, setShowImagePicker] = useState(false);\n  const [isDirty, setIsDirty] = useState(false);\n  const saveTimeoutRef = useRef(null);\n\n  // Reset state when page changes\n  useEffect(() => {\n    setTitle(page?.title || \"\");\n    setContent(page?.content || \"\");\n    setSummary(page?.summary || \"\");\n    setIsDirty(false);\n  }, [page?.pageId]);\n\n  // Auto-save on changes (debounced)\n  useEffect(() => {\n    if (!isDirty || !page) return;\n\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    saveTimeoutRef.current = setTimeout(() => {\n      onSave({\n        title,\n        content,\n        summary: summary || undefined,\n      });\n      setIsDirty(false);\n    }, 1000);\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, [isDirty, title, content, summary, page, onSave]);\n\n  const handleTitleChange = (e) => {\n    setTitle(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleContentChange = (value) => {\n    setContent(value || \"\");\n    setIsDirty(true);\n  };\n\n  const handleSummaryChange = (e) => {\n    setSummary(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleEntityLinkSelect = useCallback((linkText) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + linkText);\n    setIsDirty(true);\n  }, []);\n\n  const handleImageSelect = useCallback((imageRef) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + \"\\n\\n\" + imageRef + \"\\n\\n\");\n    setIsDirty(true);\n  }, []);\n\n  const handleSaveNow = () => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n    onSave({\n      title,\n      content,\n      summary: summary || undefined,\n    });\n    setIsDirty(false);\n  };\n\n  if (!page) {\n    return (\n      <div className=\"static-page-editor-empty\">\n        <div className=\"static-page-editor-empty-icon\">&#x1F4DD;</div>\n        <div className=\"static-page-editor-empty-title\">Select a page to edit</div>\n        <div className=\"static-page-editor-empty-desc\">\n          Choose a page from the list or create a new one\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-page-editor\">\n      {/* Header with title and actions */}\n      <div className=\"static-page-editor-header\">\n        <input\n          type=\"text\"\n          value={title}\n          onChange={handleTitleChange}\n          placeholder=\"Page title...\"\n          className=\"static-page-title-input\"\n        />\n        <div className=\"static-page-editor-actions\">\n          <span\n            className={`static-page-status-badge ${page.status}`}\n            title={page.status === \"published\" ? \"Visible in Chronicler\" : \"Draft only\"}\n          >\n            {page.status}\n          </span>\n          {isDirty && <span className=\"static-page-dirty-indicator\">Unsaved</span>}\n          <button className=\"static-page-button\" onClick={handleSaveNow} disabled={!isDirty}>\n            Save\n          </button>\n          <button\n            className=\"static-page-button\"\n            onClick={() => onPublishToggle(page.status === \"published\" ? \"draft\" : \"published\")}\n          >\n            {page.status === \"published\" ? \"Unpublish\" : \"Publish\"}\n          </button>\n          <button className=\"static-page-button danger\" onClick={onDelete}>\n            Delete\n          </button>\n        </div>\n      </div>\n\n      {/* Summary input */}\n      <div className=\"static-page-summary-section\">\n        <label className=\"static-page-summary-label\">\n          Summary (shown in page lists):\n          <input\n            type=\"text\"\n            value={summary}\n            onChange={handleSummaryChange}\n            placeholder=\"Brief description of this page...\"\n            className=\"static-page-summary-input\"\n          />\n        </label>\n      </div>\n\n      {/* Custom toolbar */}\n      <div className=\"static-page-toolbar\">\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowEntityPicker(true)}\n          title=\"Insert entity link [[Entity Name]]\"\n        >\n          &#x1F517; Entity Link\n        </button>\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowImagePicker(true)}\n          title=\"Insert image reference\"\n        >\n          &#x1F5BC; Image\n        </button>\n        <span className=\"static-page-toolbar-hint\">\n          Use <code>[[Entity Name]]</code> to link to entities\n        </span>\n      </div>\n\n      {/* Markdown editor */}\n      <div className=\"static-page-editor-container\" data-color-mode=\"dark\">\n        <MDEditor\n          value={content}\n          onChange={handleContentChange}\n          preview=\"live\"\n          height={500}\n          visibleDragbar={false}\n        />\n      </div>\n\n      {/* Word count */}\n      <div className=\"static-page-editor-footer\">\n        <span className=\"static-page-word-count\">\n          {page.wordCount || 0} words \u2022 {page.linkedEntityIds?.length || 0} entity links\n        </span>\n        <span className=\"static-page-updated\">\n          Last updated: {new Date(page.updatedAt).toLocaleString()}\n        </span>\n      </div>\n\n      {/* Modals */}\n      {showEntityPicker && (\n        <EntityLinkPicker\n          onSelect={handleEntityLinkSelect}\n          onClose={() => setShowEntityPicker(false)}\n        />\n      )}\n      {showImagePicker && (\n        <ImageRefPicker\n          projectId={projectId}\n          onSelect={handleImageSelect}\n          onClose={() => setShowImagePicker(false)}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ page, projectId, onSave, onDelete, onPublishToggle }", "type": "{ page: any; projectId: any; onSave: any; onDelete: any; onPublishToggle: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx", "sourceCode": "export default function StaticPagesPanel({ projectId }) {\n  const [pages, setPages] = useState([]);\n  const [selectedPageId, setSelectedPageId] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // Load pages on mount and when projectId changes\n  useEffect(() => {\n    if (!projectId) {\n      setPages([]);\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    setLoading(true);\n    getStaticPagesForProject(projectId)\n      .then((loadedPages) => {\n        if (cancelled) return;\n        setPages(loadedPages);\n        setLoading(false);\n      })\n      .catch((err) => {\n        console.error(\"Failed to load static pages:\", err);\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId]);\n\n  const selectedPage = pages.find((p) => p.pageId === selectedPageId);\n\n  const handleCreatePage = useCallback(async () => {\n    if (!projectId) return;\n\n    try {\n      const newPage = await createStaticPage({\n        projectId,\n        title: \"Untitled Page\",\n        content: \"# Untitled Page\\n\\nStart writing here...\",\n      });\n      setPages((prev) => [newPage, ...prev]);\n      setSelectedPageId(newPage.pageId);\n    } catch (err) {\n      console.error(\"Failed to create page:\", err);\n    }\n  }, [projectId]);\n\n  const handleSavePage = useCallback(\n    async (updates) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, updates);\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to save page:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  const handleDeletePage = useCallback(async () => {\n    if (!selectedPageId) return;\n    if (!confirm(\"Are you sure you want to delete this page?\")) return;\n\n    try {\n      await deleteStaticPage(selectedPageId);\n      setPages((prev) => prev.filter((p) => p.pageId !== selectedPageId));\n      setSelectedPageId(null);\n    } catch (err) {\n      console.error(\"Failed to delete page:\", err);\n    }\n  }, [selectedPageId]);\n\n  const handlePublishToggle = useCallback(\n    async (newStatus) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, { status: newStatus });\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to update page status:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  if (loading) {\n    return (\n      <div className=\"static-pages-panel\">\n        <div className=\"static-pages-loading\">Loading pages...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-pages-panel\">\n      {/* Left sidebar: page list */}\n      <div className=\"static-pages-sidebar\">\n        <div className=\"static-pages-sidebar-header\">\n          <h3>Static Pages</h3>\n          <button className=\"static-page-button primary\" onClick={() => void handleCreatePage()}>\n            + New Page\n          </button>\n        </div>\n\n        <div className=\"static-pages-list\">\n          {pages.length === 0 ? (\n            <div className=\"static-pages-empty\">\n              <p>No pages yet.</p>\n              <p>Create a page to add custom content like culture overviews or lore articles.</p>\n            </div>\n          ) : (\n            pages.map((page) => (\n              <button\n                key={page.pageId}\n                className={`static-pages-list-item ${selectedPageId === page.pageId ? \"selected\" : \"\"}`}\n                onClick={() => setSelectedPageId(page.pageId)}\n              >\n                <span className=\"static-pages-list-title\">{page.title}</span>\n                <span className=\"static-pages-list-meta\">\n                  <span className={`static-pages-status-dot ${page.status}`} />\n                  {page.wordCount} words\n                </span>\n              </button>\n            ))\n          )}\n        </div>\n      </div>\n\n      {/* Right area: editor */}\n      <div className=\"static-pages-editor-area\">\n        <StaticPageEditor\n          page={selectedPage}\n          projectId={projectId}\n          onSave={handleSavePage}\n          onDelete={() => void handleDeletePage()}\n          onPublishToggle={handlePublishToggle}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StoragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StoragePanel.jsx", "sourceCode": "export default function StoragePanel({ projectId: _projectId }) {\n  const [images, setImages] = useState([]);\n  const [stats, setStats] = useState({ totalCount: 0, totalSize: 0, byProject: {} });\n  const [loading, setLoading] = useState(true);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [filterProject, setFilterProject] = useState(\"all\");\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [thumbnailUrls, setThumbnailUrls] = useState({});\n  const [downloadingIds, setDownloadingIds] = useState(new Set());\n  const [exportingPrompts, setExportingPrompts] = useState(false);\n  const [pageSize, setPageSize] = useState(DEFAULT_PAGE_SIZE);\n  const [pageIndex, setPageIndex] = useState(0);\n  const thumbnailUrlsRef = useRef({});\n\n  // Load images and stats\n  const loadData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const [allImages, storageStats] = await Promise.all([getAllImages(), getStorageStats()]);\n      setImages(allImages);\n      setStats(storageStats);\n    } catch (err) {\n      console.error(\"Failed to load storage data:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadData();\n  }, [loadData]);\n\n  useEffect(() => {\n    thumbnailUrlsRef.current = thumbnailUrls;\n  }, [thumbnailUrls]);\n\n  useEffect(() => {\n    return () => {\n      for (const url of Object.values(thumbnailUrlsRef.current)) {\n        URL.revokeObjectURL(url);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    setPageIndex(0);\n  }, [filterProject]);\n\n  // Filter images by project\n  const filteredImages = useMemo(() => {\n    if (filterProject === \"all\") return images;\n    return images.filter((img) => img.projectId === filterProject);\n  }, [images, filterProject]);\n\n  // Get unique project IDs\n  const projectIds = useMemo(() => {\n    const ids = new Set();\n    for (const img of images) {\n      if (img.projectId) ids.add(img.projectId);\n    }\n    return Array.from(ids).sort();\n  }, [images]);\n\n  const totalPages = Math.max(1, Math.ceil(filteredImages.length / pageSize));\n  const currentPage = Math.min(pageIndex, totalPages - 1);\n  const pageStart = currentPage * pageSize;\n  const pageEnd = pageStart + pageSize;\n  const visibleImages = useMemo(\n    () => filteredImages.slice(pageStart, pageEnd),\n    [filteredImages, pageStart, pageEnd]\n  );\n\n  useEffect(() => {\n    setPageIndex((prev) => Math.min(prev, Math.max(0, totalPages - 1)));\n  }, [totalPages]);\n\n  useEffect(() => {\n    const visibleIds = new Set(visibleImages.map((img) => img.imageId));\n    setThumbnailUrls((prev) => {\n      let changed = false;\n      const next = {};\n      for (const [imageId, url] of Object.entries(prev)) {\n        if (visibleIds.has(imageId)) {\n          next[imageId] = url;\n        } else {\n          URL.revokeObjectURL(url);\n          changed = true;\n        }\n      }\n      return changed ? next : prev;\n    });\n  }, [visibleImages]);\n\n  // Load thumbnail URLs for visible images only\n  useEffect(() => {\n    let active = true;\n    const loadThumbnails = async () => {\n      const newUrls = {};\n      for (const img of visibleImages) {\n        if (!thumbnailUrls[img.imageId]) {\n          try {\n            const result = await loadImage(img.imageId);\n            if (result?.url) {\n              newUrls[img.imageId] = result.url;\n            }\n          } catch {\n            // Ignore errors\n          }\n        }\n      }\n\n      if (active && Object.keys(newUrls).length > 0) {\n        setThumbnailUrls((prev) => ({ ...prev, ...newUrls }));\n      }\n    };\n\n    if (visibleImages.length > 0) {\n      loadThumbnails();\n    }\n\n    return () => {\n      active = false;\n    };\n  }, [visibleImages, thumbnailUrls]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((imageId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(imageId)) {\n        next.delete(imageId);\n      } else {\n        next.add(imageId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredImages.map((img) => img.imageId)));\n  }, [filteredImages]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  const handlePageSizeChange = useCallback((event) => {\n    setPageSize(Number(event.target.value));\n    setPageIndex(0);\n  }, []);\n\n  const handlePrevPage = useCallback(() => {\n    setPageIndex((prev) => Math.max(prev - 1, 0));\n  }, []);\n\n  const handleNextPage = useCallback(() => {\n    setPageIndex((prev) => Math.min(prev + 1, totalPages - 1));\n  }, [totalPages]);\n\n  // Delete single image\n  const handleDelete = useCallback(\n    async (imageId) => {\n      if (!window.confirm(\"Delete this image? This cannot be undone.\")) return;\n\n      try {\n        // Revoke thumbnail URL\n        if (thumbnailUrls[imageId]) {\n          URL.revokeObjectURL(thumbnailUrls[imageId]);\n          setThumbnailUrls((prev) => {\n            const next = { ...prev };\n            delete next[imageId];\n            return next;\n          });\n        }\n\n        await deleteImage(imageId);\n        setSelectedIds((prev) => {\n          const next = new Set(prev);\n          next.delete(imageId);\n          return next;\n        });\n        await loadData();\n      } catch (err) {\n        console.error(\"Failed to delete image:\", err);\n        alert(\"Failed to delete image\");\n      }\n    },\n    [loadData, thumbnailUrls]\n  );\n\n  // Delete selected images\n  const handleDeleteSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n    if (!window.confirm(`Delete ${selectedIds.size} selected images? This cannot be undone.`))\n      return;\n\n    try {\n      // Revoke thumbnail URLs\n      for (const id of selectedIds) {\n        if (thumbnailUrls[id]) {\n          URL.revokeObjectURL(thumbnailUrls[id]);\n        }\n      }\n      setThumbnailUrls((prev) => {\n        const next = { ...prev };\n        for (const id of selectedIds) {\n          delete next[id];\n        }\n        return next;\n      });\n\n      await deleteImages(Array.from(selectedIds));\n      setSelectedIds(new Set());\n      await loadData();\n    } catch (err) {\n      console.error(\"Failed to delete images:\", err);\n      alert(\"Failed to delete images\");\n    }\n  }, [selectedIds, loadData, thumbnailUrls]);\n\n  // Download single image\n  const handleDownload = useCallback(async (imageId, entityName) => {\n    setDownloadingIds((prev) => new Set(prev).add(imageId));\n    try {\n      const blob = await getImageBlob(imageId);\n      if (!blob) {\n        alert(\"Image not found\");\n        return;\n      }\n\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${entityName || imageId}.png`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download image:\", err);\n      alert(\"Failed to download image\");\n    } finally {\n      setDownloadingIds((prev) => {\n        const next = new Set(prev);\n        next.delete(imageId);\n        return next;\n      });\n    }\n  }, []);\n\n  // Download selected images as zip\n  const handleDownloadSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n\n    // Check if JSZip is available\n    let JSZip;\n    try {\n      JSZip = (await import(\"jszip\")).default;\n    } catch {\n      alert(\"Bulk download requires JSZip library. Please install it: npm install jszip\");\n      return;\n    }\n\n    setDownloadingIds(new Set(selectedIds));\n    try {\n      const zip = new JSZip();\n\n      for (const imageId of selectedIds) {\n        const blob = await getImageBlob(imageId);\n        if (blob) {\n          const img = images.find((i) => i.imageId === imageId);\n          const filename = img?.entityName\n            ? `${img.entityName.replace(/[^a-z0-9]/gi, \"_\")}.png`\n            : `${imageId}.png`;\n          zip.file(filename, blob);\n        }\n      }\n\n      const content = await zip.generateAsync({ type: \"blob\" });\n      const url = URL.createObjectURL(content);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = \"images.zip\";\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download images:\", err);\n      alert(\"Failed to download images\");\n    } finally {\n      setDownloadingIds(new Set());\n    }\n  }, [selectedIds, images]);\n\n  // Export prompt data for analysis\n  const handleExportPrompts = useCallback(async () => {\n    setExportingPrompts(true);\n// ... (truncated)", "parameters": [{"name": "{ projectId: _projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx", "sourceCode": "/**\n * Main StyleLibraryEditor component\n */\nexport default function StyleLibraryEditor({\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}) {\n  const [editingStyle, setEditingStyle] = useState(null);\n  const [editingType, setEditingType] = useState(null); // 'artistic' | 'composition' | 'narrative'\n  const [confirmReset, setConfirmReset] = useState(false);\n  const handleEditArtistic = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"artistic\");\n  }, []);\n  const handleEditComposition = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"composition\");\n  }, []);\n  const handleAddArtistic = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"artistic\");\n  }, []);\n  const handleAddComposition = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"composition\");\n  }, []);\n  const handleEditNarrative = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"narrative\");\n  }, []);\n  const handleAddNarrative = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"narrative\");\n  }, []);\n  const handleSaveStyle = useCallback(async (styleData, isNew) => {\n    if (editingType === \"artistic\") {\n      if (isNew) {\n        await onAddArtisticStyle(styleData);\n      } else {\n        await onUpdateArtisticStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"composition\") {\n      if (isNew) {\n        await onAddCompositionStyle(styleData);\n      } else {\n        await onUpdateCompositionStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"narrative\") {\n      if (isNew) {\n        await onAddNarrativeStyle(styleData);\n      } else {\n        await onUpdateNarrativeStyle(styleData.id, styleData);\n      }\n    }\n    setEditingStyle(null);\n    setEditingType(null);\n  }, [editingType, onAddArtisticStyle, onUpdateArtisticStyle, onAddCompositionStyle, onUpdateCompositionStyle, onAddNarrativeStyle, onUpdateNarrativeStyle]);\n  const handleDeleteArtistic = useCallback(async id => {\n    if (window.confirm(\"Delete this artistic style?\")) {\n      await onDeleteArtisticStyle(id);\n    }\n  }, [onDeleteArtisticStyle]);\n  const handleDeleteComposition = useCallback(async id => {\n    if (window.confirm(\"Delete this composition style?\")) {\n      await onDeleteCompositionStyle(id);\n    }\n  }, [onDeleteCompositionStyle]);\n  const handleDeleteNarrative = useCallback(async id => {\n    if (window.confirm(\"Delete this narrative style?\")) {\n      await onDeleteNarrativeStyle(id);\n    }\n  }, [onDeleteNarrativeStyle]);\n  const handleReset = useCallback(async () => {\n    await onReset();\n    setConfirmReset(false);\n  }, [onReset]);\n  const handleCloseModal = useCallback(() => {\n    setEditingStyle(null);\n    setEditingType(null);\n  }, []);\n  if (loading) {\n    return <div className=\"illuminator-card\">\n        <p className=\"style-editor-loading\">Loading style library...</p>\n      </div>;\n  }\n  return <div>\n      {/* Status bar */}\n      <div className=\"illuminator-card\">\n        <div className=\"style-editor-status-row\">\n          <div>\n            <span className=\"style-editor-status-label\">Style Library</span>\n            <span className=\"style-editor-status-sublabel\">\n              {isCustom ? \"(customized)\" : \"(defaults)\"}\n            </span>\n          </div>\n          <div>\n            {!confirmReset && <button onClick={() => setConfirmReset(true)} className=\"illuminator-btn style-editor-btn-sm\" title={isCustom ? \"Reload defaults and discard custom styles\" : \"Reload default styles\"}>\n                Reload Default Styles\n              </button>}\n            {confirmReset && <span className=\"style-editor-confirm-row\">\n                <span className=\"style-editor-confirm-text\">\n                  {isCustom ? \"Reload defaults and discard custom styles?\" : \"Reload default styles?\"}\n                </span>\n                <button onClick={handleReset} className=\"illuminator-btn illuminator-btn-danger style-editor-btn-sm\">\n                  Yes, Reload\n                </button>\n                <button onClick={() => setConfirmReset(false)} className=\"illuminator-btn style-editor-btn-sm\">\n                  Cancel\n                </button>\n              </span>}\n          </div>\n        </div>\n      </div>\n\n      {/* Artistic Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Artistic Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.artisticStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddArtistic} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Artistic styles define the visual rendering approach (e.g., oil painting, watercolor,\n          digital art).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.artisticStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"artistic\" onEdit={handleEditArtistic} onDelete={handleDeleteArtistic} style={style} />)}\n        </div>\n\n        {styleLibrary.artisticStyles.length === 0 && <p className=\"style-editor-empty\">No artistic styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Composition Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Composition Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.compositionStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddComposition} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Composition styles define framing and visual arrangement (e.g., portrait, establishing\n          shot, action scene).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.compositionStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"composition\" onEdit={handleEditComposition} onDelete={handleDeleteComposition} style={style} />)}\n        </div>\n\n        {styleLibrary.compositionStyles.length === 0 && <p className=\"style-editor-empty\">\n            No composition styles defined. Add one to get started.\n          </p>}\n      </div>\n\n      {/* Narrative Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Narrative Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.narrativeStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddNarrative} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Narrative styles define story structure, character selection, and prose tone for chronicle\n          generation.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.narrativeStyles.map(style => <NarrativeStyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        compositionStyles={styleLibrary.compositionStyles} onEdit={handleEditNarrative} onDelete={handleDeleteNarrative} style={style} />)}\n        </div>\n\n        {styleLibrary.narrativeStyles.length === 0 && <p className=\"style-editor-empty\">No narrative styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Scene Prompt Templates */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Cover Image Scene Prompts\n            <span className=\"style-editor-section-count\">({SCENE_PROMPT_TEMPLATES.length})</span>\n          </h2>\n        </div>\n        <p className=\"style-editor-description\">\n          Scene prompt templates direct the LLM on what kind of cover image scene to describe. Each\n          narrative style maps to one of these templates.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {SCENE_PROMPT_TEMPLATES.map(template => <div key={template.id} className=\"illuminator-style-card\">\n              <div className=\"illuminator-style-card-header\">\n                <div className=\"illuminator-style-card-title\">{template.name}</div>\n              </div>\n              <div className=\"illuminator-style-card-prompt\">\n                <strong>Framing:</strong> {template.framing}\n              </div>\n              <div className=\"illuminator-style-card-prompt style-editor-scene-prompt-instructions\">\n                <strong>Instructions:</strong> {template.instructions}\n              </div>\n            </div>)}\n        </div>\n      </div>\n\n      {/* Edit Modal for Artistic/Composition */}\n      {editingStyle && (editingType === \"artistic\" || editingType === \"composition\") && <StyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    type={editingType} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n\n      {/* Edit Modal for Narrative */}\n      {editingStyle && editingType === \"narrative\" && <NarrativeStyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    compositionStyles={styleLibrary.compositionStyles} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n    </div>;\n}", "parameters": [{"name": "{\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}", "type": "{ styleLibrary: any; loading: any; isCustom: any; onAddArtisticStyle: any; onUpdateArtisticStyle: any; onDeleteArtisticStyle: any; onAddCompositionStyle: any; onUpdateCompositionStyle: any; onDeleteCompositionStyle: any; onAddNarrativeStyle: any; onUpdateNarrativeStyle: any; onDeleteNarrativeStyle: any; onReset: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "export default function StyleSelector({\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}) {\n  const compositionId = useId();\n  const artisticStyles = styleLibrary?.artisticStyles || [];\n  const compositionStyles = styleLibrary?.compositionStyles || [];\n  const colorPalettes = styleLibrary?.colorPalettes || [];\n\n  // Filter composition styles based on entity kind (legacy suitableForKinds)\n  const filteredCompositionStyles = useMemo(() => {\n    if (!entityKind) {\n      return compositionStyles;\n    }\n    return compositionStyles.filter(\n      (s) =>\n        !s.suitableForKinds ||\n        s.suitableForKinds.length === 0 ||\n        s.suitableForKinds.includes(entityKind)\n    );\n  }, [compositionStyles, entityKind]);\n\n  // Group compositions by targetCategory for organized display\n  const groupedCompositions = useMemo(() => {\n    return groupCompositionsByCategory(filteredCompositionStyles);\n  }, [filteredCompositionStyles]);\n\n  const selectedArtistic = artisticStyles.find((s) => s.id === selectedArtisticStyleId);\n  const selectedComposition = compositionStyles.find((s) => s.id === selectedCompositionStyleId);\n  const selectedColorPalette = colorPalettes.find((s) => s.id === selectedColorPaletteId);\n\n  if (compact) {\n    return (\n      <div className=\"stsel-compact\">\n        <span className=\"stsel-compact-label\">Style:</span>\n        <select\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedArtistic?.description || \"Select artistic style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n\n        <select\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedComposition?.description || \"Select composition style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n\n        <select\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedColorPalette?.description || \"Select color palette\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"stsel-grid\">\n      {/* Artistic Style */}\n      <div>\n        <label htmlFor=\"artistic-style\" className=\"stsel-label\">Artistic Style</label>\n        <select id=\"artistic-style\"\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n        {selectedArtistic && (\n          <div className=\"stsel-description\">{selectedArtistic.description}</div>\n        )}\n      </div>\n\n      {/* Composition Style */}\n      <div>\n        <label htmlFor={compositionId} className=\"stsel-label\">\n          Composition Style{entityKind && ` (for ${entityKind})`}\n        </label>\n        <select id={compositionId}\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n        {selectedComposition && (\n          <div className=\"stsel-description\">{selectedComposition.description}</div>\n        )}\n      </div>\n\n      {/* Color Palette */}\n      <div>\n        <label htmlFor=\"color-palette\" className=\"stsel-label\">Color Palette</label>\n        <select id=\"color-palette\"\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n        {selectedColorPalette && (\n          <div className=\"stsel-description\">{selectedColorPalette.description}</div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}", "type": "{ styleLibrary: any; selectedArtisticStyleId: any; selectedCompositionStyleId: any; selectedColorPaletteId: any; onArtisticStyleChange: any; onCompositionStyleChange: any; onColorPaletteChange: any; entityKind: any; compact?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::resolveStyleSelection", "name": "resolveStyleSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "/**\n * Resolve style selection to actual style definitions\n * Handles culture defaults, random selection, exclusion filtering, and fallbacks\n */\nexport function resolveStyleSelection({\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}) {\n  const result = {\n    artisticStyle: null,\n    compositionStyle: null,\n    colorPalette: null,\n    cultureKeywords: [],\n  };\n\n  if (!styleLibrary) return result;\n\n  const artisticStyles = styleLibrary.artisticStyles || [];\n  const compositionStyles = styleLibrary.compositionStyles || [];\n  const colorPalettes = styleLibrary.colorPalettes || [];\n  const rules = exclusionRules || [];\n\n  // Filter composition styles by entity kind\n  const filteredCompositionStyles = entityKind\n    ? compositionStyles.filter(\n        (s) =>\n          !s.suitableForKinds ||\n          s.suitableForKinds.length === 0 ||\n          s.suitableForKinds.includes(entityKind)\n      )\n    : compositionStyles;\n\n  const styleIsRandom = selection.artisticStyleId === RANDOM_ID || !selection.artisticStyleId;\n  const compIsRandom = selection.compositionStyleId === RANDOM_ID || !selection.compositionStyleId;\n\n  if (\n    styleIsRandom &&\n    compIsRandom &&\n    selection.artisticStyleId !== NONE_ID &&\n    selection.compositionStyleId !== NONE_ID\n  ) {\n    // Both random: pick composition first, then filter styles for that composition\n    result.compositionStyle = pickRandom(filteredCompositionStyles);\n    if (result.compositionStyle && rules.length > 0) {\n      const filteredStyles = filterByExclusion(\n        artisticStyles,\n        result.compositionStyle.id,\n        rules,\n        artisticStyles,\n        compositionStyles,\n        \"style\"\n      );\n      result.artisticStyle = pickRandom(filteredStyles);\n    } else {\n      result.artisticStyle = pickRandom(artisticStyles);\n    }\n  } else {\n    // Resolve artistic style\n    if (selection.artisticStyleId === NONE_ID) {\n      result.artisticStyle = null;\n    } else if (styleIsRandom) {\n      // Style is random, composition is fixed \u2014 filter styles for fixed composition\n      const fixedCompId = selection.compositionStyleId;\n      if (fixedCompId && fixedCompId !== NONE_ID && rules.length > 0) {\n        const filteredStyles = filterByExclusion(\n          artisticStyles,\n          fixedCompId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"style\"\n        );\n        result.artisticStyle = pickRandom(filteredStyles);\n      } else {\n        result.artisticStyle = pickRandom(artisticStyles);\n      }\n    } else {\n      result.artisticStyle = artisticStyles.find((s) => s.id === selection.artisticStyleId);\n    }\n\n    // Resolve composition style\n    if (selection.compositionStyleId === NONE_ID) {\n      result.compositionStyle = null;\n    } else if (compIsRandom) {\n      // Composition is random, style is fixed \u2014 filter compositions for fixed style\n      const fixedStyleId = selection.artisticStyleId;\n      if (fixedStyleId && fixedStyleId !== NONE_ID && rules.length > 0) {\n        const filteredComps = filterByExclusion(\n          filteredCompositionStyles,\n          fixedStyleId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"composition\"\n        );\n        result.compositionStyle = pickRandom(filteredComps);\n      } else {\n        result.compositionStyle = pickRandom(filteredCompositionStyles);\n      }\n    } else {\n      result.compositionStyle = compositionStyles.find(\n        (s) => s.id === selection.compositionStyleId\n      );\n    }\n  }\n\n  // Resolve color palette (no culture default for palettes)\n  if (selection.colorPaletteId === NONE_ID) {\n    result.colorPalette = null;\n  } else if (selection.colorPaletteId === RANDOM_ID || !selection.colorPaletteId) {\n    result.colorPalette = pickRandom(colorPalettes);\n  } else {\n    result.colorPalette = colorPalettes.find((p) => p.id === selection.colorPaletteId);\n  }\n\n  // Get culture style keywords\n  const culture = cultures?.find((c) => c.id === entityCultureId);\n  if (culture?.styleKeywords?.length > 0) {\n    result.cultureKeywords = culture.styleKeywords;\n  }\n\n  return result;\n}", "parameters": [{"name": "{\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}", "type": "{ selection: any; entityCultureId: any; entityKind: any; cultures: any; styleLibrary: any; exclusionRules?: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/styleExclusions\").RandomExclusionRule[]; }", "optional": false}], "returnType": "{ artisticStyle: any; compositionStyle: any; colorPalette: any; cultureKeywords: any[]; }"}, {"id": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function SummaryRevisionModal({\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}) {\n  const scrollRef = useRef(null);\n  const [expandedIds, setExpandedIds] = useState(new Set());\n\n  // Auto-scroll on new content\n  useEffect(() => {\n    scrollRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.batches?.length, run?.currentBatchIndex, run?.status]);\n\n  // Reset expanded state when batch changes\n  useEffect(() => {\n    setExpandedIds(new Set());\n  }, [run?.currentBatchIndex, run?.status]);\n\n  // Build entity lookup from entity contexts\n  const [entityLookup, setEntityLookup] = useState(new Map());\n  useEffect(() => {\n    if (!run || !getEntityContexts) {\n      setEntityLookup(new Map());\n      return;\n    }\n    let cancelled = false;\n    const allIds = run.batches.flatMap((b) => b.entityIds);\n    Promise.resolve(getEntityContexts(allIds)).then((contexts) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const ctx of contexts) {\n        if (ctx) map.set(ctx.id, ctx);\n      }\n      setEntityLookup(map);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [run, getEntityContexts]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isBatchReviewing = run.status === \"batch_reviewing\";\n  const isRunReviewing = run.status === \"run_reviewing\";\n  const isFailed = run.status === \"failed\";\n\n  const currentBatch = run.batches[run.currentBatchIndex];\n  const totalBatches = run.batches.length;\n  const completedBatches = run.batches.filter(\n    (b) => b.status === \"complete\" || b.status === \"failed\"\n  ).length;\n\n  // Collect patches for display\n  const allPatches = isRunReviewing\n    ? run.batches.flatMap((b) => b.patches || [])\n    : currentBatch?.patches || [];\n\n  const acceptedCount = allPatches.filter((p) => run.patchDecisions[p.entityId] !== false).length;\n\n  const toggleExpand = (entityId) => {\n    setExpandedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) next.delete(entityId);\n      else next.add(entityId);\n      return next;\n    });\n  };\n\n  const expandAll = () => {\n    setExpandedIds(new Set(allPatches.map((p) => p.entityId)));\n  };\n\n  const collapseAll = () => {\n    setExpandedIds(new Set());\n  };\n\n  const handleExport = () => {\n    const text = buildExportText(allPatches, entityLookup, run.patchDecisions, descriptionBaseline);\n    const timestamp = Date.now();\n    downloadText(text, `revision-patches-${timestamp}.txt`);\n  };\n\n  return (\n    <div className=\"srm-overlay\">\n      <div className=\"srm-modal\">\n        {/* Header */}\n        <div className=\"srm-modal-header\">\n          <div>\n            <h2 className=\"srm-modal-title\">\n              Batch Revision\n              {currentBatch && !isRunReviewing && (\n                <span className=\"srm-modal-culture\">{currentBatch.culture}</span>\n              )}\n            </h2>\n            <p className=\"srm-modal-subtitle\">\n              {isRunReviewing\n                ? `All ${totalBatches} batches complete. Review and apply patches.`\n                : `Batch ${run.currentBatchIndex + 1} of ${totalBatches}`}\n              {completedBatches > 0 && !isRunReviewing && ` (${completedBatches} complete)`}\n            </p>\n          </div>\n          <div className=\"srm-modal-header-right\">\n            {run.totalActualCost > 0 && (\n              <span className=\"srm-modal-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary srm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"srm-modal-scroll\">\n          {isGenerating && (\n            <div className=\"srm-generating\">\n              <div className=\"srm-generating-label\">\n                Generating revisions for batch {run.currentBatchIndex + 1}...\n              </div>\n              {currentBatch && (\n                <div className=\"srm-generating-detail\">\n                  {currentBatch.culture} ({currentBatch.entityIds.length} entities)\n                </div>\n              )}\n            </div>\n          )}\n\n          {isFailed && currentBatch?.error && <div className=\"srm-error\">{currentBatch.error}</div>}\n\n          {/* Patches */}\n          {allPatches.length > 0 && (\n            <div>\n              <div className=\"srm-patches-toolbar\">\n                <span className=\"srm-patches-count\">\n                  {allPatches.length} entities revised\n                  <span className=\"srm-patches-accepted\">{acceptedCount} accepted</span>\n                </span>\n                <div className=\"srm-patches-actions\">\n                  <button onClick={handleExport} className=\"srm-toolbar-btn\">\n                    Export\n                  </button>\n                  <button onClick={expandAll} className=\"srm-toolbar-btn\">\n                    Expand all\n                  </button>\n                  <button onClick={collapseAll} className=\"srm-toolbar-btn\">\n                    Collapse all\n                  </button>\n                </div>\n              </div>\n              {allPatches.map((patch) => (\n                <PatchCard\n                  key={patch.entityId}\n                  patch={patch}\n                  currentEntity={entityLookup.get(patch.entityId)}\n                  accepted={run.patchDecisions[patch.entityId]}\n                  onToggle={onTogglePatch}\n                  expanded={expandedIds.has(patch.entityId)}\n                  onToggleExpand={() => toggleExpand(patch.entityId)}\n                  onUpdateAnchorPhrase={onUpdateAnchorPhrase}\n                  descriptionBaseline={descriptionBaseline}\n                />\n              ))}\n            </div>\n          )}\n\n          {(isBatchReviewing || isRunReviewing) && allPatches.length === 0 && (\n            <div className=\"srm-no-patches\">No changes suggested for this batch.</div>\n          )}\n\n          <div ref={scrollRef} />\n        </div>\n\n        {/* Footer */}\n        <div className=\"srm-modal-footer\">\n          {isBatchReviewing && (\n            <>\n              <button\n                onClick={onAutoContine}\n                className=\"illuminator-button illuminator-button-secondary srm-footer-btn\"\n              >\n                Auto-Continue All\n              </button>\n              <button\n                onClick={onContinue}\n                className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n              >\n                {run.currentBatchIndex + 1 < totalBatches\n                  ? `Continue to Batch ${run.currentBatchIndex + 2}`\n                  : \"Finish Review\"}\n              </button>\n            </>\n          )}\n          {isRunReviewing && (\n            <button\n              onClick={onAccept}\n              className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n            >\n              Apply Accepted ({acceptedCount})\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}", "type": "{ run: any; isActive: any; onContinue: any; onAutoContine: any; onTogglePatch: any; onAccept: any; onCancel: any; getEntityContexts: any; onUpdateAnchorPhrase: any; descriptionBaseline: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx", "sourceCode": "export default function ToneAssignmentPreviewModal({\n  preview,\n  onApply,\n  onClose\n}) {\n  const [entries, setEntries] = useState(preview?.entries ?? []);\n  const distribution = useMemo(() => {\n    const counts = Object.fromEntries(ANNOTATION_TONES.map(t => [t, 0]));\n    for (const e of entries) {\n      if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n    }\n    return counts;\n  }, [entries]);\n  if (!preview) return null;\n  const maxCount = Math.max(1, ...Object.values(distribution));\n  const shiftedCount = entries.filter(e => e.wasShifted).length;\n  const handleToneChange = (chronicleId, newTone) => {\n    setEntries(prev => prev.map(e => e.chronicleId === chronicleId ? {\n      ...e,\n      assignedTone: newTone,\n      wasShifted: newTone !== e.ranking[0]\n    } : e));\n  };\n  const footer = <>\n      <button onClick={onClose} className=\"illuminator-button tapm-footer-btn\">\n        Cancel\n      </button>\n      <button onClick={() => onApply(entries)} className=\"illuminator-button illuminator-button-primary tapm-footer-btn\">\n        Apply ({entries.length} assignments)\n      </button>\n    </>;\n  return <ModalShell onClose={onClose} title=\"Tone Assignment\" className=\"tapm-modal\" footer={footer}>\n      <span className=\"tapm-subtitle\">\n        {entries.length} chronicles\n        {shiftedCount > 0 && ` \u00b7 ${shiftedCount} shifted`}\n      </span>\n\n      {/* Distribution chart */}\n      <div className=\"tapm-distribution\">\n        <div className=\"tapm-section-label\">Distribution</div>\n        <div className=\"tapm-chart\">\n          {ANNOTATION_TONES.map(tone => {\n          const count = distribution[tone] || 0;\n          const meta = TONE_META[tone];\n          const pct = maxCount > 0 ? count / maxCount * 100 : 0;\n          return <div key={tone} className=\"tapm-chart-row\">\n                <span className=\"tapm-chart-symbol\"\n            style={{\n              \"--tapm-symbol-color\": TONE_COLORS[tone]\n            }}>\n                  {meta?.symbol || \"?\"}\n                </span>\n                <span className=\"tapm-chart-label\">{meta?.label || tone}</span>\n                <div className=\"tapm-chart-bar-track\">\n                  <div className=\"tapm-chart-bar-fill\"\n              style={{\n                \"--tapm-bar-color\": TONE_COLORS[tone] || \"#888\",\n                \"--tapm-bar-width\": `${pct}%`\n              }} />\n                </div>\n                <span className=\"tapm-chart-count\">{count}</span>\n              </div>;\n        })}\n        </div>\n      </div>\n\n      {/* Chronicle list */}\n      <div className=\"tapm-section-label tapm-section-label-assignments\">Assignments</div>\n      <div className=\"tapm-list\">\n        {entries.map(entry => <div key={entry.chronicleId} className={`tapm-entry ${entry.wasShifted ? \"tapm-entry-shifted\" : \"\"}`}>\n            {/* Title */}\n            <div className=\"tapm-entry-title\">{entry.title}</div>\n\n            {/* Ranking display */}\n            <div className=\"tapm-ranking\">\n              {entry.ranking.map((tone, rank) => {\n            const meta = TONE_META[tone];\n            const isAssigned = tone === entry.assignedTone;\n            return <span key={rank} title={`#${rank + 1}: ${meta?.label || tone}`} className={`tapm-rank-chip ${isAssigned ? \"tapm-rank-chip-assigned\" : \"tapm-rank-chip-unassigned\"} ${rank === 1 ? \"tapm-rank-chip-rank2\" : \"\"} ${rank >= 2 ? \"tapm-rank-chip-rank3\" : \"\"}`}\n            onClick={() => handleToneChange(entry.chronicleId, tone)} role=\"button\" tabIndex={0} onKeyDown={e => {\n              if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n            }} style={{\n              \"--tapm-chip-bg\": isAssigned ? TONE_COLORS[tone] : \"transparent\"\n            }}>\n                    {meta?.symbol || \"?\"}\n                  </span>;\n          })}\n            </div>\n\n            {/* Shifted indicator */}\n            {entry.wasShifted && <span title=\"Shifted from rank 1 for distribution balance\" className=\"tapm-shifted-label\">\n                shifted\n              </span>}\n          </div>)}\n      </div>\n    </ModalShell>;\n}", "parameters": [{"name": "{\n  preview,\n  onApply,\n  onClose\n}", "type": "{ preview: any; onApply: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx", "sourceCode": "export default function TraitPaletteSection({\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}: Readonly<TraitPaletteSectionProps>) {\n  // Filter to valid, unique entity kinds\n  const entityKinds = useMemo(\n    () => [...new Set((rawEntityKinds || []).filter((k) => k && typeof k === \"string\"))],\n    // Use joined string as stable key since parent creates new array each render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [(rawEntityKinds || []).join(\",\")]\n  );\n\n  const [palettes, setPalettes] = useState<Record<string, TraitPalette | null>>({});\n  const [loading, setLoading] = useState(true);\n  const [selectedKind, setSelectedKind] = useState<string | null>(null);\n\n  // Stable key for entityKinds to use in dependencies\n  const entityKindsKey = entityKinds.join(\",\");\n\n  // Track which kinds have pending/running tasks\n  const expandingKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const item of queue) {\n      if (\n        item.type === \"paletteExpansion\" &&\n        item.paletteEntityKind &&\n        (item.status === \"queued\" || item.status === \"running\")\n      ) {\n        kinds.add(item.paletteEntityKind);\n      }\n    }\n    return kinds;\n  }, [queue]);\n\n  // Track completed tasks to refresh palettes\n  const completedPaletteTaskIds = useMemo(() => {\n    return queue\n      .filter((item) => item.type === \"paletteExpansion\" && item.status === \"complete\")\n      .map((item) => item.id);\n  }, [queue]);\n\n  // Load all palettes\n  const loadPalettes = useCallback(async () => {\n    setLoading(true);\n    try {\n      const loaded: Record<string, TraitPalette | null> = {};\n      for (const kind of entityKinds) {\n        loaded[kind] = await getPalette(projectId, kind);\n      }\n      setPalettes(loaded);\n    } catch (err) {\n      console.error(\"Failed to load palettes:\", err);\n    } finally {\n      setLoading(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [projectId, entityKindsKey]);\n\n  useEffect(() => {\n    void loadPalettes();\n  }, [loadPalettes]);\n\n  // Refresh palettes when a palette expansion task completes\n  const lastCompletedRef = useMemo(() => ({ ids: new Set<string>() }), []);\n  useEffect(() => {\n    const newCompletions = completedPaletteTaskIds.filter((id) => !lastCompletedRef.ids.has(id));\n    if (newCompletions.length > 0) {\n      for (const id of newCompletions) {\n        lastCompletedRef.ids.add(id);\n      }\n      void loadPalettes();\n    }\n  }, [completedPaletteTaskIds, lastCompletedRef, loadPalettes]);\n\n  // Expand palette for a specific kind via queue\n  const handleExpand = useCallback(\n    (entityKind: string) => {\n      if (!isWorkerReady) {\n        alert(\"Worker not ready. Please wait...\");\n        return;\n      }\n\n      // Create a synthetic entity for the queue (palette expansion is not entity-specific)\n      const syntheticEntity: EnrichedEntity = {\n        id: `palette_${entityKind}`,\n        name: `Palette: ${entityKind}`,\n        kind: entityKind,\n        subtype: \"\",\n        prominence: \"recognized\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      // Filter cultures to those with visual identities (more useful for grounding)\n      const cultureContext = cultures\n        .filter((c) => c.name && (c.visualIdentity || c.description))\n        .map((c) => ({\n          name: c.name,\n          description: c.description,\n          visualIdentity: c.visualIdentity,\n        }));\n\n      // Get subtypes for this kind\n      const subtypes = subtypesByKind[entityKind] || [];\n\n      enqueue([\n        {\n          entity: syntheticEntity,\n          type: \"paletteExpansion\",\n          prompt: \"\", // Not used - worker builds prompt from paletteEntityKind + paletteWorldContext\n          paletteEntityKind: entityKind,\n          paletteWorldContext: worldContext || \"A fantasy world with diverse entities.\",\n          paletteSubtypes: subtypes.length > 0 ? subtypes : undefined,\n          paletteEras: eras.length > 0 ? eras : undefined,\n          paletteCultureContext: cultureContext.length > 0 ? cultureContext : undefined,\n        },\n      ]);\n    },\n    [isWorkerReady, enqueue, worldContext, subtypesByKind, eras, cultures]\n  );\n\n  // Export all palettes\n  const handleExport = useCallback(async () => {\n    try {\n      const allPalettes = await exportPalettes(projectId);\n      const json = JSON.stringify(allPalettes, null, 2);\n      const blob = new Blob([json], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `trait-palettes-${new Date().toISOString().split(\"T\")[0]}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to export palettes:\", err);\n      alert(\"Failed to export palettes\");\n    }\n  }, [projectId]);\n\n  // Count total categories\n  const totalCategories = Object.values(palettes).reduce(\n    (sum, p) => sum + (p?.items.length || 0),\n    0\n  );\n\n  // Find recent errors for palette expansion\n  const recentErrors = useMemo(() => {\n    return queue\n      .filter(\n        (item) =>\n          item.type === \"paletteExpansion\" && item.status === \"error\" && item.paletteEntityKind\n      )\n      .slice(-3); // Show last 3 errors\n  }, [queue]);\n\n  if (loading) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"tps-loading\">\n          Loading trait palettes...\n        </div>\n      </div>\n    );\n  }\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        </div>\n        <div className=\"tps-empty\">\n          No entity kinds available. Load a world with entity kinds defined to use trait palettes.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header\">\n        <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        <div className=\"tps-header-actions\">\n          <button\n            onClick={() => void handleExport()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n            disabled={totalCategories === 0}\n          >\n            Export\n          </button>\n          <button\n            onClick={() => void loadPalettes()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n          >\n            Refresh\n          </button>\n        </div>\n      </div>\n\n      <p className=\"tps-description\">\n        Trait palettes provide diverse visual directions for entity descriptions. Expand palettes to\n        generate new trait categories and reduce repetition.\n      </p>\n\n      {/* Summary stats */}\n      <div className=\"tps-stats-grid\">\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{entityKinds.length}</div>\n          <div className=\"tps-stat-label\">Entity Kinds</div>\n        </div>\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{totalCategories}</div>\n          <div className=\"tps-stat-label\">Total Categories</div>\n        </div>\n      </div>\n\n      {/* Per-kind palettes */}\n      <div className=\"tps-kind-list\">\n        {entityKinds.map((kind) => {\n          const palette = palettes[kind];\n          const isExpanding = expandingKinds.has(kind);\n          const isSelected = selectedKind === kind;\n\n          return (\n            <div\n              key={kind}\n              className=\"tps-kind-card\"\n            >\n              {/* Header row */}\n              <div\n                className=\"tps-kind-header\"\n                onClick={() => setSelectedKind(isSelected ? null : kind)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"tps-kind-header-left\">\n                  <code className=\"tps-kind-badge\">\n                    {kind || \"(unknown)\"}\n                  </code>\n                  <span className=\"tps-category-count\">\n                    {palette?.items.length || 0} categories\n                  </span>\n                </div>\n                <div className=\"tps-kind-header-right\">\n                  <button\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      if (!kind) {\n                        alert(\"Invalid entity kind\");\n                        return;\n                      }\n                      handleExpand(kind);\n                    }}\n                    className=\"illuminator-button illuminator-button-primary tps-expand-btn\"\n                    disabled={isExpanding || !isWorkerReady || !kind}\n                    title={\n                      !isWorkerReady ? \"Worker not ready\" : `Generate trait categories for ${kind}`\n                    }\n                  >\n                    {isExpanding ? \"Expanding...\" : \"Expand\"}\n                  </button>\n                  <span className={`tps-expand-icon ${isSelected ? \"tps-expand-icon-open\" : \"tps-expand-icon-closed\"}`}>\n                    \u25bc\n                  </span>\n                </div>\n              </div>\n\n              {/* Expanded content */}\n              {isSelected && (\n                <div className=\"tps-kind-body\">\n                  {!palette || palette.items.length === 0 ? (\n                    <div className=\"tps-kind-empty\">\n                      No palette categories yet. Click &quot;Expand Palette&quot; to generate some.\n                    </div>\n                  ) : (\n                    <div className=\"tps-palette-list\">\n                      {palette.items.map((item: PaletteItem) => (\n                        <div\n                          key={item.id}\n                          className=\"tps-palette-item\"\n                        >\n                          <div className=\"tps-palette-header\">\n                            <span className=\"tps-palette-category\">\n                              {item.category}\n                            </span>\n                            <span\n                              className={`tps-usage-badge ${item.timesUsed > 0 ? \"tps-usage-badge-used\" : \"tps-usage-badge-unused\"}`}\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}", "type": "Readonly<TraitPaletteSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx", "sourceCode": "export default function VisualIdentityPanel({\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}) {\n  // Collect all visual identity keys\n  const visualKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.visual || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.visual]);\n\n  // Collect all descriptive identity keys\n  const descriptiveKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.descriptive || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.descriptive]);\n\n  // Visual identity handlers\n  const handleVisualIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visual: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleVisualKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visualKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n\n  // Descriptive identity handlers\n  const handleDescriptiveIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptive: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleDescriptiveKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptiveKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  return <div className=\"illuminator-visual-identity-panel\">\n      {/* Visual Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Visual Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe visual traits for image prompts (clothing, species, architecture)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define visual characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.visual} onIdentitiesChange={handleVisualIdentitiesChange} allKeys={visualKeys} keyPlaceholder=\"KEY (e.g., ATTIRE)\" valuePlaceholder=\"e.g., fur parkas with bone jewelry\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which visual traits to include per entity kind\" defaultOpen={visualKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={visualKeys} keysByKind={cultureIdentities.visualKeysByKind} onKeysByKindChange={handleVisualKeysByKindChange} emptyMessage=\"No visual identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n\n      {/* Descriptive Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Descriptive Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe traits for text prompts (customs, speech patterns, values)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define descriptive characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.descriptive} onIdentitiesChange={handleDescriptiveIdentitiesChange} allKeys={descriptiveKeys} keyPlaceholder=\"KEY (e.g., CUSTOMS)\" valuePlaceholder=\"e.g., elaborate greeting rituals involving fish exchange\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which descriptive traits to include per entity kind\" defaultOpen={descriptiveKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={descriptiveKeys} keysByKind={cultureIdentities.descriptiveKeysByKind} onKeysByKindChange={handleDescriptiveKeysByKindChange} emptyMessage=\"No descriptive identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}", "type": "{ cultures: any; entityKinds: any; cultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/WorldContextEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/WorldContextEditor.jsx", "sourceCode": "export default function WorldContextEditor({\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}) {\n  const updateField = useCallback(\n    (field, value) => {\n      onWorldContextChange({ [field]: value });\n    },\n    [onWorldContextChange]\n  );\n\n  const parseDynamicsFile = useCallback((fileContent) => {\n    try {\n      const parsed = JSON.parse(fileContent);\n      if (!Array.isArray(parsed)) {\n        alert(\"Invalid dynamics file: expected a JSON array.\");\n        return;\n      }\n      const valid = parsed.every(\n        (d) => d && typeof d.id === \"string\" && typeof d.text === \"string\"\n      );\n      if (!valid) {\n        alert(\"Invalid dynamics file: each entry must have id and text strings.\");\n        return;\n      }\n      updateField(\"worldDynamics\", parsed);\n    } catch (err) {\n      alert(`Failed to parse dynamics JSON: ${err.message}`);\n    }\n  }, [updateField]);\n\n  const handleImportDynamicsJson = useCallback(() => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json\";\n    input.onchange = (e) => {\n      const file = e.target.files?.[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) => parseDynamicsFile(ev.target.result);\n      reader.readAsText(file);\n    };\n    input.click();\n  }, [parseDynamicsFile]);\n\n  return (\n    <div>\n      {/* Info Banner */}\n      <div className=\"wce-info-banner\">\n        <div className=\"wce-info-banner-title\">Entity context is built automatically</div>\n        <div className=\"wce-info-banner-desc\">\n          Relationships, cultural peers, faction members, and entity age are extracted from the\n          simulation data. This panel only configures world-level context that applies to all\n          entities.\n        </div>\n      </div>\n\n      {/* World Identity */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">World Identity</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"world-name\" className=\"illuminator-label\">World Name</label>\n          <input id=\"world-name\"\n            type=\"text\"\n            value={worldContext.name || \"\"}\n            onChange={(e) => updateField(\"name\", e.target.value)}\n            placeholder=\"e.g., The Frozen Realms of Aurora Berg\"\n            className=\"illuminator-input\"\n          />\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label className=\"illuminator-label\">World Description\n          <LocalTextArea\n            value={worldContext.description || \"\"}\n            onChange={(value) => updateField(\"description\", value)}\n            placeholder=\"Brief description of your world's setting, themes, and what makes it unique...\"\n            className=\"illuminator-input wce-textarea-description\"\n          />\n          </label>\n        </div>\n      </div>\n\n      {/* Species Constraint */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Species Constraint</h2>\n        </div>\n        <p className=\"wce-description-text\">\n          Rule for what species can appear in generated images. This is added as a SPECIES\n          REQUIREMENT at the top of image prompts to ensure all depicted figures match your world&apos;s\n          inhabitants.\n        </p>\n        <div className=\"illuminator-form-group\">\n          <LocalTextArea\n            value={worldContext.speciesConstraint || \"\"}\n            onChange={(value) => updateField(\"speciesConstraint\", value)}\n            placeholder=\"e.g., All depicted figures must be penguins or orcas. No humans exist in this world.\"\n            className=\"illuminator-input wce-textarea-tone\"\n          />\n        </div>\n      </div>\n\n      {/* World Context Configuration */}\n      <div className=\"wce-section-divider\">\n        <div className=\"wce-section-header\">\n          <h2 className=\"wce-section-title\">Chronicle Generation</h2>\n          <p className=\"wce-section-subtitle\">\n            Tone and facts for chronicle generation. Chronicles use perspective synthesis to create\n            focused, faceted views based on each chronicle&apos;s entity constellation.\n          </p>\n        </div>\n\n        {/* Canon Facts */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Canon Facts</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            World truths and generation constraints. Required facts must appear in perspective\n            facets. Generation constraints are always included verbatim and never faceted.\n          </p>\n          <div className=\"illuminator-form-group wce-form-group-mb16\">\n            <span className=\"illuminator-label\">Facet Range (optional)</span>\n            <div className=\"wce-facet-range-row\">\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.minCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    minCount: parsed,\n                  });\n                }}\n                placeholder=\"min (4)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n              <span className=\"wce-facet-range-separator\">to</span>\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.maxCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    maxCount: parsed,\n                  });\n                }}\n                placeholder=\"max (6)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n            </div>\n            <div className=\"wce-facet-range-hint\">\n              Range of world-truth facts to facet. Required facts count toward this; min is raised\n              to match required count if needed.\n            </div>\n          </div>\n          <FactsEditor\n            facts={worldContext.canonFactsWithMetadata || []}\n            onChange={(facts) => updateField(\"canonFactsWithMetadata\", facts)}\n          />\n        </div>\n\n        {/* World Dynamics */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header wce-dynamics-header\">\n            <h2 className=\"illuminator-card-title\">World Dynamics</h2>\n            <div className=\"wce-dynamics-actions\">\n              <button\n                onClick={handleImportDynamicsJson}\n                className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n              >\n                Import JSON\n              </button>\n              {worldContext.worldDynamics?.length > 0 && (\n                <button\n                  onClick={() => {\n                    const json = JSON.stringify(worldContext.worldDynamics, null, 2);\n                    const blob = new Blob([json], { type: \"application/json\" });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = `dynamics-${new Date().toISOString().slice(0, 10)}.json`;\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(url);\n                  }}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  Export JSON\n                </button>\n              )}\n              {onGenerateDynamics && (\n                <button\n                  onClick={onGenerateDynamics}\n                  disabled={isGeneratingDynamics}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  {isGeneratingDynamics ? \"Generating...\" : \"Generate from Lore\"}\n                </button>\n              )}\n            </div>\n          </div>\n          <p className=\"wce-description-text\">\n            Higher-level narrative context about inter-group forces and behaviors. These statements\n            describe macro-level dynamics that individual relationships are expressions of.\n            Optionally filter by culture or entity kind so they only appear in relevant chronicles.\n          </p>\n          <WorldDynamicsEditor\n            dynamics={worldContext.worldDynamics || []}\n            onChange={(dynamics) => updateField(\"worldDynamics\", dynamics)}\n            eras={eras}\n          />\n        </div>\n\n\n        {/* Tone Fragments */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Tone Fragments</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            Composable tone guidance. Core is always included; culture and kind overlays are added\n            based on the chronicle&apos;s entity constellation.\n          </p>\n          <ToneFragmentsEditor\n            fragments={worldContext.toneFragments || {}}\n            onChange={(fragments) => updateField(\"toneFragments\", fragments)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}", "type": "{ worldContext: any; onWorldContextChange: any; eras: any; onGenerateDynamics: any; isGeneratingDynamics: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/hooks/useApiKeys.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useApiKeys.js", "sourceCode": "export default function useApiKeys() {\n  const [persistApiKeys, setPersistApiKeys] = useState(() =>\n    readPersistedFlag(\"illuminator:persistApiKeys\")\n  );\n  const [anthropicApiKey, setAnthropicApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:anthropicApiKey\")\n  );\n  const [openaiApiKey, setOpenaiApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:openaiApiKey\")\n  );\n  const [showApiKeyInput, setShowApiKeyInput] = useState(false);\n\n  // Persist API keys when enabled\n  useEffect(() => {\n    try {\n      localStorage.setItem(\"illuminator:persistApiKeys\", persistApiKeys ? \"true\" : \"false\");\n      if (persistApiKeys) {\n        localStorage.setItem(\"illuminator:anthropicApiKey\", anthropicApiKey);\n        localStorage.setItem(\"illuminator:openaiApiKey\", openaiApiKey);\n      } else {\n        localStorage.removeItem(\"illuminator:anthropicApiKey\");\n        localStorage.removeItem(\"illuminator:openaiApiKey\");\n      }\n    } catch {\n      /* ignored */\n    }\n  }, [persistApiKeys, anthropicApiKey, openaiApiKey]);\n\n  const hasAnthropicKey = anthropicApiKey.length > 0;\n  const hasRequiredKeys = hasAnthropicKey;\n\n  return {\n    persistApiKeys,\n    setPersistApiKeys,\n    anthropicApiKey,\n    setAnthropicApiKey,\n    openaiApiKey,\n    setOpenaiApiKey,\n    showApiKeyInput,\n    setShowApiKeyInput,\n    hasAnthropicKey,\n    hasRequiredKeys,\n  };\n}", "parameters": [], "returnType": "{ persistApiKeys: boolean; setPersistApiKeys: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; anthropicApiKey: string; setAnthropicApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; openaiApiKey: string; setOpenaiApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; showApiKeyInput: boolean; setShowApiKeyInput: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; hasAnthropicKey: boolean; hasRequiredKeys: boolean; }"}, {"id": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts::deriveStatus", "name": "deriveStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts", "sourceCode": "/**\n * Derive status from what's present in the record.\n * This eliminates status synchronization issues.\n */\nexport function deriveStatus(record: ChronicleRecord | undefined): string {\n  if (!record) return \"not_started\";\n\n  if (record.status === \"failed\") return \"failed\";\n\n  // Check for in-progress states (worker is running)\n  if (record.status === \"generating\") {\n    return record.status;\n  }\n\n  // Derive from data presence (completed states)\n  if (record.finalContent || record.status === \"complete\") return \"complete\";\n  if (record.assembledContent) return \"assembly_ready\";\n\n  return \"not_started\";\n}", "parameters": [{"name": "record", "type": "ChronicleRecord | undefined", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/hooks/useConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useConfigSync.js", "sourceCode": "export default function useConfigSync({ externalEnrichmentConfig, onEnrichmentConfigChange }) {\n  const [localConfig, setLocalConfig] = useState(() =>\n    initializeEnrichmentConfig(externalEnrichmentConfig)\n  );\n  const pendingConfigSyncRef = useRef(null);\n  const skipConfigSyncRef = useRef(false);\n\n  // Detect external config changes during render (no ref access)\n  const [prevExternalConfig, setPrevExternalConfig] = useState(externalEnrichmentConfig);\n  if (externalEnrichmentConfig !== prevExternalConfig) {\n    setPrevExternalConfig(externalEnrichmentConfig);\n    if (externalEnrichmentConfig) {\n      setLocalConfig(normalizeEnrichmentConfig(externalEnrichmentConfig) || DEFAULT_CONFIG);\n    }\n  }\n\n  // Mark skip flag in effect (runs before sync effect due to declaration order)\n  useEffect(() => {\n    if (externalEnrichmentConfig) {\n      skipConfigSyncRef.current = true;\n      pendingConfigSyncRef.current = null;\n    }\n  }, [externalEnrichmentConfig]);\n\n  const config = localConfig;\n\n  const setConfig = useCallback((updater) => {\n    setLocalConfig((prev) => {\n      const next = typeof updater === \"function\" ? updater(prev) : updater;\n      pendingConfigSyncRef.current = next;\n      return next;\n    });\n  }, []);\n\n  // Sync local changes to parent (or localStorage)\n  useEffect(() => {\n    if (skipConfigSyncRef.current) {\n      skipConfigSyncRef.current = false;\n      pendingConfigSyncRef.current = null;\n      return;\n    }\n    const pending = pendingConfigSyncRef.current;\n    if (!pending) return;\n    pendingConfigSyncRef.current = null;\n    if (onEnrichmentConfigChange) {\n      onEnrichmentConfigChange(pending);\n    } else {\n      try {\n        localStorage.setItem(\"illuminator:config\", JSON.stringify(pending));\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [localConfig, onEnrichmentConfigChange]);\n\n  const updateConfig = useCallback(\n    (updates) => {\n      setConfig((prev) => ({ ...prev, ...updates }));\n    },\n    [setConfig]\n  );\n\n  return { config, setConfig, updateConfig };\n}", "parameters": [{"name": "{ externalEnrichmentConfig, onEnrichmentConfigChange }", "type": "{ externalEnrichmentConfig: any; onEnrichmentConfigChange: any; }", "optional": false}], "returnType": "{ config: { imageModel: string; minProminenceForImage: string; numWorkers: number; requireDescription: boolean; useClaudeForImagePrompt: boolean; claudeImagePromptTemplate: string; globalImageRules: string; minEventSignificance: number; }; setConfig: (updater: any) => void; updateConfig: (updates: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useEntityCrud.ts::reloadEntities", "name": "reloadEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityCrud.ts", "sourceCode": "// ============================================================================\n// Module-level helper \u2014 reusable by other hooks without prop threading\n// ============================================================================\n\n/**\n * Refresh entity store and notify the host shell.\n * Reads simulationRunId imperatively from the entity store.\n */\nexport async function reloadEntities(invalidateIds?: string[]): Promise<void> {\n  const store = useEntityStore.getState();\n  const { simulationRunId } = store;\n  if (!simulationRunId) return;\n\n  if (invalidateIds?.length) {\n    await store.refreshEntities(invalidateIds);\n  } else {\n    await store.refreshAll();\n  }\n\n  window.dispatchEvent(\n    new CustomEvent(\"illuminator:worlddata-changed\", {\n      detail: { simulationRunId, scope: \"entities\" },\n    })\n  );\n}", "parameters": [{"name": "invalidateIds", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js", "sourceCode": "export default function useEntityGuidanceSync({\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}) {\n  const [localEntityGuidance, setLocalEntityGuidance] = useState(createDefaultEntityGuidance);\n  const [localCultureIdentities, setLocalCultureIdentities] = useState(\n    createDefaultCultureIdentities\n  );\n  const pendingEntityGuidanceRef = useRef(localEntityGuidance);\n  const pendingCultureIdentitiesRef = useRef(localCultureIdentities);\n\n  // Detect external changes during render (no ref access)\n  const [prevGuidance, setPrevGuidance] = useState(externalEntityGuidance);\n  if (externalEntityGuidance !== prevGuidance) {\n    setPrevGuidance(externalEntityGuidance);\n    if (externalEntityGuidance !== undefined) {\n      setLocalEntityGuidance(externalEntityGuidance || createDefaultEntityGuidance());\n    }\n  }\n  const [prevIdentities, setPrevIdentities] = useState(externalCultureIdentities);\n  if (externalCultureIdentities !== prevIdentities) {\n    setPrevIdentities(externalCultureIdentities);\n    if (externalCultureIdentities !== undefined) {\n      setLocalCultureIdentities(externalCultureIdentities || createDefaultCultureIdentities());\n    }\n  }\n\n  // Sync refs in effects\n  useEffect(() => {\n    if (externalEntityGuidance !== undefined) {\n      pendingEntityGuidanceRef.current = externalEntityGuidance || createDefaultEntityGuidance();\n    }\n  }, [externalEntityGuidance]);\n  useEffect(() => {\n    if (externalCultureIdentities !== undefined) {\n      pendingCultureIdentitiesRef.current =\n        externalCultureIdentities || createDefaultCultureIdentities();\n    }\n  }, [externalCultureIdentities]);\n\n  const entityGuidanceSyncTimeoutRef = useRef(null);\n  const updateEntityGuidance = useCallback(\n    (nextGuidance) => {\n      setLocalEntityGuidance(nextGuidance);\n      pendingEntityGuidanceRef.current = nextGuidance;\n      if (!onEntityGuidanceChange) return;\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      entityGuidanceSyncTimeoutRef.current = setTimeout(() => {\n        onEntityGuidanceChange(pendingEntityGuidanceRef.current);\n        entityGuidanceSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onEntityGuidanceChange]\n  );\n\n  const cultureIdentitiesSyncTimeoutRef = useRef(null);\n  const updateCultureIdentities = useCallback(\n    (nextIdentities) => {\n      setLocalCultureIdentities(nextIdentities);\n      pendingCultureIdentitiesRef.current = nextIdentities;\n      if (!onCultureIdentitiesChange) return;\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n      cultureIdentitiesSyncTimeoutRef.current = setTimeout(() => {\n        onCultureIdentitiesChange(pendingCultureIdentitiesRef.current);\n        cultureIdentitiesSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onCultureIdentitiesChange]\n  );\n\n  useEffect(\n    () => () => {\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n    },\n    []\n  );\n\n  return {\n    entityGuidance: localEntityGuidance,\n    updateEntityGuidance,\n    cultureIdentities: localCultureIdentities,\n    updateCultureIdentities,\n  };\n}", "parameters": [{"name": "{\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}", "type": "{ externalEntityGuidance: any; onEntityGuidanceChange: any; externalCultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "{ entityGuidance: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").EntityGuidance; updateEntityGuidance: (nextGuidance: any) => void; cultureIdentities: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").CultureIdentities; updateCultureIdentities: (nextIdentities: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useHistorianActions.ts::registerHistorianStarters", "name": "registerHistorianStarters", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianActions.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the primitive hook start functions.\n * The isActive flags are synced to useIlluminatorConfigStore instead.\n */\nexport function registerHistorianStarters(starters: HistorianStarters): void {\n  _starters = starters;\n}", "parameters": [{"name": "starters", "type": "HistorianStarters", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js", "sourceCode": "export default function useHistorianConfigSync({\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}) {\n  const [localHistorianConfig, setLocalHistorianConfig] = useState(() =>\n    resolveInitialHistorianConfig(externalHistorianConfig)\n  );\n  const [hasMigrated, setHasMigrated] = useState(false);\n  const pendingHistorianConfigRef = useRef(localHistorianConfig);\n\n  // Detect external changes during render (no ref access)\n  const [prevExternal, setPrevExternal] = useState(externalHistorianConfig);\n  if (externalHistorianConfig !== prevExternal) {\n    setPrevExternal(externalHistorianConfig);\n    if (externalHistorianConfig !== undefined) {\n      const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n      setLocalHistorianConfig(resolved.config);\n      if (resolved.migrated !== hasMigrated) setHasMigrated(resolved.migrated);\n    }\n  }\n\n  // Ref + side effects in effect (legacy migration, cleanup)\n  useEffect(() => {\n    if (externalHistorianConfig === undefined) return;\n    const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n    pendingHistorianConfigRef.current = resolved.config;\n    if (resolved.migrated && !externalHistorianConfig) {\n      if (onHistorianConfigChange) onHistorianConfigChange(resolved.config);\n      try {\n        localStorage.removeItem(LEGACY_HISTORIAN_CONFIG_KEY);\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [externalHistorianConfig, onHistorianConfigChange, hasMigrated]);\n\n  const historianConfigSyncTimeoutRef = useRef(null);\n  const updateHistorianConfig = useCallback(\n    (next) => {\n      setLocalHistorianConfig(next);\n      pendingHistorianConfigRef.current = next;\n      if (!onHistorianConfigChange) return;\n      if (historianConfigSyncTimeoutRef.current)\n        clearTimeout(historianConfigSyncTimeoutRef.current);\n      historianConfigSyncTimeoutRef.current = setTimeout(() => {\n        onHistorianConfigChange(pendingHistorianConfigRef.current);\n        historianConfigSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onHistorianConfigChange]\n  );\n\n  return { historianConfig: localHistorianConfig, updateHistorianConfig };\n}", "parameters": [{"name": "{\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}", "type": "{ externalHistorianConfig: any; onHistorianConfigChange: any; }", "optional": false}], "returnType": "{ historianConfig: any; updateHistorianConfig: (next: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useSlotManagement.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useSlotManagement.js", "sourceCode": "export default function useSlotManagement({ projectId, activeSlotIndex, navEntities }) {\n  const [slotRecord, setSlotRecord] = useState(null);\n\n  // Adjust state during render when projectId changes (avoids setState-in-effect)\n  const [prevProjectSlot, setPrevProjectSlot] = useState({ projectId, activeSlotIndex });\n  const projectSlotChange = resolveProjectSlotChange(projectId, prevProjectSlot, activeSlotIndex);\n  if (projectSlotChange.changed) {\n    setPrevProjectSlot({ projectId, activeSlotIndex });\n    if (projectSlotChange.clearSlot) setSlotRecord(null);\n  }\n\n  // Load slot metadata from Dexie (async work stays in effect)\n  useEffect(() => {\n    if (!projectId) return;\n    let cancelled = false;\n\n    (async () => {\n      const slot = await slotRepo.getSlot(projectId, activeSlotIndex);\n      if (cancelled) return;\n      setSlotRecord(slot || null);\n      useEntityStore.getState().reset();\n      useIndexStore.getState().reset();\n      useNarrativeEventStore.getState().reset();\n      useRelationshipStore.getState().reset();\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, activeSlotIndex]);\n\n  const [currentEra, setCurrentEra] = useState(null);\n\n  // Adjust current era during render for synchronous cases\n  const [prevEraKey, setPrevEraKey] = useState(slotRecord?.finalEraId);\n  const currentEraId = slotRecord?.finalEraId;\n  if (currentEraId !== prevEraKey) {\n    setPrevEraKey(currentEraId);\n    const result = resolveEraRenderAdjustment(slotRecord, navEntities);\n    if (result.changed) setCurrentEra(result.era);\n  }\n\n  // Async full-entity load for era (when we have a nav match but need description)\n  useEffect(() => {\n    const resolved = resolveCurrentEra(slotRecord, navEntities);\n    if (!resolved.needsFullLoad) return;\n    useEntityStore\n      .getState()\n      .loadEntity(resolved.needsFullLoad)\n      .then((full) => {\n        setCurrentEra(buildEraFromLoadedEntity(full, resolved.needsFullLoad));\n      });\n  }, [slotRecord, navEntities]);\n\n  const eraTemporalInfo = useEraTemporalInfo();\n  const eraTemporalInfoByKey = useEraTemporalInfoByKey();\n  const prominentByCulture = useProminentByCulture();\n\n  // Extract simulationRunId from slot metadata for content association\n  const simulationRunId = slotRecord?.simulationRunId;\n\n  return {\n    slotRecord,\n    setSlotRecord,\n    simulationRunId,\n    currentEra,\n    eraTemporalInfo,\n    eraTemporalInfoByKey,\n    prominentByCulture,\n  };\n}", "parameters": [{"name": "{ projectId, activeSlotIndex, navEntities }", "type": "{ projectId: any; activeSlotIndex: any; navEntities: any; }", "optional": false}], "returnType": "{ slotRecord: any; setSlotRecord: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<any>; simulationRunId: any; currentEra: any; eraTemporalInfo: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry[]; eraTemporalInfoByKey: Map<string, import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry>; prominentByCulture: Record<string, { id: string; name: string; }[]>; }"}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::assignCorpusTones", "name": "assignCorpusTones", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "/**\n * Assign tones to chronicles with strong rank-1 preference but distribution balancing.\n * Chronicles only shift from rank-1 if their preferred tone is heavily overrepresented\n * AND they have a good alternative that fills an underrepresented slot.\n */\nexport function assignCorpusTones(\n  chronicles: Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>\n): ToneAssignmentEntry[] {\n  const entries: ToneAssignmentEntry[] = chronicles.map((c) => ({\n    chronicleId: c.chronicleId,\n    title: c.title,\n    ranking: c.ranking,\n    assignedTone: c.ranking[0],\n    wasShifted: false,\n  }));\n\n  const target = entries.length / ANNOTATION_TONES.length;\n  const ceiling = Math.ceil(target * 1.2);\n\n  for (let round = 0; round < 50; round++) {\n    const counts = countDistribution(entries);\n\n    let overTone: HistorianTone | null = null;\n    let overCount = ceiling;\n    for (const t of ANNOTATION_TONES) {\n      if (counts[t] > overCount) {\n        overTone = t;\n        overCount = counts[t];\n      }\n    }\n    if (!overTone) break;\n\n    let shifted = false;\n    const candidates = entries\n      .filter((e) => e.assignedTone === overTone)\n      .map((e) => {\n        for (const altRank of [1, 2] as const) {\n          const alt = e.ranking[altRank];\n          if (alt && counts[alt] < counts[overTone]) {\n            return { entry: e, alt, priority: altRank * 100 + counts[alt] };\n          }\n        }\n        return null;\n      })\n      .filter(\n        (c): c is { entry: ToneAssignmentEntry; alt: HistorianTone; priority: number } => c !== null\n      )\n      .sort((a, b) => a.priority - b.priority);\n\n    if (candidates.length > 0) {\n      const best = candidates[0];\n      best.entry.assignedTone = best.alt;\n      best.entry.wasShifted = true;\n      shifted = true;\n    }\n\n    if (!shifted) break;\n  }\n\n  return entries;\n}", "parameters": [{"name": "chronicles", "type": "Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>", "optional": false}], "returnType": "ToneAssignmentEntry[]"}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::countDistribution", "name": "countDistribution", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "export function countDistribution(entries: ToneAssignmentEntry[]): Record<HistorianTone, number> {\n  const counts = Object.fromEntries(ANNOTATION_TONES.map((t) => [t, 0])) as Record<\n    HistorianTone,\n    number\n  >;\n  for (const e of entries) {\n    if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n  }\n  return counts;\n}", "parameters": [{"name": "entries", "type": "ToneAssignmentEntry[]", "optional": false}], "returnType": "Record<HistorianTone, number>"}, {"id": "apps/illuminator/webui/src/hooks/useWorldContextSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useWorldContextSync.js", "sourceCode": "export default function useWorldContextSync({ externalWorldContext, onWorldContextChange }) {\n  const [localWorldContext, setLocalWorldContext] = useState(DEFAULT_WORLD_CONTEXT);\n  const worldContext = localWorldContext;\n  const worldContextSyncTimeoutRef = useRef(null);\n  const worldContextDirtyRef = useRef(false);\n  const pendingWorldContextRef = useRef(localWorldContext);\n\n  // Detect external context changes during render (no ref access)\n  const [prevExternalContext, setPrevExternalContext] = useState(externalWorldContext);\n  if (externalWorldContext !== prevExternalContext) {\n    setPrevExternalContext(externalWorldContext);\n    if (externalWorldContext !== undefined) {\n      const nextContext = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n      setLocalWorldContext(nextContext);\n    }\n  }\n\n  // Ref side effects when external changes (clear timeout, update refs)\n  useEffect(() => {\n    if (externalWorldContext === undefined) return;\n    if (worldContextSyncTimeoutRef.current) {\n      clearTimeout(worldContextSyncTimeoutRef.current);\n      worldContextSyncTimeoutRef.current = null;\n    }\n    worldContextDirtyRef.current = false;\n    pendingWorldContextRef.current = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n  }, [externalWorldContext]);\n\n  const updateWorldContext = useCallback(\n    (updates) => {\n      setLocalWorldContext((prev) => {\n        const merged = { ...prev, ...updates };\n        pendingWorldContextRef.current = merged;\n        if (onWorldContextChange) {\n          worldContextDirtyRef.current = true;\n          if (worldContextSyncTimeoutRef.current) {\n            clearTimeout(worldContextSyncTimeoutRef.current);\n          }\n          worldContextSyncTimeoutRef.current = setTimeout(() => {\n            if (!worldContextDirtyRef.current) return;\n            worldContextDirtyRef.current = false;\n            onWorldContextChange(pendingWorldContextRef.current);\n            worldContextSyncTimeoutRef.current = null;\n          }, 300);\n        }\n        return merged;\n      });\n    },\n    [onWorldContextChange]\n  );\n\n  useEffect(() => {\n    return () => {\n      if (worldContextSyncTimeoutRef.current) {\n        clearTimeout(worldContextSyncTimeoutRef.current);\n        worldContextSyncTimeoutRef.current = null;\n      }\n      if (worldContextDirtyRef.current && onWorldContextChange) {\n        onWorldContextChange(pendingWorldContextRef.current);\n      }\n    };\n  }, [onWorldContextChange]);\n\n  return { worldContext, updateWorldContext };\n}", "parameters": [{"name": "{ externalWorldContext, onWorldContextChange }", "type": "{ externalWorldContext: any; onWorldContextChange: any; }", "optional": false}], "returnType": "{ worldContext: { name: string; description: string; toneFragments: { core: string; }; canonFactsWithMetadata: any[]; factSelection: {}; worldDynamics: any[]; }; updateWorldContext: (updates: any) => void; }"}, {"id": "apps/illuminator/webui/src/lib/annotateEntityNames.ts::annotateEntityNames", "name": "annotateEntityNames", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/annotateEntityNames.ts", "sourceCode": "export function annotateEntityNames(text: string, navItems: Map<string, EntityNavItem>): string {\n  const candidates = buildCandidates(navItems);\n\n  // Track annotated regions in the mutated string's coordinates.\n  // After each replacement the ranges shift -- we adjust all existing ranges\n  // so overlap checks always work against current positions.\n  const annotatedRanges: Array<[number, number]> = [];\n  const overlaps = (start: number, end: number): boolean =>\n    annotatedRanges.some(([rs, re]) => start < re && end > rs);\n\n  let result = text;\n\n  for (const { name, annotation } of candidates) {\n    const idx = result.indexOf(name);\n    if (idx === -1) continue;\n\n    const afterName = idx + name.length;\n    if (isAlreadyAnnotated(result, afterName)) continue;\n    if (overlaps(idx, afterName)) continue;\n\n    result = result.slice(0, idx) + annotation + result.slice(afterName);\n    const delta = annotation.length - name.length;\n    shiftRanges(annotatedRanges, afterName, delta);\n    annotatedRanges.push([idx, idx + annotation.length]);\n  }\n\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "navItems", "type": "Map<string, EntityNavItem>", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts::executeBrowserTask", "name": "executeBrowserTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts", "sourceCode": "/**\n * Execute an enrichment task in the main browser thread.\n *\n * Returns the same TaskResult shape as the service worker path.\n */\nexport async function executeBrowserTask(\n  task: WorkerTask,\n  config: WorkerConfig,\n  callbacks?: BrowserTaskCallbacks\n): Promise<TaskResult> {\n  // Merge task-level llmCallSettings with global config\n  const taskConfig = task.llmCallSettings\n    ? { ...config, llmCallSettings: task.llmCallSettings }\n    : config;\n\n  const { llmClient, imageClient } = createClients(taskConfig);\n\n  console.log(\"[BrowserTask] Started\", { taskId: task.id, type: task.type });\n\n  try {\n    const result = await executeTask(task, {\n      config: taskConfig,\n      llmClient,\n      imageClient,\n      isAborted: () => false,\n      onThinkingDelta: callbacks?.onThinkingDelta\n        ? (delta) => callbacks.onThinkingDelta(task.id, delta)\n        : undefined,\n      onTextDelta: callbacks?.onTextDelta\n        ? (delta) => callbacks.onTextDelta(task.id, delta)\n        : undefined,\n    });\n\n    if (result.success) {\n      await persistResult(task, result.result);\n      console.log(\"[BrowserTask] Complete\", { taskId: task.id, type: task.type });\n    } else {\n      console.warn(\"[BrowserTask] Failed\", { taskId: task.id, error: result.error });\n    }\n\n    return result;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    console.error(\"[BrowserTask] Threw\", { taskId: task.id, error: message });\n    return { success: false, error: message };\n  }\n}", "parameters": [{"name": "task", "type": "WorkerTask", "optional": false}, {"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callbacks", "type": "BrowserTaskCallbacks", "optional": true}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildEventHeadline", "name": "buildEventHeadline", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build a stable event headline from subject + action, including description.\n */\nexport function buildEventHeadline(event: {\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}): string {\n  const subjectName = event.subject?.name || event.subject?.id || \"\";\n  const action = event.action || \"\";\n  const base = [subjectName, action].filter(Boolean).join(\" \").trim();\n  if (event.description) {\n    return base ? `${base} - ${event.description}` : event.description;\n  }\n  return base || \"(event)\";\n}", "parameters": [{"name": "event", "type": "{\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildChronicleContext", "name": "buildChronicleContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build generation context from chronicle selections (chronicle-first architecture)\n *\n * This is the primary entry point for building generation context.\n * Role assignments define the chronicle's identity, not a single entity.\n *\n * @param selections - Chronicle selections from wizard\n * @param worldData - World simulation data\n * @param worldContext - World context (name, description, etc.)\n * @param narrativeStyle - Narrative style selected for this chronicle\n * @param nameBank - Optional pre-generated names by culture for invented characters\n * @param proseHints - Optional per-kind prose hints for narrative guidance\n * @param culturalIdentities - Optional cultural identity data (VALUES, SPEECH, FEARS, TABOOS etc.)\n * @param temporalContext - Optional temporal context computed from selected events and eras\n * @param narrativeDirection - Optional free-text narrative direction from wizard\n */\nexport function buildChronicleContext(\n  selections: ChronicleSelections,\n  worldData: WorldData,\n  worldContext: WorldContext,\n  narrativeStyle: NarrativeStyle,\n  nameBank?: Record<string, string[]>,\n  proseHints?: Record<string, string>,\n  culturalIdentities?: Record<string, Record<string, string>>,\n  temporalContext?: ChronicleTemporalContext | null,\n  narrativeDirection?: string\n): ChronicleGenerationContext {\n  const entityMap = new Map(worldData.entities.map((e) => [e.id, e]));\n\n  // Build focus from role assignments\n  const focus = buildFocus(\n    selections.roleAssignments,\n    selections.selectedEventIds,\n    selections.selectedRelationshipIds,\n    selections.lens\n  );\n\n  // Get entities from role assignments\n  const entities = worldData.entities\n    .filter((e) => focus.selectedEntityIds.includes(e.id))\n    .map(buildEntityContext);\n\n  // Parse relationship IDs (format: src:dst:kind) and get selected relationships\n  const relationships = selections.selectedRelationshipIds\n    .map((id) => {\n      const [src, dst, kind] = id.split(\":\");\n      return worldData.relationships.find((r) => r.src === src && r.dst === dst && r.kind === kind);\n    })\n    .filter((r): r is NonNullable<typeof r> => r !== undefined)\n    .map((r) => buildRelationshipContext(r, entityMap));\n\n  // Get selected events\n  const eventIdSet = new Set(selections.selectedEventIds);\n  const events = (worldData.narrativeHistory || [])\n    .filter((e) => eventIdSet.has(e.id))\n    .sort((a, b) => b.significance - a.significance)\n    .map(buildEventContext);\n\n  // Resolve lens entity from world data\n  const lensRaw = selections.lens ? entityMap.get(selections.lens.entityId) : undefined;\n  const lensEntity = lensRaw ? buildEntityContext(lensRaw) : undefined;\n\n  // Resolve era: prefer temporalContext.focalEra (user-selected), fall back to primary entity's era\n  let eraContext: EraContext | undefined;\n  if (temporalContext?.focalEra) {\n    // Use the user-selected focal era from temporal context\n    eraContext = {\n      id: temporalContext.focalEra.id,\n      name: temporalContext.focalEra.name,\n      description: temporalContext.focalEra.summary,\n    };\n  } else {\n    // Fall back to deriving from primary entity's eraId\n    const eraLookup = buildEraLookup(worldData.entities);\n    const primaryEntityId = focus.primaryEntityIds[0];\n    const primaryEntity = primaryEntityId ? entityMap.get(primaryEntityId) : undefined;\n    const primaryEraId = resolveEntityEraId(primaryEntity);\n    const era = primaryEraId ? eraLookup.get(primaryEraId) : undefined;\n    eraContext = era ? buildEraContext(era) : undefined;\n  }\n\n  return {\n    worldName: worldContext.name || \"The World\",\n    worldDescription: worldContext.description || \"\",\n    // These will be populated by perspective synthesis\n    canonFacts: [],\n    tone: \"\",\n    narrativeStyle,\n\n    // Input for perspective synthesis (required)\n    toneFragments: worldContext.toneFragments,\n    canonFactsWithMetadata: worldContext.canonFactsWithMetadata,\n    factSelection: worldContext.factSelection,\n\n    // Chronicle focus (primary)\n    focus,\n\n    // Narrative lens entity (contextual frame)\n    lensEntity,\n\n    era: eraContext,\n    // Full temporal context with all eras and chronicle timeline\n    temporalContext: temporalContext || undefined,\n    entities,\n    relationships,\n    events,\n\n    // Name bank for invented characters\n    nameBank,\n\n    // Prose hints for entity kinds (e.g., how to write about NPCs vs locations)\n    proseHints,\n\n    // Cultural identities for cultures (VALUES, SPEECH, FEARS, TABOOS, etc.)\n    culturalIdentities,\n\n    // World dynamics (narrative context statements)\n    worldDynamics: worldContext.worldDynamics,\n\n    // Narrative direction (optional, from wizard)\n    narrativeDirection: narrativeDirection || undefined,\n  };\n}", "parameters": [{"name": "selections", "type": "ChronicleSelections", "optional": false}, {"name": "worldData", "type": "WorldData", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "narrativeStyle", "type": "NarrativeStyle", "optional": false}, {"name": "nameBank", "type": "Record<string, string[]>", "optional": true}, {"name": "proseHints", "type": "Record<string, string>", "optional": true}, {"name": "culturalIdentities", "type": "Record<string, Record<string, string>>", "optional": true}, {"name": "temporalContext", "type": "ChronicleTemporalContext | null", "optional": true}, {"name": "narrativeDirection", "type": "string", "optional": true}], "returnType": "ChronicleGenerationContext"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::checkPrerequisites", "name": "checkPrerequisites", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "export function checkPrerequisites(context: ChronicleGenerationContext): PrerequisiteCheck {\n  const missing: PrerequisiteCheck[\"missing\"] = [];\n\n  if (!context.focus?.roleAssignments) {\n    return { ready: false, missing };\n  }\n\n  // Check that primary entities have descriptions\n  for (const role of context.focus.roleAssignments.filter((r) => r.isPrimary)) {\n    const entity = context.entities.find((e) => e.id === role.entityId);\n    if (entity && !(entity.summary && entity.description)) {\n      missing.push({\n        type: \"entityDescription\",\n        id: entity.id,\n        name: entity.name,\n      });\n    }\n  }\n\n  return {\n    ready: missing.length === 0,\n    missing,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "PrerequisiteCheck"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::summarizeContext", "name": "summarizeContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Get a summary of context for display\n */\nexport function summarizeContext(context: ChronicleGenerationContext): {\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n} {\n  const prominenceScale = buildProminenceScale(\n    context.entities\n      .map((entity) => Number(entity.prominence))\n      .filter((value) => Number.isFinite(value)),\n    { distribution: DEFAULT_PROMINENCE_DISTRIBUTION }\n  );\n  const prominentThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  const prominentEntities = context.entities\n    .filter((e) => Number(e.prominence) >= prominentThreshold)\n    .map((e) => e.name)\n    .slice(0, 10);\n\n  const highSignificanceEvents = context.events\n    .filter((e) => e.significance >= 0.7)\n    .map((e) => e.headline)\n    .slice(0, 5);\n\n  return {\n    entityCount: context.entities.length,\n    relationshipCount: context.relationships.length,\n    eventCount: context.events.length,\n    prominentEntities,\n    highSignificanceEvents,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "{\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n}"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildChronicleExport", "name": "buildChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Build the full chronicle export from STORED data only.\n *\n * This function uses only what is stored in the ChronicleRecord.\n * No reconstruction, no parameter passing of generation context.\n */\nexport function buildChronicleExport(chronicle: ChronicleRecord): ChronicleExport {\n  const versions = [...(chronicle.generationHistory || [])].sort(\n    (a, b) => a.generatedAt - b.generatedAt\n  );\n  const latestVersion = versions.reduce(\n    (acc, v) => (acc && acc.generatedAt > v.generatedAt ? acc : v),\n    versions[0]\n  );\n  const activeVersionId = chronicle.activeVersionId || latestVersion?.versionId;\n  const isAccepted = Boolean(chronicle.acceptedAt && chronicle.finalContent);\n  const acceptedVersionId =\n    chronicle.acceptedVersionId || (isAccepted ? activeVersionId : undefined);\n  const effectiveVersionId = isAccepted ? acceptedVersionId || activeVersionId : activeVersionId;\n\n  const currentContent = chronicle.assembledContent || chronicle.finalContent || \"\";\n  const historyMatch = versions.find((version) => version.versionId === effectiveVersionId);\n  const effectiveVersion = historyMatch\n    ? {\n        id: historyMatch.versionId,\n        content: historyMatch.content,\n        wordCount: historyMatch.wordCount,\n        systemPrompt: historyMatch.systemPrompt,\n        userPrompt: historyMatch.userPrompt,\n        model: historyMatch.model,\n      }\n    : {\n        id: effectiveVersionId || \"unknown\",\n        content: currentContent,\n        wordCount: currentContent.split(/\\s+/).filter(Boolean).length,\n        systemPrompt:\n          chronicle.generationSystemPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        userPrompt:\n          chronicle.generationUserPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        model: chronicle.model,\n      };\n\n  const content =\n    isAccepted && chronicle.finalContent ? chronicle.finalContent : effectiveVersion.content;\n  const wordCount =\n    isAccepted && chronicle.finalContent\n      ? chronicle.finalContent.split(/\\s+/).filter(Boolean).length\n      : effectiveVersion.wordCount;\n  const systemPrompt = effectiveVersion.systemPrompt;\n  const userPrompt = effectiveVersion.userPrompt;\n  const exportData: ChronicleExport = {\n    exportVersion: \"1.3\",\n    exportedAt: new Date().toISOString(),\n    activeVersionId,\n    acceptedVersionId,\n\n    chronicle: {\n      id: chronicle.chronicleId,\n      title: chronicle.title,\n      format: chronicle.format,\n      focusType: chronicle.focusType,\n      narrativeStyleId: chronicle.narrativeStyleId,\n      narrativeStyleName: chronicle.narrativeStyle?.name,\n      craftPosture: chronicle.narrativeStyle?.craftPosture,\n      lens: chronicle.lens\n        ? {\n            entityId: chronicle.lens.entityId,\n            entityName: chronicle.lens.entityName,\n            entityKind: chronicle.lens.entityKind,\n          }\n        : undefined,\n      narrativeDirection: chronicle.narrativeDirection,\n      createdAt: new Date(chronicle.createdAt).toISOString(),\n      acceptedAt: chronicle.acceptedAt ? new Date(chronicle.acceptedAt).toISOString() : undefined,\n      model: chronicle.model,\n    },\n\n    content,\n    wordCount,\n\n    generationLLMCall: {\n      systemPrompt,\n      userPrompt,\n      model: effectiveVersion.model,\n    },\n  };\n\n  exportData.versions = versions.map((version) => ({\n    versionId: version.versionId,\n    generatedAt: new Date(version.generatedAt).toISOString(),\n    sampling: version.sampling,\n    step: version.step,\n    model: version.model,\n    wordCount: version.wordCount,\n    content: version.content,\n    systemPrompt: version.systemPrompt,\n    userPrompt: version.userPrompt,\n    cost: version.cost,\n  }));\n\n  attachOptionalExportFields(exportData, chronicle);\n\n  return exportData;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleExport"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadChronicleExport", "name": "downloadChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Export chronicle to JSON file download.\n *\n * Uses ONLY data stored in the chronicle record - no external parameters.\n */\nexport function downloadChronicleExport(chronicle: ChronicleRecord): void {\n  const exportData = buildChronicleExport(chronicle);\n\n  // Create filename from chronicle title\n  const safeTitle = chronicle.title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `chronicle-export-${safeTitle}-${Date.now()}.json`;\n\n  // Create blob and download\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkAnnotationReviewExport", "name": "downloadBulkAnnotationReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Annotation Review Export\n// =============================================================================\n\nexport async function downloadBulkAnnotationReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n\n  const annotated = chronicles\n    .filter((c) => c.historianNotes && c.historianNotes.filter(isNoteActive).length > 0)\n    .sort((a, b) => (a.title || \"\").localeCompare(b.title || \"\"));\n\n  const rows = annotated.map((c) => {\n    const notes = (c.historianNotes || []).filter(isNoteActive);\n    return {\n      title: c.title || \"Untitled\",\n      format: c.format || \"story\",\n      narrativeStyleName: c.narrativeStyle?.name || c.narrativeStyleId || null,\n      assignedTone: c.assignedTone || null,\n      noteCount: notes.length,\n      annotations: notes.map((n) => ({\n        type: n.type,\n        display: n.display,\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      })),\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    totalAnnotations: rows.reduce((sum, r) => sum + r.noteCount, 0),\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-annotation-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkToneReviewExport", "name": "downloadBulkToneReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Tone Review Export\n// =============================================================================\n\nexport async function downloadBulkToneReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const corpusStrength = await computeCorpusFactStrength(simulationRunId);\n\n  const complete = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n\n  const rows = complete.map((c) => {\n    const wordCount = c.finalContent?.split(/\\s+/).length || c.wordCount || 0;\n    const noteRange = computeNoteRange(\"chronicle\", wordCount);\n\n    // Compute fact coverage guidance using the same logic as the annotation prompt\n    const guidance = c.factCoverageReport\n      ? buildFactCoverageGuidance(c.factCoverageReport, corpusStrength)\n      : null;\n\n    const maxRequired = noteRange.max <= 4 ? 1 : (guidance?.length ?? 0);\n    const required = guidance?.slice(0, maxRequired) ?? [];\n    const optional = guidance?.slice(maxRequired) ?? [];\n\n    return {\n      title: c.title || \"Untitled\",\n      summary: c.summary || null,\n      brief: c.perspectiveSynthesis?.brief || null,\n      wordCount,\n      noteRange,\n      assignedTone: c.assignedTone || null,\n      toneRanking: c.toneRanking\n        ? {\n            ranking: c.toneRanking.ranking,\n            rationales: c.toneRanking.rationales || { _legacy: c.toneRanking.rationale },\n          }\n        : null,\n      factCoverage:\n        c.factCoverageReport?.entries?.map((e) => ({\n          factId: e.factId,\n          rating: e.rating,\n          wasFaceted: e.wasFaceted,\n        })) || null,\n      annotationGuidance: {\n        required: required.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n        optional: optional.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n      },\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-tone-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildEraNarrativeExport", "name": "buildEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function buildEraNarrativeExport(record: EraNarrativeRecord): EraNarrativeExport {\n  const exportData: EraNarrativeExport = {\n    exportVersion: \"1.0\",\n    exportedAt: new Date().toISOString(),\n\n    narrative: {\n      narrativeId: record.narrativeId,\n      eraId: record.eraId,\n      eraName: record.eraName,\n      tone: record.tone,\n      ...(record.arcDirection ? { arcDirection: record.arcDirection } : {}),\n      status: record.status,\n      createdAt: new Date(record.createdAt).toISOString(),\n    },\n\n    sourceBriefs: record.prepBriefs.map((b) => ({\n      chronicleId: b.chronicleId,\n      chronicleTitle: b.chronicleTitle,\n      eraYear: b.eraYear,\n      ...(b.weight ? { weight: b.weight } : {}),\n      prep: b.prep,\n    })),\n\n    cost: {\n      totalInputTokens: record.totalInputTokens,\n      totalOutputTokens: record.totalOutputTokens,\n      totalActualCost: record.totalActualCost,\n    },\n  };\n\n  if (record.threadSynthesis) {\n    exportData.threadSynthesis = exportThreadSynthesis(record.threadSynthesis);\n  }\n\n  exportNarrativeContent(exportData, record);\n\n  return exportData;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "EraNarrativeExport"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadEraNarrativeExport", "name": "downloadEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function downloadEraNarrativeExport(record: EraNarrativeRecord): void {\n  const exportData = buildEraNarrativeExport(record);\n\n  const safeTitle = (record.eraName || \"era-narrative\")\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `era-narrative-export-${safeTitle}-${Date.now()}.json`;\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/chronicleTypes.ts::computeBackportProgress", "name": "computeBackportProgress", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleTypes.ts", "sourceCode": "/**\n * Compute backport progress for a chronicle.\n * Total = roleAssignments + lens + accepted tertiary.\n * Done = entities present in entityBackportStatus.\n */\nexport function computeBackportProgress(record: {\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}): { done: number; total: number } {\n  const eligibleIds = new Set<string>();\n  for (const r of record.roleAssignments || []) {\n    eligibleIds.add(r.entityId);\n  }\n  if (record.lens) {\n    eligibleIds.add(record.lens.entityId);\n  }\n  for (const t of record.tertiaryCast || []) {\n    if (t.accepted) {\n      eligibleIds.add(t.entityId);\n    }\n  }\n  const statusMap = record.entityBackportStatus || {};\n  let done = 0;\n  for (const id of eligibleIds) {\n    if (statusMap[id]) done++;\n  }\n  return { done, total: eligibleIds.size };\n}", "parameters": [{"name": "record", "type": "{\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}", "optional": false}], "returnType": "{ done: number; total: number }"}, {"id": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts::analyzeConstellation", "name": "analyzeConstellation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts", "sourceCode": "export function analyzeConstellation(input: ConstellationInput): EntityConstellation {\n  const { entities, relationships, events, focalEra } = input;\n\n  const { cultures, topCulture, cultureBalance } = analyzeCultures(entities);\n  const { kinds, topKind, kindFocus } = analyzeKinds(entities);\n  const { tagFrequency, prominentTags } = aggregateTags(entities);\n  const relationshipKinds = countRelationshipKinds(relationships);\n\n  const focalEraId = focalEra?.id || null;\n  const eraIds = new Set(events.map((e) => e.era).filter(Boolean));\n  const eraSpan: EraSpan = eraIds.size > 1 ? \"multiple\" : \"single\";\n\n  // ==========================================================================\n  // Spatial Analysis\n  // ==========================================================================\n\n  const coordinateCentroid = computeCentroid(entities);\n  const spatialSpread = computeSpatialSpread(entities);\n\n  // ==========================================================================\n  // Focus Summary\n  // ==========================================================================\n\n  const focusSummary = buildFocusSummary(\n    cultureBalance,\n    topCulture,\n    kindFocus,\n    prominentTags,\n    relationshipKinds\n  );\n\n  // ==========================================================================\n  // Return\n  // ==========================================================================\n\n  return {\n    cultures,\n    dominantCulture: cultureBalance !== \"mixed\" ? topCulture : null,\n    cultureBalance,\n    kinds,\n    dominantKind: topKind || null,\n    kindFocus,\n    tagFrequency,\n    prominentTags,\n    relationshipKinds,\n    focalEraId,\n    eraSpan,\n    coordinateCentroid,\n    spatialSpread,\n    focusSummary,\n  };\n}", "parameters": [{"name": "input", "type": "ConstellationInput", "optional": false}], "returnType": "EntityConstellation"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTokens", "name": "estimateTokens", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate tokens from text (word count based)\n */\nexport function estimateTokens(text: string): number {\n  const words = text.trim().split(/\\s+/).filter(Boolean).length;\n  return Math.ceil(words * TOKENS_PER_WORD);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCost", "name": "estimateTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for a text enrichment task\n */\nexport function estimateTextCost(\n  prompt: string,\n  type: \"description\",\n  model: string\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = EXPECTED_OUTPUT_TOKENS[type] || 300;\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "type", "type": "\"description\"", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCostForCall", "name": "estimateTextCostForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "export function estimateTextCostForCall(\n  prompt: string,\n  callType: LLMCallType,\n  model: string,\n  outputTokensOverride?: number\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = resolveOutputTokensForCall(callType, outputTokensOverride);\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "outputTokensOverride", "type": "number", "optional": true}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateImageCost", "name": "estimateImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for an image generation task\n */\nexport function estimateImageCost(model: string, size: string, quality: string): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\") {\n    // GPT Image models use token-based pricing\n    const estimatedInputTokens = 300; // Typical prompt size\n    const estimatedOutputTokens =\n      rates.estimatedOutputTokens[quality] || rates.estimatedOutputTokens[\"auto\"] || 6500;\n\n    const inputCost = (estimatedInputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (estimatedOutputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else {\n    // DALL-E models use per-image pricing\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualTextCost", "name": "calculateActualTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost from API response usage\n */\nexport function calculateActualTextCost(\n  inputTokens: number,\n  outputTokens: number,\n  model: string\n): number {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n  return inputCost + outputCost;\n}", "parameters": [{"name": "inputTokens", "type": "number", "optional": false}, {"name": "outputTokens", "type": "number", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualImageCost", "name": "calculateActualImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost for image generation from API response usage\n * GPT Image models return token usage; DALL-E models use per-image pricing\n */\nexport function calculateActualImageCost(\n  model: string,\n  size: string,\n  quality: string,\n  usage?: { inputTokens: number; outputTokens: number }\n): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\" && usage) {\n    // GPT Image models: use actual token counts from API response\n    const inputCost = (usage.inputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (usage.outputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else if (rates.type === \"token-based\") {\n    // GPT Image models without usage data: fall back to estimate\n    return estimateImageCost(model, size, quality);\n  } else {\n    // DALL-E models: per-image pricing (no token usage)\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}, {"name": "usage", "type": "{ inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::createEmptyCostSummary", "name": "createEmptyCostSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Create empty cost summary\n */\nexport function createEmptyCostSummary(): CostSummary {\n  return {\n    totalEstimated: 0,\n    totalActual: 0,\n    textCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    imageCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    byModel: {},\n  };\n}", "parameters": [], "returnType": "CostSummary"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatCost", "name": "formatCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost for display\n */\nexport function formatCost(cost: number): string {\n  if (cost < 0.001) return \"<$0.001\";\n  if (cost < 0.01) return `$${cost.toFixed(4)}`;\n  if (cost < 1) return `$${cost.toFixed(3)}`;\n  return `$${cost.toFixed(2)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatEstimatedCost", "name": "formatEstimatedCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost with estimate indicator\n */\nexport function formatEstimatedCost(cost: number): string {\n  return `~${formatCost(cost)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getCoverImageConfig", "name": "getCoverImageConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getCoverImageConfig(narrativeStyleId: string): CoverImageConfig {\n  return COVER_IMAGE_CONFIG[narrativeStyleId] || DEFAULT_CONFIG;\n}", "parameters": [{"name": "narrativeStyleId", "type": "string", "optional": false}], "returnType": "CoverImageConfig"}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getScenePromptTemplate", "name": "getScenePromptTemplate", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getScenePromptTemplate(id: string): ScenePromptTemplate {\n  return templateMap.get(id) || templateMap.get(\"montage\");\n}", "parameters": [{"name": "id", "type": "string", "optional": false}], "returnType": "ScenePromptTemplate"}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::wordSimilarity", "name": "wordSimilarity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function wordSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/));\n  let intersection = 0;\n  for (const w of wordsA) if (wordsB.has(w)) intersection++;\n  const union = wordsA.size + wordsB.size - intersection;\n  return union === 0 ? 1 : intersection / union;\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::compressDescriptionHistory", "name": "compressDescriptionHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function compressDescriptionHistory(\n  history: DescriptionHistoryEntry[]\n): CompressedHistoryEntry[] {\n  if (history.length <= COMPRESSION_FLOOR) {\n    return history;\n  }\n\n  const result: CompressedHistoryEntry[] = [];\n  let currentGroup: DescriptionHistoryEntry[] = [history[0]];\n\n  for (let i = 1; i < history.length; i++) {\n    const anchor = currentGroup[0]; // compare to group anchor, not last entry\n    const curr = history[i];\n    const sameSource = anchor.source === curr.source;\n    const similar = wordSimilarity(anchor.description, curr.description) > SIMILARITY_THRESHOLD;\n\n    if (sameSource && similar) {\n      currentGroup.push(curr);\n    } else {\n      flushGroup(currentGroup, result);\n      currentGroup = [curr];\n    }\n  }\n  flushGroup(currentGroup, result);\n\n  return result;\n}", "parameters": [{"name": "history", "type": "DescriptionHistoryEntry[]", "optional": false}], "returnType": "CompressedHistoryEntry[]"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::getEnrichmentStatus", "name": "getEnrichmentStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Get enrichment status for an entity and type\n */\nexport function getEnrichmentStatus(\n  entity: { id: string; summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  queueItems: QueueItem[]\n): EnrichmentStatus {\n  // Check queue first\n  const queueItem = queueItems.find((item) => item.entityId === entity.id && item.type === type);\n  if (queueItem) {\n    if (queueItem.status === \"running\") return \"running\";\n    if (queueItem.status === \"queued\") return \"queued\";\n    if (queueItem.status === \"error\") return \"error\";\n  }\n\n  // Check entity fields directly (summary/description are on entity, not nested)\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment is complete when entity has summary and description\n    return entity.summary && entity.description ? \"complete\" : \"missing\";\n  }\n  if (type === \"image\" && enrichment?.image?.imageId) return \"complete\";\n  if (type === \"entityChronicle\" && enrichment?.entityChronicle?.chronicleId) return \"complete\";\n\n  return \"missing\";\n}", "parameters": [{"name": "entity", "type": "{ id: string; summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "queueItems", "type": "QueueItem[]", "optional": false}], "returnType": "EnrichmentStatus"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::needsEnrichment", "name": "needsEnrichment", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Check if entity needs enrichment of a given type\n */\nexport function needsEnrichment(\n  entity: { summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType\n): boolean {\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment needed when entity lacks summary or description\n    return !(entity.summary && entity.description);\n  }\n  if (type === \"image\") return !enrichment?.image?.imageId;\n  if (type === \"entityChronicle\") return !enrichment?.entityChronicle?.chronicleId;\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "{ summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::applyEnrichmentResult", "name": "applyEnrichmentResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Apply enrichment result to entity\n *\n * Returns both the enrichment metadata and entity field updates.\n * Callers should apply both: { ...entity, ...output.entityFields, enrichment: output.enrichment }\n *\n * @param lockedSummary - If true, skip setting the summary field (preserves user-defined summary)\n */\nexport function applyEnrichmentResult(\n  entity: { enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  result: EnrichmentResult,\n  lockedSummary?: boolean\n): ApplyEnrichmentOutput {\n  const existing = entity.enrichment || {};\n\n  if (type === \"description\" && result.description) {\n    // For lockedSummary entities, skip the summary (user-defined takes precedence)\n    // For normal entities, require both summary and description\n    if (!lockedSummary && !result.summary) {\n      return { enrichment: existing };\n    }\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          aliases: result.aliases || [],\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          debug: result.debug,\n          chainDebug: result.chainDebug,\n        },\n      },\n      // Entity field updates - summary/description go directly on entity\n      summary: lockedSummary ? undefined : result.summary,\n      description: result.description,\n    };\n  }\n\n  if (type === \"visualThesis\" && result.visualThesis) {\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          ...(existing.text || { aliases: [], visualTraits: [], generatedAt: 0, model: \"\" }),\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || existing.text?.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          chainDebug: result.chainDebug,\n        },\n      },\n    };\n  }\n\n  if (type === \"image\" && result.imageId) {\n    return {\n      enrichment: {\n        ...existing,\n        image: {\n          imageId: result.imageId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          revisedPrompt: result.revisedPrompt,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          // Image dimensions for aspect-aware display\n          width: result.width,\n          height: result.height,\n          aspect: result.aspect,\n        },\n      },\n    };\n  }\n\n  if (type === \"entityChronicle\" && result.chronicleId) {\n    return {\n      enrichment: {\n        ...existing,\n        entityChronicle: {\n          chronicleId: result.chronicleId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n        },\n      },\n    };\n  }\n\n  return { enrichment: existing };\n}", "parameters": [{"name": "entity", "type": "{ enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "result", "type": "EnrichmentResult", "optional": false}, {"name": "lockedSummary", "type": "boolean", "optional": true}], "returnType": "ApplyEnrichmentOutput"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::scanForReferences", "name": "scanForReferences", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Scan all entities and chronicles for references to the given entity name.\n * Also surfaces all foreign-key references to the entity ID (relationships,\n * chronicle selectedEntityIds, etc.) so the user can verify completeness.\n */\nexport function scanForReferences(\n  entityId: string,\n  oldName: string,\n  entities: ScanEntity[],\n  chronicles: ChronicleRecord[],\n  relationships?: ScanRelationship[],\n  narrativeEvents?: ScanNarrativeEvent[]\n): RenameScanResult {\n  matchIdCounter = 0;\n\n  const ctx: ScanContext = {\n    entityId,\n    fullSlug: normalizeSlug(oldName),\n    partialSlugs: generatePartials(oldName),\n    matches: [],\n    coveredPositions: new Map(),\n    currentTier: \"general\",\n  };\n\n  const fullAndPartial: ScanFn = (st, si, sn, f, t) => scanTextField(ctx, st, si, sn, f, t);\n  const fullOnly: ScanFn = (st, si, sn, f, t) => scanTextFieldFullNameOnly(ctx, st, si, sn, f, t);\n\n  const entityById = new Map(entities.map((e) => [e.id, e]));\n\n  // Build related entity set from relationships\n  const relatedEntityIds = new Set<string>();\n  if (relationships) {\n    for (const rel of relationships) {\n      if (rel.src === entityId) relatedEntityIds.add(rel.dst);\n      if (rel.dst === entityId) relatedEntityIds.add(rel.src);\n    }\n  }\n\n  // Build cast chronicle set\n  const castChronicleIds = new Set<string>();\n  for (const chronicle of chronicles) {\n    if (chronicle.selectedEntityIds?.includes(entityId)) {\n      castChronicleIds.add(chronicle.chronicleId);\n    }\n  }\n\n  // 1. SELF\n  ctx.currentTier = \"self\";\n  const selfEntity = entityById.get(entityId);\n  if (selfEntity) scanEntityTextFields(selfEntity, ctx, fullAndPartial);\n\n  // 2. RELATED\n  ctx.currentTier = \"related\";\n  for (const relEntityId of relatedEntityIds) {\n    const relEntity = entityById.get(relEntityId);\n    if (relEntity) scanEntityTextFields(relEntity, ctx, fullAndPartial);\n  }\n\n  // 3. CAST CHRONICLES\n  ctx.currentTier = \"cast\";\n  for (const chronicle of chronicles) {\n    if (!castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullAndPartial);\n  }\n\n  // 4. GENERAL SWEEP\n  ctx.currentTier = \"general\";\n  const scannedEntityIds = new Set([entityId, ...relatedEntityIds]);\n  for (const entity of entities) {\n    if (scannedEntityIds.has(entity.id)) continue;\n    scanEntityTextFields(entity, ctx, fullOnly);\n  }\n\n  for (const chronicle of chronicles) {\n    if (castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullOnly);\n  }\n\n  // 5. NARRATIVE EVENTS\n  if (narrativeEvents) {\n    scanNarrativeEvents(narrativeEvents, entityId, ctx);\n  }\n\n  // FK references\n  scanFkReferences(entityId, entityById, relationships, chronicles, ctx);\n\n  return { entityId, oldName, matches: ctx.matches };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "entities", "type": "ScanEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "relationships", "type": "ScanRelationship[]", "optional": true}, {"name": "narrativeEvents", "type": "ScanNarrativeEvent[]", "optional": true}], "returnType": "RenameScanResult"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::adjustReplacementForGrammar", "name": "adjustReplacementForGrammar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function adjustReplacementForGrammar(\n  contextBefore: string,\n  contextAfter: string,\n  matchPosition: number,\n  matchedText: string,\n  replacement: string\n): AdjustedReplacement {\n  const state: GrammarState = {\n    position: matchPosition,\n    originalLength: matchedText.length,\n    replacement,\n  };\n\n  const rawBefore = rawCtxBefore(contextBefore);\n  const rawAfter = rawCtxAfter(contextAfter);\n  const sentenceStart = isAtSentenceStart(rawBefore);\n  const casePattern = detectCasePattern(matchedText);\n\n  applyCaseEcho(state, casePattern);\n\n  const precedingArticle = findPrecedingArticle(rawBefore);\n  const replacementStartsWithThe = /^the\\s/i.test(state.replacement);\n  const articleAbsorbed = applyArticleDeduplication(state, matchPosition, matchedText.length, precedingArticle);\n\n  if (!sentenceStart && casePattern !== \"allCaps\" && !articleAbsorbed) {\n    applyMidSentenceArticleLowercasing(state);\n  }\n\n  if (\n    precedingArticle &&\n    !replacementStartsWithThe &&\n    !articleAbsorbed &&\n    (precedingArticle.normalized === \"a\" || precedingArticle.normalized === \"an\")\n  ) {\n    applyAAnAgreement(state, matchPosition, matchedText.length, precedingArticle);\n  }\n\n  applyPossessiveTransfer(state, rawAfter);\n\n  return { position: state.position, originalLength: state.originalLength, replacement: state.replacement };\n}", "parameters": [{"name": "contextBefore", "type": "string", "optional": false}, {"name": "contextAfter", "type": "string", "optional": false}, {"name": "matchPosition", "type": "number", "optional": false}, {"name": "matchedText", "type": "string", "optional": false}, {"name": "replacement", "type": "string", "optional": false}], "returnType": "AdjustedReplacement"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyReplacements", "name": "applyReplacements", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply a set of replacements to a text string. Replacements must not overlap\n * and are applied in reverse order to preserve positions.\n */\nexport function applyReplacements(text: string, replacements: FieldReplacement[]): string {\n  // Sort by position descending so earlier positions aren't shifted\n  const sorted = [...replacements].sort((a, b) => b.position - a.position);\n  let result = text;\n  for (const r of sorted) {\n    result =\n      result.slice(0, r.position) + r.replacement + result.slice(r.position + r.originalLength);\n  }\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "replacements", "type": "FieldReplacement[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::buildRenamePatches", "name": "buildRenamePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function buildRenamePatches(\n  scanResult: RenameScanResult,\n  newName: string,\n  decisions: MatchDecision[]\n): RenamePatches {\n  const decisionMap = new Map(decisions.map((d) => [d.matchId, d]));\n\n  const entityPatchMap = new Map<string, Record<string, any>>();\n  const chroniclePatchMap = new Map<string, Record<string, any>>();\n  const eventPatchMap = new Map<string, Record<string, any>>();\n  const chronicleMetaUpdates = new Map<string, Partial<ChronicleRecord>>();\n  const eventMetaUpdates = new Map<string, Record<string, string>>();\n\n  for (const match of scanResult.matches) {\n    const decision = decisionMap.get(match.id);\n    if (!decision || decision.action === \"reject\") continue;\n\n    const replacementText = decision.action === \"edit\" ? (decision.editText ?? newName) : newName;\n\n    if (match.matchType === \"metadata\") {\n      if (match.sourceType === \"event\") {\n        const meta = eventMetaUpdates.get(match.sourceId) || {};\n        meta[match.field] = replacementText;\n        eventMetaUpdates.set(match.sourceId, meta);\n      } else {\n        const meta = chronicleMetaUpdates.get(match.sourceId) || {};\n        processChronicleMetadataMatch(meta, match.field, replacementText);\n        chronicleMetaUpdates.set(match.sourceId, meta);\n      }\n    } else {\n      const replacement = computeReplacement(match, decision, newName);\n\n      if (match.sourceType === \"entity\") {\n        appendReplacementToMap(entityPatchMap, match.sourceId, match.field, replacement, true);\n      } else if (match.sourceType === \"chronicle\") {\n        appendReplacementToMap(chroniclePatchMap, match.sourceId, match.field, replacement, false);\n      } else if (match.sourceType === \"event\") {\n        appendReplacementToMap(eventPatchMap, match.sourceId, match.field, replacement, true);\n      }\n    }\n  }\n\n  // Merge metadata updates into chronicle patches\n  for (const [chronicleId, meta] of chronicleMetaUpdates) {\n    const existing = chroniclePatchMap.get(chronicleId) || {};\n    Object.assign(existing, meta);\n    chroniclePatchMap.set(chronicleId, existing);\n  }\n\n  for (const [eventId, meta] of eventMetaUpdates) {\n    const existing = eventPatchMap.get(eventId) || {};\n    Object.assign(existing, meta);\n    eventPatchMap.set(eventId, existing);\n  }\n\n  return {\n    entityPatches: [...entityPatchMap].map(([entityId, changes]) => ({ entityId, changes })),\n    chroniclePatches: [...chroniclePatchMap].map(([chronicleId, fieldUpdates]) => ({\n      chronicleId,\n      fieldUpdates,\n    })),\n    eventPatches: [...eventPatchMap].map(([eventId, changes]) => ({ eventId, changes })),\n  };\n}", "parameters": [{"name": "scanResult", "type": "RenameScanResult", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "decisions", "type": "MatchDecision[]", "optional": false}], "returnType": "RenamePatches"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyEntityPatches", "name": "applyEntityPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Apply helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Apply entity patches to an entity array. Returns a new array with patches applied.\n * Handles summary, description, and enrichment.descriptionHistory text replacements.\n */\nexport function applyEntityPatches<T extends ScanEntity>(\n  entities: T[],\n  patches: EntityPatch[],\n  targetEntityId: string | null,\n  newName: string\n): T[] {\n  const patchMap = new Map(patches.map((p) => [p.entityId, p]));\n\n  return entities.map((entity) => {\n    // The target entity always gets its name updated, even without a text patch\n    const isTarget = entity.id === targetEntityId;\n    const patch = patchMap.get(entity.id);\n    if (!patch && !isTarget) return entity;\n\n    const updated = { ...entity };\n\n    if (isTarget) {\n      updated.name = newName;\n      // Store the entity ID as a slug alias so deep links using the old\n      // ID-based slug still resolve after the name changes. The chronicler's\n      // bySlug map indexes these for URL resolution.\n      const existingAliases = (entity as any).enrichment?.slugAliases || [];\n      if (!existingAliases.includes(entity.id)) {\n        if (!updated.enrichment) updated.enrichment = { ...(entity as any).enrichment };\n        (updated as any).enrichment.slugAliases = [...existingAliases, entity.id];\n      }\n    }\n\n    if (!patch) return updated;\n\n    // Apply text replacements\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (!key.startsWith(\"__replacements_\")) continue;\n      const field = key.replace(\"__replacements_\", \"\");\n      const replacements: FieldReplacement[] = JSON.parse(value);\n\n      if (field === \"summary\" || field === \"description\" || field === \"narrativeHint\") {\n        const originalText = (entity as any)[field];\n        if (typeof originalText === \"string\") {\n          (updated as any)[field] = applyReplacements(originalText, replacements);\n        }\n      } else if (field.startsWith(\"enrichment.descriptionHistory[\")) {\n        // Parse index from: enrichment.descriptionHistory[N].description\n        const idxMatch = field.match(/\\[(\\d+)\\]/);\n        if (idxMatch && entity.enrichment?.descriptionHistory) {\n          const idx = parseInt(idxMatch[1], 10);\n          // Shallow-copy enrichment chain on first write\n          if (!updated.enrichment || updated.enrichment === entity.enrichment) {\n            updated.enrichment = { ...entity.enrichment };\n          }\n          if (\n            !updated.enrichment.descriptionHistory ||\n            updated.enrichment.descriptionHistory === entity.enrichment.descriptionHistory\n          ) {\n            updated.enrichment.descriptionHistory = [...entity.enrichment.descriptionHistory];\n          }\n          const entry = updated.enrichment.descriptionHistory[idx];\n          if (entry) {\n            updated.enrichment.descriptionHistory[idx] = {\n              ...entry,\n              description: applyReplacements(entry.description, replacements),\n            };\n          }\n        }\n      }\n    }\n\n    return updated;\n  });\n}", "parameters": [{"name": "entities", "type": "T[]", "optional": false}, {"name": "patches", "type": "EntityPatch[]", "optional": false}, {"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "T[]"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyChroniclePatches", "name": "applyChroniclePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply chronicle patches. Reads each chronicle from IDB, applies changes, writes back.\n * Returns the number of successfully updated chronicles.\n */\nexport async function applyChroniclePatches(\n  patches: ChroniclePatch[],\n  getChronicle: (id: string) => Promise<ChronicleRecord | undefined>,\n  putChronicle: (record: ChronicleRecord) => Promise<void>\n): Promise<number> {\n  let successCount = 0;\n\n  for (const patch of patches) {\n    try {\n      const chronicle = await getChronicle(patch.chronicleId);\n      if (!chronicle) {\n        console.warn(`[EntityRename] Chronicle not found: ${patch.chronicleId}`);\n        continue;\n      }\n\n      const updated = { ...chronicle };\n\n      // Apply metadata updates\n      if ((patch.fieldUpdates as any)._roleAssignmentUpdates) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._roleAssignmentUpdates;\n        updated.roleAssignments = [...chronicle.roleAssignments];\n        for (const u of updates) {\n          if (updated.roleAssignments[u.index]) {\n            updated.roleAssignments[u.index] = {\n              ...updated.roleAssignments[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      if ((patch.fieldUpdates as any)._lensNameUpdate && chronicle.lens) {\n        updated.lens = {\n          ...chronicle.lens,\n          entityName: (patch.fieldUpdates as any)._lensNameUpdate,\n        };\n      }\n\n      if (\n        (patch.fieldUpdates as any)._directiveUpdates &&\n        chronicle.generationContext?.entityDirectives\n      ) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._directiveUpdates;\n        updated.generationContext = {\n          ...chronicle.generationContext,\n          entityDirectives: [...chronicle.generationContext.entityDirectives],\n        };\n        for (const u of updates) {\n          if (updated.generationContext.entityDirectives[u.index]) {\n            updated.generationContext.entityDirectives[u.index] = {\n              ...updated.generationContext.entityDirectives[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      // Apply text field replacements\n      for (const [key, value] of Object.entries(patch.fieldUpdates)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements = value as FieldReplacement[];\n\n        if (field.startsWith(\"generationHistory.\")) {\n          // Handle generation history versions\n          const versionId = field.replace(\"generationHistory.\", \"\");\n          if (updated.generationHistory) {\n            updated.generationHistory = updated.generationHistory.map((v) => {\n              if (v.versionId === versionId) {\n                return { ...v, content: applyReplacements(v.content, replacements) };\n              }\n              return v;\n            });\n          }\n        } else if (field === \"assembledContent\" && typeof updated.assembledContent === \"string\") {\n          updated.assembledContent = applyReplacements(updated.assembledContent, replacements);\n        } else if (field === \"finalContent\" && typeof updated.finalContent === \"string\") {\n          updated.finalContent = applyReplacements(updated.finalContent, replacements);\n        } else if (field === \"summary\" && typeof updated.summary === \"string\") {\n          updated.summary = applyReplacements(updated.summary, replacements);\n        }\n      }\n\n      updated.updatedAt = Date.now();\n      await putChronicle(updated);\n      successCount++;\n    } catch (err) {\n      console.error(`[EntityRename] Failed to update chronicle ${patch.chronicleId}:`, err);\n    }\n  }\n\n  return successCount;\n}", "parameters": [{"name": "patches", "type": "ChroniclePatch[]", "optional": false}, {"name": "getChronicle", "type": "(id: string) => Promise<ChronicleRecord | undefined>", "optional": false}, {"name": "putChronicle", "type": "(record: ChronicleRecord) => Promise<void>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyNarrativeEventPatches", "name": "applyNarrativeEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply narrative event patches to an event array. Returns a new array with patches applied.\n * Handles both structured name fields (metadata) and text replacements.\n */\nexport function applyNarrativeEventPatches<T extends ScanNarrativeEvent>(\n  events: T[],\n  patches: EventPatch[]\n): T[] {\n  if (patches.length === 0) return events;\n\n  const patchMap = new Map(patches.map((p) => [p.eventId, p]));\n\n  return events.map((event) => {\n    const patch = patchMap.get(event.id);\n    if (!patch) return event;\n\n    const updated: any = { ...event };\n\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (key.startsWith(\"__replacements_\")) {\n        // Text field replacements\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n\n        if (field === \"description\" && typeof updated.description === \"string\") {\n          updated.description = applyReplacements(updated.description, replacements);\n        } else if (field === \"action\" && typeof updated.action === \"string\") {\n          updated.action = applyReplacements(updated.action, replacements);\n        } else if (field.startsWith(\"participantEffects[\")) {\n          // Parse: participantEffects[N].effects[M].description\n          const idxMatch = field.match(\n            /participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.description/\n          );\n          if (idxMatch) {\n            const pi = parseInt(idxMatch[1], 10);\n            const ei = parseInt(idxMatch[2], 10);\n            if (\n              !updated.participantEffects ||\n              updated.participantEffects === event.participantEffects\n            ) {\n              updated.participantEffects = [...event.participantEffects];\n            }\n            if (updated.participantEffects[pi]) {\n              const pe = { ...updated.participantEffects[pi] };\n              if (pe.effects === event.participantEffects[pi].effects) {\n                pe.effects = [...event.participantEffects[pi].effects];\n              }\n              if (pe.effects[ei]) {\n                pe.effects[ei] = {\n                  ...pe.effects[ei],\n                  description: applyReplacements(pe.effects[ei].description, replacements),\n                };\n              }\n              updated.participantEffects[pi] = pe;\n            }\n          }\n        }\n      } else if (key === \"subject.name\") {\n        // Structured name field: subject.name\n        updated.subject = { ...event.subject, name: value };\n      } else if (key.startsWith(\"participantEffects[\")) {\n        // Structured name: participantEffects[N].entity.name or participantEffects[N].effects[M].relatedEntity.name\n        if (\n          !updated.participantEffects ||\n          updated.participantEffects === event.participantEffects\n        ) {\n          updated.participantEffects = [...event.participantEffects];\n        }\n\n        const entityNameMatch = key.match(/^participantEffects\\[(\\d+)\\]\\.entity\\.name$/);\n        if (entityNameMatch) {\n          const pi = parseInt(entityNameMatch[1], 10);\n          if (updated.participantEffects[pi]) {\n            updated.participantEffects[pi] = {\n              ...updated.participantEffects[pi],\n              entity: { ...updated.participantEffects[pi].entity, name: value },\n            };\n          }\n        }\n\n        const relatedMatch = key.match(\n          /^participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.relatedEntity\\.name$/\n        );\n        if (relatedMatch) {\n          const pi = parseInt(relatedMatch[1], 10);\n          const ei = parseInt(relatedMatch[2], 10);\n          if (updated.participantEffects[pi]) {\n            const pe = { ...updated.participantEffects[pi] };\n            if (pe.effects === event.participantEffects[pi]?.effects) {\n              pe.effects = [...event.participantEffects[pi].effects];\n            }\n            if (pe.effects[ei]?.relatedEntity) {\n              pe.effects[ei] = {\n                ...pe.effects[ei],\n                relatedEntity: { ...pe.effects[ei].relatedEntity!, name: value },\n              };\n            }\n            updated.participantEffects[pi] = pe;\n          }\n        }\n      }\n    }\n\n    return updated as T;\n  });\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "patches", "type": "EventPatch[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::patchNarrativeHistory", "name": "patchNarrativeHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Brute-force patch of all narrative events for a single entity rename.\n *\n * Unlike the scan-based approach (which uses position-based replacements and\n * per-match decisions), this function does a simple find-and-replace across\n * ALL name fields and text fields in every event where the entity appears.\n *\n * Use this to repair data that was missed by a previous rename, or as a\n * one-shot fix when you don't need per-match granularity.\n *\n * @returns { events: patched array, patchCount: number of events modified }\n */\nexport function patchNarrativeHistory<T extends ScanNarrativeEvent>(\n  events: T[],\n  entityId: string,\n  oldName: string,\n  newName: string\n): { events: T[]; patchCount: number } {\n  let patchCount = 0;\n\n  const patched = events.map((event) => {\n    // Quick check: is this entity involved at all?\n    const isSubject = event.subject.id === entityId;\n    const participantIdx = event.participantEffects.findIndex((pe) => pe.entity.id === entityId);\n    // Also check if old name appears anywhere in the event text\n    const hasTextMatch =\n      event.description.toLowerCase().includes(oldName.toLowerCase()) ||\n      event.action.toLowerCase().includes(oldName.toLowerCase());\n\n    const hasRelatedRef = event.participantEffects.some((pe) =>\n      pe.effects.some((eff) => eff.relatedEntity?.id === entityId)\n    );\n\n    if (!isSubject && participantIdx === -1 && !hasTextMatch && !hasRelatedRef) {\n      return event;\n    }\n\n    let didChange = false;\n    const updated: any = { ...event };\n\n    // Patch subject.name\n    if (isSubject && event.subject.name !== newName) {\n      updated.subject = { ...event.subject, name: newName };\n      didChange = true;\n    }\n\n    // Patch participantEffects\n    const newPE = [...event.participantEffects];\n    for (let pi = 0; pi < newPE.length; pi++) {\n      const pe = newPE[pi];\n      let peChanged = false;\n      let updatedPE: any = pe;\n\n      // Participant entity.name\n      if (pe.entity.id === entityId && pe.entity.name !== newName) {\n        updatedPE = { ...pe, entity: { ...pe.entity, name: newName } };\n        peChanged = true;\n      }\n\n      // Effects\n      const newEffects = [...(updatedPE.effects || pe.effects)];\n      for (let ei = 0; ei < newEffects.length; ei++) {\n        const eff = newEffects[ei];\n        let effChanged = false;\n        let updatedEff: any = eff;\n\n        // relatedEntity.name\n        if (eff.relatedEntity?.id === entityId && eff.relatedEntity.name !== newName) {\n          updatedEff = { ...eff, relatedEntity: { ...eff.relatedEntity, name: newName } };\n          effChanged = true;\n        }\n\n        // effect.description (free text)\n        const patchedDesc = replaceAllCaseInsensitive(updatedEff.description, oldName, newName);\n        if (patchedDesc !== updatedEff.description) {\n          updatedEff = { ...(effChanged ? updatedEff : eff), description: patchedDesc };\n          effChanged = true;\n        }\n\n        if (effChanged) {\n          newEffects[ei] = updatedEff;\n          peChanged = true;\n        }\n      }\n\n      if (peChanged) {\n        updatedPE = { ...(updatedPE === pe ? pe : updatedPE), effects: newEffects };\n        newPE[pi] = updatedPE;\n        didChange = true;\n      }\n    }\n\n    if (didChange) {\n      updated.participantEffects = newPE;\n    }\n\n    // Patch top-level text fields\n    const patchedDesc = replaceAllCaseInsensitive(\n      updated.description || event.description,\n      oldName,\n      newName\n    );\n    if (patchedDesc !== (updated.description || event.description)) {\n      updated.description = patchedDesc;\n      didChange = true;\n    }\n\n    const patchedAction = replaceAllCaseInsensitive(\n      updated.action || event.action,\n      oldName,\n      newName\n    );\n    if (patchedAction !== (updated.action || event.action)) {\n      updated.action = patchedAction;\n      didChange = true;\n    }\n\n    if (didChange) {\n      patchCount++;\n      return updated as T;\n    }\n    return event;\n  });\n\n  return { events: patched, patchCount };\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "{ events: T[]; patchCount: number }"}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::resolveAnchorPhrase", "name": "resolveAnchorPhrase", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "export function resolveAnchorPhrase(anchorPhrase: string, text: string): FuzzyAnchorResult | null {\n  if (!anchorPhrase || !text) return null;\n\n  const exact = tryExactMatch(anchorPhrase, text);\n  if (exact) return exact;\n\n  const phraseContentWords = contentWords(anchorPhrase);\n  if (phraseContentWords.length === 0) return null;\n\n  const phraseWordSet = new Set(phraseContentWords);\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  const anchorWordCount = anchorPhrase.split(/\\s+/).length;\n  const halfWindow = Math.floor(Math.max(anchorWordCount, 4) / 2);\n\n  const { bestScore, bestCenter } = findBestCenter(words, phraseWordSet, halfWindow);\n\n  if (bestScore < Math.max(1, Math.ceil(phraseContentWords.length * 0.4))) return null;\n\n  const spanStart = Math.max(0, bestCenter - halfWindow);\n  const spanEnd = Math.min(words.length - 1, bestCenter + halfWindow);\n  const charStart = words[spanStart].start;\n  const charEnd = words[spanEnd].end;\n\n  let candidate = text.slice(charStart, charEnd);\n  const centerCharStart = words[bestCenter].start;\n  const centerCharEnd = words[bestCenter].end;\n\n  candidate = snapToSentence(text, candidate, charStart, charEnd, centerCharStart, centerCharEnd);\n  candidate = ensureUnique(text, candidate, centerCharStart, anchorWordCount);\n\n  if (!candidate || candidate.length < 3) return null;\n\n  const finalIdx = text.indexOf(candidate);\n  if (finalIdx < 0) return null;\n\n  return { phrase: candidate, index: finalIdx, method: \"fuzzy\" };\n}", "parameters": [{"name": "anchorPhrase", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "FuzzyAnchorResult | null"}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::extractWordsAroundIndex", "name": "extractWordsAroundIndex", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "/**\n * Extract ~wordCount words centered around a character index, snapped to word\n * boundaries. Used as a proportional-index fallback when fuzzy anchor matching\n * fails after a copy edit.\n */\nexport function extractWordsAroundIndex(\n  text: string,\n  index: number,\n  wordCount: number\n): string | null {\n  if (!text || index < 0 || index >= text.length) return null;\n\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  // Find the word closest to the target index\n  let centerIdx = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].start <= index && words[i].end >= index) {\n      centerIdx = i;\n      break;\n    }\n    if (words[i].start > index) {\n      centerIdx = Math.max(0, i - 1);\n      break;\n    }\n    centerIdx = i; // last word if index is past end\n  }\n\n  const half = Math.floor(wordCount / 2);\n  const start = Math.max(0, centerIdx - half);\n  const end = Math.min(words.length - 1, start + wordCount - 1);\n  const candidate = text.slice(words[start].start, words[end].end);\n\n  return candidate && candidate.length >= 3 ? candidate : null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::collectPreviousNotes", "name": "collectPreviousNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function collectPreviousNotes(\n  options: {\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  } = {}\n): Promise<PreviousNoteSummary[]> {\n  const { maxPerTarget, relatedRatio } = HISTORIAN_SAMPLING;\n  const maxTotal = options.maxOverride ?? HISTORIAN_SAMPLING.maxTotal;\n  if (maxTotal <= 0) return [];\n  const relatedEntityIds = new Set(options.relatedEntityIds || []);\n  const relatedChronicleIds = new Set(options.relatedChronicleIds || []);\n  const { simulationRunId } = useEntityStore.getState();\n\n  const byTarget = new Map<string, NoteEntry[]>();\n\n  const addNotesForTarget = (\n    targetKey: string,\n    targetMeta: { type: string; id: string; name: string },\n    notes: Array<{ noteId?: string; anchorPhrase: string; text: string; type: string }>\n  ) => {\n    if (!notes.length) return;\n    const mapped: NoteEntry[] = notes.map((note, index) => ({\n      noteKey: note.noteId || `${targetKey}:${index}`,\n      targetKey,\n      targetType: targetMeta.type,\n      targetId: targetMeta.id,\n      targetName: targetMeta.name,\n      anchorPhrase: note.anchorPhrase,\n      text: note.text,\n      type: note.type,\n    }));\n    byTarget.set(targetKey, mapped);\n  };\n\n  // Entity notes\n  if (simulationRunId) {\n    const allEntities = await entityRepo.getEntitiesForRun(simulationRunId);\n    for (const entity of allEntities) {\n      const notes = (entity.enrichment?.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `entity:${entity.id}`,\n        {\n          type: \"entity\",\n          id: entity.id,\n          name: entity.name,\n        },\n        notes\n      );\n    }\n  }\n\n  // Chronicle notes\n  if (simulationRunId) {\n    const chronicleRecords = await getChroniclesForSimulation(simulationRunId);\n    for (const chronicle of chronicleRecords) {\n      const notes = (chronicle.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `chronicle:${chronicle.chronicleId}`,\n        {\n          type: \"chronicle\",\n          id: chronicle.chronicleId,\n          name: chronicle.title || chronicle.chronicleId,\n        },\n        notes\n      );\n    }\n  }\n\n  // Cap each target\n  const cappedNotes: NoteEntry[] = [];\n  for (const notes of byTarget.values()) {\n    const selected =\n      notes.length > maxPerTarget ? takeRandomSample(notes, maxPerTarget) : notes.slice();\n    cappedNotes.push(...selected);\n  }\n\n  if (cappedNotes.length === 0) return [];\n\n  const total = Math.min(maxTotal, cappedNotes.length);\n  const relatedNotes = cappedNotes.filter((note) => {\n    if (note.targetType === \"entity\") return relatedEntityIds.has(note.targetId);\n    if (note.targetType === \"chronicle\") return relatedChronicleIds.has(note.targetId);\n    return false;\n  });\n\n  const relatedQuota = Math.min(relatedNotes.length, Math.round(total * relatedRatio));\n  const relatedSample = takeRandomSample(relatedNotes, relatedQuota);\n  const relatedKeys = new Set(relatedSample.map((note) => note.noteKey));\n  const remainingPool = cappedNotes.filter((note) => !relatedKeys.has(note.noteKey));\n  const remainingSample = takeRandomSample(remainingPool, total - relatedSample.length);\n\n  const finalSample = [...relatedSample, ...remainingSample];\n  shuffleInPlace(finalSample);\n\n  return finalSample.map((note) => ({\n    targetName: note.targetName,\n    anchorPhrase: note.anchorPhrase,\n    text: note.text,\n    type: note.type,\n  }));\n}", "parameters": [{"name": "options", "type": "{\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  }", "optional": true}], "returnType": "Promise<PreviousNoteSummary[]>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianEditionContext", "name": "buildHistorianEditionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "// ============================================================================\n// Context builders\n// ============================================================================\n\n/**\n * Build the full context for a historian edition (description rewrite) session.\n * Returns null if preconditions aren't met (missing config, entity, etc.).\n */\nexport async function buildHistorianEditionContext(\n  entityId: string,\n  tone?: string,\n  reEdition?: boolean\n): Promise<HistorianEditionConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  // If prior historian editions exist (active or legacy), use the pre-historian baseline\n  // as the input description instead of entity.description (which may be an inflated historian\n  // output). The first historian-edition or legacy-copy-edit entry is always the pre-historian\n  // text that was replaced by the first edition. Filter edition entries from the archive so\n  // the LLM works from the original source material, not prior historian rewrites.\n  const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n  let description = entity.description;\n  let filteredHistory = entity.enrichment?.descriptionHistory || [];\n  const firstEdition = filteredHistory.find((h: { source?: string }) =>\n    editionSources.has(h.source || \"\")\n  );\n  if (firstEdition) {\n    description = firstEdition.description;\n    filteredHistory = filteredHistory.filter(\n      (h: { source?: string }) => !editionSources.has(h.source || \"\")\n    );\n  } else if (reEdition) {\n    return null; // re-edition requested but no prior edition exists\n  }\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Gather chronicle summaries from backrefs\n  const chronicleSummaries: Array<{\n    chronicleId: string;\n    title: string;\n    format: string;\n    summary: string;\n  }> = [];\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  for (const ref of backrefs) {\n    if (!ref.chronicleId) continue;\n    try {\n      const chronicle = await getChronicle(ref.chronicleId);\n      if (chronicle && chronicle.title) {\n        chronicleSummaries.push({\n          chronicleId: chronicle.chronicleId,\n          title: chronicle.title,\n          format: chronicle.format || \"\",\n          summary: chronicle.summary || chronicle.finalContent?.slice(0, 500) || \"\",\n        });\n      }\n    } catch {\n      // Skip if chronicle not found\n    }\n  }\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    description,\n    summary: entity.summary || \"\",\n    descriptionHistory: filteredHistory,\n    chronicleSummaries,\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    previousNotes,\n    historianConfig,\n    tone: (tone || \"scholarly\") as HistorianEditionConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "reEdition", "type": "boolean", "optional": true}], "returnType": "Promise<HistorianEditionConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianReviewContext", "name": "buildHistorianReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build the full context for a historian review (annotation) session on an entity.\n * Returns null if preconditions aren't met.\n */\nexport async function buildHistorianReviewContext(\n  entityId: string,\n  tone?: string,\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    summary: entity.summary || \"\",\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n  });\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"entity\",\n    targetId: entity.id,\n    targetName: entity.name,\n    sourceText: entity.description,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildChronicleReviewContext", "name": "buildChronicleReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildChronicleReviewContext(\n  chronicleId: string,\n  tone?: string,\n  corpusStrengthCache?: { runId: string | null; strength: Map<string, number> | null },\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  reinforcementCache?: ReinforcementCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !chronicleId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const chronicle = await getChronicle(chronicleId);\n  if (!chronicle) return null;\n  if (chronicle.status !== \"complete\" || !chronicle.finalContent) return null;\n\n  const content = chronicle.finalContent;\n\n  // Build cast summaries\n  const castEntityIds = (chronicle.roleAssignments || [])\n    .map((ra: { entityId: string }) => ra.entityId)\n    .filter(Boolean);\n  const castFull = await useEntityStore.getState().loadEntities(castEntityIds);\n  const castMap = new Map(castFull.map((e: { id: string }) => [e.id, e]));\n\n  const castSummaries = (chronicle.roleAssignments || [])\n    .slice(0, 10)\n    .map((ra: { entityId: string }) => {\n      const entity = castMap.get(ra.entityId);\n      if (!entity) return null;\n      return {\n        name: entity.name,\n        kind: entity.kind,\n        summary: entity.summary || entity.description?.slice(0, 200) || \"\",\n      };\n    })\n    .filter(Boolean);\n\n  const cast = (chronicle.roleAssignments || []).map((ra: { entityId: string; role: string }) => {\n    const entity = castMap.get(ra.entityId);\n    return {\n      entityName: entity?.name || ra.entityId,\n      role: ra.role,\n      kind: entity?.kind || \"unknown\",\n    };\n  });\n\n  const factCoverageGuidance = chronicle.factCoverageReport?.entries?.length\n    ? await resolveFactCoverageGuidance(\n        chronicle.factCoverageReport, simulationRunId, worldContext,\n        corpusStrengthCache, reinforcementCache\n      )\n    : undefined;\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    chronicleId: chronicle.chronicleId,\n    title: chronicle.title || \"Untitled\",\n    format: chronicle.format,\n    narrativeStyleId: chronicle.narrativeStyleId || \"\",\n    cast,\n    castSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    factCoverageGuidance,\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n    temporalNarrative: chronicle.perspectiveSynthesis?.temporalNarrative || undefined,\n    focalEra: chronicle.temporalContext?.focalEra\n      ? {\n          name: chronicle.temporalContext.focalEra.name,\n          description: chronicle.temporalContext.focalEra.description,\n        }\n      : undefined,\n    temporalCheckReport: chronicle.temporalCheckReport || undefined,\n  });\n\n  const relatedEntityIds = new Set(\n    (chronicle.roleAssignments || []).map((ra: { entityId: string }) => ra.entityId).filter(Boolean)\n  );\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: Array.from(relatedEntityIds),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"chronicle\",\n    targetId: chronicleId,\n    targetName: chronicle.title || \"Untitled Chronicle\",\n    sourceText: content,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || chronicle.assignedTone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "corpusStrengthCache", "type": "{ runId: string | null; strength: Map<string, number> | null }", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "reinforcementCache", "type": "ReinforcementCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildCorpusVoiceDigest", "name": "buildCorpusVoiceDigest", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildCorpusVoiceDigest(\n  cache?: CorpusVoiceDigestCache\n): Promise<CorpusVoiceDigest> {\n  const { simulationRunId } = useEntityStore.getState();\n\n  if (cache && cache.runId === simulationRunId && cache.digest) {\n    return cache.digest;\n  }\n\n  const allTexts = simulationRunId ? await collectCorpusNotes(simulationRunId) : [];\n\n  const digest: CorpusVoiceDigest = {\n    superlativeClaims: extractSuperlativeClaims(allTexts),\n    overusedOpenings: findOverusedOpenings(allTexts),\n    lengthHistogram: computeLengthHistogram(allTexts),\n    tangentCount: allTexts.filter((n) => n.type === \"tangent\").length,\n    totalNotes: allTexts.length,\n    targetCount: new Set(allTexts.map((n) => n.targetName)).size,\n  };\n\n  if (cache) {\n    cache.runId = simulationRunId || null;\n    cache.digest = digest;\n  }\n\n  return digest;\n}", "parameters": [{"name": "cache", "type": "CorpusVoiceDigestCache", "optional": true}], "returnType": "Promise<CorpusVoiceDigest>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildFactCoverageGuidance", "name": "buildFactCoverageGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build a prioritized list of facts the historian should pay attention to.\n * Returns null if no guidance is needed (all facts are well-represented).\n *\n * \"surface\" targets: facts rated \"mentioned\" \u2014 material exists, historian should draw attention\n * \"connect\" targets: facts rated \"missing\" \u2014 historian should find natural openings for tangent\n *\n * Dynamic dampening: facts that have already been reinforced more than their fair share\n * (relative to total annotations with guidance and total eligible facts) get their score\n * reduced proportionally, preventing any single fact from dominating annotation guidance.\n */\nexport function buildFactCoverageGuidance(\n  report: FactCoverageReport,\n  corpusStrength: Map<string, number>,\n  excludeFactIds?: Set<string>,\n  reinforcement?: ReinforcementCounts\n): FactGuidanceTarget[] | null {\n  const eligible = report.entries\n    .filter((e) => e.rating !== \"integral\" && e.rating !== \"prevalent\")\n    .filter((e) => !excludeFactIds || !excludeFactIds.has(e.factId));\n\n  // Fair share: if each annotation picks 2 targets from F eligible facts across T annotations,\n  // each fact's expected reinforcement count is 2T / F.\n  const eligibleFactCount = eligible.length;\n  const fairShare =\n    reinforcement && eligibleFactCount > 0 && reinforcement.totalAnnotationsWithGuidance > 0\n      ? (2 * reinforcement.totalAnnotationsWithGuidance) / eligibleFactCount\n      : 0;\n\n  const scored = eligible\n    .map((e) => {\n      let score = 0;\n      if (e.rating === \"mentioned\") score += 3;\n      if (e.rating === \"missing\") score += 1;\n      const strength = corpusStrength.get(e.factId) ?? 50;\n      if (strength < 25) score += 3;\n      else if (strength < 50) score += 1;\n      if (e.wasFaceted) score += 1;\n\n      // Dynamic dampening: penalize facts that have consumed more than their fair share\n      if (reinforcement && fairShare > 0) {\n        const count = reinforcement.counts.get(e.factId) ?? 0;\n        const ratio = count / fairShare;\n        if (ratio > 1) {\n          score -= Math.floor((ratio - 1) * 3);\n        }\n      }\n\n      return { entry: e, score, strength };\n    })\n    .filter((s) => s.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 2);\n\n  if (scored.length === 0) return null;\n\n  return scored.map((s) => ({\n    factId: s.entry.factId,\n    factText: s.entry.factText,\n    action: s.entry.rating === \"mentioned\" ? (\"surface\" as const) : (\"connect\" as const),\n    evidence: s.entry.rating === \"mentioned\" ? s.entry.evidence : undefined,\n    corpusStrength: s.strength,\n  }));\n}", "parameters": [{"name": "report", "type": "FactCoverageReport", "optional": false}, {"name": "corpusStrength", "type": "Map<string, number>", "optional": false}, {"name": "excludeFactIds", "type": "Set<string>", "optional": true}, {"name": "reinforcement", "type": "ReinforcementCounts", "optional": true}], "returnType": "FactGuidanceTarget[] | null"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::noteDisplay", "name": "noteDisplay", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Resolve effective display mode, handling legacy `enabled` field */\nexport function noteDisplay(\n  note: Pick<HistorianNote, \"display\" | \"enabled\">\n): HistorianNoteDisplay {\n  if (note.display) return note.display;\n  if (note.enabled === false) return \"disabled\";\n  return \"full\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "HistorianNoteDisplay"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isNoteActive", "name": "isNoteActive", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Whether a note is functionally active (not disabled) */\nexport function isNoteActive(note: Pick<HistorianNote, \"display\" | \"enabled\">): boolean {\n  return noteDisplay(note) !== \"disabled\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isHistorianConfigured", "name": "isHistorianConfigured", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Check whether a historian config has been meaningfully configured */\nexport function isHistorianConfigured(config: HistorianConfig): boolean {\n  return config.name.trim().length > 0 && config.background.trim().length > 0;\n}", "parameters": [{"name": "config", "type": "HistorianConfig", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::computeNoteRange", "name": "computeNoteRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "export function computeNoteRange(\n  targetType: HistorianTargetType,\n  wordCount: number\n): { min: number; max: number } {\n  if (targetType === \"entity\") {\n    if (wordCount < 150) return { min: 1, max: 1 };\n    if (wordCount < 300) return { min: 1, max: 3 };\n    if (wordCount < 600) return { min: 2, max: 4 };\n    if (wordCount < 1200) return { min: 3, max: 6 };\n    return { min: 4, max: 8 };\n  }\n  // chronicle \u2014 calibrated for ~75w/note targeting ~25% annotation ratio\n  if (wordCount < 300) return { min: 1, max: 2 };\n  if (wordCount < 800) return { min: 2, max: 3 };\n  if (wordCount < 1500) return { min: 3, max: 5 };\n  if (wordCount < 3000) return { min: 5, max: 8 };\n  return { min: 8, max: 13 };\n}", "parameters": [{"name": "targetType", "type": "HistorianTargetType", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "{ min: number; max: number }"}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::analyzeImageRefCompatibility", "name": "analyzeImageRefCompatibility", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Analyze all image refs for compatibility with new content.\n */\nexport function analyzeImageRefCompatibility(\n  imageRefs: ChronicleImageRefs,\n  oldContent: string,\n  newContent: string,\n  sourceVersionId: string,\n  targetVersionId: string\n): ImageRefCompatibilityAnalysis {\n  const refResults = imageRefs.refs.map((ref) => analyzeImageRef(ref, oldContent, newContent));\n\n  const summary = {\n    reusable: refResults.filter((r) => r.recommendation === \"reuse\").length,\n    needsRegeneration: refResults.filter((r) => r.recommendation === \"regenerate\").length,\n    needsReview: refResults.filter((r) => r.recommendation === \"manual_review\").length,\n  };\n\n  return {\n    sourceVersionId,\n    targetVersionId,\n    refs: refResults,\n    summary,\n  };\n}", "parameters": [{"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "oldContent", "type": "string", "optional": false}, {"name": "newContent", "type": "string", "optional": false}, {"name": "sourceVersionId", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": false}], "returnType": "ImageRefCompatibilityAnalysis"}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::createDefaultSelections", "name": "createDefaultSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Create default selections based on compatibility analysis.\n */\nexport function createDefaultSelections(\n  analysis: ImageRefCompatibilityAnalysis\n): ImageRefSelection[] {\n  return analysis.refs.map((ref) => ({\n    refId: ref.refId,\n    action: ref.recommendation === \"regenerate\" ? \"regenerate\" : \"reuse\",\n  }));\n}", "parameters": [{"name": "analysis", "type": "ImageRefCompatibilityAnalysis", "optional": false}], "returnType": "ImageRefSelection[]"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getSizeOptions", "name": "getSizeOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get size options for a given model\n */\nexport function getSizeOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_SIZES_BY_MODEL[model] || IMAGE_SIZES_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getQualityOptions", "name": "getQualityOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get quality options for a given model\n */\nexport function getQualityOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_QUALITY_BY_MODEL[model] || IMAGE_QUALITY_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultSize", "name": "getDefaultSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default size for a model\n */\nexport function getDefaultSize(model: string): string {\n  const options = getSizeOptions(model);\n  return options[0]?.value || \"1024x1024\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultQuality", "name": "getDefaultQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default quality for a model\n */\nexport function getDefaultQuality(model: string): string {\n  const options = getQualityOptions(model);\n  return options[0]?.value || \"standard\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidSize", "name": "isValidSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a size is valid for a model\n */\nexport function isValidSize(model: string, size: string): boolean {\n  const options = getSizeOptions(model);\n  return options.some((opt) => opt.value === size);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidQuality", "name": "isValidQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a quality is valid for a model\n */\nexport function isValidQuality(model: string, quality: string): boolean {\n  const options = getQualityOptions(model);\n  return options.some((opt) => opt.value === quality);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/llmBudget.ts::calcTokenBudget", "name": "calcTokenBudget", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmBudget.ts", "sourceCode": "export function calcTokenBudget(\n  callType: LLMCallType,\n  callConfig: ResolvedLLMCallConfig,\n  options: TokenBudgetOptions = {}\n): TokenBudget {\n  const defaultMaxTokens = LLM_CALL_METADATA[callType]?.defaults.maxTokens ?? 0;\n  const fallbackMaxTokens =\n    defaultMaxTokens > 0 ? defaultMaxTokens : (options.autoMaxTokens ?? DEFAULT_AUTO_MAX_TOKENS);\n  const responseBudget = callConfig.maxTokens > 0 ? callConfig.maxTokens : fallbackMaxTokens;\n  const safeResponseBudget = responseBudget > 0 ? responseBudget : DEFAULT_AUTO_MAX_TOKENS;\n  const thinkingBudget = callConfig.thinkingBudget > 0 ? callConfig.thinkingBudget : undefined;\n  const totalMaxTokens = thinkingBudget ? thinkingBudget + safeResponseBudget : safeResponseBudget;\n  return { responseBudget: safeResponseBudget, thinkingBudget, totalMaxTokens };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}, {"name": "options", "type": "TokenBudgetOptions", "optional": true}], "returnType": "TokenBudget"}, {"id": "apps/illuminator/webui/src/lib/llmCallTypes.ts::getCallTypesByCategory", "name": "getCallTypesByCategory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmCallTypes.ts", "sourceCode": "// Group call types by category\nexport function getCallTypesByCategory(): Record<LLMCallCategory, LLMCallType[]> {\n  return {\n    description: [\"description.narrative\", \"description.visualThesis\", \"description.visualTraits\"],\n    image: [\"image.promptFormatting\", \"image.chronicleFormatting\"],\n    perspective: [\"perspective.synthesis\"],\n    chronicle: [\n      \"chronicle.generation\",\n      \"chronicle.compare\",\n      \"chronicle.combine\",\n      \"chronicle.copyEdit\",\n      \"chronicle.quickCheck\",\n      \"chronicle.summary\",\n      \"chronicle.title\",\n      \"chronicle.imageRefs\",\n      \"chronicle.coverImageScene\",\n      \"chronicle.toneRanking\",\n      \"chronicle.bulkToneRanking\",\n    ],\n    palette: [\"palette.expansion\"],\n    dynamics: [\"dynamics.generation\"],\n    revision: [\"revision.summary\", \"revision.loreBackport\"],\n    historian: [\n      \"historian.entityReview\",\n      \"historian.chronicleReview\",\n      \"historian.edition\",\n      \"historian.chronology\",\n      \"historian.prep\",\n      \"historian.eraNarrative.threads\",\n      \"historian.eraNarrative.generate\",\n      \"historian.eraNarrative.edit\",\n      \"historian.eraNarrative.coverImageScene\",\n      \"historian.eraNarrative.imageRefs\",\n      \"historian.motifVariation\",\n    ],\n  };\n}", "parameters": [], "returnType": "Record<LLMCallCategory, LLMCallType[]>"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getLLMModelSettings", "name": "getLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Load settings from localStorage\n */\nexport function getLLMModelSettings(): LLMModelSettings {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      const parsed = JSON.parse(stored);\n      return migrateSettings(parsed);\n    }\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to load settings:\", err);\n  }\n  return { callOverrides: {}, version: CURRENT_VERSION };\n}", "parameters": [], "returnType": "LLMModelSettings"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::saveLLMModelSettings", "name": "saveLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "export function saveLLMModelSettings(settings: LLMModelSettings): void {\n  try {\n    const cleanOverrides: LLMModelSettings[\"callOverrides\"] = {};\n    for (const [callType, config] of Object.entries(settings.callOverrides)) {\n      if (!config) continue;\n      const metadata = LLM_CALL_METADATA[callType as LLMCallType];\n      if (!metadata) continue;\n\n      const overrides = extractNonDefaultOverrides(config, metadata.defaults);\n      if (overrides) {\n        cleanOverrides[callType as LLMCallType] = overrides;\n      }\n    }\n\n    localStorage.setItem(\n      STORAGE_KEY,\n      JSON.stringify({\n        callOverrides: cleanOverrides,\n        version: settings.version,\n      })\n    );\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to save settings:\", err);\n  }\n}", "parameters": [{"name": "settings", "type": "LLMModelSettings", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getModelForCall", "name": "getModelForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the model for a specific call type\n */\nexport function getModelForCall(callType: LLMCallType): string {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.model ?? LLM_CALL_METADATA[callType].defaults.model;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getThinkingBudgetForCall", "name": "getThinkingBudgetForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the thinking budget for a specific call type\n */\nexport function getThinkingBudgetForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.thinkingBudget ?? LLM_CALL_METADATA[callType].defaults.thinkingBudget;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getMaxTokensForCall", "name": "getMaxTokensForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the max tokens (pre-reasoning budget) for a specific call type\n */\nexport function getMaxTokensForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.maxTokens ?? LLM_CALL_METADATA[callType].defaults.maxTokens;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get complete resolved config for a call\n */\nexport function getCallConfig(callType: LLMCallType): ResolvedLLMCallConfig {\n  const model = getModelForCall(callType);\n  let thinkingBudget = getThinkingBudgetForCall(callType);\n  const maxTokens = getMaxTokensForCall(callType);\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  const defaults = LLM_CALL_METADATA[callType].defaults;\n  const temperature = override?.temperature ?? defaults.temperature;\n  const topP = override?.topP ?? defaults.topP;\n\n  // Ensure thinking is disabled for models that don't support it\n  if (!THINKING_CAPABLE_MODELS.includes(model)) {\n    thinkingBudget = 0;\n  }\n\n  const streamTimeout = override?.streamTimeout ?? defaults.streamTimeout ?? 0;\n  const disableStreaming = override?.disableStreaming ?? defaults.disableStreaming ?? false;\n  const runInBrowser = override?.runInBrowser ?? defaults.runInBrowser ?? false;\n\n  return {\n    model,\n    thinkingBudget,\n    maxTokens,\n    temperature,\n    topP,\n    streamTimeout,\n    disableStreaming,\n    runInBrowser,\n  };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getResolvedLLMCallSettings", "name": "getResolvedLLMCallSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get all resolved settings for passing to worker\n */\nexport function getResolvedLLMCallSettings(): ResolvedLLMCallSettings {\n  const result = {} as ResolvedLLMCallSettings;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    result[callType] = getCallConfig(callType);\n  }\n  return result;\n}", "parameters": [], "returnType": "ResolvedLLMCallSettings"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::updateCallConfig", "name": "updateCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Update configuration for a specific call type\n */\nexport function updateCallConfig(callType: LLMCallType, config: LLMCallConfigStored): void {\n  const settings = getLLMModelSettings();\n  settings.callOverrides[callType] = config;\n  saveLLMModelSettings(settings);\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "config", "type": "LLMCallConfigStored", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::resetToDefaults", "name": "resetToDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Reset all settings to defaults\n */\nexport function resetToDefaults(): void {\n  saveLLMModelSettings({ callOverrides: {}, version: CURRENT_VERSION });\n}", "parameters": [], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::hasOverrides", "name": "hasOverrides", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Check if a call type has any overrides from default\n */\nexport function hasOverrides(callType: LLMCallType): boolean {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  if (!override) return false;\n\n  const metadata = LLM_CALL_METADATA[callType];\n  return (\n    (override.model !== undefined && override.model !== metadata.defaults.model) ||\n    (override.thinkingBudget !== undefined &&\n      override.thinkingBudget !== metadata.defaults.thinkingBudget) ||\n    (override.maxTokens !== undefined && override.maxTokens !== metadata.defaults.maxTokens) ||\n    (override.temperature !== undefined &&\n      override.temperature !== metadata.defaults.temperature) ||\n    (override.topP !== undefined && override.topP !== metadata.defaults.topP) ||\n    (override.streamTimeout !== undefined &&\n      override.streamTimeout !== (metadata.defaults.streamTimeout ?? 0)) ||\n    (override.disableStreaming !== undefined &&\n      override.disableStreaming !== (metadata.defaults.disableStreaming ?? false)) ||\n    (override.runInBrowser !== undefined &&\n      override.runInBrowser !== (metadata.defaults.runInBrowser ?? false))\n  );\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getOverrideCount", "name": "getOverrideCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get count of call types with overrides\n */\nexport function getOverrideCount(): number {\n  let count = 0;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    if (hasOverrides(callType)) count++;\n  }\n  return count;\n}", "parameters": [], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmTextCall.ts::runTextCall", "name": "runTextCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmTextCall.ts", "sourceCode": "export async function runTextCall(options: LLMTextCallOptions): Promise<LLMTextCallResult> {\n  const budget = calcTokenBudget(options.callType, options.callConfig, {\n    autoMaxTokens: options.autoMaxTokens,\n  });\n  const estimate = estimateTextCostForCall(\n    options.prompt,\n    options.callType,\n    options.callConfig.model,\n    budget.responseBudget\n  );\n\n  const result = await options.llmClient.complete({\n    systemPrompt: options.systemPrompt,\n    prompt: options.prompt,\n    model: options.callConfig.model,\n    maxTokens: budget.totalMaxTokens,\n    temperature: options.temperature,\n    topP: options.topP,\n    thinkingBudget: budget.thinkingBudget,\n    streamTimeout: options.callConfig.streamTimeout,\n    disableStreaming: options.callConfig.disableStreaming,\n  });\n\n  const usage = result.usage\n    ? {\n        inputTokens: result.usage.inputTokens,\n        outputTokens: result.usage.outputTokens,\n        actualCost: calculateActualTextCost(\n          result.usage.inputTokens,\n          result.usage.outputTokens,\n          options.callConfig.model\n        ),\n      }\n    : {\n        inputTokens: estimate.inputTokens,\n        outputTokens: estimate.outputTokens,\n        actualCost: estimate.estimatedCost,\n      };\n\n  return { result, budget, estimate, usage };\n}", "parameters": [{"name": "options", "type": "LLMTextCallOptions", "optional": false}], "returnType": "Promise<LLMTextCallResult>"}, {"id": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts::synthesizePerspective", "name": "synthesizePerspective", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts", "sourceCode": "/**\n * Synthesize perspective using LLM\n */\nexport async function synthesizePerspective(\n  input: PerspectiveSynthesisInput,\n  llmClient: LLMClient,\n  callConfig: ResolvedLLMCallConfig\n): Promise<PerspectiveSynthesisResult> {\n  const { factsWithMetadata, toneFragments } = input;\n\n  // Separate generation constraints (always included verbatim, not sent to LLM)\n  const generationConstraints = (factsWithMetadata || []).filter(\n    (f) => f.type === \"generation_constraint\" && !f.disabled\n  );\n\n  // Build prompt with ALL baseline material - let LLM do the refinement\n  const { prompt: userPrompt, resolvedWorldDynamics } = buildUserPrompt(input);\n\n  // Assembled tone is the core tone fragment\n  const assembledTone = toneFragments.core;\n\n  // Make LLM call\n  const callResult = await runTextCall({\n    llmClient,\n    callType: \"perspective.synthesis\",\n    callConfig,\n    systemPrompt: SYSTEM_PROMPT,\n    prompt: userPrompt,\n    temperature: 0.7, // Allow variation\n  });\n\n  // Parse response\n  const synthesis = parseSynthesisResponse(callResult.result.text);\n\n  // Enforce required facts and finalize\n  const enforcedSynthesis = enforceFacetRequirements(synthesis, input);\n\n  // Build faceted facts for generation\n  const facetedFacts = buildFacetedFacts(enforcedSynthesis, factsWithMetadata, generationConstraints);\n\n  return {\n    synthesis: enforcedSynthesis,\n    assembledTone,\n    facetedFacts,\n    resolvedWorldDynamics,\n    usage: callResult.usage,\n  };\n}", "parameters": [{"name": "input", "type": "PerspectiveSynthesisInput", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}], "returnType": "Promise<PerspectiveSynthesisResult>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getTone", "name": "getTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat tone string from structured context\n */\nexport function getTone(ctx: WorldContext): string {\n  return ctx.toneFragments?.core || \"\";\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getCanonFacts", "name": "getCanonFacts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat canon facts array from structured context\n */\nexport function getCanonFacts(ctx: WorldContext): string[] {\n  return (ctx.canonFactsWithMetadata || []).map((f) => f.text);\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getKindGuidance", "name": "getKindGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// NEW: Helper Functions for Entity Guidance\n// =============================================================================\n\n/**\n * Get guidance for a specific entity kind\n * Returns undefined if kind not found (caller should handle gracefully)\n */\nexport function getKindGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): KindGuidance | undefined {\n  return entityGuidance[kind];\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "KindGuidance | undefined"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredVisualIdentity", "name": "getFilteredVisualIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual identity for a culture, filtered by entity kind\n */\nexport function getFilteredVisualIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureVisual = cultureIdentities.visual[culture];\n  if (!cultureVisual) return {};\n\n  const allowedKeys = cultureIdentities.visualKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureVisual;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureVisual[key]) {\n      filtered[key] = cultureVisual[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredDescriptiveIdentity", "name": "getFilteredDescriptiveIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get descriptive identity for a culture, filtered by entity kind\n */\nexport function getFilteredDescriptiveIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureDescriptive = cultureIdentities.descriptive[culture];\n  if (!cultureDescriptive) return {};\n\n  const allowedKeys = cultureIdentities.descriptiveKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureDescriptive;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureDescriptive[key]) {\n      filtered[key] = cultureDescriptive[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildProseHints", "name": "buildProseHints", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build prose hints for chronicle generation\n * Aggregates proseHint from all involved entity kinds\n */\nexport function buildProseHints(entityGuidance: EntityGuidance, involvedKinds: string[]): string {\n  const uniqueKinds = [...new Set(involvedKinds)];\n  const hints: string[] = [];\n\n  for (const kind of uniqueKinds) {\n    const guidance = entityGuidance[kind];\n    if (guidance?.proseHint) {\n      hints.push(`${kind.toUpperCase()}: ${guidance.proseHint}`);\n    }\n  }\n\n  return hints.length > 0 ? hints.join(\"\\n\") : \"\";\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "involvedKinds", "type": "string[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildDescriptionPromptFromGuidance", "name": "buildDescriptionPromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// Prompt Builders (using EntityGuidance directly)\n// =============================================================================\n\n/**\n * Build a description prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildDescriptionPromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Get filtered cultural identities\n  const descriptiveIdentity = getFilteredDescriptiveIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n\n  // Format sections\n  const tagsSection =\n    e.tags && Object.keys(e.tags).length > 0\n      ? `TAGS:\\n${Object.entries(e.tags)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const descriptiveSection =\n    Object.keys(descriptiveIdentity).length > 0\n      ? `CULTURAL IDENTITY (${e.culture}):\\n${Object.entries(descriptiveIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const visualSection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const relationshipsSection =\n    entityContext.relationships.length > 0\n      ? entityContext.relationships\n          .slice(0, 8)\n          .map((r) => {\n            let line = `- ${r.kind}: ${r.targetName} (${r.targetKind}`;\n            if (r.targetSubtype) line += `/${r.targetSubtype}`;\n            line += \")\";\n            const strength = r.strength ?? 0.5;\n            let label: string;\n            if (strength >= 0.7) label = \"strong\";\n            else if (strength >= 0.4) label = \"moderate\";\n            else label = \"weak\";\n            line += ` [${label}]`;\n            return line;\n          })\n          .join(\"\\n\")\n      : \"(No established relationships)\";\n\n  const parts = [\n    `Write a description for ${e.name}, a ${e.subtype} ${kind} in ${worldContext.name}.`,\n    \"\",\n    `WORLD: ${worldContext.description}`,\n    \"\",\n    \"TONE & STYLE:\",\n    getTone(worldContext),\n    \"\",\n    \"CANON FACTS (never contradict):\",\n    getCanonFacts(worldContext)\n      .map((f) => `- ${f}`)\n      .join(\"\\n\"),\n    \"\",\n    \"---\",\n    \"\",\n    \"ENTITY:\",\n    `- Kind: ${kind}`,\n    `- Subtype: ${e.subtype}`,\n    `- Prominence: ${e.prominence}`,\n    `- Status: ${e.status}`,\n    `- Culture: ${e.culture || \"unaffiliated\"}`,\n    `- Age in world: ${entityContext.entityAge}`,\n    \"\",\n    tagsSection,\n    descriptiveSection,\n    visualSection,\n    \"\",\n    \"RELATIONSHIPS:\",\n    relationshipsSection,\n    \"\",\n    entityContext.culturalPeers?.length\n      ? `CULTURAL PEERS: ${entityContext.culturalPeers.join(\", \")}`\n      : \"\",\n    entityContext.factionMembers?.length\n      ? `FACTION MEMBERS: ${entityContext.factionMembers.join(\", \")}`\n      : \"\",\n    \"\",\n    // Add events section if entity has narrative history\n    entityContext.events?.length\n      ? `HISTORY FRAGMENTS (mine for flavor, don't enumerate):\\n${entityContext.events\n          .map((ev) => `- [${ev.era}] ${ev.description}`)\n          .join(\"\\n\")}`\n      : \"\",\n    \"\",\n    `ERA: ${entityContext.era.name}${entityContext.era.description ? \" - \" + entityContext.era.description : \"\"}`,\n    \"\",\n    \"---\",\n    \"\",\n    `FOCUS FOR ${kind.toUpperCase()}:`,\n    guidance.focus,\n    \"\",\n    \"RELATIONSHIP GUIDANCE:\",\n    guidance.relationshipUse,\n    \"\",\n    \"---\",\n    \"\",\n    \"OUTPUT: Return JSON with keys: summary, description, aliases\",\n    \"- description: 2-4 sentences, vivid and specific\",\n    \"- summary: 1-2 sentences, compressed and faithful to description\",\n    \"- aliases: array of alternate names (can be empty)\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildImagePromptFromGuidance", "name": "buildImagePromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildImagePromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext,\n  styleInfo?: StyleInfo\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Use summary for image prompts (concise text for visual generation)\n  const summaryText = e.summary || \"\";\n\n  // Visual thesis - THE primary visual signal\n  const visualThesisSection = e.visualThesis\n    ? `VISUAL THESIS (PRIMARY - this is the dominant visual signal):\\n${e.visualThesis}`\n    : \"\";\n\n  // Supporting traits\n  const traitsBody = e.visualTraits?.length\n    ? e.visualTraits.map((t) => `- ${t}`).join(\"\\n\")\n    : \"\";\n  const supportingTraitsSection = traitsBody\n    ? `SUPPORTING TRAITS (reinforce the thesis):\\n${traitsBody}`\n    : \"\";\n\n  // Cultural visual identity\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentitySection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  // Style sections\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : \"\";\n\n  // Species constraint section - placed prominently after IMAGE INSTRUCTIONS\n  const speciesSection = worldContext.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${worldContext.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    `IMAGE INSTRUCTIONS: ${guidance.imageInstructions}`,\n    speciesSection,\n    \"\",\n    `SUBJECT: ${e.name}, a ${e.subtype} ${kind}`,\n    summaryText ? `CONTEXT: ${summaryText}` : \"\",\n    \"\",\n    visualThesisSection,\n    supportingTraitsSection,\n    visualIdentitySection,\n    \"\",\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    \"RENDER: Favor stylized exaggeration over anatomical realism. Push proportions to emphasize the thesis.\",\n    \"\",\n    `SETTING: ${worldContext.name}`,\n    \"\",\n    `AVOID: ${guidance.imageAvoid}`,\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getVisualConfigFromGuidance", "name": "getVisualConfigFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual config for an entity from EntityGuidance\n */\nexport function getVisualConfigFromGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): {\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n} {\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n  return {\n    visualAvoid: guidance.imageAvoid,\n    visualThesisInstructions: `${guidance.visualThesis.domain}\\n\\n${guidance.visualThesis.focus}`,\n    visualThesisFraming: guidance.visualThesis.framing,\n    visualTraitsInstructions: `${guidance.visualTraits.domain}\\n\\n${guidance.visualTraits.focus}`,\n    visualTraitsFraming: guidance.visualTraits.framing,\n  };\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "{\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n}"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultEntityGuidance", "name": "createDefaultEntityGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default entity guidance (fallback when none provided)\n */\nexport function createDefaultEntityGuidance(): EntityGuidance {\n  return {};\n}", "parameters": [], "returnType": "EntityGuidance"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultCultureIdentities", "name": "createDefaultCultureIdentities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default culture identities (fallback when none provided)\n */\nexport function createDefaultCultureIdentities(): CultureIdentities {\n  return {\n    visual: {},\n    descriptive: {},\n    visualKeysByKind: {},\n    descriptiveKeysByKind: {},\n  };\n}", "parameters": [], "returnType": "CultureIdentities"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildChronicleScenePrompt", "name": "buildChronicleScenePrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt for chronicle scene/montage images.\n * Rendering directives (STYLE/PALETTE/COMPOSITION) come first as primary authority.\n * No entity lookups \u2014 visual identity is baked into the scene description by the scene LLM.\n */\nexport function buildChronicleScenePrompt(\n  context: ChronicleSceneContext,\n  styleInfo?: StyleInfo\n): string {\n  const { sceneDescription, size, chronicleTitle, world } = context;\n\n  // Rendering directives first \u2014 these are the primary visual authority\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionHint = SIZE_COMPOSITION_HINTS[size] || SIZE_COMPOSITION_HINTS.medium;\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : `COMPOSITION: ${compositionHint}`;\n\n  const sizeHint = `SIZE HINT: ${compositionHint}`;\n\n  // Scene content\n  const worldDescSuffix = world?.description ? ` - ${world.description}` : \"\";\n  const worldSection = world\n    ? `WORLD: ${world.name}${worldDescSuffix}`\n    : \"\";\n\n  const speciesSection = world?.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${world.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    sizeHint,\n    \"\",\n    `SCENE: ${sceneDescription}`,\n    chronicleTitle ? `FROM: \"${chronicleTitle}\"` : \"\",\n    \"\",\n    worldSection,\n    speciesSection,\n    \"\",\n    \"AVOID: Human figures, humanoid hands or fingers, human body proportions. Modern elements, anachronistic technology, text overlays, watermarks\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "context", "type": "ChronicleSceneContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/traitPalette.ts::expandPalette", "name": "expandPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/traitPalette.ts", "sourceCode": "// ============================================================================\n// Expansion Execution\n// ============================================================================\n\nexport async function expandPalette(\n  request: PaletteExpansionRequest,\n  llmClient: LLMClient\n): Promise<PaletteExpansionResult> {\n  const { projectId, entityKind, worldContext } = request;\n\n  if (!llmClient.isEnabled()) {\n    return { success: false, error: \"LLM client not configured\" };\n  }\n\n  // Get model settings for palette expansion\n  const callConfig = getCallConfig(\"palette.expansion\");\n  const { model } = callConfig;\n\n  // Gather current state\n  const currentPalette = await getPalette(projectId, entityKind);\n  const historicalTraits = await getHistoricalTraits(projectId, entityKind);\n\n  const prompt = buildExpansionPrompt(\n    entityKind,\n    worldContext,\n    currentPalette?.items || [],\n    historicalTraits\n  );\n\n  const expansionCall = await runTextCall({\n    llmClient,\n    callType: \"palette.expansion\",\n    callConfig,\n    systemPrompt: EXPANSION_SYSTEM_PROMPT,\n    prompt,\n    temperature: 0.9,\n  });\n  const result = expansionCall.result;\n\n  if (result.error || !result.text) {\n    return {\n      success: false,\n      error: result.error || \"Empty response from LLM\",\n    };\n  }\n\n  // Parse response\n  let expansion: ExpansionResponse;\n  try {\n    expansion = parseExpansionResponse(result.text);\n  } catch (err) {\n    return {\n      success: false,\n      error: `Failed to parse expansion response: ${err instanceof Error ? err.message : \"Unknown error\"}`,\n    };\n  }\n\n  // Apply updates\n  const updatedPalette = await updatePaletteItems(projectId, entityKind, {\n    removeIds: expansion.removedCategories,\n    merges: expansion.mergedCategories,\n    newItems: expansion.newCategories,\n  });\n\n  // Calculate costs\n  const cost = {\n    estimated: expansionCall.estimate.estimatedCost,\n    actual: expansionCall.usage.actualCost,\n    inputTokens: expansionCall.usage.inputTokens,\n    outputTokens: expansionCall.usage.outputTokens,\n  };\n\n  // Save cost record\n  await saveCostRecordWithDefaults({\n    projectId,\n    simulationRunId: request.simulationRunId,\n    type: \"paletteExpansion\",\n    model,\n    estimatedCost: cost.estimated,\n    actualCost: cost.actual,\n    inputTokens: cost.inputTokens,\n    outputTokens: cost.outputTokens,\n  });\n\n  return {\n    success: true,\n    palette: updatedPalette,\n    stats: {\n      removed: expansion.removedCategories?.length || 0,\n      merged: expansion.mergedCategories?.length || 0,\n      added: expansion.newCategories?.length || 0,\n    },\n    cost,\n  };\n}", "parameters": [{"name": "request", "type": "PaletteExpansionRequest", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}], "returnType": "Promise<PaletteExpansionResult>"}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::findEntityMentions", "name": "findEntityMentions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "/**\n * Find entity mentions in text using Aho-Corasick matching.\n * Returns one match per entity (first occurrence), no overlap filtering.\n * Use this for detection (e.g. tertiary cast) where we need to know\n * which entities are mentioned regardless of overlapping spans.\n */\nexport function findEntityMentions(content: string, entities: WikiLinkEntity[]): WikiLinkMatch[] {\n  if (!content || entities.length === 0) return [];\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  return Array.from(matchesByEntity.values());\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkMatch[]"}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "export function applyWikiLinks(content: string, entities: WikiLinkEntity[]): WikiLinkResult {\n  if (!content || entities.length === 0) {\n    return { content, links: [], collisions: [] };\n  }\n\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  const matches = filterOverlaps(Array.from(matchesByEntity.values()));\n\n  if (matches.length === 0) {\n    return { content, links: [], collisions: automaton.collisions };\n  }\n\n  let cursor = 0;\n  const output: string[] = [];\n\n  for (const match of matches) {\n    if (match.start > cursor) {\n      output.push(content.slice(cursor, match.start));\n    }\n    const rawSegment = content.slice(match.start, match.end);\n    output.push(`[[${rawSegment}]]`);\n    cursor = match.end;\n  }\n\n  if (cursor < content.length) {\n    output.push(content.slice(cursor));\n  }\n\n  return {\n    content: output.join(\"\"),\n    links: matches,\n    collisions: automaton.collisions,\n  };\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkResult"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isSharedWorkerSupported", "name": "isSharedWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Check if SharedWorker is supported\n */\nexport function isSharedWorkerSupported(): boolean {\n  return typeof SharedWorker !== \"undefined\";\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isServiceWorkerSupported", "name": "isServiceWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function isServiceWorkerSupported(): boolean {\n  return (\n    typeof navigator !== \"undefined\" &&\n    \"serviceWorker\" in navigator &&\n    typeof window !== \"undefined\" &&\n    window.isSecureContext\n  );\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorker", "name": "createWorker", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Create a worker handle that abstracts SharedWorker vs regular Worker\n */\nexport function createWorker(config: WorkerConfig): WorkerHandle {\n  if (isServiceWorkerSupported()) {\n    const handle = createServiceWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    return handle;\n  }\n\n  // Try SharedWorker first\n  if (isSharedWorkerSupported()) {\n    try {\n      const handle = createSharedWorkerHandle();\n      handle.postMessage({ type: \"init\", config });\n      return handle;\n    } catch (err) {\n      console.warn(\"[WorkerFactory] SharedWorker failed, falling back to dedicated Worker:\", err);\n    }\n  }\n\n  // Fallback to regular Worker\n  const handle = createDedicatedWorkerHandle();\n  handle.postMessage({ type: \"init\", config });\n  return handle;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "WorkerHandle"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorkerPool", "name": "createWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function createWorkerPool(config: WorkerConfig, count: number): WorkerHandle[] {\n  if (isServiceWorkerSupported()) {\n    const handles = fillFromPool(getServiceWorkerPool(), count, createServiceWorkerHandle, \"ServiceWorker handle\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  if (isSharedWorkerSupported()) {\n    const handles = fillFromPool(getSharedWorkerPool(), count, createSharedWorkerHandle, \"SharedWorker port\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  const handles: WorkerHandle[] = [];\n  for (let i = 0; i < count; i++) {\n    const handle = createDedicatedWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    handles.push(handle);\n  }\n  return handles;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "WorkerHandle[]"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::resetWorkerPool", "name": "resetWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function resetWorkerPool(): void {\n  const sharedPool = getSharedWorkerPool();\n  for (const handle of sharedPool) {\n    handle?.terminate();\n  }\n  sharedPool.length = 0;\n\n  const servicePool = getServiceWorkerPool();\n  for (const handle of servicePool) {\n    handle?.terminate();\n  }\n  servicePool.length = 0;\n\n  const globalScope = globalThis as GlobalServiceWorkerState;\n  if (globalScope.__illuminatorServiceWorkerHandleMap) {\n    globalScope.__illuminatorServiceWorkerHandleMap.clear();\n  }\n}", "parameters": [], "returnType": "void"}, {"id": "apps/illuminator/webui/src/workers/clients.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/clients.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}"}]