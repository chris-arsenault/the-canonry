[{"id": "apps/name-forge/lib/derivation.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/derivation.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType"}, {"id": "apps/name-forge/lib/generate.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>"}, {"id": "apps/name-forge/lib/generate.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/name-forge/lib/generate.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/generate.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult"}, {"id": "apps/name-forge/lib/generate.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/name-forge/lib/index.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>"}, {"id": "apps/name-forge/lib/index.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/name-forge/lib/index.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult"}, {"id": "apps/name-forge/lib/index.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/name-forge/lib/index.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult"}, {"id": "apps/name-forge/lib/index.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }"}, {"id": "apps/name-forge/lib/index.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/index.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }"}, {"id": "apps/name-forge/lib/index.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/index.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/name-forge/lib/index.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number"}, {"id": "apps/name-forge/lib/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/index.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/index.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/index.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType"}, {"id": "apps/name-forge/lib/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport"}, {"id": "apps/name-forge/lib/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport"}, {"id": "apps/name-forge/lib/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport"}, {"id": "apps/name-forge/lib/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}"}, {"id": "apps/name-forge/lib/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]"}, {"id": "apps/name-forge/lib/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}"}, {"id": "apps/name-forge/lib/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector"}, {"id": "apps/name-forge/lib/index.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}"}, {"id": "apps/name-forge/lib/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/markov-loader-node.ts::loadModelFromFilesystem", "name": "loadModelFromFilesystem", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader-node.ts", "sourceCode": "/**\r\n * Load a model from the filesystem.\r\n */\r\nexport function loadModelFromFilesystem(modelId: string): MarkovModel | null {\r\n  const modelPath = path.join(modelsDir, `${modelId}.json`);\r\n\r\n  if (!fs.existsSync(modelPath)) {\r\n    console.warn(`Markov model '${modelId}' not found at ${modelPath}`);\r\n    return null;\r\n  }\r\n\r\n  const data = fs.readFileSync(modelPath, \"utf-8\");\r\n  return JSON.parse(data) as MarkovModel;\r\n}", "parameters": [{"name": "modelId", "type": "string", "optional": false}], "returnType": "MarkovModel | null"}, {"id": "apps/name-forge/lib/markov-loader.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/name-forge/lib/markov-loader.ts::loadMarkovModel", "name": "loadMarkovModel", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Load a Markov model by ID.\r\n */\r\nexport async function loadMarkovModel(\r\n  modelId: MarkovModelId\r\n): Promise<MarkovModel | null> {\r\n  // Check cache first\r\n  if (modelCache.has(modelId)) {\r\n    return modelCache.get(modelId)!;\r\n  }\r\n\r\n  try {\r\n    const model = isBrowser\r\n      ? await loadFromBrowser(modelId)\r\n      : await loadFromNode(modelId);\r\n\r\n    if (model) {\r\n      modelCache.set(modelId, model);\r\n    }\r\n    return model;\r\n  } catch (error) {\r\n    console.warn(`Failed to load Markov model '${modelId}':`, error);\r\n    return null;\r\n  }\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "Promise<MarkovModel | null>"}, {"id": "apps/name-forge/lib/markov-loader.ts::extractMarkovModelIds", "name": "extractMarkovModelIds", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Grammar Scanning\r\n// ============================================================================\r\n\r\n/**\r\n * Extract Markov model IDs referenced in grammars.\r\n */\r\nexport function extractMarkovModelIds(grammars: Grammar[]): MarkovModelId[] {\r\n  const modelIds = new Set<MarkovModelId>();\r\n\r\n  for (const grammar of grammars) {\r\n    for (const productions of Object.values(grammar.rules || {})) {\r\n      for (const production of productions) {\r\n        for (const token of production) {\r\n          const match = token.match(/markov:([a-z]+)/);\r\n          if (match) {\r\n            modelIds.add(match[1] as MarkovModelId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(modelIds);\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "MarkovModelId[]"}, {"id": "apps/name-forge/lib/markov-loader.ts::preloadModels", "name": "preloadModels", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Preloading\r\n// ============================================================================\r\n\r\n/**\r\n * Preload all Markov models referenced in grammars.\r\n */\r\nexport async function preloadModels(\r\n  grammars: Grammar[]\r\n): Promise<Map<string, MarkovModel>> {\r\n  const modelIds = extractMarkovModelIds(grammars);\r\n  const models = new Map<string, MarkovModel>();\r\n\r\n  await Promise.all(\r\n    modelIds.map(async (id) => {\r\n      const model = await loadMarkovModel(id);\r\n      if (model) {\r\n        models.set(id, model);\r\n      }\r\n    })\r\n  );\r\n\r\n  return models;\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "Promise<Map<string, MarkovModel>>"}, {"id": "apps/name-forge/lib/markov-loader.ts::isModelCached", "name": "isModelCached", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Cache Management\r\n// ============================================================================\r\n\r\n/**\r\n * Check if a model is cached.\r\n */\r\nexport function isModelCached(modelId: MarkovModelId): boolean {\r\n  return modelCache.has(modelId);\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/markov-loader.ts::clearModelCache", "name": "clearModelCache", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Clear the model cache.\r\n */\r\nexport function clearModelCache(): void {\r\n  modelCache.clear();\r\n}", "parameters": [], "returnType": "void"}, {"id": "apps/name-forge/lib/markov.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/markov.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphologyBest", "name": "applyMorphologyBest", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphology with multiple candidates and pick best\r\n * Useful for avoiding overly long or awkward combinations\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphologyBest(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  candidateCount: number = 3,\r\n  maxLength: number = 20,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const candidates: {\r\n    result: string;\r\n    structure: string;\r\n    parts: string[];\r\n    syllables: string[];\r\n    score: number;\r\n  }[] = [];\r\n\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    const morphed = applyMorphology(rng, root, profile, rootSyllables);\r\n\r\n    // Score based on length (prefer moderate length)\r\n    let score = 1.0;\r\n    if (morphed.result.length > maxLength) {\r\n      score *= 0.5; // Penalize overly long names\r\n    }\r\n    if (morphed.result.length < 3) {\r\n      score *= 0.5; // Penalize overly short names\r\n    }\r\n\r\n    candidates.push({ ...morphed, score });\r\n  }\r\n\r\n  // Pick weighted by score\r\n  const scores = candidates.map((c) => c.score);\r\n  const totalScore = scores.reduce((sum, s) => sum + s, 0);\r\n\r\n  const r = rng() * totalScore;\r\n  let cumulative = 0;\r\n  for (const candidate of candidates) {\r\n    cumulative += candidate.score;\r\n    if (r < cumulative) {\r\n      return {\r\n        result: candidate.result,\r\n        structure: candidate.structure,\r\n        parts: candidate.parts,\r\n        syllables: candidate.syllables,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return {\r\n    result: candidates[0].result,\r\n    structure: candidates[0].structure,\r\n    parts: candidates[0].parts,\r\n    syllables: candidates[0].syllables,\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}, {"name": "maxLength", "type": "number", "optional": true}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }"}, {"id": "apps/name-forge/lib/morphology.ts::canApplyMorphology", "name": "canApplyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Check if a morphology profile can actually modify names\r\n * (i.e., has at least some affixes or structures beyond \"root\")\r\n */\r\nexport function canApplyMorphology(profile: MorphologyProfile): boolean {\r\n  // Check if there are any non-root structures\r\n  const hasComplexStructures = profile.structure.some(\r\n    (s) => s !== \"root\" && s.includes(\"-\")\r\n  );\r\n\r\n  if (!hasComplexStructures) {\r\n    return false;\r\n  }\r\n\r\n  // Check if there are any affixes available\r\n  const hasAffixes =\r\n    (profile.prefixes && profile.prefixes.length > 0) ||\r\n    (profile.suffixes && profile.suffixes.length > 0) ||\r\n    (profile.infixes && profile.infixes.length > 0) ||\r\n    (profile.wordRoots && profile.wordRoots.length > 0);\r\n\r\n  return Boolean(hasAffixes);\r\n}", "parameters": [{"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/morphology.ts::generateCompound", "name": "generateCompound", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Generate a compound name (root-root structure)\r\n * Useful for location names and titles\r\n */\r\nexport function generateCompound(\r\n  rng: () => number,\r\n  root1: string,\r\n  root2: string,\r\n  separator: string = \"\"\r\n): string {\r\n  return root1 + separator + root2;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root1", "type": "string", "optional": false}, {"name": "root2", "type": "string", "optional": false}, {"name": "separator", "type": "string", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/morphology.ts::applyHonorific", "name": "applyHonorific", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply honorific prefix\r\n */\r\nexport function applyHonorific(\r\n  rng: () => number,\r\n  name: string,\r\n  profile: MorphologyProfile\r\n): string {\r\n  if (!profile.honorifics || profile.honorifics.length === 0) {\r\n    return name;\r\n  }\r\n\r\n  const honorific = pickRandom(rng, profile.honorifics);\r\n  return `${honorific} ${name}`;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/parameter-encoder.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllConsonants", "name": "getAllConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all consonants as flat array\n */\nexport function getAllConsonants(): string[] {\n  const all: string[] = [];\n  all.push(...CONSONANT_LIBRARY.plosives.voiceless);\n  all.push(...CONSONANT_LIBRARY.plosives.voiced);\n  all.push(...CONSONANT_LIBRARY.nasals);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiceless);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiced);\n  all.push(...CONSONANT_LIBRARY.affricates);\n  all.push(...CONSONANT_LIBRARY.approximants);\n  all.push(...CONSONANT_LIBRARY.trills);\n  all.push(...CONSONANT_LIBRARY.fantasy);\n  return [...new Set(all)]; // Remove duplicates\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllVowels", "name": "getAllVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all vowels as flat array\n */\nexport function getAllVowels(): string[] {\n  const all: string[] = [];\n  all.push(...VOWEL_LIBRARY.basic);\n  all.push(...VOWEL_LIBRARY.front);\n  all.push(...VOWEL_LIBRARY.central);\n  all.push(...VOWEL_LIBRARY.back);\n  all.push(...VOWEL_LIBRARY.long);\n  all.push(...VOWEL_LIBRARY.umlauts);\n  all.push(...VOWEL_LIBRARY.diphthongs);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllTemplates", "name": "getAllTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all templates as flat array\n */\nexport function getAllTemplates(): string[] {\n  const all: string[] = [];\n  all.push(...TEMPLATE_LIBRARY.simple);\n  all.push(...TEMPLATE_LIBRARY.complexOnset);\n  all.push(...TEMPLATE_LIBRARY.complexCoda);\n  all.push(...TEMPLATE_LIBRARY.complex);\n  all.push(...TEMPLATE_LIBRARY.vowelHeavy);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllClusters", "name": "getAllClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all clusters as flat array\n */\nexport function getAllClusters(): string[] {\n  const all: string[] = [];\n  all.push(...CLUSTER_LIBRARY.onsets.stopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.sStop);\n  all.push(...CLUSTER_LIBRARY.onsets.sStopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.other);\n  all.push(...CLUSTER_LIBRARY.codas.liquidStop);\n  all.push(...CLUSTER_LIBRARY.codas.nasalStop);\n  all.push(...CLUSTER_LIBRARY.codas.stopS);\n  all.push(...CLUSTER_LIBRARY.codas.other);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllStructures", "name": "getAllStructures", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all structures as flat array\n */\nexport function getAllStructures(): string[] {\n  const all: string[] = [];\n  all.push(...STRUCTURE_LIBRARY.simple);\n  all.push(...STRUCTURE_LIBRARY.prefixed);\n  all.push(...STRUCTURE_LIBRARY.suffixed);\n  all.push(...STRUCTURE_LIBRARY.compound);\n  all.push(...STRUCTURE_LIBRARY.complex);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableConsonants", "name": "getAvailableConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get phonemes not currently in a domain\n */\nexport function getAvailableConsonants(currentConsonants: string[]): string[] {\n  const all = getAllConsonants();\n  return all.filter(c => !currentConsonants.includes(c));\n}", "parameters": [{"name": "currentConsonants", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableVowels", "name": "getAvailableVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableVowels(currentVowels: string[]): string[] {\n  const all = getAllVowels();\n  return all.filter(v => !currentVowels.includes(v));\n}", "parameters": [{"name": "currentVowels", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableTemplates", "name": "getAvailableTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableTemplates(currentTemplates: string[]): string[] {\n  const all = getAllTemplates();\n  return all.filter(t => !currentTemplates.includes(t));\n}", "parameters": [{"name": "currentTemplates", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableClusters", "name": "getAvailableClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableClusters(currentClusters: string[]): string[] {\n  const all = getAllClusters();\n  return all.filter(c => !currentClusters.includes(c));\n}", "parameters": [{"name": "currentClusters", "type": "string[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phonology.ts::generateSyllable", "name": "generateSyllable", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a single syllable from a phonology profile\r\n */\r\nexport function generateSyllable(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): SyllableResult {\r\n  // Pick a syllable template\r\n  const template = pickWeighted(\r\n    rng,\r\n    profile.syllableTemplates,\r\n    profile.templateWeights\r\n  );\r\n\r\n  // Build syllable by replacing C and V with phonemes\r\n  let syllable = \"\";\r\n  for (const symbol of template) {\r\n    if (symbol === \"C\") {\r\n      // Pick a consonant\r\n      const consonant = pickWeighted(\r\n        rng,\r\n        profile.consonants,\r\n        profile.consonantWeights\r\n      );\r\n      syllable += consonant;\r\n    } else if (symbol === \"V\") {\r\n      // Pick a vowel\r\n      const vowel = pickWeighted(rng, profile.vowels, profile.vowelWeights);\r\n      syllable += vowel;\r\n    } else {\r\n      // Literal character (for templates like \"CVC-\")\r\n      syllable += symbol;\r\n    }\r\n  }\r\n\r\n  return { syllable, template };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "SyllableResult"}, {"id": "apps/name-forge/lib/phonology.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/phonology.ts::generateWordWithFavoredClusters", "name": "generateWordWithFavoredClusters", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate multiple word candidates and pick the best one based on favored clusters\r\n */\r\nexport function generateWordWithFavoredClusters(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  candidateCount: number = 5\r\n): string {\r\n  // If no favored clusters, just generate one word\r\n  if (!profile.favoredClusters || profile.favoredClusters.length === 0) {\r\n    return generateWord(rng, profile);\r\n  }\r\n\r\n  // Generate multiple candidates\r\n  const candidates: string[] = [];\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    candidates.push(generateWord(rng, profile));\r\n  }\r\n\r\n  // Calculate scores based on favored clusters\r\n  const boost = profile.favoredClusterBoost ?? 2.0;\r\n  const scores = candidates.map((word) => {\r\n    const hasFavored = hasFavoredCluster(word, profile.favoredClusters!);\r\n    return hasFavored ? boost : 1.0;\r\n  });\r\n\r\n  // Pick a candidate weighted by scores\r\n  return pickWeighted(rng, candidates, scores);\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/phonology.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]"}, {"id": "apps/name-forge/lib/phonology.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }"}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult"}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/pronounceability.ts::countMaxConsonantCluster", "name": "countMaxConsonantCluster", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Count maximum consecutive consonants in a name\r\n */\r\nexport function countMaxConsonantCluster(name: string): number {\r\n  let maxCluster = 0;\r\n  let currentCluster = 0;\r\n\r\n  for (const char of name.toLowerCase()) {\r\n    if (isVowel(char)) {\r\n      maxCluster = Math.max(maxCluster, currentCluster);\r\n      currentCluster = 0;\r\n    } else if (char.match(/[a-z]/)) {\r\n      // Only count letters, skip apostrophes/hyphens\r\n      currentCluster++;\r\n    }\r\n  }\r\n\r\n  return Math.max(maxCluster, currentCluster);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::checkVowelSpacing", "name": "checkVowelSpacing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Check vowel spacing (max consonants between vowels)\r\n */\r\nexport function checkVowelSpacing(name: string): number {\r\n  const chars = name.toLowerCase().split(\"\");\r\n  let maxGap = 0;\r\n  let currentGap = 0;\r\n  let foundVowel = false;\r\n\r\n  for (const char of chars) {\r\n    if (isVowel(char)) {\r\n      maxGap = Math.max(maxGap, currentGap);\r\n      currentGap = 0;\r\n      foundVowel = true;\r\n    } else if (char.match(/[a-z]/)) {\r\n      if (foundVowel) {\r\n        currentGap++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return maxGap;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreSonoritySequencing", "name": "scoreSonoritySequencing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score sonority sequencing violations\r\n *\r\n * Checks if syllables follow natural sonority rises/falls:\r\n * - Onsets should have rising sonority\r\n * - Codas should have falling sonority\r\n *\r\n * Returns: normalized score 0-1 (1 = perfect, 0 = many violations)\r\n */\r\nexport function scoreSonoritySequencing(\r\n  name: string,\r\n  phonemes: string[],\r\n  customRanks?: Record<string, number>\r\n): number {\r\n  if (phonemes.length === 0) return 1.0;\r\n\r\n  let violations = 0;\r\n  let transitions = 0;\r\n\r\n  // Scan through phoneme sequence\r\n  for (let i = 0; i < phonemes.length - 1; i++) {\r\n    const current = phonemes[i];\r\n    const next = phonemes[i + 1];\r\n\r\n    const currentSonority = getSonority(current, customRanks);\r\n    const nextSonority = getSonority(next, customRanks);\r\n\r\n    transitions++;\r\n\r\n    // If we're going from consonant to consonant\r\n    if (currentSonority < 5 && nextSonority < 5) {\r\n      // In onset (start of syllable), sonority should rise\r\n      // In coda (end of syllable), sonority should fall\r\n      // We penalize plateaus or inversions in consonant clusters\r\n      if (nextSonority < currentSonority) {\r\n        violations++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (transitions === 0) return 1.0;\r\n  return Math.max(0, 1 - violations / transitions);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "customRanks", "type": "Record<string, number>", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreTemplateLegality", "name": "scoreTemplateLegality", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score template legality\r\n *\r\n * Checks if the name can be decomposed into allowed syllable templates.\r\n * Uses the phonology profile's syllable templates.\r\n *\r\n * Returns: 0-1 score (1 = fully legal, 0 = no templates match)\r\n */\r\nexport function scoreTemplateLegality(\r\n  name: string,\r\n  syllables: string[],\r\n  allowedTemplates: string[]\r\n): number {\r\n  if (syllables.length === 0) return 0;\r\n\r\n  let matchedSyllables = 0;\r\n\r\n  for (const syllable of syllables) {\r\n    // Convert syllable to template pattern (C/V)\r\n    const pattern = syllable\r\n      .split(\"\")\r\n      .map((char) => (isVowel(char) ? \"V\" : \"C\"))\r\n      .join(\"\");\r\n\r\n    // Check if pattern matches any allowed template\r\n    if (allowedTemplates.includes(pattern)) {\r\n      matchedSyllables++;\r\n    }\r\n  }\r\n\r\n  return matchedSyllables / syllables.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "allowedTemplates", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreHarmonicConstraints", "name": "scoreHarmonicConstraints", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Compute harmonic constraint violations\r\n *\r\n * Checks culture-specific phonotactic rules:\r\n * - Max consonant cluster size\r\n * - Vowel spacing requirements\r\n *\r\n * Returns: 0-1 score (1 = no violations, 0 = many violations)\r\n */\r\nexport function scoreHarmonicConstraints(\r\n  name: string,\r\n  profile: PhonologyProfile\r\n): number {\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  const actualMaxCluster = countMaxConsonantCluster(name);\r\n  const actualVowelGap = checkVowelSpacing(name);\r\n\r\n  let violations = 0;\r\n\r\n  // Penalize exceeding max consonant cluster\r\n  if (actualMaxCluster > maxConsonantCluster) {\r\n    violations += actualMaxCluster - maxConsonantCluster;\r\n  }\r\n\r\n  // Penalize exceeding vowel spacing\r\n  if (actualVowelGap > minVowelSpacing) {\r\n    violations += actualVowelGap - minVowelSpacing;\r\n  }\r\n\r\n  // Normalize: assume max 5 violations is very bad\r\n  return Math.max(0, 1 - violations / 5);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::scorePronounceability", "name": "scorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Combined pronounceability score\r\n *\r\n * Weights:\r\n * - 30% template legality (structural correctness)\r\n * - 30% sonority sequencing (natural flow)\r\n * - 40% harmonic constraints (culture-specific rules)\r\n *\r\n * Returns: 0-1 score (1 = highly pronounceable)\r\n */\r\nexport function scorePronounceability(\r\n  name: string,\r\n  syllables: string[],\r\n  phonemes: string[],\r\n  profile: PhonologyProfile\r\n): number {\r\n  const templateScore = scoreTemplateLegality(name, syllables, profile.syllableTemplates);\r\n  const sonorityScore = scoreSonoritySequencing(name, phonemes, profile.sonorityRanks);\r\n  const harmonicScore = scoreHarmonicConstraints(name, profile);\r\n\r\n  // Weighted combination\r\n  return 0.3 * templateScore + 0.3 * sonorityScore + 0.4 * harmonicScore;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/pronounceability.ts::batchScorePronounceability", "name": "batchScorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "export function batchScorePronounceability(\r\n  names: string[],\r\n  syllablesPerName: string[][],\r\n  phonemesPerName: string[][],\r\n  profile: PhonologyProfile\r\n): PronounceabilityReport {\r\n  const scores = names.map((name, i) =>\r\n    scorePronounceability(name, syllablesPerName[i] ?? [], phonemesPerName[i] ?? [], profile)\r\n  );\r\n\r\n  scores.sort((a, b) => a - b);\r\n\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  let tooManyConsonants = 0;\r\n  let poorVowelSpacing = 0;\r\n\r\n  for (const name of names) {\r\n    if (countMaxConsonantCluster(name) > maxConsonantCluster) {\r\n      tooManyConsonants++;\r\n    }\r\n    if (checkVowelSpacing(name) > minVowelSpacing) {\r\n      poorVowelSpacing++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\r\n    minScore: scores[0],\r\n    maxScore: scores[scores.length - 1],\r\n    p5: scores[Math.floor(scores.length * 0.05)],\r\n    p95: scores[Math.floor(scores.length * 0.95)],\r\n    violations: {\r\n      tooManyConsonants,\r\n      poorVowelSpacing,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "syllablesPerName", "type": "string[][]", "optional": false}, {"name": "phonemesPerName", "type": "string[][]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "PronounceabilityReport"}, {"id": "apps/name-forge/lib/style.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }"}, {"id": "apps/name-forge/lib/style.ts::hasPreferredEnding", "name": "hasPreferredEnding", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if a name has a preferred ending\r\n */\r\nexport function hasPreferredEnding(\r\n  name: string,\r\n  preferredEndings?: string[]\r\n): boolean {\r\n  if (!preferredEndings || preferredEndings.length === 0) {\r\n    return false;\r\n  }\r\n  return endsWithAny(name, preferredEndings);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/style.ts::selectWithPreferredEndings", "name": "selectWithPreferredEndings", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Generate multiple candidates and boost those with preferred endings\r\n */\r\nexport function selectWithPreferredEndings<T>(\r\n  rng: () => number,\r\n  candidates: T[],\r\n  nameExtractor: (candidate: T) => string,\r\n  preferredEndings?: string[],\r\n  boost: number = 2.0\r\n): T {\r\n  if (\r\n    !preferredEndings ||\r\n    preferredEndings.length === 0 ||\r\n    candidates.length === 0\r\n  ) {\r\n    // No preference, pick uniformly\r\n    return candidates[Math.floor(rng() * candidates.length)];\r\n  }\r\n\r\n  // Calculate weights\r\n  const weights = candidates.map((candidate) => {\r\n    const name = nameExtractor(candidate);\r\n    return hasPreferredEnding(name, preferredEndings) ? boost : 1.0;\r\n  });\r\n\r\n  // Weighted selection\r\n  const total = weights.reduce((sum, w) => sum + w, 0);\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n\r\n  for (let i = 0; i < candidates.length; i++) {\r\n    cumulative += weights[i];\r\n    if (r < cumulative) {\r\n      return candidates[i];\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return candidates[candidates.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "T[]", "optional": false}, {"name": "nameExtractor", "type": "(candidate: T) => string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}, {"name": "boost", "type": "number", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/style.ts::applyRhythmBias", "name": "applyRhythmBias", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply rhythm-based adjustments to a name\r\n * This is a placeholder for future enhancement\r\n */\r\nexport function applyRhythmBias(\r\n  name: string,\r\n  _rhythmBias?: \"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"\r\n): string {\r\n  // Rhythm bias is primarily enforced during phonology generation.\r\n  // Post-processing transformations (softening consonant clusters,\r\n  // emphasizing consonants, adding syllable breaks, smoothing transitions)\r\n  // can be added here in the future.\r\n  return name;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_rhythmBias", "type": "\"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::validateStyle", "name": "validateStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Validate that a name meets style constraints\r\n */\r\nexport function validateStyle(name: string, _style: StyleRules): boolean {\r\n  // Basic validation: more complex checks (apostrophe/hyphen placement,\r\n  // capitalization, double apostrophes) can be added here.\r\n  return name.length > 0;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_style", "type": "StyleRules", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/style.ts::applyStyleWithCandidates", "name": "applyStyleWithCandidates", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply all stylistic transforms and select best candidate\r\n */\r\nexport function applyStyleWithCandidates(\r\n  rng: () => number,\r\n  candidates: string[],\r\n  style: StyleRules,\r\n  syllablesPerCandidate?: string[][]\r\n): string {\r\n  if (candidates.length === 0) {\r\n    throw new Error(\"No candidates provided\");\r\n  }\r\n\r\n  // Generate styled versions\r\n  const styledCandidates = candidates.map((name, index) => {\r\n    const syllables = syllablesPerCandidate?.[index];\r\n    const { result } = applyStyle(rng, name, style, syllables);\r\n    return result;\r\n  });\r\n\r\n  // Select with preferred endings boost\r\n  return selectWithPreferredEndings(\r\n    rng,\r\n    styledCandidates,\r\n    (name) => name,\r\n    style.preferredEndings,\r\n    style.preferredEndingBoost\r\n  );\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllablesPerCandidate", "type": "string[][]", "optional": true}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::normalizeForComparison", "name": "normalizeForComparison", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Strip style markers for comparison\r\n * Useful for validation and deduplication\r\n */\r\nexport function normalizeForComparison(name: string): string {\r\n  return name\r\n    .toLowerCase()\r\n    .replace(/['\\-\\s]/g, \"\") // Remove apostrophes, hyphens, spaces\r\n    .trim();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/style.ts::areTooSimilar", "name": "areTooSimilar", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if two names are too similar (considering style variations)\r\n */\r\nexport function areTooSimilar(name1: string, name2: string): boolean {\r\n  const norm1 = normalizeForComparison(name1);\r\n  const norm2 = normalizeForComparison(name2);\r\n  return norm1 === norm2;\r\n}", "parameters": [{"name": "name1", "type": "string", "optional": false}, {"name": "name2", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/genetic.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/genetic.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/hillclimb.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/hillclimb.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/optimizer/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/optimizer/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector"}, {"id": "apps/name-forge/lib/optimizer/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain"}, {"id": "apps/name-forge/lib/optimizer/sim-anneal.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/sim-anneal.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>"}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::endsWithAny", "name": "endsWithAny", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a string ends with any of the given suffixes\r\n */\r\nexport function endsWithAny(str: string, suffixes: string[]): boolean {\r\n  return suffixes.some((suffix) =>\r\n    str.toLowerCase().endsWith(suffix.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "suffixes", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::findSyllableBoundaries", "name": "findSyllableBoundaries", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Find legal positions to insert apostrophes or hyphens\r\n * Returns indices between syllables (not in the middle of syllable templates)\r\n */\r\nexport function findSyllableBoundaries(\r\n  word: string,\r\n  syllables: string[]\r\n): number[] {\r\n  const boundaries: number[] = [];\r\n  let position = 0;\r\n\r\n  for (let i = 0; i < syllables.length - 1; i++) {\r\n    position += syllables[i].length;\r\n    boundaries.push(position);\r\n  }\r\n\r\n  return boundaries;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/utils/helpers.ts::insertAtBoundary", "name": "insertAtBoundary", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Insert a character at a random syllable boundary\r\n */\r\nexport function insertAtBoundary(\r\n  word: string,\r\n  char: string,\r\n  boundaries: number[],\r\n  rng: () => number\r\n): string {\r\n  if (boundaries.length === 0) return word;\r\n\r\n  const index = boundaries[Math.floor(rng() * boundaries.length)];\r\n  return word.slice(0, index) + char + word.slice(index);\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "char", "type": "string", "optional": false}, {"name": "boundaries", "type": "number[]", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasForbiddenCluster", "name": "hasForbiddenCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Validate that a name doesn't contain forbidden clusters\r\n */\r\nexport function hasForbiddenCluster(\r\n  name: string,\r\n  forbiddenClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return forbiddenClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "forbiddenClusters", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasFavoredCluster", "name": "hasFavoredCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a name contains any favored clusters\r\n */\r\nexport function hasFavoredCluster(\r\n  name: string,\r\n  favoredClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return favoredClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "favoredClusters", "type": "string[]", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/helpers.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Count syllables in a word (rough approximation based on vowel groups)\r\n */\r\nexport function estimateSyllableCount(word: string): number {\r\n  // Simple heuristic: count vowel groups\r\n  const vowelGroups = word.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/helpers.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(word: string): number {\r\n  if (word.length === 0) return 0;\r\n  const vowelCount = (word.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / word.length;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/helpers.ts::normalizeWeights", "name": "normalizeWeights", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Normalize weights array (make them sum to 1)\r\n */\r\nexport function normalizeWeights(weights: number[]): number[] {\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All zero, return uniform\r\n    return weights.map(() => 1 / weights.length);\r\n  }\r\n  return weights.map((w) => Math.max(0, w) / total);\r\n}", "parameters": [{"name": "weights", "type": "number[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/utils/helpers.ts::deepClone", "name": "deepClone", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Deep clone an object using JSON serialization\r\n * Note: Loses functions, undefined, symbols, etc.\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  return JSON.parse(JSON.stringify(obj)) as T;\r\n}", "parameters": [{"name": "obj", "type": "T", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T"}, {"id": "apps/name-forge/lib/utils/rng.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick multiple random elements from an array without replacement\r\n */\r\nexport function pickMultiple<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  count: number\r\n): T[] {\r\n  if (count <= 0) {\r\n    return [];\r\n  }\r\n  if (count >= array.length) {\r\n    return [...array];\r\n  }\r\n\r\n  const remaining = [...array];\r\n  const result: T[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const index = Math.floor(rng() * remaining.length);\r\n    result.push(remaining[index]);\r\n    remaining.splice(index, 1);\r\n  }\r\n\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]"}, {"id": "apps/name-forge/lib/utils/rng.ts::randomInt", "name": "randomInt", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random integer in range [min, max] inclusive\r\n */\r\nexport function randomInt(rng: () => number, min: number, max: number): number {\r\n  return Math.floor(rng() * (max - min + 1)) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/rng.ts::randomFloat", "name": "randomFloat", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random number in range [min, max]\r\n */\r\nexport function randomFloat(\r\n  rng: () => number,\r\n  min: number,\r\n  max: number\r\n): number {\r\n  return rng() * (max - min) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/utils/rng.ts::chance", "name": "chance", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Return true with given probability\r\n */\r\nexport function chance(rng: () => number, probability: number): boolean {\r\n  return rng() < probability;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "probability", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/name-forge/lib/utils/rng.ts::shuffle", "name": "shuffle", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Shuffle an array in place using Fisher-Yates algorithm\r\n */\r\nexport function shuffle<T>(rng: () => number, array: T[]): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(rng() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/name-forge/lib/validation/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport"}, {"id": "apps/name-forge/lib/validation/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport"}, {"id": "apps/name-forge/lib/validation/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]"}, {"id": "apps/name-forge/lib/validation/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport"}, {"id": "apps/name-forge/lib/validation/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector"}, {"id": "apps/name-forge/lib/validation/index.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Estimate syllable count based on vowel groups\r\n */\r\nexport function estimateSyllableCount(name: string): number {\r\n  const vowelGroups = name.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(name: string): number {\r\n  if (name.length === 0) return 0;\r\n  const vowelCount = (name.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / name.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::countApostrophes", "name": "countApostrophes", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Count apostrophes in a name\r\n */\r\nexport function countApostrophes(name: string): number {\r\n  return (name.match(/'/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::countHyphens", "name": "countHyphens", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Count hyphens in a name\r\n */\r\nexport function countHyphens(name: string): number {\r\n  return (name.match(/-/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::extractBigrams", "name": "extractBigrams", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Extract character bigrams (2-character sequences)\r\n */\r\nexport function extractBigrams(name: string): Map<string, number> {\r\n  const bigrams = new Map<string, number>();\r\n  const normalized = name.toLowerCase();\r\n\r\n  for (let i = 0; i < normalized.length - 1; i++) {\r\n    const bigram = normalized.substring(i, i + 2);\r\n    bigrams.set(bigram, (bigrams.get(bigram) ?? 0) + 1);\r\n  }\r\n\r\n  return bigrams;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "Map<string, number>"}, {"id": "apps/name-forge/lib/validation/index.ts::getEnding", "name": "getEnding", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Get the ending (last 2 chars) of a name\r\n */\r\nexport function getEnding(name: string): string {\r\n  return name.length >= 2\r\n    ? name.substring(name.length - 2).toLowerCase()\r\n    : name.toLowerCase();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/validation/index.ts::featureVectorToArray", "name": "featureVectorToArray", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Convert a feature vector to a numeric array for ML\r\n * This flattens the structured features into a single vector\r\n */\r\nexport function featureVectorToArray(\r\n  fv: FeatureVector,\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  const features: number[] = [];\r\n\r\n  // Basic numeric features\r\n  features.push(fv.features.length);\r\n  features.push(fv.features.syllableCount);\r\n  features.push(fv.features.vowelRatio);\r\n  features.push(fv.features.apostropheCount);\r\n  features.push(fv.features.hyphenCount);\r\n\r\n  // Bigram features (one-hot-ish encoding)\r\n  for (const bigram of allBigrams) {\r\n    features.push(fv.features.bigrams[bigram] ?? 0);\r\n  }\r\n\r\n  // Ending feature (one-hot encoding)\r\n  const endingIndex = allEndings.indexOf(fv.features.ending);\r\n  for (let i = 0; i < allEndings.length; i++) {\r\n    features.push(i === endingIndex ? 1 : 0);\r\n  }\r\n\r\n  return features;\r\n}", "parameters": [{"name": "fv", "type": "FeatureVector", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/validation/index.ts::buildVocabulary", "name": "buildVocabulary", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Build vocabulary of all bigrams and endings from a set of feature vectors\r\n */\r\nexport function buildVocabulary(featureVectors: FeatureVector[]): {\r\n  bigrams: string[];\r\n  endings: string[];\r\n} {\r\n  const bigramSet = new Set<string>();\r\n  const endingSet = new Set<string>();\r\n\r\n  for (const fv of featureVectors) {\r\n    for (const bigram of Object.keys(fv.features.bigrams)) {\r\n      bigramSet.add(bigram);\r\n    }\r\n    endingSet.add(fv.features.ending);\r\n  }\r\n\r\n  return {\r\n    bigrams: Array.from(bigramSet).sort((a, b) => a.localeCompare(b)),\r\n    endings: Array.from(endingSet).sort((a, b) => a.localeCompare(b)),\r\n  };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}], "returnType": "{\r\n  bigrams: string[];\r\n  endings: string[];\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate centroid (mean) of feature vectors\r\n */\r\nexport function calculateCentroid(\r\n  featureVectors: FeatureVector[],\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  if (featureVectors.length === 0) {\r\n    // Return zero vector\r\n    return new Array<number>(5 + allBigrams.length + allEndings.length).fill(0);\r\n  }\r\n\r\n  // Convert all to arrays\r\n  const arrays = featureVectors.map((fv) =>\r\n    featureVectorToArray(fv, allBigrams, allEndings)\r\n  );\r\n\r\n  // Calculate mean for each dimension\r\n  const dimensions = arrays[0].length;\r\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\r\n\r\n  for (const arr of arrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      centroid[i] += arr[i];\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < dimensions; i++) {\r\n    centroid[i] /= arrays.length;\r\n  }\r\n\r\n  return centroid;\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/validation/index.ts::normalizeFeatures", "name": "normalizeFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Normalize feature vectors to [0, 1] range\r\n * Helps with distance calculations and classification\r\n */\r\nexport function normalizeFeatures(\r\n  featureArrays: number[][]\r\n): {\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n} {\r\n  if (featureArrays.length === 0) {\r\n    return { normalized: [], min: [], max: [] };\r\n  }\r\n\r\n  const dimensions = featureArrays[0].length;\r\n  const min: number[] = new Array<number>(dimensions).fill(Infinity);\r\n  const max: number[] = new Array<number>(dimensions).fill(-Infinity);\r\n\r\n  // Find min/max for each dimension\r\n  for (const arr of featureArrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      min[i] = Math.min(min[i], arr[i]);\r\n      max[i] = Math.max(max[i], arr[i]);\r\n    }\r\n  }\r\n\r\n  // Normalize\r\n  const normalized = featureArrays.map((arr) => {\r\n    return arr.map((val, i) => {\r\n      const range = max[i] - min[i];\r\n      if (range === 0) return 0;\r\n      return (val - min[i]) / range;\r\n    });\r\n  });\r\n\r\n  return { normalized, min, max };\r\n}", "parameters": [{"name": "featureArrays", "type": "number[][]", "optional": false}], "returnType": "{\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::toShapeKey", "name": "toShapeKey", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Convert a name to a shape key for phonetic similarity detection\r\n * Collapses vowels to V, consonants to C, and removes repeated patterns\r\n *\r\n * Example: \"Aeltharion\" -> \"VCCCVCVC\"\r\n */\r\nexport function toShapeKey(name: string): string {\r\n  // Lowercase and remove non-alphabetic characters\r\n  let s = name.toLowerCase().replace(/[^a-z]/g, \"\");\r\n\r\n  // Replace vowels with V\r\n  s = s.replace(/[aeiou]+/g, \"V\");\r\n\r\n  // Replace consonants with C\r\n  s = s.replace(/[^V]+/g, \"C\");\r\n\r\n  // Collapse repeated patterns (optional - can make distance less sensitive)\r\n  // s = s.replace(/(.)\\1+/g, \"$1\");\r\n\r\n  return s;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/validation/index.ts::shapeDistance", "name": "shapeDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate shape distance between two names\r\n * Uses Levenshtein on shape keys\r\n */\r\nexport function shapeDistance(a: string, b: string): number {\r\n  const shapeA = toShapeKey(a);\r\n  const shapeB = toShapeKey(b);\r\n\r\n  return normalizedLevenshtein(shapeA, shapeB);\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::pairwiseDistances", "name": "pairwiseDistances", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate distance between all pairs in a list of names\r\n * Returns a matrix where matrix[i][j] is the distance from names[i] to names[j]\r\n */\r\nexport function pairwiseDistances(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): number[][] {\r\n  const n = names.length;\r\n  const matrix: number[][] = new Array<number[]>(n)\r\n    .fill([])\r\n    .map(() => new Array<number>(n).fill(0));\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = i + 1; j < n; j++) {\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      matrix[i][j] = dist;\r\n      matrix[j][i] = dist; // Symmetric\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "number[][]"}, {"id": "apps/name-forge/lib/validation/index.ts::findNearestNeighbors", "name": "findNearestNeighbors", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Find the nearest neighbor for each name in a list\r\n * Returns array of {name, nearestName, distance}\r\n */\r\nexport function findNearestNeighbors(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): Array<{ name: string; nearestName: string; distance: number }> {\r\n  const results: Array<{ name: string; nearestName: string; distance: number }> =\r\n    [];\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    let minDistance = Infinity;\r\n    let nearestIndex = -1;\r\n\r\n    for (let j = 0; j < names.length; j++) {\r\n      if (i === j) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist < minDistance) {\r\n        minDistance = dist;\r\n        nearestIndex = j;\r\n      }\r\n    }\r\n\r\n    if (nearestIndex !== -1) {\r\n      results.push({\r\n        name: names[i],\r\n        nearestName: names[nearestIndex],\r\n        distance: minDistance,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "Array<{ name: string; nearestName: string; distance: number }>"}, {"id": "apps/name-forge/lib/validation/index.ts::calculatePercentiles", "name": "calculatePercentiles", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate percentile statistics from a list of distances\r\n */\r\nexport function calculatePercentiles(\r\n  values: number[]\r\n): {\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n} {\r\n  if (values.length === 0) {\r\n    return { min: 0, p1: 0, p5: 0, median: 0, p95: 0, p99: 0, max: 0, mean: 0 };\r\n  }\r\n\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const n = sorted.length;\r\n\r\n  const percentile = (p: number) => {\r\n    const index = Math.ceil((p / 100) * n) - 1;\r\n    return sorted[Math.max(0, Math.min(index, n - 1))];\r\n  };\r\n\r\n  const mean = values.reduce((sum, v) => sum + v, 0) / n;\r\n\r\n  return {\r\n    min: sorted[0],\r\n    p1: percentile(1),\r\n    p5: percentile(5),\r\n    median: percentile(50),\r\n    p95: percentile(95),\r\n    p99: percentile(99),\r\n    max: sorted[n - 1],\r\n    mean,\r\n  };\r\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}], "returnType": "{\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n}"}, {"id": "apps/name-forge/lib/validation/index.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/index.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}"}, {"id": "apps/name-forge/lib/validation/analysis/classifier.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/classifier.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::toShapeKey", "name": "toShapeKey", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Convert a name to a shape key for phonetic similarity detection\r\n * Collapses vowels to V, consonants to C, and removes repeated patterns\r\n *\r\n * Example: \"Aeltharion\" -> \"VCCCVCVC\"\r\n */\r\nexport function toShapeKey(name: string): string {\r\n  // Lowercase and remove non-alphabetic characters\r\n  let s = name.toLowerCase().replace(/[^a-z]/g, \"\");\r\n\r\n  // Replace vowels with V\r\n  s = s.replace(/[aeiou]+/g, \"V\");\r\n\r\n  // Replace consonants with C\r\n  s = s.replace(/[^V]+/g, \"C\");\r\n\r\n  // Collapse repeated patterns (optional - can make distance less sensitive)\r\n  // s = s.replace(/(.)\\1+/g, \"$1\");\r\n\r\n  return s;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::shapeDistance", "name": "shapeDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate shape distance between two names\r\n * Uses Levenshtein on shape keys\r\n */\r\nexport function shapeDistance(a: string, b: string): number {\r\n  const shapeA = toShapeKey(a);\r\n  const shapeB = toShapeKey(b);\r\n\r\n  return normalizedLevenshtein(shapeA, shapeB);\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::pairwiseDistances", "name": "pairwiseDistances", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate distance between all pairs in a list of names\r\n * Returns a matrix where matrix[i][j] is the distance from names[i] to names[j]\r\n */\r\nexport function pairwiseDistances(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): number[][] {\r\n  const n = names.length;\r\n  const matrix: number[][] = new Array<number[]>(n)\r\n    .fill([])\r\n    .map(() => new Array<number>(n).fill(0));\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = i + 1; j < n; j++) {\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      matrix[i][j] = dist;\r\n      matrix[j][i] = dist; // Symmetric\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "number[][]"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::findNearestNeighbors", "name": "findNearestNeighbors", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Find the nearest neighbor for each name in a list\r\n * Returns array of {name, nearestName, distance}\r\n */\r\nexport function findNearestNeighbors(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): Array<{ name: string; nearestName: string; distance: number }> {\r\n  const results: Array<{ name: string; nearestName: string; distance: number }> =\r\n    [];\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    let minDistance = Infinity;\r\n    let nearestIndex = -1;\r\n\r\n    for (let j = 0; j < names.length; j++) {\r\n      if (i === j) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist < minDistance) {\r\n        minDistance = dist;\r\n        nearestIndex = j;\r\n      }\r\n    }\r\n\r\n    if (nearestIndex !== -1) {\r\n      results.push({\r\n        name: names[i],\r\n        nearestName: names[nearestIndex],\r\n        distance: minDistance,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "Array<{ name: string; nearestName: string; distance: number }>"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::calculatePercentiles", "name": "calculatePercentiles", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate percentile statistics from a list of distances\r\n */\r\nexport function calculatePercentiles(\r\n  values: number[]\r\n): {\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n} {\r\n  if (values.length === 0) {\r\n    return { min: 0, p1: 0, p5: 0, median: 0, p95: 0, p99: 0, max: 0, mean: 0 };\r\n  }\r\n\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const n = sorted.length;\r\n\r\n  const percentile = (p: number) => {\r\n    const index = Math.ceil((p / 100) * n) - 1;\r\n    return sorted[Math.max(0, Math.min(index, n - 1))];\r\n  };\r\n\r\n  const mean = values.reduce((sum, v) => sum + v, 0) / n;\r\n\r\n  return {\r\n    min: sorted[0],\r\n    p1: percentile(1),\r\n    p5: percentile(5),\r\n    median: percentile(50),\r\n    p95: percentile(95),\r\n    p99: percentile(99),\r\n    max: sorted[n - 1],\r\n    mean,\r\n  };\r\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}], "returnType": "{\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n}"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Estimate syllable count based on vowel groups\r\n */\r\nexport function estimateSyllableCount(name: string): number {\r\n  const vowelGroups = name.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(name: string): number {\r\n  if (name.length === 0) return 0;\r\n  const vowelCount = (name.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / name.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::countApostrophes", "name": "countApostrophes", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Count apostrophes in a name\r\n */\r\nexport function countApostrophes(name: string): number {\r\n  return (name.match(/'/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::countHyphens", "name": "countHyphens", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Count hyphens in a name\r\n */\r\nexport function countHyphens(name: string): number {\r\n  return (name.match(/-/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::extractBigrams", "name": "extractBigrams", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Extract character bigrams (2-character sequences)\r\n */\r\nexport function extractBigrams(name: string): Map<string, number> {\r\n  const bigrams = new Map<string, number>();\r\n  const normalized = name.toLowerCase();\r\n\r\n  for (let i = 0; i < normalized.length - 1; i++) {\r\n    const bigram = normalized.substring(i, i + 2);\r\n    bigrams.set(bigram, (bigrams.get(bigram) ?? 0) + 1);\r\n  }\r\n\r\n  return bigrams;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "Map<string, number>"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::getEnding", "name": "getEnding", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Get the ending (last 2 chars) of a name\r\n */\r\nexport function getEnding(name: string): string {\r\n  return name.length >= 2\r\n    ? name.substring(name.length - 2).toLowerCase()\r\n    : name.toLowerCase();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::featureVectorToArray", "name": "featureVectorToArray", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Convert a feature vector to a numeric array for ML\r\n * This flattens the structured features into a single vector\r\n */\r\nexport function featureVectorToArray(\r\n  fv: FeatureVector,\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  const features: number[] = [];\r\n\r\n  // Basic numeric features\r\n  features.push(fv.features.length);\r\n  features.push(fv.features.syllableCount);\r\n  features.push(fv.features.vowelRatio);\r\n  features.push(fv.features.apostropheCount);\r\n  features.push(fv.features.hyphenCount);\r\n\r\n  // Bigram features (one-hot-ish encoding)\r\n  for (const bigram of allBigrams) {\r\n    features.push(fv.features.bigrams[bigram] ?? 0);\r\n  }\r\n\r\n  // Ending feature (one-hot encoding)\r\n  const endingIndex = allEndings.indexOf(fv.features.ending);\r\n  for (let i = 0; i < allEndings.length; i++) {\r\n    features.push(i === endingIndex ? 1 : 0);\r\n  }\r\n\r\n  return features;\r\n}", "parameters": [{"name": "fv", "type": "FeatureVector", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::buildVocabulary", "name": "buildVocabulary", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Build vocabulary of all bigrams and endings from a set of feature vectors\r\n */\r\nexport function buildVocabulary(featureVectors: FeatureVector[]): {\r\n  bigrams: string[];\r\n  endings: string[];\r\n} {\r\n  const bigramSet = new Set<string>();\r\n  const endingSet = new Set<string>();\r\n\r\n  for (const fv of featureVectors) {\r\n    for (const bigram of Object.keys(fv.features.bigrams)) {\r\n      bigramSet.add(bigram);\r\n    }\r\n    endingSet.add(fv.features.ending);\r\n  }\r\n\r\n  return {\r\n    bigrams: Array.from(bigramSet).sort((a, b) => a.localeCompare(b)),\r\n    endings: Array.from(endingSet).sort((a, b) => a.localeCompare(b)),\r\n  };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}], "returnType": "{\r\n  bigrams: string[];\r\n  endings: string[];\r\n}"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Calculate centroid (mean) of feature vectors\r\n */\r\nexport function calculateCentroid(\r\n  featureVectors: FeatureVector[],\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  if (featureVectors.length === 0) {\r\n    // Return zero vector\r\n    return new Array<number>(5 + allBigrams.length + allEndings.length).fill(0);\r\n  }\r\n\r\n  // Convert all to arrays\r\n  const arrays = featureVectors.map((fv) =>\r\n    featureVectorToArray(fv, allBigrams, allEndings)\r\n  );\r\n\r\n  // Calculate mean for each dimension\r\n  const dimensions = arrays[0].length;\r\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\r\n\r\n  for (const arr of arrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      centroid[i] += arr[i];\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < dimensions; i++) {\r\n    centroid[i] /= arrays.length;\r\n  }\r\n\r\n  return centroid;\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]"}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::normalizeFeatures", "name": "normalizeFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Normalize feature vectors to [0, 1] range\r\n * Helps with distance calculations and classification\r\n */\r\nexport function normalizeFeatures(\r\n  featureArrays: number[][]\r\n): {\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n} {\r\n  if (featureArrays.length === 0) {\r\n    return { normalized: [], min: [], max: [] };\r\n  }\r\n\r\n  const dimensions = featureArrays[0].length;\r\n  const min: number[] = new Array<number>(dimensions).fill(Infinity);\r\n  const max: number[] = new Array<number>(dimensions).fill(-Infinity);\r\n\r\n  // Find min/max for each dimension\r\n  for (const arr of featureArrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      min[i] = Math.min(min[i], arr[i]);\r\n      max[i] = Math.max(max[i], arr[i]);\r\n    }\r\n  }\r\n\r\n  // Normalize\r\n  const normalized = featureArrays.map((arr) => {\r\n    return arr.map((val, i) => {\r\n      const range = max[i] - min[i];\r\n      if (range === 0) return 0;\r\n      return (val - min[i]) / range;\r\n    });\r\n  });\r\n\r\n  return { normalized, min, max };\r\n}", "parameters": [{"name": "featureArrays", "type": "number[][]", "optional": false}], "returnType": "{\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n}"}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport"}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}"}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport"}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]"}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}"}, {"id": "apps/name-forge/lib/validation/metrics/separation.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/separation.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport"}, {"id": "apps/name-forge/lib/validation/metrics/separation.ts::compareDomains", "name": "compareDomains", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/separation.ts", "sourceCode": "/**\r\n * Calculate separation score between two specific domains\r\n */\r\nexport function compareDomains(\r\n  domain1: NamingDomain,\r\n  domain2: NamingDomain,\r\n  sampleSize: number = 200,\r\n  seed?: string\r\n): {\r\n  centroidDistance: number;\r\n  classifierAccuracy: number;\r\n  domain1MisclassifiedAs2: number;\r\n  domain2MisclassifiedAs1: number;\r\n} {\r\n  const report = validateSeparation([domain1, domain2], { sampleSize, seed });\r\n\r\n  const key = `${domain1.id}-${domain2.id}`;\r\n  const centroidDistance = report.pairwiseDistances[key] ?? 0;\r\n\r\n  const domain1Total =\r\n    Object.values(report.confusionMatrix[domain1.id] ?? {}).reduce(\r\n      (sum, count) => sum + count,\r\n      0\r\n    );\r\n  const domain1MisclassifiedAs2 =\r\n    (report.confusionMatrix[domain1.id]?.[domain2.id] ?? 0) / domain1Total;\r\n\r\n  const domain2Total =\r\n    Object.values(report.confusionMatrix[domain2.id] ?? {}).reduce(\r\n      (sum, count) => sum + count,\r\n      0\r\n    );\r\n  const domain2MisclassifiedAs1 =\r\n    (report.confusionMatrix[domain2.id]?.[domain1.id] ?? 0) / domain2Total;\r\n\r\n  return {\r\n    centroidDistance,\r\n    classifierAccuracy: report.classifierAccuracy,\r\n    domain1MisclassifiedAs2,\r\n    domain2MisclassifiedAs1,\r\n  };\r\n}", "parameters": [{"name": "domain1", "type": "NamingDomain", "optional": false}, {"name": "domain2", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  centroidDistance: number;\r\n  classifierAccuracy: number;\r\n  domain1MisclassifiedAs2: number;\r\n  domain2MisclassifiedAs1: number;\r\n}"}, {"id": "apps/name-forge/webui/src/NameForgeRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/NameForgeRemote.jsx", "sourceCode": "export default function NameForgeRemote({\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators = [],\n}) {\n  // Use passed-in section or default to 'workshop'\n  const activeTab = activeSection || \"workshop\";\n  const setActiveTab = onSectionChange || (() => {});\n  const storageKey = projectId ? `nameforge:ui:${projectId}` : null;\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [workspaceTab, setWorkspaceTab] = useState(\"domain\");\n  const [hydratedKey, setHydratedKey] = useState(null);\n\n  // Session-only API key (not persisted)\n  const [apiKey, setApiKey] = useState(\"\");\n  const [showApiKeyInput, setShowApiKeyInput] = useState(false);\n\n  // GenerateTab form state\n  const [generateFormState, setGenerateFormState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }],\n  });\n\n  const worldSchema = useMemo(\n    () => schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    [schema]\n  );\n\n  const cultures = useMemo(() => {\n    const map = {};\n    (schema?.cultures || []).forEach((culture) => {\n      map[culture.id] = culture;\n    });\n    return map;\n  }, [schema?.cultures]);\n\n  // Handle culture updates from the workspace\n  const handleCultureChange = useCallback(\n    (updatedCulture) => {\n      if (!selectedCulture || !onNamingDataChange) return;\n\n      const newNamingData = updatedCulture?.naming || {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: [],\n      };\n      onNamingDataChange(selectedCulture, newNamingData);\n    },\n    [selectedCulture, onNamingDataChange]\n  );\n\n  // Handle cultures change (for optimizer updates)\n  const handleCulturesChange = useCallback(\n    (newCultures) => {\n      if (!onNamingDataChange) return;\n\n      Object.entries(newCultures).forEach(([cultureId, culture]) => {\n        const naming = culture?.naming || {\n          domains: [],\n          lexemeLists: {},\n          lexemeSpecs: [],\n          grammars: [],\n          profiles: [],\n        };\n        onNamingDataChange(cultureId, naming);\n      });\n    },\n    [onNamingDataChange]\n  );\n\n  // Auto-select first culture if none selected\n  const cultureIds = Object.keys(cultures);\n\n  useEffect(() => {\n    if (!storageKey || typeof localStorage === \"undefined\") {\n      setHydratedKey(storageKey);\n      return;\n    }\n    try {\n      const raw = localStorage.getItem(storageKey);\n      if (raw) {\n        const parsed = JSON.parse(raw);\n        setSelectedCulture(parsed?.selectedCulture || null);\n        setWorkspaceTab(parsed?.workspaceTab || \"domain\");\n      } else {\n        setSelectedCulture(null);\n        setWorkspaceTab(\"domain\");\n      }\n    } catch {\n      setSelectedCulture(null);\n      setWorkspaceTab(\"domain\");\n    } finally {\n      setHydratedKey(storageKey);\n    }\n  }, [storageKey]);\n\n  useEffect(() => {\n    if (!storageKey || typeof localStorage === \"undefined\") return;\n    if (hydratedKey !== storageKey) return;\n    try {\n      localStorage.setItem(\n        storageKey,\n        JSON.stringify({\n          selectedCulture,\n          workspaceTab,\n        })\n      );\n    } catch {\n      // Best-effort only.\n    }\n  }, [storageKey, hydratedKey, selectedCulture, workspaceTab]);\n\n  useEffect(() => {\n    if (hydratedKey !== storageKey) return;\n    if (!cultureIds.length) return;\n    if (selectedCulture && cultures[selectedCulture]) return;\n    setSelectedCulture(cultureIds[0]);\n  }, [hydratedKey, storageKey, cultureIds, cultures, selectedCulture]);\n\n  const hasCultures = cultureIds.length > 0;\n\n  if (!hasCultures) {\n    return (\n      <div className=\"nf-empty-state\">\n        <div className=\"nf-empty-state-icon\"></div>\n        <div className=\"nf-empty-state-title\">No Cultures Defined</div>\n        <div className=\"nf-empty-state-desc\">\n          Add cultures in the <strong>Enumerist</strong> tab first, then return here to configure\n          naming domains, grammars, and profiles.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"nf-container\">\n      {/* Left sidebar with nav and cultures */}\n      <div className=\"nf-sidebar\">\n        <nav className=\"nf-nav\">\n          {TABS.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`nf-nav-button ${activeTab === tab.id ? \"active\" : \"\"}`}\n            >\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n\n        {/* API Key section */}\n        <div className=\"nf-api-section\">\n          <button\n            onClick={() => setShowApiKeyInput(!showApiKeyInput)}\n            className={`nf-api-button ${apiKey ? \"active\" : \"\"}`}\n          >\n            {apiKey ? \"\u2713 API Key Set\" : \"Set API Key\"}\n          </button>\n          {showApiKeyInput && (\n            <div className=\"nf-api-dropdown\">\n              <div className=\"nf-api-dropdown-title\">Anthropic API Key</div>\n              <p className=\"nf-api-dropdown-hint\">Required for LLM lexeme generation.</p>\n              <input\n                type=\"password\"\n                value={apiKey}\n                onChange={(e) => setApiKey(e.target.value)}\n                placeholder=\"sk-ant-...\"\n                className=\"nf-api-input\"\n              />\n              <button onClick={() => setShowApiKeyInput(false)} className=\"nf-api-button active\">\n                Done\n              </button>\n            </div>\n          )}\n        </div>\n\n        {/* Culture sidebar - always visible */}\n        <div className=\"nf-culture-section\">\n          <CultureSidebar\n            cultures={cultures}\n            selectedCulture={selectedCulture}\n            onSelectCulture={setSelectedCulture}\n            onCulturesChange={handleCulturesChange}\n            readOnly={true}\n          />\n        </div>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"nf-main\">\n        {activeTab === \"workshop\" && (\n          <div className=\"nf-content\">\n            <EntityWorkspace\n              worldSchema={worldSchema}\n              cultureId={selectedCulture}\n              cultureConfig={selectedCulture ? cultures[selectedCulture] : null}\n              allCultures={cultures}\n              activeTab={workspaceTab}\n              onTabChange={setWorkspaceTab}\n              onCultureChange={handleCultureChange}\n              onAddTag={onAddTag}\n              apiKey={apiKey}\n              generators={generators}\n            />\n          </div>\n        )}\n\n        {activeTab === \"optimizer\" && (\n          <div className=\"nf-content\">\n            <OptimizerWorkshop cultures={cultures} onCulturesChange={handleCulturesChange} />\n          </div>\n        )}\n\n        {activeTab === \"generate\" && (\n          <div className=\"nf-content\">\n            <GenerateTab\n              worldSchema={worldSchema}\n              cultures={cultures}\n              formState={generateFormState}\n              onFormStateChange={setGenerateFormState}\n            />\n          </div>\n        )}\n\n        {activeTab === \"coverage\" && (\n          <div className=\"nf-content\">\n            <ProfileCoverageMatrix\n              cultures={cultures}\n              worldSchema={worldSchema}\n              onNavigateToProfile={(cultureId, _profileId) => {\n                setSelectedCulture(cultureId);\n                setWorkspaceTab(\"profiles\");\n                setActiveTab(\"workshop\");\n              }}\n            />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators = [],\n}", "type": "{ projectId: any; schema: any; onNamingDataChange: any; onAddTag: any; activeSection: any; onSectionChange: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/utils.js::getEffectiveDomain", "name": "getEffectiveDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get effective domain from culture config\n */\nexport function getEffectiveDomain(cultureConfig) {\n  const domains = cultureConfig?.naming?.domains;\n  if (domains && domains.length > 0) {\n    return domains[0];\n  }\n  return null;\n}", "parameters": [{"name": "cultureConfig", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/name-forge/webui/src/components/utils.js::getAllDomains", "name": "getAllDomains", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Collect all domains from all cultures\n */\nexport function getAllDomains(allCultures) {\n  const allDomains = [];\n  if (allCultures) {\n    Object.entries(allCultures).forEach(([cultId, cultConfig]) => {\n      if (cultConfig?.naming?.domains) {\n        cultConfig.naming.domains.forEach((domain) => {\n          allDomains.push({\n            ...domain,\n            sourceCulture: cultId,\n          });\n        });\n      }\n    });\n  }\n  return allDomains;\n}", "parameters": [{"name": "allCultures", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/components/utils.js::getStrategyColor", "name": "getStrategyColor", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get strategy color based on type\n */\nexport function getStrategyColor(type) {\n  switch (type) {\n    case \"phonotactic\":\n      return \"rgba(59, 130, 246, 0.3)\";\n    case \"grammar\":\n      return \"rgba(147, 51, 234, 0.3)\";\n    default:\n      return \"rgba(100, 100, 100, 0.3)\";\n  }\n}", "parameters": [{"name": "type", "type": "any", "optional": false}], "returnType": "\"rgba(59, 130, 246, 0.3)\" | \"rgba(147, 51, 234, 0.3)\" | \"rgba(100, 100, 100, 0.3)\""}, {"id": "apps/name-forge/webui/src/components/utils.js::getStrategyBorder", "name": "getStrategyBorder", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get strategy border color based on type\n */\nexport function getStrategyBorder(type) {\n  switch (type) {\n    case \"phonotactic\":\n      return \"rgba(59, 130, 246, 0.5)\";\n    case \"grammar\":\n      return \"rgba(147, 51, 234, 0.5)\";\n    default:\n      return \"rgba(100, 100, 100, 0.5)\";\n  }\n}", "parameters": [{"name": "type", "type": "any", "optional": false}], "returnType": "\"rgba(59, 130, 246, 0.5)\" | \"rgba(147, 51, 234, 0.5)\" | \"rgba(100, 100, 100, 0.5)\""}, {"id": "apps/name-forge/webui/src/components/utils.js::listAppliesHere", "name": "listAppliesHere", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Check if a lexeme list applies to a given culture/entity\n */\nexport function listAppliesHere(list, cultureId, entityKind) {\n  const appliesTo = list.appliesTo || {};\n  const cultures = appliesTo.cultures || [];\n  const entityKinds = appliesTo.entityKinds || [];\n\n  // Check culture match (empty array or '*' means all)\n  const cultureMatch =\n    cultures.length === 0 || cultures.includes(\"*\") || cultures.includes(cultureId);\n\n  // Check entity kind match\n  const entityMatch =\n    entityKinds.length === 0 || entityKinds.includes(\"*\") || entityKinds.includes(entityKind);\n\n  return cultureMatch && entityMatch;\n}", "parameters": [{"name": "list", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/name-forge/webui/src/components/utils.js::getSharedLexemeLists", "name": "getSharedLexemeLists", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get shared lexeme lists from other cultures/entity types\n */\nexport function getSharedLexemeLists(allCultures, cultureId, entityKind) {\n  const shared = {};\n\n  if (allCultures) {\n    Object.entries(allCultures).forEach(([cultId, cultConfig]) => {\n      if (cultId === cultureId) return;\n      const lists = cultConfig?.naming?.lexemeLists || {};\n      Object.entries(lists).forEach(([listId, list]) => {\n        if (listAppliesHere(list, cultureId, entityKind) && !shared[listId]) {\n          shared[listId] = {\n            ...list,\n            id: listId,\n            sourceCulture: cultId,\n            isShared: true,\n          };\n        }\n      });\n    });\n  }\n\n  return shared;\n}", "parameters": [{"name": "allCultures", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "{}"}, {"id": "apps/name-forge/webui/src/components/utils.js::getAvailableLexemeLists", "name": "getAvailableLexemeLists", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Get available lexeme lists (local and shared from same culture)\n */\nexport function getAvailableLexemeLists(entityConfig, cultureConfig, cultureId, entityKind) {\n  const lists = [];\n  // Local lists\n  if (entityConfig?.lexemeLists) {\n    Object.keys(entityConfig.lexemeLists).forEach((id) => {\n      lists.push({ id, source: \"local\" });\n    });\n  }\n  // Shared lists from same culture\n  const cultureLists = cultureConfig?.naming?.lexemeLists || {};\n  Object.entries(cultureLists).forEach(([id, list]) => {\n    if (entityConfig?.lexemeLists && entityConfig.lexemeLists[id]) return;\n    const appliesTo = list.appliesTo || {};\n    const cultureMatch =\n      !appliesTo.cultures?.length ||\n      appliesTo.cultures.includes(\"*\") ||\n      appliesTo.cultures.includes(cultureId);\n    const entityMatch =\n      !appliesTo.entityKinds?.length ||\n      appliesTo.entityKinds.includes(\"*\") ||\n      appliesTo.entityKinds.includes(entityKind);\n    if (cultureMatch && entityMatch) {\n      lists.push({ id, source: cultureId });\n    }\n  });\n  return lists;\n}", "parameters": [{"name": "entityConfig", "type": "any", "optional": false}, {"name": "cultureConfig", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "entityKind", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/components/utils.js::getSortedGroups", "name": "getSortedGroups", "kind": "function", "filePath": "apps/name-forge/webui/src/components/utils.js", "sourceCode": "/**\n * Sort strategy groups by priority (highest first)\n */\nexport function getSortedGroups(groups) {\n  if (!groups) return [];\n  return [...groups].sort((a, b) => b.priority - a.priority);\n}", "parameters": [{"name": "groups", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::generateTestNames", "name": "generateTestNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Generate names using a culture's configuration.\n *\n * @param {Object} options\n * @param {Object} options.culture - The culture object (from project.cultures[id])\n * @param {string} options.profileId - Which profile to use (optional, uses first if not specified)\n * @param {number} options.count - Number of names to generate\n * @param {string} options.seed - Optional seed for reproducibility\n * @param {Object} options.context - Context key-value pairs for context:key slots\n * @param {string} options.kind - Entity kind for condition matching\n * @param {string} options.subtype - Entity subtype for condition matching\n * @param {string} options.prominence - Prominence level for condition matching\n * @param {string[]} options.tags - Tags for condition matching\n * @returns {Promise<Object>} { names: string[], strategyUsage: Record<string, number> }\n */\nexport async function generateTestNames({\n  culture,\n  profileId,\n  count = 10,\n  seed,\n  context = {},\n  kind,\n  subtype,\n  prominence,\n  tags = []\n}) {\n  const nameForgeCulture = toNameForgeCulture(culture);\n  if (!nameForgeCulture) {\n    throw new Error('Culture required');\n  }\n\n  if (!nameForgeCulture.profiles || nameForgeCulture.profiles.length === 0) {\n    throw new Error('Culture has no profiles');\n  }\n\n  // generate() handles Markov model preloading internally\n  return generate(nameForgeCulture, {\n    cultureId: nameForgeCulture.id,\n    profileId: profileId,\n    context: context,\n    count: count,\n    seed: seed || `test-${Date.now()}`,\n    kind: kind,\n    subtype: subtype,\n    prominence: prominence,\n    tags: tags\n  });\n}", "parameters": [{"name": "{\n  culture,\n  profileId,\n  count = 10,\n  seed,\n  context = {},\n  kind,\n  subtype,\n  prominence,\n  tags = []\n}", "type": "{ culture: any; profileId: string; count: number; seed: string; context: any; kind: string; subtype: string; prominence: string; tags: string[]; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::generateNamesFromDomain", "name": "generateNamesFromDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Generate names directly from a domain (without profile)\n */\nexport function generateNamesFromDomain(domain, count = 10, seed) {\n  return generateFromDomain(domain, count, seed);\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/name-forge/webui/src/lib/browser-generator.js::previewGrammarNames", "name": "previewGrammarNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-generator.js", "sourceCode": "/**\n * Preview a grammar by generating sample names.\n * Used for live preview in the grammar editor.\n *\n * @param {Object} options\n * @param {Object} options.grammar - The grammar to preview\n * @param {Array} options.domains - Available domains\n * @param {Object} options.lexemeLists - Available lexeme lists (keyed by id)\n * @param {number} options.count - Number of names to generate (default 8)\n * @returns {Promise<string[]>} Generated sample names\n */\nexport async function previewGrammarNames({ grammar, domains, lexemeLists, count = 8 }) {\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\n    return [];\n  }\n\n  // Convert lexemeLists object to array format expected by lib\n  const lexemeListsArray = Object.entries(lexemeLists || {}).map(([id, list]) => ({\n    id,\n    entries: list.entries || [],\n    ...list\n  }));\n\n  return previewGrammar({\n    grammar,\n    domains: domains || [],\n    lexemeLists: lexemeListsArray,\n    count\n  });\n}", "parameters": [{"name": "{ grammar, domains, lexemeLists, count = 8 }", "type": "{ grammar: any; domains: any[]; lexemeLists: any; count: number; }", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Main optimizer entry point\n */\nexport async function optimizeDomain(\n  domain,\n  validationSettings,\n  fitnessWeights,\n  optimizationSettings,\n  siblingDomains = [],\n  onProgress = null\n) {\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\n  const seed = `optimize-${domain.id}-${Date.now()}`;\n\n  onProgress?.('Starting optimization...');\n\n  try {\n    let result;\n\n    switch (algorithm) {\n      case 'hillclimb':\n        result = await hillclimb(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          DEFAULT_BOUNDS,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'sim_anneal':\n        result = await simulatedAnnealing(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          DEFAULT_BOUNDS,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'bayes':\n        result = await bayesianOptimization(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      case 'ga':\n        result = await geneticAlgorithm(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          optimizationSettings,\n          seed,\n          siblingDomains\n        );\n        break;\n\n      default:\n        throw new Error(`Unknown algorithm: ${algorithm}`);\n    }\n\n    onProgress?.('Optimization complete!');\n    return result;\n  } catch (error) {\n    onProgress?.(`Error: ${error.message}`);\n    throw error;\n  }\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "validationSettings", "type": "any", "optional": false}, {"name": "fitnessWeights", "type": "any", "optional": false}, {"name": "optimizationSettings", "type": "any", "optional": false}, {"name": "siblingDomains", "type": "any[]", "optional": true}, {"name": "onProgress", "type": "any", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::generateTestNames", "name": "generateTestNames", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Generate test names using a domain\n */\nexport function generateTestNames(domain, count = 10, seed) {\n  const rng = createRNG(seed || `test-${Date.now()}`);\n  const names = [];\n\n  for (let i = 0; i < count; i++) {\n    names.push(generatePhonotacticName(rng, domain));\n  }\n\n  return names;\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/lib/browser-optimizer.js::validateDomain", "name": "validateDomain", "kind": "function", "filePath": "apps/name-forge/webui/src/lib/browser-optimizer.js", "sourceCode": "/**\n * Validate a domain configuration\n *\n * Returns metrics without running full optimization.\n */\nexport async function validateDomain(domain, sampleSize = 500, siblingDomains = []) {\n  const seed = `validate-${Date.now()}`;\n\n  const capacityReport = validateCapacity(domain, { sampleSize, seed: `${seed}-cap` });\n  const diffusenessReport = validateDiffuseness(domain, { sampleSize, seed: `${seed}-diff` });\n\n  let separationReport = null;\n  if (siblingDomains.length > 0) {\n    const allDomains = [domain, ...siblingDomains];\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\n    separationReport = validateSeparation(allDomains, { sampleSize: perDomainSample, seed: `${seed}-sep` });\n  }\n\n  return {\n    capacity: capacityReport,\n    diffuseness: diffusenessReport,\n    separation: separationReport,\n  };\n}", "parameters": [{"name": "domain", "type": "any", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "siblingDomains", "type": "any[]", "optional": true}], "returnType": "Promise<{ capacity: any; diffuseness: any; separation: any; }>"}, {"id": "apps/name-forge/webui/src/components/generator/GenerateTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/generator/GenerateTab.jsx", "sourceCode": "/**\n * Generate Tab - Full control over name generation\n *\n * Note: Conditions (entityKind, subtype, tags, prominence) are evaluated at the\n * strategy GROUP level within profiles, not at the profile level. The generator\n * filters which strategy groups apply based on the generation context.\n */\nfunction GenerateTab({ worldSchema, cultures, formState, onFormStateChange }) {\n  // Use lifted state if provided, otherwise use local state\n  const [localState, setLocalState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }], // Start with one empty row\n  });\n\n  // Use formState from parent if available\n  const state = formState || localState;\n  const setState = onFormStateChange || setLocalState;\n\n  // Destructure for convenience\n  const {\n    selectedCulture,\n    selectedProfile,\n    selectedKind,\n    selectedSubKind,\n    tags,\n    prominence,\n    count,\n    contextPairs,\n  } = state;\n\n  // Update helpers\n  const updateField = (field, value) => {\n    setState({ ...state, [field]: value });\n  };\n\n  // Results\n  const [generatedNames, setGeneratedNames] = useState([]);\n  const [debugInfo, setDebugInfo] = useState([]);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [generating, setGenerating] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Get available options from schema\n  const cultureIds = Object.keys(cultures || {});\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  // Get profiles for selected culture\n  const availableProfiles = useMemo(() => {\n    if (!selectedCulture) return [];\n    return cultures[selectedCulture]?.naming?.profiles || [];\n  }, [selectedCulture, cultures]);\n\n  // Auto-select first profile when culture changes\n  useMemo(() => {\n    if (availableProfiles.length > 0 && !selectedProfile) {\n      updateField(\"selectedProfile\", availableProfiles[0].id);\n    } else if (availableProfiles.length === 0 && selectedProfile) {\n      updateField(\"selectedProfile\", \"\");\n    }\n  }, [availableProfiles]);\n\n  // Get subkinds for selected entity kind\n  const subKinds = useMemo(() => {\n    if (!selectedKind || !worldSchema?.entityKinds) return [];\n    const entity = worldSchema.entityKinds.find((e) => e.kind === selectedKind);\n    return entity?.subtypes?.map((s) => s.id) || [];\n  }, [selectedKind, worldSchema]);\n\n  // Prominence levels\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  // Get the culture for generation\n  const getSelectedCulture = () => {\n    if (!selectedCulture) return null;\n    return cultures[selectedCulture] || null;\n  };\n\n  // Context pair handlers\n  const handleAddContextPair = () => {\n    updateField(\"contextPairs\", [...contextPairs, { key: \"\", value: \"\" }]);\n  };\n\n  const handleRemoveContextPair = (index) => {\n    const newPairs = contextPairs.filter((_, i) => i !== index);\n    // Always keep at least one row\n    updateField(\"contextPairs\", newPairs.length > 0 ? newPairs : [{ key: \"\", value: \"\" }]);\n  };\n\n  const handleUpdateContextPair = (index, field, value) => {\n    const updated = [...contextPairs];\n    updated[index] = { ...updated[index], [field]: value };\n    updateField(\"contextPairs\", updated);\n  };\n\n  const handleGenerate = async () => {\n    setError(null);\n    setGenerating(true);\n\n    try {\n      const culture = getSelectedCulture();\n\n      if (!culture) {\n        throw new Error(\"No culture selected.\");\n      }\n\n      if (!culture?.naming?.profiles || culture.naming.profiles.length === 0) {\n        throw new Error(\"No profile found. Create a profile in Workshop \u2192 Profiles.\");\n      }\n\n      // Parse tags for condition matching\n      const tagList = Array.isArray(tags) ? tags : [];\n\n      // Build context object from key-value pairs for grammar context:key slots\n      const userContext = {};\n      for (const pair of contextPairs) {\n        if (pair.key) {\n          userContext[pair.key] = pair.value;\n        }\n      }\n\n      // Add standard fields to context as well\n      if (selectedKind) userContext.entityKind = selectedKind;\n      if (selectedSubKind) userContext.subtype = selectedSubKind;\n      if (prominence) userContext.prominence = prominence;\n      if (tagList.length > 0) userContext.tags = tagList.join(\",\");\n\n      // Generate names - pass culture directly\n      const result = await generateTestNames({\n        culture,\n        profileId: selectedProfile || undefined,\n        count,\n        seed: `generate-${Date.now()}`,\n        context: userContext,\n        kind: selectedKind || undefined,\n        subtype: selectedSubKind || undefined,\n        prominence: prominence || undefined,\n        tags: tagList,\n      });\n\n      setGeneratedNames(result.names || []);\n      setDebugInfo(result.debugInfo || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setError(err.message);\n      setGeneratedNames([]);\n      setDebugInfo([]);\n    } finally {\n      setGenerating(false);\n    }\n  };\n\n  const handleCopy = () => {\n    navigator.clipboard.writeText(generatedNames.join(\"\\n\"));\n  };\n\n  const handleCopyJson = () => {\n    navigator.clipboard.writeText(JSON.stringify(generatedNames, null, 2));\n  };\n\n  // Check if we can generate\n  const canGenerate = selectedCulture;\n  const culture = canGenerate ? getSelectedCulture() : null;\n  const hasProfile = culture?.naming?.profiles?.length > 0;\n\n  return (\n    <div className=\"generate-container\">\n      <h2>Name Generator</h2>\n      <p className=\"text-muted intro\">\n        Generate names using configured profiles. Strategy groups with conditions will be filtered\n        based on entity type, subtype, tags, and prominence.\n      </p>\n\n      <div className=\"generate-layout\">\n        {/* Left: Controls */}\n        <div className=\"generate-controls\">\n          <div className=\"card mb-md\">\n            <h3 className=\"mt-0 mb-md\">Generation Settings</h3>\n\n            {/* Culture Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"culture\">Culture *</label>\n              <select id=\"culture\"\n                value={selectedCulture}\n                onChange={(e) => {\n                  setState({ ...state, selectedCulture: e.target.value, selectedProfile: \"\" });\n                }}\n              >\n                <option value=\"\">Select a culture...</option>\n                {cultureIds.map((id) => (\n                  <option key={id} value={id}>\n                    {cultures[id]?.name || id}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            {/* Profile Selection */}\n            <div className=\"form-group\">\n              <label htmlFor=\"profile\">Profile</label>\n              <select id=\"profile\"\n                value={selectedProfile}\n                onChange={(e) => updateField(\"selectedProfile\", e.target.value)}\n                disabled={availableProfiles.length === 0}\n              >\n                {availableProfiles.length === 0 ? (\n                  <option value=\"\">No profiles available</option>\n                ) : (\n                  availableProfiles.map((p) => (\n                    <option key={p.id} value={p.id}>\n                      {p.id}\n                    </option>\n                  ))\n                )}\n              </select>\n            </div>\n\n            <div className=\"generate-section-divider\">\n              <div className=\"generate-section-header\">\n                Context (for conditional strategy groups)\n              </div>\n\n              {/* Entity Kind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"entity-kind\">Entity Kind</label>\n                <select id=\"entity-kind\"\n                  value={selectedKind}\n                  onChange={(e) => {\n                    setState({ ...state, selectedKind: e.target.value, selectedSubKind: \"\" });\n                  }}\n                >\n                  <option value=\"\">Any type</option>\n                  {entityKinds.map((kind) => (\n                    <option key={kind} value={kind}>\n                      {kind}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* SubKind */}\n              <div className=\"form-group\">\n                <label htmlFor=\"subtype\">Subtype</label>\n                <select id=\"subtype\"\n                  value={selectedSubKind}\n                  onChange={(e) => updateField(\"selectedSubKind\", e.target.value)}\n                  disabled={subKinds.length === 0}\n                >\n                  <option value=\"\">Any subtype</option>\n                  {subKinds.map((sub) => (\n                    <option key={sub} value={sub}>\n                      {sub}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Tags */}\n              <div className=\"form-group\">\n                <label>Tags\n                <TagSelector\n                  value={tags || []}\n                  onChange={(vals) => updateField(\"tags\", vals)}\n                  tagRegistry={tagRegistry}\n                  placeholder=\"Select tags...\"\n                />\n                </label>\n              </div>\n\n              {/* Prominence */}\n              <div className=\"form-group\">\n                <label htmlFor=\"prominence\">Prominence</label>\n                <select id=\"prominence\"\n                  value={prominence}\n                  onChange={(e) => updateField(\"prominence\", e.target.value)}\n                >\n                  <option value=\"\">Any prominence</option>\n                  {prominenceLevels.map((level) => (\n                    <option key={level} value={level}>\n                      {level}\n                    </option>\n                  ))}\n                </select>\n              </div>\n            </div>\n\n            {/* Context Key-Value Pairs */}\n            <div className=\"generate-section-divider\">\n              <div className=\"flex justify-between items-center mb-sm\">\n                <div className=\"generate-section-header mb-0\">\n                  Context Values\n                  <span className=\"hint\">(for context:key slots)</span>\n                </div>\n                <button type=\"button\" onClick={handleAddContextPair} className=\"add-row-btn\">\n// ... (truncated)", "parameters": [{"name": "{ worldSchema, cultures, formState, onFormStateChange }", "type": "{ worldSchema: any; cultures: any; formState: any; onFormStateChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/modals/ConditionsModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/modals/ConditionsModal.jsx", "sourceCode": "function ConditionsModal({ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }) {\n  const [localConditions, setLocalConditions] = useState(conditions || {});\n\n  useEffect(() => {\n    setLocalConditions(conditions || {});\n  }, [conditions, isOpen]);\n\n  const handleSave = () => {\n    // Clean up empty values\n    const cleaned = {};\n    if (localConditions.tags?.length > 0) cleaned.tags = localConditions.tags;\n    if (localConditions.requireAllTags) cleaned.requireAllTags = true;\n    if (localConditions.prominence?.length > 0) cleaned.prominence = localConditions.prominence;\n    if (localConditions.subtype?.length > 0) cleaned.subtype = localConditions.subtype;\n\n    onChange(Object.keys(cleaned).length > 0 ? cleaned : undefined);\n    onClose();\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <ModalShell onClose={onClose} title=\"Strategy Conditions\" className=\"conditions-modal\">\n      <p className=\"text-muted text-small mt-0\">\n        Define when this strategy should be used. Leave empty for unconditional use.\n      </p>\n\n      {/* Tags */}\n      <div className=\"form-group\">\n        <label>Entity Tags\n        <TagSelector\n          value={localConditions.tags || []}\n          onChange={(tags) =>\n            setLocalConditions({ ...localConditions, tags: tags.length > 0 ? tags : undefined })\n          }\n          tagRegistry={tagRegistry}\n          placeholder=\"Select tags...\"\n          matchAllEnabled={true}\n          matchAll={localConditions.requireAllTags || false}\n          onMatchAllChange={(val) =>\n            setLocalConditions({ ...localConditions, requireAllTags: val || undefined })\n          }\n          onAddToRegistry={onAddTag}\n        />\n        </label>\n        <small className=\"text-muted\">\n          Use tags from the shared registry; toggle match-all when needed.\n        </small>\n      </div>\n\n      {/* Prominence */}\n      <div className=\"form-group\">\n        <span>Prominence Levels</span>\n        <div className=\"flex flex-wrap gap-sm mt-xs\">\n          {PROMINENCE_LEVELS.map((level) => {\n            const isSelected = (localConditions.prominence || []).includes(level);\n            return (\n              <button\n                key={level}\n                type=\"button\"\n                onClick={() => {\n                  const current = localConditions.prominence || [];\n                  const updated = isSelected\n                    ? current.filter((l) => l !== level)\n                    : [...current, level];\n                  setLocalConditions({\n                    ...localConditions,\n                    prominence: updated.length > 0 ? updated : undefined,\n                  });\n                }}\n                className={`pill-button ${isSelected ? \"selected-gold\" : \"\"}`}\n              >\n                {level}\n              </button>\n            );\n          })}\n        </div>\n        <small className=\"text-muted mt-sm block\">\n          Only use this strategy for entities with selected prominence levels\n        </small>\n      </div>\n\n      {/* Subtype */}\n      <div className=\"form-group\">\n        <label htmlFor=\"entity-subtypes\">Entity Subtypes</label>\n        <input id=\"entity-subtypes\"\n          value={(localConditions.subtype || []).join(\", \")}\n          onChange={(e) => {\n            const subtypes = e.target.value\n              .split(\",\")\n              .map((t) => t.trim())\n              .filter((t) => t);\n            setLocalConditions({\n              ...localConditions,\n              subtype: subtypes.length > 0 ? subtypes : undefined,\n            });\n          }}\n          placeholder=\"e.g., merchant, artisan, warrior\"\n        />\n        <small className=\"text-muted\">Comma-separated list of subtypes to match</small>\n      </div>\n\n      {/* Summary */}\n      {(localConditions.tags?.length > 0 ||\n        localConditions.prominence?.length > 0 ||\n        localConditions.subtype?.length > 0) && (\n        <div className=\"conditions-preview\">\n          <strong className=\"text-gold\">Preview:</strong> This strategy will be used when entity has{\" \"}\n          {[\n            localConditions.tags?.length > 0 &&\n              `${localConditions.requireAllTags ? \"ALL\" : \"any\"} tags: ${localConditions.tags.join(\", \")}`,\n            localConditions.prominence?.length > 0 &&\n              `prominence: ${localConditions.prominence.join(\" or \")}`,\n            localConditions.subtype?.length > 0 &&\n              `subtype: ${localConditions.subtype.join(\" or \")}`,\n          ]\n            .filter(Boolean)\n            .join(\" AND \")}\n        </div>\n      )}\n\n      <div className=\"flex gap-md mt-lg justify-end\">\n        <button className=\"secondary\" onClick={onClose}>\n          Cancel\n        </button>\n        <button className=\"primary\" onClick={handleSave}>\n          Save Conditions\n        </button>\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, conditions, onChange, tagRegistry = [], onAddTag }", "type": "{ isOpen: any; onClose: any; conditions: any; onChange: any; tagRegistry?: any[]; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx::computeDomainDiff", "name": "computeDomainDiff", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx", "sourceCode": "/**\n * Compute diff between two domain configs\n * Returns an array of changes with path, old value, and new value\n */\nexport function computeDomainDiff(initial, optimized) {\n  const changes = [];\n\n  if (!initial || !optimized) return changes;\n\n  // Helper to compare arrays\n  const arrayDiff = (path, oldArr, newArr, labels) => {\n    if (!oldArr && !newArr) return;\n    if (!oldArr) {\n      changes.push({ path, type: \"added\", newValue: newArr });\n      return;\n    }\n    if (!newArr) {\n      changes.push({ path, type: \"removed\", oldValue: oldArr });\n      return;\n    }\n\n    // For weight arrays, show significant changes\n    const changedIndices = [];\n    const maxLen = Math.max(oldArr.length, newArr.length);\n    for (let i = 0; i < maxLen; i++) {\n      const oldVal = oldArr[i] ?? 0;\n      const newVal = newArr[i] ?? 0;\n      if (Math.abs(oldVal - newVal) > 0.01) {\n        changedIndices.push({\n          index: i,\n          label: labels?.[i] || `[${i}]`,\n          oldVal: typeof oldVal === \"number\" ? oldVal.toFixed(2) : oldVal,\n          newVal: typeof newVal === \"number\" ? newVal.toFixed(2) : newVal,\n        });\n      }\n    }\n    if (changedIndices.length > 0) {\n      changes.push({ path, type: \"weights\", changes: changedIndices });\n    }\n  };\n\n  // Helper to compare scalars\n  const scalarDiff = (path, oldVal, newVal) => {\n    if (oldVal === newVal) return;\n    if (oldVal === undefined && newVal === undefined) return;\n\n    const oldNum = typeof oldVal === \"number\" ? oldVal : null;\n    const newNum = typeof newVal === \"number\" ? newVal : null;\n\n    if (oldNum !== null && newNum !== null) {\n      if (Math.abs(oldNum - newNum) < 0.001) return;\n    }\n\n    changes.push({\n      path,\n      type: \"scalar\",\n      oldValue: oldVal === undefined ? \"(default)\" : oldVal,\n      newValue: newVal === undefined ? \"(default)\" : newVal,\n    });\n  };\n\n  // Helper to compare string arrays (sets)\n  const setDiff = (path, oldSet, newSet) => {\n    if (!oldSet && !newSet) return;\n    const oldItems = new Set(oldSet || []);\n    const newItems = new Set(newSet || []);\n\n    const added = [...newItems].filter((x) => !oldItems.has(x));\n    const removed = [...oldItems].filter((x) => !newItems.has(x));\n\n    if (added.length > 0 || removed.length > 0) {\n      changes.push({ path, type: \"set\", added, removed });\n    }\n  };\n\n  // Compare phonology\n  const ph = { old: initial.phonology, new: optimized.phonology };\n  arrayDiff(\n    \"phonology.consonantWeights\",\n    ph.old?.consonantWeights,\n    ph.new?.consonantWeights,\n    ph.old?.consonants\n  );\n  arrayDiff(\"phonology.vowelWeights\", ph.old?.vowelWeights, ph.new?.vowelWeights, ph.old?.vowels);\n  arrayDiff(\n    \"phonology.templateWeights\",\n    ph.old?.templateWeights,\n    ph.new?.templateWeights,\n    ph.old?.syllableTemplates\n  );\n  scalarDiff(\n    \"phonology.favoredClusterBoost\",\n    ph.old?.favoredClusterBoost,\n    ph.new?.favoredClusterBoost\n  );\n  setDiff(\"phonology.favoredClusters\", ph.old?.favoredClusters, ph.new?.favoredClusters);\n  setDiff(\"phonology.consonants\", ph.old?.consonants, ph.new?.consonants);\n  setDiff(\"phonology.vowels\", ph.old?.vowels, ph.new?.vowels);\n\n  if (ph.old?.lengthRange && ph.new?.lengthRange) {\n    if (\n      ph.old.lengthRange[0] !== ph.new.lengthRange[0] ||\n      ph.old.lengthRange[1] !== ph.new.lengthRange[1]\n    ) {\n      changes.push({\n        path: \"phonology.lengthRange\",\n        type: \"scalar\",\n        oldValue: `[${ph.old.lengthRange[0]}, ${ph.old.lengthRange[1]}]`,\n        newValue: `[${ph.new.lengthRange[0]}, ${ph.new.lengthRange[1]}]`,\n      });\n    }\n  }\n\n  // Compare morphology\n  const mo = { old: initial.morphology, new: optimized.morphology };\n  arrayDiff(\n    \"morphology.prefixWeights\",\n    mo.old?.prefixWeights,\n    mo.new?.prefixWeights,\n    mo.old?.prefixes\n  );\n  arrayDiff(\n    \"morphology.suffixWeights\",\n    mo.old?.suffixWeights,\n    mo.new?.suffixWeights,\n    mo.old?.suffixes\n  );\n  arrayDiff(\n    \"morphology.structureWeights\",\n    mo.old?.structureWeights,\n    mo.new?.structureWeights,\n    mo.old?.structure\n  );\n\n  // Compare style\n  const st = { old: initial.style || {}, new: optimized.style || {} };\n  scalarDiff(\"style.apostropheRate\", st.old.apostropheRate, st.new.apostropheRate);\n  scalarDiff(\"style.hyphenRate\", st.old.hyphenRate, st.new.hyphenRate);\n  scalarDiff(\"style.targetLength\", st.old.targetLength, st.new.targetLength);\n  scalarDiff(\"style.lengthTolerance\", st.old.lengthTolerance, st.new.lengthTolerance);\n  scalarDiff(\n    \"style.preferredEndingBoost\",\n    st.old.preferredEndingBoost,\n    st.new.preferredEndingBoost\n  );\n  scalarDiff(\"style.capitalization\", st.old.capitalization, st.new.capitalization);\n  scalarDiff(\"style.rhythmBias\", st.old.rhythmBias, st.new.rhythmBias);\n\n  return changes;\n}", "parameters": [{"name": "initial", "type": "any", "optional": false}, {"name": "optimized", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainDiff.jsx", "sourceCode": "/**\n * Domain Diff Component - Shows what changed in a collapsible format\n */\nexport default function DomainDiff({ initial, optimized }) {\n  const changes = useMemo(() => computeDomainDiff(initial, optimized), [initial, optimized]);\n\n  if (changes.length === 0) {\n    return <div className=\"text-muted italic p-sm\">No changes detected</div>;\n  }\n\n  return (\n    <div className=\"text-small\">\n      {changes.map((change, i) => (\n        <div key={i} className={`diff-row ${i % 2 === 0 ? \"alt\" : \"\"}`}>\n          <div className=\"diff-path\">{change.path}</div>\n\n          {change.type === \"scalar\" && (\n            <div className=\"flex align-center gap-sm\">\n              <span className=\"diff-old\">{String(change.oldValue)}</span>\n              <span className=\"text-muted\">\u2192</span>\n              <span className=\"diff-new\">{String(change.newValue)}</span>\n            </div>\n          )}\n\n          {change.type === \"set\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.removed.map((item, j) => (\n                <span key={`r${j}`} className=\"diff-tag removed\">\n                  -{item}\n                </span>\n              ))}\n              {change.added.map((item, j) => (\n                <span key={`a${j}`} className=\"diff-tag added\">\n                  +{item}\n                </span>\n              ))}\n            </div>\n          )}\n\n          {change.type === \"weights\" && (\n            <div className=\"flex flex-wrap gap-xs\">\n              {change.changes.slice(0, 8).map((c, j) => (\n                <span key={j} className=\"diff-weight\">\n                  <strong className=\"text-gold\">{c.label}</strong>: {c.oldVal}\u2192{c.newVal}\n                </span>\n              ))}\n              {change.changes.length > 8 && (\n                <span className=\"text-muted text-small\">+{change.changes.length - 8} more</span>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ initial, optimized }", "type": "{ initial: any; optimized: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/DomainSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/DomainSelector.jsx", "sourceCode": "/**\n * DomainSelector - Left panel for selecting domains to optimize\n */\nexport default function DomainSelector({\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}) {\n  return (\n    <div className=\"optimizer-sidebar\">\n      <div className=\"optimizer-sidebar-header\">\n        <h3 className=\"mt-0 mb-sm text-small\">Select Domains</h3>\n        <div className=\"flex gap-sm\">\n          <button onClick={onSelectAll} className=\"secondary btn-xs\">\n            Select All\n          </button>\n          <button onClick={onDeselectAll} className=\"secondary btn-xs\">\n            Clear\n          </button>\n        </div>\n        <div className=\"mt-sm text-small text-muted\">\n          {selectedDomains.size} of {allDomains.length} selected\n        </div>\n      </div>\n\n      <div className=\"optimizer-sidebar-list\">\n        {Object.entries(domainsByCulture).map(([cultureId, { name, domains }]) => {\n          const isExpanded = expandedCultures.has(cultureId);\n          const allSelected = domains.every((d) => selectedDomains.has(d.id));\n          const someSelected = domains.some((d) => selectedDomains.has(d.id));\n\n          return (\n            <div key={cultureId} className=\"mb-sm\">\n              <div className=\"culture-row\">\n                <input\n                  type=\"checkbox\"\n                  checked={allSelected}\n                  ref={(el) => {\n                    if (el) el.indeterminate = someSelected && !allSelected;\n                  }}\n                  onChange={() => onToggleAllInCulture(cultureId)}\n                  onClick={(e) => e.stopPropagation()}\n                  className=\"accent-ice\"\n                />\n                <span onClick={() => onToggleCulture(cultureId)} className=\"culture-row-label\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                  {isExpanded ? \"\u25bc\" : \"\u25b6\"} {name || cultureId}\n                  <span className=\"text-muted font-normal ml-sm\">({domains.length})</span>\n                </span>\n              </div>\n\n              {isExpanded && (\n                <div className=\"domain-list\">\n                  {domains.map((domain) => (\n                    <div\n                      key={domain.id}\n                      className={`domain-row ${selectedDomains.has(domain.id) ? \"selected\" : \"\"}`}\n                      onClick={() => onToggleDomain(domain.id)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <input\n                        type=\"checkbox\"\n                        checked={selectedDomains.has(domain.id)}\n                        onChange={() => onToggleDomain(domain.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        className=\"accent-gold\"\n                      />\n                      <span>{domain.id}</span>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          );\n        })}\n\n        {allDomains.length === 0 && (\n          <div className=\"empty-message\">\n            No domains found. Create domains in the Workshop tab first.\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  domainsByCulture,\n  allDomains,\n  selectedDomains,\n  expandedCultures,\n  onToggleDomain,\n  onToggleCulture,\n  onToggleAllInCulture,\n  onSelectAll,\n  onDeselectAll,\n}", "type": "{ domainsByCulture: any; allDomains: any; selectedDomains: any; expandedCultures: any; onToggleDomain: any; onToggleCulture: any; onToggleAllInCulture: any; onSelectAll: any; onDeselectAll: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/index.js::computeDomainDiff", "name": "computeDomainDiff", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/index.js", "sourceCode": "/**\n * Compute diff between two domain configs\n * Returns an array of changes with path, old value, and new value\n */\nexport function computeDomainDiff(initial, optimized) {\n  const changes = [];\n\n  if (!initial || !optimized) return changes;\n\n  // Helper to compare arrays\n  const arrayDiff = (path, oldArr, newArr, labels) => {\n    if (!oldArr && !newArr) return;\n    if (!oldArr) {\n      changes.push({ path, type: \"added\", newValue: newArr });\n      return;\n    }\n    if (!newArr) {\n      changes.push({ path, type: \"removed\", oldValue: oldArr });\n      return;\n    }\n\n    // For weight arrays, show significant changes\n    const changedIndices = [];\n    const maxLen = Math.max(oldArr.length, newArr.length);\n    for (let i = 0; i < maxLen; i++) {\n      const oldVal = oldArr[i] ?? 0;\n      const newVal = newArr[i] ?? 0;\n      if (Math.abs(oldVal - newVal) > 0.01) {\n        changedIndices.push({\n          index: i,\n          label: labels?.[i] || `[${i}]`,\n          oldVal: typeof oldVal === \"number\" ? oldVal.toFixed(2) : oldVal,\n          newVal: typeof newVal === \"number\" ? newVal.toFixed(2) : newVal,\n        });\n      }\n    }\n    if (changedIndices.length > 0) {\n      changes.push({ path, type: \"weights\", changes: changedIndices });\n    }\n  };\n\n  // Helper to compare scalars\n  const scalarDiff = (path, oldVal, newVal) => {\n    if (oldVal === newVal) return;\n    if (oldVal === undefined && newVal === undefined) return;\n\n    const oldNum = typeof oldVal === \"number\" ? oldVal : null;\n    const newNum = typeof newVal === \"number\" ? newVal : null;\n\n    if (oldNum !== null && newNum !== null) {\n      if (Math.abs(oldNum - newNum) < 0.001) return;\n    }\n\n    changes.push({\n      path,\n      type: \"scalar\",\n      oldValue: oldVal === undefined ? \"(default)\" : oldVal,\n      newValue: newVal === undefined ? \"(default)\" : newVal,\n    });\n  };\n\n  // Helper to compare string arrays (sets)\n  const setDiff = (path, oldSet, newSet) => {\n    if (!oldSet && !newSet) return;\n    const oldItems = new Set(oldSet || []);\n    const newItems = new Set(newSet || []);\n\n    const added = [...newItems].filter((x) => !oldItems.has(x));\n    const removed = [...oldItems].filter((x) => !newItems.has(x));\n\n    if (added.length > 0 || removed.length > 0) {\n      changes.push({ path, type: \"set\", added, removed });\n    }\n  };\n\n  // Compare phonology\n  const ph = { old: initial.phonology, new: optimized.phonology };\n  arrayDiff(\n    \"phonology.consonantWeights\",\n    ph.old?.consonantWeights,\n    ph.new?.consonantWeights,\n    ph.old?.consonants\n  );\n  arrayDiff(\"phonology.vowelWeights\", ph.old?.vowelWeights, ph.new?.vowelWeights, ph.old?.vowels);\n  arrayDiff(\n    \"phonology.templateWeights\",\n    ph.old?.templateWeights,\n    ph.new?.templateWeights,\n    ph.old?.syllableTemplates\n  );\n  scalarDiff(\n    \"phonology.favoredClusterBoost\",\n    ph.old?.favoredClusterBoost,\n    ph.new?.favoredClusterBoost\n  );\n  setDiff(\"phonology.favoredClusters\", ph.old?.favoredClusters, ph.new?.favoredClusters);\n  setDiff(\"phonology.consonants\", ph.old?.consonants, ph.new?.consonants);\n  setDiff(\"phonology.vowels\", ph.old?.vowels, ph.new?.vowels);\n\n  if (ph.old?.lengthRange && ph.new?.lengthRange) {\n    if (\n      ph.old.lengthRange[0] !== ph.new.lengthRange[0] ||\n      ph.old.lengthRange[1] !== ph.new.lengthRange[1]\n    ) {\n      changes.push({\n        path: \"phonology.lengthRange\",\n        type: \"scalar\",\n        oldValue: `[${ph.old.lengthRange[0]}, ${ph.old.lengthRange[1]}]`,\n        newValue: `[${ph.new.lengthRange[0]}, ${ph.new.lengthRange[1]}]`,\n      });\n    }\n  }\n\n  // Compare morphology\n  const mo = { old: initial.morphology, new: optimized.morphology };\n  arrayDiff(\n    \"morphology.prefixWeights\",\n    mo.old?.prefixWeights,\n    mo.new?.prefixWeights,\n    mo.old?.prefixes\n  );\n  arrayDiff(\n    \"morphology.suffixWeights\",\n    mo.old?.suffixWeights,\n    mo.new?.suffixWeights,\n    mo.old?.suffixes\n  );\n  arrayDiff(\n    \"morphology.structureWeights\",\n    mo.old?.structureWeights,\n    mo.new?.structureWeights,\n    mo.old?.structure\n  );\n\n  // Compare style\n  const st = { old: initial.style || {}, new: optimized.style || {} };\n  scalarDiff(\"style.apostropheRate\", st.old.apostropheRate, st.new.apostropheRate);\n  scalarDiff(\"style.hyphenRate\", st.old.hyphenRate, st.new.hyphenRate);\n  scalarDiff(\"style.targetLength\", st.old.targetLength, st.new.targetLength);\n  scalarDiff(\"style.lengthTolerance\", st.old.lengthTolerance, st.new.lengthTolerance);\n  scalarDiff(\n    \"style.preferredEndingBoost\",\n    st.old.preferredEndingBoost,\n    st.new.preferredEndingBoost\n  );\n  scalarDiff(\"style.capitalization\", st.old.capitalization, st.new.capitalization);\n  scalarDiff(\"style.rhythmBias\", st.old.rhythmBias, st.new.rhythmBias);\n\n  return changes;\n}", "parameters": [{"name": "initial", "type": "any", "optional": false}, {"name": "optimized", "type": "any", "optional": false}], "returnType": "any[]"}, {"id": "apps/name-forge/webui/src/components/optimizer/OptimizerSettings.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/OptimizerSettings.jsx", "sourceCode": "/**\n * OptimizerSettings - Right panel for algorithm settings and optimization controls\n */\nexport default function OptimizerSettings({\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}) {\n  const handleAlgorithmParamChange = (key, defaultValue) => (v) => {\n    onAlgorithmParamsChange((prev) => ({ ...prev, [key]: v ?? defaultValue }));\n  };\n\n  // Render algorithm parameter inputs\n  const renderAlgorithmParams = () => {\n    const config = ALGORITHMS[algorithm];\n    if (!config?.params || Object.keys(config.params).length === 0) {\n      return (\n        <p className=\"text-muted text-small italic\">No additional parameters for this algorithm.</p>\n      );\n    }\n\n    return (\n      <div className=\"optimizer-param-grid\">\n        {Object.entries(config.params).map(([key, param]) => (\n          <div key={key} className=\"flex flex-col gap-xs\">\n            <label className=\"text-small\">{param.label}\n            <NumberInput\n              value={algorithmParams[key] ?? param.default}\n              onChange={handleAlgorithmParamChange(key, param.default)}\n              min={param.min}\n              max={param.max}\n              step={param.step || 1}\n              className=\"optimizer-input\"\n            />\n            </label>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"optimizer-main\">\n      {/* Settings */}\n      <div className=\"optimizer-settings-area\">\n        <h2 className=\"mt-0 mb-md\">Optimizer Settings</h2>\n\n        {/* Algorithm Selection */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm</h3>\n          <div className=\"algorithm-grid\">\n            {Object.entries(ALGORITHMS).map(([key, config]) => (\n              <div\n                key={key}\n                onClick={() => onAlgorithmChange(key)}\n                className={`algorithm-card ${algorithm === key ? \"selected\" : \"\"}`}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className={`algorithm-name ${algorithm === key ? \"selected\" : \"\"}`}>\n                  {config.name}\n                </div>\n                <div className=\"algorithm-desc\">{config.description}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Algorithm-Specific Parameters */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Algorithm Parameters</h3>\n          {renderAlgorithmParams()}\n        </div>\n\n        {/* Validation Settings */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Validation Settings</h3>\n          <div className=\"optimizer-param-grid-small\">\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Size\n              <NumberInput\n                value={validationSettings.requiredNames}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, requiredNames: v ?? 500 }))\n                }\n                min={100}\n                max={5000}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n            <div className=\"flex flex-col gap-xs\">\n              <label className=\"text-small\">Sample Factor\n              <NumberInput\n                value={validationSettings.sampleFactor}\n                onChange={(v) =>\n                  onValidationSettingsChange((prev) => ({ ...prev, sampleFactor: v ?? 10 }))\n                }\n                min={1}\n                max={50}\n                className=\"optimizer-input\"\n                integer\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n\n        {/* Fitness Weights */}\n        <div className=\"mb-lg\">\n          <h3 className=\"section-title\">Fitness Weights</h3>\n          <div className=\"fitness-grid\">\n            {[\n              { key: \"capacity\", label: \"Capacity\", title: \"Entropy / collision rate\" },\n              { key: \"diffuseness\", label: \"Diffuseness\", title: \"Intra-domain variation\" },\n              { key: \"separation\", label: \"Separation\", title: \"Inter-domain distinctiveness\" },\n              { key: \"pronounceability\", label: \"Pronounce\", title: \"Phonetic naturalness\" },\n              { key: \"length\", label: \"Length\", title: \"Target length adherence\" },\n              { key: \"style\", label: \"Style\", title: \"LLM style judge (optional)\" },\n            ].map(({ key, label, title }) => (\n              <div key={key} className=\"flex flex-col gap-xs\">\n                <label className=\"text-small\" title={title}>\n                  {label}\n                </label>\n                <NumberInput\n                  step={0.1}\n                  min={0}\n                  max={1}\n                  value={fitnessWeights[key]}\n                  onChange={(v) => onFitnessWeightsChange((prev) => ({ ...prev, [key]: v ?? 0 }))}\n                  title={title}\n                  disabled={key === \"separation\" && allDomains.length <= 1}\n                  className={`optimizer-input ${key === \"separation\" && allDomains.length <= 1 ? \"disabled\" : \"\"}`}\n                />\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Run Button */}\n        <div className=\"flex gap-md align-center flex-wrap\">\n          <button\n            onClick={onOptimize}\n            disabled={optimizing || selectedDomains.size === 0}\n            className={`optimize-button ${optimizing || selectedDomains.size === 0 ? \"disabled\" : \"\"}`}\n          >\n            {optimizing ? \"Optimizing...\" : `Optimize ${selectedDomains.size} Domain(s)`}\n          </button>\n\n          {results.length > 0 && results.some((r) => r.success) && (\n            <button onClick={onSaveResults} className=\"secondary optimize-action-button\">\n              Save Results\n            </button>\n          )}\n\n          {optimizing && (\n            <span className=\"text-small text-muted\">\n              {progress.current}/{progress.total}: {progress.currentDomain}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Status Bar - Shows when there are results */}\n      {results.length > 0 && !optimizing && (\n        <div className=\"optimizer-status-bar\">\n          <div className=\"flex align-center gap-md\">\n            <span className=\"text-small\">\n              Last run:{\" \"}\n              <strong className=\"text-success\">{results.filter((r) => r.success).length}</strong>{\" \"}\n              succeeded,{\" \"}\n              <strong className={results.some((r) => !r.success) ? \"text-danger\" : \"\"}>\n                {results.filter((r) => !r.success).length}\n              </strong>{\" \"}\n              failed\n            </span>\n            {results.filter((r) => r.success).length > 0 && (\n              <span className=\"text-gold font-bold text-small\">\n                Avg improvement: +\n                {(\n                  (results\n                    .filter((r) => r.success)\n                    .reduce((sum, r) => sum + (r.improvement || 0), 0) /\n                    results.filter((r) => r.success).length) *\n                  100\n                ).toFixed(1)}\n                %\n              </span>\n            )}\n          </div>\n          <button onClick={onShowModal} className=\"secondary text-small\">\n            View Details\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  algorithm,\n  onAlgorithmChange,\n  algorithmParams,\n  onAlgorithmParamsChange,\n  validationSettings,\n  onValidationSettingsChange,\n  fitnessWeights,\n  onFitnessWeightsChange,\n  selectedDomains,\n  allDomains,\n  optimizing,\n  progress,\n  results,\n  onOptimize,\n  onSaveResults,\n  onShowModal,\n}", "type": "{ algorithm: any; onAlgorithmChange: any; algorithmParams: any; onAlgorithmParamsChange: any; validationSettings: any; onValidationSettingsChange: any; fitnessWeights: any; onFitnessWeightsChange: any; selectedDomains: any; allDomains: any; optimizing: any; progress: any; results: any; onOptimize: any; onSaveResults: any; onShowModal: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/OptimizerWorkshop.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/OptimizerWorkshop.jsx", "sourceCode": "/**\n * Optimizer Workshop - Dedicated UI for domain optimization\n * Now runs entirely in the browser (no server required)\n */\nexport default function OptimizerWorkshop({ cultures, onCulturesChange }) {\n  // Domain selection state\n  const [selectedDomains, setSelectedDomains] = useState(new Set());\n  const [expandedCultures, setExpandedCultures] = useState(new Set());\n\n  // Algorithm and settings state\n  const [algorithm, setAlgorithm] = useState(\"hillclimb\");\n  const [algorithmParams, setAlgorithmParams] = useState({});\n  const [validationSettings, setValidationSettings] = useState({\n    requiredNames: 500,\n    sampleFactor: 10,\n  });\n  const [fitnessWeights, setFitnessWeights] = useState({\n    capacity: 0.2,\n    diffuseness: 0.2,\n    separation: 0.2,\n    pronounceability: 0.3,\n    length: 0.1,\n    style: 0.0,\n  });\n\n  // Optimization state\n  const [optimizing, setOptimizing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0, currentDomain: \"\" });\n  const [results, setResults] = useState([]);\n  const [logs, setLogs] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n\n  // Collect all domains from all cultures\n  const allDomains = useMemo(() => {\n    const domains = [];\n    Object.entries(cultures || {}).forEach(([cultureId, culture]) => {\n      const naming = culture?.naming || {};\n      (naming.domains || []).forEach((domain) => {\n        domains.push({\n          ...domain,\n          cultureId,\n          cultureName: culture.name || cultureId,\n        });\n      });\n    });\n    return domains;\n  }, [cultures]);\n\n  // Initialize algorithm params when algorithm changes\n  useEffect(() => {\n    const config = ALGORITHMS[algorithm];\n    if (config?.params) {\n      const defaults = {};\n      Object.entries(config.params).forEach(([key, param]) => {\n        defaults[key] = param.default;\n      });\n      setAlgorithmParams(defaults);\n    }\n  }, [algorithm]);\n\n  // Toggle culture expansion\n  const toggleCulture = (cultureId) => {\n    setExpandedCultures((prev) => {\n      const next = new Set(prev);\n      if (next.has(cultureId)) {\n        next.delete(cultureId);\n      } else {\n        next.add(cultureId);\n      }\n      return next;\n    });\n  };\n\n  // Toggle domain selection\n  const toggleDomain = (domainId) => {\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n\n  // Select/deselect all domains in a culture\n  const toggleAllInCulture = (cultureId) => {\n    const cultureDomains = allDomains.filter((d) => d.cultureId === cultureId);\n    const allSelected = cultureDomains.every((d) => selectedDomains.has(d.id));\n\n    setSelectedDomains((prev) => {\n      const next = new Set(prev);\n      cultureDomains.forEach((d) => {\n        if (allSelected) {\n          next.delete(d.id);\n        } else {\n          next.add(d.id);\n        }\n      });\n      return next;\n    });\n  };\n\n  // Select all domains\n  const selectAll = () => {\n    setSelectedDomains(new Set(allDomains.map((d) => d.id)));\n  };\n\n  // Deselect all domains\n  const deselectAll = () => {\n    setSelectedDomains(new Set());\n  };\n\n  // Add log entry\n  const addLog = (message, type = \"info\") => {\n    setLogs((prev) => [...prev, { message, type, timestamp: new Date().toISOString() }]);\n  };\n\n  // Run optimization (now runs in browser, no API needed)\n  const handleOptimize = async () => {\n    const domainsToOptimize = allDomains.filter((d) => selectedDomains.has(d.id));\n\n    if (domainsToOptimize.length === 0) {\n      addLog(\"No domains selected\", \"error\");\n      return;\n    }\n\n    setOptimizing(true);\n    setResults([]);\n    setLogs([]);\n    setProgress({ current: 0, total: domainsToOptimize.length, currentDomain: \"\" });\n    setShowModal(true);\n\n    addLog(\n      `Starting optimization of ${domainsToOptimize.length} domain(s) using ${ALGORITHMS[algorithm].name}`,\n      \"info\"\n    );\n    addLog(\"Running in browser (no server required)\", \"info\");\n\n    const newResults = [];\n\n    for (let i = 0; i < domainsToOptimize.length; i++) {\n      const domain = domainsToOptimize[i];\n      setProgress({ current: i + 1, total: domainsToOptimize.length, currentDomain: domain.id });\n      addLog(`[${i + 1}/${domainsToOptimize.length}] Optimizing ${domain.id}...`, \"info\");\n\n      try {\n        // Get all sibling domains for separation metric\n        const siblingDomains = allDomains.filter((d) => d.id !== domain.id);\n\n        // Progress callback for real-time updates\n        const onProgress = (message) => {\n          addLog(`  ${message}`, \"info\");\n        };\n\n        // Run optimizer directly in browser\n        const optimizationResult = await runOptimizer(\n          domain,\n          validationSettings,\n          fitnessWeights,\n          {\n            algorithm,\n            ...algorithmParams,\n          },\n          siblingDomains,\n          onProgress\n        );\n\n        const result = {\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          initialFitness: optimizationResult.initialFitness,\n          finalFitness: optimizationResult.finalFitness,\n          improvement: optimizationResult.improvement,\n          initialConfig: optimizationResult.initialConfig || domain,\n          optimizedConfig: optimizationResult.optimizedConfig,\n          success: true,\n        };\n        newResults.push(result);\n        addLog(\n          `  ${domain.id}: ${(result.initialFitness || 0).toFixed(3)} -> ${(result.finalFitness || 0).toFixed(3)} (+${((result.improvement || 0) * 100).toFixed(1)}%)`,\n          \"success\"\n        );\n      } catch (error) {\n        newResults.push({\n          domainId: domain.id,\n          cultureId: domain.cultureId,\n          error: error.message,\n          success: false,\n        });\n        addLog(`  ${domain.id}: Error - ${error.message}`, \"error\");\n      }\n    }\n\n    setResults(newResults);\n    setOptimizing(false);\n    setProgress({ current: 0, total: 0, currentDomain: \"\" });\n\n    const successCount = newResults.filter((r) => r.success).length;\n    addLog(\n      `Optimization complete: ${successCount}/${domainsToOptimize.length} succeeded`,\n      successCount === domainsToOptimize.length ? \"success\" : \"warning\"\n    );\n  };\n\n  // Save results to local storage (IndexedDB)\n  const handleSaveResults = async () => {\n    const successfulResults = results.filter((r) => r.success);\n    if (successfulResults.length === 0) {\n      addLog(\"No successful results to save\", \"error\");\n      return;\n    }\n\n    if (!onCulturesChange) {\n      addLog(\"Cannot save: no storage handler provided\", \"error\");\n      return;\n    }\n\n    addLog(`Saving ${successfulResults.length} optimized domain(s) to browser storage...`, \"info\");\n\n    // Group by culture\n    const byCulture = {};\n    successfulResults.forEach((r) => {\n      if (!byCulture[r.cultureId]) {\n        byCulture[r.cultureId] = [];\n      }\n      byCulture[r.cultureId].push(r);\n    });\n\n    // Build updated cultures object\n    const updatedCultures = { ...cultures };\n\n    for (const [cultureId, cultureResults] of Object.entries(byCulture)) {\n      const culture = cultures[cultureId];\n      const naming = culture?.naming || {};\n      if (!naming.domains) continue;\n\n      // Replace optimized domains\n      const updatedDomains = naming.domains.map((domain) => {\n        const optimized = cultureResults.find((r) => r.domainId === domain.id);\n        return optimized ? optimized.optimizedConfig : domain;\n      });\n\n      updatedCultures[cultureId] = {\n        ...culture,\n        naming: {\n          ...naming,\n          domains: updatedDomains,\n        },\n      };\n\n      addLog(`  Updated ${cultureResults.length} domain(s) in ${cultureId}`, \"success\");\n    }\n\n    // Save via callback\n    try {\n      await onCulturesChange(updatedCultures);\n      addLog(\"Save complete (stored in browser)\", \"success\");\n    } catch (error) {\n      addLog(`Save failed: ${error.message}`, \"error\");\n    }\n  };\n\n  // Group domains by culture\n  const domainsByCulture = useMemo(() => {\n    const grouped = {};\n    allDomains.forEach((domain) => {\n      if (!grouped[domain.cultureId]) {\n        grouped[domain.cultureId] = {\n          name: domain.cultureName,\n          domains: [],\n        };\n      }\n      grouped[domain.cultureId].domains.push(domain);\n    });\n    return grouped;\n  }, [allDomains]);\n\n  return (\n    <div className=\"optimizer-container\">\n      {/* Left Panel - Domain Selection */}\n      <DomainSelector\n        domainsByCulture={domainsByCulture}\n        allDomains={allDomains}\n        selectedDomains={selectedDomains}\n        expandedCultures={expandedCultures}\n        onToggleDomain={toggleDomain}\n        onToggleCulture={toggleCulture}\n        onToggleAllInCulture={toggleAllInCulture}\n        onSelectAll={selectAll}\n        onDeselectAll={deselectAll}\n      />\n\n      {/* Right Panel - Settings & Results */}\n      <OptimizerSettings\n        algorithm={algorithm}\n        onAlgorithmChange={setAlgorithm}\n        algorithmParams={algorithmParams}\n        onAlgorithmParamsChange={setAlgorithmParams}\n// ... (truncated)", "parameters": [{"name": "{ cultures, onCulturesChange }", "type": "{ cultures: any; onCulturesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/optimizer/ResultsModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/optimizer/ResultsModal.jsx", "sourceCode": "/**\n * ResultsModal - Modal showing optimization progress and results\n */\nexport default function ResultsModal({\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}) {\n  const [expandedResults, setExpandedResults] = useState(new Set());\n  const toggleExpand = domainId => {\n    setExpandedResults(prev => {\n      const next = new Set(prev);\n      if (next.has(domainId)) {\n        next.delete(domainId);\n      } else {\n        next.add(domainId);\n      }\n      return next;\n    });\n  };\n  if (!show) return null;\n  return <div className=\"optimizer-modal-overlay\" onClick={e => {\n    if (e.target === e.currentTarget && !optimizing) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"optimizer-modal\">\n        {/* Modal Header */}\n        <div className=\"optimizer-modal-header\">\n          <h2 className=\"mt-0 mb-0\">\n            {optimizing ? \"Optimization in Progress...\" : \"Optimization Results\"}\n          </h2>\n          {!optimizing && <button onClick={onClose} className=\"modal-close-btn\">\n              \u00d7\n            </button>}\n        </div>\n\n        {/* Progress Bar (during optimization) */}\n        {optimizing && <div className=\"optimizer-progress-section\">\n            <div className=\"flex justify-between mb-sm\">\n              <span className=\"text-small\">\n                Processing: <strong>{progress.currentDomain}</strong>\n              </span>\n              <span className=\"text-small text-muted\">\n                {progress.current} / {progress.total}\n              </span>\n            </div>\n            <div className=\"progress-bar-track\">\n              <div className=\"progress-bar-fill rm-progress-bar-fill\" style={{\n            '--rm-progress-width': `${progress.total > 0 ? progress.current / progress.total * 100 : 0}%`\n          }} />\n            </div>\n          </div>}\n\n        {/* Modal Body - Log and Results */}\n        <div className=\"optimizer-modal-body\">\n          {/* Log Section */}\n          <div className=\"optimizer-log-section\">\n            <h3 className=\"section-title mt-0\">Optimization Log</h3>\n            <div className=\"optimizer-log\">\n              {logs.map((log, i) => <div key={i} className={`log-entry ${log.type}`}>\n                  {log.message}\n                </div>)}\n              {logs.length === 0 && <div className=\"text-muted italic\">Waiting for optimization to start...</div>}\n            </div>\n\n            {/* Results Table */}\n            {results.length > 0 && <div className=\"mt-lg\">\n                <h3 className=\"section-title mt-0\">Results Summary</h3>\n                <div className=\"results-table-container\">\n                  <table className=\"results-table\">\n                    <thead>\n                      <tr>\n                        <th className=\"col-expand\"></th>\n                        <th>Domain</th>\n                        <th className=\"text-right\">Initial</th>\n                        <th className=\"text-right\">Final</th>\n                        <th className=\"text-right\">Improvement</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {results.map((result, i) => <ResultRow key={result.domainId} result={result} index={i} isExpanded={expandedResults.has(result.domainId)} onToggle={toggleExpand} />)}\n                    </tbody>\n                  </table>\n                </div>\n              </div>}\n          </div>\n        </div>\n\n        {/* Modal Footer */}\n        <div className=\"optimizer-modal-footer\">\n          {results.length > 0 && results.some(r => r.success) && !optimizing && <button onClick={onSaveResults} className=\"optimize-button\">\n              Save Results\n            </button>}\n          <button onClick={onClose} disabled={optimizing} className={`secondary optimize-action-button ${optimizing ? \"disabled\" : \"\"}`}>\n            {optimizing ? \"Running...\" : \"Close\"}\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  show,\n  onClose,\n  optimizing,\n  progress,\n  logs,\n  results,\n  onSaveResults\n}", "type": "{ show: any; onClose: any; optimizing: any; progress: any; logs: any; results: any; onSaveResults: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "apps/name-forge/webui/src/components/shared/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "apps/name-forge/webui/src/components/shared/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any"}, {"id": "apps/name-forge/webui/src/components/sidebar/CultureSidebar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/sidebar/CultureSidebar.jsx", "sourceCode": "function CultureSidebar({\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}) {\n  const [creatingCulture, setCreatingCulture] = useState(false);\n  const [newCultureId, setNewCultureId] = useState(\"\");\n  const [newCultureName, setNewCultureName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const handleCreateCulture = () => {\n    if (!newCultureId.trim()) {\n      setError(\"Culture ID is required\");\n      return;\n    }\n    if (!/^[a-z0-9_]+$/.test(newCultureId)) {\n      setError(\"Culture ID must be lowercase letters, numbers, and underscores only (no hyphens)\");\n      return;\n    }\n    if (cultures[newCultureId]) {\n      setError(\"Culture ID already exists\");\n      return;\n    }\n    const cultureName = newCultureName || newCultureId;\n\n    // Create new culture with culture-level resources\n    const newCulture = {\n      id: newCultureId,\n      name: cultureName,\n      naming: {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: []\n      }\n    };\n    const updatedCultures = {\n      ...cultures,\n      [newCultureId]: newCulture\n    };\n    onCulturesChange(updatedCultures);\n\n    // Select the new culture\n    onSelectCulture(newCultureId);\n\n    // Reset form\n    setNewCultureId(\"\");\n    setNewCultureName(\"\");\n    setCreatingCulture(false);\n    setError(null);\n  };\n\n  // Get resource counts for a culture\n  const getResourceCounts = culture => {\n    const naming = culture?.naming || {};\n    return {\n      domains: naming.domains?.length || 0,\n      lexemes: Object.keys(naming.lexemeLists || {}).length,\n      grammars: naming.grammars?.length || 0,\n      profiles: naming.profiles?.length || 0\n    };\n  };\n\n  // Calculate completion based on having at least one of each resource\n  const calculateCompletion = culture => {\n    const counts = getResourceCounts(culture);\n    let completed = 0;\n    if (counts.domains > 0) completed++;\n    if (counts.lexemes > 0) completed++;\n    if (counts.grammars > 0) completed++;\n    if (counts.profiles > 0) completed++;\n    return Math.round(completed / 4 * 100);\n  };\n  return <div className=\"culture-sidebar\">\n      <div className=\"culture-sidebar-header\">\n        <div className=\"culture-sidebar-header-row\">\n          <h4>Cultures</h4>\n          {!readOnly && !creatingCulture && <button className=\"primary sm\" onClick={() => setCreatingCulture(true)}>\n              + New\n            </button>}\n        </div>\n\n        {creatingCulture && <div className=\"culture-form\">\n            <div className=\"form-group\">\n              <label htmlFor=\"culture-id\">Culture ID</label>\n              <input id=\"culture-id\" type=\"text\" value={newCultureId} onChange={e => setNewCultureId(e.target.value)} placeholder=\"elven\" />\n            </div>\n            <div className=\"form-group\">\n              <label htmlFor=\"display-name\">Display Name</label>\n              <input id=\"display-name\" type=\"text\" value={newCultureName} onChange={e => setNewCultureName(e.target.value)} placeholder=\"Elven\" />\n            </div>\n\n            {error && <div className=\"error\">{error}</div>}\n\n            <div className=\"culture-form-buttons\">\n              <button className=\"primary\" onClick={handleCreateCulture}>\n                Create\n              </button>\n              <button className=\"secondary\" onClick={() => {\n            setCreatingCulture(false);\n            setError(null);\n            setNewCultureId(\"\");\n            setNewCultureName(\"\");\n          }}>\n                Cancel\n              </button>\n            </div>\n          </div>}\n      </div>\n\n      <div className=\"culture-list\">\n        {Object.keys(cultures).length === 0 ? <div className=\"culture-list-empty\">No cultures yet. Create one to get started.</div> : Object.values(cultures).map(culture => {\n        const completion = calculateCompletion(culture);\n        const counts = getResourceCounts(culture);\n        const isSelected = selectedCulture === culture.id;\n        return <div key={culture.id} onClick={() => onSelectCulture(culture.id)} className={`culture-card ${isSelected ? \"selected\" : \"\"}`} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n                <div className=\"culture-card-content\">\n                  <div className=\"culture-card-name\">{culture.name || culture.id}</div>\n\n                  {/* Resource counts */}\n                  <div className=\"culture-resource-grid\">\n                    <span className={`culture-resource-item ${counts.domains > 0 ? \"has-domains\" : \"\"}`}>\n                      {counts.domains} dom\n                    </span>\n                    <span className={`culture-resource-item ${counts.lexemes > 0 ? \"has-lexemes\" : \"\"}`}>\n                      {counts.lexemes} lex\n                    </span>\n                    <span className={`culture-resource-item ${counts.grammars > 0 ? \"has-grammars\" : \"\"}`}>\n                      {counts.grammars} gram\n                    </span>\n                    <span className={`culture-resource-item ${counts.profiles > 0 ? \"has-profiles\" : \"\"}`}>\n                      {counts.profiles} prof\n                    </span>\n                  </div>\n\n                  {/* Progress bar */}\n                  <div className=\"culture-progress-bar\">\n                    <div className={`culture-progress-fill csb-progress-fill ${completion === 100 ? \"complete\" : \"\"}`} style={{\n                '--csb-progress-width': `${completion}%`\n              }} />\n                  </div>\n                </div>\n              </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  selectedCulture,\n  onSelectCulture,\n  onCulturesChange,\n  readOnly = false\n}", "type": "{ cultures: any; selectedCulture: any; onSelectCulture: any; onCulturesChange: any; readOnly?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/EntityWorkspace.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/EntityWorkspace.jsx", "sourceCode": "function EntityWorkspace({\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}) {\n  const [error, setError] = useState(null);\n\n  // Use prop or fallback to local handling\n  const setActiveTab = onTabChange || (() => {});\n\n  if (!cultureId) {\n    return (\n      <div className=\"workspace-empty\">\n        <p className=\"text-muted\">Select a culture from the sidebar to begin</p>\n      </div>\n    );\n  }\n\n  // Handle domains change at culture level\n  const handleDomainsChange = (newDomains) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          domains: newDomains,\n        },\n      });\n    }\n  };\n\n  // Handle lexemes change at culture level\n  // Optional third param allows atomic update with grammars (for copy operations)\n  const handleLexemesChange = (newLexemeLists, newLexemeSpecs, newGrammars) => {\n    if (onCultureChange) {\n      const updates = {\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n        },\n      };\n      if (newLexemeLists !== undefined) updates.naming.lexemeLists = newLexemeLists;\n      if (newLexemeSpecs !== undefined) updates.naming.lexemeSpecs = newLexemeSpecs;\n      if (newGrammars !== undefined) updates.naming.grammars = newGrammars;\n      onCultureChange(updates);\n    }\n  };\n\n  // Handle grammars change at culture level\n  const handleGrammarsChange = (newGrammars) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          grammars: newGrammars,\n        },\n      });\n    }\n  };\n\n  // Handle profiles change at culture level\n  const handleProfilesChange = (newProfiles) => {\n    if (onCultureChange) {\n      onCultureChange({\n        ...cultureConfig,\n        naming: {\n          ...cultureConfig?.naming,\n          profiles: newProfiles,\n        },\n      });\n    }\n  };\n\n  const getCompletionBadge = (key) => {\n    const naming = cultureConfig?.naming || {};\n    // Compute counts from culture-level data\n    if (key === \"domain\") {\n      const count = naming.domains?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"lexemes\") {\n      const count = Object.keys(naming.lexemeLists || {}).length;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"grammars\") {\n      const count = naming.grammars?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    } else if (key === \"profiles\") {\n      const count = naming.profiles?.length || 0;\n      return count > 0 ? `(${count})` : \"\";\n    }\n\n    return \"\";\n  };\n\n  return (\n    <div className=\"workspace\">\n      {/* Header */}\n      <div className=\"workspace-header\">\n        <div className=\"workspace-header-row\">\n          <div>\n            <h3 className=\"workspace-title\">\n              <span className=\"workspace-title-name\">{cultureConfig?.name || cultureId}</span>\n              <span className=\"workspace-title-label\">Culture</span>\n            </h3>\n          </div>\n          <div className=\"workspace-autosave\">Auto-saved</div>\n        </div>\n\n        {error && (\n          <div className=\"error mt-sm\">\n            {error}\n            <button className=\"secondary ml-sm\" onClick={() => setError(null)}>\n              Dismiss\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"workspace-tabs\">\n        {[\"domain\", \"lexemes\", \"grammars\", \"profiles\"].map((tab) => (\n          <button\n            key={tab}\n            onClick={() => setActiveTab(tab)}\n            className={`workspace-tab ${activeTab === tab ? \"active\" : \"\"}`}\n          >\n            {tab} {getCompletionBadge(tab)}\n          </button>\n        ))}\n      </div>\n\n      {/* Content */}\n      <div className=\"workspace-content\">\n        {activeTab === \"domain\" && (\n          <DomainTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onDomainsChange={handleDomainsChange}\n          />\n        )}\n\n        {activeTab === \"lexemes\" && (\n          <LexemesTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onLexemesChange={handleLexemesChange}\n            apiKey={apiKey}\n          />\n        )}\n\n        {activeTab === \"grammars\" && (\n          <GrammarsTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            onGrammarsChange={handleGrammarsChange}\n            onLexemesChange={handleLexemesChange}\n          />\n        )}\n\n        {activeTab === \"profiles\" && (\n          <ProfileTab\n            key={cultureId}\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            onProfilesChange={handleProfilesChange}\n            worldSchema={worldSchema}\n            onAddTag={onAddTag}\n            generators={generators}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldSchema,\n  cultureId,\n  cultureConfig,\n  allCultures,\n  activeTab = \"domain\",\n  onTabChange,\n  onCultureChange,\n  onAddTag,\n  apiKey,\n  generators = [],\n}", "type": "{ worldSchema: any; cultureId: any; cultureConfig: any; allCultures: any; activeTab?: string; onTabChange: any; onCultureChange: any; onAddTag: any; apiKey: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/DomainTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/DomainTab.jsx", "sourceCode": "function DomainTab({ cultureId, cultureConfig, allCultures, onDomainsChange }) {\n  const [editing, setEditing] = useState(false);\n  const [editingIndex, setEditingIndex] = useState(-1); // -1 = new domain, >= 0 = editing existing\n  const [expandedSections, setExpandedSections] = useState({\n    phonology: true,\n    morphology: false,\n    style: false,\n    weights: false,\n  });\n\n  const cultureDomains = cultureConfig?.naming?.domains || [];\n\n  // Collect ALL domains from ALL cultures for \"copy from other cultures\" feature\n  const allDomains = getAllDomains(allCultures);\n\n  const defaultDomain = {\n    id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    cultureId: cultureId,\n    phonology: {\n      consonants: [],\n      vowels: [],\n      syllableTemplates: [\"CV\", \"CVC\"],\n      lengthRange: [2, 4],\n      favoredClusters: [],\n      forbiddenClusters: [],\n      favoredClusterBoost: 1.0,\n    },\n    morphology: {\n      prefixes: [],\n      suffixes: [],\n      structure: [\"root\", \"root-suffix\"],\n      structureWeights: [0.5, 0.5],\n    },\n    style: {\n      capitalization: \"title\",\n      apostropheRate: 0,\n      hyphenRate: 0,\n      preferredEndings: [],\n      preferredEndingBoost: 1.0,\n      rhythmBias: \"neutral\",\n    },\n  };\n\n  const [formData, setFormData] = useState(defaultDomain);\n\n  const toggleSection = (section) => {\n    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section] }));\n  };\n\n  // Save domain to culture-level domains array\n  const handleSave = () => {\n    let newDomains;\n    if (editingIndex >= 0) {\n      // Update existing domain\n      newDomains = [...cultureDomains];\n      newDomains[editingIndex] = formData;\n    } else {\n      // Add new domain\n      newDomains = [...cultureDomains, formData];\n    }\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n\n    setEditing(false);\n    setEditingIndex(-1);\n  };\n\n  const handleCreateNew = () => {\n    setFormData({\n      ...defaultDomain,\n      id: `${cultureId}_domain_${cultureDomains.length + 1}`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  const handleEditDomain = (domain, index) => {\n    setFormData({ ...domain });\n    setEditingIndex(index);\n    setEditing(true);\n  };\n\n  const handleDeleteDomain = (index) => {\n    if (!window.confirm(\"Delete this domain? This cannot be undone.\")) return;\n\n    const newDomains = cultureDomains.filter((_, i) => i !== index);\n\n    // Save via callback\n    if (onDomainsChange) {\n      onDomainsChange(newDomains);\n    }\n  };\n\n  const handleCopyDomain = (domain) => {\n    // Create a copy with new ID\n    setFormData({\n      ...domain,\n      id: `${domain.id}_copy`,\n    });\n    setEditingIndex(-1);\n    setEditing(true);\n  };\n\n  // View mode - show list of culture-level domains\n  if (!editing && cultureDomains.length > 0) {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Phonological Domains ({cultureDomains.length})</h3>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Add Domain\n          </button>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Domains define the sound patterns for <strong>{cultureId}</strong> names. Reference them\n          in grammars using <code>domain:domain_id</code>. Use the <strong>Optimizer</strong> tab to\n          tune domain parameters.\n        </p>\n\n        {/* Domain List */}\n        <div className=\"grid gap-md\">\n          {cultureDomains.map((domain, index) => (\n            <div key={domain.id} className=\"domain-card\">\n              <div className=\"domain-card-header\">\n                <div>\n                  <strong className=\"domain-card-title\">{domain.id}</strong>\n                  <div className=\"domain-card-hint\">\n                    Use in grammars: <code>domain:{domain.id}</code>\n                  </div>\n                </div>\n                <div className=\"domain-card-actions\">\n                  <button className=\"secondary icon-btn\" onClick={() => handleCopyDomain(domain)}>\n                    \ud83d\udccb\n                  </button>\n                  <button\n                    className=\"secondary icon-btn\"\n                    onClick={() => handleEditDomain(domain, index)}\n                  >\n                    \u270f\ufe0f\n                  </button>\n                  <button\n                    className=\"secondary icon-btn danger\"\n                    onClick={() => handleDeleteDomain(index)}\n                  >\n                    \ud83d\uddd1\ufe0f\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"domain-summary-grid\">\n                <div>\n                  <div>Phonology</div>\n                  <div>\n                    <div>\n                      C: {domain.phonology?.consonants?.slice(0, 5).join(\" \") || \"None\"}\n                      {domain.phonology?.consonants?.length > 5 ? \"...\" : \"\"}\n                    </div>\n                    <div>V: {domain.phonology?.vowels?.join(\" \") || \"None\"}</div>\n                    <div>Syl: {domain.phonology?.syllableTemplates?.join(\", \") || \"CV, CVC\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Morphology</div>\n                  <div>\n                    <div>Pre: {domain.morphology?.prefixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                    <div>Suf: {domain.morphology?.suffixes?.slice(0, 3).join(\", \") || \"None\"}</div>\n                  </div>\n                </div>\n                <div>\n                  <div>Style</div>\n                  <div>\n                    <div>Cap: {domain.style?.capitalization || \"title\"}</div>\n                    <div>Rhythm: {domain.style?.rhythmBias || \"neutral\"}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  // No domains yet - show create prompt\n  if (!editing && cultureDomains.length === 0) {\n    return (\n      <div>\n        <h3>Phonological Domains</h3>\n        <p className=\"text-muted\">\n          Define the sound patterns and morphology for <strong>{cultureId}</strong> names.\n        </p>\n\n        <div className=\"empty-state-card\">\n          <p>No domains configured for this culture yet.</p>\n          <button className=\"primary\" onClick={handleCreateNew}>\n            + Create First Domain\n          </button>\n        </div>\n\n        {/* Show domains from other cultures as inspiration */}\n        {allDomains.filter((d) => d.sourceCulture !== cultureId).length > 0 && (\n          <div className=\"copy-from-section\">\n            <h4>Copy from other cultures</h4>\n            <div className=\"grid gap-sm\">\n              {allDomains\n                .filter((d) => d.sourceCulture !== cultureId)\n                .slice(0, 5)\n                .map((domain) => (\n                  <div key={`${domain.sourceCulture}_${domain.id}`} className=\"copy-item\">\n                    <div>\n                      <strong>{domain.id}</strong>\n                      <div className=\"copy-item-meta\">From culture: {domain.sourceCulture}</div>\n                    </div>\n                    <button className=\"secondary sm\" onClick={() => handleCopyDomain(domain)}>\n                      Copy & Edit\n                    </button>\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Editing mode - full form\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3>{editingIndex >= 0 ? \"Edit Domain\" : \"Create Domain\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setEditing(false);\n              setEditingIndex(-1);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group mb-md\">\n        <label htmlFor=\"domain-id\">Domain ID</label>\n        <input id=\"domain-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_domain`}\n        />\n        <small className=\"text-muted\">\n          Unique identifier for this domain. Use in grammars as{\" \"}\n          <code>domain:{formData.id || \"domain_id\"}</code>\n        </small>\n      </div>\n\n      {/* Phonology Section */}\n      <div className=\"collapsible-section\">\n        <div className=\"collapsible-header\" onClick={() => toggleSection(\"phonology\")} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n          <h4>Phonology</h4>\n          <span>{expandedSections.phonology ? \"\u25bc\" : \"\u25b6\"}</span>\n        </div>\n        {expandedSections.phonology && (\n          <div className=\"collapsible-content\">\n            <div className=\"form-grid-2\">\n              <div className=\"form-group\">\n                <label htmlFor=\"consonants-space-separated\">Consonants (space-separated)</label>\n                <input id=\"consonants-space-separated\"\n                  defaultValue={formData.phonology?.consonants?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        consonants: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n                  }\n                  placeholder=\"l r th f n m v s\"\n                />\n              </div>\n              <div className=\"form-group\">\n                <label htmlFor=\"vowels-space-separated\">Vowels (space-separated)</label>\n                <input id=\"vowels-space-separated\"\n                  defaultValue={formData.phonology?.vowels?.join(\" \") || \"\"}\n                  onBlur={(e) =>\n                    setFormData({\n                      ...formData,\n                      phonology: {\n                        ...formData.phonology,\n                        vowels: e.target.value.split(/\\s+/).filter((s) => s),\n                      },\n                    })\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, allCultures, onDomainsChange }", "type": "{ cultureId: any; cultureConfig: any; allCultures: any; onDomainsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/GrammarsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/GrammarsTab.jsx", "sourceCode": "function GrammarsTab({ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }) {\n  const [mode, setMode] = useState(\"view\");\n  const [editingGrammar, setEditingGrammar] = useState(null);\n  const [showHelp, setShowHelp] = useState(false);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n  const [formData, setFormData] = useState({\n    id: `${cultureId}_grammar`,\n    start: \"name\",\n    capitalization: \"\",\n    rules: {},\n  });\n  const [newRuleKey, setNewRuleKey] = useState(\"\");\n  const [newRuleValue, setNewRuleValue] = useState(\"\");\n  const [editingRuleKey, setEditingRuleKey] = useState(null); // Track which rule is being edited\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedFormDataRef = useRef(null);\n  const lastSavedIdRef = useRef(null);\n\n  const naming = cultureConfig?.naming || {};\n  const grammars = naming.grammars || [];\n  const lexemeLists = naming.lexemeLists || {};\n  const domains = naming.domains || [];\n\n  // Autosave effect\n  useEffect(() => {\n    if (mode !== \"edit\" || !editingGrammar) return;\n\n    const formDataStr = JSON.stringify(formData);\n    if (formDataStr === lastSavedFormDataRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      performAutosave(formData, editingGrammar, grammars, onGrammarsChange, lastSavedIdRef, lastSavedFormDataRef, formDataStr);\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [formData, mode, editingGrammar]);\n\n  useEffect(() => {\n    if (mode === \"view\") {\n      lastSavedFormDataRef.current = null;\n      lastSavedIdRef.current = null;\n    }\n  }, [mode]);\n\n  const handleAddRule = () => {\n    if (!newRuleKey.trim() || !newRuleValue.trim()) return;\n\n    const newProductions = newRuleValue\n      .split(\"|\")\n      .map((p) =>\n        p\n          .trim()\n          .split(/\\s+/)\n          .filter((s) => s)\n      )\n      .filter((p) => p.length > 0);\n\n    if (editingRuleKey) {\n      // Update mode: replace the rule entirely\n      const newRules = { ...formData.rules };\n      // If key changed, delete the old one\n      if (editingRuleKey !== newRuleKey) {\n        delete newRules[editingRuleKey];\n      }\n      newRules[newRuleKey] = newProductions;\n      setFormData({ ...formData, rules: newRules });\n      setEditingRuleKey(null);\n    } else {\n      // Add mode: merge with existing productions\n      const existingProductions = formData.rules[newRuleKey] || [];\n      const mergedProductions = [...existingProductions, ...newProductions];\n      setFormData({\n        ...formData,\n        rules: {\n          ...formData.rules,\n          [newRuleKey]: mergedProductions,\n        },\n      });\n    }\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n  };\n\n  const handleEditRule = (key) => {\n    const productions = formData.rules[key] || [];\n    // Convert productions back to string format: \"prod1 | prod2 | prod3\"\n    const valueStr = productions.map((p) => p.join(\" \")).join(\" | \");\n    setNewRuleKey(key);\n    setNewRuleValue(valueStr);\n    setEditingRuleKey(key);\n  };\n\n  const handleCancelEdit = () => {\n    setNewRuleKey(\"\");\n    setNewRuleValue(\"\");\n    setEditingRuleKey(null);\n  };\n\n  const handleDeleteRule = (key) => {\n    const newRules = { ...formData.rules };\n    delete newRules[key];\n    setFormData({ ...formData, rules: newRules });\n  };\n\n  const handleSave = () => {\n    if (!formData.id.trim()) return;\n\n    // Same logic as autosave: track all IDs that should be replaced\n    const idsToRemove = new Set([formData.id]);\n    if (lastSavedIdRef.current) {\n      idsToRemove.add(lastSavedIdRef.current);\n    }\n    if (editingGrammar !== \"new\") {\n      idsToRemove.add(editingGrammar);\n    }\n\n    const newGrammars = [...grammars.filter((g) => !idsToRemove.has(g.id)), formData];\n\n    onGrammarsChange(newGrammars);\n    setMode(\"view\");\n    setEditingGrammar(null);\n  };\n\n  const handleDelete = (id) => {\n    const newGrammars = grammars.filter((g) => g.id !== id);\n    onGrammarsChange(newGrammars);\n  };\n\n  const handleEdit = (grammar) => {\n    setEditingGrammar(grammar.id);\n    setFormData(grammar);\n    setMode(\"edit\");\n  };\n\n  const handleAddNew = () => {\n    setEditingGrammar(\"new\");\n    setFormData({\n      id: `${cultureId}_grammar`,\n      start: \"name\",\n      capitalization: \"\",\n      rules: {},\n    });\n    setMode(\"edit\");\n  };\n\n  const insertIntoRule = (text) => {\n    setNewRuleValue((prev) => (prev ? `${prev} ${text}` : text));\n  };\n\n  // Get available lexeme lists\n  const availableLexemeLists = Object.keys(lexemeLists).map((id) => ({ id, source: \"local\" }));\n\n  // View mode\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3 className=\"mt-0\">Context-Free Grammars</h3>\n          <div className=\"flex gap-sm\">\n            <button className=\"secondary\" onClick={() => setShowHelp(true)}>\n              ? Help\n            </button>\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={handleAddNew}>\n              + New Grammar\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted mb-md\">\n          Grammars define structured name patterns shared across all entity types in this culture.\n          Use <code>slot:lexeme_id</code> to reference lexeme lists.\n        </p>\n\n        {grammars.length === 0 ? (\n          <div className=\"empty-state-card\">\n            <p className=\"mt-0 mb-0\">No grammars yet.</p>\n            <p className=\"text-muted mt-sm mb-0\">\n              Create lexeme lists first, then define grammars to structure names.\n            </p>\n          </div>\n        ) : (\n          <div className=\"grid gap-sm\">\n            {grammars.map((grammar) => (\n              <div key={grammar.id} className=\"grammar-card\">\n                <div className=\"flex justify-between align-start\">\n                  <div>\n                    <strong>{grammar.id}</strong>\n                    <div className=\"text-small text-muted mt-xs\">\n                      Start: <code>{grammar.start}</code> \u2022{\" \"}\n                      {Object.keys(grammar.rules || {}).length} rules\n                      {grammar.capitalization && (\n                        <>\n                          {\" \"}\n                          \u2022 Case: <code>{grammar.capitalization}</code>\n                        </>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex gap-sm\">\n                    <button className=\"secondary text-small\" onClick={() => handleEdit(grammar)}>\n                      Edit\n                    </button>\n                    <button className=\"danger text-small\" onClick={() => handleDelete(grammar.id)}>\n                      Delete\n                    </button>\n                  </div>\n                </div>\n                <GrammarPreview grammar={grammar} domains={domains} lexemeLists={lexemeLists} />\n              </div>\n            ))}\n          </div>\n        )}\n\n        {showHelp && <GrammarHelpModal onClose={() => setShowHelp(false)} />}\n        {showCopyModal && (\n          <CopyGrammarModal\n            cultureId={cultureId}\n            cultureConfig={cultureConfig}\n            allCultures={allCultures}\n            existingGrammarIds={grammars.map((g) => g.id)}\n            onCopy={(copiedGrammar, copiedLexemeLists) => {\n              const newGrammars = [...grammars, copiedGrammar];\n              // If copying lexeme lists, do atomic update with grammar\n              if (\n                copiedLexemeLists &&\n                Object.keys(copiedLexemeLists).length > 0 &&\n                onLexemesChange\n              ) {\n                const updatedLists = { ...lexemeLists, ...copiedLexemeLists };\n                onLexemesChange(updatedLists, undefined, newGrammars);\n              } else {\n                onGrammarsChange(newGrammars);\n              }\n              setShowCopyModal(false);\n            }}\n            onClose={() => setShowCopyModal(false)}\n          />\n        )}\n      </div>\n    );\n  }\n\n  // Edit mode\n  return (\n    <div>\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">{editingGrammar === \"new\" ? \"New Grammar\" : \"Edit Grammar\"}</h3>\n        <div className=\"flex gap-sm\">\n          <button className=\"primary\" onClick={handleSave}>\n            Save\n          </button>\n          <button\n            className=\"secondary\"\n            onClick={() => {\n              setMode(\"view\");\n              setEditingGrammar(null);\n            }}\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"grammar-id\">Grammar ID</label>\n        <input id=\"grammar-id\"\n          value={formData.id}\n          onChange={(e) => setFormData({ ...formData, id: e.target.value })}\n          placeholder={`${cultureId}_grammar`}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"start-symbol\">Start Symbol</label>\n        <input id=\"start-symbol\"\n          value={formData.start}\n          onChange={(e) => setFormData({ ...formData, start: e.target.value })}\n          placeholder=\"e.g., name, phrase, title\"\n        />\n        <small className=\"text-muted\">The entry point for name generation</small>\n      </div>\n\n      <div className=\"form-group\">\n        <label htmlFor=\"capitalization\">Capitalization</label>\n        <select id=\"capitalization\"\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onGrammarsChange, onLexemesChange, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onGrammarsChange: any; onLexemesChange: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/LexemesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/LexemesTab.jsx", "sourceCode": "function LexemesTab({ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }) {\n  const [mode, setMode] = useState(\"view\"); // 'view', 'create-spec', 'edit-spec', 'create-manual', 'edit-list'\n  const [selectedList, setSelectedList] = useState(null);\n  const [, setEditingListId] = useState(null);\n  const [, setEditingSpecId] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [showCopyModal, setShowCopyModal] = useState(false);\n\n  // Form state for spec creation\n  const [specForm, setSpecForm] = useState({\n    id: `${cultureId}_nouns`,\n    pos: \"noun\",\n    style: \"\",\n    wordStylePreset: \"none\",\n    wordStyle: null,\n    targetCount: 30,\n    maxWords: 1,\n    qualityFilter: { minLength: 3, maxLength: 15 },\n  });\n\n  // Form state for manual/edit list\n  const [listForm, setListForm] = useState({\n    id: \"\",\n    description: \"\",\n    entries: \"\",\n    source: \"manual\",\n  });\n\n  // Get culture-level lexeme data\n  const naming = cultureConfig?.naming || {};\n  const lexemeLists = naming.lexemeLists || {};\n  const lexemeSpecs = naming.lexemeSpecs || [];\n\n  const handleSaveSpec = () => {\n    const newSpec = {\n      ...specForm,\n      cultureId,\n    };\n    // Don't save preset key to spec, just the wordStyle object\n    delete newSpec.wordStylePreset;\n\n    const updatedSpecs = [...lexemeSpecs.filter((s) => s.id !== newSpec.id), newSpec];\n    onLexemesChange(undefined, updatedSpecs);\n    setMode(\"view\");\n    setEditingSpecId(null);\n    setSpecForm({\n      id: `${cultureId}_nouns`,\n      pos: \"noun\",\n      style: \"\",\n      wordStylePreset: \"none\",\n      wordStyle: null,\n      targetCount: 30,\n      maxWords: 1,\n      qualityFilter: { minLength: 3, maxLength: 15 },\n    });\n  };\n\n  const handleEditSpec = (spec) => {\n    // Try to match wordStyle to a preset\n    let matchedPreset = \"none\";\n    if (spec.wordStyle) {\n      for (const [key, preset] of Object.entries(WORD_STYLE_PRESETS)) {\n        if (\n          preset.wordStyle &&\n          JSON.stringify(preset.wordStyle) === JSON.stringify(spec.wordStyle)\n        ) {\n          matchedPreset = key;\n          break;\n        }\n      }\n      if (matchedPreset === \"none\") {\n        matchedPreset = \"custom\"; // Has wordStyle but doesn't match any preset\n      }\n    }\n\n    setSpecForm({\n      id: spec.id,\n      pos: spec.pos || \"noun\",\n      style: spec.style || \"\",\n      wordStylePreset: matchedPreset,\n      wordStyle: spec.wordStyle || null,\n      targetCount: spec.targetCount || 30,\n      maxWords: spec.maxWords || 1,\n      qualityFilter: spec.qualityFilter || { minLength: 3, maxLength: 15 },\n    });\n    setEditingSpecId(spec.id);\n    setMode(\"edit-spec\");\n  };\n\n  const handleDeleteSpec = (specId) => {\n    const updatedSpecs = lexemeSpecs.filter((s) => s.id !== specId);\n    onLexemesChange(undefined, updatedSpecs);\n  };\n\n  const handleSaveList = () => {\n    if (!listForm.id.trim()) {\n      setError(\"Please enter a list ID\");\n      return;\n    }\n\n    const entries = listForm.entries\n      .split(/[\\n,]/)\n      .map((e) => e.trim())\n      .filter((e) => e);\n\n    if (entries.length === 0) {\n      setError(\"Please enter at least one entry\");\n      return;\n    }\n\n    const newList = {\n      id: listForm.id,\n      description:\n        listForm.description || (listForm.source === \"manual\" ? \"Manual list\" : \"Generated list\"),\n      entries: entries,\n      source: listForm.source,\n    };\n\n    const updatedLists = {\n      ...lexemeLists,\n      [listForm.id]: newList,\n    };\n\n    onLexemesChange(updatedLists, undefined);\n    setMode(\"view\");\n    setEditingListId(null);\n    setListForm({ id: \"\", description: \"\", entries: \"\", source: \"manual\" });\n    setError(null);\n  };\n\n  const handleEditList = (listId) => {\n    const list = lexemeLists[listId];\n    if (list) {\n      setListForm({\n        id: list.id,\n        description: list.description || \"\",\n        entries: list.entries?.join(\"\\n\") || \"\",\n        source: list.source || \"manual\",\n      });\n      setEditingListId(listId);\n      setMode(\"edit-list\");\n    }\n  };\n\n  const handleCreateManual = () => {\n    setListForm({\n      id: `${cultureId}_manual`,\n      description: \"\",\n      entries: \"\",\n      source: \"manual\",\n    });\n    setEditingListId(null);\n    setMode(\"create-manual\");\n  };\n\n  const handleGenerate = async (spec) => {\n    if (!apiKey) {\n      setError(\n        'API key required. Click \"Set API Key\" in the header to enter your Anthropic API key.'\n      );\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const entries = await generateLexemesWithAnthropic(spec, apiKey);\n\n      const newList = {\n        id: spec.id,\n        description: `Generated ${spec.pos} list: ${spec.style || \"classic fantasy\"}`,\n        entries: entries,\n        source: \"llm\",\n      };\n\n      const updatedLists = {\n        ...lexemeLists,\n        [spec.id]: newList,\n      };\n\n      onLexemesChange(updatedLists, undefined);\n      setSelectedList(spec.id);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDeleteList = (listId) => {\n    const updatedLists = { ...lexemeLists };\n    delete updatedLists[listId];\n    onLexemesChange(updatedLists, undefined);\n    if (selectedList === listId) setSelectedList(null);\n  };\n\n  // View mode - show existing lists and specs\n  if (mode === \"view\") {\n    return (\n      <div>\n        <div className=\"tab-header\">\n          <h3>Lexeme Lists</h3>\n          <div className=\"flex gap-sm\">\n            {allCultures && Object.keys(allCultures).length > 1 && (\n              <button className=\"secondary\" onClick={() => setShowCopyModal(true)}>\n                Copy from...\n              </button>\n            )}\n            <button className=\"primary\" onClick={() => setMode(\"create-spec\")}>\n              + New Spec\n            </button>\n            <button className=\"secondary\" onClick={handleCreateManual}>\n              + Manual List\n            </button>\n          </div>\n        </div>\n\n        <p className=\"text-muted tab-intro\">\n          Lexeme lists are semantic building blocks shared across all entity types in this culture.\n          {!apiKey && (\n            <span className=\"api-key-warning\">\n              Set your API key in the header to enable LLM generation.\n            </span>\n          )}\n        </p>\n\n        {error && <div className=\"error mb-md\">{error}</div>}\n\n        {/* Lexeme Specs Section */}\n        {lexemeSpecs.length > 0 && (\n          <div className=\"mb-lg\">\n            <h4 className=\"mb-sm\">Generation Specs ({lexemeSpecs.length})</h4>\n            <div className=\"grid gap-sm\">\n              {lexemeSpecs.map((spec) => {\n                const hasGenerated = lexemeLists[spec.id];\n                const category = LEXEME_CATEGORIES[spec.pos];\n                return (\n                  <div key={spec.id} className=\"spec-card\">\n                    <div>\n                      <strong>{spec.id}</strong>\n                      {hasGenerated && (\n                        <span className=\"badge generated\">\n                          Generated ({lexemeLists[spec.id]?.entries?.length || 0})\n                        </span>\n                      )}\n                      {spec.wordStyle && (\n                        <span className=\"badge word-style\">\n                          {spec.wordStyle.etymology || \"mixed\"}\n                          {spec.wordStyle.syllables?.max === 1 && \" \u2022 mono\"}\n                        </span>\n                      )}\n                      <div className=\"spec-card-meta\">\n                        {category?.label || spec.pos} \u2022 {spec.targetCount} entries\n                        {spec.maxWords > 1 && ` \u2022 up to ${spec.maxWords} words each`}\n                        {spec.style &&\n                          ` \u2022 ${spec.style.substring(0, 40)}${spec.style.length > 40 ? \"...\" : \"\"}`}\n                      </div>\n                    </div>\n                    <div className=\"flex gap-sm\">\n                      {hasGenerated && (\n                        <button className=\"secondary sm\" onClick={() => setSelectedList(spec.id)}>\n                          View\n                        </button>\n                      )}\n                      <button className=\"secondary sm\" onClick={() => handleEditSpec(spec)}>\n                        Edit\n                      </button>\n                      <button\n                        className=\"primary sm\"\n                        onClick={() => handleGenerate(spec)}\n                        disabled={loading}\n                      >\n                        {(() => { if (loading) return \"...\"; if (hasGenerated) return \"Regenerate\"; return \"Generate\"; })()}\n                      </button>\n                      <button className=\"danger sm\" onClick={() => handleDeleteSpec(spec.id)}>\n                        Delete\n                      </button>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n\n        {/* Generated & Manual Lists Section */}\n        <div className=\"split-layout\">\n          <div className={`split-layout-main ${selectedList ? \"has-sidebar\" : \"\"}`}>\n            <h4 className=\"mb-sm\">Lexeme Lists ({Object.keys(lexemeLists).length})</h4>\n\n            {Object.keys(lexemeLists).length === 0 ? (\n              <div className=\"empty-state-card\">\n                <p>No lexeme lists yet.</p>\n                <p className=\"text-muted mt-sm\">\n                  Create a spec and generate via LLM, or add a manual list.\n                </p>\n              </div>\n            ) : (\n// ... (truncated)", "parameters": [{"name": "{ cultureId, cultureConfig, onLexemesChange, apiKey, allCultures }", "type": "{ cultureId: any; cultureConfig: any; onLexemesChange: any; apiKey: any; allCultures: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/PhonemeWeightGrid.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/PhonemeWeightGrid.jsx", "sourceCode": "/**\n * Visual grid editor for phoneme weights\n * Shows each phoneme with its corresponding weight and a visual bar\n */\n\nfunction PhonemeWeightGrid({\n  label,\n  items,\n  weights,\n  onChange,\n  minWeight = 0.1,\n  maxWeight = 3.0\n}) {\n  const [editingIndex, setEditingIndex] = useState(null);\n  const [editValue, setEditValue] = useState(\"\");\n\n  // Ensure weights array matches items length\n  const normalizedWeights = items.map((_, i) => weights?.[i] ?? 1.0);\n\n  // Calculate max for visual scaling\n  const maxVal = Math.max(...normalizedWeights, 1);\n  const handleCellClick = index => {\n    setEditingIndex(index);\n    setEditValue(normalizedWeights[index].toString());\n  };\n  const handleBlur = () => {\n    if (editingIndex !== null) {\n      const newValue = parseFloat(editValue);\n      if (!isNaN(newValue) && newValue >= minWeight && newValue <= maxWeight) {\n        const newWeights = [...normalizedWeights];\n        newWeights[editingIndex] = Math.round(newValue * 100) / 100;\n        onChange(newWeights);\n      }\n      setEditingIndex(null);\n    }\n  };\n  const handleKeyDown = e => {\n    if (e.key === \"Enter\") {\n      handleBlur();\n    } else if (e.key === \"Escape\") {\n      setEditingIndex(null);\n    }\n  };\n  const handleReset = () => {\n    onChange(items.map(() => 1.0));\n  };\n  if (items.length === 0) {\n    return <div className=\"weight-grid-section\">\n        <div className=\"weight-grid-header\">\n          <span className=\"weight-grid-label\">{label}</span>\n        </div>\n        <div className=\"weight-grid-empty\">\n          No items defined. Add {label.toLowerCase().replace(\" weights\", \"s\")} in Phonology section.\n        </div>\n      </div>;\n  }\n  return <div className=\"weight-grid-section\">\n      <div className=\"weight-grid-header\">\n        <span className=\"weight-grid-label\">{label}</span>\n        <button type=\"button\" className=\"weight-grid-reset\" onClick={handleReset} title=\"Reset all to 1.0\">\n          Reset\n        </button>\n      </div>\n      <div className=\"weight-grid\">\n        {items.map((item, index) => {\n        const weight = normalizedWeights[index];\n        const barHeight = weight / maxVal * 100;\n        const isEditing = editingIndex === index;\n\n        // Color based on weight: low=cool, normal=neutral, high=warm\n        let hue;\n        if (weight < 1) hue = 200;else if (weight > 1) hue = 30;else hue = 150;\n        const saturation = Math.abs(weight - 1) * 50 + 20;\n        return <div key={index} className={`weight-cell ${isEditing ? \"editing\" : \"\"}`} onClick={() => !isEditing && handleCellClick(index)} role=\"button\" tabIndex={0} onKeyDown={e => {\n          if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n        }}>\n              <div className=\"weight-cell-item\" title={item}>\n                {item}\n              </div>\n              {isEditing ? <input type=\"number\" className=\"weight-cell-input\" value={editValue} onChange={e => setEditValue(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} step=\"0.1\" min={minWeight} max={maxWeight}\n          // eslint-disable-next-line jsx-a11y/no-autofocus\n          autoFocus /> : <div className=\"weight-cell-value\">{weight.toFixed(1)}</div>}\n              <div className=\"weight-cell-bar-container\">\n                <div className=\"weight-cell-bar pwg-bar\" style={{\n              '--pwg-bar-height': `${barHeight}%`,\n              '--pwg-bar-color': `hsl(${hue}, ${saturation}%, 50%)`\n            }} />\n              </div>\n            </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  label,\n  items,\n  weights,\n  onChange,\n  minWeight = 0.1,\n  maxWeight = 3.0\n}", "type": "{ label: any; items: any; weights: any; onChange: any; minWeight?: number; maxWeight?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/ProfileTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/ProfileTab.jsx", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::findMatchingGenerators", "name": "findMatchingGenerators", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Analyze which generators will match a specific strategy group's conditions\n */\nexport function findMatchingGenerators(generators, cultureId, conditions) {\n  if (!generators || generators.length === 0) return [];\n\n  const matches = [];\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    const creations = gen.creation || [];\n    const genName = gen.name || gen.id;\n\n    for (const creation of creations) {\n      if (!creationMatchesCulture(creation, cultureId)) continue;\n\n      const match = matchCreationToConditions(creation, conditions, gen.id, genName);\n      if (match) matches.push(match);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "conditions", "type": "any", "optional": false}], "returnType": "{ generatorId: any; generatorName: any; entityKind: any; subtype: any; isDefault: boolean; }[]"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js::computeProfileGeneratorUsage", "name": "computeProfileGeneratorUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/index.js", "sourceCode": "/**\n * Compute generator usage for all profiles in a culture\n */\nexport function computeProfileGeneratorUsage(profiles, generators, cultureId) {\n  const usage = {};\n\n  for (const profile of profiles) {\n    usage[profile.id] = {\n      totalMatches: 0,\n      groups: {},\n    };\n\n    for (const group of profile.strategyGroups || []) {\n      const matches = findMatchingGenerators(generators, cultureId, group.conditions);\n      usage[profile.id].groups[group.name || \"Default\"] = matches;\n      usage[profile.id].totalMatches += matches.length;\n    }\n  }\n\n  return usage;\n}", "parameters": [{"name": "profiles", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}], "returnType": "{}"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/MultiSelectPills.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/MultiSelectPills.jsx", "sourceCode": "/**\n * Multi-select pills component for selecting multiple options\n * Note: Consider replacing with ChipSelect from shared-components in future\n */\nexport default function MultiSelectPills({ options, selected, onChange, allLabel = \"All\" }) {\n  const isAllSelected = selected.length === 0 || (selected.length === 1 && selected[0] === \"*\");\n\n  const handleToggle = (value) => {\n    if (value === \"*\") {\n      onChange([]);\n    } else {\n      const newSelected = selected.filter((s) => s !== \"*\");\n      if (newSelected.includes(value)) {\n        const filtered = newSelected.filter((s) => s !== value);\n        onChange(filtered.length === 0 ? [] : filtered);\n      } else {\n        onChange([...newSelected, value]);\n      }\n    }\n  };\n\n  return (\n    <div className=\"flex flex-wrap gap-xs\">\n      <button\n        type=\"button\"\n        onClick={() => handleToggle(\"*\")}\n        className={`pill-button ${isAllSelected ? \"selected-gold\" : \"\"}`}\n      >\n        {allLabel}\n      </button>\n      {options.map((opt) => {\n        const isSelected = !isAllSelected && selected.includes(opt);\n        return (\n          <button\n            key={opt}\n            type=\"button\"\n            onClick={() => handleToggle(opt)}\n            className={`pill-button ${isSelected ? \"selected-green\" : \"\"}`}\n          >\n            {opt}\n          </button>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ options, selected, onChange, allLabel = \"All\" }", "type": "{ options: any; selected: any; onChange: any; allLabel?: string; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileModal.jsx", "sourceCode": "export default function ProfileModal({\n  profile,\n  isNew,\n  onSave,\n  onClose,\n  onDelete,\n  onDuplicate,\n  cultureConfig,\n  worldSchema,\n  onAddTag,\n  generatorUsage,\n}) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n  const [editedProfile, setEditedProfile] = useState(null);\n\n  // Autosave refs\n  const autosaveTimeoutRef = useRef(null);\n  const lastSavedRef = useRef(null);\n\n  // Initialize edited profile\n  useEffect(() => {\n    if (profile) {\n      setEditedProfile(JSON.parse(JSON.stringify(profile)));\n      lastSavedRef.current = JSON.stringify(profile);\n    }\n  }, [profile]);\n\n  // Autosave effect\n  useEffect(() => {\n    if (!editedProfile) return;\n\n    const profileStr = JSON.stringify(editedProfile);\n    if (profileStr === lastSavedRef.current) return;\n\n    if (autosaveTimeoutRef.current) {\n      clearTimeout(autosaveTimeoutRef.current);\n    }\n\n    autosaveTimeoutRef.current = setTimeout(() => {\n      handleSave(editedProfile);\n      lastSavedRef.current = profileStr;\n    }, 1000);\n\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, [editedProfile]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (autosaveTimeoutRef.current) {\n        clearTimeout(autosaveTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Build dynamic tabs based on strategy groups\n  const tabs = useMemo(() => {\n    if (!editedProfile) return [];\n\n    const dynamicTabs = [{ id: \"overview\", label: \"Overview\", icon: \"\ud83d\udccb\" }];\n\n    // Add a tab for each strategy group\n    (editedProfile.strategyGroups || []).forEach((group, idx) => {\n      const isConditional = !!group.conditions;\n      dynamicTabs.push({\n        id: `group-${idx}`,\n        label: group.name || `Group ${idx + 1}`,\n        icon: isConditional ? \"\ud83c\udfaf\" : \"\ud83d\udce6\",\n      });\n    });\n\n    dynamicTabs.push({ id: \"test\", label: \"Test\", icon: \"\ud83e\uddea\" });\n\n    return dynamicTabs;\n  }, [editedProfile]);\n\n  const handleSave = (profileToSave) => {\n    // Normalize weights within each group\n    const normalizedGroups = (profileToSave.strategyGroups || []).map((group) => {\n      const totalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n      return {\n        ...group,\n        strategies: group.strategies.map((s) => ({\n          ...s,\n          weight:\n            totalWeight > 0 ? s.weight / totalWeight : 1 / Math.max(group.strategies.length, 1),\n        })),\n      };\n    });\n\n    const updatedProfile = {\n      ...profileToSave,\n      strategyGroups: normalizedGroups,\n    };\n\n    onSave(updatedProfile, isNew);\n  };\n\n  const handleClose = () => {\n    // Save any pending changes before closing\n    if (editedProfile && JSON.stringify(editedProfile) !== lastSavedRef.current) {\n      handleSave(editedProfile);\n    }\n    onClose();\n  };\n\n  const handleDelete = () => {\n    if (confirm(`Delete profile \"${editedProfile?.id}\"?`)) {\n      onDelete(editedProfile?.id);\n      onClose();\n    }\n  };\n\n  const handleDuplicate = () => {\n    // Save any pending changes first\n    if (editedProfile && JSON.stringify(editedProfile) !== lastSavedRef.current) {\n      handleSave(editedProfile);\n    }\n    onDuplicate(editedProfile);\n  };\n\n  const handleAddGroup = (withConditions = false) => {\n    const newGroup = {\n      name: withConditions ? \"Conditional\" : \"Default\",\n      priority: withConditions ? 50 : 0,\n      conditions: withConditions\n        ? {\n            entityKinds: [],\n            prominence: [],\n            subtypes: [],\n            subtypeMatchAll: false,\n            tags: [],\n            tagMatchAll: false,\n          }\n        : null,\n      strategies: [],\n    };\n    const updated = {\n      ...editedProfile,\n      strategyGroups: [...(editedProfile.strategyGroups || []), newGroup],\n    };\n    setEditedProfile(updated);\n    // Switch to the new group's tab\n    setActiveTab(`group-${updated.strategyGroups.length - 1}`);\n  };\n\n  const handleDeleteGroup = (groupIdx) => {\n    const updated = {\n      ...editedProfile,\n      strategyGroups: editedProfile.strategyGroups.filter((_, i) => i !== groupIdx),\n    };\n    setEditedProfile(updated);\n    // Switch to overview if we deleted the current tab\n    if (activeTab === `group-${groupIdx}`) {\n      setActiveTab(\"overview\");\n    }\n  };\n\n  const handleGroupChange = (groupIdx, updatedGroup) => {\n    const groups = [...editedProfile.strategyGroups];\n    groups[groupIdx] = updatedGroup;\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  if (!editedProfile) return null;\n\n  const naming = cultureConfig?.naming || {};\n  const domains = naming.domains || [];\n  const grammars = naming.grammars || [];\n  const entityKinds = worldSchema?.entityKinds?.map((e) => e.kind) || [];\n  const tagRegistry = worldSchema?.tagRegistry || [];\n\n  const renderTabContent = () => {\n    if (activeTab === \"overview\") {\n      return (\n        <OverviewTab\n          profile={editedProfile}\n          onChange={setEditedProfile}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          onNavigateToGroup={(idx) => setActiveTab(`group-${idx}`)}\n          generatorUsage={generatorUsage}\n          entityKinds={entityKinds}\n        />\n      );\n    }\n\n    if (activeTab === \"test\") {\n      return <TestTab profile={editedProfile} cultureConfig={cultureConfig} />;\n    }\n\n    // Check if it's a group tab\n    if (activeTab.startsWith(\"group-\")) {\n      const groupIdx = parseInt(activeTab.replace(\"group-\", \"\"), 10);\n      const group = editedProfile.strategyGroups?.[groupIdx];\n      if (group) {\n        return (\n          <SingleGroupTab\n            group={group}\n            groupIdx={groupIdx}\n            onChange={(updated) => handleGroupChange(groupIdx, updated)}\n            onDelete={() => handleDeleteGroup(groupIdx)}\n            domains={domains}\n            grammars={grammars}\n            entityKinds={entityKinds}\n            worldSchema={worldSchema}\n            tagRegistry={tagRegistry}\n            onAddTag={onAddTag}\n          />\n        );\n      }\n    }\n\n    return null;\n  };\n\n  // Sidebar footer with add group buttons\n  const renderSidebarFooter = () => (\n    <div className=\"profile-modal-footer\">\n      <button\n        className=\"add-group-btn\"\n        onClick={() => handleAddGroup(false)}\n        title=\"Add default group\"\n      >\n        + Default\n      </button>\n      <button\n        className=\"add-group-btn conditional\"\n        onClick={() => handleAddGroup(true)}\n        title=\"Add conditional group\"\n      >\n        + Conditional\n      </button>\n    </div>\n  );\n\n  return (\n    <ModalShell\n      onClose={handleClose}\n      icon=\"\ud83d\udcdd\"\n      title={isNew ? \"New Profile\" : editedProfile.id}\n      tabs={tabs}\n      activeTab={activeTab}\n      onTabChange={setActiveTab}\n      sidebarFooter={renderSidebarFooter()}\n      className=\"profile-modal\"\n    >\n      {renderTabContent()}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  isNew,\n  onSave,\n  onClose,\n  onDelete,\n  onDuplicate,\n  cultureConfig,\n  worldSchema,\n  onAddTag,\n  generatorUsage,\n}", "type": "{ profile: any; isNew: any; onSave: any; onClose: any; onDelete: any; onDuplicate: any; cultureConfig: any; worldSchema: any; onAddTag: any; generatorUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/ProfileTab.jsx", "sourceCode": "/**\n * ProfileTab - Profile list with modal editing\n */\nexport default function ProfileTab({\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}) {\n  const [editingProfile, setEditingProfile] = useState(null);\n  const [isNewProfile, setIsNewProfile] = useState(false);\n\n  const profiles = cultureConfig?.naming?.profiles || [];\n\n  // Compute generator usage for each profile\n  const generatorUsage = useMemo(\n    () => computeProfileGeneratorUsage(profiles, generators, cultureId),\n    [profiles, generators, cultureId]\n  );\n\n  const handleCreateProfile = () => {\n    const newProfile = {\n      id: `${cultureId}_profile_${profiles.length + 1}`,\n      strategyGroups: [\n        {\n          name: \"Default\",\n          priority: 0,\n          conditions: null,\n          strategies: [],\n        },\n      ],\n    };\n    setEditingProfile(newProfile);\n    setIsNewProfile(true);\n  };\n\n  const handleEditProfile = (profile) => {\n    setEditingProfile(profile);\n    setIsNewProfile(false);\n  };\n\n  const handleSaveProfile = (updatedProfile, isNew) => {\n    let newProfiles;\n    if (isNew) {\n      newProfiles = [...profiles.filter((p) => p.id !== updatedProfile.id), updatedProfile];\n    } else {\n      const existingIdx = profiles.findIndex((p) => p.id === editingProfile.id);\n      if (existingIdx >= 0) {\n        newProfiles = profiles.map((p, i) => (i === existingIdx ? updatedProfile : p));\n      } else {\n        newProfiles = [...profiles, updatedProfile];\n      }\n    }\n    onProfilesChange(newProfiles);\n    // Update local reference for continued editing\n    setEditingProfile(updatedProfile);\n  };\n\n  const handleDeleteProfile = (profileId) => {\n    const newProfiles = profiles.filter((p) => p.id !== profileId);\n    onProfilesChange(newProfiles);\n  };\n\n  const handleDuplicateProfile = (profile) => {\n    // Generate unique ID\n    let newId = `${profile.id}_copy`;\n    let counter = 1;\n    while (profiles.some((p) => p.id === newId)) {\n      newId = `${profile.id}_copy${counter++}`;\n    }\n\n    // Deep clone the profile with new ID\n    const duplicated = {\n      ...JSON.parse(JSON.stringify(profile)),\n      id: newId,\n      isDefault: false, // Don't copy default status\n    };\n\n    // Add to profiles and open for editing\n    onProfilesChange([...profiles, duplicated]);\n    setEditingProfile(duplicated);\n    setIsNewProfile(false);\n  };\n\n  const handleCloseModal = () => {\n    setEditingProfile(null);\n    setIsNewProfile(false);\n  };\n\n  // Count conditional groups in a profile\n  const countConditionalGroups = (profile) => {\n    return (profile.strategyGroups || []).filter((g) => g.conditions).length;\n  };\n\n  // Count total strategies in a profile\n  const countStrategies = (profile) => {\n    return (profile.strategyGroups || []).reduce((sum, g) => sum + (g.strategies?.length || 0), 0);\n  };\n\n  return (\n    <div className=\"profile-tab-container\">\n      <div className=\"tab-header\">\n        <h3 className=\"mt-0\">Naming Profiles</h3>\n        <button className=\"primary\" onClick={handleCreateProfile}>\n          + New Profile\n        </button>\n      </div>\n\n      <p className=\"text-muted mb-md\">\n        Profiles define how names are generated. Each profile contains strategy groups that can be\n        conditional (based on entity type, prominence, tags) or unconditional (default).\n      </p>\n\n      {profiles.length === 0 ? (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No profiles yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Create a profile to define how names are generated for this culture.\n          </p>\n        </div>\n      ) : (\n        <div className=\"profile-cards-grid\">\n          {profiles.map((profile) => {\n            const usage = generatorUsage[profile.id];\n            const matchCount = usage?.totalMatches || 0;\n            return (\n              <div\n                key={profile.id}\n                className=\"profile-card-item\"\n                onClick={() => handleEditProfile(profile)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"profile-card-header\">\n                  <strong className=\"profile-card-title\">{profile.id}</strong>\n                  <div className=\"profile-badges\">\n                    {profile.isDefault && <span className=\"profile-badge default\">Default</span>}\n                    {profile.entityKinds?.length > 0 && (\n                      <span className=\"profile-badge kinds\" title={profile.entityKinds.join(\", \")}>\n                        {profile.entityKinds.length} kind\n                        {profile.entityKinds.length !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                    {matchCount > 0 && (\n                      <span className=\"generator-match-pill\">\n                        {matchCount} generator{matchCount !== 1 ? \"s\" : \"\"}\n                      </span>\n                    )}\n                  </div>\n                </div>\n                <div className=\"profile-card-stats\">\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{profile.strategyGroups?.length || 0}</span>\n                    <span className=\"stat-label\">groups</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countStrategies(profile)}</span>\n                    <span className=\"stat-label\">strategies</span>\n                  </span>\n                  <span className=\"profile-stat\">\n                    <span className=\"stat-num\">{countConditionalGroups(profile)}</span>\n                    <span className=\"stat-label\">conditional</span>\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n\n      {/* Profile Editor Modal */}\n      {editingProfile && (\n        <ProfileModal\n          profile={editingProfile}\n          isNew={isNewProfile}\n          onSave={handleSaveProfile}\n          onClose={handleCloseModal}\n          onDelete={handleDeleteProfile}\n          onDuplicate={handleDuplicateProfile}\n          cultureConfig={cultureConfig}\n          worldSchema={worldSchema}\n          onAddTag={onAddTag}\n          generatorUsage={generatorUsage[editingProfile.id]}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  cultureId,\n  cultureConfig,\n  onProfilesChange,\n  worldSchema,\n  onAddTag,\n  generators = [],\n}", "type": "{ cultureId: any; cultureConfig: any; onProfilesChange: any; worldSchema: any; onAddTag: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/StrategyGroupEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/StrategyGroupEditor.jsx", "sourceCode": "/**\n * Strategy group editor component\n */\nexport default function StrategyGroupEditor({\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}) {\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n  const hasConditions = !!group.conditions;\n\n  const toggleConditions = () => {\n    const groups = [...editedProfile.strategyGroups];\n    if (hasConditions) {\n      groups[groupIdx] = { ...groups[groupIdx], conditions: null };\n    } else {\n      groups[groupIdx] = {\n        ...groups[groupIdx],\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      };\n    }\n    setEditedProfile({ ...editedProfile, strategyGroups: groups });\n  };\n\n  return (\n    <div className={`strategy-group ${hasConditions ? \"conditional\" : \"default\"}`}>\n      <div className=\"flex justify-between align-center mb-md\">\n        <div className=\"flex align-center gap-md\">\n          <input\n            value={group.name || \"\"}\n            onChange={(e) => {\n              const groups = [...editedProfile.strategyGroups];\n              groups[groupIdx] = { ...groups[groupIdx], name: e.target.value };\n              setEditedProfile({ ...editedProfile, strategyGroups: groups });\n            }}\n            placeholder=\"Group name\"\n            className=\"input-group-name\"\n          />\n          <div className=\"flex align-center gap-xs\">\n            <label className=\"text-xs text-muted\">Priority:\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => {\n                const groups = [...editedProfile.strategyGroups];\n                groups[groupIdx] = { ...groups[groupIdx], priority: v ?? 0 };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"input-priority\"\n              integer\n            />\n            </label>\n          </div>\n          <button className=\"secondary btn-xs\" onClick={toggleConditions}>\n            {hasConditions ? \"Remove Conditions\" : \"Add Conditions\"}\n          </button>\n        </div>\n        <button className=\"danger text-xs\" onClick={() => onDeleteGroup(groupIdx)}>\n          Delete Group\n        </button>\n      </div>\n\n      {/* Group Conditions */}\n      {hasConditions && (\n        <div className=\"conditions-panel\">\n          <div className=\"text-xs font-bold text-purple mb-md\">Group Conditions</div>\n\n          {/* Row 1: Entity Types and Prominence */}\n          <div className=\"form-grid-2 mb-md\">\n            {/* Entity Types */}\n            <div>\n              <label className=\"condition-label\">Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => onConditionChange(groupIdx, \"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            {/* Prominence */}\n            <div>\n              <label className=\"condition-label\">Prominence\n              <MultiSelectPills\n                options={prominenceLevels}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => onConditionChange(groupIdx, \"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n          </div>\n\n          {/* Row 2: Subtypes and Tags */}\n          <div className=\"form-grid-2\">\n            {/* Subtypes */}\n            <div>\n              <div className=\"flex justify-between align-center mb-xs\">\n                <span className=\"condition-label mb-0\">Subtypes</span>\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) =>\n                      onConditionChange(groupIdx, \"subtypeMatchAll\", e.target.checked)\n                    }\n                    className=\"checkbox-small\"\n                  />\n                  Match all\n                </label>\n              </div>\n              <TagsInput\n                value={group.conditions?.subtypes || []}\n                onChange={(val) => onConditionChange(groupIdx, \"subtypes\", val)}\n                placeholder=\"Type and press space...\"\n              />\n            </div>\n\n            {/* Tags */}\n            <div>\n              <label className=\"condition-label\">Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => onConditionChange(groupIdx, \"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => onConditionChange(groupIdx, \"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Strategies */}\n      {group.strategies.length === 0 && (\n        <div className=\"text-muted text-small mb-sm\">No strategies. Add one below.</div>\n      )}\n\n      {group.strategies.map((strategy, stratIdx) => (\n        <div key={stratIdx} className={`strategy-card ${strategy.type}`}>\n          <div className=\"flex justify-between align-center mb-sm\">\n            <div className=\"flex align-center gap-sm\">\n              <strong className=\"capitalize text-small\">{strategy.type}</strong>\n              <span className=\"weight-badge\">\n                {groupTotalWeight > 0 ? ((strategy.weight / groupTotalWeight) * 100).toFixed(0) : 0}\n                %\n              </span>\n            </div>\n            <button className=\"danger btn-xs\" onClick={() => onDeleteStrategy(groupIdx, stratIdx)}>\n              Remove\n            </button>\n          </div>\n\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.05\"\n            value={strategy.weight}\n            onChange={(e) => onWeightChange(groupIdx, stratIdx, e.target.value)}\n            className=\"strategy-slider\"\n          />\n\n          {strategy.type === \"phonotactic\" && (\n            <select\n              value={strategy.domainId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], domainId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select domain...</option>\n              {domains.map((d) => (\n                <option key={d.id} value={d.id}>\n                  {d.id}\n                </option>\n              ))}\n            </select>\n          )}\n\n          {strategy.type === \"grammar\" && (\n            <select\n              value={strategy.grammarId || \"\"}\n              onChange={(e) => {\n                const groups = [...editedProfile.strategyGroups];\n                const strategies = [...groups[groupIdx].strategies];\n                strategies[stratIdx] = { ...strategies[stratIdx], grammarId: e.target.value };\n                groups[groupIdx] = { ...groups[groupIdx], strategies };\n                setEditedProfile({ ...editedProfile, strategyGroups: groups });\n              }}\n              className=\"strategy-select\"\n            >\n              <option value=\"\">Select grammar...</option>\n              {grammars.map((g) => (\n                <option key={g.id} value={g.id}>\n                  {g.id}\n                </option>\n              ))}\n            </select>\n          )}\n        </div>\n      ))}\n\n      <div className=\"flex gap-xs mt-sm\">\n        <button\n          className=\"secondary text-xs\"\n          onClick={() => onAddStrategy(groupIdx, \"phonotactic\")}\n        >\n          + Phonotactic\n        </button>\n        <button className=\"secondary text-xs\" onClick={() => onAddStrategy(groupIdx, \"grammar\")}>\n          + Grammar\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  group,\n  groupIdx,\n  domains,\n  grammars,\n  entityKinds,\n  prominenceLevels,\n  tagRegistry,\n  editedProfile,\n  setEditedProfile,\n  onDeleteGroup,\n  onAddStrategy,\n  onDeleteStrategy,\n  onWeightChange,\n  onConditionChange,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; domains: any; grammars: any; entityKinds: any; prominenceLevels: any; tagRegistry: any; editedProfile: any; setEditedProfile: any; onDeleteGroup: any; onAddStrategy: any; onDeleteStrategy: any; onWeightChange: any; onConditionChange: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/TagsInput.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/TagsInput.jsx", "sourceCode": "/**\n * Tags input with auto-split on space/comma\n * Note: Consider using TagSelector from shared-components in future\n */\nexport default function TagsInput({ value, onChange, placeholder }) {\n  const tags = Array.isArray(value) ? value : [];\n\n  const handleKeyDown = (e) => {\n    if (e.key === \" \" || e.key === \",\" || e.key === \"Enter\") {\n      e.preventDefault();\n      const input = e.target.value.trim();\n      if (input && !tags.includes(input)) {\n        onChange([...tags, input]);\n      }\n      e.target.value = \"\";\n    } else if (e.key === \"Backspace\" && e.target.value === \"\" && tags.length > 0) {\n      onChange(tags.slice(0, -1));\n    }\n  };\n\n  const handleRemove = (tag) => {\n    onChange(tags.filter((t) => t !== tag));\n  };\n\n  return (\n    <div className=\"tags-input-container\">\n      {tags.map((tag) => (\n        <span key={tag} className=\"tag-chip\">\n          {tag}\n          <button type=\"button\" onClick={() => handleRemove(tag)} className=\"tag-remove-btn\">\n            x\n          </button>\n        </span>\n      ))}\n      <input\n        type=\"text\"\n        onKeyDown={handleKeyDown}\n        placeholder={tags.length === 0 ? placeholder : \"\"}\n        className=\"tags-input\"\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ value, onChange, placeholder }", "type": "{ value: any; onChange: any; placeholder: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/TestPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/TestPanel.jsx", "sourceCode": "/**\n * Test panel for generating test names from a profile\n */\nexport default function TestPanel({\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}) {\n  return (\n    <div className=\"test-panel\">\n      <div className=\"flex justify-between align-center mb-md\">\n        <h4 className=\"mt-0 mb-0\">Test: {profile.id}</h4>\n        <div className=\"flex gap-sm\">\n          <button\n            className=\"primary text-small\"\n            onClick={() => onTest(profile, 10)}\n            disabled={testLoading}\n          >\n            {testLoading ? \"...\" : \"Generate\"}\n          </button>\n          <button className=\"secondary text-small\" onClick={onClose}>\n            Close\n          </button>\n        </div>\n      </div>\n\n      {testError && <div className=\"error mb-md text-small\">{testError}</div>}\n\n      {strategyUsage && (\n        <div className=\"strategy-usage-panel\">\n          {Object.entries(strategyUsage)\n            .filter(([, count]) => count > 0)\n            .map(([strategy, count]) => (\n              <span key={strategy} className=\"mr-sm\">\n                {strategy}: {count}\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-names-list\">\n          {testNames.map((name, i) => (\n            <div key={i} className=\"test-name-item\">\n              {name}\n            </div>\n          ))}\n        </div>\n      ) : (\n        <p className=\"text-muted text-small mt-0 mb-0\">Click Generate to test this profile</p>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  testNames,\n  testLoading,\n  testError,\n  strategyUsage,\n  onTest,\n  onClose,\n}", "type": "{ profile: any; testNames: any; testLoading: any; testError: any; strategyUsage: any; onTest: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js::findMatchingGenerators", "name": "findMatchingGenerators", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js", "sourceCode": "/**\n * Analyze which generators will match a specific strategy group's conditions\n */\nexport function findMatchingGenerators(generators, cultureId, conditions) {\n  if (!generators || generators.length === 0) return [];\n\n  const matches = [];\n\n  for (const gen of generators) {\n    if (gen.enabled === false) continue;\n    const creations = gen.creation || [];\n    const genName = gen.name || gen.id;\n\n    for (const creation of creations) {\n      if (!creationMatchesCulture(creation, cultureId)) continue;\n\n      const match = matchCreationToConditions(creation, conditions, gen.id, genName);\n      if (match) matches.push(match);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}, {"name": "conditions", "type": "any", "optional": false}], "returnType": "{ generatorId: any; generatorName: any; entityKind: any; subtype: any; isDefault: boolean; }[]"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js::computeProfileGeneratorUsage", "name": "computeProfileGeneratorUsage", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/utils.js", "sourceCode": "/**\n * Compute generator usage for all profiles in a culture\n */\nexport function computeProfileGeneratorUsage(profiles, generators, cultureId) {\n  const usage = {};\n\n  for (const profile of profiles) {\n    usage[profile.id] = {\n      totalMatches: 0,\n      groups: {},\n    };\n\n    for (const group of profile.strategyGroups || []) {\n      const matches = findMatchingGenerators(generators, cultureId, group.conditions);\n      usage[profile.id].groups[group.name || \"Default\"] = matches;\n      usage[profile.id].totalMatches += matches.length;\n    }\n  }\n\n  return usage;\n}", "parameters": [{"name": "profiles", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "cultureId", "type": "any", "optional": false}], "returnType": "{}"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/GroupsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/GroupsTab.jsx", "sourceCode": "export default function GroupsTab({\n  profile,\n  onChange,\n  domains,\n  grammars,\n  entityKinds,\n  tagRegistry,\n  onAddTag,\n}) {\n  const prominenceLevels = [\"forgotten\", \"marginal\", \"recognized\", \"renowned\", \"mythic\"];\n\n  const handleAddGroup = (withConditions = false) => {\n    const newGroup = {\n      name: withConditions ? \"Conditional Group\" : \"Default\",\n      priority: withConditions ? 50 : 0,\n      conditions: withConditions\n        ? {\n            entityKinds: [],\n            prominence: [],\n            subtypes: [],\n            subtypeMatchAll: false,\n            tags: [],\n            tagMatchAll: false,\n          }\n        : null,\n      strategies: [],\n    };\n    onChange({\n      ...profile,\n      strategyGroups: [...(profile.strategyGroups || []), newGroup],\n    });\n  };\n\n  const handleDeleteGroup = (groupIdx) => {\n    onChange({\n      ...profile,\n      strategyGroups: profile.strategyGroups.filter((_, i) => i !== groupIdx),\n    });\n  };\n\n  const handleAddStrategy = (groupIdx, type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n\n    const groups = [...profile.strategyGroups];\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      strategies: [...groups[groupIdx].strategies, newStrategy],\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleDeleteStrategy = (groupIdx, stratIdx) => {\n    const groups = [...profile.strategyGroups];\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      strategies: groups[groupIdx].strategies.filter((_, i) => i !== stratIdx),\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleWeightChange = (groupIdx, stratIdx, newWeight) => {\n    const groups = [...profile.strategyGroups];\n    const strategies = [...groups[groupIdx].strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    groups[groupIdx] = { ...groups[groupIdx], strategies };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const handleGroupConditionChange = (groupIdx, field, value) => {\n    const groups = [...profile.strategyGroups];\n    const currentConditions = groups[groupIdx].conditions || {\n      entityKinds: [],\n      prominence: [],\n      subtypes: [],\n      tags: [],\n    };\n    groups[groupIdx] = {\n      ...groups[groupIdx],\n      conditions: { ...currentConditions, [field]: value },\n    };\n    onChange({ ...profile, strategyGroups: groups });\n  };\n\n  const setEditedProfile = (updated) => {\n    onChange(updated);\n  };\n\n  return (\n    <div className=\"profile-groups-tab\">\n      <p className=\"text-muted text-small mt-0\">\n        Strategy groups are evaluated by priority (highest first). The first matching group&apos;s\n        strategies are used for name generation.\n      </p>\n\n      {(profile.strategyGroups || []).length === 0 && (\n        <div className=\"empty-state-card\">\n          <p className=\"mt-0 mb-0\">No strategy groups yet.</p>\n          <p className=\"text-muted mt-sm mb-0\">\n            Add a default group to get started with name generation.\n          </p>\n        </div>\n      )}\n\n      {(profile.strategyGroups || []).map((group, groupIdx) => (\n        <StrategyGroupEditor\n          key={groupIdx}\n          group={group}\n          groupIdx={groupIdx}\n          domains={domains}\n          grammars={grammars}\n          entityKinds={entityKinds}\n          prominenceLevels={prominenceLevels}\n          tagRegistry={tagRegistry}\n          editedProfile={profile}\n          setEditedProfile={setEditedProfile}\n          onDeleteGroup={handleDeleteGroup}\n          onAddStrategy={handleAddStrategy}\n          onDeleteStrategy={handleDeleteStrategy}\n          onWeightChange={handleWeightChange}\n          onConditionChange={handleGroupConditionChange}\n          onAddTag={onAddTag}\n        />\n      ))}\n\n      <div className=\"add-group-buttons\">\n        <button className=\"secondary\" onClick={() => handleAddGroup(false)}>\n          + Default Group\n        </button>\n        <button className=\"secondary\" onClick={() => handleAddGroup(true)}>\n          + Conditional Group\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  domains,\n  grammars,\n  entityKinds,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ profile: any; onChange: any; domains: any; grammars: any; entityKinds: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/OverviewTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/OverviewTab.jsx", "sourceCode": "export default function OverviewTab({\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}) {\n  const matchCount = generatorUsage?.totalMatches || 0;\n  const groups = profile.strategyGroups || [];\n\n  // Drag state\n  const [draggedIdx, setDraggedIdx] = useState(null);\n  const [dragOverIdx, setDragOverIdx] = useState(null);\n  const dragNodeRef = useRef(null);\n\n  const handleDragStart = (e, idx) => {\n    setDraggedIdx(idx);\n    dragNodeRef.current = e.target;\n    e.target.classList.add(\"dragging\");\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setData(\"text/plain\", idx);\n  };\n\n  const handleDragEnd = (e) => {\n    e.target.classList.remove(\"dragging\");\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n    dragNodeRef.current = null;\n  };\n\n  const handleDragOver = (e, idx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === idx) return;\n    setDragOverIdx(idx);\n  };\n\n  const handleDragLeave = () => {\n    setDragOverIdx(null);\n  };\n\n  const handleDrop = (e, dropIdx) => {\n    e.preventDefault();\n    if (draggedIdx === null || draggedIdx === dropIdx) return;\n\n    const newGroups = [...groups];\n    const [draggedGroup] = newGroups.splice(draggedIdx, 1);\n    newGroups.splice(dropIdx, 0, draggedGroup);\n\n    onChange({ ...profile, strategyGroups: newGroups });\n    setDraggedIdx(null);\n    setDragOverIdx(null);\n  };\n\n  const getStrategyTypeCounts = (group) => {\n    const counts = { phonotactic: 0, grammar: 0 };\n    (group.strategies || []).forEach((s) => {\n      if (counts[s.type] !== undefined) counts[s.type]++;\n    });\n    return counts;\n  };\n\n  return (\n    <div className=\"profile-overview-tab\">\n      {/* Profile ID */}\n      <div className=\"form-group\">\n        <label htmlFor=\"profile-id\">Profile ID</label>\n        <input id=\"profile-id\"\n          value={profile.id || \"\"}\n          onChange={(e) => onChange({ ...profile, id: e.target.value })}\n          placeholder=\"e.g., culture_default\"\n        />\n        <small className=\"text-muted\">\n          Unique identifier used to reference this profile in generators\n        </small>\n      </div>\n\n      {/* Default Profile Toggle */}\n      <div className=\"form-group\">\n        <label className=\"checkbox-label\">\n          <input\n            type=\"checkbox\"\n            checked={profile.isDefault || false}\n            onChange={(e) => onChange({ ...profile, isDefault: e.target.checked })}\n          />\n          <span>Default Profile</span>\n        </label>\n        <small className=\"text-muted\">\n          Use this profile when no entity kind matches. Only one profile should be marked as\n          default.\n        </small>\n      </div>\n\n      {/* Entity Kinds Binding */}\n      <div className=\"form-group\">\n        <label>Entity Kinds\n        <MultiSelectPills\n          options={entityKinds}\n          selected={profile.entityKinds || []}\n          onChange={(kinds) => onChange({ ...profile, entityKinds: kinds })}\n          allLabel=\"Any\"\n        />\n        </label>\n        <small className=\"text-muted\">\n          Profile applies when generating names for these entity kinds. &quot;Any&quot; means use default\n          profile logic.\n        </small>\n      </div>\n\n      {/* Stats */}\n      <div className=\"profile-stats\">\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.length}</div>\n          <div className=\"stat-label\">Strategy Groups</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">\n            {groups.reduce((sum, g) => sum + (g.strategies?.length || 0), 0)}\n          </div>\n          <div className=\"stat-label\">Total Strategies</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{groups.filter((g) => g.conditions).length}</div>\n          <div className=\"stat-label\">Conditional</div>\n        </div>\n        <div className=\"stat-card\">\n          <div className=\"stat-value\">{matchCount}</div>\n          <div className=\"stat-label\">Generator Matches</div>\n        </div>\n      </div>\n\n      {/* Groups Overview */}\n      <div className=\"groups-overview\">\n        <div className=\"groups-header\">\n          <h4>Strategy Groups</h4>\n          <span className=\"text-muted text-small\">Drag to reorder priority</span>\n        </div>\n\n        {groups.length === 0 ? (\n          <div className=\"empty-groups\">\n            <p>No strategy groups yet. Add one using the buttons below the sidebar.</p>\n          </div>\n        ) : (\n          <div className=\"groups-list\">\n            {groups.map((group, idx) => {\n              const isConditional = !!group.conditions;\n              const counts = getStrategyTypeCounts(group);\n              const isDragOver = dragOverIdx === idx && draggedIdx !== idx;\n\n              return (\n                <div\n                  key={idx}\n                  className={`group-row ${isDragOver ? \"drag-over\" : \"\"} ${draggedIdx === idx ? \"dragging\" : \"\"}`}\n                  draggable\n                  onDragStart={(e) => handleDragStart(e, idx)}\n                  onDragEnd={handleDragEnd}\n                  onDragOver={(e) => handleDragOver(e, idx)}\n                  onDragLeave={handleDragLeave}\n                  onDrop={(e) => handleDrop(e, idx)}\n                  onClick={() => onNavigateToGroup?.(idx)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  <div className=\"drag-handle\" title=\"Drag to reorder\">\n                    <span>\u22ee\u22ee</span>\n                  </div>\n\n                  <div className=\"group-info\">\n                    <span className=\"group-name\">{group.name || `Group ${idx + 1}`}</span>\n                    <span\n                      className={`group-type-badge ${isConditional ? \"conditional\" : \"default\"}`}\n                    >\n                      {isConditional ? \"\ud83c\udfaf Conditional\" : \"\ud83d\udce6 Default\"}\n                    </span>\n                  </div>\n\n                  <div className=\"group-meta\">\n                    <span className=\"priority-badge\" title=\"Priority\">\n                      P{group.priority || 0}\n                    </span>\n                    {counts.phonotactic > 0 && (\n                      <span className=\"strategy-count phonotactic\" title=\"Phonotactic strategies\">\n                        {counts.phonotactic}\n                      </span>\n                    )}\n                    {counts.grammar > 0 && (\n                      <span className=\"strategy-count grammar\" title=\"Grammar strategies\">\n                        {counts.grammar}\n                      </span>\n                    )}\n                    {counts.phonotactic === 0 && counts.grammar === 0 && (\n                      <span className=\"no-strategies\">No strategies</span>\n                    )}\n                  </div>\n\n                  <div className=\"group-arrow\">\u2192</div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n\n        <p className=\"text-muted text-xs mt-sm\">\n          Groups are evaluated by priority (highest first). First matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Actions */}\n      <div className=\"profile-actions\">\n        <button className=\"secondary\" onClick={onDuplicate}>\n          Duplicate Profile\n        </button>\n      </div>\n\n      {/* Danger Zone */}\n      <div className=\"danger-zone\">\n        <h4>Danger Zone</h4>\n        <button className=\"danger\" onClick={onDelete}>\n          Delete Profile\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  profile,\n  onChange,\n  onDelete,\n  onDuplicate,\n  onNavigateToGroup,\n  generatorUsage,\n  entityKinds = [],\n}", "type": "{ profile: any; onChange: any; onDelete: any; onDuplicate: any; onNavigateToGroup: any; generatorUsage: any; entityKinds?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/SingleGroupTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/SingleGroupTab.jsx", "sourceCode": "export default function SingleGroupTab({\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}) {\n  const hasConditions = !!group.conditions;\n  const groupTotalWeight = group.strategies.reduce((sum, s) => sum + s.weight, 0);\n\n  // Compute available subtypes based on selected entity kinds\n  // worldSchema.hardState has: { kind, subtype: string[], status: string[] }\n  const availableSubtypes = useMemo(() => {\n    const selectedKinds = group.conditions?.entityKinds || [];\n    const entityDefs = worldSchema?.hardState || [];\n\n    // If no entity kinds selected, show all subtypes from all entity kinds\n    const kindsToCheck =\n      selectedKinds.length > 0\n        ? entityDefs.filter((e) => selectedKinds.includes(e.kind))\n        : entityDefs;\n\n    const subtypes = new Set();\n    kindsToCheck.forEach((entityDef) => {\n      // subtype is already a string array in hardState format\n      (entityDef.subtype || []).forEach((st) => {\n        if (st) subtypes.add(st);\n      });\n    });\n\n    return Array.from(subtypes).sort();\n  }, [group.conditions?.entityKinds, worldSchema]);\n\n  const updateGroup = (updates) => {\n    onChange({ ...group, ...updates });\n  };\n\n  const toggleConditions = () => {\n    if (hasConditions) {\n      updateGroup({ conditions: null });\n    } else {\n      updateGroup({\n        conditions: {\n          entityKinds: [],\n          prominence: [],\n          subtypes: [],\n          subtypeMatchAll: false,\n          tags: [],\n          tagMatchAll: false,\n        },\n      });\n    }\n  };\n\n  const handleConditionChange = (field, value) => {\n    updateGroup({\n      conditions: { ...group.conditions, [field]: value },\n    });\n  };\n\n  const handleAddStrategy = (type) => {\n    const newStrategy = { type, weight: 0.25 };\n    if (type === \"phonotactic\") {\n      newStrategy.domainId = domains[0]?.id || \"\";\n    } else if (type === \"grammar\") {\n      newStrategy.grammarId = grammars[0]?.id || \"\";\n    }\n    updateGroup({\n      strategies: [...group.strategies, newStrategy],\n    });\n  };\n\n  const handleDeleteStrategy = (stratIdx) => {\n    updateGroup({\n      strategies: group.strategies.filter((_, i) => i !== stratIdx),\n    });\n  };\n\n  const handleWeightChange = (stratIdx, newWeight) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], weight: parseFloat(newWeight) || 0 };\n    updateGroup({ strategies });\n  };\n\n  const handleStrategyConfigChange = (stratIdx, field, value) => {\n    const strategies = [...group.strategies];\n    strategies[stratIdx] = { ...strategies[stratIdx], [field]: value };\n    updateGroup({ strategies });\n  };\n\n  return (\n    <div className=\"single-group-tab\">\n      {/* Group Header */}\n      <div className=\"group-header-section\">\n        <div className=\"group-name-row\">\n          <div className=\"form-group\">\n            <label htmlFor=\"group-name\">Group Name</label>\n            <input id=\"group-name\"\n              value={group.name || \"\"}\n              onChange={(e) => updateGroup({ name: e.target.value })}\n              placeholder=\"e.g., Noble Names\"\n            />\n          </div>\n          <div className=\"form-group priority-field\">\n            <label>Priority\n            <NumberInput\n              value={group.priority || 0}\n              onChange={(v) => updateGroup({ priority: v ?? 0 })}\n              integer\n            />\n            </label>\n          </div>\n        </div>\n        <p className=\"text-muted text-small mt-0\">\n          Higher priority groups are evaluated first. The first matching group&apos;s strategies are\n          used.\n        </p>\n      </div>\n\n      {/* Conditions Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Conditions</h4>\n          <button\n            className={`toggle-btn ${hasConditions ? \"active\" : \"\"}`}\n            onClick={toggleConditions}\n          >\n            {hasConditions ? \"Conditional\" : \"Always Match\"}\n          </button>\n        </div>\n\n        {hasConditions ? (\n          <div className=\"conditions-grid\">\n            <div className=\"condition-field\">\n              <label>Entity Types\n              <MultiSelectPills\n                options={entityKinds}\n                selected={group.conditions?.entityKinds || []}\n                onChange={(val) => handleConditionChange(\"entityKinds\", val)}\n                allLabel=\"All\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Prominence\n              <MultiSelectPills\n                options={PROMINENCE_LEVELS}\n                selected={group.conditions?.prominence || []}\n                onChange={(val) => handleConditionChange(\"prominence\", val)}\n                allLabel=\"Any\"\n              />\n              </label>\n            </div>\n\n            <div className=\"condition-field\">\n              <label>\n                Subtypes\n                <label className=\"match-all-toggle\">\n                  <input\n                    type=\"checkbox\"\n                    checked={group.conditions?.subtypeMatchAll || false}\n                    onChange={(e) => handleConditionChange(\"subtypeMatchAll\", e.target.checked)}\n                  />\n                  Match all\n                </label>\n              </label>\n              {availableSubtypes.length > 0 ? (\n                <MultiSelectPills\n                  options={availableSubtypes}\n                  selected={group.conditions?.subtypes || []}\n                  onChange={(val) => handleConditionChange(\"subtypes\", val)}\n                  allLabel=\"Any\"\n                />\n              ) : (\n                <p className=\"text-muted text-small sgt-no-subtypes\">\n                  {(group.conditions?.entityKinds?.length || 0) > 0\n                    ? \"Selected entity types have no subtypes defined\"\n                    : \"Select entity types to see available subtypes\"}\n                </p>\n              )}\n            </div>\n\n            <div className=\"condition-field\">\n              <label>Tags\n              <TagSelector\n                value={group.conditions?.tags || []}\n                onChange={(val) => handleConditionChange(\"tags\", val)}\n                tagRegistry={tagRegistry}\n                placeholder=\"Select tags...\"\n                matchAllEnabled={true}\n                matchAll={group.conditions?.tagMatchAll || false}\n                onMatchAllChange={(val) => handleConditionChange(\"tagMatchAll\", val)}\n                onAddToRegistry={onAddTag}\n              />\n              </label>\n            </div>\n          </div>\n        ) : (\n          <p className=\"text-muted text-small\">\n            This group will always be considered. Click &quot;Always Match&quot; to add conditions.\n          </p>\n        )}\n      </div>\n\n      {/* Strategies Section */}\n      <div className=\"group-section\">\n        <div className=\"section-header\">\n          <h4>Strategies</h4>\n          <div className=\"add-strategy-buttons\">\n            <button\n              className=\"add-btn phonotactic\"\n              onClick={() => handleAddStrategy(\"phonotactic\")}\n            >\n              + Phonotactic\n            </button>\n            <button className=\"add-btn grammar\" onClick={() => handleAddStrategy(\"grammar\")}>\n              + Grammar\n            </button>\n          </div>\n        </div>\n\n        {group.strategies.length === 0 ? (\n          <div className=\"empty-strategies\">\n            <p>No strategies yet. Add a strategy to define how names are generated.</p>\n          </div>\n        ) : (\n          <div className=\"strategies-list\">\n            {group.strategies.map((strategy, stratIdx) => (\n              <div key={stratIdx} className={`strategy-item ${strategy.type}`}>\n                <div className=\"strategy-header\">\n                  <span className=\"strategy-type\">{strategy.type}</span>\n                  <span className=\"strategy-weight\">\n                    {groupTotalWeight > 0\n                      ? Math.round((strategy.weight / groupTotalWeight) * 100)\n                      : 0}\n                    %\n                  </span>\n                  <button className=\"remove-btn\" onClick={() => handleDeleteStrategy(stratIdx)}>\n                    \u00d7\n                  </button>\n                </div>\n\n                <div className=\"strategy-body\">\n                  <div className=\"weight-slider\">\n                    <label htmlFor=\"weight\">Weight</label>\n                    <input id=\"weight\"\n                      type=\"range\"\n                      min=\"0\"\n                      max=\"1\"\n                      step=\"0.05\"\n                      value={strategy.weight}\n                      onChange={(e) => handleWeightChange(stratIdx, e.target.value)}\n                    />\n                  </div>\n\n                  {strategy.type === \"phonotactic\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"domain\">Domain</label>\n                      <select id=\"domain\"\n                        value={strategy.domainId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"domainId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select domain...</option>\n                        {domains.map((d) => (\n                          <option key={d.id} value={d.id}>\n                            {d.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n\n                  {strategy.type === \"grammar\" && (\n                    <div className=\"strategy-config\">\n                      <label htmlFor=\"grammar\">Grammar</label>\n                      <select id=\"grammar\"\n                        value={strategy.grammarId || \"\"}\n                        onChange={(e) =>\n                          handleStrategyConfigChange(stratIdx, \"grammarId\", e.target.value)\n                        }\n                      >\n                        <option value=\"\">Select grammar...</option>\n                        {grammars.map((g) => (\n                          <option key={g.id} value={g.id}>\n                            {g.id}\n                          </option>\n                        ))}\n                      </select>\n                    </div>\n                  )}\n                </div>\n              </div>\n// ... (truncated)", "parameters": [{"name": "{\n  group,\n  groupIdx: _groupIdx,\n  onChange,\n  onDelete,\n  domains,\n  grammars,\n  entityKinds,\n  worldSchema,\n  tagRegistry,\n  onAddTag,\n}", "type": "{ group: any; groupIdx: any; onChange: any; onDelete: any; domains: any; grammars: any; entityKinds: any; worldSchema: any; tagRegistry: any; onAddTag: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/TestTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/components/workspace/tabs/profile/tabs/TestTab.jsx", "sourceCode": "export default function TestTab({ profile, cultureConfig }) {\n  const [testNames, setTestNames] = useState([]);\n  const [testLoading, setTestLoading] = useState(false);\n  const [testError, setTestError] = useState(null);\n  const [strategyUsage, setStrategyUsage] = useState(null);\n  const [count, setCount] = useState(10);\n\n  const handleTestNames = async () => {\n    if (!profile || !cultureConfig) return;\n\n    setTestLoading(true);\n    setTestError(null);\n    setTestNames([]);\n    setStrategyUsage(null);\n\n    try {\n      const result = await generateTestNames({\n        culture: cultureConfig,\n        profileId: profile.id,\n        count,\n        seed: `test-${Date.now()}`,\n      });\n\n      setTestNames(result.names || []);\n      setStrategyUsage(result.strategyUsage || null);\n    } catch (err) {\n      setTestError(err.message);\n    } finally {\n      setTestLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"profile-test-tab\">\n      <div className=\"test-controls\">\n        <div className=\"test-count-control\">\n          <label>Count:\n          <NumberInput\n            min={1}\n            max={100}\n            value={count}\n            onChange={(v) => setCount(v ?? 10)}\n            integer\n          />\n          </label>\n        </div>\n        <button className=\"primary\" onClick={handleTestNames} disabled={testLoading}>\n          {testLoading ? \"Generating...\" : \"Generate Names\"}\n        </button>\n      </div>\n\n      {testError && <div className=\"error-box\">{testError}</div>}\n\n      {strategyUsage && Object.keys(strategyUsage).length > 0 && (\n        <div className=\"strategy-usage-summary\">\n          <span className=\"usage-label\">Strategy usage:</span>\n          {Object.entries(strategyUsage)\n            .filter(([, cnt]) => cnt > 0)\n            .map(([strategy, cnt]) => (\n              <span key={strategy} className=\"usage-item\">\n                <span className=\"usage-strategy\">{strategy}</span>\n                <span className=\"usage-count\">{cnt}</span>\n              </span>\n            ))}\n        </div>\n      )}\n\n      {testNames.length > 0 ? (\n        <div className=\"test-results\">\n          <div className=\"results-header\">\n            <span className=\"results-count\">{testNames.length} names generated</span>\n          </div>\n          <div className=\"test-names-grid\">\n            {testNames.map((name, i) => (\n              <div key={i} className=\"test-name-card\">\n                {name}\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div className=\"empty-test-state\">\n          <p>Click &quot;Generate Names&quot; to test this profile</p>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ profile, cultureConfig }", "type": "{ profile: any; cultureConfig: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}]