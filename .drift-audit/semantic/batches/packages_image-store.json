[{"id": "packages/image-store/src/hooks.ts::useImageUrl", "name": "useImageUrl", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load a single image URL on demand.\n * Returns { url, loading, error, metadata }.\n */\nexport function useImageUrl(\n  imageId: string | null | undefined,\n  size: ImageSize = 'thumb',\n): UseImageUrlResult {\n  const [url, setUrl] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<ImageEntryMetadata | null>(null);\n  const loadUrl = useImageStore((s) => s.loadUrl);\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  useEffect(() => {\n    if (!imageId || !initialized) {\n      setUrl(null);\n      setLoading(false);\n      setError(null);\n      setMetadata(null);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n    setError(null);\n\n    Promise.all([\n      loadUrl(imageId, size),\n      loadMetadata([imageId]),\n    ])\n      .then(([result, metaMap]) => {\n        if (cancelled) return;\n        if (result) {\n          setUrl(result);\n          setMetadata(metaMap.get(imageId) ?? null);\n        } else {\n          setError('Image not found');\n        }\n      })\n      .catch((err: unknown) => {\n        if (!cancelled) {\n          setError(err instanceof Error ? err.message : 'Failed to load image');\n        }\n      })\n      .finally(() => {\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [imageId, size, loadUrl, loadMetadata, initialized]);\n\n  return { url, loading, error, metadata };\n}", "parameters": [{"name": "imageId", "type": "string | null | undefined", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "UseImageUrlResult", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useImageStore", "count": 3}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/hooks.ts::useImageUrls", "name": "useImageUrls", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load multiple image URLs in batch.\n * Returns { urls: Map<imageId, url>, loading }.\n */\nexport function useImageUrls(\n  imageIds: (string | null | undefined)[],\n  size: ImageSize = 'thumb',\n): { urls: Map<string, string>; loading: boolean } {\n  const [urls, setUrls] = useState<Map<string, string>>(new Map());\n  const [loading, setLoading] = useState(false);\n  const loadUrls = useImageStore((s) => s.loadUrls);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setUrls(new Map());\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    void loadUrls(validIds, size).then((result) => {\n      if (!cancelled) {\n        setUrls(result);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, size, loadUrls, initialized]);\n\n  return { urls, loading };\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "{ urls: Map<string, string>; loading: boolean }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/hooks.ts::useImageMetadata", "name": "useImageMetadata", "kind": "hook", "filePath": "packages/image-store/src/hooks.ts", "sourceCode": "/**\n * Load metadata (dimensions, entity info) for a set of image IDs.\n * Metadata is lightweight and cached in the store.\n */\nexport function useImageMetadata(\n  imageIds: (string | null | undefined)[],\n): Map<string, ImageEntryMetadata> {\n  const [metadata, setMetadata] = useState<Map<string, ImageEntryMetadata>>(\n    new Map(),\n  );\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  // Track previous idsKey to avoid re-fetching same data\n  const prevIdsKeyRef = useRef('');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setMetadata(new Map());\n      return;\n    }\n\n    // Skip if IDs haven't changed\n    if (idsKey === prevIdsKeyRef.current) return;\n    prevIdsKeyRef.current = idsKey;\n\n    let cancelled = false;\n\n    void loadMetadata(validIds).then((result) => {\n      if (!cancelled) {\n        setMetadata(result);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, loadMetadata, initialized]);\n\n  return metadata;\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}], "returnType": "Map<string, ImageEntryMetadata>", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [{"source": "react", "specifiers": ["useEffect", "useState", "useMemo", "useRef"], "category": "framework"}, {"source": "./store", "specifiers": ["useImageStore"], "category": "internal"}, {"source": "./types", "specifiers": ["ImageEntryMetadata", "ImageSize"], "category": "internal"}], "storeAccess": ["useImageStore"]}, {"id": "packages/image-store/src/index.ts::useImageUrl", "name": "useImageUrl", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load a single image URL on demand.\n * Returns { url, loading, error, metadata }.\n */\nexport function useImageUrl(\n  imageId: string | null | undefined,\n  size: ImageSize = 'thumb',\n): UseImageUrlResult {\n  const [url, setUrl] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<ImageEntryMetadata | null>(null);\n  const loadUrl = useImageStore((s) => s.loadUrl);\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  useEffect(() => {\n    if (!imageId || !initialized) {\n      setUrl(null);\n      setLoading(false);\n      setError(null);\n      setMetadata(null);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n    setError(null);\n\n    Promise.all([\n      loadUrl(imageId, size),\n      loadMetadata([imageId]),\n    ])\n      .then(([result, metaMap]) => {\n        if (cancelled) return;\n        if (result) {\n          setUrl(result);\n          setMetadata(metaMap.get(imageId) ?? null);\n        } else {\n          setError('Image not found');\n        }\n      })\n      .catch((err: unknown) => {\n        if (!cancelled) {\n          setError(err instanceof Error ? err.message : 'Failed to load image');\n        }\n      })\n      .finally(() => {\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [imageId, size, loadUrl, loadMetadata, initialized]);\n\n  return { url, loading, error, metadata };\n}", "parameters": [{"name": "imageId", "type": "string | null | undefined", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "UseImageUrlResult", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useImageStore", "count": 3}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/image-store/src/index.ts::useImageUrls", "name": "useImageUrls", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load multiple image URLs in batch.\n * Returns { urls: Map<imageId, url>, loading }.\n */\nexport function useImageUrls(\n  imageIds: (string | null | undefined)[],\n  size: ImageSize = 'thumb',\n): { urls: Map<string, string>; loading: boolean } {\n  const [urls, setUrls] = useState<Map<string, string>>(new Map());\n  const [loading, setLoading] = useState(false);\n  const loadUrls = useImageStore((s) => s.loadUrls);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setUrls(new Map());\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    void loadUrls(validIds, size).then((result) => {\n      if (!cancelled) {\n        setUrls(result);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, size, loadUrls, initialized]);\n\n  return { urls, loading };\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}, {"name": "size", "type": "ImageSize", "optional": true}], "returnType": "{ urls: Map<string, string>; loading: boolean }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/image-store/src/index.ts::useImageMetadata", "name": "useImageMetadata", "kind": "hook", "filePath": "packages/image-store/src/index.ts", "sourceCode": "/**\n * Load metadata (dimensions, entity info) for a set of image IDs.\n * Metadata is lightweight and cached in the store.\n */\nexport function useImageMetadata(\n  imageIds: (string | null | undefined)[],\n): Map<string, ImageEntryMetadata> {\n  const [metadata, setMetadata] = useState<Map<string, ImageEntryMetadata>>(\n    new Map(),\n  );\n  const loadMetadata = useImageStore((s) => s.loadMetadata);\n  const initialized = useImageStore((s) => s.initialized);\n\n  const validIds = useMemo(\n    () => imageIds.filter((id): id is string => Boolean(id)),\n    [imageIds],\n  );\n  const idsKey = validIds.join(',');\n\n  // Track previous idsKey to avoid re-fetching same data\n  const prevIdsKeyRef = useRef('');\n\n  useEffect(() => {\n    if (validIds.length === 0 || !initialized) {\n      setMetadata(new Map());\n      return;\n    }\n\n    // Skip if IDs haven't changed\n    if (idsKey === prevIdsKeyRef.current) return;\n    prevIdsKeyRef.current = idsKey;\n\n    let cancelled = false;\n\n    void loadMetadata(validIds).then((result) => {\n      if (!cancelled) {\n        setMetadata(result);\n      }\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [idsKey, loadMetadata, initialized]);\n\n  return metadata;\n}", "parameters": [{"name": "imageIds", "type": "(string | null | undefined)[]", "optional": false}], "returnType": "Map<string, ImageEntryMetadata>", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useImageStore", "count": 2}, {"name": "useMemo", "count": 1}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}]