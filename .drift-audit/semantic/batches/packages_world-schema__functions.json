[{"id": "packages/world-schema/src/eventFiltering.ts::isProminenceOnlyEvent", "name": "isProminenceOnlyEvent", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Check if an event is prominence-only for a given entity.\r\n * An event is \"prominence-only\" if ALL of its effects on the entity are\r\n * field_changed effects where field === 'prominence'.\r\n *\r\n * These events are typically noise (gradual prominence changes) rather than\r\n * narratively interesting happenings.\r\n */\r\nexport function isProminenceOnlyEvent(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): boolean {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  if (!participant || participant.effects.length === 0) return false;\r\n\r\n  // Check if ALL effects are prominence field changes\r\n  return participant.effects.every(\r\n    effect => effect.type === 'field_changed' && effect.field === 'prominence'\r\n  );\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "packages/world-schema/src/eventFiltering.ts::getEntityEffects", "name": "getEntityEffects", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Get effects for a specific entity from an event\r\n */\r\nexport function getEntityEffects(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): EntityEffect[] {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  return participant?.effects ?? [];\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "EntityEffect[]"}, {"id": "packages/world-schema/src/eventFiltering.ts::getEntityEvents", "name": "getEntityEvents", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Get filtered events for an entity from narrative history.\r\n *\r\n * Applies filters:\r\n * 1. Entity must appear in participantEffects\r\n * 2. Exclude prominence-only events (if enabled)\r\n * 3. Significance >= minSignificance\r\n *\r\n * Results are sorted chronologically (by tick).\r\n */\r\nexport function getEntityEvents(\r\n  narrativeHistory: NarrativeEvent[],\r\n  options: EventFilterOptions\r\n): NarrativeEvent[] {\r\n  const {\r\n    entityId,\r\n    minSignificance = 0,\r\n    excludeProminenceOnly = true,\r\n    limit,\r\n  } = options;\r\n\r\n  const filtered = narrativeHistory\r\n    .filter(event => {\r\n      // Entity must appear in participantEffects\r\n      if (!event.participantEffects?.some(p => p.entity.id === entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Exclude prominence-only events if configured\r\n      if (excludeProminenceOnly && isProminenceOnlyEvent(event, entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Filter by significance threshold\r\n      if (event.significance < minSignificance) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    })\r\n    .sort((a, b) => a.tick - b.tick); // Chronological order\r\n\r\n  return limit ? filtered.slice(0, limit) : filtered;\r\n}", "parameters": [{"name": "narrativeHistory", "type": "NarrativeEvent[]", "optional": false}, {"name": "options", "type": "EventFilterOptions", "optional": false}], "returnType": "NarrativeEvent[]"}, {"id": "packages/world-schema/src/eventFiltering.ts::formatEventForPrompt", "name": "formatEventForPrompt", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Format an event for inclusion in a prompt.\r\n * Produces a concise one-line summary.\r\n */\r\nexport function formatEventForPrompt(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): string {\r\n  const effects = getEntityEffects(event, entityId);\r\n\r\n  // Use the event description, or summarize effects\r\n  if (event.description) {\r\n    return `[Tick ${event.tick}] ${event.description}`;\r\n  }\r\n\r\n  // Fallback: summarize effects\r\n  const effectSummary = effects\r\n    .map(e => e.description)\r\n    .filter(Boolean)\r\n    .join('; ');\r\n\r\n  return `[Tick ${event.tick}] ${effectSummary || event.action}`;\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "string"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkEntityKind", "name": "isFrameworkEntityKind", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "// ===========================\n// TYPE GUARDS\n// ===========================\n\nexport function isFrameworkEntityKind(kind: string): kind is FrameworkEntityKind {\n  return FRAMEWORK_ENTITY_KIND_VALUES.includes(kind as FrameworkEntityKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkEntityKind"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkRelationshipKind", "name": "isFrameworkRelationshipKind", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkRelationshipKind(kind: string): kind is FrameworkRelationshipKind {\n  return FRAMEWORK_RELATIONSHIP_KIND_VALUES.includes(kind as FrameworkRelationshipKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkRelationshipKind"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkStatus", "name": "isFrameworkStatus", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkStatus(status: string): status is FrameworkStatus {\n  return FRAMEWORK_STATUS_VALUES.includes(status as FrameworkStatus);\n}", "parameters": [{"name": "status", "type": "string", "optional": false}], "returnType": "status is FrameworkStatus"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkSubtype", "name": "isFrameworkSubtype", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkSubtype(subtype: string): subtype is FrameworkSubtype {\n  return FRAMEWORK_SUBTYPE_VALUES.includes(subtype as FrameworkSubtype);\n}", "parameters": [{"name": "subtype", "type": "string", "optional": false}], "returnType": "subtype is FrameworkSubtype"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkTag", "name": "isFrameworkTag", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkTag(tag: string): tag is FrameworkTag {\n  return FRAMEWORK_TAG_VALUES.includes(tag as FrameworkTag);\n}", "parameters": [{"name": "tag", "type": "string", "optional": false}], "returnType": "tag is FrameworkTag"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::getFrameworkRelationshipStrength", "name": "getFrameworkRelationshipStrength", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function getFrameworkRelationshipStrength(kind: FrameworkRelationshipKind): number {\n  return FRAMEWORK_RELATIONSHIP_PROPERTIES[kind].defaultStrength;\n}", "parameters": [{"name": "kind", "type": "FrameworkRelationshipKind", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::mergeFrameworkSchemaSlice", "name": "mergeFrameworkSchemaSlice", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "// ===========================\n// SCHEMA MERGE HELPERS\n// ===========================\n\nexport function mergeFrameworkSchemaSlice(schema: CanonrySchemaSlice): CanonrySchemaSlice {\n  const entityOverrides = new Map(\n    (schema.entityKinds || []).map(item => [item.kind, item])\n  );\n  const relationshipOverrides = new Map(\n    (schema.relationshipKinds || []).map(item => [item.kind, item])\n  );\n  const cultureOverrides = new Map(\n    (schema.cultures || []).map(item => [item.id, item])\n  );\n  const tagOverrides = new Map(\n    (schema.tagRegistry || []).map(item => [item.tag, item])\n  );\n\n  const frameworkEntityKindIds = new Set(FRAMEWORK_ENTITY_KIND_VALUES.map(String));\n  const frameworkRelationshipKindIds = new Set(FRAMEWORK_RELATIONSHIP_KIND_VALUES.map(String));\n  const frameworkCultureIds = new Set(Object.values(FRAMEWORK_CULTURES).map(String));\n  const frameworkTagIds = new Set(FRAMEWORK_TAG_VALUES.map(String));\n\n  const mergeSubtypes = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.subtypes.map(s => s.id));\n    const extra = (override?.subtypes || []).filter(s => !seen.has(s.id));\n    return [...base.subtypes, ...extra];\n  };\n\n  const mergeStatuses = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.statuses.map(s => s.id));\n    const extra = (override?.statuses || []).filter(s => !seen.has(s.id));\n    return [...base.statuses, ...extra];\n  };\n\n  const mergeRequiredRelationships = (\n    base: EntityKindDefinition,\n    override?: EntityKindDefinition\n  ) => {\n    const baseRules = base.requiredRelationships || [];\n    const seen = new Set(baseRules.map(r => r.kind));\n    const extra = (override?.requiredRelationships || []).filter(r => !seen.has(r.kind));\n    return baseRules.length > 0 || extra.length > 0 ? [...baseRules, ...extra] : undefined;\n  };\n\n  const mergedEntityKinds = [\n    ...FRAMEWORK_ENTITY_KIND_DEFINITIONS.map((base) => {\n      const override = entityOverrides.get(base.kind);\n      const merged: EntityKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        subtypes: mergeSubtypes(base, override),\n        statuses: mergeStatuses(base, override),\n        requiredRelationships: mergeRequiredRelationships(base, override),\n        style: { ...(base.style || {}), ...(override?.style || {}) },\n        semanticPlane: override?.semanticPlane ?? base.semanticPlane,\n        defaultStatus: override?.defaultStatus ?? base.defaultStatus,\n      };\n      return merged;\n    }),\n    ...(schema.entityKinds || []).filter(item => !frameworkEntityKindIds.has(String(item.kind))),\n  ];\n\n  const mergedRelationshipKinds = [\n    ...FRAMEWORK_RELATIONSHIP_KIND_DEFINITIONS.map((base) => {\n      const override = relationshipOverrides.get(base.kind);\n      const merged: RelationshipKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        srcKinds: (override?.srcKinds && override.srcKinds.length > 0)\n          ? override.srcKinds\n          : base.srcKinds,\n        dstKinds: (override?.dstKinds && override.dstKinds.length > 0)\n          ? override.dstKinds\n          : base.dstKinds,\n        cullable: base.cullable,\n        decayRate: base.decayRate,\n      };\n      return merged;\n    }),\n    ...(schema.relationshipKinds || []).filter(item => !frameworkRelationshipKindIds.has(String(item.kind))),\n  ];\n\n  const mergedCultures = [\n    ...FRAMEWORK_CULTURE_DEFINITIONS.map((base) => {\n      const override = cultureOverrides.get(base.id);\n      const merged: CultureDefinition = {\n        ...base,\n        ...(override || {}),\n        id: base.id,\n        isFramework: true,\n        name: base.name,\n        description: base.description ?? override?.description,\n        color: base.color ?? override?.color,\n        naming: override?.naming ?? base.naming,\n        axisBiases: override?.axisBiases ?? base.axisBiases,\n        homeRegions: override?.homeRegions ?? base.homeRegions,\n      };\n      return merged;\n    }),\n    ...(schema.cultures || []).filter(item => !frameworkCultureIds.has(String(item.id))),\n  ];\n\n  const mergedTags = [\n    ...FRAMEWORK_TAG_DEFINITIONS.map((base) => {\n      const override = tagOverrides.get(base.tag);\n      const merged: TagDefinition = {\n        ...base,\n        ...(override || {}),\n        tag: base.tag,\n        isFramework: true,\n      };\n      return merged;\n    }),\n    ...(schema.tagRegistry || []).filter(item => !frameworkTagIds.has(String(item.tag))),\n  ];\n\n  return {\n    ...schema,\n    entityKinds: mergedEntityKinds,\n    relationshipKinds: mergedRelationshipKinds,\n    cultures: mergedCultures,\n    tagRegistry: mergedTags,\n  };\n}", "parameters": [{"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "CanonrySchemaSlice"}, {"id": "packages/world-schema/src/index.ts::createDefaultStyleLibrary", "name": "createDefaultStyleLibrary", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Create a default style library\n */\nexport function createDefaultStyleLibrary(): StyleLibrary {\n  return {\n    artisticStyles: [...DEFAULT_ARTISTIC_STYLES],\n    compositionStyles: [...DEFAULT_COMPOSITION_STYLES],\n    colorPalettes: [...DEFAULT_COLOR_PALETTES],\n    narrativeStyles: [...DEFAULT_NARRATIVE_STYLES, ...DEFAULT_DOCUMENT_STYLES],\n  };\n}", "parameters": [], "returnType": "StyleLibrary"}, {"id": "packages/world-schema/src/index.ts::findArtisticStyle", "name": "findArtisticStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find an artistic style by ID\n */\nexport function findArtisticStyle(library: StyleLibrary, id: string): ArtisticStyle | undefined {\n  return library.artisticStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ArtisticStyle | undefined"}, {"id": "packages/world-schema/src/index.ts::findCompositionStyle", "name": "findCompositionStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a composition style by ID\n */\nexport function findCompositionStyle(library: StyleLibrary, id: string): CompositionStyle | undefined {\n  return library.compositionStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "CompositionStyle | undefined"}, {"id": "packages/world-schema/src/index.ts::findColorPalette", "name": "findColorPalette", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a color palette by ID\n */\nexport function findColorPalette(library: StyleLibrary, id: string): ColorPalette | undefined {\n  return library.colorPalettes.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ColorPalette | undefined"}, {"id": "packages/world-schema/src/index.ts::findNarrativeStyle", "name": "findNarrativeStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a narrative style by ID\n */\nexport function findNarrativeStyle(library: StyleLibrary, id: string): NarrativeStyle | undefined {\n  return library.narrativeStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "NarrativeStyle | undefined"}, {"id": "packages/world-schema/src/index.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean"}, {"id": "packages/world-schema/src/index.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]"}, {"id": "packages/world-schema/src/index.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]"}, {"id": "packages/world-schema/src/index.ts::isFrameworkEntityKind", "name": "isFrameworkEntityKind", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// ===========================\n// TYPE GUARDS\n// ===========================\n\nexport function isFrameworkEntityKind(kind: string): kind is FrameworkEntityKind {\n  return FRAMEWORK_ENTITY_KIND_VALUES.includes(kind as FrameworkEntityKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkEntityKind"}, {"id": "packages/world-schema/src/index.ts::isFrameworkRelationshipKind", "name": "isFrameworkRelationshipKind", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkRelationshipKind(kind: string): kind is FrameworkRelationshipKind {\n  return FRAMEWORK_RELATIONSHIP_KIND_VALUES.includes(kind as FrameworkRelationshipKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkRelationshipKind"}, {"id": "packages/world-schema/src/index.ts::isFrameworkStatus", "name": "isFrameworkStatus", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkStatus(status: string): status is FrameworkStatus {\n  return FRAMEWORK_STATUS_VALUES.includes(status as FrameworkStatus);\n}", "parameters": [{"name": "status", "type": "string", "optional": false}], "returnType": "status is FrameworkStatus"}, {"id": "packages/world-schema/src/index.ts::isFrameworkSubtype", "name": "isFrameworkSubtype", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkSubtype(subtype: string): subtype is FrameworkSubtype {\n  return FRAMEWORK_SUBTYPE_VALUES.includes(subtype as FrameworkSubtype);\n}", "parameters": [{"name": "subtype", "type": "string", "optional": false}], "returnType": "subtype is FrameworkSubtype"}, {"id": "packages/world-schema/src/index.ts::isFrameworkTag", "name": "isFrameworkTag", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkTag(tag: string): tag is FrameworkTag {\n  return FRAMEWORK_TAG_VALUES.includes(tag as FrameworkTag);\n}", "parameters": [{"name": "tag", "type": "string", "optional": false}], "returnType": "tag is FrameworkTag"}, {"id": "packages/world-schema/src/index.ts::getFrameworkRelationshipStrength", "name": "getFrameworkRelationshipStrength", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function getFrameworkRelationshipStrength(kind: FrameworkRelationshipKind): number {\n  return FRAMEWORK_RELATIONSHIP_PROPERTIES[kind].defaultStrength;\n}", "parameters": [{"name": "kind", "type": "FrameworkRelationshipKind", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/index.ts::mergeFrameworkSchemaSlice", "name": "mergeFrameworkSchemaSlice", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// ===========================\n// SCHEMA MERGE HELPERS\n// ===========================\n\nexport function mergeFrameworkSchemaSlice(schema: CanonrySchemaSlice): CanonrySchemaSlice {\n  const entityOverrides = new Map(\n    (schema.entityKinds || []).map(item => [item.kind, item])\n  );\n  const relationshipOverrides = new Map(\n    (schema.relationshipKinds || []).map(item => [item.kind, item])\n  );\n  const cultureOverrides = new Map(\n    (schema.cultures || []).map(item => [item.id, item])\n  );\n  const tagOverrides = new Map(\n    (schema.tagRegistry || []).map(item => [item.tag, item])\n  );\n\n  const frameworkEntityKindIds = new Set(FRAMEWORK_ENTITY_KIND_VALUES.map(String));\n  const frameworkRelationshipKindIds = new Set(FRAMEWORK_RELATIONSHIP_KIND_VALUES.map(String));\n  const frameworkCultureIds = new Set(Object.values(FRAMEWORK_CULTURES).map(String));\n  const frameworkTagIds = new Set(FRAMEWORK_TAG_VALUES.map(String));\n\n  const mergeSubtypes = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.subtypes.map(s => s.id));\n    const extra = (override?.subtypes || []).filter(s => !seen.has(s.id));\n    return [...base.subtypes, ...extra];\n  };\n\n  const mergeStatuses = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.statuses.map(s => s.id));\n    const extra = (override?.statuses || []).filter(s => !seen.has(s.id));\n    return [...base.statuses, ...extra];\n  };\n\n  const mergeRequiredRelationships = (\n    base: EntityKindDefinition,\n    override?: EntityKindDefinition\n  ) => {\n    const baseRules = base.requiredRelationships || [];\n    const seen = new Set(baseRules.map(r => r.kind));\n    const extra = (override?.requiredRelationships || []).filter(r => !seen.has(r.kind));\n    return baseRules.length > 0 || extra.length > 0 ? [...baseRules, ...extra] : undefined;\n  };\n\n  const mergedEntityKinds = [\n    ...FRAMEWORK_ENTITY_KIND_DEFINITIONS.map((base) => {\n      const override = entityOverrides.get(base.kind);\n      const merged: EntityKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        subtypes: mergeSubtypes(base, override),\n        statuses: mergeStatuses(base, override),\n        requiredRelationships: mergeRequiredRelationships(base, override),\n        style: { ...(base.style || {}), ...(override?.style || {}) },\n        semanticPlane: override?.semanticPlane ?? base.semanticPlane,\n        defaultStatus: override?.defaultStatus ?? base.defaultStatus,\n      };\n      return merged;\n    }),\n    ...(schema.entityKinds || []).filter(item => !frameworkEntityKindIds.has(String(item.kind))),\n  ];\n\n  const mergedRelationshipKinds = [\n    ...FRAMEWORK_RELATIONSHIP_KIND_DEFINITIONS.map((base) => {\n      const override = relationshipOverrides.get(base.kind);\n      const merged: RelationshipKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        srcKinds: (override?.srcKinds && override.srcKinds.length > 0)\n          ? override.srcKinds\n          : base.srcKinds,\n        dstKinds: (override?.dstKinds && override.dstKinds.length > 0)\n          ? override.dstKinds\n          : base.dstKinds,\n        cullable: base.cullable,\n        decayRate: base.decayRate,\n      };\n      return merged;\n    }),\n    ...(schema.relationshipKinds || []).filter(item => !frameworkRelationshipKindIds.has(String(item.kind))),\n  ];\n\n  const mergedCultures = [\n    ...FRAMEWORK_CULTURE_DEFINITIONS.map((base) => {\n      const override = cultureOverrides.get(base.id);\n      const merged: CultureDefinition = {\n        ...base,\n        ...(override || {}),\n        id: base.id,\n        isFramework: true,\n        name: base.name,\n        description: base.description ?? override?.description,\n        color: base.color ?? override?.color,\n        naming: override?.naming ?? base.naming,\n        axisBiases: override?.axisBiases ?? base.axisBiases,\n        homeRegions: override?.homeRegions ?? base.homeRegions,\n      };\n      return merged;\n    }),\n    ...(schema.cultures || []).filter(item => !frameworkCultureIds.has(String(item.id))),\n  ];\n\n  const mergedTags = [\n    ...FRAMEWORK_TAG_DEFINITIONS.map((base) => {\n      const override = tagOverrides.get(base.tag);\n      const merged: TagDefinition = {\n        ...base,\n        ...(override || {}),\n        tag: base.tag,\n        isFramework: true,\n      };\n      return merged;\n    }),\n    ...(schema.tagRegistry || []).filter(item => !frameworkTagIds.has(String(item.tag))),\n  ];\n\n  return {\n    ...schema,\n    entityKinds: mergedEntityKinds,\n    relationshipKinds: mergedRelationshipKinds,\n    cultures: mergedCultures,\n    tagRegistry: mergedTags,\n  };\n}", "parameters": [{"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "CanonrySchemaSlice"}, {"id": "packages/world-schema/src/index.ts::buildProminenceScale", "name": "buildProminenceScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function buildProminenceScale(\n  values: number[],\n  options: BuildProminenceScaleOptions = {}\n): ProminenceScale {\n  const labels = options.labels ?? PROMINENCE_LABELS;\n  const min = typeof options.min === 'number' ? options.min : DEFAULT_MIN;\n  const max = typeof options.max === 'number' ? options.max : DEFAULT_MAX;\n  const distribution = normalizeDistribution(\n    options.distribution ?? DEFAULT_PROMINENCE_DISTRIBUTION,\n    labels.length\n  );\n\n  const numericValues = values.filter((value) => Number.isFinite(value)).sort((a, b) => a - b);\n\n  if (numericValues.length === 0) {\n    return {\n      labels,\n      distribution,\n      thresholds: defaultThresholds(min, max, labels.length),\n      min,\n      max,\n    };\n  }\n\n  const thresholds: number[] = [];\n  let cumulative = 0;\n  for (let i = 0; i < labels.length - 1; i += 1) {\n    cumulative += distribution[i];\n    thresholds.push(clamp(quantile(numericValues, cumulative), min, max));\n  }\n\n  return {\n    labels,\n    distribution,\n    thresholds,\n    min,\n    max,\n  };\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}, {"name": "options", "type": "BuildProminenceScaleOptions", "optional": true}], "returnType": "ProminenceScale"}, {"id": "packages/world-schema/src/index.ts::prominenceLabelFromScale", "name": "prominenceLabelFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceLabelFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): ProminenceLabel {\n  if (typeof value === 'string' && scale.labels.includes(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'number' || !Number.isFinite(value)) {\n    return scale.labels[0];\n  }\n\n  for (let i = 0; i < scale.thresholds.length; i += 1) {\n    if (value < scale.thresholds[i]) {\n      return scale.labels[i];\n    }\n  }\n\n  return scale.labels[scale.labels.length - 1];\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "ProminenceLabel"}, {"id": "packages/world-schema/src/index.ts::prominenceThresholdFromScale", "name": "prominenceThresholdFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceThresholdFromScale(label: ProminenceLabel, scale: ProminenceScale): number {\n  const index = scale.labels.indexOf(label);\n  if (index <= 0) return scale.min;\n  return scale.thresholds[index - 1] ?? scale.max;\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/index.ts::prominenceIndexFromScale", "name": "prominenceIndexFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceIndexFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): number {\n  const label = prominenceLabelFromScale(value, scale);\n  const index = scale.labels.indexOf(label);\n  return index >= 0 ? index : 0;\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/index.ts::isProminenceOnlyEvent", "name": "isProminenceOnlyEvent", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Check if an event is prominence-only for a given entity.\r\n * An event is \"prominence-only\" if ALL of its effects on the entity are\r\n * field_changed effects where field === 'prominence'.\r\n *\r\n * These events are typically noise (gradual prominence changes) rather than\r\n * narratively interesting happenings.\r\n */\r\nexport function isProminenceOnlyEvent(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): boolean {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  if (!participant || participant.effects.length === 0) return false;\r\n\r\n  // Check if ALL effects are prominence field changes\r\n  return participant.effects.every(\r\n    effect => effect.type === 'field_changed' && effect.field === 'prominence'\r\n  );\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "packages/world-schema/src/index.ts::getEntityEffects", "name": "getEntityEffects", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Get effects for a specific entity from an event\r\n */\r\nexport function getEntityEffects(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): EntityEffect[] {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  return participant?.effects ?? [];\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "EntityEffect[]"}, {"id": "packages/world-schema/src/index.ts::getEntityEvents", "name": "getEntityEvents", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Get filtered events for an entity from narrative history.\r\n *\r\n * Applies filters:\r\n * 1. Entity must appear in participantEffects\r\n * 2. Exclude prominence-only events (if enabled)\r\n * 3. Significance >= minSignificance\r\n *\r\n * Results are sorted chronologically (by tick).\r\n */\r\nexport function getEntityEvents(\r\n  narrativeHistory: NarrativeEvent[],\r\n  options: EventFilterOptions\r\n): NarrativeEvent[] {\r\n  const {\r\n    entityId,\r\n    minSignificance = 0,\r\n    excludeProminenceOnly = true,\r\n    limit,\r\n  } = options;\r\n\r\n  const filtered = narrativeHistory\r\n    .filter(event => {\r\n      // Entity must appear in participantEffects\r\n      if (!event.participantEffects?.some(p => p.entity.id === entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Exclude prominence-only events if configured\r\n      if (excludeProminenceOnly && isProminenceOnlyEvent(event, entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Filter by significance threshold\r\n      if (event.significance < minSignificance) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    })\r\n    .sort((a, b) => a.tick - b.tick); // Chronological order\r\n\r\n  return limit ? filtered.slice(0, limit) : filtered;\r\n}", "parameters": [{"name": "narrativeHistory", "type": "NarrativeEvent[]", "optional": false}, {"name": "options", "type": "EventFilterOptions", "optional": false}], "returnType": "NarrativeEvent[]"}, {"id": "packages/world-schema/src/index.ts::formatEventForPrompt", "name": "formatEventForPrompt", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Format an event for inclusion in a prompt.\r\n * Produces a concise one-line summary.\r\n */\r\nexport function formatEventForPrompt(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): string {\r\n  const effects = getEntityEffects(event, entityId);\r\n\r\n  // Use the event description, or summarize effects\r\n  if (event.description) {\r\n    return `[Tick ${event.tick}] ${event.description}`;\r\n  }\r\n\r\n  // Fallback: summarize effects\r\n  const effectSummary = effects\r\n    .map(e => e.description)\r\n    .filter(Boolean)\r\n    .join('; ');\r\n\r\n  return `[Tick ${event.tick}] ${effectSummary || event.action}`;\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "string"}, {"id": "packages/world-schema/src/prominenceScale.ts::buildProminenceScale", "name": "buildProminenceScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function buildProminenceScale(\n  values: number[],\n  options: BuildProminenceScaleOptions = {}\n): ProminenceScale {\n  const labels = options.labels ?? PROMINENCE_LABELS;\n  const min = typeof options.min === 'number' ? options.min : DEFAULT_MIN;\n  const max = typeof options.max === 'number' ? options.max : DEFAULT_MAX;\n  const distribution = normalizeDistribution(\n    options.distribution ?? DEFAULT_PROMINENCE_DISTRIBUTION,\n    labels.length\n  );\n\n  const numericValues = values.filter((value) => Number.isFinite(value)).sort((a, b) => a - b);\n\n  if (numericValues.length === 0) {\n    return {\n      labels,\n      distribution,\n      thresholds: defaultThresholds(min, max, labels.length),\n      min,\n      max,\n    };\n  }\n\n  const thresholds: number[] = [];\n  let cumulative = 0;\n  for (let i = 0; i < labels.length - 1; i += 1) {\n    cumulative += distribution[i];\n    thresholds.push(clamp(quantile(numericValues, cumulative), min, max));\n  }\n\n  return {\n    labels,\n    distribution,\n    thresholds,\n    min,\n    max,\n  };\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}, {"name": "options", "type": "BuildProminenceScaleOptions", "optional": true}], "returnType": "ProminenceScale"}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceLabelFromScale", "name": "prominenceLabelFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceLabelFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): ProminenceLabel {\n  if (typeof value === 'string' && scale.labels.includes(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'number' || !Number.isFinite(value)) {\n    return scale.labels[0];\n  }\n\n  for (let i = 0; i < scale.thresholds.length; i += 1) {\n    if (value < scale.thresholds[i]) {\n      return scale.labels[i];\n    }\n  }\n\n  return scale.labels[scale.labels.length - 1];\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "ProminenceLabel"}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceThresholdFromScale", "name": "prominenceThresholdFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceThresholdFromScale(label: ProminenceLabel, scale: ProminenceScale): number {\n  const index = scale.labels.indexOf(label);\n  if (index <= 0) return scale.min;\n  return scale.thresholds[index - 1] ?? scale.max;\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceIndexFromScale", "name": "prominenceIndexFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceIndexFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): number {\n  const label = prominenceLabelFromScale(value, scale);\n  const index = scale.labels.indexOf(label);\n  return index >= 0 ? index : 0;\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number"}, {"id": "packages/world-schema/src/style.ts::createDefaultStyleLibrary", "name": "createDefaultStyleLibrary", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Create a default style library\n */\nexport function createDefaultStyleLibrary(): StyleLibrary {\n  return {\n    artisticStyles: [...DEFAULT_ARTISTIC_STYLES],\n    compositionStyles: [...DEFAULT_COMPOSITION_STYLES],\n    colorPalettes: [...DEFAULT_COLOR_PALETTES],\n    narrativeStyles: [...DEFAULT_NARRATIVE_STYLES, ...DEFAULT_DOCUMENT_STYLES],\n  };\n}", "parameters": [], "returnType": "StyleLibrary"}, {"id": "packages/world-schema/src/style.ts::findArtisticStyle", "name": "findArtisticStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find an artistic style by ID\n */\nexport function findArtisticStyle(library: StyleLibrary, id: string): ArtisticStyle | undefined {\n  return library.artisticStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ArtisticStyle | undefined"}, {"id": "packages/world-schema/src/style.ts::findColorPalette", "name": "findColorPalette", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a color palette by ID\n */\nexport function findColorPalette(library: StyleLibrary, id: string): ColorPalette | undefined {\n  return library.colorPalettes.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ColorPalette | undefined"}, {"id": "packages/world-schema/src/style.ts::findCompositionStyle", "name": "findCompositionStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a composition style by ID\n */\nexport function findCompositionStyle(library: StyleLibrary, id: string): CompositionStyle | undefined {\n  return library.compositionStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "CompositionStyle | undefined"}, {"id": "packages/world-schema/src/style.ts::findNarrativeStyle", "name": "findNarrativeStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a narrative style by ID\n */\nexport function findNarrativeStyle(library: StyleLibrary, id: string): NarrativeStyle | undefined {\n  return library.narrativeStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "NarrativeStyle | undefined"}, {"id": "packages/world-schema/src/style.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean"}, {"id": "packages/world-schema/src/style.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]"}, {"id": "packages/world-schema/src/style.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]"}, {"id": "packages/world-schema/src/styleExclusions.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean"}, {"id": "packages/world-schema/src/styleExclusions.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]"}, {"id": "packages/world-schema/src/styleExclusions.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]"}]