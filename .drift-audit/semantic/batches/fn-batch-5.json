[{"id": "apps/lore-weave/webui/src/components/dashboard/trace/SimulationTraceVisx.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/SimulationTraceVisx.jsx", "sourceCode": "/**\n * Main component with responsive wrapper\n */\nexport default function SimulationTraceVisx({\n  pressureUpdates = [],\n  epochStats = [],\n  templateApplications = [],\n  actionApplications = [],\n  systemActions = [],\n  onClose,\n}) {\n  // State\n  const [selectedTick, setSelectedTick] = useState(null);\n  const [lockedTick, setLockedTick] = useState(null);\n  const [hiddenPressures, setHiddenPressures] = useState(new Set());\n  const [hoveredEventId, setHoveredEventId] = useState(null);\n  const [selectedEventId, setSelectedEventId] = useState(null);\n  const [scrollOffset, setScrollOffset] = useState(null);\n  const [systemPanel, setSystemPanel] = useState(null); // null | 'activity' | 'plane-diffusion' | 'graph-contagion'\n  const [selectedDiffusionId, setSelectedDiffusionId] = useState(null);\n  const [selectedContagionId, setSelectedContagionId] = useState(null);\n  const [autoScaleColors, setAutoScaleColors] = useState(false);\n\n  // Derive available diffusion/contagion systems from what actually ran (has snapshot data in systemActions)\n  const diffusionSystemsWithData = useMemo(() => {\n    const systemsMap = new Map();\n    for (const action of systemActions) {\n      if (action.details?.diffusionSnapshot && !systemsMap.has(action.systemId)) {\n        systemsMap.set(action.systemId, {\n          id: action.systemId,\n          name: action.systemName,\n        });\n      }\n    }\n    return Array.from(systemsMap.values());\n  }, [systemActions]);\n\n  const contagionSystemsWithData = useMemo(() => {\n    const systemsMap = new Map();\n    for (const action of systemActions) {\n      if (action.details?.contagionSnapshot && !systemsMap.has(action.systemId)) {\n        systemsMap.set(action.systemId, {\n          id: action.systemId,\n          name: action.systemName,\n        });\n      }\n    }\n    return Array.from(systemsMap.values());\n  }, [systemActions]);\n\n  // Auto-select first available system if none selected\n  const activeDiffusionId = selectedDiffusionId ?? diffusionSystemsWithData[0]?.id ?? null;\n  const activeContagionId = selectedContagionId ?? contagionSystemsWithData[0]?.id ?? null;\n\n  const diffusionConfig = useMemo(\n    () => ({\n      name: diffusionSystemsWithData.find((s) => s.id === activeDiffusionId)?.name,\n    }),\n    [diffusionSystemsWithData, activeDiffusionId]\n  );\n\n  const contagionConfig = useMemo(\n    () => ({\n      name: contagionSystemsWithData.find((s) => s.id === activeContagionId)?.name,\n    }),\n    [contagionSystemsWithData, activeContagionId]\n  );\n\n  // Transform data\n  const {\n    data: pressureData,\n    pressureIds,\n    breakdownsByTick,\n  } = useMemo(() => transformPressureData(pressureUpdates), [pressureUpdates]);\n\n  const eventData = useMemo(\n    () => transformEventData(templateApplications, actionApplications, systemActions, pressureData),\n    [templateApplications, actionApplications, systemActions, pressureData]\n  );\n\n  const eraBoundaries = useMemo(\n    () => extractEraBoundaries(pressureUpdates, epochStats, systemActions),\n    [pressureUpdates, epochStats, systemActions]\n  );\n\n  // Get selected event for detail panel (template, action, or system action)\n  const selectedEvent = useMemo(() => {\n    const eventId = selectedEventId || hoveredEventId;\n    if (!eventId) return null;\n\n    // Check templates first\n    const templateEvent = eventData.template.find((e) => e.uniqueId === eventId);\n    if (templateEvent) {\n      return { type: \"template\", data: templateEvent.data };\n    }\n\n    // Check action applications\n    const actionEvent = eventData.action.find((e) => e.uniqueId === eventId);\n    if (actionEvent) {\n      return { type: \"action\", data: actionEvent.data };\n    }\n\n    // Check system actions\n    const systemEvent = eventData.system.find((e) => e.uniqueId === eventId);\n    if (systemEvent) {\n      return {\n        type: \"system\",\n        data: systemEvent.data,\n        isEraTransition: systemEvent.isEraTransition,\n      };\n    }\n\n    return null;\n  }, [eventData, selectedEventId, hoveredEventId]);\n\n  // Count era transitions for display\n  const eraTransitionCount = useMemo(\n    () => eventData.system.filter((e) => e.isEraTransition).length,\n    [eventData]\n  );\n\n  // Get max tick for slider (from pressure data or system actions)\n  const maxTick = useMemo(() => {\n    const pressureMax = pressureData.length > 0 ? Math.max(...pressureData.map((d) => d.tick)) : 0;\n    const systemMax = systemActions.length > 0 ? Math.max(...systemActions.map((a) => a.tick)) : 0;\n    return Math.max(pressureMax, systemMax, 1);\n  }, [pressureData, systemActions]);\n\n  // Get available ticks with visualization data for the active system\n  const availableVisTicks = useMemo(() => {\n    if (systemPanel === \"plane-diffusion\" && activeDiffusionId) {\n      return [\n        ...new Set(\n          systemActions\n            .filter((a) => a.systemId === activeDiffusionId && a.details?.diffusionSnapshot)\n            .map((a) => a.tick)\n        ),\n      ].sort((a, b) => a - b);\n    }\n    if (systemPanel === \"graph-contagion\" && activeContagionId) {\n      return [\n        ...new Set(\n          systemActions\n            .filter((a) => a.systemId === activeContagionId && a.details?.contagionSnapshot)\n            .map((a) => a.tick)\n        ),\n      ].sort((a, b) => a - b);\n    }\n    return [];\n  }, [systemPanel, activeDiffusionId, activeContagionId, systemActions]);\n\n  // Initialize lockedTick to maxTick when opening a visualization panel\n  // This ensures slider position matches displayed data\n  React.useEffect(() => {\n    if (\n      (systemPanel === \"plane-diffusion\" || systemPanel === \"graph-contagion\") &&\n      lockedTick === null\n    ) {\n      setLockedTick(maxTick);\n    }\n  }, [systemPanel, maxTick, lockedTick]);\n\n  // Handlers\n  const handleTickHover = useCallback((tick) => {\n    setSelectedTick(tick);\n  }, []);\n\n  const handleTickClick = useCallback(\n    (tick) => {\n      if (lockedTick === tick) {\n        setLockedTick(null);\n      } else {\n        setLockedTick(tick);\n        setSelectedTick(tick);\n      }\n    },\n    [lockedTick]\n  );\n\n  const handleEventHover = useCallback(\n    (eventId) => {\n      if (!selectedEventId) {\n        setHoveredEventId(eventId);\n      }\n    },\n    [selectedEventId]\n  );\n\n  const handleEventClick = useCallback(\n    (eventId) => {\n      if (selectedEventId === eventId) {\n        setSelectedEventId(null);\n      } else {\n        setSelectedEventId(eventId);\n      }\n    },\n    [selectedEventId]\n  );\n\n  const handleUnlock = useCallback(() => {\n    setLockedTick(null);\n  }, []);\n\n  const handleClearEvent = useCallback(() => {\n    setSelectedEventId(null);\n    setHoveredEventId(null);\n  }, []);\n\n  const togglePressure = useCallback((id) => {\n    setHiddenPressures((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) next.delete(id);\n      else next.add(id);\n      return next;\n    });\n  }, []);\n\n  return (\n    <div className=\"lw-trace-view-overlay\">\n      <div className=\"lw-trace-view\">\n        {/* Header */}\n        <div className=\"lw-trace-view-header\">\n          <div className=\"lw-trace-view-title\">\n            Simulation Trace\n            <span className=\"lw-trace-view-subtitle\">\n              {pressureData.length} ticks / {pressureIds.length} pressures /{\" \"}\n              {eventData.template.length} templates / {eventData.action.length} actions /{\" \"}\n              {eraTransitionCount} era transitions\n            </span>\n          </div>\n          <div className=\"lw-trace-view-header-actions\">\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"activity\" ? \"active\" : \"\"}`}\n              onClick={() => setSystemPanel(systemPanel === \"activity\" ? null : \"activity\")}\n            >\n              Activity\n            </button>\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"plane-diffusion\" ? \"active\" : \"\"} ${diffusionSystemsWithData.length > 0 ? \"has-data\" : \"\"}`}\n              onClick={() =>\n                setSystemPanel(systemPanel === \"plane-diffusion\" ? null : \"plane-diffusion\")\n              }\n              title={\n                diffusionSystemsWithData.length > 0\n                  ? `${diffusionSystemsWithData.length} system(s): ${diffusionSystemsWithData.map((s) => s.name).join(\", \")}`\n                  : \"No diffusion systems ran\"\n              }\n            >\n              Diffusion\n              {diffusionSystemsWithData.length > 0 && ` (${diffusionSystemsWithData.length})`}\n            </button>\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"graph-contagion\" ? \"active\" : \"\"} ${contagionSystemsWithData.length > 0 ? \"has-data\" : \"\"}`}\n              onClick={() =>\n                setSystemPanel(systemPanel === \"graph-contagion\" ? null : \"graph-contagion\")\n              }\n              title={\n                contagionSystemsWithData.length > 0\n                  ? `${contagionSystemsWithData.length} system(s): ${contagionSystemsWithData.map((s) => s.name).join(\", \")}`\n                  : \"No contagion systems ran\"\n              }\n            >\n              Contagion\n              {contagionSystemsWithData.length > 0 && ` (${contagionSystemsWithData.length})`}\n            </button>\n            <button className=\"lw-trace-view-close\" onClick={onClose}>\n              x\n            </button>\n          </div>\n        </div>\n\n        {/* Main content */}\n        <div className=\"lw-trace-view-content\">\n          {/* Left: Charts */}\n          <div className=\"lw-trace-view-charts\">\n            {/* Pressure toggles */}\n            <div className=\"lw-trace-view-toggles\">\n              {pressureIds.map((id, i) => {\n                const name = pressureData[0]?.[`${id}_name`] || id;\n                const isHidden = hiddenPressures.has(id);\n                return (\n                  <button\n                    key={id}\n                    className={`lw-trace-view-toggle ${isHidden ? \"hidden\" : \"\"}`}\n                    style={{\n                      '--st-toggle-border': PRESSURE_COLORS[i % PRESSURE_COLORS.length],\n                      '--st-toggle-bg': isHidden\n                        ? \"transparent\"\n                        : PRESSURE_COLORS[i % PRESSURE_COLORS.length] + \"20\",\n                    }}\n                    onClick={() => togglePressure(id)}\n                  >\n                    {name}\n                  </button>\n                );\n              })}\n            </div>\n\n            {/* Chart area */}\n            <div className={`lw-trace-view-chart-area ${lockedTick !== null ? \"locked\" : \"\"}`}>\n// ... (truncated)", "parameters": [{"name": "{\n  pressureUpdates = [],\n  epochStats = [],\n  templateApplications = [],\n  actionApplications = [],\n  systemActions = [],\n  onClose,\n}", "type": "{ pressureUpdates?: any[]; epochStats?: any[]; templateApplications?: any[]; actionApplications?: any[]; systemActions?: any[]; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@visx/responsive", "specifiers": ["ParentSize"], "category": "external"}, {"source": "./SimulationTraceVisx.css", "specifiers": [], "category": "internal"}, {"source": "./scales", "specifiers": ["createXScale", "createPressureYScale", "DEFAULT_MARGIN", "ERA_TIMELINE_HEIGHT"], "category": "internal"}, {"source": "./PressureChart", "specifiers": ["PressureChart"], "category": "internal"}, {"source": "./EraTimeline", "specifiers": ["EraTimeline"], "category": "internal"}, {"source": "../systems", "specifiers": ["SystemActivityPanel", "PlaneDiffusionVis", "GraphContagionVis"], "category": "internal"}]}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/TraceTooltip.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/TraceTooltip.jsx", "sourceCode": "/**\n * Simple tooltip component\n */\nexport default function TraceTooltip({ tooltipData, tooltipLeft, tooltipTop, tooltipOpen }) {\n  if (!tooltipOpen || !tooltipData) return null;\n\n  return (\n    <TooltipWithBounds left={tooltipLeft} top={tooltipTop} className=\"tt-tooltip\">\n      {tooltipData.type === \"tick\" && (\n        <div>\n          <div className=\"tt-tick-header\">Tick {tooltipData.tick}</div>\n          {tooltipData.pressures?.map((p, i) => (\n            <div key={i} className=\"tt-pressure-row\">\n              <span className=\"tt-pressure-name\" style={{ '--tt-pressure-color': p.color }}>{p.name}</span>\n              <span>{p.value?.toFixed(1)}</span>\n            </div>\n          ))}\n        </div>\n      )}\n      {tooltipData.type === \"event\" && (\n        <div>\n          <div className=\"tt-event-header\">\n            {tooltipData.eventType === \"template\" && \"\u25b2 \"}\n            {tooltipData.eventType === \"system\" && \"\u25c6 \"}\n            {tooltipData.eventType === \"action\" && \"\u25cf \"}\n            {tooltipData.label}\n          </div>\n          <div className=\"tt-event-tick\">Tick {tooltipData.tick}</div>\n        </div>\n      )}\n    </TooltipWithBounds>\n  );\n}", "parameters": [{"name": "{ tooltipData, tooltipLeft, tooltipTop, tooltipOpen }", "type": "{ tooltipData: any; tooltipLeft: any; tooltipTop: any; tooltipOpen: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@visx/tooltip", "specifiers": ["useTooltip", "TooltipWithBounds"], "category": "external"}, {"source": "./TraceTooltip.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/lib/derivation.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/derivation.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/derivation.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/generate.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./utils/rng.js", "specifiers": ["createRNG", "pickRandom"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization"], "category": "internal"}, {"source": "./phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "internal"}, {"source": "./markov-loader.js", "specifiers": ["preloadModels"], "category": "internal"}, {"source": "./derivation.js", "specifiers": ["applyDerivation", "isDerivationType", "DerivationType"], "category": "internal"}, {"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Culture", "Grammar", "LexemeList", "Profile", "StrategyGroup", "Strategy", "GenerateRequest", "GenerateResult", "NameDebugInfo", "GroupMatchDebug"], "category": "internal"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/generate.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./utils/rng.js", "specifiers": ["createRNG", "pickRandom"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization"], "category": "internal"}, {"source": "./phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "internal"}, {"source": "./markov-loader.js", "specifiers": ["preloadModels"], "category": "internal"}, {"source": "./derivation.js", "specifiers": ["applyDerivation", "isDerivationType", "DerivationType"], "category": "internal"}, {"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Culture", "Grammar", "LexemeList", "Profile", "StrategyGroup", "Strategy", "GenerateRequest", "GenerateResult", "NameDebugInfo", "GroupMatchDebug"], "category": "internal"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/generate.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./utils/rng.js", "specifiers": ["createRNG", "pickRandom"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization"], "category": "internal"}, {"source": "./phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "internal"}, {"source": "./markov-loader.js", "specifiers": ["preloadModels"], "category": "internal"}, {"source": "./derivation.js", "specifiers": ["applyDerivation", "isDerivationType", "DerivationType"], "category": "internal"}, {"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Culture", "Grammar", "LexemeList", "Profile", "StrategyGroup", "Strategy", "GenerateRequest", "GenerateResult", "NameDebugInfo", "GroupMatchDebug"], "category": "internal"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/generate.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./utils/rng.js", "specifiers": ["createRNG", "pickRandom"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization"], "category": "internal"}, {"source": "./phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "internal"}, {"source": "./markov-loader.js", "specifiers": ["preloadModels"], "category": "internal"}, {"source": "./derivation.js", "specifiers": ["applyDerivation", "isDerivationType", "DerivationType"], "category": "internal"}, {"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Culture", "Grammar", "LexemeList", "Profile", "StrategyGroup", "Strategy", "GenerateRequest", "GenerateResult", "NameDebugInfo", "GroupMatchDebug"], "category": "internal"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/generate.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/generate.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./utils/rng.js", "specifiers": ["createRNG", "pickRandom"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization"], "category": "internal"}, {"source": "./phonotactic-pipeline.js", "specifiers": ["generatePhonotacticName"], "category": "internal"}, {"source": "./markov-loader.js", "specifiers": ["preloadModels"], "category": "internal"}, {"source": "./derivation.js", "specifiers": ["applyDerivation", "isDerivationType", "DerivationType"], "category": "internal"}, {"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Culture", "Grammar", "LexemeList", "Profile", "StrategyGroup", "Strategy", "GenerateRequest", "GenerateResult", "NameDebugInfo", "GroupMatchDebug"], "category": "internal"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/index.ts::generate", "name": "generate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Main Generation Function\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names using a culture's configuration.\r\n *\r\n * Automatically preloads any Markov models referenced in grammars.\r\n *\r\n * @param culture - The culture containing domains, grammars, lexemes, profiles\r\n * @param request - Generation parameters\r\n * @returns Generated names and strategy usage statistics\r\n */\r\nexport async function generate(\r\n  culture: Culture,\r\n  request: GenerateRequest\r\n): Promise<GenerateResult> {\r\n  const {\r\n    profileId,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags = [],\r\n    context = {},\r\n    count = 10,\r\n    seed,\r\n  } = request;\r\n\r\n  // Find the profile using selection logic:\r\n  // 1. If profileId specified, use that\r\n  // 2. Otherwise, find first profile matching entityKind\r\n  // 3. Fall back to profile marked isDefault\r\n  // 4. Error if no match\r\n  const profile = selectProfile(culture.profiles, profileId, kind);\r\n\r\n  if (!profile) {\r\n    const availableProfiles = culture.profiles.map(p => {\r\n      const kindsSuffix = p.entityKinds?.length ? ` (${p.entityKinds.join(', ')})` : '';\r\n      return `${p.id}${kindsSuffix}${p.isDefault ? ' [default]' : ''}`;\r\n    }).join(', ');\r\n    throw new Error(\r\n      `No matching profile for entityKind \"${kind || '(none)'}\" in culture ${culture.id}. ` +\r\n      `Available profiles: ${availableProfiles || 'none'}. ` +\r\n      `Add entityKinds to a profile or mark one as isDefault.`\r\n    );\r\n  }\r\n\r\n  // Preload any Markov models referenced in grammars\r\n  const markovModels = await preloadModels(culture.grammars || []);\r\n\r\n  // Build generation context\r\n  const rng = createRNG(seed || `gen-${Date.now()}`);\r\n  const genContext: GenerationContext = {\r\n    rng,\r\n    domains: culture.domains,\r\n    grammars: culture.grammars,\r\n    lexemeLists: Object.values(culture.lexemeLists),\r\n    markovModels,\r\n    userContext: context,\r\n  };\r\n\r\n  // Find matching strategy group with debug info\r\n  const { matchingGroup, debugInfo: groupDebugInfo } = findMatchingGroup(\r\n    profile.strategyGroups,\r\n    kind,\r\n    subtype,\r\n    prominence,\r\n    tags\r\n  );\r\n\r\n  const names: string[] = [];\r\n  const debugInfo: NameDebugInfo[] = [];\r\n  const strategyUsage: Record<string, number> = {\r\n    grammar: 0,\r\n    phonotactic: 0,\r\n    markov: 0,\r\n    fallback: 0,\r\n  };\r\n\r\n  // Generate names\r\n  for (let i = 0; i < count; i++) {\r\n    const result = generateSingleName(\r\n      matchingGroup,\r\n      genContext,\r\n      i\r\n    );\r\n    names.push(result.name);\r\n    strategyUsage[result.strategyType] = (strategyUsage[result.strategyType] || 0) + 1;\r\n\r\n    // Build debug info for this name\r\n    debugInfo.push({\r\n      groupUsed: matchingGroup?.name || \"(fallback)\",\r\n      strategyUsed: result.strategyDesc,\r\n      strategyType: result.strategyType,\r\n      grammarId: result.grammarId,\r\n      domainId: result.domainId,\r\n      groupMatching: groupDebugInfo,\r\n    });\r\n  }\r\n\r\n  return { names, strategyUsage, debugInfo };\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "GenerateRequest", "optional": false}], "returnType": "Promise<GenerateResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateOne", "name": "generateOne", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a single name for a specific entity.\r\n * Convenience function for lore-weave integration.\r\n *\r\n * @param culture - The culture to use\r\n * @param request - Generation parameters (count is ignored, always returns 1)\r\n * @returns The generated name\r\n */\r\nexport async function generateOne(\r\n  culture: Culture,\r\n  request: Omit<GenerateRequest, \"count\">\r\n): Promise<string> {\r\n  const result = await generate(culture, { ...request, count: 1 });\r\n  return result.names[0];\r\n}", "parameters": [{"name": "culture", "type": "Culture", "optional": false}, {"name": "request", "type": "Omit<GenerateRequest, \"count\">", "optional": false}], "returnType": "Promise<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateFromDomain", "name": "generateFromDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Utility: Generate from Domain Directly\r\n// ============================================================================\r\n\r\n/**\r\n * Generate names directly from a domain (without profile).\r\n * Useful for testing domains in isolation.\r\n */\r\nexport function generateFromDomain(\r\n  domain: NamingDomain,\r\n  count: number = 10,\r\n  seed?: string\r\n): string[] {\r\n  const rng = createRNG(seed || `domain-${Date.now()}`);\r\n  const names: string[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    names.push(generatePhonotacticName(rng, domain));\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::testDomain", "name": "testDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Test a domain by generating samples and computing statistics.\r\n * Used by validation metrics.\r\n */\r\nexport function testDomain(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 100,\r\n  seed?: string\r\n): TestDomainResult {\r\n  const samples = generateFromDomain(domain, sampleSize, seed);\r\n  const uniqueSet = new Set(samples);\r\n\r\n  const lengths = samples.map((s) => s.length);\r\n  const totalLength = lengths.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    samples,\r\n    uniqueCount: uniqueSet.size,\r\n    avgLength: totalLength / samples.length,\r\n    minLength: Math.min(...lengths),\r\n    maxLength: Math.max(...lengths),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "TestDomainResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::previewGrammar", "name": "previewGrammar", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Preview a grammar by generating sample names.\r\n * Used by the UI to show live preview of grammar output.\r\n *\r\n * @returns Array of generated names (may contain duplicates if grammar is simple)\r\n */\r\nexport async function previewGrammar(\r\n  options: PreviewGrammarOptions\r\n): Promise<string[]> {\r\n  const { grammar, domains, lexemeLists, count = 8, seed } = options;\r\n\r\n  if (!grammar || !grammar.rules || Object.keys(grammar.rules).length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Preload Markov models if the grammar uses them\r\n  const markovModels = await preloadModels([grammar]);\r\n\r\n  const rng = createRNG(seed || `preview-${Date.now()}`);\r\n  const ctx: GenerationContext = {\r\n    rng,\r\n    domains: domains || [],\r\n    grammars: [grammar],\r\n    lexemeLists: lexemeLists || [],\r\n    markovModels,\r\n    userContext: {},\r\n  };\r\n\r\n  const names: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      const result = expandGrammar(grammar, ctx);\r\n      names.push(result.name);\r\n    } catch {\r\n      // Grammar might have unresolved references - skip\r\n    }\r\n  }\r\n\r\n  return names;\r\n}", "parameters": [{"name": "options", "type": "PreviewGrammarOptions", "optional": false}], "returnType": "Promise<string[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::agentive", "name": "agentive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply agentive transformation: one who does X\r\n * hunt \u2192 hunter, forge \u2192 forger, rend \u2192 render, cut \u2192 cutter\r\n */\r\nexport function agentive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_AGENTIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_AGENTIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'r'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ier'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  // Default: add 'er'\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::superlative", "name": "superlative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply superlative transformation: most X\r\n * deep \u2192 deepest, grim \u2192 grimmest, pale \u2192 palest\r\n */\r\nexport function superlative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_SUPERLATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_SUPERLATIVE[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'st'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"st\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'iest'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"iest\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"est\";\r\n  }\r\n\r\n  // Default: add 'est'\r\n  return word + \"est\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::comparative", "name": "comparative", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply comparative transformation: more X\r\n * dark \u2192 darker, swift \u2192 swifter\r\n */\r\nexport function comparative(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars\r\n  if (IRREGULAR_COMPARATIVE[lower]) {\r\n    return matchCase(word, IRREGULAR_COMPARATIVE[lower]);\r\n  }\r\n\r\n  // Same rules as superlative but with 'er'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"r\";\r\n  }\r\n\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ier\";\r\n  }\r\n\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"er\";\r\n  }\r\n\r\n  return word + \"er\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::gerund", "name": "gerund", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply gerund/present participle transformation: X-ing\r\n * burn \u2192 burning, forge \u2192 forging, run \u2192 running\r\n */\r\nexport function gerund(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 'ie' - change to 'ying'\r\n  if (lower.endsWith(\"ie\")) {\r\n    return word.slice(0, -2) + \"ying\";\r\n  }\r\n\r\n  // Ends in 'e' (but not 'ee') - drop 'e' and add 'ing'\r\n  if (lower.endsWith(\"e\") && !lower.endsWith(\"ee\")) {\r\n    return word.slice(0, -1) + \"ing\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ing\";\r\n  }\r\n\r\n  // Default: add 'ing'\r\n  return word + \"ing\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::past", "name": "past", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply past/passive transformation: X-ed\r\n * curse \u2192 cursed, hunt \u2192 hunted, cut \u2192 cut\r\n */\r\nexport function past(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Check irregulars first\r\n  if (IRREGULAR_PAST[lower]) {\r\n    return matchCase(word, IRREGULAR_PAST[lower]);\r\n  }\r\n\r\n  // Ends in 'e' - just add 'd'\r\n  if (lower.endsWith(\"e\")) {\r\n    return word + \"d\";\r\n  }\r\n\r\n  // Ends in 'y' after consonant - change to 'ied'\r\n  if (lower.endsWith(\"y\") && word.length > 1 && isConsonant(lower[lower.length - 2])) {\r\n    return word.slice(0, -1) + \"ied\";\r\n  }\r\n\r\n  // CVC pattern - double final consonant\r\n  if (shouldDoubleConsonant(word)) {\r\n    return word + word[word.length - 1] + \"ed\";\r\n  }\r\n\r\n  // Default: add 'ed'\r\n  return word + \"ed\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::possessive", "name": "possessive", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply possessive transformation: X's\r\n * storm \u2192 storm's, darkness \u2192 darkness'\r\n */\r\nexport function possessive(word: string): string {\r\n  const lower = word.toLowerCase();\r\n\r\n  // Ends in 's' or 'x' or 'z' - just add apostrophe\r\n  if (lower.endsWith(\"s\") || lower.endsWith(\"x\") || lower.endsWith(\"z\")) {\r\n    return word + \"'\";\r\n  }\r\n\r\n  // Default: add 's\r\n  return word + \"'s\";\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyDerivation", "name": "applyDerivation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Apply a derivation by name\r\n */\r\nexport function applyDerivation(\r\n  word: string,\r\n  derivationType: \"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"\r\n): string {\r\n  switch (derivationType) {\r\n    case \"er\":\r\n      return agentive(word);\r\n    case \"est\":\r\n      return superlative(word);\r\n    case \"comp\":\r\n      return comparative(word);\r\n    case \"ing\":\r\n      return gerund(word);\r\n    case \"ed\":\r\n      return past(word);\r\n    case \"poss\":\r\n      return possessive(word);\r\n    default:\r\n      return word;\r\n  }\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "derivationType", "type": "\"er\" | \"est\" | \"ing\" | \"ed\" | \"poss\" | \"comp\"", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::isDerivationType", "name": "isDerivationType", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Check if a string is a valid derivation type\r\n */\r\nexport function isDerivationType(s: string): s is DerivationType {\r\n  return DERIVATION_TYPES.includes(s as DerivationType);\r\n}", "parameters": [{"name": "s", "type": "string", "optional": false}], "returnType": "s is DerivationType", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/markov-loader-node.ts::loadModelFromFilesystem", "name": "loadModelFromFilesystem", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader-node.ts", "sourceCode": "/**\r\n * Load a model from the filesystem.\r\n */\r\nexport function loadModelFromFilesystem(modelId: string): MarkovModel | null {\r\n  const modelPath = path.join(modelsDir, `${modelId}.json`);\r\n\r\n  if (!fs.existsSync(modelPath)) {\r\n    console.warn(`Markov model '${modelId}' not found at ${modelPath}`);\r\n    return null;\r\n  }\r\n\r\n  const data = fs.readFileSync(modelPath, \"utf-8\");\r\n  return JSON.parse(data) as MarkovModel;\r\n}", "parameters": [{"name": "modelId", "type": "string", "optional": false}], "returnType": "MarkovModel | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["* as fs"], "category": "external"}, {"source": "path", "specifiers": ["* as path"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}, {"source": "./markov.js", "specifiers": ["MarkovModel"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::setMarkovBaseUrl", "name": "setMarkovBaseUrl", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Configure the base URL for browser model loading.\r\n * Call this before generating names in browser environment.\r\n */\r\nexport function setMarkovBaseUrl(baseUrl: string): void {\r\n  browserBaseUrl = baseUrl.replace(/\\/$/, \"\");\r\n}", "parameters": [{"name": "baseUrl", "type": "string", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::loadMarkovModel", "name": "loadMarkovModel", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Load a Markov model by ID.\r\n */\r\nexport async function loadMarkovModel(\r\n  modelId: MarkovModelId\r\n): Promise<MarkovModel | null> {\r\n  // Check cache first\r\n  if (modelCache.has(modelId)) {\r\n    return modelCache.get(modelId)!;\r\n  }\r\n\r\n  try {\r\n    const model = isBrowser\r\n      ? await loadFromBrowser(modelId)\r\n      : await loadFromNode(modelId);\r\n\r\n    if (model) {\r\n      modelCache.set(modelId, model);\r\n    }\r\n    return model;\r\n  } catch (error) {\r\n    console.warn(`Failed to load Markov model '${modelId}':`, error);\r\n    return null;\r\n  }\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "Promise<MarkovModel | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::extractMarkovModelIds", "name": "extractMarkovModelIds", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Grammar Scanning\r\n// ============================================================================\r\n\r\n/**\r\n * Extract Markov model IDs referenced in grammars.\r\n */\r\nexport function extractMarkovModelIds(grammars: Grammar[]): MarkovModelId[] {\r\n  const modelIds = new Set<MarkovModelId>();\r\n\r\n  for (const grammar of grammars) {\r\n    for (const productions of Object.values(grammar.rules || {})) {\r\n      for (const production of productions) {\r\n        for (const token of production) {\r\n          const match = token.match(/markov:([a-z]+)/);\r\n          if (match) {\r\n            modelIds.add(match[1] as MarkovModelId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(modelIds);\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "MarkovModelId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::preloadModels", "name": "preloadModels", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Preloading\r\n// ============================================================================\r\n\r\n/**\r\n * Preload all Markov models referenced in grammars.\r\n */\r\nexport async function preloadModels(\r\n  grammars: Grammar[]\r\n): Promise<Map<string, MarkovModel>> {\r\n  const modelIds = extractMarkovModelIds(grammars);\r\n  const models = new Map<string, MarkovModel>();\r\n\r\n  await Promise.all(\r\n    modelIds.map(async (id) => {\r\n      const model = await loadMarkovModel(id);\r\n      if (model) {\r\n        models.set(id, model);\r\n      }\r\n    })\r\n  );\r\n\r\n  return models;\r\n}", "parameters": [{"name": "grammars", "type": "Grammar[]", "optional": false}], "returnType": "Promise<Map<string, MarkovModel>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::isModelCached", "name": "isModelCached", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "// ============================================================================\r\n// Cache Management\r\n// ============================================================================\r\n\r\n/**\r\n * Check if a model is cached.\r\n */\r\nexport function isModelCached(modelId: MarkovModelId): boolean {\r\n  return modelCache.has(modelId);\r\n}", "parameters": [{"name": "modelId", "type": "MarkovModelId", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov-loader.ts::clearModelCache", "name": "clearModelCache", "kind": "function", "filePath": "apps/name-forge/lib/markov-loader.ts", "sourceCode": "/**\r\n * Clear the model cache.\r\n */\r\nexport function clearModelCache(): void {\r\n  modelCache.clear();\r\n}", "parameters": [], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./markov.js", "specifiers": ["MarkovModel", "MarkovModelId"], "category": "internal"}, {"source": "./types/project.js", "specifiers": ["Grammar"], "category": "internal"}]}, {"id": "apps/name-forge/lib/markov.ts::generateFromMarkov", "name": "generateFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate a name from a Markov model\n */\nexport function generateFromMarkov(\n  model: MarkovModel,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string {\n  const { minLength = 3, maxLength = 12, seed } = options;\n  const rng = seed ? seedrandom(seed) : Math.random;\n\n  // Pick start state\n  let state = weightedRandom(model.startStates, rng);\n  let result = \"\";\n\n  for (let i = 0; i < maxLength + model.order; i++) {\n    const nextProbs = model.transitions[state];\n    if (!nextProbs) break;\n\n    const next = weightedRandom(nextProbs, rng);\n    if (next === END) {\n      if (result.length >= minLength) break;\n      // Too short, continue (might get stuck in rare cases)\n      continue;\n    }\n\n    result += next;\n    state = state.slice(1) + next;\n  }\n\n  // Capitalize first letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/markov.ts::generateNamesFromMarkov", "name": "generateNamesFromMarkov", "kind": "function", "filePath": "apps/name-forge/lib/markov.ts", "sourceCode": "/**\n * Generate multiple unique names from a Markov model\n */\nexport function generateNamesFromMarkov(\n  model: MarkovModel,\n  count: number,\n  options: {\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  } = {}\n): string[] {\n  const names = new Set<string>();\n  const baseSeed = options.seed || String(Date.now());\n  let attempts = 0;\n  const maxAttempts = count * 10;\n\n  while (names.size < count && attempts < maxAttempts) {\n    const name = generateFromMarkov(model, {\n      ...options,\n      seed: `${baseSeed}-${attempts}`,\n    });\n\n    if (name.length >= (options.minLength || 3)) {\n      names.add(name);\n    }\n    attempts++;\n  }\n\n  return Array.from(names);\n}", "parameters": [{"name": "model", "type": "MarkovModel", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "options", "type": "{\n    minLength?: number;\n    maxLength?: number;\n    seed?: string;\n  }", "optional": true}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphology", "name": "applyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphological structure to a base word (root)\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphology(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const structure = pickWeighted(rng, profile.structure, profile.structureWeights);\r\n  const state: MorphState = { result: \"\", parts: [], syllables: [] };\r\n  const tokens = structure.split(\"-\");\r\n\r\n  for (const token of tokens) {\r\n    switch (token) {\r\n      case \"root\": applyRootToken(state, root, rootSyllables); break;\r\n      case \"prefix\": applyPrefixToken(state, rng, profile); break;\r\n      case \"suffix\": applySuffixToken(state, rng, profile); break;\r\n      case \"infix\": applyInfixToken(state, rng, profile, root); break;\r\n      case \"wordroot\": applyWordrootToken(state, rng, profile, root, rootSyllables); break;\r\n      case \"honorific\": applyHonorificToken(state, rng, profile); break;\r\n      default: break;\r\n    }\r\n  }\r\n\r\n  return { result: state.result, structure, parts: state.parts, syllables: state.syllables };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["MorphologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "pickRandom"], "category": "internal"}]}, {"id": "apps/name-forge/lib/morphology.ts::applyMorphologyBest", "name": "applyMorphologyBest", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply morphology with multiple candidates and pick best\r\n * Useful for avoiding overly long or awkward combinations\r\n * @param rootSyllables - Original syllables from phonology (used to track syllable boundaries)\r\n */\r\nexport function applyMorphologyBest(\r\n  rng: () => number,\r\n  root: string,\r\n  profile: MorphologyProfile,\r\n  candidateCount: number = 3,\r\n  maxLength: number = 20,\r\n  rootSyllables?: string[]\r\n): { result: string; structure: string; parts: string[]; syllables: string[] } {\r\n  const candidates: {\r\n    result: string;\r\n    structure: string;\r\n    parts: string[];\r\n    syllables: string[];\r\n    score: number;\r\n  }[] = [];\r\n\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    const morphed = applyMorphology(rng, root, profile, rootSyllables);\r\n\r\n    // Score based on length (prefer moderate length)\r\n    let score = 1.0;\r\n    if (morphed.result.length > maxLength) {\r\n      score *= 0.5; // Penalize overly long names\r\n    }\r\n    if (morphed.result.length < 3) {\r\n      score *= 0.5; // Penalize overly short names\r\n    }\r\n\r\n    candidates.push({ ...morphed, score });\r\n  }\r\n\r\n  // Pick weighted by score\r\n  const scores = candidates.map((c) => c.score);\r\n  const totalScore = scores.reduce((sum, s) => sum + s, 0);\r\n\r\n  const r = rng() * totalScore;\r\n  let cumulative = 0;\r\n  for (const candidate of candidates) {\r\n    cumulative += candidate.score;\r\n    if (r < cumulative) {\r\n      return {\r\n        result: candidate.result,\r\n        structure: candidate.structure,\r\n        parts: candidate.parts,\r\n        syllables: candidate.syllables,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return {\r\n    result: candidates[0].result,\r\n    structure: candidates[0].structure,\r\n    parts: candidates[0].parts,\r\n    syllables: candidates[0].syllables,\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}, {"name": "maxLength", "type": "number", "optional": true}, {"name": "rootSyllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; structure: string; parts: string[]; syllables: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["MorphologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "pickRandom"], "category": "internal"}]}, {"id": "apps/name-forge/lib/morphology.ts::canApplyMorphology", "name": "canApplyMorphology", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Check if a morphology profile can actually modify names\r\n * (i.e., has at least some affixes or structures beyond \"root\")\r\n */\r\nexport function canApplyMorphology(profile: MorphologyProfile): boolean {\r\n  // Check if there are any non-root structures\r\n  const hasComplexStructures = profile.structure.some(\r\n    (s) => s !== \"root\" && s.includes(\"-\")\r\n  );\r\n\r\n  if (!hasComplexStructures) {\r\n    return false;\r\n  }\r\n\r\n  // Check if there are any affixes available\r\n  const hasAffixes =\r\n    (profile.prefixes && profile.prefixes.length > 0) ||\r\n    (profile.suffixes && profile.suffixes.length > 0) ||\r\n    (profile.infixes && profile.infixes.length > 0) ||\r\n    (profile.wordRoots && profile.wordRoots.length > 0);\r\n\r\n  return Boolean(hasAffixes);\r\n}", "parameters": [{"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["MorphologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "pickRandom"], "category": "internal"}]}, {"id": "apps/name-forge/lib/morphology.ts::generateCompound", "name": "generateCompound", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Generate a compound name (root-root structure)\r\n * Useful for location names and titles\r\n */\r\nexport function generateCompound(\r\n  rng: () => number,\r\n  root1: string,\r\n  root2: string,\r\n  separator: string = \"\"\r\n): string {\r\n  return root1 + separator + root2;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "root1", "type": "string", "optional": false}, {"name": "root2", "type": "string", "optional": false}, {"name": "separator", "type": "string", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["MorphologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "pickRandom"], "category": "internal"}]}, {"id": "apps/name-forge/lib/morphology.ts::applyHonorific", "name": "applyHonorific", "kind": "function", "filePath": "apps/name-forge/lib/morphology.ts", "sourceCode": "/**\r\n * Apply honorific prefix\r\n */\r\nexport function applyHonorific(\r\n  rng: () => number,\r\n  name: string,\r\n  profile: MorphologyProfile\r\n): string {\r\n  if (!profile.honorifics || profile.honorifics.length === 0) {\r\n    return name;\r\n  }\r\n\r\n  const honorific = pickRandom(rng, profile.honorifics);\r\n  return `${honorific} ${name}`;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "MorphologyProfile", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["MorphologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "pickRandom"], "category": "internal"}]}, {"id": "apps/name-forge/lib/parameter-encoder.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimizer/optimization.js", "specifiers": ["ParameterVector", "ParameterBounds"], "category": "internal"}]}, {"id": "apps/name-forge/lib/parameter-encoder.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimizer/optimization.js", "specifiers": ["ParameterVector", "ParameterBounds"], "category": "internal"}]}, {"id": "apps/name-forge/lib/parameter-encoder.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimizer/optimization.js", "specifiers": ["ParameterVector", "ParameterBounds"], "category": "internal"}]}, {"id": "apps/name-forge/lib/parameter-encoder.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/parameter-encoder.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimizer/optimization.js", "specifiers": ["ParameterVector", "ParameterBounds"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllConsonants", "name": "getAllConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all consonants as flat array\n */\nexport function getAllConsonants(): string[] {\n  const all: string[] = [];\n  all.push(...CONSONANT_LIBRARY.plosives.voiceless);\n  all.push(...CONSONANT_LIBRARY.plosives.voiced);\n  all.push(...CONSONANT_LIBRARY.nasals);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiceless);\n  all.push(...CONSONANT_LIBRARY.fricatives.voiced);\n  all.push(...CONSONANT_LIBRARY.affricates);\n  all.push(...CONSONANT_LIBRARY.approximants);\n  all.push(...CONSONANT_LIBRARY.trills);\n  all.push(...CONSONANT_LIBRARY.fantasy);\n  return [...new Set(all)]; // Remove duplicates\n}", "parameters": [], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllVowels", "name": "getAllVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all vowels as flat array\n */\nexport function getAllVowels(): string[] {\n  const all: string[] = [];\n  all.push(...VOWEL_LIBRARY.basic);\n  all.push(...VOWEL_LIBRARY.front);\n  all.push(...VOWEL_LIBRARY.central);\n  all.push(...VOWEL_LIBRARY.back);\n  all.push(...VOWEL_LIBRARY.long);\n  all.push(...VOWEL_LIBRARY.umlauts);\n  all.push(...VOWEL_LIBRARY.diphthongs);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllTemplates", "name": "getAllTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all templates as flat array\n */\nexport function getAllTemplates(): string[] {\n  const all: string[] = [];\n  all.push(...TEMPLATE_LIBRARY.simple);\n  all.push(...TEMPLATE_LIBRARY.complexOnset);\n  all.push(...TEMPLATE_LIBRARY.complexCoda);\n  all.push(...TEMPLATE_LIBRARY.complex);\n  all.push(...TEMPLATE_LIBRARY.vowelHeavy);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllClusters", "name": "getAllClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all clusters as flat array\n */\nexport function getAllClusters(): string[] {\n  const all: string[] = [];\n  all.push(...CLUSTER_LIBRARY.onsets.stopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.sStop);\n  all.push(...CLUSTER_LIBRARY.onsets.sStopLiquid);\n  all.push(...CLUSTER_LIBRARY.onsets.other);\n  all.push(...CLUSTER_LIBRARY.codas.liquidStop);\n  all.push(...CLUSTER_LIBRARY.codas.nasalStop);\n  all.push(...CLUSTER_LIBRARY.codas.stopS);\n  all.push(...CLUSTER_LIBRARY.codas.other);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAllStructures", "name": "getAllStructures", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get all structures as flat array\n */\nexport function getAllStructures(): string[] {\n  const all: string[] = [];\n  all.push(...STRUCTURE_LIBRARY.simple);\n  all.push(...STRUCTURE_LIBRARY.prefixed);\n  all.push(...STRUCTURE_LIBRARY.suffixed);\n  all.push(...STRUCTURE_LIBRARY.compound);\n  all.push(...STRUCTURE_LIBRARY.complex);\n  return [...new Set(all)];\n}", "parameters": [], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableConsonants", "name": "getAvailableConsonants", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "/**\n * Get phonemes not currently in a domain\n */\nexport function getAvailableConsonants(currentConsonants: string[]): string[] {\n  const all = getAllConsonants();\n  return all.filter(c => !currentConsonants.includes(c));\n}", "parameters": [{"name": "currentConsonants", "type": "string[]", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableVowels", "name": "getAvailableVowels", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableVowels(currentVowels: string[]): string[] {\n  const all = getAllVowels();\n  return all.filter(v => !currentVowels.includes(v));\n}", "parameters": [{"name": "currentVowels", "type": "string[]", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableTemplates", "name": "getAvailableTemplates", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableTemplates(currentTemplates: string[]): string[] {\n  const all = getAllTemplates();\n  return all.filter(t => !currentTemplates.includes(t));\n}", "parameters": [{"name": "currentTemplates", "type": "string[]", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phoneme-library.ts::getAvailableClusters", "name": "getAvailableClusters", "kind": "function", "filePath": "apps/name-forge/lib/phoneme-library.ts", "sourceCode": "export function getAvailableClusters(currentClusters: string[]): string[] {\n  const all = getAllClusters();\n  return all.filter(c => !currentClusters.includes(c));\n}", "parameters": [{"name": "currentClusters", "type": "string[]", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/phonology.ts::generateSyllable", "name": "generateSyllable", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a single syllable from a phonology profile\r\n */\r\nexport function generateSyllable(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): SyllableResult {\r\n  // Pick a syllable template\r\n  const template = pickWeighted(\r\n    rng,\r\n    profile.syllableTemplates,\r\n    profile.templateWeights\r\n  );\r\n\r\n  // Build syllable by replacing C and V with phonemes\r\n  let syllable = \"\";\r\n  for (const symbol of template) {\r\n    if (symbol === \"C\") {\r\n      // Pick a consonant\r\n      const consonant = pickWeighted(\r\n        rng,\r\n        profile.consonants,\r\n        profile.consonantWeights\r\n      );\r\n      syllable += consonant;\r\n    } else if (symbol === \"V\") {\r\n      // Pick a vowel\r\n      const vowel = pickWeighted(rng, profile.vowels, profile.vowelWeights);\r\n      syllable += vowel;\r\n    } else {\r\n      // Literal character (for templates like \"CVC-\")\r\n      syllable += symbol;\r\n    }\r\n  }\r\n\r\n  return { syllable, template };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "SyllableResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "randomInt"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["hasForbiddenCluster", "hasFavoredCluster"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonology.ts::generateWord", "name": "generateWord", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a multi-syllable word from a phonology profile\r\n */\r\nexport function generateWord(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  maxAttempts: number = 50\r\n): string {\r\n  // Pick syllable count from length range\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  let attempts = 0;\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n\r\n    let word = \"\";\r\n    let valid = true;\r\n\r\n    // Generate syllables one by one\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const { syllable } = generateSyllable(rng, profile);\r\n\r\n      // Check if this syllable would create a forbidden cluster\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      word += syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      // Final check: does the complete word violate forbidden clusters?\r\n      if (\r\n        profile.forbiddenClusters &&\r\n        hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      return word;\r\n    }\r\n  }\r\n\r\n  // If we failed to generate a valid word, fall back to a simple single syllable\r\n  const { syllable } = generateSyllable(rng, profile);\r\n  return syllable;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "maxAttempts", "type": "number", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "randomInt"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["hasForbiddenCluster", "hasFavoredCluster"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonology.ts::generateWordWithFavoredClusters", "name": "generateWordWithFavoredClusters", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate multiple word candidates and pick the best one based on favored clusters\r\n */\r\nexport function generateWordWithFavoredClusters(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  candidateCount: number = 5\r\n): string {\r\n  // If no favored clusters, just generate one word\r\n  if (!profile.favoredClusters || profile.favoredClusters.length === 0) {\r\n    return generateWord(rng, profile);\r\n  }\r\n\r\n  // Generate multiple candidates\r\n  const candidates: string[] = [];\r\n  for (let i = 0; i < candidateCount; i++) {\r\n    candidates.push(generateWord(rng, profile));\r\n  }\r\n\r\n  // Calculate scores based on favored clusters\r\n  const boost = profile.favoredClusterBoost ?? 2.0;\r\n  const scores = candidates.map((word) => {\r\n    const hasFavored = hasFavoredCluster(word, profile.favoredClusters!);\r\n    return hasFavored ? boost : 1.0;\r\n  });\r\n\r\n  // Pick a candidate weighted by scores\r\n  return pickWeighted(rng, candidates, scores);\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "candidateCount", "type": "number", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "randomInt"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["hasForbiddenCluster", "hasFavoredCluster"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonology.ts::generateWords", "name": "generateWords", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Generate a batch of words for sampling/validation\r\n */\r\nexport function generateWords(\r\n  rng: () => number,\r\n  profile: PhonologyProfile,\r\n  count: number\r\n): string[] {\r\n  const words: string[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    words.push(generateWordWithFavoredClusters(rng, profile));\r\n  }\r\n  return words;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "randomInt"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["hasForbiddenCluster", "hasFavoredCluster"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonology.ts::generateWordWithDebug", "name": "generateWordWithDebug", "kind": "function", "filePath": "apps/name-forge/lib/phonology.ts", "sourceCode": "/**\r\n * Get debug info about syllable generation\r\n */\r\nexport function generateWordWithDebug(\r\n  rng: () => number,\r\n  profile: PhonologyProfile\r\n): { word: string; syllables: string[]; templates: string[] } {\r\n  const [minLength, maxLength] = profile.lengthRange;\r\n  const syllableCount = randomInt(rng, minLength, maxLength);\r\n\r\n  const syllables: string[] = [];\r\n  const templates: string[] = [];\r\n  let word = \"\";\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 50;\r\n\r\n  while (attempts < maxAttempts) {\r\n    attempts++;\r\n    syllables.length = 0;\r\n    templates.length = 0;\r\n    word = \"\";\r\n    let valid = true;\r\n\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const result = generateSyllable(rng, profile);\r\n\r\n      if (\r\n        wouldCreateForbiddenCluster(\r\n          word,\r\n          result.syllable,\r\n          profile.forbiddenClusters\r\n        )\r\n      ) {\r\n        valid = false;\r\n        break;\r\n      }\r\n\r\n      syllables.push(result.syllable);\r\n      templates.push(result.template);\r\n      word += result.syllable;\r\n    }\r\n\r\n    if (valid) {\r\n      if (\r\n        !profile.forbiddenClusters ||\r\n        !hasForbiddenCluster(word, profile.forbiddenClusters)\r\n      ) {\r\n        return { word, syllables, templates };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  const result = generateSyllable(rng, profile);\r\n  return {\r\n    word: result.syllable,\r\n    syllables: [result.syllable],\r\n    templates: [result.template],\r\n  };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "{ word: string; syllables: string[]; templates: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["pickWeighted", "randomInt"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["hasForbiddenCluster", "hasFavoredCluster"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::executePhonotacticPipeline", "name": "executePhonotacticPipeline", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Execute the full phonotactic name generation pipeline\n *\n * This is the single source of truth for generating names from a domain.\n * All callers should use this function rather than calling phonology,\n * morphology, and style separately.\n *\n * @param rng - Random number generator function\n * @param domain - The naming domain configuration\n * @param options - Optional settings\n * @returns Generated name with debug information\n */\nexport function executePhonotacticPipeline(\n  rng: () => number,\n  domain: NamingDomain,\n  options: {\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  } = {}\n): PipelineResult {\n  const {\n    morphologyCandidates = 3,\n    maxMorphologyLength = 20,\n  } = options;\n\n  // Phase 1: Generate phonological base with syllables\n  const { word, syllables, templates } = generateWordWithDebug(rng, domain.phonology);\n\n  // Phase 2: Apply morphology (if configured), tracking syllables through\n  let morphedWord = word;\n  let morphedSyllables = syllables;\n  let morphologyStructure = \"root\";\n  let morphologyParts = [`root:${word}`];\n\n  if (canApplyMorphology(domain.morphology)) {\n    const morphed = applyMorphologyBest(\n      rng,\n      word,\n      domain.morphology,\n      morphologyCandidates,\n      maxMorphologyLength,\n      syllables\n    );\n    morphedWord = morphed.result;\n    morphedSyllables = morphed.syllables;\n    morphologyStructure = morphed.structure;\n    morphologyParts = morphed.parts;\n  }\n\n  // Phase 3: Apply style transforms with correct syllable boundaries\n  const { result: name, transforms } = applyStyle(\n    rng,\n    morphedWord,\n    domain.style,\n    morphedSyllables\n  );\n\n  return {\n    name,\n    debug: {\n      rawWord: word,\n      syllables,\n      templates,\n      morphedWord,\n      morphedSyllables,\n      morphologyStructure,\n      morphologyParts,\n      styleTransforms: transforms,\n    },\n  };\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "options", "type": "{\n    /** Number of morphology candidates to generate (default: 3) */\n    morphologyCandidates?: number;\n    /** Maximum name length for morphology scoring (default: 20) */\n    maxMorphologyLength?: number;\n  }", "optional": true}], "returnType": "PipelineResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./phonology.js", "specifiers": ["generateWordWithDebug"], "category": "internal"}, {"source": "./morphology.js", "specifiers": ["applyMorphologyBest", "canApplyMorphology"], "category": "internal"}, {"source": "./style.js", "specifiers": ["applyStyle"], "category": "internal"}]}, {"id": "apps/name-forge/lib/phonotactic-pipeline.ts::generatePhonotacticName", "name": "generatePhonotacticName", "kind": "function", "filePath": "apps/name-forge/lib/phonotactic-pipeline.ts", "sourceCode": "/**\n * Simple wrapper that returns just the name string\n * For callers that don't need debug info\n */\nexport function generatePhonotacticName(\n  rng: () => number,\n  domain: NamingDomain\n): string {\n  return executePhonotacticPipeline(rng, domain).name;\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./phonology.js", "specifiers": ["generateWordWithDebug"], "category": "internal"}, {"source": "./morphology.js", "specifiers": ["applyMorphologyBest", "canApplyMorphology"], "category": "internal"}, {"source": "./style.js", "specifiers": ["applyStyle"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::countMaxConsonantCluster", "name": "countMaxConsonantCluster", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Count maximum consecutive consonants in a name\r\n */\r\nexport function countMaxConsonantCluster(name: string): number {\r\n  let maxCluster = 0;\r\n  let currentCluster = 0;\r\n\r\n  for (const char of name.toLowerCase()) {\r\n    if (isVowel(char)) {\r\n      maxCluster = Math.max(maxCluster, currentCluster);\r\n      currentCluster = 0;\r\n    } else if (char.match(/[a-z]/)) {\r\n      // Only count letters, skip apostrophes/hyphens\r\n      currentCluster++;\r\n    }\r\n  }\r\n\r\n  return Math.max(maxCluster, currentCluster);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::checkVowelSpacing", "name": "checkVowelSpacing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Check vowel spacing (max consonants between vowels)\r\n */\r\nexport function checkVowelSpacing(name: string): number {\r\n  const chars = name.toLowerCase().split(\"\");\r\n  let maxGap = 0;\r\n  let currentGap = 0;\r\n  let foundVowel = false;\r\n\r\n  for (const char of chars) {\r\n    if (isVowel(char)) {\r\n      maxGap = Math.max(maxGap, currentGap);\r\n      currentGap = 0;\r\n      foundVowel = true;\r\n    } else if (char.match(/[a-z]/)) {\r\n      if (foundVowel) {\r\n        currentGap++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return maxGap;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreSonoritySequencing", "name": "scoreSonoritySequencing", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score sonority sequencing violations\r\n *\r\n * Checks if syllables follow natural sonority rises/falls:\r\n * - Onsets should have rising sonority\r\n * - Codas should have falling sonority\r\n *\r\n * Returns: normalized score 0-1 (1 = perfect, 0 = many violations)\r\n */\r\nexport function scoreSonoritySequencing(\r\n  name: string,\r\n  phonemes: string[],\r\n  customRanks?: Record<string, number>\r\n): number {\r\n  if (phonemes.length === 0) return 1.0;\r\n\r\n  let violations = 0;\r\n  let transitions = 0;\r\n\r\n  // Scan through phoneme sequence\r\n  for (let i = 0; i < phonemes.length - 1; i++) {\r\n    const current = phonemes[i];\r\n    const next = phonemes[i + 1];\r\n\r\n    const currentSonority = getSonority(current, customRanks);\r\n    const nextSonority = getSonority(next, customRanks);\r\n\r\n    transitions++;\r\n\r\n    // If we're going from consonant to consonant\r\n    if (currentSonority < 5 && nextSonority < 5) {\r\n      // In onset (start of syllable), sonority should rise\r\n      // In coda (end of syllable), sonority should fall\r\n      // We penalize plateaus or inversions in consonant clusters\r\n      if (nextSonority < currentSonority) {\r\n        violations++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (transitions === 0) return 1.0;\r\n  return Math.max(0, 1 - violations / transitions);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "customRanks", "type": "Record<string, number>", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreTemplateLegality", "name": "scoreTemplateLegality", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Score template legality\r\n *\r\n * Checks if the name can be decomposed into allowed syllable templates.\r\n * Uses the phonology profile's syllable templates.\r\n *\r\n * Returns: 0-1 score (1 = fully legal, 0 = no templates match)\r\n */\r\nexport function scoreTemplateLegality(\r\n  name: string,\r\n  syllables: string[],\r\n  allowedTemplates: string[]\r\n): number {\r\n  if (syllables.length === 0) return 0;\r\n\r\n  let matchedSyllables = 0;\r\n\r\n  for (const syllable of syllables) {\r\n    // Convert syllable to template pattern (C/V)\r\n    const pattern = syllable\r\n      .split(\"\")\r\n      .map((char) => (isVowel(char) ? \"V\" : \"C\"))\r\n      .join(\"\");\r\n\r\n    // Check if pattern matches any allowed template\r\n    if (allowedTemplates.includes(pattern)) {\r\n      matchedSyllables++;\r\n    }\r\n  }\r\n\r\n  return matchedSyllables / syllables.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "allowedTemplates", "type": "string[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::scoreHarmonicConstraints", "name": "scoreHarmonicConstraints", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Compute harmonic constraint violations\r\n *\r\n * Checks culture-specific phonotactic rules:\r\n * - Max consonant cluster size\r\n * - Vowel spacing requirements\r\n *\r\n * Returns: 0-1 score (1 = no violations, 0 = many violations)\r\n */\r\nexport function scoreHarmonicConstraints(\r\n  name: string,\r\n  profile: PhonologyProfile\r\n): number {\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  const actualMaxCluster = countMaxConsonantCluster(name);\r\n  const actualVowelGap = checkVowelSpacing(name);\r\n\r\n  let violations = 0;\r\n\r\n  // Penalize exceeding max consonant cluster\r\n  if (actualMaxCluster > maxConsonantCluster) {\r\n    violations += actualMaxCluster - maxConsonantCluster;\r\n  }\r\n\r\n  // Penalize exceeding vowel spacing\r\n  if (actualVowelGap > minVowelSpacing) {\r\n    violations += actualVowelGap - minVowelSpacing;\r\n  }\r\n\r\n  // Normalize: assume max 5 violations is very bad\r\n  return Math.max(0, 1 - violations / 5);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::scorePronounceability", "name": "scorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "/**\r\n * Combined pronounceability score\r\n *\r\n * Weights:\r\n * - 30% template legality (structural correctness)\r\n * - 30% sonority sequencing (natural flow)\r\n * - 40% harmonic constraints (culture-specific rules)\r\n *\r\n * Returns: 0-1 score (1 = highly pronounceable)\r\n */\r\nexport function scorePronounceability(\r\n  name: string,\r\n  syllables: string[],\r\n  phonemes: string[],\r\n  profile: PhonologyProfile\r\n): number {\r\n  const templateScore = scoreTemplateLegality(name, syllables, profile.syllableTemplates);\r\n  const sonorityScore = scoreSonoritySequencing(name, phonemes, profile.sonorityRanks);\r\n  const harmonicScore = scoreHarmonicConstraints(name, profile);\r\n\r\n  // Weighted combination\r\n  return 0.3 * templateScore + 0.3 * sonorityScore + 0.4 * harmonicScore;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}, {"name": "phonemes", "type": "string[]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/pronounceability.ts::batchScorePronounceability", "name": "batchScorePronounceability", "kind": "function", "filePath": "apps/name-forge/lib/pronounceability.ts", "sourceCode": "export function batchScorePronounceability(\r\n  names: string[],\r\n  syllablesPerName: string[][],\r\n  phonemesPerName: string[][],\r\n  profile: PhonologyProfile\r\n): PronounceabilityReport {\r\n  const scores = names.map((name, i) =>\r\n    scorePronounceability(name, syllablesPerName[i] ?? [], phonemesPerName[i] ?? [], profile)\r\n  );\r\n\r\n  scores.sort((a, b) => a - b);\r\n\r\n  const maxConsonantCluster = profile.maxConsonantCluster ?? 3;\r\n  const minVowelSpacing = profile.minVowelSpacing ?? 3;\r\n\r\n  let tooManyConsonants = 0;\r\n  let poorVowelSpacing = 0;\r\n\r\n  for (const name of names) {\r\n    if (countMaxConsonantCluster(name) > maxConsonantCluster) {\r\n      tooManyConsonants++;\r\n    }\r\n    if (checkVowelSpacing(name) > minVowelSpacing) {\r\n      poorVowelSpacing++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    avgScore: scores.reduce((a, b) => a + b, 0) / scores.length,\r\n    minScore: scores[0],\r\n    maxScore: scores[scores.length - 1],\r\n    p5: scores[Math.floor(scores.length * 0.05)],\r\n    p95: scores[Math.floor(scores.length * 0.95)],\r\n    violations: {\r\n      tooManyConsonants,\r\n      poorVowelSpacing,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "syllablesPerName", "type": "string[][]", "optional": false}, {"name": "phonemesPerName", "type": "string[][]", "optional": false}, {"name": "profile", "type": "PhonologyProfile", "optional": false}], "returnType": "PronounceabilityReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["PhonologyProfile"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::applyStyle", "name": "applyStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply stylistic transforms to a name\r\n */\r\nexport function applyStyle(\r\n  rng: () => number,\r\n  name: string,\r\n  style: StyleRules,\r\n  syllables?: string[]\r\n): { result: string; transforms: string[] } {\r\n  let result = name;\r\n  const transforms: string[] = [];\r\n\r\n  const apostropheRate = style.apostropheRate ?? 0;\r\n  const hyphenRate = style.hyphenRate ?? 0;\r\n  const capitalization = style.capitalization ?? \"title\";\r\n\r\n  const wantApostrophe = apostropheRate > 0 && chance(rng, apostropheRate);\r\n  const wantHyphen = hyphenRate > 0 && chance(rng, hyphenRate);\r\n\r\n  if ((wantApostrophe || wantHyphen) && syllables && syllables.length > 1) {\r\n    const boundaries = findSyllableBoundaries(result, syllables);\r\n    if (boundaries.length > 0) {\r\n      result = insertStyleMarkers(result, boundaries, wantApostrophe, wantHyphen, rng, transforms);\r\n    }\r\n  }\r\n\r\n  result = applyCapitalization(result, capitalization);\r\n  transforms.push(`cap:${capitalization}`);\r\n\r\n  return { result, transforms };\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllables", "type": "string[]", "optional": true}], "returnType": "{ result: string; transforms: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::hasPreferredEnding", "name": "hasPreferredEnding", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if a name has a preferred ending\r\n */\r\nexport function hasPreferredEnding(\r\n  name: string,\r\n  preferredEndings?: string[]\r\n): boolean {\r\n  if (!preferredEndings || preferredEndings.length === 0) {\r\n    return false;\r\n  }\r\n  return endsWithAny(name, preferredEndings);\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::selectWithPreferredEndings", "name": "selectWithPreferredEndings", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Generate multiple candidates and boost those with preferred endings\r\n */\r\nexport function selectWithPreferredEndings<T>(\r\n  rng: () => number,\r\n  candidates: T[],\r\n  nameExtractor: (candidate: T) => string,\r\n  preferredEndings?: string[],\r\n  boost: number = 2.0\r\n): T {\r\n  if (\r\n    !preferredEndings ||\r\n    preferredEndings.length === 0 ||\r\n    candidates.length === 0\r\n  ) {\r\n    // No preference, pick uniformly\r\n    return candidates[Math.floor(rng() * candidates.length)];\r\n  }\r\n\r\n  // Calculate weights\r\n  const weights = candidates.map((candidate) => {\r\n    const name = nameExtractor(candidate);\r\n    return hasPreferredEnding(name, preferredEndings) ? boost : 1.0;\r\n  });\r\n\r\n  // Weighted selection\r\n  const total = weights.reduce((sum, w) => sum + w, 0);\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n\r\n  for (let i = 0; i < candidates.length; i++) {\r\n    cumulative += weights[i];\r\n    if (r < cumulative) {\r\n      return candidates[i];\r\n    }\r\n  }\r\n\r\n  // Fallback\r\n  return candidates[candidates.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "T[]", "optional": false}, {"name": "nameExtractor", "type": "(candidate: T) => string", "optional": false}, {"name": "preferredEndings", "type": "string[]", "optional": true}, {"name": "boost", "type": "number", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::applyRhythmBias", "name": "applyRhythmBias", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply rhythm-based adjustments to a name\r\n * This is a placeholder for future enhancement\r\n */\r\nexport function applyRhythmBias(\r\n  name: string,\r\n  _rhythmBias?: \"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"\r\n): string {\r\n  // Rhythm bias is primarily enforced during phonology generation.\r\n  // Post-processing transformations (softening consonant clusters,\r\n  // emphasizing consonants, adding syllable breaks, smoothing transitions)\r\n  // can be added here in the future.\r\n  return name;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_rhythmBias", "type": "\"soft\" | \"harsh\" | \"staccato\" | \"flowing\" | \"neutral\"", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::validateStyle", "name": "validateStyle", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Validate that a name meets style constraints\r\n */\r\nexport function validateStyle(name: string, _style: StyleRules): boolean {\r\n  // Basic validation: more complex checks (apostrophe/hyphen placement,\r\n  // capitalization, double apostrophes) can be added here.\r\n  return name.length > 0;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "_style", "type": "StyleRules", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::applyStyleWithCandidates", "name": "applyStyleWithCandidates", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Apply all stylistic transforms and select best candidate\r\n */\r\nexport function applyStyleWithCandidates(\r\n  rng: () => number,\r\n  candidates: string[],\r\n  style: StyleRules,\r\n  syllablesPerCandidate?: string[][]\r\n): string {\r\n  if (candidates.length === 0) {\r\n    throw new Error(\"No candidates provided\");\r\n  }\r\n\r\n  // Generate styled versions\r\n  const styledCandidates = candidates.map((name, index) => {\r\n    const syllables = syllablesPerCandidate?.[index];\r\n    const { result } = applyStyle(rng, name, style, syllables);\r\n    return result;\r\n  });\r\n\r\n  // Select with preferred endings boost\r\n  return selectWithPreferredEndings(\r\n    rng,\r\n    styledCandidates,\r\n    (name) => name,\r\n    style.preferredEndings,\r\n    style.preferredEndingBoost\r\n  );\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "style", "type": "StyleRules", "optional": false}, {"name": "syllablesPerCandidate", "type": "string[][]", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::normalizeForComparison", "name": "normalizeForComparison", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Strip style markers for comparison\r\n * Useful for validation and deduplication\r\n */\r\nexport function normalizeForComparison(name: string): string {\r\n  return name\r\n    .toLowerCase()\r\n    .replace(/['\\-\\s]/g, \"\") // Remove apostrophes, hyphens, spaces\r\n    .trim();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/style.ts::areTooSimilar", "name": "areTooSimilar", "kind": "function", "filePath": "apps/name-forge/lib/style.ts", "sourceCode": "/**\r\n * Check if two names are too similar (considering style variations)\r\n */\r\nexport function areTooSimilar(name1: string, name2: string): boolean {\r\n  const norm1 = normalizeForComparison(name1);\r\n  const norm2 = normalizeForComparison(name2);\r\n  return norm1 === norm2;\r\n}", "parameters": [{"name": "name1", "type": "string", "optional": false}, {"name": "name2", "type": "string", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/domain.js", "specifiers": ["StyleRules"], "category": "internal"}, {"source": "./utils/rng.js", "specifiers": ["chance"], "category": "internal"}, {"source": "./utils/helpers.js", "specifiers": ["applyCapitalization", "findSyllableBoundaries", "insertAtBoundary", "endsWithAny"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../utils/rng.js", "specifiers": ["createRNG"], "category": "internal"}, {"source": "./fitness.js", "specifiers": ["computeFitness"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAllConsonants", "getAllVowels", "getAllTemplates", "getAllClusters"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["OptimizationSettings", "ValidationSettings", "FitnessWeights", "OptimizationResult", "EvaluationResult"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/bayesian.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/bayesian.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../utils/rng.js", "specifiers": ["createRNG"], "category": "internal"}, {"source": "./fitness.js", "specifiers": ["computeFitness"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAllConsonants", "getAllVowels", "getAllTemplates", "getAllClusters"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["OptimizationSettings", "ValidationSettings", "FitnessWeights", "OptimizationResult", "EvaluationResult"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../generate.js", "specifiers": ["generateFromDomain"], "category": "internal"}, {"source": "../pronounceability.js", "specifiers": ["batchScorePronounceability"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["FitnessWeights", "ValidationSettings", "EvaluationResult", "ParameterVector"], "category": "internal"}, {"source": "../validation/metrics/capacity.js", "specifiers": ["validateCapacity"], "category": "internal"}, {"source": "../validation/metrics/diffuseness.js", "specifiers": ["validateDiffuseness"], "category": "internal"}, {"source": "../validation/metrics/separation.js", "specifiers": ["validateSeparation"], "category": "internal"}, {"source": "../validation/validation.js", "specifiers": ["CapacityReport", "DiffusenessReport", "SeparationReport"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/fitness.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/fitness.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../generate.js", "specifiers": ["generateFromDomain"], "category": "internal"}, {"source": "../pronounceability.js", "specifiers": ["batchScorePronounceability"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["FitnessWeights", "ValidationSettings", "EvaluationResult", "ParameterVector"], "category": "internal"}, {"source": "../validation/metrics/capacity.js", "specifiers": ["validateCapacity"], "category": "internal"}, {"source": "../validation/metrics/diffuseness.js", "specifiers": ["validateDiffuseness"], "category": "internal"}, {"source": "../validation/metrics/separation.js", "specifiers": ["validateSeparation"], "category": "internal"}, {"source": "../validation/validation.js", "specifiers": ["CapacityReport", "DiffusenessReport", "SeparationReport"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/genetic.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/genetic.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../utils/rng.js", "specifiers": ["createRNG"], "category": "internal"}, {"source": "./fitness.js", "specifiers": ["computeFitness"], "category": "internal"}, {"source": "./mutations.js", "specifiers": ["applyMultipleMutations", "applyWeightedMutation", "MUTATION_WEIGHTS"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["OptimizationSettings", "ValidationSettings", "FitnessWeights", "OptimizationResult", "EvaluationResult"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/hillclimb.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/hillclimb.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../utils/rng.js", "specifiers": ["createRNG"], "category": "internal"}, {"source": "../parameter-encoder.js", "specifiers": ["encodeParameters", "decodeParameters", "perturbParameters"], "category": "internal"}, {"source": "./fitness.js", "specifiers": ["computeFitness", "computeFitnessLight"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["OptimizationSettings", "ValidationSettings", "FitnessWeights", "ParameterBounds", "OptimizationResult", "EvaluationResult"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::optimizeDomain", "name": "optimizeDomain", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * High-level optimize function that dispatches to the appropriate algorithm\r\n */\r\nexport async function optimizeDomain(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  siblingDomains: NamingDomain[] = [],\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed?: string\r\n): Promise<OptimizationResult> {\r\n  const algorithm = optimizationSettings.algorithm || 'hillclimb';\r\n  const effectiveSeed = seed || `optimize-${algorithm}-${Date.now()}`;\r\n\r\n  switch (algorithm) {\r\n    case 'hillclimb':\r\n      return hillclimb(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'sim_anneal':\r\n      return simulatedAnnealing(initialDomain, validationSettings, fitnessWeights, optimizationSettings, bounds, effectiveSeed, siblingDomains);\r\n    case 'ga':\r\n      // GA doesn't use bounds parameter\r\n      return geneticAlgorithm(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    case 'bayes':\r\n      // Bayesian doesn't use bounds parameter\r\n      return bayesianOptimization(initialDomain, validationSettings, fitnessWeights, optimizationSettings, effectiveSeed, siblingDomains);\r\n    default:\r\n      throw new Error(`Unknown optimization algorithm: ${algorithm}`);\r\n  }\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitness", "name": "computeFitness", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Generate names and compute fitness score\r\n */\r\nexport async function computeFitness(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  otherDomains: NamingDomain[] = [],\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  const startTime = Date.now();\r\n  const log = (msg: string) => {\r\n    if (verbose || iteration === 0) {\r\n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\r\n      console.log(`  [fitness ${iteration}] ${msg} (${elapsed}s)`);\r\n    }\r\n  };\r\n\r\n  log(\"Loading validation metrics...\");\r\n  await loadValidationMetrics();\r\n\r\n  // Apply defaults for validation settings\r\n  const requiredNames = settings.requiredNames ?? 500;\r\n  const sampleFactor = settings.sampleFactor ?? 20;\r\n  const maxSampleSize = settings.maxSampleSize ?? 20_000;\r\n  const minNN_p5 = settings.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = settings.minShapeNN_p5 ?? 0.2;\r\n  const minCentroidDistance = settings.minCentroidDistance ?? 0.2;\r\n\r\n  // Merge defaults into settings for downstream use\r\n  const mergedSettings: ValidationSettings = {\r\n    ...settings,\r\n    requiredNames,\r\n    sampleFactor,\r\n    maxSampleSize,\r\n    minNN_p5,\r\n    minShapeNN_p5,\r\n    minCentroidDistance,\r\n  };\r\n\r\n  // Calculate sample size\r\n  const sampleSize = Math.min(\r\n    maxSampleSize,\r\n    requiredNames * sampleFactor\r\n  );\r\n\r\n  // Run capacity and diffuseness in parallel (they're independent)\r\n  log(`Computing metrics in parallel (${sampleSize} names)...`);\r\n\r\n  const capacityReport = validateCapacity(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-capacity`,\r\n  });\r\n  const diffusenessReport = validateDiffuseness(config, {\r\n    sampleSize,\r\n    seed: `fitness-${iteration}-diffuseness`,\r\n  });\r\n\r\n  // For separation, we need multiple domains (run after parallel metrics)\r\n  let separationScore = 1.0; // Default if no other domains\r\n  if (otherDomains.length > 0) {\r\n    const allDomains = [config, ...otherDomains];\r\n    const perDomainSample = Math.floor(sampleSize / allDomains.length);\r\n\r\n    log(`Computing separation (${allDomains.length} domains, ${perDomainSample} names each)...`);\r\n    const separationReport = validateSeparation(allDomains, {\r\n      sampleSize: perDomainSample,\r\n      seed: `fitness-${iteration}-separation`,\r\n    });\r\n    separationScore = normalizeSeparationScore(separationReport, mergedSettings);\r\n  }\r\n\r\n  log(\"Done computing metrics.\");\r\n\r\n  // Normalize individual metrics to 0-1\r\n  const capacityScore = normalizeCapacityScore(capacityReport, mergedSettings);\r\n  const diffusenessScore = normalizeDiffusenessScore(diffusenessReport, mergedSettings);\r\n\r\n  // Compute pronounceability and length scores if weighted\r\n  let pronounceabilityScore = 1.0;\r\n  let lengthScore = 1.0;\r\n  if (weights.pronounceability > 0 || weights.length > 0) {\r\n    // Generate sample names for these metrics\r\n    const names = generateFromDomain(config, sampleSize, `fitness-${iteration}-style`);\r\n\r\n    if (weights.pronounceability > 0) {\r\n      pronounceabilityScore = scorePronounceability(names, config);\r\n    }\r\n\r\n    if (weights.length > 0) {\r\n      lengthScore = scoreLengthDeviation(names, config);\r\n    }\r\n  }\r\n\r\n  // Combine with weights (warn on undefined weights)\r\n  const warnUndefined = (name: string, value: number | undefined): number => {\r\n    if (value === undefined) {\r\n      console.warn(`[fitness] WARNING: weight '${name}' is undefined, using 0. Check caller is passing all required weights.`);\r\n      return 0;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  const w = {\r\n    capacity: warnUndefined(\"capacity\", weights.capacity),\r\n    diffuseness: warnUndefined(\"diffuseness\", weights.diffuseness),\r\n    separation: warnUndefined(\"separation\", weights.separation),\r\n    pronounceability: warnUndefined(\"pronounceability\", weights.pronounceability),\r\n    length: warnUndefined(\"length\", weights.length),\r\n    style: warnUndefined(\"style\", weights.style),\r\n  };\r\n\r\n  const totalWeight =\r\n    w.capacity + w.diffuseness + w.separation + w.pronounceability + w.length + w.style;\r\n\r\n  // Debug: check for NaN values\r\n  if (isNaN(capacityScore) || isNaN(diffusenessScore) || isNaN(separationScore)) {\r\n    console.error(\"NaN detected in scores:\", {\r\n      capacityScore,\r\n      diffusenessScore,\r\n      separationScore,\r\n      totalWeight,\r\n    });\r\n  }\r\n\r\n  const fitness =\r\n    totalWeight > 0\r\n      ? (w.capacity * capacityScore +\r\n          w.diffuseness * diffusenessScore +\r\n          w.separation * separationScore +\r\n          w.pronounceability * pronounceabilityScore +\r\n          w.length * lengthScore) /\r\n        totalWeight\r\n      : 0;\r\n\r\n  log(`Fitness: ${fitness.toFixed(4)} (weights: cap=${w.capacity}, diff=${w.diffuseness}, sep=${w.separation})`);\r\n\r\n  return {\r\n    config,\r\n    theta,\r\n    fitness,\r\n    scores: {\r\n      capacity: capacityScore,\r\n      diffuseness: diffusenessScore,\r\n      separation: separationScore,\r\n      pronounceability: pronounceabilityScore,\r\n      length: lengthScore,\r\n    },\r\n    iteration,\r\n    timestamp: Date.now(),\r\n  };\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "otherDomains", "type": "NamingDomain[]", "optional": true}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::computeFitnessLight", "name": "computeFitnessLight", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Lightweight fitness function (without separation)\r\n *\r\n * Used for quick evaluations during optimization loop.\r\n * Only computes capacity and diffuseness.\r\n */\r\nexport async function computeFitnessLight(\r\n  config: NamingDomain,\r\n  theta: ParameterVector,\r\n  settings: ValidationSettings,\r\n  weights: FitnessWeights,\r\n  iteration: number = 0,\r\n  verbose: boolean = false\r\n): Promise<EvaluationResult> {\r\n  return computeFitness(config, theta, settings, weights, [], iteration, verbose);\r\n}", "parameters": [{"name": "config", "type": "NamingDomain", "optional": false}, {"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "settings", "type": "ValidationSettings", "optional": false}, {"name": "weights", "type": "FitnessWeights", "optional": false}, {"name": "iteration", "type": "number", "optional": true}, {"name": "verbose", "type": "boolean", "optional": true}], "returnType": "Promise<EvaluationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::hillclimb", "name": "hillclimb", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run hill-climbing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function hillclimb(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"hillclimb\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0, verbose)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0, verbose);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n\r\n  // Always log initial fitness (regardless of verbose)\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(\r\n    `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n    `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n    `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n  );\r\n  console.log(`Starting ${iterations} iterations (each takes ~${useSeparation ? '60-90' : '5-10'}s)...`);\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n\r\n  // Hill-climbing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const iterStart = Date.now();\r\n    console.log(`\\n[${i}/${iterations}] Evaluating...`);\r\n\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i, verbose)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i, verbose);\r\n\r\n    const iterElapsed = ((Date.now() - iterStart) / 1000).toFixed(1);\r\n    console.log(`[${i}/${iterations}] Fitness: ${proposedEval.fitness.toFixed(4)} (${iterElapsed}s)`);\r\n    evaluations.push(proposedEval);\r\n\r\n    // Accept if better\r\n    if (proposedEval.fitness > currentEval.fitness) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      bestEval = maybeUpdateBest(proposedEval, bestEval, initialFitness);\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n\r\n    const converged = checkConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const finalImprovement = finalFitness - initialFitness;\r\n\r\n  console.log(\"\\n=== Optimization complete ===\");\r\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n  console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n  console.log(`Improvement: +${(finalImprovement * 100).toFixed(1)}%`);\r\n  console.log(`Total evaluations: ${evaluations.length}`);\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement: finalImprovement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::geneticAlgorithm", "name": "geneticAlgorithm", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run genetic algorithm optimization\n */\nexport async function geneticAlgorithm(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"ga\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const gaSettings: GASettings = {\n    ...DEFAULT_GA_SETTINGS,\n    populationSize: optimizationSettings.populationSize || DEFAULT_GA_SETTINGS.populationSize,\n  };\n\n  const generations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n  const primaryGoal = getPrimaryGoal(fitnessWeights);\n\n  console.log(`\\n=== Genetic Algorithm ===`);\n  console.log(`Population: ${gaSettings.populationSize}, Generations: ${generations}`);\n  console.log(`Primary goal: ${primaryGoal}`);\n  const geneticSeparationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${geneticSeparationLabel}`);\n\n  // Initialize population with mutations of initial domain\n  console.log(\"\\nInitializing population...\");\n\n  // Create all genomes first\n  const genomes: NamingDomain[] = [];\n  for (let i = 0; i < gaSettings.populationSize; i++) {\n    const mutationCount = i === 0 ? 0 : Math.floor(rng() * 5) + 1;\n    genomes.push(applyMultipleMutations(initialDomain, mutationCount, rng));\n  }\n\n  // Evaluate all individuals\n  console.log(`  Evaluating ${genomes.length} individuals...`);\n\n  const evalResults = await evaluateBatch(\n    genomes,\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0\n  );\n\n  // Build population from results\n  const population: Individual[] = genomes.map((genome, i) => ({\n    genome,\n    fitness: evalResults[i].fitness,\n    scores: evalResults[i].scores,\n  }));\n\n  console.log(`  Population initialized.`);\n\n  // Sort by fitness\n  population.sort((a, b) => b.fitness - a.fitness);\n\n  const initialFitness = population[0].fitness;\n  console.log(`Initial best fitness: ${initialFitness.toFixed(4)}`);\n\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [initialFitness];\n\n  // Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    const genStart = Date.now();\n\n    const newPopulation: Individual[] = [];\n\n    // Elitism: keep best individuals\n    for (let i = 0; i < gaSettings.eliteCount; i++) {\n      newPopulation.push(population[i]);\n    }\n\n    // Generate children through selection, crossover, mutation\n    const childGenomes = generateChildren(\n      population, gaSettings, primaryGoal, rng,\n      gaSettings.populationSize - newPopulation.length\n    );\n\n    // Evaluate all children in parallel\n    const childEvaluations = await evaluateBatch(\n      childGenomes,\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      gen + 1\n    );\n\n    // Add children to population\n    for (let i = 0; i < childGenomes.length; i++) {\n      newPopulation.push({\n        genome: childGenomes[i],\n        fitness: childEvaluations[i].fitness,\n        scores: childEvaluations[i].scores,\n      });\n      evaluations.push(childEvaluations[i]);\n    }\n\n    // Replace population\n    newPopulation.sort((a, b) => b.fitness - a.fitness);\n    population.length = 0;\n    population.push(...newPopulation.slice(0, gaSettings.populationSize));\n\n    const genElapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n    const bestFitness = population[0].fitness;\n    const avgFitness = population.reduce((sum, ind) => sum + ind.fitness, 0) / population.length;\n\n    convergenceHistory.push(bestFitness);\n\n    console.log(\n      `[Gen ${gen + 1}/${generations}] ` +\n      `Best: ${bestFitness.toFixed(4)}, Avg: ${avgFitness.toFixed(4)} ` +\n      `(${genElapsed}s)`\n    );\n\n    if (bestFitness > initialFitness * 1.001) {\n      const improvement = ((bestFitness - initialFitness) / initialFitness) * 100;\n      console.log(`  -> Improvement: +${improvement.toFixed(1)}%`);\n    }\n  }\n\n  const bestIndividual = population[0];\n  const finalFitness = bestIndividual.fitness;\n  const improvement = finalFitness - initialFitness;\n\n  console.log(\"\\n=== GA Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${finalFitness.toFixed(4)}`);\n  console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestIndividual.genome.phonology.consonants.length}C + ${bestIndividual.genome.phonology.vowels.length}V`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestIndividual.genome,\n    initialFitness,\n    finalFitness,\n    improvement,\n    iterations: generations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::bayesianOptimization", "name": "bayesianOptimization", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Run Bayesian optimization with TPE\n */\nexport async function bayesianOptimization(\n  initialDomain: NamingDomain,\n  validationSettings: ValidationSettings,\n  fitnessWeights: FitnessWeights,\n  optimizationSettings: OptimizationSettings,\n  seed: string = \"tpe\",\n  siblingDomains: NamingDomain[] = []\n): Promise<OptimizationResult> {\n  const rng = createRNG(seed);\n\n  const tpeSettings: TPESettings = {\n    ...DEFAULT_TPE_SETTINGS,\n    nInitial: Math.min(optimizationSettings.iterations ?? 50, 15),\n  };\n\n  const totalIterations = optimizationSettings.iterations ?? 50;\n  const useSeparation = siblingDomains.length > 0 && (fitnessWeights.separation ?? 0) > 0;\n\n  console.log(\"\\n=== Bayesian Optimization (TPE) ===\");\n  console.log(`Initial samples: ${tpeSettings.nInitial}`);\n  console.log(`Total iterations: ${totalIterations}`);\n  console.log(`Gamma (quantile): ${tpeSettings.gamma}`);\n  const separationLabel = useSeparation ? `yes (${siblingDomains.length} siblings)` : \"no\";\n  console.log(`Separation: ${separationLabel}`);\n\n  const observations: Observation[] = [];\n  const evaluations: EvaluationResult[] = [];\n  const convergenceHistory: number[] = [];\n\n  // Evaluate initial domain\n  const initialEval = await computeFitness(\n    initialDomain,\n    { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n    validationSettings,\n    fitnessWeights,\n    useSeparation ? siblingDomains : [],\n    0,\n    false\n  );\n\n  const initialFitness = initialEval.fitness;\n  console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\n\n  observations.push({\n    point: encodeConfig(initialDomain),\n    fitness: initialFitness,\n    domain: initialDomain,\n  });\n  evaluations.push(initialEval);\n  convergenceHistory.push(initialFitness);\n\n  let bestFitness = initialFitness;\n  let bestDomain = initialDomain;\n\n  // Phase 1: Random exploration\n  console.log(\"\\nPhase 1: Random exploration...\");\n  for (let i = 0; i < tpeSettings.nInitial - 1; i++) {\n    const point = sampleRandom(initialDomain, rng);\n    const domain = decodeConfig(point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      i + 1,\n      false\n    );\n\n    observations.push({ point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`  [${i + 1}] New best: ${bestFitness.toFixed(4)}`);\n    }\n\n    process.stdout.write(`\\r  Exploring ${i + 1}/${tpeSettings.nInitial - 1}`);\n  }\n  console.log();\n\n  // Phase 2: TPE-guided search\n  console.log(\"\\nPhase 2: TPE-guided optimization...\");\n  for (let iter = tpeSettings.nInitial; iter < totalIterations; iter++) {\n    const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n    const splitIdx = Math.max(1, Math.floor(sorted.length * tpeSettings.gamma));\n    const goodObs = sorted.slice(0, splitIdx);\n    const badObs = sorted.slice(splitIdx);\n\n    const bestCandidate = selectBestTPECandidate(goodObs, badObs, initialDomain, rng, tpeSettings.nCandidates);\n    const domain = decodeConfig(bestCandidate.point, initialDomain);\n\n    const evalResult = await computeFitness(\n      domain,\n      { consonantWeights: [], vowelWeights: [], templateWeights: [], structureWeights: [], apostropheRate: 0, hyphenRate: 0, lengthMin: 0, lengthMax: 0 },\n      validationSettings,\n      fitnessWeights,\n      useSeparation ? siblingDomains : [],\n      iter,\n      false\n    );\n\n    observations.push({ point: bestCandidate.point, fitness: evalResult.fitness, domain });\n    evaluations.push(evalResult);\n    convergenceHistory.push(Math.max(bestFitness, evalResult.fitness));\n\n    if (evalResult.fitness > bestFitness) {\n      bestFitness = evalResult.fitness;\n      bestDomain = domain;\n      console.log(`[${iter + 1}/${totalIterations}] New best: ${bestFitness.toFixed(4)} (EI: ${bestCandidate.ei.toFixed(2)})`);\n    } else if ((iter + 1) % 10 === 0) {\n      console.log(`[${iter + 1}/${totalIterations}] Best: ${bestFitness.toFixed(4)}, Current: ${evalResult.fitness.toFixed(4)}`);\n    }\n  }\n\n  const improvement = bestFitness - initialFitness;\n\n  console.log(\"\\n=== TPE Complete ===\");\n  console.log(`Initial: ${initialFitness.toFixed(4)}`);\n  console.log(`Final: ${bestFitness.toFixed(4)}`);\n  console.log(`Improvement: ${improvement >= 0 ? \"+\" : \"\"}${(improvement * 100).toFixed(1)}%`);\n  console.log(`Phonemes: ${bestDomain.phonology.consonants.length}C + ${bestDomain.phonology.vowels.length}V`);\n  console.log(`Templates: ${bestDomain.phonology.syllableTemplates.length}`);\n\n  return {\n    initialConfig: initialDomain,\n    optimizedConfig: bestDomain,\n    initialFitness,\n    finalFitness: bestFitness,\n    improvement,\n    iterations: totalIterations,\n    evaluations,\n    convergenceHistory,\n    settings: optimizationSettings,\n  };\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::analyzePhonemeImportance", "name": "analyzePhonemeImportance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Analyze phoneme importance from TPE observations\n */\nexport function analyzePhonemeImportance(\n  observations: Observation[],\n  gamma: number = 0.25\n): {\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n} {\n  const sorted = [...observations].sort((a, b) => b.fitness - a.fitness);\n  const splitIdx = Math.max(1, Math.floor(sorted.length * gamma));\n  const goodObs = sorted.slice(0, splitIdx);\n  const badObs = sorted.slice(splitIdx);\n\n  const analyzeCategory = (\n    accessor: (p: ConfigPoint) => Map<string, boolean>\n  ): Array<{ phoneme: string; importance: number }> => {\n    const results: Array<{ phoneme: string; importance: number }> = [];\n\n    // Get all keys from first observation\n    const firstPoint = observations[0].point;\n    const keys = Array.from(accessor(firstPoint).keys());\n\n    for (const key of keys) {\n      const importance = estimateInclusionProbability(\n        key,\n        goodObs,\n        badObs,\n        accessor\n      );\n      results.push({ phoneme: key, importance });\n    }\n\n    return results.sort((a, b) => b.importance - a.importance);\n  };\n\n  return {\n    consonants: analyzeCategory((p) => p.consonants),\n    vowels: analyzeCategory((p) => p.vowels),\n    templates: analyzeCategory((p) => p.templates).map((r) => ({\n      template: r.phoneme,\n      importance: r.importance,\n    })),\n  };\n}", "parameters": [{"name": "observations", "type": "Observation[]", "optional": false}, {"name": "gamma", "type": "number", "optional": true}], "returnType": "{\n  consonants: Array<{ phoneme: string; importance: number }>;\n  vowels: Array<{ phoneme: string; importance: number }>;\n  templates: Array<{ template: string; importance: number }>;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::encodeParameters", "name": "encodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Encode domain config to parameter vector\r\n */\r\nexport function encodeParameters(domain: NamingDomain): ParameterVector {\r\n  const { phonology, morphology, style } = domain;\r\n\r\n  // Get weights or create uniform defaults\r\n  const consonantWeights: number[] =\r\n    phonology.consonantWeights && phonology.consonantWeights.length > 0\r\n      ? phonology.consonantWeights\r\n      : new Array<number>(phonology.consonants.length).fill(1);\r\n\r\n  const vowelWeights: number[] =\r\n    phonology.vowelWeights && phonology.vowelWeights.length > 0\r\n      ? phonology.vowelWeights\r\n      : new Array<number>(phonology.vowels.length).fill(1);\r\n\r\n  const templateWeights: number[] =\r\n    phonology.templateWeights && phonology.templateWeights.length > 0\r\n      ? phonology.templateWeights\r\n      : new Array<number>(phonology.syllableTemplates.length).fill(1);\r\n\r\n  const structureWeights: number[] =\r\n    morphology.structureWeights && morphology.structureWeights.length > 0\r\n      ? morphology.structureWeights\r\n      : new Array<number>(morphology.structure.length).fill(1);\r\n\r\n  return {\r\n    consonantWeights: normalizeWeights(consonantWeights).map(toLogSpace),\r\n    vowelWeights: normalizeWeights(vowelWeights).map(toLogSpace),\r\n    templateWeights: normalizeWeights(templateWeights).map(toLogSpace),\r\n    structureWeights: normalizeWeights(structureWeights).map(toLogSpace),\r\n\r\n    apostropheRate: toLogit(style.apostropheRate ?? 0),\r\n    hyphenRate: toLogit(style.hyphenRate ?? 0),\r\n\r\n    lengthMin: phonology.lengthRange[0],\r\n    lengthMax: phonology.lengthRange[1],\r\n\r\n    favoredClusterBoost: phonology.favoredClusterBoost,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::decodeParameters", "name": "decodeParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Decode parameter vector back to domain config\r\n */\r\nexport function decodeParameters(\r\n  theta: ParameterVector,\r\n  baseDomain: NamingDomain,\r\n  bounds: ParameterBounds\r\n): NamingDomain {\r\n  // Transform back from log/logit space\r\n  const consonantWeights = normalizeWeights(theta.consonantWeights.map(fromLogSpace));\r\n  const vowelWeights = normalizeWeights(theta.vowelWeights.map(fromLogSpace));\r\n  const templateWeights = normalizeWeights(theta.templateWeights.map(fromLogSpace));\r\n  const structureWeights = normalizeWeights(theta.structureWeights.map(fromLogSpace));\r\n\r\n  const apostropheRate = fromLogit(theta.apostropheRate);\r\n  const hyphenRate = fromLogit(theta.hyphenRate);\r\n\r\n  // Clamp length range to bounds\r\n  const lengthMin = Math.max(\r\n    bounds.lengthMin.min,\r\n    Math.min(bounds.lengthMin.max, Math.round(theta.lengthMin))\r\n  );\r\n  const lengthMax = Math.max(\r\n    bounds.lengthMax.min,\r\n    Math.min(bounds.lengthMax.max, Math.round(theta.lengthMax))\r\n  );\r\n\r\n  // Ensure lengthMax >= lengthMin\r\n  const finalLengthMax = Math.max(lengthMax, lengthMin);\r\n\r\n  return {\r\n    ...baseDomain,\r\n    phonology: {\r\n      ...baseDomain.phonology,\r\n      consonantWeights,\r\n      vowelWeights,\r\n      templateWeights,\r\n      lengthRange: [lengthMin, finalLengthMax],\r\n      favoredClusterBoost: theta.favoredClusterBoost,\r\n    },\r\n    morphology: {\r\n      ...baseDomain.morphology,\r\n      structureWeights,\r\n    },\r\n    style: {\r\n      ...baseDomain.style,\r\n      apostropheRate,\r\n      hyphenRate,\r\n    },\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "baseDomain", "type": "NamingDomain", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::perturbParameters", "name": "perturbParameters", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Create a perturbed copy of parameter vector\r\n */\r\nexport function perturbParameters(\r\n  theta: ParameterVector,\r\n  stepSizes: {\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  },\r\n  rng: () => number\r\n): ParameterVector {\r\n  // Add Gaussian noise (using Box-Muller transform)\r\n  const gaussian = (): number => {\r\n    const u1 = rng();\r\n    const u2 = rng();\r\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\r\n  };\r\n\r\n  return {\r\n    consonantWeights: theta.consonantWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    vowelWeights: theta.vowelWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    templateWeights: theta.templateWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n    structureWeights: theta.structureWeights.map((w) => w + gaussian() * stepSizes.weights),\r\n\r\n    apostropheRate: theta.apostropheRate + gaussian() * stepSizes.apostropheRate,\r\n    hyphenRate: theta.hyphenRate + gaussian() * stepSizes.hyphenRate,\r\n\r\n    lengthMin: theta.lengthMin + Math.round(gaussian() * stepSizes.lengthRange),\r\n    lengthMax: theta.lengthMax + Math.round(gaussian() * stepSizes.lengthRange),\r\n\r\n    favoredClusterBoost: theta.favoredClusterBoost\r\n      ? theta.favoredClusterBoost + gaussian() * 1.0\r\n      : undefined,\r\n  };\r\n}", "parameters": [{"name": "theta", "type": "ParameterVector", "optional": false}, {"name": "stepSizes", "type": "{\r\n    weights: number;\r\n    apostropheRate: number;\r\n    hyphenRate: number;\r\n    lengthRange: number;\r\n  }", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "ParameterVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/index.ts::parameterDistance", "name": "parameterDistance", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/index.ts", "sourceCode": "/**\r\n * Calculate distance between two parameter vectors (L2 norm)\r\n */\r\nexport function parameterDistance(theta1: ParameterVector, theta2: ParameterVector): number {\r\n  const allParams1 = [\r\n    ...theta1.consonantWeights,\r\n    ...theta1.vowelWeights,\r\n    ...theta1.templateWeights,\r\n    ...theta1.structureWeights,\r\n    theta1.apostropheRate,\r\n    theta1.hyphenRate,\r\n    theta1.lengthMin,\r\n    theta1.lengthMax,\r\n  ];\r\n\r\n  const allParams2 = [\r\n    ...theta2.consonantWeights,\r\n    ...theta2.vowelWeights,\r\n    ...theta2.templateWeights,\r\n    ...theta2.structureWeights,\r\n    theta2.apostropheRate,\r\n    theta2.hyphenRate,\r\n    theta2.lengthMin,\r\n    theta2.lengthMax,\r\n  ];\r\n\r\n  const squaredDiffs = allParams1.map((p1, i) => Math.pow(p1 - allParams2[i], 2));\r\n  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0));\r\n}", "parameters": [{"name": "theta1", "type": "ParameterVector", "optional": false}, {"name": "theta2", "type": "ParameterVector", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./hillclimb.js", "specifiers": ["hillclimb"], "category": "internal"}, {"source": "./sim-anneal.js", "specifiers": ["simulatedAnnealing"], "category": "internal"}, {"source": "./genetic.js", "specifiers": ["geneticAlgorithm"], "category": "internal"}, {"source": "./bayesian.js", "specifiers": ["bayesianOptimization", "analyzePhonemeImportance"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["ValidationSettings", "FitnessWeights", "OptimizationSettings", "OptimizationResult", "ParameterBounds"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addConsonant", "name": "addConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// PHONEME MUTATIONS\n// ============================================\n\n/**\n * Add a random consonant from the library\n */\nexport function addConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const newConsonant = pickRandom(available, rng);\n  const newConsonants = [...domain.phonology.consonants, newConsonant];\n  const newWeights = [...(domain.phonology.consonantWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeConsonant", "name": "removeConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant (preferring low-weight ones)\n */\nexport function removeConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.consonants.length <= 3) return domain; // Keep minimum\n\n  const weights = domain.phonology.consonantWeights ||\n    domain.phonology.consonants.map(() => 1);\n\n  // Weight removal probability by inverse of current weight\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newConsonants = domain.phonology.consonants.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n      consonantWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapConsonant", "name": "swapConsonant", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a consonant with one from the library\n */\nexport function swapConsonant(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableConsonants(domain.phonology.consonants);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.consonants.length);\n  const newConsonant = pickRandom(available, rng);\n\n  const newConsonants = [...domain.phonology.consonants];\n  newConsonants[swapIndex] = newConsonant;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      consonants: newConsonants,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addVowel", "name": "addVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Add a random vowel from the library\n */\nexport function addVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const newVowel = pickRandom(available, rng);\n  const newVowels = [...domain.phonology.vowels, newVowel];\n  const newWeights = [...(domain.phonology.vowelWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeVowel", "name": "removeVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a vowel (preferring low-weight ones)\n */\nexport function removeVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.vowels.length <= 2) return domain; // Keep minimum\n\n  const weights = domain.phonology.vowelWeights ||\n    domain.phonology.vowels.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newVowels = domain.phonology.vowels.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n      vowelWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::swapVowel", "name": "swapVowel", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Swap a vowel with one from the library\n */\nexport function swapVowel(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableVowels(domain.phonology.vowels);\n  if (available.length === 0) return domain;\n\n  const swapIndex = Math.floor(rng() * domain.phonology.vowels.length);\n  const newVowel = pickRandom(available, rng);\n\n  const newVowels = [...domain.phonology.vowels];\n  newVowels[swapIndex] = newVowel;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      vowels: newVowels,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addTemplate", "name": "addTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// TEMPLATE MUTATIONS\n// ============================================\n\n/**\n * Add a syllable template from the library\n */\nexport function addTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const available = getAvailableTemplates(domain.phonology.syllableTemplates);\n  if (available.length === 0) return domain;\n\n  const newTemplate = pickRandom(available, rng);\n  const newTemplates = [...domain.phonology.syllableTemplates, newTemplate];\n  const newWeights = [...(domain.phonology.templateWeights || []), 1.0];\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeTemplate", "name": "removeTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a template (preferring low-weight ones)\n */\nexport function removeTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  if (domain.phonology.syllableTemplates.length <= 1) return domain;\n\n  const weights = domain.phonology.templateWeights ||\n    domain.phonology.syllableTemplates.map(() => 1);\n\n  const inverseWeights = weights.map(w => 1 / (w + 0.1));\n  const totalInverse = inverseWeights.reduce((a, b) => a + b, 0);\n\n  let roll = rng() * totalInverse;\n  let removeIndex = 0;\n  for (let i = 0; i < inverseWeights.length; i++) {\n    roll -= inverseWeights[i];\n    if (roll <= 0) {\n      removeIndex = i;\n      break;\n    }\n  }\n\n  const newTemplates = domain.phonology.syllableTemplates.filter((_, i) => i !== removeIndex);\n  const newWeights = weights.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n      templateWeights: newWeights,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::modifyTemplate", "name": "modifyTemplate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Modify a template by adding or removing a position\n */\nexport function modifyTemplate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const templateIndex = Math.floor(rng() * domain.phonology.syllableTemplates.length);\n  const template = domain.phonology.syllableTemplates[templateIndex];\n\n  let newTemplate: string;\n\n  if (rng() < 0.5 && template.length > 1) {\n    // Remove a position\n    const removePos = Math.floor(rng() * template.length);\n    newTemplate = template.slice(0, removePos) + template.slice(removePos + 1);\n  } else if (template.length < 5) {\n    // Add a position\n    const insertPos = Math.floor(rng() * (template.length + 1));\n    const insertChar = rng() < 0.5 ? 'C' : 'V';\n    newTemplate = template.slice(0, insertPos) + insertChar + template.slice(insertPos);\n  } else {\n    return domain;\n  }\n\n  // Validate template (must have at least one V)\n  if (!newTemplate.includes('V')) return domain;\n\n  const newTemplates = [...domain.phonology.syllableTemplates];\n  newTemplates[templateIndex] = newTemplate;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      syllableTemplates: newTemplates,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::addCluster", "name": "addCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// CLUSTER MUTATIONS\n// ============================================\n\n/**\n * Add a consonant cluster\n */\nexport function addCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const currentClusters = domain.phonology.favoredClusters || [];\n  const available = getAvailableClusters(currentClusters);\n  if (available.length === 0) return domain;\n\n  const newCluster = pickRandom(available, rng);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::removeCluster", "name": "removeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Remove a consonant cluster\n */\nexport function removeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const clusters = domain.phonology.favoredClusters || [];\n  if (clusters.length === 0) return domain;\n\n  const removeIndex = Math.floor(rng() * clusters.length);\n  const newClusters = clusters.filter((_, i) => i !== removeIndex);\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: newClusters,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::synthesizeCluster", "name": "synthesizeCluster", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Create a new cluster by combining existing consonants\n */\nexport function synthesizeCluster(domain: NamingDomain, rng: RNG): NamingDomain {\n  const consonants = domain.phonology.consonants;\n  if (consonants.length < 2) return domain;\n\n  // Pick 2-3 consonants\n  const clusterLength = rng() < 0.7 ? 2 : 3;\n  const selected = pickMultiple(consonants, clusterLength, rng);\n  const newCluster = selected.join('');\n\n  const currentClusters = domain.phonology.favoredClusters || [];\n  if (currentClusters.includes(newCluster)) return domain;\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      favoredClusters: [...currentClusters, newCluster],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateApostropheRate", "name": "mutateApostropheRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "// ============================================\n// STYLE MUTATIONS\n// ============================================\n\n/**\n * Mutate apostrophe rate\n */\nexport function mutateApostropheRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.apostropheRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2; // +/- 10%\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      apostropheRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateHyphenRate", "name": "mutateHyphenRate", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate hyphen rate\n */\nexport function mutateHyphenRate(domain: NamingDomain, rng: RNG): NamingDomain {\n  const current = domain.style.hyphenRate ?? 0;\n  const delta = (rng() - 0.5) * 0.2;\n  const newRate = Math.max(0, Math.min(1, current + delta));\n\n  return {\n    ...domain,\n    style: {\n      ...domain.style,\n      hyphenRate: newRate,\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::mutateLengthRange", "name": "mutateLengthRange", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Mutate length range\n */\nexport function mutateLengthRange(domain: NamingDomain, rng: RNG): NamingDomain {\n  const [minLen, maxLen] = domain.phonology.lengthRange;\n\n  // Mutate one bound by +/- 1-2\n  const mutateMin = rng() < 0.5;\n  const delta = Math.floor(rng() * 3) - 1; // -1, 0, or +1\n\n  let newMin = minLen;\n  let newMax = maxLen;\n\n  if (mutateMin) {\n    newMin = Math.max(2, minLen + delta);\n    if (newMin > newMax) newMax = newMin;\n  } else {\n    newMax = Math.max(newMin, maxLen + delta);\n    newMax = Math.min(20, newMax);\n  }\n\n  return {\n    ...domain,\n    phonology: {\n      ...domain.phonology,\n      lengthRange: [newMin, newMax] as [number, number],\n    },\n  };\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyRandomMutation", "name": "applyRandomMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply a random mutation\n */\nexport function applyRandomMutation(domain: NamingDomain, rng: RNG): NamingDomain {\n  const mutationNames = Object.keys(MUTATIONS) as MutationType[];\n  const mutation = pickRandom(mutationNames, rng);\n  return MUTATIONS[mutation](domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyMultipleMutations", "name": "applyMultipleMutations", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply multiple random mutations\n */\nexport function applyMultipleMutations(\n  domain: NamingDomain,\n  count: number,\n  rng: RNG\n): NamingDomain {\n  let result = domain;\n  for (let i = 0; i < count; i++) {\n    result = applyRandomMutation(result, rng);\n  }\n  return result;\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "count", "type": "number", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/mutations.ts::applyWeightedMutation", "name": "applyWeightedMutation", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/mutations.ts", "sourceCode": "/**\n * Apply weighted random mutation based on goal\n */\nexport function applyWeightedMutation(\n  domain: NamingDomain,\n  goal: keyof typeof MUTATION_WEIGHTS,\n  rng: RNG\n): NamingDomain {\n  const weights = MUTATION_WEIGHTS[goal];\n  const mutationNames = Object.keys(weights) as MutationType[];\n\n  const totalWeight = mutationNames.reduce((sum, name) => sum + weights[name], 0);\n  let roll = rng() * totalWeight;\n\n  for (const name of mutationNames) {\n    roll -= weights[name];\n    if (roll <= 0) {\n      return MUTATIONS[name](domain, rng);\n    }\n  }\n\n  // Fallback\n  return applyRandomMutation(domain, rng);\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "goal", "type": "keyof typeof MUTATION_WEIGHTS", "optional": false}, {"name": "rng", "type": "RNG", "optional": false}], "returnType": "NamingDomain", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../phoneme-library.js", "specifiers": ["getAvailableConsonants", "getAvailableVowels", "getAvailableTemplates", "getAvailableClusters"], "category": "internal"}]}, {"id": "apps/name-forge/lib/optimizer/sim-anneal.ts::simulatedAnnealing", "name": "simulatedAnnealing", "kind": "function", "filePath": "apps/name-forge/lib/optimizer/sim-anneal.ts", "sourceCode": "/**\r\n * Run simulated annealing optimization\r\n * @param siblingDomains - Other domains to compare against for separation metric\r\n */\r\nexport async function simulatedAnnealing(\r\n  initialDomain: NamingDomain,\r\n  validationSettings: ValidationSettings,\r\n  fitnessWeights: FitnessWeights,\r\n  optimizationSettings: OptimizationSettings,\r\n  bounds: ParameterBounds = DEFAULT_BOUNDS,\r\n  seed: string = \"sim-anneal\",\r\n  siblingDomains: NamingDomain[] = []\r\n): Promise<OptimizationResult> {\r\n  const rng = createRNG(seed);\r\n\r\n  // Use full fitness (with separation) if we have sibling domains, otherwise lightweight\r\n  const useSeparation = siblingDomains.length > 0 && fitnessWeights.separation > 0;\r\n\r\n  // Apply defaults\r\n  const iterations = optimizationSettings.iterations ?? 100;\r\n  const verbose = optimizationSettings.verbose ?? false;\r\n  const convergenceThreshold = optimizationSettings.convergenceThreshold ?? 0.001;\r\n  const convergenceWindow = optimizationSettings.convergenceWindow ?? 10;\r\n  const stepSizes = optimizationSettings.stepSizes ?? {\r\n    weights: 0.1,\r\n    apostropheRate: 0.05,\r\n    hyphenRate: 0.05,\r\n    lengthRange: 1,\r\n  };\r\n\r\n  // Annealing parameters\r\n  let temperature = optimizationSettings.initialTemperature ?? 1.0;\r\n  const coolingRate = optimizationSettings.coolingRate ?? 0.95;\r\n\r\n  // Encode initial parameters\r\n  let currentTheta = encodeParameters(initialDomain);\r\n  let currentDomain = initialDomain;\r\n\r\n  // Evaluate initial fitness\r\n  console.log(\"Evaluating initial configuration...\");\r\n  let currentEval = useSeparation\r\n    ? await computeFitness(currentDomain, currentTheta, validationSettings, fitnessWeights, siblingDomains, 0)\r\n    : await computeFitnessLight(currentDomain, currentTheta, validationSettings, fitnessWeights, 0);\r\n\r\n  const initialFitness = currentEval.fitness;\r\n  let bestEval = currentEval;\r\n  const evaluations: EvaluationResult[] = [currentEval];\r\n  const convergenceHistory: number[] = [currentEval.fitness];\r\n\r\n  if (verbose) {\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Initial temperature: ${temperature.toFixed(3)}`);\r\n    console.log(\r\n      `  Capacity: ${currentEval.scores.capacity.toFixed(3)}, ` +\r\n        `Diffuseness: ${currentEval.scores.diffuseness.toFixed(3)}, ` +\r\n        `Separation: ${currentEval.scores.separation.toFixed(3)}`\r\n    );\r\n  }\r\n\r\n  // Track convergence\r\n  let noImprovementCount = 0;\r\n  let lastBestFitness = initialFitness;\r\n  let acceptedMoves = 0;\r\n  let rejectedMoves = 0;\r\n\r\n  // Simulated annealing loop\r\n  for (let i = 1; i <= iterations; i++) {\r\n    const proposedTheta = perturbParameters(currentTheta, stepSizes, rng);\r\n    const proposedDomain = decodeParameters(proposedTheta, initialDomain, bounds);\r\n\r\n    const proposedEval = useSeparation\r\n      ? await computeFitness(proposedDomain, proposedTheta, validationSettings, fitnessWeights, siblingDomains, i)\r\n      : await computeFitnessLight(proposedDomain, proposedTheta, validationSettings, fitnessWeights, i);\r\n\r\n    evaluations.push(proposedEval);\r\n\r\n    const delta = proposedEval.fitness - currentEval.fitness;\r\n    const accept = shouldAcceptMove(delta, temperature, rng, verbose, i);\r\n\r\n    if (accept) {\r\n      currentTheta = proposedTheta;\r\n      currentDomain = proposedDomain; // eslint-disable-line sonarjs/no-dead-store -- loop-carried variable\r\n      currentEval = proposedEval;\r\n      acceptedMoves++;\r\n\r\n      if (proposedEval.fitness > bestEval.fitness) {\r\n        bestEval = proposedEval;\r\n        logNewBest(verbose, i, iterations, bestEval.fitness, initialFitness);\r\n      }\r\n    } else {\r\n      rejectedMoves++;\r\n    }\r\n\r\n    convergenceHistory.push(bestEval.fitness);\r\n    temperature *= coolingRate;\r\n\r\n    const converged = checkSAConvergence(\r\n      bestEval.fitness, lastBestFitness, convergenceThreshold,\r\n      noImprovementCount, convergenceWindow, verbose, i\r\n    );\r\n    if (converged.shouldBreak) break;\r\n    noImprovementCount = converged.noImprovementCount;\r\n    lastBestFitness = converged.lastBestFitness;\r\n\r\n    logSAProgress(verbose, i, iterations, bestEval, currentEval, temperature, acceptedMoves, rejectedMoves);\r\n  }\r\n\r\n  const finalFitness = bestEval.fitness;\r\n  const improvement = finalFitness - initialFitness;\r\n  const acceptanceRate = acceptedMoves / (acceptedMoves + rejectedMoves);\r\n\r\n  if (verbose) {\r\n    console.log(\"\\nOptimization complete!\");\r\n    console.log(`Initial fitness: ${initialFitness.toFixed(4)}`);\r\n    console.log(`Final fitness: ${finalFitness.toFixed(4)}`);\r\n    console.log(`Improvement: +${(improvement * 100).toFixed(1)}%`);\r\n    console.log(`Total evaluations: ${evaluations.length}`);\r\n    console.log(`Acceptance rate: ${(acceptanceRate * 100).toFixed(1)}%`);\r\n    console.log(`Final temperature: ${temperature.toFixed(3)}`);\r\n  }\r\n\r\n  return {\r\n    initialConfig: initialDomain,\r\n    optimizedConfig: bestEval.config,\r\n    initialFitness,\r\n    finalFitness,\r\n    improvement,\r\n    iterations: evaluations.length,\r\n    evaluations,\r\n    convergenceHistory,\r\n    settings: optimizationSettings,\r\n  };\r\n}", "parameters": [{"name": "initialDomain", "type": "NamingDomain", "optional": false}, {"name": "validationSettings", "type": "ValidationSettings", "optional": false}, {"name": "fitnessWeights", "type": "FitnessWeights", "optional": false}, {"name": "optimizationSettings", "type": "OptimizationSettings", "optional": false}, {"name": "bounds", "type": "ParameterBounds", "optional": true}, {"name": "seed", "type": "string", "optional": true}, {"name": "siblingDomains", "type": "NamingDomain[]", "optional": true}], "returnType": "Promise<OptimizationResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../utils/rng.js", "specifiers": ["createRNG"], "category": "internal"}, {"source": "../parameter-encoder.js", "specifiers": ["encodeParameters", "decodeParameters", "perturbParameters"], "category": "internal"}, {"source": "./fitness.js", "specifiers": ["computeFitness", "computeFitnessLight"], "category": "internal"}, {"source": "../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["OptimizationSettings", "ValidationSettings", "FitnessWeights", "ParameterBounds", "OptimizationResult", "EvaluationResult"], "category": "internal"}, {"source": "./optimization.js", "specifiers": ["DEFAULT_BOUNDS"], "category": "internal"}]}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalize", "name": "capitalize", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of a string\r\n */\r\nexport function capitalize(str: string): string {\r\n  if (str.length === 0) return str;\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::capitalizeWords", "name": "capitalizeWords", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Capitalize first letter of each word\r\n */\r\nexport function capitalizeWords(str: string): string {\r\n  return str\r\n    .split(/(\\s+)/) // Split but keep whitespace\r\n    .map((part) => {\r\n      // Don't capitalize whitespace-only parts\r\n      if (/^\\s+$/.test(part)) return part;\r\n      return capitalize(part.toLowerCase());\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::mixedCase", "name": "mixedCase", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Alternating capitalization (e.g., \"test name\" \u2192 \"TeSt NaMe\")\r\n */\r\nexport function mixedCase(str: string): string {\r\n  let letterIndex = 0;\r\n  return str\r\n    .split(\"\")\r\n    .map((char) => {\r\n      if (/[a-zA-Z]/.test(char)) {\r\n        const result = letterIndex % 2 === 0 ? char.toUpperCase() : char.toLowerCase();\r\n        letterIndex++;\r\n        return result;\r\n      }\r\n      return char;\r\n    })\r\n    .join(\"\");\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::applyCapitalization", "name": "applyCapitalization", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Apply capitalization style to a string\r\n */\r\nexport function applyCapitalization(\r\n  str: string,\r\n  style: Capitalization\r\n): string {\r\n  switch (style) {\r\n    case \"title\":\r\n      return capitalize(str.toLowerCase());\r\n    case \"titleWords\":\r\n      return capitalizeWords(str);\r\n    case \"allcaps\":\r\n      return str.toUpperCase();\r\n    case \"lowercase\":\r\n      return str.toLowerCase();\r\n    case \"mixed\":\r\n      return mixedCase(str);\r\n    default:\r\n      return str;\r\n  }\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "style", "type": "Capitalization", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::endsWithAny", "name": "endsWithAny", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a string ends with any of the given suffixes\r\n */\r\nexport function endsWithAny(str: string, suffixes: string[]): boolean {\r\n  return suffixes.some((suffix) =>\r\n    str.toLowerCase().endsWith(suffix.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "str", "type": "string", "optional": false}, {"name": "suffixes", "type": "string[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::findSyllableBoundaries", "name": "findSyllableBoundaries", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Find legal positions to insert apostrophes or hyphens\r\n * Returns indices between syllables (not in the middle of syllable templates)\r\n */\r\nexport function findSyllableBoundaries(\r\n  word: string,\r\n  syllables: string[]\r\n): number[] {\r\n  const boundaries: number[] = [];\r\n  let position = 0;\r\n\r\n  for (let i = 0; i < syllables.length - 1; i++) {\r\n    position += syllables[i].length;\r\n    boundaries.push(position);\r\n  }\r\n\r\n  return boundaries;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "syllables", "type": "string[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::insertAtBoundary", "name": "insertAtBoundary", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Insert a character at a random syllable boundary\r\n */\r\nexport function insertAtBoundary(\r\n  word: string,\r\n  char: string,\r\n  boundaries: number[],\r\n  rng: () => number\r\n): string {\r\n  if (boundaries.length === 0) return word;\r\n\r\n  const index = boundaries[Math.floor(rng() * boundaries.length)];\r\n  return word.slice(0, index) + char + word.slice(index);\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "char", "type": "string", "optional": false}, {"name": "boundaries", "type": "number[]", "optional": false}, {"name": "rng", "type": "() => number", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasForbiddenCluster", "name": "hasForbiddenCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Validate that a name doesn't contain forbidden clusters\r\n */\r\nexport function hasForbiddenCluster(\r\n  name: string,\r\n  forbiddenClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return forbiddenClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "forbiddenClusters", "type": "string[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::hasFavoredCluster", "name": "hasFavoredCluster", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Check if a name contains any favored clusters\r\n */\r\nexport function hasFavoredCluster(\r\n  name: string,\r\n  favoredClusters: string[]\r\n): boolean {\r\n  const lower = name.toLowerCase();\r\n  return favoredClusters.some((cluster) =>\r\n    lower.includes(cluster.toLowerCase())\r\n  );\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "favoredClusters", "type": "string[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Count syllables in a word (rough approximation based on vowel groups)\r\n */\r\nexport function estimateSyllableCount(word: string): number {\r\n  // Simple heuristic: count vowel groups\r\n  const vowelGroups = word.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(word: string): number {\r\n  if (word.length === 0) return 0;\r\n  const vowelCount = (word.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / word.length;\r\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::normalizeWeights", "name": "normalizeWeights", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Normalize weights array (make them sum to 1)\r\n */\r\nexport function normalizeWeights(weights: number[]): number[] {\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All zero, return uniform\r\n    return weights.map(() => 1 / weights.length);\r\n  }\r\n  return weights.map((w) => Math.max(0, w) / total);\r\n}", "parameters": [{"name": "weights", "type": "number[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/helpers.ts::deepClone", "name": "deepClone", "kind": "function", "filePath": "apps/name-forge/lib/utils/helpers.ts", "sourceCode": "/**\r\n * Deep clone an object using JSON serialization\r\n * Note: Loses functions, undefined, symbols, etc.\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  return JSON.parse(JSON.stringify(obj)) as T;\r\n}", "parameters": [{"name": "obj", "type": "T", "optional": false}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/utils/rng.ts::createRNG", "name": "createRNG", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Create a seeded random number generator\r\n * Returns a function that produces random numbers in [0, 1)\r\n */\r\nexport function createRNG(seed?: string): () => number {\r\n  if (seed) {\r\n    return seedrandom(seed);\r\n  }\r\n  // Use Math.random for unseeded\r\n  return Math.random;\r\n}", "parameters": [{"name": "seed", "type": "string", "optional": true}], "returnType": "() => number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array\r\n */\r\nexport function pickRandom<T>(rng: () => number, array: T[]): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n  const index = Math.floor(rng() * array.length);\r\n  return array[index];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::pickWeighted", "name": "pickWeighted", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick a random element from an array with weights\r\n * Weights must be non-negative numbers (they'll be normalized)\r\n */\r\nexport function pickWeighted<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  weights?: number[]\r\n): T {\r\n  if (array.length === 0) {\r\n    throw new Error(\"Cannot pick from empty array\");\r\n  }\r\n\r\n  // If no weights or weights length doesn't match, use uniform\r\n  if (!weights || weights.length !== array.length) {\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Normalize weights\r\n  const total = weights.reduce((sum, w) => sum + Math.max(0, w), 0);\r\n  if (total === 0) {\r\n    // All weights are zero, fall back to uniform\r\n    return pickRandom(rng, array);\r\n  }\r\n\r\n  // Pick based on cumulative probabilities\r\n  const r = rng() * total;\r\n  let cumulative = 0;\r\n  for (let i = 0; i < array.length; i++) {\r\n    cumulative += Math.max(0, weights[i]);\r\n    if (r < cumulative) {\r\n      return array[i];\r\n    }\r\n  }\r\n\r\n  // Fallback (shouldn't happen due to floating point)\r\n  return array[array.length - 1];\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Pick multiple random elements from an array without replacement\r\n */\r\nexport function pickMultiple<T>(\r\n  rng: () => number,\r\n  array: T[],\r\n  count: number\r\n): T[] {\r\n  if (count <= 0) {\r\n    return [];\r\n  }\r\n  if (count >= array.length) {\r\n    return [...array];\r\n  }\r\n\r\n  const remaining = [...array];\r\n  const result: T[] = [];\r\n\r\n  for (let i = 0; i < count; i++) {\r\n    const index = Math.floor(rng() * remaining.length);\r\n    result.push(remaining[index]);\r\n    remaining.splice(index, 1);\r\n  }\r\n\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::randomInt", "name": "randomInt", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random integer in range [min, max] inclusive\r\n */\r\nexport function randomInt(rng: () => number, min: number, max: number): number {\r\n  return Math.floor(rng() * (max - min + 1)) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::randomFloat", "name": "randomFloat", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Generate a random number in range [min, max]\r\n */\r\nexport function randomFloat(\r\n  rng: () => number,\r\n  min: number,\r\n  max: number\r\n): number {\r\n  return rng() * (max - min) + min;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "min", "type": "number", "optional": false}, {"name": "max", "type": "number", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::chance", "name": "chance", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Return true with given probability\r\n */\r\nexport function chance(rng: () => number, probability: number): boolean {\r\n  return rng() < probability;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "probability", "type": "number", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/utils/rng.ts::shuffle", "name": "shuffle", "kind": "function", "filePath": "apps/name-forge/lib/utils/rng.ts", "sourceCode": "/**\r\n * Shuffle an array in place using Fisher-Yates algorithm\r\n */\r\nexport function shuffle<T>(rng: () => number, array: T[]): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(rng() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "rng", "type": "() => number", "optional": false}, {"name": "array", "type": "T[]", "optional": false}], "returnType": "T[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "seedrandom", "specifiers": ["seedrandom"], "category": "external"}]}, {"id": "apps/name-forge/lib/validation/index.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}]