[{"id": "apps/lore-weave/lib/systems/connectionEvolution.ts::createConnectionEvolutionSystem", "name": "createConnectionEvolutionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/connectionEvolution.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ConnectionEvolutionConfig\r\n */\r\nexport function createConnectionEvolutionSystem(\r\n  config: ConnectionEvolutionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      return applyConnectionEvolution(config, graphView, modifier);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ConnectionEvolutionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/eraSpawner.ts::createEraEntity", "name": "createEraEntity", "kind": "function", "filePath": "apps/lore-weave/lib/systems/eraSpawner.ts", "sourceCode": "/**\n * Era Spawner System\n *\n * Framework-level system that ensures the first era entity exists in the graph.\n *\n * NEW LAZY SPAWNING MODEL:\n * - Only the FIRST era is spawned at initialization\n * - Subsequent eras are spawned by eraTransition when conditions are met\n * - This supports divergent era paths where the next era depends on world state\n *\n * Era Lifecycle:\n * 1. First era is spawned at init with status='current'\n * 2. eraTransition handles checking exitConditions and finding/spawning next era\n * 3. Era entities are created on-demand when transitioned into\n *\n * This system only runs once to spawn the first era if it doesn't exist.\n */\n\n/**\n * Create an era entity from config.\n * Exported so eraTransition can use it for lazy spawning.\n */\nexport function createEraEntity(\n  configEra: Era,\n  tick: number,\n  status: string,\n  previousEra?: HardState,\n  id?: string\n): { entity: HardState } {\n  // Use config ID as entity ID - this must match the era field in history events\n  const resolvedId = id ?? configEra.id;\n  const eraEntity: HardState = {\n    id: resolvedId,\n    kind: FRAMEWORK_ENTITY_KINDS.ERA,\n    subtype: configEra.id,\n    name: configEra.name,\n    summary: configEra.summary,       // User-defined, locked\n    lockedSummary: true,              // Prevent enrichment from overwriting\n    description: '',                  // LLM will generate via enrichment\n    status: status,\n    prominence: 5.0,  // Eras are always mythic (world-defining)\n    culture: FRAMEWORK_CULTURES.WORLD,  // Eras are world-level entities\n    eraId: resolvedId,\n    tags: {\n      [FRAMEWORK_TAGS.TEMPORAL]: true,\n      [FRAMEWORK_TAGS.ERA]: true,\n      [FRAMEWORK_TAGS.ERA_ID]: configEra.id\n    },\n    createdAt: tick,\n    updatedAt: tick,\n    coordinates: { x: 50, y: 50, z: 50 },  // Eras are world-level, centered in their map\n    temporal: status === FRAMEWORK_STATUS.CURRENT ? {\n      startTick: tick,\n      endTick: null\n    } : undefined\n  };\n\n  return { entity: eraEntity };\n}", "parameters": [{"name": "configEra", "type": "Era", "optional": false}, {"name": "tick", "type": "number", "optional": false}, {"name": "status", "type": "string", "optional": false}, {"name": "previousEra", "type": "HardState", "optional": true}, {"name": "id", "type": "string", "optional": true}], "returnType": "{ entity: HardState }"}, {"id": "apps/lore-weave/lib/systems/eraSpawner.ts::applyEntryEffects", "name": "applyEntryEffects", "kind": "function", "filePath": "apps/lore-weave/lib/systems/eraSpawner.ts", "sourceCode": "/**\n * Apply entry effects when transitioning INTO an era.\n */\nexport function applyEntryEffects(\n  graphView: WorldRuntime,\n  configEra: Era\n): Record<string, number> {\n  const entryEffects = configEra.entryEffects;\n  const mutations = entryEffects?.mutations || [];\n  if (mutations.length === 0) return {};\n\n  const ctx = createSystemContext(graphView);\n  const pressureChanges: Record<string, number> = {};\n\n  for (const mutation of mutations) {\n    const result = prepareMutation(mutation, ctx);\n    for (const [pressureId, delta] of Object.entries(result.pressureChanges)) {\n      pressureChanges[pressureId] = (pressureChanges[pressureId] || 0) + delta;\n    }\n  }\n\n  return pressureChanges;\n}", "parameters": [{"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "configEra", "type": "Era", "optional": false}], "returnType": "Record<string, number>"}, {"id": "apps/lore-weave/lib/systems/eraSpawner.ts::createEraSpawnerSystem", "name": "createEraSpawnerSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/eraSpawner.ts", "sourceCode": "/**\n * Create an Era Spawner system with the given configuration.\n */\nexport function createEraSpawnerSystem(config: EraSpawnerConfig): SimulationSystem {\n  return {\n    id: config.id || 'era_spawner',\n    name: config.name || 'Era Initialization',\n\n    apply: (graphView: WorldRuntime, _modifier: number = 1.0): SystemResult => {\n      // Check if any era entities already exist\n      const existingEras = graphView.findEntities({ kind: FRAMEWORK_ENTITY_KINDS.ERA });\n\n      if (existingEras.length > 0) {\n        // Eras already exist - skip\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${existingEras.length} era entities already exist`\n        };\n      }\n\n      // Get eras from config\n      const configEras = graphView.config.eras;\n      if (!configEras || configEras.length === 0) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: 'No eras defined in config'\n        };\n      }\n\n      // LAZY SPAWNING: Only create the FIRST era at init\n      const firstEraConfig = configEras[0];\n      const { entity: firstEra } = createEraEntity(\n        firstEraConfig,\n        graphView.tick,\n        FRAMEWORK_STATUS.CURRENT,\n        undefined,\n        firstEraConfig.id  // Use config ID directly\n      );\n\n      // Add era entity to graph\n      graphView.loadEntity(firstEra);\n\n      // Set currentEra reference\n      graphView.setCurrentEra(firstEraConfig);\n\n      // Apply entry effects for the first era\n      const pressureChanges = applyEntryEffects(graphView, firstEraConfig);\n\n      graphView.log('info', `[EraSpawner] Started first era: ${firstEraConfig.name}`);\n\n      return {\n        relationshipsAdded: [],\n        entitiesModified: [],\n        pressureChanges,\n        description: `Started first era: ${firstEraConfig.name}`\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "EraSpawnerConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/eraTransition.ts::createEraTransitionSystem", "name": "createEraTransitionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/eraTransition.ts", "sourceCode": "/**\n * Era Transition System\n *\n * Framework-level system that handles era transitions based on exit/entry conditions.\n *\n * TRANSITION MODEL:\n * - exitConditions: Criteria for current era to END (all must be met)\n * - entryConditions: Criteria for next era to START (all must be met)\n * - nextEra: Optional explicit next era ID (supports divergent paths)\n * - exitEffects: Applied when transitioning OUT of current era\n * - entryEffects: Applied when transitioning INTO next era\n *\n * LAZY SPAWNING:\n * - Era entities are created on-demand when transitioned into\n * - Only the first era is spawned at init (by eraSpawner)\n *\n * Transition Logic:\n * 1. Check exitConditions for current era\n * 2. If met, find next era:\n *    a. If nextEra is set, use that specific era\n *    b. Otherwise, find first era whose entryConditions are met\n * 3. Spawn the next era entity (lazy spawning)\n * 4. Apply exitEffects, then entryEffects\n * 5. Update current era status to 'historical', new era to 'current'\n */\n\n/**\n * Create an Era Transition system with the given configuration.\n */\nexport function createEraTransitionSystem(config: EraTransitionConfig): SimulationSystem {\n  return {\n    id: config.id || 'era_transition',\n    name: config.name || 'Era Progression',\n\n    apply: (graphView: WorldRuntime, _modifier: number = 1.0): SystemResult => {\n      // Find current era entity\n      const currentEraEntity = graphView.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0];\n\n      if (!currentEraEntity) {\n        // No current era - this shouldn't happen as eraSpawner creates the first era\n        graphView.debug('eras', 'No current era found');\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: 'No current era'\n        };\n      }\n\n      // Initialize temporal tracking if missing\n      if (currentEraEntity.temporal?.startTick == null) {\n        const startTick = currentEraEntity.createdAt ?? graphView.tick;\n        currentEraEntity.temporal = {\n          startTick,\n          endTick: currentEraEntity.temporal?.endTick ?? null\n        };\n      }\n\n      const timeSinceStart = graphView.tick - currentEraEntity.temporal.startTick;\n\n      // Get era config for current era\n      const currentEraConfig = graphView.config.eras.find(e => e.id === currentEraEntity.subtype);\n\n      if (!currentEraConfig) {\n        graphView.log('warn',\n          `[EraTransition] No era config found for \"${currentEraEntity.name}\" (subtype=\"${currentEraEntity.subtype}\")`,\n          { availableEras: graphView.config.eras.map(e => e.id) }\n        );\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${currentEraEntity.name} persists (config not found)`\n        };\n      }\n\n      const exitConditions = currentEraConfig.exitConditions || [];\n\n      // Check exit conditions\n      const { shouldTransition, conditionResults } = checkTransitionConditions(\n        currentEraEntity,\n        graphView,\n        exitConditions\n      );\n\n      if (!shouldTransition) {\n        // Build detailed condition status string\n        const conditionSummary = conditionResults.map(r => {\n          const status = r.passed ? '\u2713' : '\u2717';\n          return `${status} ${r.type}: ${r.diagnostic}`;\n        }).join(' | ');\n\n        graphView.debug('eras',\n          `${currentEraEntity.name}: exit conditions not met (age=${timeSinceStart}) [${conditionSummary}]`,\n          { eraAge: timeSinceStart, conditionResults }\n        );\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${currentEraEntity.name} persists`\n        };\n      }\n\n      // Exit conditions met - find next era\n      const nextEraConfig = findNextEra(currentEraConfig, currentEraEntity, graphView);\n\n      if (!nextEraConfig) {\n        // No valid next era found - current era continues\n        graphView.debug('eras', `${currentEraEntity.name}: final era or no valid next era`);\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${currentEraEntity.name} endures (final era)`\n        };\n      }\n\n      // Log transition conditions met\n      const conditionSummary = conditionResults.map(r => {\n        const status = r.passed ? '\u2713' : '\u2717';\n        return `${status} ${r.type}: ${r.diagnostic}`;\n      }).join(' | ');\n\n      graphView.debug('eras',\n        `${currentEraEntity.name}: exit conditions MET (age=${timeSinceStart}) [${conditionSummary}]`,\n        { eraAge: timeSinceStart, conditionResults }\n      );\n\n      // LAZY SPAWNING: Create new era entity\n      const { entity: nextEraEntity } = createEraEntity(\n        nextEraConfig,\n        graphView.tick,\n        FRAMEWORK_STATUS.CURRENT,\n        currentEraEntity,\n        nextEraConfig.id  // Use config ID directly to match history event era field\n      );\n\n      // Add new era entity to graph\n      graphView.loadEntity(nextEraEntity);\n\n      // Update current era to historical\n      currentEraEntity.status = FRAMEWORK_STATUS.HISTORICAL;\n      currentEraEntity.temporal.endTick = graphView.tick;\n      currentEraEntity.updatedAt = graphView.tick;\n\n      // Update graph's currentEra reference\n      graphView.setCurrentEra(nextEraConfig);\n\n      // Log transition\n      graphView.debug('eras', `TRANSITIONING: ${currentEraEntity.name} \u2192 ${nextEraEntity.name}`, {\n        tick: graphView.tick,\n        fromEra: currentEraEntity.subtype,\n        toEra: nextEraEntity.subtype\n      });\n\n      // Collect pressure changes: exitEffects then entryEffects\n      const pressureChanges: Record<string, number> = {};\n\n      const exitPressureChanges = collectEffectPressureChanges(\n        graphView,\n        currentEraConfig.exitEffects,\n        currentEraEntity\n      );\n      for (const [pressureId, delta] of Object.entries(exitPressureChanges)) {\n        pressureChanges[pressureId] = (pressureChanges[pressureId] || 0) + delta;\n      }\n\n      const entryPressureChanges = collectEffectPressureChanges(\n        graphView,\n        nextEraConfig.entryEffects,\n        nextEraEntity\n      );\n      for (const [pressureId, delta] of Object.entries(entryPressureChanges)) {\n        pressureChanges[pressureId] = (pressureChanges[pressureId] || 0) + delta;\n      }\n\n      // Create supersedes relationship\n      const relationshipsAdded: SystemResult['relationshipsAdded'] = [{\n        kind: FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        src: nextEraEntity.id,\n        dst: currentEraEntity.id,\n        strength: 1.0,\n        createdAt: graphView.tick\n      }];\n\n      // Create active_during relationships for prominent entities in the ending era\n      // Prominence >= 2.0 = recognized or higher\n      const prominentEntities = graphView.getEntities().filter(e =>\n        e.prominence >= 2.0 &&\n        e.kind !== FRAMEWORK_ENTITY_KINDS.ERA &&\n        e.createdAt >= currentEraEntity.temporal!.startTick &&\n        e.createdAt < graphView.tick\n      );\n\n      // Link up to 10 most prominent entities to the ending era\n      prominentEntities.slice(0, 10).forEach(entity => {\n        relationshipsAdded.push({\n          kind: FRAMEWORK_RELATIONSHIP_KINDS.ACTIVE_DURING,\n          src: entity.id,\n          dst: currentEraEntity.id,\n          strength: 1.0,\n          createdAt: graphView.tick\n        });\n      });\n\n      const snapshotConfig = config.prominenceSnapshot;\n      const snapshotModifications: Array<{ id: string; changes: Partial<HardState> }> = [];\n      let snapshotLockedCount = 0;\n\n      if (snapshotConfig?.enabled) {\n        const minProminence = snapshotConfig.minProminence ?? 'renowned';\n        const minThreshold = prominenceThreshold(minProminence as ProminenceLabel);\n        if (minThreshold >= 0) {\n          const entitiesToLock = graphView.getEntities().filter(e =>\n            e.kind !== FRAMEWORK_ENTITY_KINDS.ERA &&\n            e.prominence >= minThreshold &&\n            !hasTag(e.tags, FRAMEWORK_TAGS.PROMINENCE_LOCKED)\n          );\n\n          entitiesToLock.forEach(entity => {\n            const newTags = { ...(entity.tags ?? {}), [FRAMEWORK_TAGS.PROMINENCE_LOCKED]: currentEraConfig.id };\n            graphView.updateEntity(entity.id, { tags: newTags });\n            snapshotModifications.push({ id: entity.id, changes: { tags: newTags } });\n          });\n          snapshotLockedCount = entitiesToLock.length;\n        }\n      }\n\n      return {\n        relationshipsAdded,\n        entitiesModified: [\n          { id: currentEraEntity.id, changes: { status: FRAMEWORK_STATUS.HISTORICAL, temporal: currentEraEntity.temporal } },\n          ...snapshotModifications\n        ],\n        pressureChanges,\n        description: `Era transition: ${currentEraEntity.name} \u2192 ${nextEraEntity.name} (${prominentEntities.length} entities linked, ${snapshotLockedCount} prominence locked)`,\n        details: {\n          eraTransition: {\n            fromEra: currentEraEntity.name,\n            fromEraId: currentEraConfig.id,\n            toEra: nextEraEntity.name,\n            toEraId: nextEraConfig.id,\n            tickInEra: timeSinceStart,\n            exitConditionsMet: conditionResults.filter(r => r.passed).map(r => ({\n              type: r.type,\n              ...r.details\n            })),\n            prominentEntitiesLinked: prominentEntities.length,\n            prominenceLocked: snapshotLockedCount,\n            pressureEffects: pressureChanges\n          }\n        }\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "EraTransitionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/eraTransition.ts::checkTransitionConditions", "name": "checkTransitionConditions", "kind": "function", "filePath": "apps/lore-weave/lib/systems/eraTransition.ts", "sourceCode": "/**\n * Check if conditions are met for era transition.\n * ALL conditions must pass for the check to succeed.\n */\nexport function checkTransitionConditions(\n  currentEra: HardState,\n  graphView: WorldRuntime,\n  conditions: TransitionCondition[]\n): TransitionCheckResult {\n  // Empty conditions array = allow immediate transition\n  if (conditions.length === 0) {\n    return {\n      shouldTransition: true,\n      conditionResults: [{\n        type: 'none',\n        passed: true,\n        diagnostic: 'empty conditions array - immediate transition',\n        details: { reason: 'empty conditions array - immediate transition' }\n      }]\n    };\n  }\n\n  const baseCtx = createSystemContext(graphView);\n  const ctx = { ...baseCtx, self: currentEra };\n\n  const conditionResults: TransitionConditionResult[] = conditions.map((condition) => {\n    const result: ConditionResult = evaluateCondition(condition, ctx, currentEra);\n    return {\n      type: condition.type,\n      passed: result.passed,\n      diagnostic: result.diagnostic,\n      details: result.details,\n    };\n  });\n\n  return {\n    shouldTransition: conditionResults.every(r => r.passed),\n    conditionResults\n  };\n}", "parameters": [{"name": "currentEra", "type": "HardState", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "conditions", "type": "TransitionCondition[]", "optional": false}], "returnType": "TransitionCheckResult"}, {"id": "apps/lore-weave/lib/systems/graphContagion.ts::createGraphContagionSystem", "name": "createGraphContagionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/graphContagion.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a GraphContagionConfig\r\n */\r\nexport function createGraphContagionSystem(\r\n  config: GraphContagionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Use multi-source mode if configured, otherwise single-source mode\r\n      if (config.multiSource) {\r\n        return applyMultiSourceContagion(config, graphView, modifier);\r\n      } else {\r\n        return applySingleSourceContagion(config, graphView, modifier);\r\n      }\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "GraphContagionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/growthSystem.ts::createGrowthSystem", "name": "createGrowthSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/growthSystem.ts", "sourceCode": "export function createGrowthSystem(\n  config: GrowthSystemConfig,\n  deps: GrowthSystemDependencies\n): GrowthSystem {\n  const state: GrowthState = {\n    epoch: -1,\n    epochTarget: 0,\n    entitiesCreated: 0,\n    templatesApplied: 0,\n    templatesUsed: new Set(),\n    yieldSamples: [],\n    phaseCompleted: false\n  };\n\n  const maxTemplatesPerTick = config.maxTemplatesPerTick ?? 5;\n  const minTemplatesPerTick = config.minTemplatesPerTick ?? 1;\n  const yieldWindow = config.yieldAveragingWindow ?? 30;\n  const maxAttemptsPerTick = config.maxAttemptsPerTick ?? 40;\n\n  function getExpectedYield(): number {\n    if (state.yieldSamples.length === 0) return 1;\n    const avg = state.yieldSamples.reduce((sum, val) => sum + val, 0) / state.yieldSamples.length;\n    // Avoid runaway budgets from unlucky zeros\n    return Math.max(1, avg);\n  }\n\n  function recordPhaseCompletion(graphView: WorldRuntime, reason: GrowthPhaseCompletion['reason']): void {\n    if (state.phaseCompleted) return;\n    if (state.epochTarget <= 0) return;\n    const eraId = state.epochEra?.id ?? deps.getEpochEra().id;\n    if (!eraId) return;\n\n    state.phaseCompleted = true;\n    graphView.growthPhaseHistory.push({\n      epoch: state.epoch,\n      eraId,\n      tick: graphView.tick,\n      reason\n    });\n  }\n\n  async function applyTemplateOnce(\n    template: GrowthTemplate,\n    graphView: WorldRuntime,\n    _era: Era\n  ): Promise<number> {\n    try {\n      // Check applicability\n      if (!template.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n          if (!diag.applicabilityPassed) {\n            graphView.debug('templates', `${template.id} rejected: ${diag.failedRules.join('; ')}`);\n          } else if (diag.selectionCount === 0) {\n            graphView.debug('templates', `${template.id} selection(${diag.selectionStrategy}) returned 0 targets`);\n          }\n        }\n        return 0;\n      }\n\n      const templateTargets = template.findTargets(graphView);\n      if (templateTargets.length === 0) {\n        graphView.debug('selection', `${template.id} found no targets via findTargets()`);\n        return 0;\n      }\n\n      const target = pickRandom(templateTargets);\n\n      const pressureModsBefore = deps.getPendingPressureModifications().length;\n      graphView.setPressureModificationCallback((pressureId, delta, source) => {\n        deps.trackPressureModification(pressureId, delta, source);\n      });\n      graphView.setCurrentSource({ type: 'template', templateId: template.id });\n\n      // LINEAGE: Enter template context for entity/relationship stamping.\n      // All entities and relationships created will have\n      // createdBy = { tick, source: 'template', sourceId: template.id }.\n      // See LINEAGE.md for design details.\n      // NOTE: Context must stay open until AFTER addEntity/createRelationship calls below.\n      deps.mutationTracker?.enterContext('template', template.id);\n\n      let result: import('../engine/types').TemplateResult;\n      try {\n        result = await template.expand(graphView, target);\n      } catch (error) {\n        // LINEAGE: Exit context on expand error\n        deps.mutationTracker?.exitContext();\n        throw error;\n      }\n      graphView.clearCurrentSource();\n\n      // Contract enforcement warnings\n      const allTagsSet = new Set<string>();\n      for (const entity of result.entities) {\n        Object.keys(entity.tags || {}).forEach(tag => allTagsSet.add(tag));\n      }\n      const allTagsToAdd = Array.from(allTagsSet);\n      const tagSaturationCheck = deps.contractEnforcer.checkTagSaturation(graphView, allTagsToAdd);\n      if (tagSaturationCheck.saturated) {\n        deps.emitter.log('warn', `Template ${template.id} would oversaturate tags: ${tagSaturationCheck.oversaturatedTags.join(', ')}`);\n      }\n      const orphanCheck = deps.contractEnforcer.checkTagOrphans(allTagsToAdd);\n      if (orphanCheck.hasOrphans && orphanCheck.orphanTags.length >= 3) {\n        deps.emitter.log('debug', `Template ${template.id} creates unregistered tags: ${orphanCheck.orphanTags.slice(0, 5).join(', ')}`);\n      }\n\n      deps.statisticsCollector.recordTemplateApplication(template.id);\n\n      const createdEntities: HardState[] = [];\n      const newIds: string[] = [];\n\n      for (let i = 0; i < result.entities.length; i++) {\n        const entity = result.entities[i];\n        const placementStrategy = result.placementStrategies?.[i] || 'unknown';\n        const id = await graphView.addEntity(entity, `template:${template.id}`, placementStrategy);\n        newIds.push(id);\n        const ref = graphView.getEntity(id);\n        if (ref) {\n          createdEntities.push(ref);\n        }\n      }\n\n      for (const entity of createdEntities) {\n        initializeCatalystSmart(entity);\n      }\n\n      result.relationships.forEach(rel => {\n        const srcId = rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src;\n        const dstId = rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst;\n\n        if (srcId && dstId) {\n          graphView.createRelationship(rel.kind, srcId, dstId, rel.strength);\n        }\n      });\n\n      // LINEAGE: Exit template context now that entities/relationships are created.\n      // They are now stamped with createdBy = { source: 'template', sourceId: template.id }.\n      deps.mutationTracker?.exitContext();\n\n      for (const entity of createdEntities) {\n        const coverageCheck = deps.contractEnforcer.enforceTagCoverage(entity, graphView);\n        if (coverageCheck.needsAdjustment) {\n          deps.emitter.log('debug', coverageCheck.suggestion || '', { entity: entity.id });\n        }\n        const taxonomyCheck = deps.contractEnforcer.validateTagTaxonomy(entity);\n        if (!taxonomyCheck.valid) {\n          deps.emitter.log('warn', `Entity ${entity.name} has conflicting tags`, { conflicts: taxonomyCheck.conflicts });\n        }\n      }\n\n      // Record creation batch for narrative event generation\n      if (newIds.length > 0) {\n        // Summarize relationships by kind\n        const relationshipCounts = new Map<string, number>();\n        for (const rel of result.relationships) {\n          relationshipCounts.set(rel.kind, (relationshipCounts.get(rel.kind) || 0) + 1);\n        }\n        const relationshipSummary: RelationshipSummary[] = [];\n        for (const [kind, count] of relationshipCounts) {\n          relationshipSummary.push({ kind, count });\n        }\n\n        // Use description from first creation item if available\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        const rawDescription = declTemplate?.creation?.[0]?.description;\n        // DescriptionSpec can be string or { template, replacements } - extract string if possible\n        const primaryDescription = typeof rawDescription === 'string' ? rawDescription : undefined;\n\n        // Generate narration ONCE here, now that entities have names\n        // result.resolvedVariables contains $target, $enemy, etc. from template expansion\n        let narration: string | undefined;\n        if (declTemplate?.narrationTemplate) {\n          // Start with the resolved variables from template expansion (like $target, $enemy)\n          const variables: Record<string, HardState | HardState[] | undefined> = {\n            ...(result.resolvedVariables || {}),\n          };\n\n          // Add created entities by their entityRef (like $war, $ideology)\n          // Use entityRefToIndex mapping since createChance can skip entities\n          if (result.entityRefToIndex) {\n            for (const [entityRef, idx] of Object.entries(result.entityRefToIndex)) {\n              const index = idx;\n              if (createdEntities[index]) {\n                // Ensure $ prefix for the key\n                const key = entityRef.startsWith('$') ? entityRef : `$${entityRef}`;\n                variables[key] = createdEntities[index];\n              }\n            }\n          }\n\n          const narrationCtx = createGeneratorContext({\n            target,\n            variables,\n          });\n          const narrationResult = interpolate(declTemplate.narrationTemplate, narrationCtx);\n          // Use narration even if not complete - partial narration better than mechanical\n          narration = narrationResult.text;\n          if (!narrationResult.complete) {\n            // Debug: log unresolved tokens (use debug level since partial is expected sometimes)\n            console.debug(`[GrowthSystem] Template ${template.id} narration partial:`, {\n              unresolvedTokens: narrationResult.unresolvedTokens,\n              variableKeys: Object.keys(variables),\n            });\n          }\n        }\n\n        deps.stateChangeTracker.recordCreationBatch(\n          template.id,\n          template.name || template.id,\n          newIds,\n          relationshipSummary,\n          primaryDescription || result.description,\n          narration\n        );\n      }\n\n      const templatePressureMods = deps.getPendingPressureModifications().slice(pressureModsBefore);\n      const pressureChanges: Record<string, number> = {};\n      for (const mod of templatePressureMods) {\n        pressureChanges[mod.pressureId] = (pressureChanges[mod.pressureId] || 0) + mod.delta;\n      }\n\n      const resolvedRelationships = result.relationships.map(rel => ({\n        kind: rel.kind,\n        srcId: rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src,\n        dstId: rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst,\n        strength: rel.strength\n      }));\n\n      deps.emitter.templateApplication({\n        tick: graphView.tick,\n        epoch: deps.getCurrentEpoch(),\n        templateId: template.id,\n        targetEntityId: target.id,\n        targetEntityName: target.name,\n        targetEntityKind: target.kind,\n        description: result.description,\n        entitiesCreated: createdEntities.map((e, i) => {\n          const placementDebug = result.placementDebugList?.[i];\n          const strategy = result.placementStrategies?.[i] || 'unknown';\n          return {\n            id: e.id,\n            name: e.name,\n            kind: e.kind,\n            subtype: e.subtype,\n            culture: e.culture,\n            prominence: prominenceLabel(e.prominence),\n            tags: e.tags,\n            placementStrategy: strategy,\n            coordinates: e.coordinates,\n            regionId: placementDebug?.regionId ?? e.regionId,\n            allRegionIds: placementDebug?.allRegionIds ?? e.allRegionIds,\n            derivedTags: result.derivedTagsList?.[i],\n            placement: placementDebug ? {\n              anchorType: placementDebug.anchorType,\n              anchorEntity: placementDebug.anchorEntity,\n              anchorCulture: placementDebug.anchorCulture,\n              resolvedVia: placementDebug.resolvedVia,\n              seedRegionsAvailable: placementDebug.seedRegionsAvailable,\n              emergentRegionCreated: placementDebug.emergentRegionCreated\n            } : undefined\n          };\n        }),\n        relationshipsCreated: resolvedRelationships,\n        pressureChanges\n      });\n\n      return result.entities.length;\n    } catch (error) {\n      graphView.clearCurrentSource();\n      const message = error instanceof Error ? error.message : String(error);\n      const templateLabel = template.name ? `${template.name} (${template.id})` : template.id;\n      throw new Error(`Template ${templateLabel} failed: ${message}`);\n    }\n  }\n\n  function buildApplicableTemplates(\n    graphView: WorldRuntime,\n    rejectionReasons: Map<string, string>\n  ): GrowthTemplate[] {\n    return deps.runtimeTemplates.filter(t => {\n      const runCount = deps.templateRunCounts.get(t.id) || 0;\n      if (runCount >= deps.maxRunsPerTemplate) {\n        rejectionReasons.set(t.id, `run_cap: ${runCount}/${deps.maxRunsPerTemplate}`);\n        return false;\n      }\n\n      if (!t.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(t.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n// ... (truncated)", "parameters": [{"name": "config", "type": "GrowthSystemConfig", "optional": false}, {"name": "deps", "type": "GrowthSystemDependencies", "optional": false}], "returnType": "GrowthSystem"}, {"id": "apps/lore-weave/lib/systems/planeDiffusion.ts::createPlaneDiffusionSystem", "name": "createPlaneDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/planeDiffusion.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a PlaneDiffusionConfig\r\n */\r\nexport function createPlaneDiffusionSystem(\r\n  config: PlaneDiffusionConfig\r\n): SimulationSystem<DiffusionState> {\r\n  const diffusionRate = config.diffusion.rate ?? 0.2;\r\n  const sourceRadius = config.diffusion.sourceRadius ?? 1;\r\n  const decayRate = config.diffusion.decayRate ?? 0; // Default to 0\r\n  const falloffType = config.diffusion.falloffType ?? 'absolute';\r\n  const iterationsPerTick = config.diffusion.iterationsPerTick ?? 20; // Default 20 for fast spreading\r\n\r\n  // Validate ranges\r\n  if (diffusionRate < 0 || diffusionRate > 1) {\r\n    throw new Error(`[${config.id}] Diffusion rate must be between 0 and 1, got ${diffusionRate}`);\r\n  }\r\n  if (decayRate < 0 || decayRate > 1) {\r\n    throw new Error(`[${config.id}] Decay rate must be between 0 and 1, got ${decayRate}`);\r\n  }\r\n  if (sourceRadius < 0 || sourceRadius > 50) {\r\n    throw new Error(`[${config.id}] Source radius must be between 0 and 50, got ${sourceRadius}`);\r\n  }\r\n  if (!config.selection?.kind) {\r\n    throw new Error(`[${config.id}] Plane diffusion requires selection.kind to define the semantic plane.`);\r\n  }\r\n\r\n  // Create the system with internal state\r\n  const system: SimulationSystem<DiffusionState> = {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    // Internal state - will be initialized by initialize()\r\n    state: undefined,\r\n\r\n    // Initialize the grid on first use\r\n    initialize: function() {\r\n      this.state = {\r\n        grid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        tempGrid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        initialized: true,\r\n      };\r\n    },\r\n\r\n    apply: function(graphView: WorldRuntime, _modifier: number = 1.0): SystemResult {\r\n      // Ensure state is initialized (safety check)\r\n      if (!this.state?.initialized) {\r\n        this.initialize!();\r\n      }\r\n      const state = this.state!;\r\n\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        // eslint-disable-next-line sonarjs/pseudo-random -- simulation throttle check\r\n        if (Math.random() > config.throttleChance) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`,\r\n            details: {\r\n              diffusionSnapshot: {\r\n                grid: Array.from(state.grid),\r\n                gridSize: GRID_SIZE,\r\n                sources: [],\r\n                sinks: [],\r\n                entities: [],\r\n              },\r\n            },\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const metricCtx = createSystemContext(graphView);\r\n\r\n      const getFalloff = (distance: number, strength: number): number => {\r\n        const maxDistance = falloffType === 'absolute' ? strength : sourceRadius + 1;\r\n        if (maxDistance <= 0) return 0;\r\n        const metric: Metric = {\r\n          type: 'falloff',\r\n          falloffType,\r\n          distance,\r\n          maxDistance,\r\n        };\r\n        return evaluateMetric(metric, metricCtx).value;\r\n      };\r\n\r\n      // Find all entities on the target plane\r\n      const entities = selectEntities(config.selection, metricCtx);\r\n\r\n      // Filter to entities with valid coordinates\r\n      const entitiesWithCoords = entities.filter(hasCoordinates);\r\n\r\n      // Identify sources and sinks\r\n      const sources = entitiesWithCoords.filter(e => hasTag(e.tags, config.sources.tagFilter));\r\n      const sinks = config.sinks\r\n        ? entitiesWithCoords.filter(e => hasTag(e.tags, config.sinks!.tagFilter))\r\n        : [];\r\n\r\n      // =======================================================================\r\n      // STEP 1: Build a mask of fixed boundary cells (only when decay=0)\r\n      // - decay=0: Sources SET values, need Dirichlet boundary (fixed during diffusion)\r\n      // - decay>0: Sources ADD values, no fixed boundary (diffusion happens normally)\r\n      // - Sinks never create fixed cells - they subtract and let diffusion happen\r\n      // =======================================================================\r\n      const fixedCells = new Set<number>();\r\n\r\n      // Only create fixed boundaries when decay=0 (SET mode)\r\n      if (decayRate === 0) {\r\n        for (const source of sources) {\r\n          const gx = coordToGrid(source.coordinates.x);\r\n          const gy = coordToGrid(source.coordinates.y);\r\n          for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n            for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n              const dist = Math.sqrt(dx * dx + dy * dy);\r\n              if (dist <= sourceRadius) {\r\n                const nx = gx + dx;\r\n                const ny = gy + dy;\r\n                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {\r\n                  fixedCells.add(ny * GRID_SIZE + nx);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2a: Sources SET (decay=0) or ADD (decay>0) their values\r\n      // - decay=0: Dirichlet boundary - stable fixed values\r\n      // - decay>0: Injection model - add per tick, decay prevents unbounded growth\r\n      // =======================================================================\r\n      const sourceMode = decayRate > 0 ? 'add' : 'set';\r\n\r\n      for (const source of sources) {\r\n        const gx = coordToGrid(source.coordinates.x);\r\n        const gy = coordToGrid(source.coordinates.y);\r\n        // Note: source strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(source, config.sources.strengthTag, config.sources.defaultStrength);\r\n\r\n        // Set/Add values within source radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const injectionValue = strength * falloff;\r\n\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              if (sourceMode === 'add') {\r\n                // ADD mode: inject on top of existing value\r\n                const currentValue = getGridValue(state.grid, nx, ny);\r\n                setGridValue(state.grid, nx, ny, currentValue + injectionValue);\r\n              } else {\r\n                // SET mode: fixed boundary value\r\n                setGridValue(state.grid, nx, ny, injectionValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2b: Sinks SUBTRACT from existing values (not SET)\r\n      // This allows sinks in source regions to reduce the field, not overwrite it\r\n      // =======================================================================\r\n      for (const sink of sinks) {\r\n        const gx = coordToGrid(sink.coordinates.x);\r\n        const gy = coordToGrid(sink.coordinates.y);\r\n        // Note: sink strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(sink, config.sinks!.strengthTag, config.sinks!.defaultStrength);\r\n\r\n        // Subtract values within sink radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const subtractAmount = strength * falloff;\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              const currentValue = getGridValue(state.grid, nx, ny);\r\n              setGridValue(state.grid, nx, ny, currentValue - subtractAmount);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3: Apply diffusion (heat equation)\r\n      // Skip source cells (Dirichlet source), edges diffuse normally (Neumann-like)\r\n      // Out-of-bounds neighbors return 0, so edges naturally trend toward 0\r\n      // =======================================================================\r\n      for (let iter = 0; iter < iterationsPerTick; iter++) {\r\n        state.tempGrid.set(state.grid);\r\n\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n\r\n            // Skip source cells - they maintain their set values\r\n            if (fixedCells.has(idx)) {\r\n              continue;\r\n            }\r\n\r\n            const current = getGridValue(state.tempGrid, x, y);\r\n\r\n            // Get 4-connected neighbors (out-of-bounds returns 0)\r\n            const north = getGridValue(state.tempGrid, x, y - 1);\r\n            const south = getGridValue(state.tempGrid, x, y + 1);\r\n            const east = getGridValue(state.tempGrid, x + 1, y);\r\n            const west = getGridValue(state.tempGrid, x - 1, y);\r\n\r\n            // Average of neighbors\r\n            const neighborAvg = (north + south + east + west) / 4;\r\n\r\n            // Diffusion: move toward neighbor average\r\n            const diffused = current + diffusionRate * (neighborAvg - current);\r\n\r\n            setGridValue(state.grid, x, y, diffused);\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3b: Apply decay ONCE per tick (not per iteration)\r\n      // =======================================================================\r\n      if (decayRate > 0) {\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n            // Don't decay fixed boundary cells\r\n            if (!fixedCells.has(idx)) {\r\n              const current = getGridValue(state.grid, x, y);\r\n              setGridValue(state.grid, x, y, current * (1 - decayRate));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 4: Sample grid at entity positions and set tags (CLAMPED OUTPUT)\r\n      // Track significant modifications (new output tags) separately from\r\n      // value tag updates to avoid false positives in the trace.\r\n      // =======================================================================\r\n      let significantModificationCount = 0;\r\n\r\n      for (const entity of entitiesWithCoords) {\r\n        const rawFieldValue = sampleGrid(state.grid, entity.coordinates.x, entity.coordinates.y);\r\n        // Clamp to output range for game space\r\n        const fieldValue = clampToOutput(rawFieldValue);\r\n\r\n        const newTags: Record<string, boolean | string> = { ...entity.tags };\r\n        let tagsChanged = false;\r\n\r\n        // Track which output tags the entity currently has\r\n        const previousOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            previousOutputTags.add(outputTag.tag);\r\n          }\r\n        }\r\n\r\n        // Remove old output tags and value tag\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            delete newTags[outputTag.tag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n        if (config.valueTag) {\r\n          if (config.valueTag in newTags) {\r\n            delete newTags[config.valueTag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n\r\n        // Add appropriate output tag based on thresholds (using clamped value)\r\n        // Track if any NEW output tag was added (not previously present)\r\n        let newOutputTagAdded = false;\r\n        let gainedOutputTag: DiffusionOutputTag | undefined;\r\n        const newOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          const minOk = outputTag.minValue === undefined || fieldValue >= outputTag.minValue;\r\n          const maxOk = outputTag.maxValue === undefined || fieldValue < outputTag.maxValue;\r\n\r\n          if (minOk && maxOk) {\r\n            newTags[outputTag.tag] = true;\r\n            newOutputTags.add(outputTag.tag);\r\n            tagsChanged = true;\r\n            // This is a significant change if entity didn't have this tag before\r\n            if (!previousOutputTags.has(outputTag.tag)) {\r\n              newOutputTagAdded = true;\r\n              gainedOutputTag = outputTag;\r\n// ... (truncated)", "parameters": [{"name": "config", "type": "PlaneDiffusionConfig", "optional": false}], "returnType": "SimulationSystem<DiffusionState>"}, {"id": "apps/lore-weave/lib/systems/relationshipMaintenance.ts::createRelationshipMaintenanceSystem", "name": "createRelationshipMaintenanceSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/relationshipMaintenance.ts", "sourceCode": "// =============================================================================\n// SYSTEM CREATION\n// =============================================================================\n\n/**\n * Create a Relationship Maintenance system with the given configuration.\n */\nexport function createRelationshipMaintenanceSystem(config: RelationshipMaintenanceConfig): SimulationSystem {\n  // Extract config with defaults\n  const maintenanceFrequency = config.maintenanceFrequency ?? 5;\n  const cullThreshold = config.cullThreshold ?? 0.15;\n  const gracePeriod = config.gracePeriod ?? 20;\n  const reinforcementBonus = config.reinforcementBonus ?? 0.02;\n  const maxStrength = config.maxStrength ?? 1.0;\n  const proximityRelationshipKinds = config.proximityRelationshipKinds ?? [];\n\n  return {\n    id: config.id || 'relationship_maintenance',\n    name: config.name || 'Relationship Maintenance',\n\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\n      // Only run every N ticks\n      if (graphView.tick % maintenanceFrequency !== 0) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: 'Relationship maintenance dormant'\n        };\n      }\n\n      // Get all relationships including historical\n      const allRelationships = graphView.getAllRelationships({ includeHistorical: true });\n      const originalCount = allRelationships.filter(r => r.status !== 'historical').length;\n\n      let decayed = 0;\n      let reinforced = 0;\n      let archived = 0;\n      let removed = 0;\n\n      const metricCtx = createSystemContext(graphView);\n\n      const maintainedRelationships: Relationship[] = [];\n      const modifiedEntityIds = new Set<string>();\n\n      for (const rel of allRelationships) {\n        // Preserve historical relationships unchanged\n        if (rel.status === 'historical') {\n          maintainedRelationships.push(rel);\n          continue;\n        }\n\n        const srcEntity = graphView.getEntity(rel.src);\n        const dstEntity = graphView.getEntity(rel.dst);\n\n        // Remove relationships to non-existent entities (can't archive - no entity to reference)\n        if (!srcEntity || !dstEntity) {\n          removed++;\n          continue;\n        }\n\n        // Calculate relationship age\n        const age = Math.min(\n          graphView.tick - srcEntity.createdAt,\n          graphView.tick - dstEntity.createdAt\n        );\n\n        // Young relationships are protected\n        const isYoung = age < gracePeriod;\n\n        // Get relationship kind properties\n        const decayRate = getDecayRate(graphView, rel.kind);\n        const cullable = isCullable(graphView, rel.kind);\n\n        let strength = rel.strength ?? 0.5;\n\n        // === DECAY ===\n        // Apply decay to relationships that aren't young and have decay enabled\n        if (!isYoung && decayRate !== 'none') {\n          const decayAmount = getDecayAmount(decayRate, metricCtx) * modifier;\n          strength = Math.max(0, strength - decayAmount);\n          decayed++;\n        }\n\n        // === REINFORCEMENT ===\n        // Strengthen relationships when entities are in proximity\n        if (proximityRelationshipKinds.length > 0 &&\n            areInProximity(graphView, rel.src, rel.dst, proximityRelationshipKinds)) {\n          strength = Math.min(maxStrength, strength + reinforcementBonus * modifier);\n          reinforced++;\n        }\n\n        // === CULLING (now archives instead of deleting) ===\n        // Archive weak relationships that are cullable and past grace period\n        if (!isYoung && cullable && strength < cullThreshold) {\n          archived++;\n\n          // Mark as historical instead of removing\n          rel.status = 'historical';\n          rel.archivedAt = graphView.tick;\n\n          if (srcEntity) {\n            srcEntity.updatedAt = graphView.tick;\n            modifiedEntityIds.add(srcEntity.id);\n          }\n          if (dstEntity) {\n            dstEntity.updatedAt = graphView.tick;\n            modifiedEntityIds.add(dstEntity.id);\n          }\n\n          maintainedRelationships.push(rel);\n          continue;\n        }\n\n        // Update strength if changed\n        if (rel.strength !== strength) {\n          rel.strength = strength;\n        }\n\n        maintainedRelationships.push(rel);\n      }\n\n      // Update graph with all maintained relationships\n      graphView.setRelationships(maintainedRelationships);\n\n      // Build description\n      const parts: string[] = [];\n      if (decayed > 0) parts.push(`${decayed} decayed`);\n      if (reinforced > 0) parts.push(`${reinforced} reinforced`);\n      if (archived > 0) parts.push(`${archived} archived`);\n      if (removed > 0) parts.push(`${removed} removed (orphaned)`);\n\n      const description = parts.length > 0\n        ? `Relationship maintenance: ${parts.join(', ')} (${originalCount} total)`\n        : `Relationship maintenance: all ${originalCount} relationships stable`;\n\n      return {\n        relationshipsAdded: [],\n        entitiesModified: Array.from(modifiedEntityIds).map(id => ({\n          id,\n          changes: { updatedAt: graphView.tick }\n        })),\n        pressureChanges: {},\n        description\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "RelationshipMaintenanceConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/tagDiffusion.ts::createTagDiffusionSystem", "name": "createTagDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/tagDiffusion.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a TagDiffusionConfig\r\n */\r\nexport function createTagDiffusionSystem(\r\n  config: TagDiffusionConfig\r\n): SimulationSystem {\r\n  const direction = config.connectionDirection ?? 'both';\r\n  const maxTags = config.maxTags ?? 10;\r\n\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const modifiedTags = new Map<string, Record<string, boolean | string>>();\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const entityNarrations = new Map<string, { tag: string; type: 'convergence' | 'divergence' }>();\r\n\r\n      // Find entities to evaluate\r\n      const selectionCtx = createSystemContext(graphView);\r\n      const entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      if (entities.length < 2) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: not enough entities`\r\n        };\r\n      }\r\n\r\n      // Track divergent entities for pressure calculation\r\n      let divergentCount = 0;\r\n\r\n      // === CONVERGENCE: Connected entities gain shared tags ===\r\n      if (config.convergence) {\r\n        const conv = config.convergence;\r\n        const maxShared = conv.maxSharedTags ?? 2;\r\n\r\n        // Compare pairs of entities\r\n        for (let i = 0; i < entities.length; i++) {\r\n          const entity = entities[i];\r\n          const connected = getConnectedEntities(entity, config.connectionKind, direction, graphView);\r\n\r\n          // Filter to only entities in our evaluation set\r\n          const connectedInSet = connected.filter(c =>\r\n            entities.some(e => e.id === c.id)\r\n          );\r\n\r\n          if (connectedInSet.length >= conv.minConnections) {\r\n            // Check shared tags with connected entities\r\n            for (const other of connectedInSet) {\r\n              const sharedCount = countSharedTags(entity, other, conv.tags);\r\n\r\n              if (sharedCount < maxShared) {\r\n                // Roll for convergence\r\n                if (rollProbability(conv.probability, modifier)) {\r\n                  // Pick a tag that neither has\r\n                  const candidateTags = conv.tags.filter(t =>\r\n                    !hasTag(entity.tags, t) && !hasTag(other.tags, t)\r\n                  );\r\n\r\n                  if (candidateTags.length > 0) {\r\n                    const newTag = pickRandom(candidateTags);\r\n                    const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                    if (Object.keys(currentTags).length < maxTags) {\r\n                      currentTags[newTag] = true;\r\n                      modifiedTags.set(entity.id, currentTags);\r\n                      // Track for narration\r\n                      if (!entityNarrations.has(entity.id)) {\r\n                        entityNarrations.set(entity.id, { tag: newTag, type: 'convergence' });\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // === DIVERGENCE: Isolated entities gain unique tags ===\r\n      if (config.divergence) {\r\n        const div = config.divergence;\r\n\r\n        for (const entity of entities) {\r\n          const connectionCount = countConnections(entity, config.connectionKind, direction, graphView);\r\n\r\n          if (connectionCount <= div.maxConnections) {\r\n            // This entity is isolated\r\n            if (rollProbability(div.probability, modifier)) {\r\n              // Pick a divergence tag the entity doesn't have\r\n              const candidateTags = div.tags.filter(t => !hasTag(entity.tags, t));\r\n\r\n              if (candidateTags.length > 0) {\r\n                const newTag = pickRandom(candidateTags);\r\n                const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                if (Object.keys(currentTags).length < maxTags) {\r\n                  currentTags[newTag] = true;\r\n                  modifiedTags.set(entity.id, currentTags);\r\n                  // Track for narration\r\n                  if (!entityNarrations.has(entity.id)) {\r\n                    entityNarrations.set(entity.id, { tag: newTag, type: 'divergence' });\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // Track for pressure calculation\r\n            if (div.tags.some(t => hasTag(entity.tags, t))) {\r\n              divergentCount++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert tag modifications to entity modifications and generate narrations\r\n      for (const [entityId, tags] of modifiedTags) {\r\n        const entity = graphView.getEntity(entityId);\r\n        const narrationInfo = entityNarrations.get(entityId);\r\n\r\n        // Generate narration if template is available\r\n        if (entity && narrationInfo) {\r\n          const template = narrationInfo.type === 'convergence'\r\n            ? config.convergence?.narrationTemplate\r\n            : config.divergence?.narrationTemplate;\r\n\r\n          if (template) {\r\n            const narrationCtx = createSystemRuleContext({ self: entity });\r\n            const narrationResult = interpolate(template, narrationCtx);\r\n            if (narrationResult.complete) {\r\n              narrationsByGroup[entityId] = narrationResult.text;\r\n            }\r\n          }\r\n        }\r\n\r\n        modifications.push({\r\n          id: entityId,\r\n          changes: { tags: tags as Record<string, boolean> },\r\n          narrativeGroupId: narrationInfo ? entityId : undefined\r\n        });\r\n      }\r\n\r\n      // Calculate pressure changes\r\n      let pressureChanges: Record<string, number> = {};\r\n\r\n      if (modifications.length > 0 && config.pressureChanges) {\r\n        pressureChanges = { ...config.pressureChanges };\r\n      }\r\n\r\n      // Apply divergence-specific pressure\r\n      if (config.divergencePressure && divergentCount >= config.divergencePressure.minDivergent) {\r\n        pressureChanges[config.divergencePressure.pressureName] =\r\n          (pressureChanges[config.divergencePressure.pressureName] ?? 0) +\r\n          config.divergencePressure.delta * modifier;\r\n      }\r\n\r\n      return {\r\n        relationshipsAdded: [],\r\n        entitiesModified: modifications,\r\n        pressureChanges,\r\n        description: `${config.name}: ${modifications.length} entities affected`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "TagDiffusionConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/thresholdTrigger.ts::createThresholdTriggerSystem", "name": "createThresholdTriggerSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/thresholdTrigger.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ThresholdTriggerConfig\r\n */\r\nexport function createThresholdTriggerSystem(\r\n  config: ThresholdTriggerConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Find entities matching selection\r\n      const selectionCtx = createSystemContext(graphView);\r\n      let entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      // Apply cooldown filter\r\n      if (config.cooldownTag) {\r\n        entities = entities.filter(e => !hasTag(e.tags, config.cooldownTag!));\r\n      }\r\n\r\n      // Evaluate conditions on each entity\r\n      const matchingEntities = entities.filter(entity =>\r\n        evaluateAllConditions(entity, config.conditions, graphView)\r\n      );\r\n\r\n      if (matchingEntities.length === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: no matches`\r\n        };\r\n      }\r\n\r\n      // Cluster matching entities\r\n      const clusters = clusterEntities(matchingEntities, config, graphView);\r\n\r\n      if (clusters.size === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: clusters too small`\r\n        };\r\n      }\r\n\r\n      // Apply actions\r\n      const { modifications, relationships, relationshipsAdjusted, relationshipsToArchive, pressureChanges, skippedMembers, narrationsByGroup } =\r\n        applyActions(clusters, config, graphView);\r\n\r\n      const skippedInfo = skippedMembers > 0 ? `, ${skippedMembers} skipped (missing vars)` : '';\r\n      return {\r\n        relationshipsAdded: relationships,\r\n        relationshipsAdjusted,\r\n        relationshipsToArchive,\r\n        entitiesModified: modifications as SystemResult['entitiesModified'],\r\n        pressureChanges,\r\n        description: `${config.name}: ${clusters.size} trigger(s), ${modifications.length} entities tagged${skippedInfo}`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined,\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ThresholdTriggerConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/systems/universalCatalyst.ts::createUniversalCatalystSystem", "name": "createUniversalCatalystSystem", "kind": "function", "filePath": "apps/lore-weave/lib/systems/universalCatalyst.ts", "sourceCode": "/**\n * Universal Catalyst System\n *\n * Framework-level system that enables agents to perform actions.\n * This is domain-agnostic - all domain-specific logic lives in action handlers.\n *\n * Flow:\n * 1. Find all entities that can act (catalyst.canAct = true)\n * 2. For each agent, roll for action attempt based on prominence\n * 3. Select action from available actions, weighted by pressures\n * 4. Execute action via declarative handler (success chance based on prominence)\n * 5. Record catalyzedBy attribution\n */\n\n/**\n * Create a Universal Catalyst system with the given configuration.\n */\nexport function createUniversalCatalystSystem(config: UniversalCatalystConfig): SimulationSystem {\n  // Extract config with defaults\n  const actionAttemptRate = config.actionAttemptRate ?? 0.3;\n  const pressureMultiplier = config.pressureMultiplier ?? 1.5;\n  const prominenceUpChance = config.prominenceUpChanceOnSuccess ?? 0.1;\n  const prominenceDownChance = config.prominenceDownChanceOnFailure ?? 0.05;\n\n  return {\n    id: config.id || 'universal_catalyst',\n    name: config.name || 'Agent Actions',\n\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\n      // Get executable actions from declarative config\n      const actions: ExecutableAction[] = graphView.config.executableActions || [];\n\n      if (actions.length === 0) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: 'Catalyst system dormant (no actions configured in actions.json)'\n        };\n      }\n\n      // Find all agents (entities that can act)\n      const allAgents = graphView.getEntities().filter(e => e.catalyst?.canAct === true);\n\n      const relationshipsAdded: Array<Relationship & { actionContext?: { source: 'action'; sourceId: string; success?: boolean } }> = [];\n      const relationshipsAdjusted: Array<{ kind: string; src: string; dst: string; delta: number; actionContext?: { source: 'action'; sourceId: string; success?: boolean } }> = [];\n      const relationshipsToArchive: Array<{ kind: string; src: string; dst: string; actionContext?: { source: 'action'; sourceId: string; success?: boolean } }> = [];\n      const entitiesModified: Array<{ id: string; changes: Partial<HardState>; actionContext?: { source: 'action'; sourceId: string; success?: boolean } }> = [];\n      const pressureChanges: Record<string, number> = {};\n      // Collect narrations per action for narrative event generation\n      const actionNarrations: Map<string, string> = new Map();\n      let actionsAttempted = 0;\n      let actionsSucceeded = 0;\n\n      // Get emitter from graphView config if available\n      const emitter = graphView.config.emitter;\n\n      allAgents.forEach(agent => {\n        if (!agent.catalyst?.canAct) return;\n\n        // Calculate action attempt chance\n        const baseAttemptChance = calculateAttemptChance(agent, actionAttemptRate);\n\n        // Apply pressure multiplier based on available actions for this agent\n        const availableActions = getAvailableActions(agent, actions, graphView);\n        const relevantPressures = getRelevantPressuresFromActions(graphView, availableActions);\n        const prominenceBonus = relevantPressures * (pressureMultiplier - 1.0);\n        const finalAttemptChance = Math.min(1.0, (baseAttemptChance + prominenceBonus) * modifier);\n\n        if (Math.random() > finalAttemptChance) return;\n\n        actionsAttempted++;\n\n        // Select action from available actions with context\n        const { action: selectedAction, context: selectionContext } = selectActionWithContext(\n          agent,\n          availableActions,\n          graphView,\n          finalAttemptChance,\n          prominenceBonus\n        );\n        if (!selectedAction) return;\n\n        // Attempt to execute action with extended outcome\n        const outcome = executeActionWithContext(agent, selectedAction, graphView);\n\n        // Store action context for narrative attribution\n        // WorldEngine will use this to enter/exit contexts when applying modifications\n        // Include agent.id to make each action invocation a separate narrative event\n        // Include success flag so failed actions can be filtered in narrative views\n        const actionContext = {\n          source: 'action' as const,\n          sourceId: `${selectedAction.type}:${agent.id}`,\n          success: outcome.success,\n        };\n\n        // Track prominence changes for instrumentation\n        const prominenceChanges: Array<{ entityId: string; entityName: string; direction: 'up' | 'down' }> = [];\n\n        if (outcome.success) {\n          actionsSucceeded++;\n\n          // Collect narration for this action (keyed by action context sourceId)\n          if (outcome.narration) {\n            actionNarrations.set(actionContext.sourceId, outcome.narration);\n          }\n\n          if (outcome.entitiesModified && outcome.entitiesModified.length > 0) {\n            // Add action context to entity modifications for proper narrative attribution\n            for (const mod of outcome.entitiesModified) {\n              entitiesModified.push({ ...mod, actionContext });\n            }\n          }\n\n          if (outcome.relationshipsAdjusted && outcome.relationshipsAdjusted.length > 0) {\n            // Add action context to relationship adjustments\n            for (const adj of outcome.relationshipsAdjusted) {\n              relationshipsAdjusted.push({ ...adj, actionContext });\n            }\n          }\n\n          if (outcome.relationshipsToArchive && outcome.relationshipsToArchive.length > 0) {\n            // Add action context to relationship archivals\n            for (const arch of outcome.relationshipsToArchive) {\n              relationshipsToArchive.push({ ...arch, actionContext });\n            }\n          }\n\n          if (outcome.pressureChanges) {\n            for (const [pressureId, delta] of Object.entries(outcome.pressureChanges)) {\n              pressureChanges[pressureId] = (pressureChanges[pressureId] || 0) + delta;\n            }\n          }\n\n          // Add created relationships with catalyst attribution and action context\n          outcome.relationships.forEach(rel => {\n            rel.catalyzedBy = agent.id;\n            rel.createdAt = graphView.tick;\n            relationshipsAdded.push({ ...rel, actionContext });\n          });\n\n          entitiesModified.push({\n            id: agent.id,\n            changes: {\n              catalyst: agent.catalyst,\n              updatedAt: graphView.tick\n            },\n            actionContext,\n          });\n\n          // Apply prominence increase on success (if action specifies a positive delta)\n          // NOTE: Do NOT modify entity directly - let worldEngine apply changes\n          // to ensure proper state tracking and persistence\n          const successDelta = selectedAction.actorProminenceDelta.onSuccess;\n          if (\n            successDelta > 0 &&\n            Math.random() < prominenceUpChance &&\n            !hasTag(agent.tags, FRAMEWORK_TAGS.PROMINENCE_LOCKED)\n          ) {\n            const newProminence = clampProminence(agent.prominence + successDelta);\n            entitiesModified.push({\n              id: agent.id,\n              changes: { prominence: newProminence },\n              actionContext,\n            });\n            prominenceChanges.push({ entityId: agent.id, entityName: agent.name, direction: 'up' });\n          }\n\n          // Apply target prominence change on success (if action specifies a delta)\n          const targetSuccessDelta = selectedAction.targetProminenceDelta.onSuccess;\n          if (targetSuccessDelta !== 0 && outcome.targetId) {\n            const target = graphView.getEntity(outcome.targetId);\n            if (target && !hasTag(target.tags, FRAMEWORK_TAGS.PROMINENCE_LOCKED)) {\n              const newProminence = clampProminence(target.prominence + targetSuccessDelta);\n              entitiesModified.push({\n                id: target.id,\n                changes: { prominence: newProminence },\n                actionContext,\n              });\n              prominenceChanges.push({\n                entityId: target.id,\n                entityName: target.name,\n                direction: targetSuccessDelta > 0 ? 'up' : 'down'\n              });\n            }\n          }\n        } else {\n          // Apply prominence decrease on failure (if action specifies a negative delta)\n          // NOTE: Do NOT modify entity directly - let worldEngine apply changes\n          const failureDelta = selectedAction.actorProminenceDelta.onFailure;\n          if (\n            failureDelta !== 0 &&\n            Math.random() < prominenceDownChance &&\n            !hasTag(agent.tags, FRAMEWORK_TAGS.PROMINENCE_LOCKED)\n          ) {\n            const newProminence = clampProminence(agent.prominence + failureDelta);\n            entitiesModified.push({\n              id: agent.id,\n              changes: { prominence: newProminence },\n              actionContext,\n            });\n            prominenceChanges.push({ entityId: agent.id, entityName: agent.name, direction: failureDelta < 0 ? 'down' : 'up' });\n          }\n\n          // Apply target prominence change on failure (if action specifies a delta)\n          const targetFailureDelta = selectedAction.targetProminenceDelta.onFailure;\n          if (targetFailureDelta !== 0 && outcome.targetId) {\n            const target = graphView.getEntity(outcome.targetId);\n            if (target && !hasTag(target.tags, FRAMEWORK_TAGS.PROMINENCE_LOCKED)) {\n              const newProminence = clampProminence(target.prominence + targetFailureDelta);\n              entitiesModified.push({\n                id: target.id,\n                changes: { prominence: newProminence },\n                actionContext,\n              });\n              prominenceChanges.push({\n                entityId: target.id,\n                entityName: target.name,\n                direction: targetFailureDelta > 0 ? 'up' : 'down'\n              });\n            }\n          }\n        }\n\n        // NOTE: Action context is now embedded in modifications instead of using enter/exit\n        // This ensures WorldEngine can apply the correct context when recording mutations\n\n        if (outcome.success) {\n          // Calculate epoch from tick (approximate)\n          const ticksPerEpoch = graphView.config.ticksPerEpoch || 20;\n          const epoch = Math.floor(graphView.tick / ticksPerEpoch);\n\n          const payload: ActionApplicationPayload = {\n            tick: graphView.tick,\n            epoch,\n            actionId: selectedAction.type,\n            actionName: selectedAction.name,\n            actorId: agent.id,\n            actorName: agent.name,\n            actorKind: agent.kind,\n            actorProminence: prominenceLabel(agent.prominence),\n            instigatorId: outcome.instigatorId,\n            instigatorName: outcome.instigatorName,\n            targetId: outcome.targetId,\n            targetName: outcome.targetName,\n            targetKind: outcome.targetKind,\n            target2Id: outcome.target2Id,\n            target2Name: outcome.target2Name,\n            selectionContext: {\n              availableActionCount: selectionContext.availableActionCount,\n              selectedWeight: selectionContext.selectedWeight,\n              totalWeight: selectionContext.totalWeight,\n              pressureInfluences: selectionContext.pressureInfluences,\n              attemptChance: selectionContext.attemptChance,\n              prominenceBonus: selectionContext.prominenceBonus\n            },\n            outcome: {\n              status: outcome.status,\n              successChance: outcome.successChance,\n              prominenceMultiplier: outcome.prominenceMultiplier,\n              description: outcome.description,\n              narration: outcome.narration,\n              relationshipsCreated: outcome.relationships.map(rel => ({\n                kind: rel.kind,\n                srcId: rel.src,\n                dstId: rel.dst,\n                srcName: graphView.getEntity(rel.src)?.name || rel.src,\n                dstName: graphView.getEntity(rel.dst)?.name || rel.dst,\n                strength: rel.strength\n              })),\n              relationshipsStrengthened: (outcome.relationshipsAdjusted || []).map(rel => ({\n                kind: rel.kind,\n                srcId: rel.src,\n                dstId: rel.dst,\n                srcName: graphView.getEntity(rel.src)?.name || rel.src,\n                dstName: graphView.getEntity(rel.dst)?.name || rel.dst,\n                delta: rel.delta\n              })),\n              prominenceChanges\n            }\n          };\n\n          if (emitter) {\n            emitter.actionApplication(payload);\n          }\n\n          const tracker = graphView.config.actionUsageTracker;\n          if (tracker) {\n            tracker.applications.push(payload);\n            tracker.countsByActionId.set(\n              payload.actionId,\n              (tracker.countsByActionId.get(payload.actionId) || 0) + 1\n            );\n            const currentActor = tracker.countsByActorId.get(payload.actorId);\n            if (currentActor) {\n              tracker.countsByActorId.set(payload.actorId, {\n                name: payload.actorName,\n                kind: payload.actorKind,\n                count: currentActor.count + 1\n              });\n// ... (truncated)", "parameters": [{"name": "config", "type": "UniversalCatalystConfig", "optional": false}], "returnType": "SimulationSystem"}, {"id": "apps/lore-weave/lib/utils/arrayUtils.ts::parseJsonSafe", "name": "parseJsonSafe", "kind": "function", "filePath": "apps/lore-weave/lib/utils/arrayUtils.ts", "sourceCode": "/**\r\n * Array and JSON Utilities\r\n *\r\n * Generic utility functions for arrays and JSON parsing.\r\n */\r\n\r\n/**\r\n * Safely parse JSON with automatic cleanup of markdown code blocks.\r\n * Returns null if parsing fails.\r\n */\r\nexport function parseJsonSafe<T = unknown>(raw: string): T | null {\r\n  if (!raw) return null;\r\n  let cleaned = raw.trim();\r\n  cleaned = cleaned.replace(/^```(?:json)?/i, '').replace(/```$/, '').trim();\r\n  try {\r\n    return JSON.parse(cleaned) as T;\r\n  } catch {\r\n    return null;\r\n  }\r\n}", "parameters": [{"name": "raw", "type": "string", "optional": false}], "returnType": "T | null"}, {"id": "apps/lore-weave/lib/utils/arrayUtils.ts::chunk", "name": "chunk", "kind": "function", "filePath": "apps/lore-weave/lib/utils/arrayUtils.ts", "sourceCode": "/**\r\n * Split an array into chunks of a specified size.\r\n */\r\nexport function chunk<T>(items: T[], size: number): T[][] {\r\n  const result: T[][] = [];\r\n  for (let i = 0; i < items.length; i += size) {\r\n    result.push(items.slice(i, i + size));\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "size", "type": "number", "optional": false}], "returnType": "T[][]"}, {"id": "apps/lore-weave/lib/utils/index.ts::mergeTags", "name": "mergeTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Merge multiple tag objects. Later tags override earlier ones.\r\n */\r\nexport function mergeTags(...tagSets: (EntityTags | undefined)[]): EntityTags {\r\n  const result: EntityTags = {};\r\n  for (const tags of tagSets) {\r\n    if (tags) {\r\n      Object.assign(result, tags);\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "tagSets", "type": "(EntityTags | undefined)[]", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/utils/index.ts::hasTag", "name": "hasTag", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Check if an entity has a specific tag.\r\n * @param tags - The entity's tags\r\n * @param key - The tag key to check\r\n * @param value - Optional: specific value to match (if not provided, checks key existence)\r\n */\r\nexport function hasTag(tags: EntityTags | undefined, key: string, value?: string | boolean): boolean {\r\n  if (!tags) return false;\r\n  if (!(key in tags)) return false;\r\n  if (value === undefined) return true;\r\n  return tags[key] === value;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "value", "type": "string | boolean", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/index.ts::getTagValue", "name": "getTagValue", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Get a tag's value, with optional default.\r\n */\r\nexport function getTagValue<T extends string | boolean>(\r\n  tags: EntityTags | undefined,\r\n  key: string,\r\n  defaultValue?: T\r\n): T | undefined {\r\n  if (!tags || !(key in tags)) return defaultValue;\r\n  return tags[key] as T;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "defaultValue", "type": "T", "optional": true}], "returnType": "T | undefined"}, {"id": "apps/lore-weave/lib/utils/index.ts::getTrueTagKeys", "name": "getTrueTagKeys", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Get all tag keys that have truthy values.\r\n */\r\nexport function getTrueTagKeys(tags: EntityTags | undefined): string[] {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => value === true)\r\n    .map(([key]) => key);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "string[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::getStringTags", "name": "getStringTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Get all string-valued tags as key-value entries.\r\n */\r\nexport function getStringTags(tags: EntityTags | undefined): Array<[string, string]> {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => typeof value === 'string')\r\n    .map(([key, value]) => [key, value as string]);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "Array<[string, string]>"}, {"id": "apps/lore-weave/lib/utils/index.ts::arrayToTags", "name": "arrayToTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Convert array tags to EntityTags (KVP) format.\r\n * Plain strings become boolean true, \"key:value\" becomes string value.\r\n */\r\nexport function arrayToTags(arr: string[] | undefined): EntityTags {\r\n  if (!arr) return {};\r\n  const result: EntityTags = {};\r\n  for (const tag of arr) {\r\n    if (tag.startsWith('!')) {\r\n      result[tag.slice(1)] = false;\r\n    } else if (tag.includes(':')) {\r\n      const [key, ...valueParts] = tag.split(':');\r\n      result[key] = valueParts.join(':');\r\n    } else {\r\n      result[tag] = true;\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "arr", "type": "string[] | undefined", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/utils/index.ts::shuffle", "name": "shuffle", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Fisher-Yates shuffle - produces unbiased random permutation.\r\n */\r\nexport function shuffle<T>(array: T[]): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(secureRandom() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export function pickRandom<T>(array: T[]): T {\r\n  return array[Math.floor(secureRandom() * array.length)];\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/lore-weave/lib/utils/index.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export function pickMultiple<T>(array: T[], count: number): T[] {\r\n  const shuffled = shuffle(array);\r\n  return shuffled.slice(0, Math.min(count, array.length));\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::weightedRandom", "name": "weightedRandom", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Weighted random selection\r\n */\r\nexport function weightedRandom<T>(\r\n  items: T[],\r\n  weights: number[]\r\n): T | undefined {\r\n  if (items.length === 0 || items.length !== weights.length) return undefined;\r\n\r\n  const totalWeight = weights.reduce((sum, w) => sum + w, 0);\r\n  let random = secureRandom() * totalWeight;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    random -= weights[i];\r\n    if (random <= 0) {\r\n      return items[i];\r\n    }\r\n  }\r\n\r\n  return items[items.length - 1];\r\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": false}], "returnType": "T | undefined"}, {"id": "apps/lore-weave/lib/utils/index.ts::rollProbability", "name": "rollProbability", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Check if a probabilistic event should occur, scaled by an era modifier.\r\n *\r\n * @param baseProbability - Base chance of the event occurring (0.0 to 1.0)\r\n *                         e.g., 0.3 = 30% chance\r\n * @param eraModifier - Era-based multiplier for the probability\r\n *                      > 1 increases likelihood, < 1 decreases it\r\n * @returns true if the event should occur\r\n *\r\n * @example\r\n * // 30% base chance, doubled in conflict era (modifier = 2)\r\n * if (rollProbability(0.3, eraModifier)) {\r\n *   createConflict();\r\n * }\r\n */\r\nexport function rollProbability(baseProbability: number, eraModifier: number = 1.0): boolean {\r\n  const p = baseProbability;\r\n\r\n  // Edge cases: probability of 0 or 1 should be deterministic\r\n  if (p <= 0) return false;\r\n  if (p >= 1) return true;\r\n\r\n  // odds scaling\r\n  const odds = p / (1 - p);\r\n  const scaledOdds = Math.pow(odds, eraModifier);\r\n  const scaledP = scaledOdds / (1 + scaledOdds);\r\n\r\n  return secureRandom() < scaledP;\r\n}", "parameters": [{"name": "baseProbability", "type": "number", "optional": false}, {"name": "eraModifier", "type": "number", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/index.ts::generateId", "name": "generateId", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export function generateId(prefix: string): string {\n  return `${prefix}_${idCounter++}`;\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/utils/index.ts::generateLoreId", "name": "generateLoreId", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Generate unique ID for lore records with timestamp and counter\r\n */\r\nexport function generateLoreId(prefix: string): string {\r\n  return `${prefix}_${Date.now()}_${loreRecordCounter++}`;\r\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/utils/index.ts::findEntities", "name": "findEntities", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Find entities matching criteria\r\n */\r\nexport function findEntities(\r\n  graph: Graph,\r\n  criteria: Partial<HardState>\r\n): HardState[] {\r\n  const results: HardState[] = [];\r\n\r\n  graph.forEachEntity(entity => {\r\n    let matches = true;\r\n\r\n    for (const [key, value] of Object.entries(criteria)) {\r\n      if (entity[key as keyof HardState] !== value) {\r\n        matches = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches) {\r\n      results.push(entity);\r\n    }\r\n  });\r\n\r\n  return results;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "criteria", "type": "Partial<HardState>", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::getRelated", "name": "getRelated", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Get related entities via relationships\r\n */\r\nexport function getRelated(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipKind?: string,\r\n  direction: 'src' | 'dst' | 'both' = 'both',\r\n  options?: RelationshipQueryOptions\r\n): HardState[] {\r\n  const related: Array<{ entity: HardState; strength: number }> = [];\r\n  const opts = options || {};\r\n\r\n  graph.getRelationships().forEach(rel => {\r\n    if (relationshipKind && rel.kind !== relationshipKind) return;\r\n\r\n    // Strength filtering\r\n    const strength = rel.strength ?? 0.5;\r\n    if (opts.minStrength !== undefined && strength < opts.minStrength) return;\r\n    if (opts.maxStrength !== undefined && strength > opts.maxStrength) return;\r\n\r\n    if ((direction === 'src' || direction === 'both') && rel.src === entityId) {\r\n      const entity = graph.getEntity(rel.dst);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n\r\n    if ((direction === 'dst' || direction === 'both') && rel.dst === entityId) {\r\n      const entity = graph.getEntity(rel.src);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n  });\r\n\r\n  // Sort by strength if requested\r\n  if (opts.sortByStrength) {\r\n    related.sort((a, b) => b.strength - a.strength);\r\n  }\r\n\r\n  return related.map(r => r.entity);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": true}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}, {"name": "options", "type": "RelationshipQueryOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export function hasRelationship(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind?: string\r\n): boolean {\r\n  return graph.getRelationships().some(rel =>\r\n    rel.src === srcId &&\r\n    rel.dst === dstId &&\r\n    (!kind || rel.kind === kind)\r\n  );\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/index.ts::getConnectionWeight", "name": "getConnectionWeight", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Calculate relationship formation weight based on existing connection count.\r\n * Favors underconnected entities to balance network density and prevent hubs.\r\n */\r\nexport function getConnectionWeight(graph: Graph, entity: HardState): number {\r\n  const connectionCount = graph.getEntityRelationships(entity.id, 'both').length;\r\n\r\n  // Boost isolated/underconnected entities\r\n  if (connectionCount === 0) return 3.0;    // Strongly boost isolated\r\n  if (connectionCount <= 2) return 2.0;     // Boost underconnected (below median)\r\n  if (connectionCount <= 5) return 1.0;     // Normal\r\n  if (connectionCount <= 10) return 0.5;    // Reduce well-connected\r\n  return 0.2;                               // Heavily reduce hubs (15+)\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/utils/index.ts::slugifyName", "name": "slugifyName", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\n * Slugify a name for use in IDs or other contexts\n */\nexport function slugifyName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '') || 'unknown'; // eslint-disable-line sonarjs/slow-regex -- short slug string, no ReDoS risk\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/utils/index.ts::generateEntityIdFromName", "name": "generateEntityIdFromName", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\n * Generate a stable entity ID from a name, with optional collision handling.\n */\nexport function generateEntityIdFromName(\n  name: string,\n  hasEntity?: (id: string) => boolean,\n  log?: (message: string, context?: Record<string, unknown>) => void\n): string {\n  const baseId = slugifyName(name);\n  if (!hasEntity) return baseId;\n  if (!hasEntity(baseId)) return baseId;\n\n  let suffix = 2;\n  let candidate = `${baseId}-${suffix}`;\n  while (hasEntity(candidate)) {\n    suffix += 1;\n    candidate = `${baseId}-${suffix}`;\n  }\n\n  log?.(`Entity id collision for \"${name}\". Using \"${candidate}\".`, {\n    name,\n    baseId,\n    resolvedId: candidate\n  });\n\n  return candidate;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "hasEntity", "type": "(id: string) => boolean", "optional": true}, {"name": "log", "type": "(message: string, context?: Record<string, unknown>) => void", "optional": true}], "returnType": "string"}, {"id": "apps/lore-weave/lib/utils/index.ts::normalizeInitialState", "name": "normalizeInitialState", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export function normalizeInitialState(entities: RawEntityInput[]): HardState[] {\n  return entities.map((entity, index) => {\n    if (!entity.id) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no id. ` +\n        `Seed entities must include a stable id used by relationships.`\n      );\n    }\n    if (!entity.name) {\n      throw new Error(\n        `normalizeInitialState: entity at index ${index} has no name. ` +\n        `Initial state entities must have names defined in JSON.`\n      );\n    }\n    if (!entity.coordinates) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no coordinates. ` +\n        `Initial state entities must have coordinates defined in JSON.`\n      );\n    }\n    if (!entity.kind) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no kind.`\n      );\n    }\n    if (!entity.subtype) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no subtype.`\n      );\n    }\n    if (!entity.status) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no status.`\n      );\n    }\n    if (!entity.prominence) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no prominence.`\n      );\n    }\n    if (!entity.culture) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no culture.`\n      );\n    }\n\n    // Handle both old array format and new KVP format for tags\n    let tags: EntityTags;\n    if (Array.isArray(entity.tags)) {\n      tags = arrayToTags(entity.tags);\n    } else {\n      tags = entity.tags || {};\n    }\n\n    const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n    return {\n      id: entity.id,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      name: entity.name,\n      summary: entity.summary,\n      narrativeHint,\n      description: entity.description || '',\n      status: entity.status,\n      prominence: entity.prominence,\n      culture: entity.culture,\n      tags,\n      createdAt: 0,\n      updatedAt: 0,\n      coordinates: entity.coordinates\n    };\n  });\n}", "parameters": [{"name": "entities", "type": "RawEntityInput[]", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/utils/index.ts::addEntity", "name": "addEntity", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "export async function addEntity(graph: Graph, entity: Partial<HardState>, source?: string, placementStrategy?: string): Promise<string> {\n  validateEntityForAdd(entity);\n\n  const coords = entity.coordinates!;\n  const tags: EntityTags = Array.isArray(entity.tags) ? arrayToTags(entity.tags) : { ...(entity.tags || {}) };\n\n  const entityId = generateEntityIdFromName(entity.name!, id => graph.hasEntity(id));\n\n  // Delegate to Graph.createEntity()\n  // Use validated coords to satisfy TypeScript (already validated above)\n  if (typeof coords.z !== 'number') {\n    throw new Error(\n      `addEntity: coordinates must include numeric z. ` +\n      `Entity kind: ${entity.kind}, name: ${entity.name || 'unnamed'}. ` +\n      `Received: ${JSON.stringify(coords)}.`\n    );\n  }\n  const validCoords = { x: coords.x, y: coords.y, z: coords.z };\n\n  const currentEraEntity = entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA\n    ? graph.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0]\n    : undefined;\n  const explicitEraId = entity.eraId;\n  let resolvedEraId: string | undefined;\n  if (typeof explicitEraId === 'string' && explicitEraId) {\n    resolvedEraId = explicitEraId;\n  } else if (entity.kind === FRAMEWORK_ENTITY_KINDS.ERA) {\n    resolvedEraId = entity.subtype;\n  } else {\n    resolvedEraId = currentEraEntity?.id;\n  }\n\n  const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n  const createdId = await graph.createEntity({\n    id: entityId,\n    kind: entity.kind!,\n    subtype: entity.subtype!,\n    coordinates: validCoords,\n    tags,\n    eraId: resolvedEraId,\n    name: entity.name,\n    description: entity.description,\n    narrativeHint,\n    status: entity.status!,\n    prominence: entity.prominence!,\n    culture: entity.culture!,\n    temporal: entity.temporal,\n    source,\n    placementStrategy\n  });\n\n  // Create CREATED_DURING relationship to current era (unless entity is an era itself)\n  // This is a framework-level temporal relationship distinct from spatial \"originated_in\"\n  if (entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA && currentEraEntity) {\n    graph.addRelationship(\n      FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING,\n      entityId,\n      currentEraEntity.id,\n      FRAMEWORK_RELATIONSHIP_PROPERTIES[FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING].defaultStrength\n    );\n  }\n\n  return createdId;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "Partial<HardState>", "optional": false}, {"name": "source", "type": "string", "optional": true}, {"name": "placementStrategy", "type": "string", "optional": true}], "returnType": "Promise<string>"}, {"id": "apps/lore-weave/lib/utils/index.ts::updateEntity", "name": "updateEntity", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\n * Update entity in graph\n */\nexport function updateEntity(\n  graph: Graph,\n  entityId: string,\n  changes: Partial<HardState>\n): void {\n  // Use Graph's updateEntity method to modify the actual entity, not a clone\n  graph.updateEntity(entityId, changes);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "changes", "type": "Partial<HardState>", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/utils/index.ts::addRelationship", "name": "addRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP MUTATION\r\n// ===========================\r\n\r\n/**\r\n * Add a relationship between two entities.\r\n * Distance is ALWAYS computed from Euclidean distance between coordinates.\r\n */\r\nexport function addRelationship(\r\n  graph: Graph,\r\n  kind: string,\r\n  srcId: string,\r\n  dstId: string,\r\n  strength: number = 0.5\r\n): void {\r\n  graph.addRelationship(kind, srcId, dstId, strength);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/utils/index.ts::archiveRelationship", "name": "archiveRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Archive a relationship by marking it as historical.\r\n */\r\nexport function archiveRelationship(\r\n  graph: Graph,\r\n  src: string,\r\n  dst: string,\r\n  kind: string,\r\n  reason?: string\r\n): void {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === src &&\r\n    r.dst === dst &&\r\n    r.kind === kind &&\r\n    r.status !== 'historical'\r\n  );\r\n\r\n  if (rel) {\r\n    const age = graph.tick - (rel.createdAt ?? 0);\r\n    rel.status = 'historical';\r\n    rel.archivedAt = graph.tick;\r\n\r\n    // Record archival for context-based event generation\r\n    graph.mutationTracker?.recordRelationshipArchived({\r\n      srcId: src,\r\n      dstId: dst,\r\n      kind,\r\n      age,\r\n      reason,\r\n    });\r\n  }\r\n\r\n  const srcEntity = graph.getEntity(src);\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  const dstEntity = graph.getEntity(dst);\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "reason", "type": "string", "optional": true}], "returnType": "void"}, {"id": "apps/lore-weave/lib/utils/index.ts::modifyRelationshipStrength", "name": "modifyRelationshipStrength", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Modify relationship strength by delta\r\n */\r\nexport function modifyRelationshipStrength(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind: string,\r\n  delta: number\r\n): boolean {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === srcId && r.dst === dstId && r.kind === kind\r\n  );\r\n\r\n  if (!rel) return false;\r\n\r\n  const currentStrength = rel.strength ?? 0.5;\r\n  rel.strength = Math.max(0.0, Math.min(1.0, currentStrength + delta));\r\n\r\n  const srcEntity = graph.getEntity(srcId);\r\n  const dstEntity = graph.getEntity(dstId);\r\n\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  return true;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "delta", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/index.ts::canFormRelationship", "name": "canFormRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP COOLDOWN\r\n// ===========================\r\n\r\n/**\r\n * Check if an entity can form a new relationship based on cooldown.\r\n */\r\nexport function canFormRelationship(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string,\r\n  cooldownTicks: number\r\n): boolean {\r\n  const entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n  if (!entityCooldowns) return true;\r\n\r\n  const lastFormationTick = entityCooldowns.get(relationshipType);\r\n  if (lastFormationTick === undefined) return true;\r\n\r\n  return (graph.tick - lastFormationTick) >= cooldownTicks;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}, {"name": "cooldownTicks", "type": "number", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/index.ts::recordRelationshipFormation", "name": "recordRelationshipFormation", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Record that an entity has formed a relationship.\r\n */\r\nexport function recordRelationshipFormation(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string\r\n): void {\r\n  let entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n\r\n  if (!entityCooldowns) {\r\n    entityCooldowns = new Map();\r\n    graph.relationshipCooldowns.set(entityId, entityCooldowns);\r\n  }\r\n\r\n  entityCooldowns.set(relationshipType, graph.tick);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/utils/index.ts::parseJsonSafe", "name": "parseJsonSafe", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Array and JSON Utilities\r\n *\r\n * Generic utility functions for arrays and JSON parsing.\r\n */\r\n\r\n/**\r\n * Safely parse JSON with automatic cleanup of markdown code blocks.\r\n * Returns null if parsing fails.\r\n */\r\nexport function parseJsonSafe<T = unknown>(raw: string): T | null {\r\n  if (!raw) return null;\r\n  let cleaned = raw.trim();\r\n  cleaned = cleaned.replace(/^```(?:json)?/i, '').replace(/```$/, '').trim();\r\n  try {\r\n    return JSON.parse(cleaned) as T;\r\n  } catch {\r\n    return null;\r\n  }\r\n}", "parameters": [{"name": "raw", "type": "string", "optional": false}], "returnType": "T | null"}, {"id": "apps/lore-weave/lib/utils/index.ts::chunk", "name": "chunk", "kind": "function", "filePath": "apps/lore-weave/lib/utils/index.ts", "sourceCode": "/**\r\n * Split an array into chunks of a specified size.\r\n */\r\nexport function chunk<T>(items: T[], size: number): T[][] {\r\n  const result: T[][] = [];\r\n  for (let i = 0; i < items.length; i += size) {\r\n    result.push(items.slice(i, i + size));\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "size", "type": "number", "optional": false}], "returnType": "T[][]"}, {"id": "apps/lore-weave/lib/utils/randomUtils.ts::shuffle", "name": "shuffle", "kind": "function", "filePath": "apps/lore-weave/lib/utils/randomUtils.ts", "sourceCode": "/**\r\n * Fisher-Yates shuffle - produces unbiased random permutation.\r\n */\r\nexport function shuffle<T>(array: T[]): T[] {\r\n  const result = [...array];\r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(secureRandom() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/lore-weave/lib/utils/randomUtils.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/lore-weave/lib/utils/randomUtils.ts", "sourceCode": "export function pickRandom<T>(array: T[]): T {\r\n  return array[Math.floor(secureRandom() * array.length)];\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T"}, {"id": "apps/lore-weave/lib/utils/randomUtils.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/lore-weave/lib/utils/randomUtils.ts", "sourceCode": "export function pickMultiple<T>(array: T[], count: number): T[] {\r\n  const shuffled = shuffle(array);\r\n  return shuffled.slice(0, Math.min(count, array.length));\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]"}, {"id": "apps/lore-weave/lib/utils/randomUtils.ts::weightedRandom", "name": "weightedRandom", "kind": "function", "filePath": "apps/lore-weave/lib/utils/randomUtils.ts", "sourceCode": "/**\r\n * Weighted random selection\r\n */\r\nexport function weightedRandom<T>(\r\n  items: T[],\r\n  weights: number[]\r\n): T | undefined {\r\n  if (items.length === 0 || items.length !== weights.length) return undefined;\r\n\r\n  const totalWeight = weights.reduce((sum, w) => sum + w, 0);\r\n  let random = secureRandom() * totalWeight;\r\n\r\n  for (let i = 0; i < items.length; i++) {\r\n    random -= weights[i];\r\n    if (random <= 0) {\r\n      return items[i];\r\n    }\r\n  }\r\n\r\n  return items[items.length - 1];\r\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "weights", "type": "number[]", "optional": false}], "returnType": "T | undefined"}, {"id": "apps/lore-weave/lib/utils/randomUtils.ts::rollProbability", "name": "rollProbability", "kind": "function", "filePath": "apps/lore-weave/lib/utils/randomUtils.ts", "sourceCode": "/**\r\n * Check if a probabilistic event should occur, scaled by an era modifier.\r\n *\r\n * @param baseProbability - Base chance of the event occurring (0.0 to 1.0)\r\n *                         e.g., 0.3 = 30% chance\r\n * @param eraModifier - Era-based multiplier for the probability\r\n *                      > 1 increases likelihood, < 1 decreases it\r\n * @returns true if the event should occur\r\n *\r\n * @example\r\n * // 30% base chance, doubled in conflict era (modifier = 2)\r\n * if (rollProbability(0.3, eraModifier)) {\r\n *   createConflict();\r\n * }\r\n */\r\nexport function rollProbability(baseProbability: number, eraModifier: number = 1.0): boolean {\r\n  const p = baseProbability;\r\n\r\n  // Edge cases: probability of 0 or 1 should be deterministic\r\n  if (p <= 0) return false;\r\n  if (p >= 1) return true;\r\n\r\n  // odds scaling\r\n  const odds = p / (1 - p);\r\n  const scaledOdds = Math.pow(odds, eraModifier);\r\n  const scaledP = scaledOdds / (1 + scaledOdds);\r\n\r\n  return secureRandom() < scaledP;\r\n}", "parameters": [{"name": "baseProbability", "type": "number", "optional": false}, {"name": "eraModifier", "type": "number", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::mergeTags", "name": "mergeTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Merge multiple tag objects. Later tags override earlier ones.\r\n */\r\nexport function mergeTags(...tagSets: (EntityTags | undefined)[]): EntityTags {\r\n  const result: EntityTags = {};\r\n  for (const tags of tagSets) {\r\n    if (tags) {\r\n      Object.assign(result, tags);\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "tagSets", "type": "(EntityTags | undefined)[]", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::hasTag", "name": "hasTag", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Check if an entity has a specific tag.\r\n * @param tags - The entity's tags\r\n * @param key - The tag key to check\r\n * @param value - Optional: specific value to match (if not provided, checks key existence)\r\n */\r\nexport function hasTag(tags: EntityTags | undefined, key: string, value?: string | boolean): boolean {\r\n  if (!tags) return false;\r\n  if (!(key in tags)) return false;\r\n  if (value === undefined) return true;\r\n  return tags[key] === value;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "value", "type": "string | boolean", "optional": true}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::getTagValue", "name": "getTagValue", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Get a tag's value, with optional default.\r\n */\r\nexport function getTagValue<T extends string | boolean>(\r\n  tags: EntityTags | undefined,\r\n  key: string,\r\n  defaultValue?: T\r\n): T | undefined {\r\n  if (!tags || !(key in tags)) return defaultValue;\r\n  return tags[key] as T;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "defaultValue", "type": "T", "optional": true}], "returnType": "T | undefined"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::getTrueTagKeys", "name": "getTrueTagKeys", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Get all tag keys that have truthy values.\r\n */\r\nexport function getTrueTagKeys(tags: EntityTags | undefined): string[] {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => value === true)\r\n    .map(([key]) => key);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "string[]"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::getStringTags", "name": "getStringTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Get all string-valued tags as key-value entries.\r\n */\r\nexport function getStringTags(tags: EntityTags | undefined): Array<[string, string]> {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => typeof value === 'string')\r\n    .map(([key, value]) => [key, value as string]);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "Array<[string, string]>"}, {"id": "apps/lore-weave/lib/utils/tagUtils.ts::arrayToTags", "name": "arrayToTags", "kind": "function", "filePath": "apps/lore-weave/lib/utils/tagUtils.ts", "sourceCode": "/**\r\n * Convert array tags to EntityTags (KVP) format.\r\n * Plain strings become boolean true, \"key:value\" becomes string value.\r\n */\r\nexport function arrayToTags(arr: string[] | undefined): EntityTags {\r\n  if (!arr) return {};\r\n  const result: EntityTags = {};\r\n  for (const tag of arr) {\r\n    if (tag.startsWith('!')) {\r\n      result[tag.slice(1)] = false;\r\n    } else if (tag.includes(':')) {\r\n      const [key, ...valueParts] = tag.split(':');\r\n      result[key] = valueParts.join(':');\r\n    } else {\r\n      result[tag] = true;\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "arr", "type": "string[] | undefined", "optional": false}], "returnType": "EntityTags"}, {"id": "apps/lore-weave/lib/rules/conditions/index.ts::evaluateCondition", "name": "evaluateCondition", "kind": "function", "filePath": "apps/lore-weave/lib/rules/conditions/index.ts", "sourceCode": "export function evaluateCondition(\r\n  condition: Condition,\r\n  ctx: RuleContext,\r\n  entity?: HardState\r\n): ConditionResult {\r\n  const self = entity ?? ctx.self;\r\n  const handler = CONDITION_HANDLERS[condition.type];\r\n  if (handler) return handler(condition, ctx, self);\r\n\r\n  return {\r\n    passed: false,\r\n    diagnostic: `unknown condition type: ${condition.type}`,\r\n    details: { condition },\r\n  };\r\n}", "parameters": [{"name": "condition", "type": "Condition", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "entity", "type": "HardState", "optional": true}], "returnType": "ConditionResult"}, {"id": "apps/lore-weave/lib/rules/filters/index.ts::applySelectionFilters", "name": "applySelectionFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/filters/index.ts", "sourceCode": "/**\r\n * Apply a list of selection filters to entities.\r\n * Filters are applied in sequence (AND logic).\r\n */\r\nexport function applySelectionFilters(\r\n  entities: HardState[],\r\n  filters: SelectionFilter[] | undefined,\r\n  resolver: EntityResolver,\r\n  graphPathOptions?: GraphPathOptions\r\n): HardState[] {\r\n  if (!filters || filters.length === 0) return entities;\r\n\r\n  let result = entities;\r\n  const options = resolveGraphPathOptions(graphPathOptions);\r\n\r\n  for (const filter of filters) {\r\n    result = applySelectionFilter(result, filter, resolver, options);\r\n  }\r\n\r\n  return result;\r\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "graphPathOptions", "type": "GraphPathOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/filters/index.ts::applySelectionFilter", "name": "applySelectionFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/filters/index.ts", "sourceCode": "/**\r\n * Apply a single selection filter to a list of entities.\r\n */\r\nexport function applySelectionFilter(\r\n  entities: HardState[],\r\n  filter: SelectionFilter,\r\n  resolver: EntityResolver,\r\n  graphPathOptions?: GraphPathOptions\r\n): HardState[] {\r\n  switch (filter.type) {\r\n    case 'exclude': {\r\n      const excludeIds = new Set(\r\n        filter.entities\r\n          .map(ref => resolver.resolveEntity(ref)?.id)\r\n          .filter((id): id is string => id !== undefined)\r\n      );\r\n      return entities.filter(e => !excludeIds.has(e.id));\r\n    }\r\n\r\n    case 'has_relationship': {\r\n      const graphView = resolver.getGraphView();\r\n      const withEntity = filter.with ? resolver.resolveEntity(filter.with) : undefined;\r\n      return entities.filter(entity => {\r\n        const relationships = graphView.getRelationships(entity.id, filter.kind);\r\n        return relationships.some(link => {\r\n          if (filter.direction === 'src' && link.src !== entity.id) return false;\r\n          if (filter.direction === 'dst' && link.dst !== entity.id) return false;\r\n          if (withEntity) {\r\n            const otherId = link.src === entity.id ? link.dst : link.src;\r\n            return otherId === withEntity.id;\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n    }\r\n\r\n    case 'lacks_relationship': {\r\n      const graphView = resolver.getGraphView();\r\n      const withEntity = filter.with ? resolver.resolveEntity(filter.with) : undefined;\r\n      return entities.filter(entity => {\r\n        const relationships = graphView.getRelationships(entity.id, filter.kind);\r\n        const hasRel = relationships.some(link => {\r\n          if (withEntity) {\r\n            const otherId = link.src === entity.id ? link.dst : link.src;\r\n            return otherId === withEntity.id;\r\n          }\r\n          return true;\r\n        });\r\n        return !hasRel;\r\n      });\r\n    }\r\n\r\n    case 'has_tag': {\r\n      return entities.filter(entity => {\r\n        if (!hasTag(entity.tags, filter.tag)) return false;\r\n        if (filter.value === undefined) return true;\r\n        return getTagValue(entity.tags, filter.tag) === filter.value;\r\n      });\r\n    }\r\n\r\n    case 'has_tags': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => tagList.every(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'has_any_tag': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => tagList.some(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'lacks_tag': {\r\n      return entities.filter(entity => {\r\n        if (!hasTag(entity.tags, filter.tag)) return true; // Doesn't have tag, include\r\n        if (filter.value === undefined) return false; // Has tag, exclude\r\n        // Has tag, only exclude if value matches\r\n        return getTagValue(entity.tags, filter.tag) !== filter.value;\r\n      });\r\n    }\r\n\r\n    case 'lacks_any_tag': {\r\n      const tagList = filter.tags || [];\r\n      if (tagList.length === 0) return entities;\r\n      return entities.filter(entity => !tagList.some(tag => hasTag(entity.tags, tag)));\r\n    }\r\n\r\n    case 'has_culture': {\r\n      return entities.filter(e => e.culture === filter.culture);\r\n    }\r\n\r\n    case 'not_has_culture': {\r\n      return entities.filter(e => e.culture !== filter.culture);\r\n    }\r\n\r\n    case 'matches_culture': {\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n      return entities.filter(e => e.culture === refEntity.culture);\r\n    }\r\n\r\n    case 'not_matches_culture': {\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n      return entities.filter(e => e.culture !== refEntity.culture);\r\n    }\r\n\r\n    case 'has_status': {\r\n      return entities.filter(e => e.status === filter.status);\r\n    }\r\n\r\n    case 'has_prominence': {\r\n      const minValue = prominenceThreshold(filter.minProminence);\r\n      return entities.filter(e => e.prominence >= minValue);\r\n    }\r\n\r\n    case 'shares_related': {\r\n      // Find entities that share a common related entity with the reference\r\n      const graphView = resolver.getGraphView();\r\n      const refEntity = resolver.resolveEntity(filter.with);\r\n      if (!refEntity) return entities;\r\n\r\n      const refRelated = graphView\r\n        .getConnectedEntities(refEntity.id, filter.relationshipKind, 'both')\r\n        .map(entity => entity.id);\r\n\r\n      if (refRelated.length === 0) return [];\r\n\r\n      const refRelatedSet = new Set(refRelated);\r\n\r\n      return entities.filter(entity => {\r\n        const entityRelated = graphView\r\n          .getConnectedEntities(entity.id, filter.relationshipKind, 'both')\r\n          .map(related => related.id);\r\n        return entityRelated.some(id => refRelatedSet.has(id));\r\n      });\r\n    }\r\n\r\n    case 'graph_path': {\r\n      const options = resolveGraphPathOptions(graphPathOptions);\r\n      return entities.filter(entity =>\r\n        evaluateGraphPath(entity, filter.assert, resolver, options)\r\n      );\r\n    }\r\n\r\n    case 'component_size': {\r\n      const graphView = resolver.getGraphView();\r\n      const rels = graphView.getAllRelationships();\r\n      const minStrength = filter.minStrength ?? 0;\r\n\r\n      // Build adjacency index for the specified relationship kinds\r\n      const adjacency = new Map<string, Set<string>>();\r\n      for (const link of rels) {\r\n        if (!filter.relationshipKinds.includes(link.kind)) continue;\r\n        if ((link.strength ?? 0) < minStrength) continue;\r\n\r\n        // Bidirectional edges (undirected graph)\r\n        if (!adjacency.has(link.src)) adjacency.set(link.src, new Set());\r\n        if (!adjacency.has(link.dst)) adjacency.set(link.dst, new Set());\r\n        adjacency.get(link.src)!.add(link.dst);\r\n        adjacency.get(link.dst)!.add(link.src);\r\n      }\r\n\r\n      return entities.filter(entity => {\r\n        // DFS to find component size\r\n        const visited = new Set<string>([entity.id]);\r\n        const stack = [entity.id];\r\n\r\n        while (stack.length > 0) {\r\n          const current = stack.pop()!;\r\n          const neighbors = adjacency.get(current);\r\n          if (neighbors) {\r\n            for (const neighborId of neighbors) {\r\n              if (!visited.has(neighborId)) {\r\n                visited.add(neighborId);\r\n                stack.push(neighborId);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const componentSize = visited.size;\r\n        const minOk = filter.min === undefined || componentSize >= filter.min;\r\n        const maxOk = filter.max === undefined || componentSize <= filter.max;\r\n        return minOk && maxOk;\r\n      });\r\n    }\r\n\r\n    default:\r\n      return entities;\r\n  }\r\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filter", "type": "SelectionFilter", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}, {"name": "graphPathOptions", "type": "GraphPathOptions", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/filters/index.ts::entityPassesFilter", "name": "entityPassesFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/filters/index.ts", "sourceCode": "/**\r\n * Check if an entity passes a single filter.\r\n * Useful for checking individual entities without creating a list.\r\n */\r\nexport function entityPassesFilter(\r\n  entity: HardState,\r\n  filter: SelectionFilter,\r\n  resolver: EntityResolver\r\n): boolean {\r\n  const result = applySelectionFilter([entity], filter, resolver);\r\n  return result.length > 0;\r\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "filter", "type": "SelectionFilter", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/filters/index.ts::entityPassesAllFilters", "name": "entityPassesAllFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/filters/index.ts", "sourceCode": "/**\r\n * Check if an entity passes all filters.\r\n */\r\nexport function entityPassesAllFilters(\r\n  entity: HardState,\r\n  filters: SelectionFilter[] | undefined,\r\n  resolver: EntityResolver\r\n): boolean {\r\n  if (!filters || filters.length === 0) return true;\r\n\r\n  for (const filter of filters) {\r\n    if (!entityPassesFilter(entity, filter, resolver)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "resolver", "type": "EntityResolver", "optional": false}], "returnType": "boolean"}, {"id": "apps/lore-weave/lib/rules/metrics/index.ts::describeMetric", "name": "describeMetric", "kind": "function", "filePath": "apps/lore-weave/lib/rules/metrics/index.ts", "sourceCode": "export function describeMetric(metric: Metric): string {\n  switch (metric.type) {\n    case 'entity_count': {\n      const parts = [metric.kind];\n      if (metric.subtype) parts.push(`:${metric.subtype}`);\n      if (metric.status) parts.push(`(${metric.status})`);\n      return `${parts.join('')} count`;\n    }\n    case 'relationship_count':\n      return `${metric.relationshipKinds?.join('/') ?? 'all'} relationships`;\n    case 'tag_count':\n      return `entities with ${metric.tags.join('/')} tags`;\n    case 'total_entities':\n      return 'total entities';\n    case 'constant':\n      return 'constant';\n    case 'connection_count':\n      return `${metric.relationshipKinds?.join('/') ?? 'all'} connections`;\n    case 'ratio':\n      return `${describeSimpleCount(metric.numerator)}/${describeSimpleCount(metric.denominator)} ratio`;\n    case 'status_ratio':\n      return `${metric.kind} status ratio`;\n    case 'cross_culture_ratio':\n      return `cross-culture ${metric.relationshipKinds.join('/')} ratio`;\n    case 'shared_relationship':\n      return `shared ${Array.isArray(metric.sharedRelationshipKind) ? metric.sharedRelationshipKind.join('/') : metric.sharedRelationshipKind} relationships`;\n    case 'prominence_multiplier':\n      return `prominence multiplier (${metric.mode ?? 'success_chance'})`;\n    case 'neighbor_prominence':\n      return `neighbor prominence (${metric.relationshipKinds?.join('/') ?? 'all'} connections)`;\n    case 'neighbor_kind_count': {\n      const neighborKindSpec = metric.subtype ? `${metric.kind}:${metric.subtype}` : metric.kind;\n      return `neighbor ${neighborKindSpec} count via ${Array.isArray(metric.via) ? metric.via.join('/') : metric.via}`;\n    }\n    case 'component_size':\n      return `component size via ${metric.relationshipKinds.join('/')}`;\n    case 'decay_rate':\n      return `decay rate ${metric.rate}`;\n    case 'falloff':\n      return `${metric.falloffType} falloff`;\n    default:\n      return (metric as { type: string }).type;\n  }\n}", "parameters": [{"name": "metric", "type": "Metric", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/rules/metrics/index.ts::getProminenceMultiplierValue", "name": "getProminenceMultiplierValue", "kind": "function", "filePath": "apps/lore-weave/lib/rules/metrics/index.ts", "sourceCode": "// forgotten->mythic\n\n/**\n * Get prominence multiplier with interpolation for numeric values.\n * Values between levels are linearly interpolated.\n */\nexport function getProminenceMultiplierValue(\n  prominence: number,\n  mode: ProminenceMultiplierMetric['mode'] = 'success_chance'\n): number {\n  const multipliers = mode === 'action_rate' ? ACTION_MULTIPLIERS : SUCCESS_MULTIPLIERS;\n\n  // Clamp to valid range\n  const clamped = Math.max(0, Math.min(5, prominence));\n  const level = Math.min(4, Math.floor(clamped));\n  const fraction = clamped - level;\n\n  const current = multipliers[level];\n  const next = multipliers[Math.min(level + 1, 4)];\n\n  return current + (next - current) * fraction;\n}", "parameters": [{"name": "prominence", "type": "number", "optional": false}, {"name": "mode", "type": "ProminenceMultiplierMetric['mode']", "optional": true}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/metrics/index.ts::evaluateMetric", "name": "evaluateMetric", "kind": "function", "filePath": "apps/lore-weave/lib/rules/metrics/index.ts", "sourceCode": "// =============================================================================\n// MAIN EVALUATOR\n// =============================================================================\n\n/**\n * Evaluate a metric against the current context.\n *\n * @param metric - The metric to evaluate\n * @param ctx - The rule context\n * @param entity - Optional entity for per-entity metrics\n * @returns MetricResult with value and diagnostic info\n */\nexport function evaluateMetric(\n  metric: Metric,\n  ctx: MetricContext,\n  entity?: HardState\n): MetricResult {\n  switch (metric.type) {\n    // =========================================================================\n    // COUNT METRICS\n    // =========================================================================\n\n    case 'entity_count':\n      return evaluateEntityCount(metric, ctx);\n\n    case 'relationship_count':\n      return evaluateRelationshipCount(metric, ctx, entity);\n\n    case 'tag_count':\n      return evaluateTagCount(metric, ctx);\n\n    case 'total_entities':\n      return evaluateTotalEntities(metric, ctx);\n\n    case 'constant':\n      return evaluateConstant(metric);\n\n    case 'connection_count':\n      return evaluateConnectionCount(metric, ctx, entity);\n\n    // =========================================================================\n    // RATIO METRICS\n    // =========================================================================\n\n    case 'ratio':\n      return evaluateRatio(metric, ctx);\n\n    case 'status_ratio':\n      return evaluateStatusRatio(metric, ctx);\n\n    case 'cross_culture_ratio':\n      return evaluateCrossCultureRatio(metric, ctx);\n\n    // =========================================================================\n    // EVOLUTION METRICS\n    // =========================================================================\n\n    case 'shared_relationship':\n      return evaluateSharedRelationship(metric, ctx, entity);\n\n    // =========================================================================\n    // PROMINENCE METRICS\n    // =========================================================================\n\n    case 'prominence_multiplier':\n      return evaluateProminenceMultiplier(metric, entity);\n\n    case 'neighbor_prominence':\n      return evaluateNeighborProminence(metric, ctx, entity);\n\n    // =========================================================================\n    // NEIGHBOR METRICS\n    // =========================================================================\n\n    case 'neighbor_kind_count':\n      return evaluateNeighborKindCount(metric, ctx, entity);\n\n    // =========================================================================\n    // GRAPH TOPOLOGY METRICS\n    // =========================================================================\n\n    case 'component_size':\n      return evaluateComponentSize(metric, ctx, entity);\n\n    // =========================================================================\n    // DECAY/FALLOFF METRICS\n    // =========================================================================\n\n    case 'decay_rate':\n      return evaluateDecayRate(metric);\n\n    case 'falloff':\n      return evaluateFalloff(metric);\n\n    default:\n      return {\n        value: 0,\n        diagnostic: `unknown metric type: ${(metric as Metric).type}`,\n        details: { metric },\n      };\n  }\n}", "parameters": [{"name": "metric", "type": "Metric", "optional": false}, {"name": "ctx", "type": "MetricContext", "optional": false}, {"name": "entity", "type": "HardState", "optional": true}], "returnType": "MetricResult"}, {"id": "apps/lore-weave/lib/rules/metrics/index.ts::evaluateSimpleCount", "name": "evaluateSimpleCount", "kind": "function", "filePath": "apps/lore-weave/lib/rules/metrics/index.ts", "sourceCode": "/**\n * Evaluate a simple count metric (for use in ratios).\n */\nexport function evaluateSimpleCount(\n  metric: SimpleCountMetric,\n  ctx: MetricContext\n): number {\n  switch (metric.type) {\n    case 'entity_count': {\n      let entities = ctx.graph.findEntities({ kind: metric.kind });\n      if (metric.subtype) {\n        entities = entities.filter((e) => e.subtype === metric.subtype);\n      }\n      if (metric.status) {\n        entities = entities.filter((e) => e.status === metric.status);\n      }\n      return entities.length;\n    }\n\n    case 'relationship_count': {\n      const rels = ctx.graph.getAllRelationships();\n      if (!metric.relationshipKinds || metric.relationshipKinds.length === 0) {\n        return rels.length;\n      }\n      return rels.filter((r) => metric.relationshipKinds!.includes(r.kind)).length;\n    }\n\n    case 'tag_count': {\n      const entities = ctx.graph.getEntities();\n      return entities.filter((e) =>\n        metric.tags.some((tag) => hasTag(e.tags, tag))\n      ).length;\n    }\n\n    case 'total_entities':\n      return ctx.graph.getEntities().length;\n\n    case 'constant':\n      return metric.value;\n\n    default:\n      return 0;\n  }\n}", "parameters": [{"name": "metric", "type": "SimpleCountMetric", "optional": false}, {"name": "ctx", "type": "MetricContext", "optional": false}], "returnType": "number"}, {"id": "apps/lore-weave/lib/rules/mutations/index.ts::applyTagPatch", "name": "applyTagPatch", "kind": "function", "filePath": "apps/lore-weave/lib/rules/mutations/index.ts", "sourceCode": "export function applyTagPatch(\r\n  base: Record<string, TagValue> | undefined,\r\n  patch: TagPatch\r\n): Record<string, TagValue> {\r\n  const merged: Record<string, TagValue> = { ...(base ?? {}) };\r\n\r\n  for (const [tag, value] of Object.entries(patch)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (value === undefined) {\r\n      delete merged[tag];\r\n    } else {\r\n      merged[tag] = value;\r\n    }\r\n  }\r\n\r\n  if ('undefined' in merged) {\r\n    delete merged['undefined'];\r\n  }\r\n  if ('' in merged) {\r\n    delete merged[''];\r\n  }\r\n\r\n  return merged;\r\n}", "parameters": [{"name": "base", "type": "Record<string, TagValue> | undefined", "optional": false}, {"name": "patch", "type": "TagPatch", "optional": false}], "returnType": "Record<string, TagValue>"}, {"id": "apps/lore-weave/lib/rules/mutations/index.ts::buildTagPatch", "name": "buildTagPatch", "kind": "function", "filePath": "apps/lore-weave/lib/rules/mutations/index.ts", "sourceCode": "export function buildTagPatch(\r\n  before: Record<string, TagValue> | undefined,\r\n  after: Record<string, TagValue>\r\n): TagPatch {\r\n  const base = before ?? {};\r\n  const patch: TagPatch = {};\r\n\r\n  for (const [tag, value] of Object.entries(after)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (base[tag] !== value) {\r\n      patch[tag] = value;\r\n    }\r\n  }\r\n\r\n  for (const tag of Object.keys(base)) {\r\n    if (!tag || tag === 'undefined') {\r\n      continue;\r\n    }\r\n    if (!(tag in after)) {\r\n      patch[tag] = undefined;\r\n    }\r\n  }\r\n\r\n  return patch;\r\n}", "parameters": [{"name": "before", "type": "Record<string, TagValue> | undefined", "optional": false}, {"name": "after", "type": "Record<string, TagValue>", "optional": false}], "returnType": "TagPatch"}, {"id": "apps/lore-weave/lib/rules/mutations/index.ts::prepareMutation", "name": "prepareMutation", "kind": "function", "filePath": "apps/lore-weave/lib/rules/mutations/index.ts", "sourceCode": "/**\r\n * Prepare a mutation for application.\r\n *\r\n * This returns a MutationResult describing what changes should be made,\r\n * without actually modifying the graph. The caller is responsible for\r\n * applying the changes.\r\n *\r\n * @param mutation - The mutation to prepare\r\n * @param ctx - The rule context\r\n * @returns MutationResult with prepared changes\r\n */\r\nexport function prepareMutation(\r\n  mutation: Mutation,\r\n  ctx: RuleContext\r\n): MutationResult {\r\n  const result: MutationResult = {\r\n    applied: true,\r\n    diagnostic: '',\r\n    entityModifications: [],\r\n    relationshipsCreated: [],\r\n    relationshipsAdjusted: [],\r\n    relationshipsToArchive: [],\r\n    pressureChanges: {},\r\n    rateLimitUpdated: false,\r\n  };\r\n\r\n  switch (mutation.type) {\r\n    // =========================================================================\r\n    // TAG MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'set_tag':\r\n      return prepareSetTag(mutation, ctx, result);\r\n\r\n    case 'remove_tag':\r\n      return prepareRemoveTag(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // RELATIONSHIP MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'create_relationship':\r\n      return prepareCreateRelationship(mutation, ctx, result);\r\n\r\n    case 'archive_relationship':\r\n      return prepareArchiveRelationship(mutation, ctx, result);\r\n\r\n    case 'archive_all_relationships':\r\n      // Convert to archive_relationship format (without 'with' = archives all)\r\n      return prepareArchiveRelationship(\r\n        {\r\n          type: 'archive_relationship',\r\n          entity: mutation.entity,\r\n          relationshipKind: mutation.relationshipKind,\r\n          direction: mutation.direction,\r\n        },\r\n        ctx,\r\n        result\r\n      );\r\n\r\n    case 'adjust_relationship_strength':\r\n      return prepareAdjustRelationshipStrength(mutation, ctx, result);\r\n\r\n    case 'transfer_relationship':\r\n      return prepareTransferRelationship(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // ENTITY MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'change_status':\r\n      return prepareChangeStatus(mutation, ctx, result);\r\n\r\n    case 'adjust_prominence':\r\n      return prepareAdjustProminence(mutation, ctx, result);\r\n\r\n    // =========================================================================\r\n    // PRESSURE MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'modify_pressure':\r\n      return prepareModifyPressure(mutation, result);\r\n\r\n    // =========================================================================\r\n    // RATE LIMIT MUTATIONS\r\n    // =========================================================================\r\n\r\n    case 'update_rate_limit':\r\n      result.rateLimitUpdated = true;\r\n      result.diagnostic = 'rate limit updated';\r\n      return result;\r\n\r\n    // =========================================================================\r\n    // COMPOUND ACTIONS\r\n    // =========================================================================\r\n\r\n    case 'for_each_related':\r\n      return prepareForEachRelated(mutation, ctx, result);\r\n\r\n    case 'conditional':\r\n      return prepareConditional(mutation, ctx, result);\r\n\r\n    default:\r\n      result.applied = false;\r\n      result.diagnostic = `unknown mutation type: ${(mutation as Mutation).type}`;\r\n      return result;\r\n  }\r\n}", "parameters": [{"name": "mutation", "type": "Mutation", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "MutationResult"}, {"id": "apps/lore-weave/lib/rules/mutations/index.ts::applyMutationResult", "name": "applyMutationResult", "kind": "function", "filePath": "apps/lore-weave/lib/rules/mutations/index.ts", "sourceCode": "/**\r\n * Apply a prepared mutation result to the graph.\r\n *\r\n * @param result - The prepared mutation result\r\n * @param ctx - The rule context\r\n */\r\nexport function applyMutationResult(result: MutationResult, ctx: RuleContext): void {\r\n  // Apply entity modifications\r\n  for (const mod of result.entityModifications) {\r\n    const entity = ctx.graph.getEntity(mod.id);\r\n    if (!entity) continue;\r\n\r\n    if (mod.changes.status !== undefined) {\r\n      ctx.graph.updateEntityStatus(mod.id, mod.changes.status);\r\n    }\r\n\r\n    if (mod.changes.prominence !== undefined) {\r\n      ctx.graph.updateEntity(mod.id, { prominence: mod.changes.prominence });\r\n    }\r\n\r\n    if (mod.changes.tags !== undefined) {\r\n      const newTags = applyTagPatch(entity.tags, mod.changes.tags);\r\n      ctx.graph.updateEntity(mod.id, { tags: newTags });\r\n    }\r\n  }\r\n\r\n  // Create relationships\r\n  for (const rel of result.relationshipsCreated) {\r\n    ctx.graph.createRelationship(rel.kind, rel.src, rel.dst, rel.strength);\r\n  }\r\n\r\n  // Adjust relationships\r\n  for (const rel of result.relationshipsAdjusted) {\r\n    ctx.graph.modifyRelationshipStrength(rel.src, rel.dst, rel.kind, rel.delta);\r\n  }\r\n\r\n  // Archive relationships\r\n  for (const rel of result.relationshipsToArchive) {\r\n    ctx.graph.archiveRelationship(rel.src, rel.dst, rel.kind);\r\n  }\r\n\r\n  // Apply pressure changes\r\n  for (const [pressureId, delta] of Object.entries(result.pressureChanges)) {\r\n    ctx.graph.modifyPressure(pressureId, delta);\r\n  }\r\n\r\n  // Update rate limit state if needed\r\n  if (result.rateLimitUpdated && ctx.graph.rateLimitState) {\r\n    ctx.graph.rateLimitState.lastCreationTick = ctx.tick;\r\n    ctx.graph.rateLimitState.creationsThisEpoch++;\r\n  }\r\n}", "parameters": [{"name": "result", "type": "MutationResult", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "void"}, {"id": "apps/lore-weave/lib/rules/mutations/index.ts::applyMutation", "name": "applyMutation", "kind": "function", "filePath": "apps/lore-weave/lib/rules/mutations/index.ts", "sourceCode": "/**\r\n * Prepare and immediately apply a mutation.\r\n * Convenience wrapper for simple cases.\r\n *\r\n * @param mutation - The mutation to apply\r\n * @param ctx - The rule context\r\n * @returns MutationResult describing what was done\r\n */\r\nexport function applyMutation(mutation: Mutation, ctx: RuleContext): MutationResult {\r\n  const result = prepareMutation(mutation, ctx);\r\n  if (result.applied) {\r\n    applyMutationResult(result, ctx);\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "mutation", "type": "Mutation", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "MutationResult"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::describeSelectionFilter", "name": "describeSelectionFilter", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "export function describeSelectionFilter(filter: SelectionFilter): string {\n  switch (filter.type) {\n    case 'exclude':\n      return `exclude [${filter.entities.join(', ')}]`;\n    case 'has_relationship':\n      return `has_relationship '${filter.kind}'${filter.with ? ' with ' + filter.with : ''}`;\n    case 'lacks_relationship':\n      return `lacks_relationship '${filter.kind}'${filter.with ? ' with ' + filter.with : ''}`;\n    case 'has_tag':\n      return `has_tag '${filter.tag}'${filter.value !== undefined ? ' = ' + filter.value : ''}`;\n    case 'has_tags':\n      return `has_tags [${filter.tags.join(', ')}]`;\n    case 'has_any_tag':\n      return `has_any_tag [${filter.tags.join(', ')}]`;\n    case 'lacks_tag':\n      return `lacks_tag '${filter.tag}'${filter.value !== undefined ? ' = ' + filter.value : ''}`;\n    case 'lacks_any_tag':\n      return `lacks_any_tag [${filter.tags.join(', ')}]`;\n    case 'has_culture':\n      return `has_culture '${filter.culture}'`;\n    case 'matches_culture':\n      return `matches_culture with ${filter.with}`;\n    case 'not_matches_culture':\n      return `not_matches_culture with ${filter.with}`;\n    case 'has_status':\n      return `has_status '${filter.status}'`;\n    case 'has_prominence':\n      return `has_prominence >= ${filter.minProminence}`;\n    case 'shares_related':\n      return `shares_related '${filter.relationshipKind}' with ${filter.with}`;\n    case 'graph_path':\n      return `graph_path ${filter.assert.check}`;\n    default:\n      return 'unknown filter';\n  }\n}", "parameters": [{"name": "filter", "type": "SelectionFilter", "optional": false}], "returnType": "string"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::applyEntityCriteria", "name": "applyEntityCriteria", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Apply base selection criteria to a set of entities.\n */\nexport function applyEntityCriteria(\n  entities: HardState[],\n  criteria: EntitySelectionCriteria\n): HardState[] {\n  let result = entities;\n\n  if (criteria.kind) {\n    result = result.filter((e) => e.kind === criteria.kind);\n  }\n\n  if (criteria.kinds && criteria.kinds.length > 0) {\n    result = result.filter((e) => criteria.kinds!.includes(e.kind));\n  }\n\n  if (criteria.subtypes && criteria.subtypes.length > 0) {\n    result = result.filter((e) => criteria.subtypes!.includes(e.subtype));\n  }\n\n  if (criteria.excludeSubtypes && criteria.excludeSubtypes.length > 0) {\n    result = result.filter((e) => !criteria.excludeSubtypes!.includes(e.subtype));\n  }\n\n  if (criteria.status) {\n    result = result.filter((e) => e.status === criteria.status);\n  }\n\n  if (criteria.statuses && criteria.statuses.length > 0) {\n    result = result.filter((e) => criteria.statuses!.includes(e.status));\n  }\n\n  if (criteria.notStatus) {\n    result = result.filter((e) => e.status !== criteria.notStatus);\n  }\n\n  if (criteria.hasTag) {\n    result = result.filter((e) => hasTag(e.tags, criteria.hasTag!));\n  }\n\n  if (criteria.notHasTag) {\n    result = result.filter((e) => !hasTag(e.tags, criteria.notHasTag!));\n  }\n\n  return result;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "criteria", "type": "EntitySelectionCriteria", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::applyPreferFilters", "name": "applyPreferFilters", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Apply prefer filters to an entity list, falling back to the original list.\n */\nexport function applyPreferFilters(\n  entities: HardState[],\n  filters: SelectionFilter[] | undefined,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  if (!filters || filters.length === 0) return entities;\n\n  let preferred = entities;\n  for (const filter of filters) {\n    preferred = applySelectionFilters(preferred, [filter], ctx.resolver);\n  }\n\n  if (preferred.length > 0) {\n    pushTrace(trace, 'prefer filters matched', preferred.length);\n    return preferred;\n  }\n\n  pushTrace(trace, 'prefer filters (no match, using all)', entities.length);\n  return entities;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "filters", "type": "SelectionFilter[] | undefined", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::applyPickStrategy", "name": "applyPickStrategy", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "export function applyPickStrategy(\n  entities: HardState[],\n  pickStrategy: SelectionRule['pickStrategy']   | undefined,\n  maxResults?: number\n): HardState[] {\n  const limit = maxResults && maxResults > 0 ? Math.min(maxResults, entities.length) : undefined;\n\n  switch (pickStrategy) {\n    case 'random': {\n      if (limit) return sampleRandom(entities, limit);\n      return entities.length > 0 ? [pickRandom(entities)] : [];\n    }\n    case 'weighted':\n      if (limit) return sampleWeighted(entities, limit);\n      const picked = pickWeighted(entities);\n      return picked ? [picked] : [];\n    case 'first':\n      return limit ? entities.slice(0, limit) : entities.slice(0, 1);\n    case 'all':\n      return limit ? entities.slice(0, limit) : entities;\n    default:\n      return limit ? entities.slice(0, limit) : entities;\n  }\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "pickStrategy", "type": "SelectionRule['pickStrategy']   | undefined", "optional": false}, {"name": "maxResults", "type": "number", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::applySaturationLimits", "name": "applySaturationLimits", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Apply saturation limits to filter out entities that have too many relationships.\n * Counts unique connected entities, not raw relationships.\n * This handles bidirectional relationships correctly (A\u2192B and B\u2192A count as one connection).\n */\nexport function applySaturationLimits(\n  entities: HardState[],\n  limits: SaturationLimit[] | undefined,\n  ctx: RuleContext\n): HardState[] {\n  if (!limits || limits.length === 0) return entities;\n\n  return entities.filter((entity) => {\n    for (const limit of limits) {\n      const relationships = ctx.graph.getRelationships(entity.id, limit.relationshipKind);\n\n      // Use a Set to count unique connected entities, not raw relationships\n      // This correctly handles bidirectional relationships stored as two records\n      const connectedEntities = new Set<string>();\n\n      for (const rel of relationships) {\n        const otherId = rel.src === entity.id ? rel.dst : rel.src;\n        if (limit.fromKind) {\n          const otherEntity = ctx.graph.getEntity(otherId);\n          if (!otherEntity || otherEntity.kind !== limit.fromKind) continue;\n          if (limit.fromSubtype && otherEntity.subtype !== limit.fromSubtype) continue;\n        }\n        connectedEntities.add(otherId);\n      }\n\n      if (connectedEntities.size >= limit.maxCount) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "limits", "type": "SaturationLimit[] | undefined", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::selectEntities", "name": "selectEntities", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Select entities using a SelectionRule.\n */\nexport function selectEntities(\n  rule: SelectionRule,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  const graphView = ctx.graph;\n  let entities: HardState[];\n  let kinds: string[];\n  if (rule.kinds && rule.kinds.length > 0) {\n    kinds = rule.kinds;\n  } else if (rule.kind) {\n    kinds = [rule.kind];\n  } else {\n    kinds = [];\n  }\n  const kindLabel = kinds.length > 0 ? kinds.join('|') : 'any';\n\n  // Include historical entities if the rule explicitly asks for them\n  const needsHistorical = rule.status === 'historical' || rule.statuses?.includes('historical');\n\n  const getCandidatesByKind = (): HardState[] => {\n    if (kinds.length === 0 || kinds.includes('any')) {\n      return graphView.getEntities({ includeHistorical: needsHistorical });\n    }\n    if (kinds.length === 1 && rule.kind && (!rule.kinds || rule.kinds.length === 0)) {\n      return graphView.findEntities({ kind: rule.kind, includeHistorical: needsHistorical });\n    }\n    return graphView.getEntities({ includeHistorical: needsHistorical }).filter((e) => kinds.includes(e.kind));\n  };\n\n  switch (rule.strategy) {\n    case 'by_kind': {\n      entities = getCandidatesByKind();\n      pushTrace(trace, `kind=${kindLabel}`, entities.length);\n      break;\n    }\n\n    case 'by_preference_order': {\n      entities = [];\n      const allEntities = getCandidatesByKind();\n      for (const subtype of rule.subtypePreferences || []) {\n        const matches = allEntities.filter((e) => e.subtype === subtype);\n        if (matches.length > 0) {\n          entities = matches;\n          break;\n        }\n      }\n      if (entities.length === 0) {\n        entities = allEntities;\n      }\n      pushTrace(trace, `preference_order=${kindLabel}`, entities.length);\n      break;\n    }\n\n    case 'by_relationship': {\n      const allEntities = getCandidatesByKind();\n      const direction = normalizeDirection(rule.direction);\n      const mustHave = rule.mustHave === true;\n      entities = allEntities.filter((entity) => {\n        const relationships = ctx.graph.getRelationships(entity.id, rule.relationshipKind);\n        const hasRel = relationships.some((link) => {\n          if (direction === 'src') return link.src === entity.id;\n          if (direction === 'dst') return link.dst === entity.id;\n          return link.src === entity.id || link.dst === entity.id;\n        });\n        return mustHave ? hasRel : !hasRel;\n      });\n      pushTrace(trace, `relationship=${rule.relationshipKind ?? 'any'}`, entities.length);\n      break;\n    }\n\n    case 'by_proximity': {\n      const refEntity = ctx.resolver.resolveEntity(rule.referenceEntity || '$target');\n      if (!refEntity?.coordinates) {\n        entities = [];\n        pushTrace(trace, 'proximity: no reference coordinates', 0);\n        break;\n      }\n      const maxDist = rule.maxDistance || 50;\n      entities = getCandidatesByKind().filter((e) => {\n        if (!e.coordinates) return false;\n        const dx = e.coordinates.x - refEntity.coordinates.x;\n        const dy = e.coordinates.y - refEntity.coordinates.y;\n        const dz = e.coordinates.z - refEntity.coordinates.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz) <= maxDist;\n      });\n      pushTrace(trace, `proximity<=${maxDist}`, entities.length);\n      break;\n    }\n\n    case 'by_prominence': {\n      const minLabel = (rule.minProminence || 'marginal') as ProminenceLabel;\n      const minThreshold = prominenceThreshold(minLabel);\n      entities = getCandidatesByKind().filter((e) => {\n        return e.prominence >= minThreshold;\n      });\n      pushTrace(trace, `prominence>=${rule.minProminence ?? 'marginal'}`, entities.length);\n      break;\n    }\n\n    default:\n      entities = [];\n      pushTrace(trace, 'unknown strategy', 0);\n  }\n\n  if (rule.subtypes && rule.subtypes.length > 0) {\n    entities = entities.filter((e) => rule.subtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype in [${rule.subtypes.join(', ')}]`, entities.length);\n  }\n\n  if (rule.excludeSubtypes && rule.excludeSubtypes.length > 0) {\n    entities = entities.filter((e) => !rule.excludeSubtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype not in [${rule.excludeSubtypes.join(', ')}]`, entities.length);\n  }\n\n  if (rule.status) {\n    entities = entities.filter((e) => e.status === rule.status);\n    pushTrace(trace, `status=${rule.status}`, entities.length);\n  }\n\n  if (rule.statuses && rule.statuses.length > 0) {\n    entities = entities.filter((e) => rule.statuses!.includes(e.status));\n    pushTrace(trace, `status in [${rule.statuses.join(', ')}]`, entities.length);\n  }\n\n  if (rule.notStatus) {\n    entities = entities.filter((e) => e.status !== rule.notStatus);\n    pushTrace(trace, `status!=${rule.notStatus}`, entities.length);\n  }\n\n  if (rule.filters && rule.filters.length > 0) {\n    for (const filter of rule.filters) {\n      entities = applySelectionFilters(entities, [filter], ctx.resolver);\n      pushTrace(trace, describeSelectionFilter(filter), entities.length);\n    }\n  }\n\n  entities = applySaturationLimits(entities, rule.saturationLimits, ctx);\n\n  return applyPickStrategyWithBias(entities, rule, ctx);\n}", "parameters": [{"name": "rule", "type": "SelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::selectVariableEntities", "name": "selectVariableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Select candidates for a variable selection rule.\n */\nexport function selectVariableEntities(\n  select: VariableSelectionRule,\n  ctx: RuleContext,\n  trace?: SelectionTrace\n): HardState[] {\n  const graphView = ctx.graph;\n  let entities: HardState[];\n\n  // Include historical entities if the rule explicitly asks for them\n  const needsHistorical = select.status === 'historical' || select.statuses?.includes('historical');\n\n  if (select.from && select.from !== 'graph') {\n    // Check if this is a path-based traversal\n    if (isPathBasedSpec(select.from)) {\n      // Path-based traversal: follow multiple hops\n      const steps = select.from.path;\n      if (steps.length === 0) {\n        pushTrace(trace, 'empty path', 0);\n        return [];\n      }\n\n      // Get starting entities from first step's 'from' field\n      const firstStep = steps[0];\n      let startEntities: HardState[];\n\n      if (firstStep.from) {\n        const startEntity = ctx.resolver.resolveEntity(firstStep.from);\n        if (!startEntity) {\n          pushTrace(trace, `path start ${firstStep.from} (not found)`, 0);\n          return [];\n        }\n        startEntities = [startEntity];\n        pushTrace(trace, `path start: ${startEntity.name || startEntity.id}`, 1);\n      } else {\n        // No 'from' on first step - use all entities matching kind filters\n        startEntities = graphView.getEntities({ includeHistorical: needsHistorical });\n        pushTrace(trace, 'path start: all entities', startEntities.length);\n      }\n\n      // Traverse the path\n      entities = traversePath(startEntities, steps, ctx, trace);\n    } else {\n      // Single-hop related entities (legacy format)\n      const relatedTo = ctx.resolver.resolveEntity(select.from.relatedTo);\n      if (!relatedTo) {\n        pushTrace(trace, `related to ${select.from.relatedTo} (not found)`, 0);\n        return [];\n      }\n      const direction = normalizeDirection(select.from.direction);\n      entities = graphView.getConnectedEntities(\n        relatedTo.id,\n        select.from.relationshipKind,\n        direction\n      );\n      pushTrace(trace, `via ${select.from.relationshipKind} from ${relatedTo.name || relatedTo.id}`, entities.length);\n    }\n  } else {\n    if (select.kinds && select.kinds.length > 0) {\n      entities = graphView.getEntities({ includeHistorical: needsHistorical }).filter((e) => select.kinds!.includes(e.kind));\n      pushTrace(trace, `${select.kinds.join('|')} entities`, entities.length);\n    } else if (select.kind) {\n      entities = graphView.findEntities({ kind: select.kind, includeHistorical: needsHistorical });\n      pushTrace(trace, `${select.kind} entities`, entities.length);\n    } else {\n      entities = graphView.getEntities({ includeHistorical: needsHistorical });\n      pushTrace(trace, 'all entities', entities.length);\n    }\n  }\n\n  if (select.kinds && select.kinds.length > 0) {\n    entities = entities.filter((e) => select.kinds!.includes(e.kind));\n    pushTrace(trace, `kind in [${select.kinds.join(', ')}]`, entities.length);\n  } else if (select.kind) {\n    entities = entities.filter((e) => e.kind === select.kind);\n    pushTrace(trace, `kind=${select.kind}`, entities.length);\n  }\n\n  if (select.subtypes && select.subtypes.length > 0) {\n    entities = entities.filter((e) => select.subtypes!.includes(e.subtype));\n    pushTrace(trace, `subtype in [${select.subtypes.join(', ')}]`, entities.length);\n  }\n\n  if (select.status) {\n    entities = entities.filter((e) => e.status === select.status);\n    pushTrace(trace, `status=${select.status}`, entities.length);\n  }\n\n  if (select.statuses && select.statuses.length > 0) {\n    entities = entities.filter((e) => select.statuses!.includes(e.status));\n    pushTrace(trace, `status in [${select.statuses.join(', ')}]`, entities.length);\n  }\n\n  if (select.notStatus) {\n    entities = entities.filter((e) => e.status !== select.notStatus);\n    pushTrace(trace, `status!=${select.notStatus}`, entities.length);\n  }\n\n  if (select.filters && select.filters.length > 0) {\n    for (const filter of select.filters) {\n      entities = applySelectionFilters(entities, [filter], ctx.resolver);\n      pushTrace(trace, describeSelectionFilter(filter), entities.length);\n    }\n  }\n\n  return applyPreferFilters(entities, select.preferFilters, ctx, trace);\n}", "parameters": [{"name": "select", "type": "VariableSelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}, {"name": "trace", "type": "SelectionTrace", "optional": true}], "returnType": "HardState[]"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::resolveSingleVariable", "name": "resolveSingleVariable", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Resolve a single variable selection.\n *\n * This is the core variable resolution function used by both templateInterpreter\n * and thresholdTrigger systems.\n *\n * @param select - Variable selection rule\n * @param ctx - Rule context with graph, resolver, and any bound entities\n * @returns Single entity, array of entities, or undefined if no matches\n */\nexport function resolveSingleVariable(\n  select: VariableSelectionRule,\n  ctx: RuleContext\n): HardState | HardState[] | undefined {\n  const candidates = selectVariableEntities(select, ctx);\n\n  if (candidates.length === 0) {\n    return undefined;\n  }\n\n  const pickStrategy = select.pickStrategy ?? 'random';\n  const picked = applyPickStrategy(candidates, pickStrategy, select.maxResults);\n\n  if (pickStrategy === 'all' || (select.maxResults && select.maxResults > 1)) {\n    return picked;\n  }\n  return picked[0];\n}", "parameters": [{"name": "select", "type": "VariableSelectionRule", "optional": false}, {"name": "ctx", "type": "RuleContext", "optional": false}], "returnType": "HardState | HardState[] | undefined"}, {"id": "apps/lore-weave/lib/rules/selection/index.ts::resolveVariablesForEntity", "name": "resolveVariablesForEntity", "kind": "function", "filePath": "apps/lore-weave/lib/rules/selection/index.ts", "sourceCode": "/**\n * Resolve a set of variables for a given self entity.\n *\n * Variables are resolved in order, and each resolved variable becomes available\n * to subsequent variable selections (allowing $var1 to reference $var2 if $var2\n * was defined earlier).\n *\n * This is a convenience wrapper around resolveSingleVariable for systems that\n * need to resolve all variables at once.\n *\n * @param variables - Map of variable names to definitions\n * @param baseCtx - Base rule context (should have graph and resolver)\n * @param self - The entity to bind as $self\n * @returns Record of resolved variables, or null if any required variable couldn't be resolved\n */\nexport function resolveVariablesForEntity(\n  variables: Record<string, VariableDefinitionForResolution>,\n  baseCtx: RuleContext,\n  self: HardState\n): Record<string, HardState> | null {\n  const resolved: Record<string, HardState> = {};\n\n  // Create a resolver that can resolve $self and previously resolved variables\n  const createResolvingContext = (): RuleContext => ({\n    ...baseCtx,\n    self,\n    entities: { ...baseCtx.entities, self, ...resolved },\n    resolver: {\n      resolveEntity: (ref: string): HardState | undefined => {\n        if (ref === '$self') return self;\n        if (ref.startsWith('$')) {\n          const name = ref.slice(1);\n          if (resolved[name]) return resolved[name];\n          if (name === 'self') return self;\n        }\n        return baseCtx.resolver.resolveEntity(ref);\n      },\n      getGraphView: () => baseCtx.resolver.getGraphView(),\n      setPathSet: (name: string, ids: Set<string>) => baseCtx.resolver.setPathSet(name, ids),\n      getPathSet: (name: string) => baseCtx.resolver.getPathSet(name),\n    },\n  });\n\n  // Resolve variables in order\n  for (const [varName, varDef] of Object.entries(variables)) {\n    // Strip leading $ from variable name for storage\n    const cleanName = varName.startsWith('$') ? varName.slice(1) : varName;\n\n    const ctx = createResolvingContext();\n    const result = resolveSingleVariable(varDef.select, ctx);\n\n    if (!result || (Array.isArray(result) && result.length === 0)) {\n      if (varDef.required) {\n        // Required variable not found - skip this entity\n        return null;\n      }\n      // Optional variable not found - continue without it\n      continue;\n    }\n\n    // For system variables, we only support single entities\n    resolved[cleanName] = Array.isArray(result) ? result[0] : result;\n  }\n\n  return resolved;\n}", "parameters": [{"name": "variables", "type": "Record<string, VariableDefinitionForResolution>", "optional": false}, {"name": "baseCtx", "type": "RuleContext", "optional": false}, {"name": "self", "type": "HardState", "optional": false}], "returnType": "Record<string, HardState> | null"}, {"id": "apps/lore-weave/webui/src/LoreWeaveRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/LoreWeaveRemote.jsx", "sourceCode": "export default function LoreWeaveRemote({\n  projectId,\n  schema = { entityKinds: [], relationshipKinds: [], cultures: [] },\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  seedEntities = [],\n  seedRelationships = [],\n  distributionTargets = null,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults: externalSimulationResults,\n  onSimulationResultsChange,\n  simulationState: externalSimulationState,\n  onSimulationStateChange,\n  onSearchRunScored,\n}) {\n  // Use passed-in section or default to 'configure'\n  const activeTab = activeSection || \"configure\";\n  const setActiveTab = onSectionChange || (() => {});\n\n  // Simulation state - use external state if provided, otherwise use local state\n  const [localSimulationResults, setLocalSimulationResults] = useState(null);\n  const simulationResults =\n    externalSimulationResults !== undefined ? externalSimulationResults : localSimulationResults;\n  const setSimulationResults = onSimulationResultsChange || setLocalSimulationResults;\n  const [isRunning, setIsRunning] = useState(false);\n\n  // Lift worker management to this level so it persists across tab navigation\n  // This allows stepping through epochs, exporting to Archivist, and returning to continue\n  const simulationWorker = useSimulationWorker();\n\n  // Sync worker running state (only update if value actually changed)\n  const prevIsRunningRef = useRef(simulationWorker.isRunning);\n  useEffect(() => {\n    if (prevIsRunningRef.current !== simulationWorker.isRunning) {\n      prevIsRunningRef.current = simulationWorker.isRunning;\n      setIsRunning(simulationWorker.isRunning);\n    }\n  }, [simulationWorker.isRunning]);\n\n  // Validate configuration completeness\n  const configValidation = useMemo(() => {\n    const issues = [];\n    const warnings = [];\n\n    // Required elements\n    if (schema.entityKinds.length === 0) {\n      issues.push(\"No entity kinds defined\");\n    }\n    if (schema.relationshipKinds.length === 0) {\n      issues.push(\"No relationship kinds defined\");\n    }\n    if (schema.cultures.length === 0) {\n      issues.push(\"No cultures defined\");\n    }\n    if (eras.length === 0) {\n      issues.push(\"No eras defined\");\n    }\n    if (generators.length === 0) {\n      issues.push(\"No generators (growth templates) defined\");\n    }\n\n    // Warnings\n    if (pressures.length === 0) {\n      warnings.push(\"No pressures defined - simulation will have no dynamic feedback\");\n    }\n    if (seedEntities.length === 0) {\n      warnings.push(\"No seed entities - world will start empty\");\n    }\n    const hasNamingProfiles = schema.cultures.some((c) => c.naming?.profiles?.length);\n    if (!hasNamingProfiles) {\n      warnings.push(\"No naming data - entities will need explicit names\");\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      warnings,\n      stats: {\n        entityKinds: schema.entityKinds.length,\n        relationshipKinds: schema.relationshipKinds.length,\n        cultures: schema.cultures.length,\n        eras: eras.length,\n        pressures: pressures.length,\n        generators: generators.length,\n        seedEntities: seedEntities.length,\n        seedRelationships: seedRelationships.length,\n      },\n    };\n  }, [schema, eras, pressures, generators, seedEntities, seedRelationships]);\n\n  // Handle simulation completion (don't auto-navigate - let user review logs first)\n  const handleSimulationComplete = useCallback((results) => {\n    setSimulationResults(results);\n    setIsRunning(false);\n    // Don't auto-navigate to results - user will click \"View Results\" button\n  }, []);\n\n  const renderContent = () => {\n    switch (activeTab) {\n      case \"configure\":\n        return (\n          <ConfigurationSummary\n            schema={schema}\n            eras={eras}\n            pressures={pressures}\n            generators={generators}\n            seedEntities={seedEntities}\n            seedRelationships={seedRelationships}\n            validation={configValidation}\n            onNavigateToRun={() => setActiveTab(\"run\")}\n          />\n        );\n      case \"targets\":\n        return (\n          <DistributionTargetsEditor\n            distributionTargets={distributionTargets}\n            schema={schema}\n            onDistributionTargetsChange={onDistributionTargetsChange}\n          />\n        );\n      case \"validate\":\n        return (\n          <ValidationPanel\n            schema={schema}\n            eras={eras}\n            generators={generators}\n            pressures={pressures}\n            systems={systems}\n            actions={actions}\n            seedEntities={seedEntities}\n          />\n        );\n      case \"run\":\n        return (\n          <SimulationRunner\n            projectId={projectId}\n            schema={schema}\n            eras={eras}\n            pressures={pressures}\n            generators={generators}\n            systems={systems}\n            actions={actions}\n            seedEntities={seedEntities}\n            seedRelationships={seedRelationships}\n            distributionTargets={distributionTargets}\n            validation={configValidation}\n            isRunning={isRunning}\n            setIsRunning={setIsRunning}\n            onComplete={handleSimulationComplete}\n            onViewResults={() => setActiveTab(\"results\")}\n            externalSimulationState={externalSimulationState}\n            onSimulationStateChange={onSimulationStateChange}\n            onSearchRunScored={onSearchRunScored}\n            simulationWorker={simulationWorker}\n          />\n        );\n      case \"results\":\n        return (\n          <ResultsViewer\n            results={simulationResults}\n            schema={schema}\n            onNewRun={() => setActiveTab(\"run\")}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"lw-app-container\">\n      {/* Left sidebar with nav */}\n      <div className=\"lw-sidebar\">\n        <nav className=\"lw-sidebar-nav\">\n          {TABS.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`lw-nav-button ${activeTab === tab.id ? \"active\" : \"\"}`}\n            >\n              {tab.label}\n              {tab.id === \"results\" && simulationResults && (\n                <span className=\"lw-nav-badge\">{simulationResults.metadata?.entityCount || 0}</span>\n              )}\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"lw-main-area\">\n        <div className=\"lw-content-area\">{renderContent()}</div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema = { entityKinds: [], relationshipKinds: [], cultures: [] },\n  eras = [],\n  pressures = [],\n  generators = [],\n  systems = [],\n  actions = [],\n  seedEntities = [],\n  seedRelationships = [],\n  distributionTargets = null,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults: externalSimulationResults,\n  onSimulationResultsChange,\n  simulationState: externalSimulationState,\n  onSimulationStateChange,\n  onSearchRunScored,\n}", "type": "{ projectId: any; schema?: { entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; }; eras?: any[]; pressures?: any[]; generators?: any[]; systems?: any[]; actions?: any[]; seedEntities?: any[]; seedRelationships?: any[]; distributionTargets?: any; onDistributionTargetsChange: any; activeSection: any; onSectionChange: any; simulationResults: any; onSimulationResultsChange: any; simulationState: any; onSimulationStateChange: any; onSearchRunScored: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/DebugSettingsModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/DebugSettingsModal.jsx", "sourceCode": "export default function DebugSettingsModal({ isOpen, onClose, debugConfig, onDebugConfigChange }) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const handleMasterToggle = () => {\n    onDebugConfigChange({\n      ...debugConfig,\n      enabled: !debugConfig.enabled,\n    });\n  };\n\n  const handleCategoryToggle = (categoryId) => {\n    if (!debugConfig.enabled) return;\n\n    const currentCategories = debugConfig.enabledCategories || [];\n    const newCategories = currentCategories.includes(categoryId)\n      ? currentCategories.filter((c) => c !== categoryId)\n      : [...currentCategories, categoryId];\n\n    onDebugConfigChange({\n      ...debugConfig,\n      enabledCategories: newCategories,\n    });\n  };\n\n  const handleSelectAll = () => {\n    onDebugConfigChange({\n      ...debugConfig,\n      enabled: true,\n      enabledCategories: DEBUG_CATEGORIES.map((c) => c.id),\n    });\n  };\n\n  const handleClearAll = () => {\n    onDebugConfigChange({\n      ...debugConfig,\n      enabledCategories: [],\n    });\n  };\n\n  const isCategoryEnabled = (categoryId) => {\n    // If no categories are explicitly enabled, all are shown (when master is on)\n    if (debugConfig.enabledCategories.length === 0) return true;\n    return debugConfig.enabledCategories.includes(categoryId);\n  };\n\n  return (\n    <div\n      className=\"lw-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"lw-modal\">\n        <div className=\"lw-modal-header\">\n          <h2 className=\"lw-modal-title\">Debug Settings</h2>\n          <button className=\"lw-modal-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n\n        <div className=\"lw-modal-body\">\n          {/* Master toggle */}\n          <div className=\"lw-master-toggle\">\n            <span className=\"lw-master-label\">Enable Debug Output</span>\n            <div\n              className={`lw-toggle ${debugConfig.enabled ? \"active\" : \"\"}`}\n              onClick={handleMasterToggle}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleMasterToggle(); }}\n            >\n              <div className=\"lw-toggle-knob\" />\n            </div>\n          </div>\n\n          {/* Category list */}\n          <div className=\"lw-category-list\">\n            {DEBUG_CATEGORIES.map((category) => (\n              <div\n                key={category.id}\n                className={`lw-category-item ${!debugConfig.enabled ? \"disabled\" : \"\"}`}\n                onClick={() => handleCategoryToggle(category.id)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div\n                  className={`lw-category-checkbox ${debugConfig.enabled && isCategoryEnabled(category.id) ? \"checked\" : \"\"}`}\n                >\n                  {debugConfig.enabled && isCategoryEnabled(category.id) && (\n                    <span className=\"checkmark\">\u2713</span>\n                  )}\n                </div>\n                <div className=\"lw-category-info\">\n                  <div className=\"lw-category-label\">{category.label}</div>\n                  <div className=\"lw-category-desc\">{category.description}</div>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Footer with select/clear buttons */}\n        <div className=\"lw-modal-footer\">\n          <button className=\"lw-btn lw-btn-secondary\" onClick={handleClearAll}>\n            Clear All\n          </button>\n          <button className=\"lw-btn lw-btn-secondary\" onClick={handleSelectAll}>\n            Select All\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, debugConfig, onDebugConfigChange }", "type": "{ isOpen: any; onClose: any; debugConfig: any; onDebugConfigChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/config/ConfigurationSummary.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/config/ConfigurationSummary.jsx", "sourceCode": "export default function ConfigurationSummary({\n  schema,\n  eras,\n  pressures,\n  generators,\n  seedEntities: _seedEntities,\n  seedRelationships: _seedRelationships,\n  validation,\n  onNavigateToRun,\n}) {\n  return (\n    <div className=\"lw-container\">\n      <div className=\"lw-header\">\n        <h1 className=\"lw-title\">Configuration Summary</h1>\n        <p className=\"lw-subtitle\">Review the world configuration before running the simulation</p>\n      </div>\n\n      {/* Validation Status */}\n      <div className={`lw-validation-box ${validation.isValid ? \"valid\" : \"invalid\"}`}>\n        <div className={`lw-validation-title ${validation.isValid ? \"valid\" : \"invalid\"}`}>\n          {validation.isValid ? \"Configuration is ready\" : \"Configuration incomplete\"}\n        </div>\n\n        {validation.issues.length > 0 && (\n          <ul className=\"lw-validation-list\">\n            {validation.issues.map((issue, i) => (\n              <li key={i} className=\"lw-validation-item error\">\n                {issue}\n              </li>\n            ))}\n          </ul>\n        )}\n\n        {validation.warnings.length > 0 && (\n          <ul\n            className={`lw-validation-list ${validation.issues.length > 0 ? \"cs-warning-list-spaced\" : \"\"}`}\n          >\n            {validation.warnings.map((warning, i) => (\n              <li key={i} className=\"lw-validation-item warning\">\n                {warning}\n              </li>\n            ))}\n          </ul>\n        )}\n      </div>\n\n      {/* Stats Overview */}\n      <div className=\"lw-stats-grid\">\n        <StatCard label=\"Entity Kinds\" value={validation.stats.entityKinds} />\n        <StatCard label=\"Relationship Kinds\" value={validation.stats.relationshipKinds} />\n        <StatCard label=\"Cultures\" value={validation.stats.cultures} />\n        <StatCard label=\"Eras\" value={validation.stats.eras} />\n        <StatCard label=\"Pressures\" value={validation.stats.pressures} />\n        <StatCard label=\"Generators\" value={validation.stats.generators} />\n        <StatCard label=\"Seed Entities\" value={validation.stats.seedEntities} />\n        <StatCard label=\"Seed Relationships\" value={validation.stats.seedRelationships} />\n      </div>\n\n      {/* Eras Detail */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Eras ({eras.length})</h2>\n        {eras.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No eras defined. Configure eras in the Coherence Engine tab.\n          </div>\n        ) : (\n          eras.map((era) => (\n            <div key={era.id} className=\"lw-detail-card\">\n              <div className=\"lw-detail-header\">\n                <span className=\"lw-detail-name\">{era.name || era.id}</span>\n                <span className=\"lw-detail-id\">{era.id}</span>\n              </div>\n              {era.summary && <div className=\"lw-detail-description\">{era.summary}</div>}\n            </div>\n          ))\n        )}\n      </div>\n\n      {/* Cultures */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Cultures ({schema.cultures.length})</h2>\n        {schema.cultures.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No cultures defined. Configure cultures in the Enumerist tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {schema.cultures.map((culture) => (\n              <span\n                key={culture.id}\n                className=\"lw-item-badge cs-culture-badge\"\n                style={{\n                  '--cs-culture-badge-border': culture.color || undefined,\n                  '--cs-culture-badge-color': culture.color || undefined,\n                }}\n              >\n                {culture.name}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Entity Kinds */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Entity Kinds ({schema.entityKinds.length})</h2>\n        {schema.entityKinds.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No entity kinds defined. Configure entity kinds in the Enumerist tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {schema.entityKinds.map((ek) => (\n              <span key={ek.kind || ek.id} className=\"lw-item-badge\">\n                {ek.name || ek.kind || ek.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Generators */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Generators ({generators.length})</h2>\n        {generators.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No generators defined. Configure generators in the Coherence Engine tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {generators.map((gen) => (\n              <span key={gen.id} className=\"lw-item-badge\">\n                {gen.name || gen.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Pressures */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Pressures ({pressures.length})</h2>\n        {pressures.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No pressures defined. Configure pressures in the Coherence Engine tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {pressures.map((pressure) => (\n              <span key={pressure.id} className=\"lw-item-badge\">\n                {pressure.name || pressure.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Run Button */}\n      <button\n        className={`lw-btn lw-btn-primary ${!validation.isValid ? \"disabled\" : \"\"}`}\n        onClick={onNavigateToRun}\n        disabled={!validation.isValid}\n      >\n        Continue to Run\n      </button>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema,\n  eras,\n  pressures,\n  generators,\n  seedEntities: _seedEntities,\n  seedRelationships: _seedRelationships,\n  validation,\n  onNavigateToRun,\n}", "type": "{ schema: any; eras: any; pressures: any; generators: any; seedEntities: any; seedRelationships: any; validation: any; onNavigateToRun: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/config/index.js::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/config/index.js", "sourceCode": "export default function ConfigurationSummary({\n  schema,\n  eras,\n  pressures,\n  generators,\n  seedEntities: _seedEntities,\n  seedRelationships: _seedRelationships,\n  validation,\n  onNavigateToRun,\n}) {\n  return (\n    <div className=\"lw-container\">\n      <div className=\"lw-header\">\n        <h1 className=\"lw-title\">Configuration Summary</h1>\n        <p className=\"lw-subtitle\">Review the world configuration before running the simulation</p>\n      </div>\n\n      {/* Validation Status */}\n      <div className={`lw-validation-box ${validation.isValid ? \"valid\" : \"invalid\"}`}>\n        <div className={`lw-validation-title ${validation.isValid ? \"valid\" : \"invalid\"}`}>\n          {validation.isValid ? \"Configuration is ready\" : \"Configuration incomplete\"}\n        </div>\n\n        {validation.issues.length > 0 && (\n          <ul className=\"lw-validation-list\">\n            {validation.issues.map((issue, i) => (\n              <li key={i} className=\"lw-validation-item error\">\n                {issue}\n              </li>\n            ))}\n          </ul>\n        )}\n\n        {validation.warnings.length > 0 && (\n          <ul\n            className={`lw-validation-list ${validation.issues.length > 0 ? \"cs-warning-list-spaced\" : \"\"}`}\n          >\n            {validation.warnings.map((warning, i) => (\n              <li key={i} className=\"lw-validation-item warning\">\n                {warning}\n              </li>\n            ))}\n          </ul>\n        )}\n      </div>\n\n      {/* Stats Overview */}\n      <div className=\"lw-stats-grid\">\n        <StatCard label=\"Entity Kinds\" value={validation.stats.entityKinds} />\n        <StatCard label=\"Relationship Kinds\" value={validation.stats.relationshipKinds} />\n        <StatCard label=\"Cultures\" value={validation.stats.cultures} />\n        <StatCard label=\"Eras\" value={validation.stats.eras} />\n        <StatCard label=\"Pressures\" value={validation.stats.pressures} />\n        <StatCard label=\"Generators\" value={validation.stats.generators} />\n        <StatCard label=\"Seed Entities\" value={validation.stats.seedEntities} />\n        <StatCard label=\"Seed Relationships\" value={validation.stats.seedRelationships} />\n      </div>\n\n      {/* Eras Detail */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Eras ({eras.length})</h2>\n        {eras.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No eras defined. Configure eras in the Coherence Engine tab.\n          </div>\n        ) : (\n          eras.map((era) => (\n            <div key={era.id} className=\"lw-detail-card\">\n              <div className=\"lw-detail-header\">\n                <span className=\"lw-detail-name\">{era.name || era.id}</span>\n                <span className=\"lw-detail-id\">{era.id}</span>\n              </div>\n              {era.summary && <div className=\"lw-detail-description\">{era.summary}</div>}\n            </div>\n          ))\n        )}\n      </div>\n\n      {/* Cultures */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Cultures ({schema.cultures.length})</h2>\n        {schema.cultures.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No cultures defined. Configure cultures in the Enumerist tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {schema.cultures.map((culture) => (\n              <span\n                key={culture.id}\n                className=\"lw-item-badge cs-culture-badge\"\n                style={{\n                  '--cs-culture-badge-border': culture.color || undefined,\n                  '--cs-culture-badge-color': culture.color || undefined,\n                }}\n              >\n                {culture.name}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Entity Kinds */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Entity Kinds ({schema.entityKinds.length})</h2>\n        {schema.entityKinds.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No entity kinds defined. Configure entity kinds in the Enumerist tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {schema.entityKinds.map((ek) => (\n              <span key={ek.kind || ek.id} className=\"lw-item-badge\">\n                {ek.name || ek.kind || ek.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Generators */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Generators ({generators.length})</h2>\n        {generators.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No generators defined. Configure generators in the Coherence Engine tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {generators.map((gen) => (\n              <span key={gen.id} className=\"lw-item-badge\">\n                {gen.name || gen.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Pressures */}\n      <div className=\"lw-section\">\n        <h2 className=\"lw-section-title\">Pressures ({pressures.length})</h2>\n        {pressures.length === 0 ? (\n          <div className=\"lw-empty-state cs-empty-state-compact\">\n            No pressures defined. Configure pressures in the Coherence Engine tab.\n          </div>\n        ) : (\n          <div className=\"lw-item-list\">\n            {pressures.map((pressure) => (\n              <span key={pressure.id} className=\"lw-item-badge\">\n                {pressure.name || pressure.id}\n              </span>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Run Button */}\n      <button\n        className={`lw-btn lw-btn-primary ${!validation.isValid ? \"disabled\" : \"\"}`}\n        onClick={onNavigateToRun}\n        disabled={!validation.isValid}\n      >\n        Continue to Run\n      </button>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema,\n  eras,\n  pressures,\n  generators,\n  seedEntities: _seedEntities,\n  seedRelationships: _seedRelationships,\n  validation,\n  onNavigateToRun,\n}", "type": "{ schema: any; eras: any; pressures: any; generators: any; seedEntities: any; seedRelationships: any; validation: any; onNavigateToRun: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/EpochTimeline.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/EpochTimeline.jsx", "sourceCode": "export default function EpochTimeline({\n  epochStats,\n  currentEpoch,\n  pressures,\n  pressureDetails,\n  reachability,\n}) {\n  const recentEpochs = epochStats.slice(-5).reverse();\n\n  // Build a map of pressure details by ID for easy lookup\n  const detailsMap = new Map();\n  if (pressureDetails?.pressures) {\n    for (const p of pressureDetails.pressures) {\n      detailsMap.set(p.id, p);\n    }\n  }\n\n  const connectedComponents = reachability?.connectedComponents;\n  const fullyConnectedTick = reachability?.fullyConnectedTick ?? null;\n  const disconnectedClustersValue =\n    typeof connectedComponents === \"number\" ? connectedComponents.toLocaleString() : \"--\";\n  let fullyConnectedValue = \"--\";\n  if (reachability) {\n    fullyConnectedValue = fullyConnectedTick === null ? \"never\" : fullyConnectedTick.toLocaleString();\n  }\n  const clusterValueColor =\n    typeof connectedComponents === \"number\" && connectedComponents > 1\n      ? \"var(--lw-danger)\"\n      : undefined;\n\n  return (\n    <div className=\"lw-panel\">\n      <div className=\"lw-panel-header\">\n        <div className=\"lw-panel-title\">\n          <span>\u23f1</span>\n          Epoch Timeline\n        </div>\n        {currentEpoch && (\n          <span className=\"et-era-label\">\n            Era: {currentEpoch.era.name}\n          </span>\n        )}\n      </div>\n      <div className=\"lw-panel-content\">\n        {recentEpochs.length === 0 ? (\n          <div className=\"lw-empty-state\">\n            <span className=\"lw-empty-icon\">\u23f3</span>\n            <span>No epochs completed yet</span>\n          </div>\n        ) : (\n          <>\n            <div className=\"lw-timeline\">\n              {recentEpochs.map((epoch, i) => (\n                <div\n                  key={epoch.epoch}\n                  className={`lw-timeline-item ${i === 0 ? \"active\" : \"\"} et-timeline-opacity`}\n                  style={{ '--et-timeline-opacity': i === 0 ? 1 : 0.7 }}\n                >\n                  <div className={`lw-timeline-icon ${i === 0 ? \"active\" : \"\"}`}>{epoch.epoch}</div>\n                  <div className=\"lw-timeline-content\">\n                    <div className=\"lw-timeline-title\">{formatEpochEra(epoch.era)}</div>\n                    <div className=\"lw-timeline-subtitle\">\n                      +{epoch.entitiesCreated} entities \u2022 +{epoch.relationshipsCreated} relations\n                    </div>\n                  </div>\n                </div>\n              ))}\n            </div>\n\n            {/* Pressure Gauges with hover details */}\n            {pressures && Object.keys(pressures).length > 0 && (\n              <div className=\"et-section-spacer\">\n                <div className=\"et-section-label\">\n                  Current Pressures\n                  {pressureDetails && (\n                    <span className=\"et-section-label-hint\">\n                      (hover for epoch details\n                      {pressureDetails.ticksAggregated\n                        ? `, ${pressureDetails.ticksAggregated} ticks`\n                        : \"\"}\n                      )\n                    </span>\n                  )}\n                </div>\n                <div className=\"lw-flex-col lw-gap-sm\">\n                  {Object.entries(pressures).map(([name, value]) => (\n                    <PressureGauge\n                      key={name}\n                      name={name}\n                      value={value}\n                      detail={detailsMap.get(name)}\n                      discreteModifications={pressureDetails?.discreteModifications}\n                      tickCount={pressureDetails?.ticksAggregated}\n                    />\n                  ))}\n                </div>\n              </div>\n            )}\n\n            <div className=\"et-section-spacer\">\n              <div className=\"et-section-label\">\n                Graph Connectivity\n              </div>\n              <div className=\"lw-flex-col lw-gap-sm\">\n                <div className=\"et-metric-row\">\n                  <span>Disconnected clusters</span>\n                  <span className=\"et-cluster-value\" style={{ '--et-cluster-value-color': clusterValueColor }}>{disconnectedClustersValue}</span>\n                </div>\n                <div className=\"et-metric-row\">\n                  <span>Fully connected tick</span>\n                  <span className=\"et-connected-value\">{fullyConnectedValue}</span>\n                </div>\n              </div>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  epochStats,\n  currentEpoch,\n  pressures,\n  pressureDetails,\n  reachability,\n}", "type": "{ epochStats: any; currentEpoch: any; pressures: any; pressureDetails: any; reachability: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/FinalDiagnostics.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/FinalDiagnostics.jsx", "sourceCode": "// Keep for JS template bar calculations\n\nexport default function FinalDiagnostics({\n  entityBreakdown,\n  catalystStats,\n  relationshipBreakdown,\n  notableEntities,\n}) {\n  const [activeTab, setActiveTab] = useState(\"entities\");\n\n  const hasDiagnostics =\n    entityBreakdown || catalystStats || relationshipBreakdown || notableEntities;\n\n  if (!hasDiagnostics) {\n    return null;\n  }\n\n  return (\n    <div className=\"lw-panel\">\n      <div className=\"lw-panel-header\">\n        <div className=\"lw-panel-title\">\n          <span>\ud83d\udccb</span>\n          Final Diagnostics\n        </div>\n      </div>\n\n      {/* Tab navigation */}\n      <div className=\"lw-filter-tabs\">\n        {[\"entities\", \"relationships\", \"agents\", \"notable\"].map((tab) => (\n          <button\n            key={tab}\n            className={`lw-filter-tab ${activeTab === tab ? \"active\" : \"\"}`}\n            onClick={() => setActiveTab(tab)}\n          >\n            {tab.charAt(0).toUpperCase() + tab.slice(1)}\n          </button>\n        ))}\n      </div>\n\n      <div className=\"lw-panel-content\">\n        {activeTab === \"entities\" && entityBreakdown && (\n          <EntityBreakdownTab entityBreakdown={entityBreakdown} />\n        )}\n        {activeTab === \"relationships\" && relationshipBreakdown && (\n          <RelationshipBreakdownTab relationshipBreakdown={relationshipBreakdown} />\n        )}\n        {activeTab === \"agents\" && catalystStats && <AgentsTab catalystStats={catalystStats} />}\n        {activeTab === \"notable\" && notableEntities && (\n          <NotableEntitiesTab notableEntities={notableEntities} />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entityBreakdown,\n  catalystStats,\n  relationshipBreakdown,\n  notableEntities,\n}", "type": "{ entityBreakdown: any; catalystStats: any; relationshipBreakdown: any; notableEntities: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/LogStream.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/LogStream.jsx", "sourceCode": "export default function LogStream({ logs, onClear }) {\n  const [isExpanded, setIsExpanded] = useState(true);\n  const [filter, setFilter] = useState(\"all\");\n\n  const filteredLogs = useMemo(() => {\n    if (filter === \"all\") return logs;\n    return logs.filter((log) => log.level === filter);\n  }, [logs, filter]);\n\n  const logCounts = useMemo(\n    () => ({\n      all: logs.length,\n      info: logs.filter((l) => l.level === \"info\").length,\n      warn: logs.filter((l) => l.level === \"warn\").length,\n      error: logs.filter((l) => l.level === \"error\").length,\n    }),\n    [logs]\n  );\n\n  return (\n    <div className=\"lw-log-panel\">\n      <div className=\"lw-log-header\" onClick={() => setIsExpanded(!isExpanded)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"ls-header-left\">\n          <span className=\"ls-title\">\n            {isExpanded ? \"\u25bc\" : \"\u25b6\"} Log Stream\n          </span>\n          <span className=\"ls-count\">\n            {logs.length} entries\n          </span>\n          {logCounts.error > 0 && (\n            <span className=\"lw-badge lw-badge-error\">{logCounts.error} errors</span>\n          )}\n          {logCounts.warn > 0 && (\n            <span className=\"lw-badge lw-badge-warn\">{logCounts.warn} warnings</span>\n          )}\n        </div>\n        {logs.length > 0 && (\n          <button\n            className=\"lw-btn-copy\"\n            onClick={(e) => {\n              e.stopPropagation();\n              onClear();\n            }}\n          >\n            Clear\n          </button>\n        )}\n      </div>\n      {isExpanded && logs.length > 0 && (\n        <>\n          <div className=\"ls-filter-bar\">\n            <div className=\"lw-filter-tabs\">\n              {[\"all\", \"info\", \"warn\", \"error\"].map((f) => (\n                <button\n                  key={f}\n                  className={`lw-filter-tab ${filter === f ? \"active\" : \"\"}`}\n                  onClick={() => setFilter(f)}\n                >\n                  {f} ({logCounts[f] || 0})\n                </button>\n              ))}\n            </div>\n          </div>\n          <div className=\"lw-log-content\">\n            {filteredLogs.slice(-100).map((log, i) => (\n              <div key={i} className={`lw-log-entry ${log.level}`}>\n                [{log.level.toUpperCase().padEnd(5)}] {log.message}\n              </div>\n            ))}\n          </div>\n        </>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ logs, onClear }", "type": "{ logs: any; onClear: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/PopulationMetrics.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/PopulationMetrics.jsx", "sourceCode": "export default function PopulationMetrics({ populationReport, epochStats }) {\n  // Get latest epoch stats for entity breakdown\n  const latestEpoch = epochStats[epochStats.length - 1];\n\n  if (!populationReport && !latestEpoch) {\n    return (\n      <div className=\"lw-panel\">\n        <div className=\"lw-panel-header\">\n          <div className=\"lw-panel-title\">\n            <span>\ud83d\udcca</span>\n            Population Metrics\n          </div>\n        </div>\n        <div className=\"lw-panel-content\">\n          <div className=\"lw-empty-state\">\n            <span className=\"lw-empty-icon\">\ud83d\udcc8</span>\n            <span>Metrics will appear after first epoch</span>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"lw-panel\">\n      <div className=\"lw-panel-header\">\n        <div className=\"lw-panel-title\">\n          <span>\ud83d\udcca</span>\n          Population Metrics\n        </div>\n        {populationReport && (\n          <span\n            className=\"pm-deviation\"\n            style={{\n              '--pm-deviation-color': (() => {\n                if (populationReport.avgDeviation < 0.2) return \"var(--lw-success)\";\n                if (populationReport.avgDeviation < 0.4) return \"var(--lw-warning)\";\n                return \"var(--lw-danger)\";\n              })(),\n            }}\n          >\n            {(populationReport.avgDeviation * 100).toFixed(1)}% avg deviation\n          </span>\n        )}\n      </div>\n      <div className=\"lw-panel-content\">\n        {/* Entity counts by kind */}\n        {latestEpoch && (\n          <div className=\"lw-metric-grid\">\n            {Object.entries(latestEpoch.entitiesByKind).map(([kind, count]) => (\n              <div key={kind} className=\"lw-metric-card\">\n                <div className=\"lw-metric-header\">\n                  <span className=\"lw-metric-name\">{kind}</span>\n                </div>\n                <div className=\"lw-metric-value\">{count}</div>\n              </div>\n            ))}\n          </div>\n        )}\n\n        {/* Population deviations */}\n        {populationReport && populationReport.entityMetrics.length > 0 && (\n          <div className=\"pm-section-spacer\">\n            <div className=\"pm-section-label\">\n              Population Health\n            </div>\n            <div className=\"lw-flex-col lw-gap-sm\">\n              {populationReport.entityMetrics.slice(0, 6).map((metric) => {\n                const deviationPercent = Math.abs(metric.deviation * 100);\n                let color;\n                if (deviationPercent < 20) color = \"var(--lw-success)\";\n                else if (deviationPercent < 40) color = \"var(--lw-warning)\";\n                else color = \"var(--lw-danger)\";\n                return (\n                  <div key={`${metric.kind}:${metric.subtype}`} className=\"lw-pressure-gauge\">\n                    <span className=\"lw-pressure-name\">\n                      {metric.kind}:{metric.subtype}\n                    </span>\n                    <div className=\"lw-pressure-bar\">\n                      <div\n                        className=\"lw-pressure-fill pm-pressure-fill\"\n                        style={{\n                          '--pm-pressure-fill-width': `${Math.min(100, (metric.count / metric.target) * 50)}%`,\n                          '--pm-pressure-fill-color': color,\n                        }}\n                      />\n                    </div>\n                    <span className=\"lw-pressure-value pm-pressure-value\" style={{ '--pm-pressure-value-color': color }}>\n                      {metric.count}/{metric.target}\n                    </span>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ populationReport, epochStats }", "type": "{ populationReport: any; epochStats: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/ProgressOverview.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/ProgressOverview.jsx", "sourceCode": "export default function ProgressOverview({ progress, status }) {\n  if (!progress) {\n    return (\n      <div className=\"lw-overview-bar\">\n        <StatusBadge status={status} />\n        <div className=\"lw-progress-section\">\n          <div className=\"lw-progress-bar\">\n            <div className=\"lw-progress-fill po-progress-fill\" style={{ '--po-progress-width': '0%' }} />\n          </div>\n          <div className=\"lw-progress-text\">\n            <span>Waiting to start...</span>\n            <span>0%</span>\n          </div>\n        </div>\n        <div className=\"lw-stats-row\">\n          <div className=\"lw-stat-item\">\n            <div className=\"lw-stat-value\">0</div>\n            <div className=\"lw-stat-label\">Entities</div>\n          </div>\n          <div className=\"lw-stat-item\">\n            <div className=\"lw-stat-value\">0</div>\n            <div className=\"lw-stat-label\">Relations</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // Progress based on completed epochs (0-100%)\n  const epochProgress =\n    progress.totalEpochs > 0 ? (progress.epoch / progress.totalEpochs) * 100 : 0;\n\n  let percent;\n  if (status === \"complete\") percent = 100;\n  else if (status === \"initializing\" || status === \"validating\") percent = 0;\n  else if (status === \"finalizing\") percent = 99;\n  else percent = Math.round(epochProgress);\n\n  return (\n    <div className=\"lw-overview-bar\">\n      <StatusBadge status={status} />\n      <div className=\"lw-progress-section\">\n        <div className=\"lw-progress-bar\">\n          <div className=\"lw-progress-fill po-progress-fill\" style={{ '--po-progress-width': `${percent}%` }} />\n        </div>\n        <div className=\"lw-progress-text\">\n          <span>\n            Tick {progress.tick} / {progress.maxTicks} \u2022 Epoch {progress.epoch} /{\" \"}\n            {progress.totalEpochs}\n          </span>\n          <span>{Math.round(percent)}%</span>\n        </div>\n      </div>\n      <div className=\"lw-stats-row\">\n        <div className=\"lw-stat-item\">\n          <div className=\"lw-stat-value\">{progress.entityCount.toLocaleString()}</div>\n          <div className=\"lw-stat-label\">Entities</div>\n        </div>\n        <div className=\"lw-stat-item\">\n          <div className=\"lw-stat-value\">{progress.relationshipCount.toLocaleString()}</div>\n          <div className=\"lw-stat-label\">Relations</div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ progress, status }", "type": "{ progress: any; status: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/SimulationDashboard.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/SimulationDashboard.jsx", "sourceCode": "export default function SimulationDashboard({ simState, onClearLogs }) {\n  const {\n    status,\n    progress,\n    currentEpoch,\n    epochStats,\n    pressureUpdates,\n    populationReport,\n    templateUsage,\n    systemHealth,\n    entityBreakdown,\n    catalystStats,\n    relationshipBreakdown,\n    notableEntities,\n    result,\n    logs,\n  } = simState;\n\n  // Extract pressures from latest epoch stats\n  const pressures = epochStats.length > 0 ? epochStats[epochStats.length - 1].pressures : null;\n\n  // Get the current epoch number\n  const currentEpochNumber =\n    currentEpoch?.epoch ?? (epochStats.length > 0 ? epochStats[epochStats.length - 1].epoch : 0);\n\n  // Aggregate all pressure updates for the current epoch\n  const aggregatedPressureUpdate = useMemo(\n    () => aggregatePressureUpdates(pressureUpdates, currentEpochNumber),\n    [pressureUpdates, currentEpochNumber]\n  );\n\n  const reachability = result?.metadata?.reachability;\n\n  // Show final diagnostics when simulation is complete or we have diagnostic data\n  const showFinalDiagnostics =\n    status === \"complete\" ||\n    entityBreakdown ||\n    catalystStats ||\n    relationshipBreakdown ||\n    notableEntities;\n\n  return (\n    <div className=\"lw-dashboard\">\n      {/* Overview Bar */}\n      <ProgressOverview progress={progress} status={status} />\n\n      {/* Main Content Grid */}\n      <div className=\"lw-main-content\">\n        {/* Left Panel */}\n        <EpochTimeline\n          epochStats={epochStats}\n          currentEpoch={currentEpoch}\n          pressures={pressures}\n          pressureDetails={aggregatedPressureUpdate}\n          reachability={reachability}\n        />\n\n        {/* Right Panel - stacked */}\n        <div className=\"lw-flex-col lw-gap-lg\">\n          <PopulationMetrics populationReport={populationReport} epochStats={epochStats} />\n          <TemplateUsage templateUsage={templateUsage} systemHealth={systemHealth} />\n        </div>\n      </div>\n\n      {/* Final Diagnostics (shown after completion) */}\n      {showFinalDiagnostics && (\n        <FinalDiagnostics\n          entityBreakdown={entityBreakdown}\n          catalystStats={catalystStats}\n          relationshipBreakdown={relationshipBreakdown}\n          notableEntities={notableEntities}\n        />\n      )}\n\n      {/* Log Stream */}\n      <LogStream logs={logs} onClear={onClearLogs} />\n    </div>\n  );\n}", "parameters": [{"name": "{ simState, onClearLogs }", "type": "{ simState: any; onClearLogs: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/StatusBadge.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/StatusBadge.jsx", "sourceCode": "export default function StatusBadge({ status }) {\n  const config = STATUS_CONFIGS[status] || STATUS_CONFIGS.idle;\n\n  return (\n    <div className=\"lw-status-badge sb-badge\" style={{ '--sb-badge-bg': config.bg, '--sb-badge-color': config.color }}>\n      <span>{config.icon}</span>\n      <span>{config.label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ status }", "type": "{ status: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/TemplateUsage.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/TemplateUsage.jsx", "sourceCode": "export default function TemplateUsage({ templateUsage, systemHealth }) {\n  const [showUnused, setShowUnused] = useState(false);\n\n  if (!templateUsage) {\n    return (\n      <div className=\"lw-panel\">\n        <div className=\"lw-panel-header\">\n          <div className=\"lw-panel-title\">\n            <span>\ud83d\udd27</span>\n            Template Usage\n          </div>\n        </div>\n        <div className=\"lw-panel-content\">\n          <div className=\"lw-empty-state\">\n            <span className=\"lw-empty-icon\">\u2699\ufe0f</span>\n            <span>Template stats will appear here</span>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const maxCount = Math.max(...templateUsage.usage.map((t) => t.count), 1);\n  const unusedCount = templateUsage.unusedTemplates?.length || 0;\n\n  return (\n    <div className=\"lw-panel\">\n      <div className=\"lw-panel-header\">\n        <div className=\"lw-panel-title\">\n          <span>\ud83d\udd27</span>\n          Template Usage\n        </div>\n        <span className=\"tu-used-label\">\n          {templateUsage.uniqueTemplatesUsed}/{templateUsage.totalTemplates} used\n        </span>\n      </div>\n      <div className=\"lw-panel-content\">\n        {/* System health indicator */}\n        {systemHealth && (\n          <div className=\"lw-health-indicator tu-health-indicator\">\n            <div\n              className={`lw-health-dot ${systemHealth.status} tu-health-dot`}\n              style={{\n                '--tu-health-dot-bg': (() => {\n                  if (systemHealth.status === \"stable\") return \"var(--lw-success)\";\n                  if (systemHealth.status === \"functional\") return \"var(--lw-warning)\";\n                  return \"var(--lw-danger)\";\n                })(),\n              }}\n            />\n            <span className=\"lw-health-text\">\n              System Health: {(systemHealth.populationHealth * 100).toFixed(0)}%\n            </span>\n            <span className=\"tu-health-status\">\n              {systemHealth.status}\n            </span>\n          </div>\n        )}\n\n        {/* Top templates */}\n        <div className=\"lw-template-list\">\n          {templateUsage.usage.slice(0, 8).map((template) => {\n            let fillColor;\n            if (template.status === \"saturated\") fillColor = \"var(--lw-danger)\";\n            else if (template.status === \"warning\") fillColor = \"var(--lw-warning)\";\n            else fillColor = \"var(--lw-accent)\";\n            return (\n              <div key={template.templateId} className=\"lw-template-item\">\n                <span className=\"lw-template-name\" title={template.templateId}>\n                  {template.templateId}\n                </span>\n                <div className=\"lw-template-bar\">\n                  <div\n                    className=\"lw-template-fill tu-template-fill\"\n                    style={{\n                      '--tu-template-fill-width': `${(template.count / maxCount) * 100}%`,\n                      '--tu-template-fill-color': fillColor,\n                    }}\n                  />\n                </div>\n                <span className=\"lw-template-count\">{template.count}\u00d7</span>\n              </div>\n            );\n          })}\n        </div>\n\n        {/* Unused templates section */}\n        {unusedCount > 0 && (\n          <div className=\"lw-unused-section\">\n            <div className=\"lw-unused-header\" onClick={() => setShowUnused(!showUnused)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n              <span className=\"lw-unused-toggle\">{showUnused ? \"\u25bc\" : \"\u25b6\"}</span>\n              <span className=\"lw-unused-title\">Unused Templates ({unusedCount})</span>\n            </div>\n            {showUnused && (\n              <div className=\"lw-unused-list\">\n                {templateUsage.unusedTemplates.map((template) => (\n                  <UnusedTemplateItem key={template.templateId} template={template} />\n                ))}\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ templateUsage, systemHealth }", "type": "{ templateUsage: any; systemHealth: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/results/index.js::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/results/index.js", "sourceCode": "export default function ResultsViewer({ results, schema: _schema, onNewRun }) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n\n  // Process results for display\n  const processedData = useMemo(() => {\n    if (!results) return null;\n\n    const { metadata, hardState, relationships, pressures, engineConfig } = results;\n\n    // Group entities by kind\n    const entityGroups = {};\n    (hardState || []).forEach((entity) => {\n      const key = `${entity.kind}:${entity.subtype}`;\n      if (!entityGroups[key]) entityGroups[key] = [];\n      entityGroups[key].push(entity);\n    });\n\n    // Group relationships by kind\n    const relationshipGroups = {};\n    (relationships || []).forEach((rel) => {\n      if (!relationshipGroups[rel.kind]) relationshipGroups[rel.kind] = [];\n      relationshipGroups[rel.kind].push(rel);\n    });\n\n    return {\n      metadata,\n      entityGroups,\n      relationshipGroups,\n      pressures: pressures || {},\n      engineConfig,\n    };\n  }, [results]);\n\n  if (!results) {\n    return (\n      <div className=\"lw-container\">\n        <div className=\"lw-empty-state rv-empty-state\">\n          <div className=\"lw-empty-icon\"></div>\n          <div className=\"lw-empty-title\">No Results Yet</div>\n          <div className=\"lw-empty-text\">\n            Run a simulation to see the generated world history here. You can review the\n            configuration and adjust parameters before running.\n          </div>\n          <button className=\"lw-btn lw-btn-primary\" onClick={onNewRun}>\n            Go to Run\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  const exportResults = () => {\n    const blob = new Blob([JSON.stringify(results, null, 2)], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"lore-weave-results.json\";\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const exportConfig = () => {\n    const blob = new Blob([JSON.stringify(processedData.engineConfig, null, 2)], {\n      type: \"application/json\",\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"engine-config.json\";\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <div className=\"lw-container\">\n      <div className=\"lw-header\">\n        <h1 className=\"lw-title\">Simulation Results</h1>\n        <p className=\"lw-subtitle\">\n          Generated world with {processedData.metadata?.entityCount || 0} entities and{\" \"}\n          {processedData.metadata?.relationshipCount || 0} relationships\n        </p>\n      </div>\n\n      {/* Action Buttons */}\n      <div className=\"lw-button-group rv-button-group\">\n        <button className=\"lw-btn lw-btn-secondary\" onClick={exportResults}>\n          Export Results\n        </button>\n        <button className=\"lw-btn lw-btn-secondary\" onClick={exportConfig}>\n          Export Config\n        </button>\n        <button className=\"lw-btn lw-btn-secondary\" onClick={onNewRun}>\n          Run New Simulation\n        </button>\n      </div>\n\n      {/* Stats Overview */}\n      <div className=\"lw-stats-grid\">\n        <StatCard label=\"Total Entities\" value={processedData.metadata?.entityCount || 0} />\n        <StatCard\n          label=\"Total Relationships\"\n          value={processedData.metadata?.relationshipCount || 0}\n        />\n        <StatCard label=\"Final Tick\" value={processedData.metadata?.tick || 0} />\n        <StatCard label=\"Epochs\" value={processedData.metadata?.epoch || 0} />\n        <StatCard label=\"Final Era\" value={processedData.metadata?.era || \"N/A\"} />\n      </div>\n\n      {/* Tabs */}\n      <div className=\"lw-tabs\">\n        <button\n          className={`lw-tab ${activeTab === \"overview\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"overview\")}\n        >\n          Overview\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"entities\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"entities\")}\n        >\n          Entities\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"pressures\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"pressures\")}\n        >\n          Pressures\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"config\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"config\")}\n        >\n          Config\n        </button>\n      </div>\n\n      {/* Tab Content */}\n      {activeTab === \"overview\" && (\n        <>\n          {/* Entity Groups */}\n          <div className=\"lw-card\">\n            <div className=\"lw-card-title\">\n              Entity Breakdown ({Object.keys(processedData.entityGroups).length} types)\n            </div>\n            <div className=\"lw-item-list\">\n              {Object.entries(processedData.entityGroups).map(([type, entities]) => (\n                <span key={type} className=\"lw-item-badge\">\n                  {type}: {entities.length}\n                </span>\n              ))}\n              {Object.keys(processedData.entityGroups).length === 0 && (\n                <span className=\"lw-comment\">No entities generated (mock run)</span>\n              )}\n            </div>\n          </div>\n\n          {/* Relationship Groups */}\n          <div className=\"lw-card\">\n            <div className=\"lw-card-title\">\n              Relationship Types ({Object.keys(processedData.relationshipGroups).length} kinds)\n            </div>\n            <div className=\"lw-item-list\">\n              {Object.entries(processedData.relationshipGroups).map(([kind, rels]) => (\n                <span key={kind} className=\"lw-item-badge\">\n                  {kind}: {rels.length}\n                </span>\n              ))}\n              {Object.keys(processedData.relationshipGroups).length === 0 && (\n                <span className=\"lw-comment\">No relationships generated (mock run)</span>\n              )}\n            </div>\n          </div>\n        </>\n      )}\n\n      {activeTab === \"entities\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Generated Entities</div>\n          {(results.hardState || []).length === 0 ? (\n            <div className=\"lw-comment\">\n              Entity generation is a mock in the current version. Run the CLI for actual entity\n              generation.\n            </div>\n          ) : (\n            <div className=\"lw-code-block\">{JSON.stringify(results.hardState, null, 2)}</div>\n          )}\n        </div>\n      )}\n\n      {activeTab === \"pressures\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Final Pressure States</div>\n          {Object.entries(processedData.pressures).length === 0 ? (\n            <div className=\"lw-comment\">No pressure data available</div>\n          ) : (\n            <div className=\"lw-flex-col lw-gap-md\">\n              {Object.entries(processedData.pressures).map(([name, value]) => (\n                <PressureBar key={name} name={name} value={value} />\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {activeTab === \"config\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Engine Configuration Used</div>\n          <div className=\"lw-code-block\">{JSON.stringify(processedData.engineConfig, null, 2)}</div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ results, schema: _schema, onNewRun }", "type": "{ results: any; schema: any; onNewRun: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/results/ResultsViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/results/ResultsViewer.jsx", "sourceCode": "export default function ResultsViewer({ results, schema: _schema, onNewRun }) {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n\n  // Process results for display\n  const processedData = useMemo(() => {\n    if (!results) return null;\n\n    const { metadata, hardState, relationships, pressures, engineConfig } = results;\n\n    // Group entities by kind\n    const entityGroups = {};\n    (hardState || []).forEach((entity) => {\n      const key = `${entity.kind}:${entity.subtype}`;\n      if (!entityGroups[key]) entityGroups[key] = [];\n      entityGroups[key].push(entity);\n    });\n\n    // Group relationships by kind\n    const relationshipGroups = {};\n    (relationships || []).forEach((rel) => {\n      if (!relationshipGroups[rel.kind]) relationshipGroups[rel.kind] = [];\n      relationshipGroups[rel.kind].push(rel);\n    });\n\n    return {\n      metadata,\n      entityGroups,\n      relationshipGroups,\n      pressures: pressures || {},\n      engineConfig,\n    };\n  }, [results]);\n\n  if (!results) {\n    return (\n      <div className=\"lw-container\">\n        <div className=\"lw-empty-state rv-empty-state\">\n          <div className=\"lw-empty-icon\"></div>\n          <div className=\"lw-empty-title\">No Results Yet</div>\n          <div className=\"lw-empty-text\">\n            Run a simulation to see the generated world history here. You can review the\n            configuration and adjust parameters before running.\n          </div>\n          <button className=\"lw-btn lw-btn-primary\" onClick={onNewRun}>\n            Go to Run\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  const exportResults = () => {\n    const blob = new Blob([JSON.stringify(results, null, 2)], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"lore-weave-results.json\";\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const exportConfig = () => {\n    const blob = new Blob([JSON.stringify(processedData.engineConfig, null, 2)], {\n      type: \"application/json\",\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = \"engine-config.json\";\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <div className=\"lw-container\">\n      <div className=\"lw-header\">\n        <h1 className=\"lw-title\">Simulation Results</h1>\n        <p className=\"lw-subtitle\">\n          Generated world with {processedData.metadata?.entityCount || 0} entities and{\" \"}\n          {processedData.metadata?.relationshipCount || 0} relationships\n        </p>\n      </div>\n\n      {/* Action Buttons */}\n      <div className=\"lw-button-group rv-button-group\">\n        <button className=\"lw-btn lw-btn-secondary\" onClick={exportResults}>\n          Export Results\n        </button>\n        <button className=\"lw-btn lw-btn-secondary\" onClick={exportConfig}>\n          Export Config\n        </button>\n        <button className=\"lw-btn lw-btn-secondary\" onClick={onNewRun}>\n          Run New Simulation\n        </button>\n      </div>\n\n      {/* Stats Overview */}\n      <div className=\"lw-stats-grid\">\n        <StatCard label=\"Total Entities\" value={processedData.metadata?.entityCount || 0} />\n        <StatCard\n          label=\"Total Relationships\"\n          value={processedData.metadata?.relationshipCount || 0}\n        />\n        <StatCard label=\"Final Tick\" value={processedData.metadata?.tick || 0} />\n        <StatCard label=\"Epochs\" value={processedData.metadata?.epoch || 0} />\n        <StatCard label=\"Final Era\" value={processedData.metadata?.era || \"N/A\"} />\n      </div>\n\n      {/* Tabs */}\n      <div className=\"lw-tabs\">\n        <button\n          className={`lw-tab ${activeTab === \"overview\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"overview\")}\n        >\n          Overview\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"entities\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"entities\")}\n        >\n          Entities\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"pressures\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"pressures\")}\n        >\n          Pressures\n        </button>\n        <button\n          className={`lw-tab ${activeTab === \"config\" ? \"active\" : \"\"}`}\n          onClick={() => setActiveTab(\"config\")}\n        >\n          Config\n        </button>\n      </div>\n\n      {/* Tab Content */}\n      {activeTab === \"overview\" && (\n        <>\n          {/* Entity Groups */}\n          <div className=\"lw-card\">\n            <div className=\"lw-card-title\">\n              Entity Breakdown ({Object.keys(processedData.entityGroups).length} types)\n            </div>\n            <div className=\"lw-item-list\">\n              {Object.entries(processedData.entityGroups).map(([type, entities]) => (\n                <span key={type} className=\"lw-item-badge\">\n                  {type}: {entities.length}\n                </span>\n              ))}\n              {Object.keys(processedData.entityGroups).length === 0 && (\n                <span className=\"lw-comment\">No entities generated (mock run)</span>\n              )}\n            </div>\n          </div>\n\n          {/* Relationship Groups */}\n          <div className=\"lw-card\">\n            <div className=\"lw-card-title\">\n              Relationship Types ({Object.keys(processedData.relationshipGroups).length} kinds)\n            </div>\n            <div className=\"lw-item-list\">\n              {Object.entries(processedData.relationshipGroups).map(([kind, rels]) => (\n                <span key={kind} className=\"lw-item-badge\">\n                  {kind}: {rels.length}\n                </span>\n              ))}\n              {Object.keys(processedData.relationshipGroups).length === 0 && (\n                <span className=\"lw-comment\">No relationships generated (mock run)</span>\n              )}\n            </div>\n          </div>\n        </>\n      )}\n\n      {activeTab === \"entities\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Generated Entities</div>\n          {(results.hardState || []).length === 0 ? (\n            <div className=\"lw-comment\">\n              Entity generation is a mock in the current version. Run the CLI for actual entity\n              generation.\n            </div>\n          ) : (\n            <div className=\"lw-code-block\">{JSON.stringify(results.hardState, null, 2)}</div>\n          )}\n        </div>\n      )}\n\n      {activeTab === \"pressures\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Final Pressure States</div>\n          {Object.entries(processedData.pressures).length === 0 ? (\n            <div className=\"lw-comment\">No pressure data available</div>\n          ) : (\n            <div className=\"lw-flex-col lw-gap-md\">\n              {Object.entries(processedData.pressures).map(([name, value]) => (\n                <PressureBar key={name} name={name} value={value} />\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n\n      {activeTab === \"config\" && (\n        <div className=\"lw-card\">\n          <div className=\"lw-card-title\">Engine Configuration Used</div>\n          <div className=\"lw-code-block\">{JSON.stringify(processedData.engineConfig, null, 2)}</div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ results, schema: _schema, onNewRun }", "type": "{ results: any; schema: any; onNewRun: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/runner/ConfigViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/runner/ConfigViewer.jsx", "sourceCode": "export default function ConfigViewer({ engineConfig, debugConfig, onShowDebugModal }) {\n  const [showConfig, setShowConfig] = useState(false);\n\n  const copyConfig = useCallback(() => {\n    navigator.clipboard.writeText(JSON.stringify(engineConfig, null, 2));\n  }, [engineConfig]);\n\n  return (\n    <>\n      <div className=\"cv-row\">\n        <div\n          className=\"lw-config-toggle cv-toggle-flush\"\n          onClick={() => setShowConfig(!showConfig)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span>{showConfig ? \"\u25bc\" : \"\u25b6\"}</span>\n          <span>View Engine Configuration</span>\n          <button\n            className=\"lw-btn-copy\"\n            onClick={(e) => {\n              e.stopPropagation();\n              copyConfig();\n            }}\n          >\n            Copy\n          </button>\n        </div>\n        <button\n          className={`lw-btn lw-btn-debug ${debugConfig.enabled ? \"active\" : \"\"}`}\n          onClick={onShowDebugModal}\n        >\n          \ud83d\udd27 Debug {debugConfig.enabled ? `(${debugConfig.enabledCategories.length || \"All\"})` : \"\"}\n        </button>\n      </div>\n      {showConfig && (\n        <div className=\"lw-config-output\">{JSON.stringify(engineConfig, null, 2)}</div>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ engineConfig, debugConfig, onShowDebugModal }", "type": "{ engineConfig: any; debugConfig: any; onShowDebugModal: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/runner/ParameterForm.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/runner/ParameterForm.jsx", "sourceCode": "export default function ParameterForm({ params, onParamChange }) {\n  return (\n    <div className=\"lw-form-grid\">\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Scale Factor\n        <NumberInput\n          min={0.1}\n          max={10}\n          step={0.1}\n          value={params.scaleFactor}\n          onChange={(v) => onParamChange(\"scaleFactor\", v ?? 1)}\n          className=\"lw-input\"\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Default Min Distance\n        <NumberInput\n          min={1}\n          max={20}\n          step={0.5}\n          value={params.defaultMinDistance}\n          onChange={(v) => onParamChange(\"defaultMinDistance\", v ?? 5)}\n          className=\"lw-input\"\n          title=\"Minimum distance between entities on semantic planes\"\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Pressure Smoothing\n        <NumberInput\n          min={1}\n          max={50}\n          step={1}\n          value={params.pressureDeltaSmoothing}\n          onChange={(v) => onParamChange(\"pressureDeltaSmoothing\", v ?? 10)}\n          className=\"lw-input\"\n          integer\n          title=\"Max pressure change per tick from feedback (higher = faster swings)\"\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Ticks Per Epoch\n        <NumberInput\n          min={1}\n          max={50}\n          value={params.ticksPerEpoch}\n          onChange={(v) => onParamChange(\"ticksPerEpoch\", v ?? 20)}\n          className=\"lw-input\"\n          integer\n          title=\"Number of simulation ticks to run per epoch\"\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Max Epochs\n        <NumberInput\n          min={1}\n          max={100}\n          value={params.maxEpochs}\n          onChange={(v) => onParamChange(\"maxEpochs\", v ?? 14)}\n          className=\"lw-input\"\n          integer\n          title=\"Maximum epochs to run (hard limit on simulation length)\"\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Max Ticks\n        <NumberInput\n          min={100}\n          max={5000}\n          value={params.maxTicks}\n          onChange={(v) => onParamChange(\"maxTicks\", v ?? 500)}\n          className=\"lw-input\"\n          integer\n        />\n        </label>\n      </div>\n      <div className=\"lw-form-group\">\n        <label className=\"lw-label\">Validity Attempts\n        <NumberInput\n          min={1}\n          max={20}\n          value={params.maxValidityAttempts}\n          onChange={(v) => onParamChange(\"maxValidityAttempts\", v ?? 4)}\n          className=\"lw-input\"\n          integer\n          title=\"Max runs for 'Until Valid' search\"\n        />\n        </label>\n      </div>\n\n      {/* Narrative Events Section */}\n      <div className=\"lw-form-group pf-narrative-section\">\n        <div className=\"pf-narrative-header\">\n          <span className=\"lw-label pf-narrative-label\">\n            Narrative Events\n          </span>\n          <label className=\"pf-toggle-label\">\n            <input\n              type=\"checkbox\"\n              checked={params.narrativeEnabled ?? false}\n              onChange={(e) => onParamChange(\"narrativeEnabled\", e.target.checked)}\n              className=\"pf-toggle-checkbox\"\n            />\n            Enable event tracking\n          </label>\n        </div>\n        <p className=\"pf-narrative-desc\">\n          Captures significant world changes (status, prominence, relationships) as narrative events\n          for story generation.\n        </p>\n        {params.narrativeEnabled && (\n          <div className=\"pf-narrative-fields\">\n            <div className=\"lw-form-group pf-narrative-field\">\n              <label className=\"lw-label\">Min Significance\n              <NumberInput\n                min={0}\n                max={1}\n                step={0.1}\n                value={params.narrativeMinSignificance ?? 0}\n                onChange={(v) => onParamChange(\"narrativeMinSignificance\", v ?? 0)}\n                className=\"lw-input\"\n                title=\"Minimum significance threshold (0-1). Higher = fewer, more important events.\"\n              />\n              </label>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ params, onParamChange }", "type": "{ params: any; onParamChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/runner/RunControls.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/runner/RunControls.jsx", "sourceCode": "export default function RunControls({\n  isRunning,\n  isPaused,\n  simState,\n  validation,\n  runValidity,\n  isRunningUntilValid,\n  validityAttempts,\n  maxValidityAttempts,\n  validitySearchComplete,\n  validityReport,\n  onRun,\n  onRunUntilValid,\n  onCancelRunUntilValid,\n  onDownloadValidityData,\n  onStartStepMode,\n  onStep,\n  onRunToCompletion,\n  onAbort,\n  onReset,\n  onViewResults,\n}) {\n  // Running until valid - show special stop button\n  if (isRunningUntilValid && isRunning) {\n    return (\n      <>\n        <div className=\"lw-step-indicator\">\n          <span>\n            Attempt {validityAttempts} / {maxValidityAttempts}\n          </span>\n          <span className=\"rc-searching-label\">SEARCHING FOR BEST RUN</span>\n        </div>\n        <button className=\"lw-btn lw-btn-danger\" onClick={onCancelRunUntilValid}>\n          \u25fc Cancel\n        </button>\n      </>\n    );\n  }\n\n  if (isRunning && !isPaused) {\n    // Running state - show stop button\n    return (\n      <button className=\"lw-btn lw-btn-danger\" onClick={onAbort}>\n        \u25fc Stop\n      </button>\n    );\n  }\n\n  if (isPaused) {\n    // Paused state - show step controls\n    return (\n      <>\n        <div className=\"lw-step-indicator\">\n          <span>\n            Epoch {simState.progress?.epoch || 0} / {simState.progress?.totalEpochs || 0}\n          </span>\n          <span className=\"rc-paused-label\">PAUSED</span>\n        </div>\n        <div className=\"lw-button-group\">\n          <button className=\"lw-btn lw-btn-step\" onClick={onStep}>\n            \u23ed Next Epoch\n          </button>\n          <button\n            className=\"lw-btn lw-btn-primary\"\n            onClick={onRunToCompletion}\n            title=\"Continue running all remaining epochs\"\n          >\n            \u25b6 Continue\n          </button>\n          <button className=\"lw-btn lw-btn-reset\" onClick={onReset}>\n            \u21bb Reset\n          </button>\n        </div>\n        {simState.status === \"complete\" && onViewResults && (\n          <button className=\"lw-btn lw-btn-success\" onClick={onViewResults}>\n            \u2713 View Results\n          </button>\n        )}\n      </>\n    );\n  }\n\n  // Idle or complete state - show run/step buttons\n  return (\n    <>\n      {simState.status === \"complete\" && <ValidityBadge runValidity={runValidity} />}\n      {validitySearchComplete && validityReport && (\n        <span\n          className=\"lw-validity-badge rc-badge-search\"\n          title={`Best score ${validityReport.summary.bestScore}${validityReport.summary.bestScoreMax ? \"/\" + validityReport.summary.bestScoreMax : \"\"} on attempt ${validityReport.summary.bestAttempt}`}\n        >\n          {validityReport.summary.totalAttempts} runs\n        </span>\n      )}\n      <div className=\"lw-button-group\">\n        <button\n          className={`lw-btn lw-btn-primary ${!validation.isValid ? \"disabled\" : \"\"}`}\n          onClick={onRun}\n          disabled={!validation.isValid}\n        >\n          \u25b6 Run\n        </button>\n        <button\n          className={`lw-btn lw-btn-secondary ${!validation.isValid ? \"disabled\" : \"\"}`}\n          onClick={onRunUntilValid}\n          disabled={!validation.isValid}\n          title={`Run up to ${maxValidityAttempts} simulations and keep the highest score`}\n        >\n          \u27f3 Search\n        </button>\n        <button\n          className={`lw-btn lw-btn-step ${!validation.isValid ? \"disabled\" : \"\"}`}\n          onClick={onStartStepMode}\n          disabled={!validation.isValid}\n          title=\"Run one epoch at a time\"\n        >\n          \u23ef Step\n        </button>\n      </div>\n      {validitySearchComplete && validityReport && (\n        <button\n          className=\"lw-btn lw-btn-secondary\"\n          onClick={onDownloadValidityData}\n          title=\"Download all run data and analysis report as ZIP\"\n        >\n          \u2b07 Download Runs\n        </button>\n      )}\n      {simState.status === \"complete\" && onViewResults && (\n        <button className=\"lw-btn lw-btn-success\" onClick={onViewResults}>\n          \u2713 View Results\n        </button>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{\n  isRunning,\n  isPaused,\n  simState,\n  validation,\n  runValidity,\n  isRunningUntilValid,\n  validityAttempts,\n  maxValidityAttempts,\n  validitySearchComplete,\n  validityReport,\n  onRun,\n  onRunUntilValid,\n  onCancelRunUntilValid,\n  onDownloadValidityData,\n  onStartStepMode,\n  onStep,\n  onRunToCompletion,\n  onAbort,\n  onReset,\n  onViewResults,\n}", "type": "{ isRunning: any; isPaused: any; simState: any; validation: any; runValidity: any; isRunningUntilValid: any; validityAttempts: any; maxValidityAttempts: any; validitySearchComplete: any; validityReport: any; onRun: any; onRunUntilValid: any; onCancelRunUntilValid: any; onDownloadValidityData: any; onStartStepMode: any; onStep: any; onRunToCompletion: any; onAbort: any; onReset: any; onViewResults: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/runner/SimulationRunner.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/runner/SimulationRunner.jsx", "sourceCode": "export default function SimulationRunner({\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  validation,\n  isRunning: _isRunning,\n  setIsRunning: _setIsRunning,\n  onComplete,\n  onViewResults,\n  onSearchRunScored,\n  externalSimulationState,\n  onSimulationStateChange,\n  simulationWorker,\n}) {\n  // Simulation parameters\n  const [params, setParams] = useState({\n    scaleFactor: 1.0,\n    defaultMinDistance: 5,\n    pressureDeltaSmoothing: 10,\n    ticksPerEpoch: 20,\n    maxEpochs: 14,\n    maxTicks: 500,\n    // Narrative event tracking\n    narrativeEnabled: true,\n    narrativeMinSignificance: 0,\n    // Validity search\n    maxValidityAttempts: 4,\n  });\n\n  // Debug configuration\n  const [debugConfig, setDebugConfig] = useState({\n    enabled: false,\n    enabledCategories: [],\n  });\n  const debugModalKey = projectId\n    ? `${DEBUG_MODAL_PREFIX}${projectId}`\n    : `${DEBUG_MODAL_PREFIX}global`;\n  const [showDebugModal, setShowDebugModal] = useState(() => loadStoredBoolean(debugModalKey));\n\n  useEffect(() => {\n    setShowDebugModal(loadStoredBoolean(debugModalKey));\n  }, [debugModalKey]);\n\n  useEffect(() => {\n    saveStoredBoolean(debugModalKey, showDebugModal);\n  }, [debugModalKey, showDebugModal]);\n\n  // Use simulation worker passed from parent\n  const {\n    state: workerSimState,\n    start: startWorker,\n    startStepping: startSteppingWorker,\n    step: stepWorker,\n    runToCompletion: runToCompletionWorker,\n    reset: resetWorker,\n    abort: abortWorker,\n    clearLogs: workerClearLogs,\n    isRunning: workerIsRunning,\n    isPaused: workerIsPaused,\n  } = simulationWorker;\n\n  // Use external state if provided and worker is idle\n  const simState =\n    workerSimState.status === \"idle\" && externalSimulationState\n      ? externalSimulationState\n      : workerSimState;\n\n  // Sync worker state changes to external state\n  const prevStatusRef = React.useRef(workerSimState.status);\n  useEffect(() => {\n    if (onSimulationStateChange && workerSimState.status !== \"idle\") {\n      if (prevStatusRef.current !== workerSimState.status) {\n        prevStatusRef.current = workerSimState.status;\n        onSimulationStateChange(workerSimState);\n      }\n    }\n  }, [workerSimState.status, onSimulationStateChange]);\n\n  // Wrap clearLogs to also clear external state\n  const clearLogs = useCallback(() => {\n    workerClearLogs();\n    if (onSimulationStateChange && externalSimulationState) {\n      onSimulationStateChange({ ...externalSimulationState, logs: [] });\n    }\n  }, [workerClearLogs, onSimulationStateChange, externalSimulationState]);\n\n  // Handle completion\n  useEffect(() => {\n    if (simState.status === \"complete\" && simState.result) {\n      onComplete(simState.result);\n    }\n  }, [simState.status, simState.result, onComplete]);\n\n  // Run scoring: templates fired (high), actions completed (med), systems executed (low)\n  const runValidity = useMemo(() => {\n    if (simState.status !== \"complete\") {\n      return {\n        score: 0,\n        maxScore: 0,\n        scoreBreakdown: null,\n        reachedFinalEra: false,\n        unusedSystems: [],\n      };\n    }\n\n    const totalTemplates = simState.templateUsage?.totalTemplates ?? countEnabled(generators);\n    const unusedTemplates = simState.templateUsage?.unusedTemplates || [];\n    const templatesUsed = Math.max(totalTemplates - unusedTemplates.length, 0);\n\n    const totalActions = countEnabled(actions);\n    const unusedActions = simState.catalystStats?.unusedActions || [];\n    const actionsUsed = Math.max(totalActions - unusedActions.length, 0);\n\n    // Check systems fired (derived from narrativeHistory)\n    const unusedSystems = getUnusedSystems(simState.result?.narrativeHistory, systems);\n    const totalSystems = (systems || [])\n      .filter((s) => s.enabled !== false)\n      .map((s) => s.config?.id || s.systemType)\n      .filter((id) => id && !INFRASTRUCTURE_SYSTEMS.has(id)).length;\n    const systemsUsed = Math.max(totalSystems - unusedSystems.length, 0);\n\n    // Check if we reached the final era\n    // The final era is the last one in the eras array\n    const finalEraId = eras?.length > 0 ? eras[eras.length - 1].id : null;\n    const currentEraId = simState.currentEpoch?.era?.id;\n    const reachedFinalEra = finalEraId && currentEraId === finalEraId;\n\n    const score =\n      templatesUsed * RUN_SCORE_WEIGHTS.templates +\n      actionsUsed * RUN_SCORE_WEIGHTS.actions +\n      systemsUsed * RUN_SCORE_WEIGHTS.systems;\n    const maxScore =\n      totalTemplates * RUN_SCORE_WEIGHTS.templates +\n      totalActions * RUN_SCORE_WEIGHTS.actions +\n      totalSystems * RUN_SCORE_WEIGHTS.systems;\n\n    return {\n      score,\n      maxScore,\n      scoreBreakdown: {\n        templates: {\n          used: templatesUsed,\n          total: totalTemplates,\n          weight: RUN_SCORE_WEIGHTS.templates,\n        },\n        actions: {\n          used: actionsUsed,\n          total: totalActions,\n          weight: RUN_SCORE_WEIGHTS.actions,\n        },\n        systems: {\n          used: systemsUsed,\n          total: totalSystems,\n          weight: RUN_SCORE_WEIGHTS.systems,\n        },\n      },\n      unusedSystems,\n      reachedFinalEra,\n    };\n  }, [\n    simState.status,\n    simState.templateUsage,\n    simState.catalystStats,\n    simState.result,\n    simState.currentEpoch,\n    eras,\n    systems,\n    generators,\n    actions,\n  ]);\n\n  // Run Until Valid state\n  const [validityAttempts, setValidityAttempts] = useState(0);\n  const [isRunningUntilValid, setIsRunningUntilValid] = useState(false);\n  const runUntilValidRef = useRef(false);\n\n  // Store run data for validity search analysis\n  const [validityRunData, setValidityRunData] = useState([]);\n  const [validitySearchComplete, setValiditySearchComplete] = useState(false);\n\n  // Generate the EngineConfig\n  const engineConfig = useMemo(() => {\n    return {\n      schema,\n      eras,\n      pressures: pressures,\n      templates: (generators || []).filter((g) => g.enabled !== false),\n      systems: (systems || []).filter((s) => s.enabled !== false),\n      actions: (actions || []).filter((a) => a.enabled !== false),\n      ticksPerEpoch: params.ticksPerEpoch,\n      maxEpochs: params.maxEpochs,\n      maxTicks: params.maxTicks,\n      maxRelationshipsPerType: 10,\n      scaleFactor: params.scaleFactor,\n      defaultMinDistance: params.defaultMinDistance,\n      pressureDeltaSmoothing: params.pressureDeltaSmoothing,\n      seedRelationships: seedRelationships || [],\n      distributionTargets: distributionTargets || undefined,\n      debugConfig,\n      // Narrative event tracking config\n      narrativeConfig: {\n        enabled: params.narrativeEnabled,\n        minSignificance: params.narrativeMinSignificance,\n      },\n    };\n  }, [\n    schema,\n    eras,\n    pressures,\n    generators,\n    systems,\n    actions,\n    params,\n    seedRelationships,\n    distributionTargets,\n    debugConfig,\n  ]);\n\n  // Run simulation\n  const runSimulation = useCallback(() => {\n    if (!validation.isValid) return;\n\n    const initialEntities = seedEntities || [];\n    startWorker(engineConfig, initialEntities);\n  }, [validation, engineConfig, seedEntities, startWorker]);\n\n  // Start in step mode\n  const startStepMode = useCallback(() => {\n    if (!validation.isValid) return;\n\n    const initialEntities = seedEntities || [];\n    startSteppingWorker(engineConfig, initialEntities);\n  }, [validation, engineConfig, seedEntities, startSteppingWorker]);\n\n  // Run Until Valid handler\n  const runUntilValid = useCallback(() => {\n    if (!validation.isValid) return;\n\n    runUntilValidRef.current = true;\n    setIsRunningUntilValid(true);\n    setValidityAttempts(1);\n    setValidityRunData([]); // Clear previous run data\n    setValiditySearchComplete(false);\n\n    const initialEntities = seedEntities || [];\n    startWorker(engineConfig, initialEntities);\n  }, [validation, engineConfig, seedEntities, startWorker]);\n\n  // Cancel run until valid\n  const cancelRunUntilValid = useCallback(() => {\n    runUntilValidRef.current = false;\n    setIsRunningUntilValid(false);\n    setValiditySearchComplete(false);\n    abortWorker();\n  }, [abortWorker]);\n\n  // Effect to handle \"run until valid\" loop and store run data\n  useEffect(() => {\n    if (!runUntilValidRef.current) return;\n    if (simState.status !== \"complete\") return;\n    if (!simState.result) return; // Wait for result to be fully populated\n\n    // Store this run's data for analysis - match canonry-slot export format\n    const runData = {\n      attempt: validityAttempts,\n      runScore: runValidity.score,\n      runScoreMax: runValidity.maxScore,\n      runScoreDetails: runValidity.scoreBreakdown,\n      finalEra: simState.currentEpoch?.era?.id || \"unknown\",\n      finalEraName: simState.currentEpoch?.era?.name || \"Unknown\",\n      reachedFinalEra: runValidity.reachedFinalEra,\n      unusedTemplates: simState.templateUsage?.unusedTemplates?.map((t) => t.templateId) || [],\n      unusedActions: simState.catalystStats?.unusedActions?.map((a) => a.actionId) || [],\n      unusedSystems: runValidity.unusedSystems || [],\n      entityCount: simState.result?.hardState?.length || 0,\n      relationshipCount: simState.result?.relationships?.length || 0,\n      // Store in canonry-slot format for script compatibility\n      simulationResults: simState.result,\n      simulationState: simState,\n    };\n\n    setValidityRunData((prev) => [...prev, runData]);\n    if (onSearchRunScored) {\n      onSearchRunScored({\n        attempt: runData.attempt,\n        runScore: runData.runScore,\n        runScoreMax: runData.runScoreMax,\n        runScoreDetails: runData.runScoreDetails,\n        simulationResults: runData.simulationResults,\n        simulationState: runData.simulationState,\n      });\n    }\n\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  validation,\n  isRunning: _isRunning,\n  setIsRunning: _setIsRunning,\n  onComplete,\n  onViewResults,\n  onSearchRunScored,\n  externalSimulationState,\n  onSimulationStateChange,\n  simulationWorker,\n}", "type": "{ projectId: any; schema: any; eras: any; pressures: any; generators: any; systems: any; actions: any; seedEntities: any; seedRelationships: any; distributionTargets: any; validation: any; isRunning: any; setIsRunning: any; onComplete: any; onViewResults: any; onSearchRunScored: any; externalSimulationState: any; onSimulationStateChange: any; simulationWorker: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/targets/DistributionTargetsEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/targets/DistributionTargetsEditor.jsx", "sourceCode": "export default function DistributionTargetsEditor({\n  distributionTargets,\n  schema,\n  onDistributionTargetsChange,\n}) {\n  // Create default targets if none exist\n  const createDefaultTargets = useCallback(() => {\n    const defaultTargets = {\n      $schema: \"Per-subtype targets for homeostatic template weighting\",\n      version: \"1.0.0\",\n      entities: {},\n    };\n\n    // Populate per-subtype targets from schema (default 0)\n    if (schema?.entityKinds) {\n      schema.entityKinds.forEach((ek) => {\n        if (!defaultTargets.entities[ek.kind]) {\n          defaultTargets.entities[ek.kind] = {};\n        }\n        ek.subtypes?.forEach((subtype) => {\n          defaultTargets.entities[ek.kind][subtype.id] = { target: 0 };\n        });\n      });\n    }\n\n    onDistributionTargetsChange(defaultTargets);\n  }, [schema, onDistributionTargetsChange]);\n\n  // Update a nested path in the targets\n  const updateTargets = useCallback(\n    (path, value) => {\n      if (!distributionTargets) return;\n\n      const newTargets = JSON.parse(JSON.stringify(distributionTargets));\n      const parts = path.split(\".\");\n      let current = newTargets;\n\n      for (let i = 0; i < parts.length - 1; i++) {\n        if (!current[parts[i]]) {\n          current[parts[i]] = {};\n        }\n        current = current[parts[i]];\n      }\n\n      current[parts[parts.length - 1]] = value;\n      onDistributionTargetsChange(newTargets);\n    },\n    [distributionTargets, onDistributionTargetsChange]\n  );\n\n  // If no targets exist, show empty state\n  if (\n    !distributionTargets ||\n    !distributionTargets.entities ||\n    Array.isArray(distributionTargets.entities)\n  ) {\n    return (\n      <div className=\"lw-container\">\n        <div className=\"lw-header\">\n          <h1 className=\"lw-title\">Distribution Targets</h1>\n          <p className=\"lw-subtitle\">\n            Configure per-subtype targets for homeostatic template weighting\n          </p>\n        </div>\n        <div className=\"lw-empty-state dte-empty-state\">\n          <div className=\"lw-empty-title\">No Distribution Targets Configured</div>\n          <div className=\"lw-empty-text\">\n            Set per-subtype targets used for homeostatic template weighting.\n          </div>\n          <button className=\"lw-btn lw-btn-primary\" onClick={createDefaultTargets}>\n            Create Default Targets\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"lw-container\">\n      <div className=\"lw-header\">\n        <h1 className=\"lw-title\">Distribution Targets</h1>\n        <p className=\"lw-subtitle\">\n          Configure per-subtype targets for homeostatic template weighting\n        </p>\n      </div>\n\n      {/* Content */}\n      <div className=\"lw-section\">\n        <EntityTargets\n          entities={distributionTargets.entities}\n          updateTargets={updateTargets}\n          distributionTargets={distributionTargets}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  distributionTargets,\n  schema,\n  onDistributionTargetsChange,\n}", "type": "{ distributionTargets: any; schema: any; onDistributionTargetsChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/targets/EntityTargets.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/targets/EntityTargets.jsx", "sourceCode": "export default function EntityTargets({ entities, updateTargets, distributionTargets }) {\n  // Group by entity kind\n  const kindGroups = {};\n  Object.entries(entities).forEach(([key, value]) => {\n    if (key === \"comment\") return;\n    if (typeof value === \"object\") {\n      kindGroups[key] = value;\n    }\n  });\n\n  return (\n    <>\n      <p className=\"lw-section-description\">\n        Per-subtype population targets for homeostatic control\n      </p>\n      {Object.entries(kindGroups).map(([kind, subtypes]) => (\n        <div key={kind} className=\"lw-card\">\n          <div className=\"lw-card-title\">{kind}</div>\n          {Object.entries(subtypes).map(([subtype, config]) => (\n            <div key={subtype} className=\"lw-row\">\n              <span className=\"lw-row-label\">{subtype}</span>\n              <div className=\"et-controls\">\n                <label className=\"lw-label et-label-inline\">\n                  Target:\n                <NumberInput\n                  className=\"lw-input-small\"\n                  value={config.target || 0}\n                  onChange={(v) => {\n                    const currentEntities = distributionTargets.entities;\n                    const newEntities = JSON.parse(JSON.stringify(currentEntities));\n                    if (!newEntities[kind]) newEntities[kind] = {};\n                    newEntities[kind][subtype] = { ...config, target: v ?? 0 };\n                    updateTargets(\"entities\", newEntities);\n                  }}\n                  integer\n                />\n                </label>\n              </div>\n              {config.comment && (\n                <span className=\"lw-comment et-comment\">\n                  {config.comment}\n                </span>\n              )}\n            </div>\n          ))}\n        </div>\n      ))}\n    </>\n  );\n}", "parameters": [{"name": "{ entities, updateTargets, distributionTargets }", "type": "{ entities: any; updateTargets: any; distributionTargets: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/validation/ValidationPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/validation/ValidationPanel.jsx", "sourceCode": "export default function ValidationPanel({\n  schema,\n  eras,\n  generators,\n  pressures,\n  systems,\n  actions,\n  seedEntities,\n}) {\n  const validationResult = useMemo(() => {\n    const cultures = schema?.cultures?.map((c) => c.id) || [];\n    const entityKinds = schema?.entityKinds?.map((k) => k.kind) || [];\n    const relationshipKinds = schema?.relationshipKinds?.map((k) => k.kind) || [];\n\n    return validateAllConfigs({\n      templates: generators,\n      pressures,\n      systems,\n      eras,\n      actions,\n      seedEntities,\n      schema: { cultures, entityKinds, relationshipKinds },\n    });\n  }, [schema, eras, generators, pressures, systems, actions, seedEntities]);\n\n  const { valid, errors, warnings } = validationResult;\n\n  return (\n    <div className=\"validation-panel-container\">\n      <div className=\"validation-panel-header\">\n        <h1 className=\"validation-panel-title\">Structure Validation</h1>\n        <p className=\"validation-panel-subtitle\">\n          Validates JSON config structure (types, required fields, shapes). This is a hard gate\n          before simulation. For semantic validation (references, balance, orphans), see the\n          Coherence Engine tab.\n        </p>\n      </div>\n\n      <div\n        className={`validation-panel-status-banner ${\n          valid ? \"validation-panel-status-valid\" : \"validation-panel-status-invalid\"\n        }`}\n      >\n        <span className=\"validation-panel-status-icon\">{valid ? \"\u2713\" : \"\u2717\"}</span>\n        <div className=\"validation-panel-status-text\">\n          <div className=\"validation-panel-status-title\">\n            {valid ? \"Configuration is valid\" : \"Configuration has errors\"}\n          </div>\n          <div className=\"validation-panel-status-subtitle\">\n            {errors.length} error{errors.length !== 1 ? \"s\" : \"\"}, {warnings.length} warning\n            {warnings.length !== 1 ? \"s\" : \"\"}\n          </div>\n        </div>\n      </div>\n\n      {errors.length > 0 && (\n        <div className=\"validation-panel-section\">\n          <h2 className=\"validation-panel-section-title\">\n            Errors\n            <span className=\"validation-panel-section-count validation-panel-section-count-error\">\n              {errors.length}\n            </span>\n          </h2>\n          <div className=\"validation-panel-list\">\n            {errors.map((error, i) => (\n              <ErrorCard key={i} error={error} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {warnings.length > 0 && (\n        <div className=\"validation-panel-section\">\n          <h2 className=\"validation-panel-section-title\">\n            Warnings\n            <span className=\"validation-panel-section-count validation-panel-section-count-warning\">\n              {warnings.length}\n            </span>\n          </h2>\n          <div className=\"validation-panel-list\">\n            {warnings.map((warning, i) => (\n              <WarningCard key={i} warning={warning} />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {valid && warnings.length === 0 && (\n        <div className=\"validation-panel-empty-state\">\n          <div className=\"validation-panel-empty-icon\">\u2713</div>\n          <div>All configuration files are valid and ready for simulation.</div>\n        </div>\n      )}\n\n      <div className=\"validation-panel-stats\">\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{generators?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Generators</div>\n        </div>\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{pressures?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Pressures</div>\n        </div>\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{systems?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Systems</div>\n        </div>\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{actions?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Actions</div>\n        </div>\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{eras?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Eras</div>\n        </div>\n        <div className=\"validation-panel-stat-card\">\n          <div className=\"validation-panel-stat-value\">{seedEntities?.length || 0}</div>\n          <div className=\"validation-panel-stat-label\">Seed Entities</div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema,\n  eras,\n  generators,\n  pressures,\n  systems,\n  actions,\n  seedEntities,\n}", "type": "{ schema: any; eras: any; generators: any; pressures: any; systems: any; actions: any; seedEntities: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/systems/GraphContagionVis.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/systems/GraphContagionVis.jsx", "sourceCode": "/**\n * Main exported component\n */\nexport function GraphContagionVis({ config, systemActions, selectedTick }) {\n  // Find all snapshots from systemActions\n  const snapshots = useMemo(() => {\n    if (!systemActions?.length) return [];\n    return systemActions\n      .filter((a) => a.details?.contagionSnapshot)\n      .map((a) => ({\n        tick: a.tick,\n        snapshot: a.details.contagionSnapshot,\n      }))\n      .sort((a, b) => a.tick - b.tick);\n  }, [systemActions]);\n\n  // Find snapshot for current tick\n  const currentSnapshot = useMemo(() => {\n    if (!snapshots.length) return null;\n\n    // If no tick selected, return most recent snapshot\n    if (selectedTick === undefined || selectedTick === null) {\n      return snapshots[snapshots.length - 1].snapshot;\n    }\n\n    // Find snapshot at or before selected tick\n    // If no snapshot exists yet at that tick, return null (don't show future data)\n    const atOrBefore = snapshots.filter((s) => s.tick <= selectedTick);\n    if (atOrBefore.length > 0) {\n      return atOrBefore[atOrBefore.length - 1].snapshot;\n    }\n    return null;\n  }, [snapshots, selectedTick]);\n\n  // Generate network from snapshot\n  const network = useMemo(() => {\n    if (!currentSnapshot) return { nodes: [], links: [] };\n    return generateNetworkFromSnapshot(currentSnapshot);\n  }, [currentSnapshot]);\n\n  if (!config) {\n    return (\n      <div className=\"vis-empty\">\n        <div className=\"vis-empty-icon\">&#9673;</div>\n        <div>No contagion configuration</div>\n      </div>\n    );\n  }\n\n  if (!currentSnapshot) {\n    return (\n      <div className=\"vis-empty\">\n        <div className=\"vis-empty-icon\">&#9673;</div>\n        <div>No contagion data</div>\n        <div className=\"vis-info-hint\">\n          Run simulation with {config.name} enabled\n        </div>\n      </div>\n    );\n  }\n\n  // Get state counts from snapshot\n  const counts = currentSnapshot.counts || {};\n  const newInfections = currentSnapshot.newInfections?.length || 0;\n\n  return (\n    <div className=\"vis-container\">\n      <div className=\"vis-container-header\">\n        <div className=\"vis-container-title\">\n          {config.name}\n          <span className=\"vis-subtitle\">\n            S:{counts.susceptible || 0} I:{counts.infected || 0} R:{counts.recovered || 0}\n          </span>\n        </div>\n        {newInfections > 0 && (\n          <div className=\"vis-info-danger\">+{newInfections} new infections</div>\n        )}\n      </div>\n      <div className=\"vis-container-body vis-container-body-full\">\n        <ParentSize>\n          {({ width, height }) =>\n            width > 0 &&\n            height > 0 && (\n              <ContagionGraph\n                width={width}\n                height={height}\n                network={network}\n                config={config}\n                selectedTick={selectedTick}\n                isPlaying={false}\n              />\n            )\n          }\n        </ParentSize>\n        <StateLegend />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ config, systemActions, selectedTick }", "type": "{ config: any; systemActions: any; selectedTick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/systems/PlaneDiffusionVis.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/systems/PlaneDiffusionVis.jsx", "sourceCode": "/**\n * Main exported component with responsive wrapper\n *\n * @param {boolean} autoScaleColors - If true, scale colors to actual min/max instead of fixed -100/100\n */\nexport function PlaneDiffusionVis({\n  config,\n  systemActions,\n  selectedTick,\n  autoScaleColors = false,\n}) {\n  // Find the snapshot for the selected tick (or most recent if no tick selected)\n  const snapshot = useMemo(() => {\n    if (!systemActions?.length) return null;\n\n    // Filter to actions from this system that have diffusion snapshots\n    const validActions = systemActions.filter((a) => a.details?.diffusionSnapshot);\n    if (!validActions.length) return null;\n\n    // If selectedTick is specified, find closest action at or before that tick\n    // If no snapshot exists yet at that tick, return null (don't show future data)\n    if (selectedTick !== undefined && selectedTick !== null) {\n      const atOrBefore = validActions.filter((a) => a.tick <= selectedTick);\n      if (atOrBefore.length > 0) {\n        return atOrBefore[atOrBefore.length - 1].details.diffusionSnapshot;\n      }\n      // No snapshot at or before selected tick - return null\n      return null;\n    }\n\n    // No tick selected - return most recent snapshot\n    return validActions[validActions.length - 1].details.diffusionSnapshot;\n  }, [systemActions, selectedTick]);\n\n  // Extract data from snapshot\n  const {\n    gridData,\n    gridSize,\n    valueRange,\n    gridStats,\n    sources,\n    sinks,\n    entities: entityData,\n  } = useMemo(() => {\n    if (!snapshot) {\n      return {\n        gridData: null,\n        gridSize: 100,\n        valueRange: { min: -100, max: 100 },\n        gridStats: null,\n        sources: [],\n        sinks: [],\n        entities: [],\n      };\n    }\n\n    // Use fixed coordinate system (0-100 is the semantic plane range)\n    const PLANE_RANGE = 100;\n\n    const normalize = (p) => ({\n      ...p,\n      x: p.x / PLANE_RANGE,\n      y: p.y / PLANE_RANGE,\n    });\n\n    // Determine color scale range\n    let effectiveRange = snapshot.valueRange || { min: -100, max: 100 };\n    if (autoScaleColors && snapshot.gridStats) {\n      // Use actual data range for better visibility of small values\n      const { min, max } = snapshot.gridStats;\n      // Add small padding and ensure we don't have a zero-width range\n      const padding = Math.max(1, (max - min) * 0.05);\n      effectiveRange = {\n        min: min - padding,\n        max: max + padding,\n      };\n    }\n\n    return {\n      gridData: snapshot.grid,\n      gridSize: snapshot.gridSize || 100,\n      valueRange: effectiveRange,\n      gridStats: snapshot.gridStats || null,\n      sources: snapshot.sources.map((s) => ({\n        ...normalize(s),\n        label: s.name?.slice(0, 8) || \"S\",\n      })),\n      sinks: (snapshot.sinks || []).map((k) => ({\n        ...normalize(k),\n        label: k.name?.slice(0, 8) || \"K\",\n      })),\n      entities: snapshot.entities.map((e) => ({\n        ...normalize(e),\n        fieldValue: e.fieldValue,\n      })),\n    };\n  }, [snapshot, autoScaleColors]);\n\n  if (!config) {\n    return (\n      <div className=\"vis-empty\">\n        <div className=\"vis-empty-icon\">&#9783;</div>\n        <div>No diffusion configuration</div>\n      </div>\n    );\n  }\n\n  if (!snapshot) {\n    return (\n      <div className=\"vis-empty\">\n        <div className=\"vis-empty-icon\">&#9783;</div>\n        <div>No diffusion data</div>\n        <div className=\"vis-info-hint\">\n          Run simulation with {config.name} enabled\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"vis-container\">\n      <div className=\"vis-container-header\">\n        <div className=\"vis-container-title\">\n          {config.name}\n          {selectedTick !== undefined && (\n            <span className=\"vis-subtitle\">Tick {selectedTick}</span>\n          )}\n        </div>\n        <div className=\"vis-info-text\">\n          {sources.length} sources, {sinks.length} sinks, {entityData.length} entities\n          {gridStats && (\n            <span className=\"vis-info-stats\">\n              | min: {gridStats.min?.toFixed(1)} max: {gridStats.max?.toFixed(1)} avg:{\" \"}\n              {gridStats.avg?.toFixed(2)} ({gridStats.nonZeroCount} non-zero)\n            </span>\n          )}\n        </div>\n      </div>\n      <div className=\"vis-container-body\">\n        <ParentSize>\n          {({ width, height }) =>\n            width > 0 &&\n            height > 0 && (\n              <DiffusionFieldChart\n                width={width}\n                height={height}\n                gridData={gridData}\n                gridSize={gridSize}\n                valueRange={valueRange}\n                sources={sources}\n                sinks={sinks}\n                entities={entityData}\n                useLogScale={autoScaleColors}\n              />\n            )\n          }\n        </ParentSize>\n        <GradientLegend\n          title={autoScaleColors ? \"Field Value (log scale)\" : \"Field Value\"}\n          minLabel=\"-100\"\n          centerLabel=\"0\"\n          maxLabel=\"+100\"\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  config,\n  systemActions,\n  selectedTick,\n  autoScaleColors = false,\n}", "type": "boolean", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/systems/SystemActivityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/systems/SystemActivityPanel.jsx", "sourceCode": "/**\n * Main panel component\n */\nexport default function SystemActivityPanel({ systemActions }) {\n  const [activeView, setActiveView] = useState(\"swimlane\");\n\n  const { systems, timeline, maxTick } = useMemo(\n    () => processSystemActions(systemActions),\n    [systemActions]\n  );\n\n  if (!systems.length) {\n    return (\n      <div className=\"system-activity-empty\">\n        <div className=\"system-activity-empty-icon\">&#9881;</div>\n        <div>No system activity recorded</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"system-activity-panel\">\n      {/* Header with view toggle */}\n      <div className=\"system-activity-header\">\n        <div className=\"system-activity-title\">System Activity</div>\n        <div className=\"system-activity-toggles\">\n          <button\n            className={`system-toggle ${activeView === \"swimlane\" ? \"active\" : \"\"}`}\n            onClick={() => setActiveView(\"swimlane\")}\n          >\n            Swimlane\n          </button>\n          <button\n            className={`system-toggle ${activeView === \"timeline\" ? \"active\" : \"\"}`}\n            onClick={() => setActiveView(\"timeline\")}\n          >\n            Timeline\n          </button>\n        </div>\n      </div>\n\n      {/* Summary cards */}\n      <SystemSummaryCards systems={systems} />\n\n      {/* Chart area */}\n      <div className=\"system-activity-chart\">\n        <ParentSize>\n          {({ width, height: _height }) => {\n            if (width === 0) return null;\n            const chartHeight = Math.max(200, Math.min(300, systems.length * 40 + 60));\n\n            return activeView === \"swimlane\" ? (\n              <SystemSwimlaneChart\n                systems={systems}\n                maxTick={maxTick}\n                width={width}\n                height={chartHeight}\n              />\n            ) : (\n              <ActivityTimelineChart\n                timeline={timeline}\n                maxTick={maxTick}\n                width={width}\n                height={chartHeight}\n              />\n            );\n          }}\n        </ParentSize>\n      </div>\n\n      {/* Legend */}\n      <div className=\"system-activity-legend\">\n        {activeView === \"timeline\" && (\n          <>\n            <div className=\"legend-item\">\n              <span className=\"legend-line sa-legend-line\" style={{ '--sa-legend-line-color': '#8b5cf6' }} />\n              <span>Relationships Added</span>\n            </div>\n            <div className=\"legend-item\">\n              <span className=\"legend-line dashed sa-legend-line\" style={{ '--sa-legend-line-color': '#22c55e' }} />\n              <span>Entities Modified</span>\n            </div>\n          </>\n        )}\n        {activeView === \"swimlane\" && (\n          <>\n            <div className=\"legend-item\">\n              <Circle cx={6} cy={6} r={6} fill=\"#8b5cf6\" />\n              <span>Active (with changes)</span>\n            </div>\n            <div className=\"legend-item\">\n              <Circle cx={6} cy={6} r={3} fill=\"#64748b\" fillOpacity={0.3} />\n              <span>Dormant</span>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ systemActions }", "type": "{ systemActions: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/EraTimeline.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/EraTimeline.jsx", "sourceCode": "/**\n * Main era timeline component\n */\nexport default function EraTimeline({ eraBoundaries, xScale, y, height, width, margin }) {\n  if (!eraBoundaries?.length) {\n    return null;\n  }\n\n  return (\n    <g>\n      {/* Timeline baseline */}\n      <line\n        x1={margin.left}\n        y1={y}\n        x2={width - margin.right}\n        y2={y}\n        stroke=\"rgba(255,255,255,0.2)\"\n        strokeWidth={1}\n      />\n\n      {/* Era segments */}\n      {eraBoundaries.map((era, i) => (\n        <EraSegment\n          key={`era-${i}`}\n          era={era}\n          index={i}\n          xScale={xScale}\n          y={y + 2}\n          height={height - 4}\n          isFirst={i === 0}\n          isLast={i === eraBoundaries.length - 1}\n        />\n      ))}\n\n      {/* Transition markers between eras */}\n      {eraBoundaries.slice(1).map((era, i) => (\n        <TransitionMarker key={`transition-${i}`} x={xScale(era.startTick)} y={y} height={height} />\n      ))}\n\n      {/* Timeline label */}\n      <text\n        x={margin.left - 8}\n        y={y + height / 2}\n        textAnchor=\"end\"\n        dominantBaseline=\"middle\"\n        fill=\"rgba(255,255,255,0.4)\"\n        fontSize={9}\n        fontWeight={500}\n      >\n        Eras\n      </text>\n    </g>\n  );\n}", "parameters": [{"name": "{ eraBoundaries, xScale, y, height, width, margin }", "type": "{ eraBoundaries: any; xScale: any; y: any; height: any; width: any; margin: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/EventSwimlanes.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/EventSwimlanes.jsx", "sourceCode": "/**\n * Main swimlanes component\n */\nexport default function EventSwimlanes({\n  events,\n  xScale,\n  y,\n  width,\n  margin,\n  hoveredEventId,\n  selectedEventId,\n  onEventHover,\n  onEventClick,\n}) {\n  const { height, gap, types } = SWIMLANE_CONFIG;\n\n  return (\n    <g>\n      {/* Swimlanes separator line */}\n      <line\n        x1={margin.left}\n        y1={y - 4}\n        x2={width - margin.right}\n        y2={y - 4}\n        stroke=\"rgba(255,255,255,0.1)\"\n        strokeWidth={1}\n      />\n\n      {/* Individual swimlanes */}\n      {types.map((type, i) => (\n        <Swimlane\n          key={type}\n          type={type}\n          events={events[type] || []}\n          xScale={xScale}\n          y={y + i * (height + gap)}\n          height={height}\n          margin={margin}\n          hoveredEventId={hoveredEventId}\n          selectedEventId={selectedEventId}\n          onEventHover={onEventHover}\n          onEventClick={onEventClick}\n        />\n      ))}\n    </g>\n  );\n}", "parameters": [{"name": "{\n  events,\n  xScale,\n  y,\n  width,\n  margin,\n  hoveredEventId,\n  selectedEventId,\n  onEventHover,\n  onEventClick,\n}", "type": "{ events: any; xScale: any; y: any; width: any; margin: any; hoveredEventId: any; selectedEventId: any; onEventHover: any; onEventClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/index.js::createXScale", "name": "createXScale", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/index.js", "sourceCode": "/**\n * Create X scale for tick values\n */\nexport function createXScale(data, width, margin) {\n  if (!data?.length) {\n    return scaleLinear({\n      domain: [0, 100],\n      range: [margin.left, width - margin.right],\n    });\n  }\n\n  const ticks = data.map((d) => d.tick);\n  return scaleLinear({\n    domain: [Math.min(...ticks), Math.max(...ticks)],\n    range: [margin.left, width - margin.right],\n  });\n}", "parameters": [{"name": "data", "type": "any", "optional": false}, {"name": "width", "type": "any", "optional": false}, {"name": "margin", "type": "any", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+d3-scale@4.0.2/node_modules/@types/d3-scale/index\").ScaleLinear<any, any, never>"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/index.js::createPressureYScale", "name": "createPressureYScale", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/index.js", "sourceCode": "/**\n * Create Y scale for pressure values\n *\n * Note: `chartBottom` is the y-coordinate of the bottom of the chart area.\n * This is NOT height - margin.bottom; the caller passes the actual bottom coordinate.\n */\nexport function createPressureYScale(data, pressureIds, chartBottom, margin) {\n  return scaleLinear({\n    domain: [-100, 100],\n    range: [chartBottom, margin.top],\n    nice: true,\n  });\n}", "parameters": [{"name": "data", "type": "any", "optional": false}, {"name": "pressureIds", "type": "any", "optional": false}, {"name": "chartBottom", "type": "any", "optional": false}, {"name": "margin", "type": "any", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+d3-scale@4.0.2/node_modules/@types/d3-scale/index\").ScaleLinear<any, any, never>"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/PressureChart.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/PressureChart.jsx", "sourceCode": "/**\n * Pressure chart component\n *\n * Note: `height` here is the y-coordinate of the chart bottom (chartBottom),\n * NOT the total chart height. The chart area spans from margin.top to height.\n */\nexport default function PressureChart({\n  data,\n  pressureIds,\n  hiddenPressures,\n  xScale,\n  yScale,\n  margin,\n  height, // This is chartBottom, not total height\n  width,\n}) {\n  if (!data?.length || !pressureIds?.length) {\n    return null;\n  }\n\n  const visiblePressures = pressureIds.filter((id) => !hiddenPressures.has(id));\n  // Chart area height is from margin.top to chartBottom (height param)\n  const chartAreaHeight = height - margin.top;\n  const zeroY = yScale(0);\n\n  return (\n    <g>\n      {/* Grid */}\n      <GridRows\n        scale={yScale}\n        width={width - margin.left - margin.right}\n        left={margin.left}\n        stroke=\"rgba(255,255,255,0.1)\"\n        strokeDasharray=\"3 3\"\n      />\n      <GridColumns\n        scale={xScale}\n        height={chartAreaHeight}\n        top={margin.top}\n        stroke=\"rgba(255,255,255,0.1)\"\n        strokeDasharray=\"3 3\"\n      />\n      {/* Equilibrium line */}\n      {Number.isFinite(zeroY) && (\n        <line\n          x1={margin.left}\n          x2={width - margin.right}\n          y1={zeroY}\n          y2={zeroY}\n          stroke=\"rgba(255,255,255,0.25)\"\n          strokeWidth={1}\n          strokeDasharray=\"4 2\"\n        />\n      )}\n\n      {/* Pressure lines */}\n      {visiblePressures.map((pressureId) => {\n        const colorIndex = pressureIds.indexOf(pressureId);\n        const color = PRESSURE_COLORS[colorIndex % PRESSURE_COLORS.length];\n\n        return (\n          <LinePath\n            key={pressureId}\n            data={data}\n            x={(d) => xScale(d.tick)}\n            y={(d) => yScale(d[pressureId] ?? 0)}\n            stroke={color}\n            strokeWidth={2}\n            strokeLinecap=\"round\"\n          />\n        );\n      })}\n\n      {/* Y Axis */}\n      <AxisLeft\n        scale={yScale}\n        left={margin.left}\n        stroke=\"#93c5fd\"\n        tickStroke=\"#93c5fd\"\n        tickLabelProps={() => ({\n          fill: \"#93c5fd\",\n          fontSize: 11,\n          textAnchor: \"end\",\n          dy: \"0.33em\",\n          dx: -4,\n        })}\n        numTicks={5}\n        hideAxisLine={false}\n        hideTicks={false}\n      />\n\n      {/* X Axis - positioned at chart bottom */}\n      <AxisBottom\n        scale={xScale}\n        top={height}\n        stroke=\"#93c5fd\"\n        tickStroke=\"#93c5fd\"\n        tickLabelProps={() => ({\n          fill: \"#93c5fd\",\n          fontSize: 11,\n          textAnchor: \"middle\",\n          dy: 4,\n        })}\n        numTicks={Math.min(10, data.length)}\n        hideAxisLine={false}\n        hideTicks={false}\n      />\n    </g>\n  );\n}", "parameters": [{"name": "{\n  data,\n  pressureIds,\n  hiddenPressures,\n  xScale,\n  yScale,\n  margin,\n  height, // This is chartBottom, not total height\n  width,\n}", "type": "{ data: any; pressureIds: any; hiddenPressures: any; xScale: any; yScale: any; margin: any; height: any; width: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/scales.js::createXScale", "name": "createXScale", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/scales.js", "sourceCode": "/**\n * Create X scale for tick values\n */\nexport function createXScale(data, width, margin) {\n  if (!data?.length) {\n    return scaleLinear({\n      domain: [0, 100],\n      range: [margin.left, width - margin.right],\n    });\n  }\n\n  const ticks = data.map((d) => d.tick);\n  return scaleLinear({\n    domain: [Math.min(...ticks), Math.max(...ticks)],\n    range: [margin.left, width - margin.right],\n  });\n}", "parameters": [{"name": "data", "type": "any", "optional": false}, {"name": "width", "type": "any", "optional": false}, {"name": "margin", "type": "any", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+d3-scale@4.0.2/node_modules/@types/d3-scale/index\").ScaleLinear<any, any, never>"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/scales.js::createPressureYScale", "name": "createPressureYScale", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/scales.js", "sourceCode": "/**\n * Create Y scale for pressure values\n *\n * Note: `chartBottom` is the y-coordinate of the bottom of the chart area.\n * This is NOT height - margin.bottom; the caller passes the actual bottom coordinate.\n */\nexport function createPressureYScale(data, pressureIds, chartBottom, margin) {\n  return scaleLinear({\n    domain: [-100, 100],\n    range: [chartBottom, margin.top],\n    nice: true,\n  });\n}", "parameters": [{"name": "data", "type": "any", "optional": false}, {"name": "pressureIds", "type": "any", "optional": false}, {"name": "chartBottom", "type": "any", "optional": false}, {"name": "margin", "type": "any", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+d3-scale@4.0.2/node_modules/@types/d3-scale/index\").ScaleLinear<any, any, never>"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/SimulationTraceVisx.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/SimulationTraceVisx.jsx", "sourceCode": "/**\n * Main component with responsive wrapper\n */\nexport default function SimulationTraceVisx({\n  pressureUpdates = [],\n  epochStats = [],\n  templateApplications = [],\n  actionApplications = [],\n  systemActions = [],\n  onClose,\n}) {\n  // State\n  const [selectedTick, setSelectedTick] = useState(null);\n  const [lockedTick, setLockedTick] = useState(null);\n  const [hiddenPressures, setHiddenPressures] = useState(new Set());\n  const [hoveredEventId, setHoveredEventId] = useState(null);\n  const [selectedEventId, setSelectedEventId] = useState(null);\n  const [scrollOffset, setScrollOffset] = useState(null);\n  const [systemPanel, setSystemPanel] = useState(null); // null | 'activity' | 'plane-diffusion' | 'graph-contagion'\n  const [selectedDiffusionId, setSelectedDiffusionId] = useState(null);\n  const [selectedContagionId, setSelectedContagionId] = useState(null);\n  const [autoScaleColors, setAutoScaleColors] = useState(false);\n\n  // Derive available diffusion/contagion systems from what actually ran (has snapshot data in systemActions)\n  const diffusionSystemsWithData = useMemo(() => {\n    const systemsMap = new Map();\n    for (const action of systemActions) {\n      if (action.details?.diffusionSnapshot && !systemsMap.has(action.systemId)) {\n        systemsMap.set(action.systemId, {\n          id: action.systemId,\n          name: action.systemName,\n        });\n      }\n    }\n    return Array.from(systemsMap.values());\n  }, [systemActions]);\n\n  const contagionSystemsWithData = useMemo(() => {\n    const systemsMap = new Map();\n    for (const action of systemActions) {\n      if (action.details?.contagionSnapshot && !systemsMap.has(action.systemId)) {\n        systemsMap.set(action.systemId, {\n          id: action.systemId,\n          name: action.systemName,\n        });\n      }\n    }\n    return Array.from(systemsMap.values());\n  }, [systemActions]);\n\n  // Auto-select first available system if none selected\n  const activeDiffusionId = selectedDiffusionId ?? diffusionSystemsWithData[0]?.id ?? null;\n  const activeContagionId = selectedContagionId ?? contagionSystemsWithData[0]?.id ?? null;\n\n  const diffusionConfig = useMemo(\n    () => ({\n      name: diffusionSystemsWithData.find((s) => s.id === activeDiffusionId)?.name,\n    }),\n    [diffusionSystemsWithData, activeDiffusionId]\n  );\n\n  const contagionConfig = useMemo(\n    () => ({\n      name: contagionSystemsWithData.find((s) => s.id === activeContagionId)?.name,\n    }),\n    [contagionSystemsWithData, activeContagionId]\n  );\n\n  // Transform data\n  const {\n    data: pressureData,\n    pressureIds,\n    breakdownsByTick,\n  } = useMemo(() => transformPressureData(pressureUpdates), [pressureUpdates]);\n\n  const eventData = useMemo(\n    () => transformEventData(templateApplications, actionApplications, systemActions, pressureData),\n    [templateApplications, actionApplications, systemActions, pressureData]\n  );\n\n  const eraBoundaries = useMemo(\n    () => extractEraBoundaries(pressureUpdates, epochStats, systemActions),\n    [pressureUpdates, epochStats, systemActions]\n  );\n\n  // Get selected event for detail panel (template, action, or system action)\n  const selectedEvent = useMemo(() => {\n    const eventId = selectedEventId || hoveredEventId;\n    if (!eventId) return null;\n\n    // Check templates first\n    const templateEvent = eventData.template.find((e) => e.uniqueId === eventId);\n    if (templateEvent) {\n      return { type: \"template\", data: templateEvent.data };\n    }\n\n    // Check action applications\n    const actionEvent = eventData.action.find((e) => e.uniqueId === eventId);\n    if (actionEvent) {\n      return { type: \"action\", data: actionEvent.data };\n    }\n\n    // Check system actions\n    const systemEvent = eventData.system.find((e) => e.uniqueId === eventId);\n    if (systemEvent) {\n      return {\n        type: \"system\",\n        data: systemEvent.data,\n        isEraTransition: systemEvent.isEraTransition,\n      };\n    }\n\n    return null;\n  }, [eventData, selectedEventId, hoveredEventId]);\n\n  // Count era transitions for display\n  const eraTransitionCount = useMemo(\n    () => eventData.system.filter((e) => e.isEraTransition).length,\n    [eventData]\n  );\n\n  // Get max tick for slider (from pressure data or system actions)\n  const maxTick = useMemo(() => {\n    const pressureMax = pressureData.length > 0 ? Math.max(...pressureData.map((d) => d.tick)) : 0;\n    const systemMax = systemActions.length > 0 ? Math.max(...systemActions.map((a) => a.tick)) : 0;\n    return Math.max(pressureMax, systemMax, 1);\n  }, [pressureData, systemActions]);\n\n  // Get available ticks with visualization data for the active system\n  const availableVisTicks = useMemo(() => {\n    if (systemPanel === \"plane-diffusion\" && activeDiffusionId) {\n      return [\n        ...new Set(\n          systemActions\n            .filter((a) => a.systemId === activeDiffusionId && a.details?.diffusionSnapshot)\n            .map((a) => a.tick)\n        ),\n      ].sort((a, b) => a - b);\n    }\n    if (systemPanel === \"graph-contagion\" && activeContagionId) {\n      return [\n        ...new Set(\n          systemActions\n            .filter((a) => a.systemId === activeContagionId && a.details?.contagionSnapshot)\n            .map((a) => a.tick)\n        ),\n      ].sort((a, b) => a - b);\n    }\n    return [];\n  }, [systemPanel, activeDiffusionId, activeContagionId, systemActions]);\n\n  // Initialize lockedTick to maxTick when opening a visualization panel\n  // This ensures slider position matches displayed data\n  React.useEffect(() => {\n    if (\n      (systemPanel === \"plane-diffusion\" || systemPanel === \"graph-contagion\") &&\n      lockedTick === null\n    ) {\n      setLockedTick(maxTick);\n    }\n  }, [systemPanel, maxTick, lockedTick]);\n\n  // Handlers\n  const handleTickHover = useCallback((tick) => {\n    setSelectedTick(tick);\n  }, []);\n\n  const handleTickClick = useCallback(\n    (tick) => {\n      if (lockedTick === tick) {\n        setLockedTick(null);\n      } else {\n        setLockedTick(tick);\n        setSelectedTick(tick);\n      }\n    },\n    [lockedTick]\n  );\n\n  const handleEventHover = useCallback(\n    (eventId) => {\n      if (!selectedEventId) {\n        setHoveredEventId(eventId);\n      }\n    },\n    [selectedEventId]\n  );\n\n  const handleEventClick = useCallback(\n    (eventId) => {\n      if (selectedEventId === eventId) {\n        setSelectedEventId(null);\n      } else {\n        setSelectedEventId(eventId);\n      }\n    },\n    [selectedEventId]\n  );\n\n  const handleUnlock = useCallback(() => {\n    setLockedTick(null);\n  }, []);\n\n  const handleClearEvent = useCallback(() => {\n    setSelectedEventId(null);\n    setHoveredEventId(null);\n  }, []);\n\n  const togglePressure = useCallback((id) => {\n    setHiddenPressures((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) next.delete(id);\n      else next.add(id);\n      return next;\n    });\n  }, []);\n\n  return (\n    <div className=\"lw-trace-view-overlay\">\n      <div className=\"lw-trace-view\">\n        {/* Header */}\n        <div className=\"lw-trace-view-header\">\n          <div className=\"lw-trace-view-title\">\n            Simulation Trace\n            <span className=\"lw-trace-view-subtitle\">\n              {pressureData.length} ticks / {pressureIds.length} pressures /{\" \"}\n              {eventData.template.length} templates / {eventData.action.length} actions /{\" \"}\n              {eraTransitionCount} era transitions\n            </span>\n          </div>\n          <div className=\"lw-trace-view-header-actions\">\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"activity\" ? \"active\" : \"\"}`}\n              onClick={() => setSystemPanel(systemPanel === \"activity\" ? null : \"activity\")}\n            >\n              Activity\n            </button>\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"plane-diffusion\" ? \"active\" : \"\"} ${diffusionSystemsWithData.length > 0 ? \"has-data\" : \"\"}`}\n              onClick={() =>\n                setSystemPanel(systemPanel === \"plane-diffusion\" ? null : \"plane-diffusion\")\n              }\n              title={\n                diffusionSystemsWithData.length > 0\n                  ? `${diffusionSystemsWithData.length} system(s): ${diffusionSystemsWithData.map((s) => s.name).join(\", \")}`\n                  : \"No diffusion systems ran\"\n              }\n            >\n              Diffusion\n              {diffusionSystemsWithData.length > 0 && ` (${diffusionSystemsWithData.length})`}\n            </button>\n            <button\n              className={`lw-trace-view-panel-toggle ${systemPanel === \"graph-contagion\" ? \"active\" : \"\"} ${contagionSystemsWithData.length > 0 ? \"has-data\" : \"\"}`}\n              onClick={() =>\n                setSystemPanel(systemPanel === \"graph-contagion\" ? null : \"graph-contagion\")\n              }\n              title={\n                contagionSystemsWithData.length > 0\n                  ? `${contagionSystemsWithData.length} system(s): ${contagionSystemsWithData.map((s) => s.name).join(\", \")}`\n                  : \"No contagion systems ran\"\n              }\n            >\n              Contagion\n              {contagionSystemsWithData.length > 0 && ` (${contagionSystemsWithData.length})`}\n            </button>\n            <button className=\"lw-trace-view-close\" onClick={onClose}>\n              x\n            </button>\n          </div>\n        </div>\n\n        {/* Main content */}\n        <div className=\"lw-trace-view-content\">\n          {/* Left: Charts */}\n          <div className=\"lw-trace-view-charts\">\n            {/* Pressure toggles */}\n            <div className=\"lw-trace-view-toggles\">\n              {pressureIds.map((id, i) => {\n                const name = pressureData[0]?.[`${id}_name`] || id;\n                const isHidden = hiddenPressures.has(id);\n                return (\n                  <button\n                    key={id}\n                    className={`lw-trace-view-toggle ${isHidden ? \"hidden\" : \"\"}`}\n                    style={{\n                      '--st-toggle-border': PRESSURE_COLORS[i % PRESSURE_COLORS.length],\n                      '--st-toggle-bg': isHidden\n                        ? \"transparent\"\n                        : PRESSURE_COLORS[i % PRESSURE_COLORS.length] + \"20\",\n                    }}\n                    onClick={() => togglePressure(id)}\n                  >\n                    {name}\n                  </button>\n                );\n              })}\n            </div>\n\n            {/* Chart area */}\n            <div className={`lw-trace-view-chart-area ${lockedTick !== null ? \"locked\" : \"\"}`}>\n// ... (truncated)", "parameters": [{"name": "{\n  pressureUpdates = [],\n  epochStats = [],\n  templateApplications = [],\n  actionApplications = [],\n  systemActions = [],\n  onClose,\n}", "type": "{ pressureUpdates?: any[]; epochStats?: any[]; templateApplications?: any[]; actionApplications?: any[]; systemActions?: any[]; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/lore-weave/webui/src/components/dashboard/trace/TraceTooltip.jsx::default", "name": "default", "kind": "function", "filePath": "apps/lore-weave/webui/src/components/dashboard/trace/TraceTooltip.jsx", "sourceCode": "/**\n * Simple tooltip component\n */\nexport default function TraceTooltip({ tooltipData, tooltipLeft, tooltipTop, tooltipOpen }) {\n  if (!tooltipOpen || !tooltipData) return null;\n\n  return (\n    <TooltipWithBounds left={tooltipLeft} top={tooltipTop} className=\"tt-tooltip\">\n      {tooltipData.type === \"tick\" && (\n        <div>\n          <div className=\"tt-tick-header\">Tick {tooltipData.tick}</div>\n          {tooltipData.pressures?.map((p, i) => (\n            <div key={i} className=\"tt-pressure-row\">\n              <span className=\"tt-pressure-name\" style={{ '--tt-pressure-color': p.color }}>{p.name}</span>\n              <span>{p.value?.toFixed(1)}</span>\n            </div>\n          ))}\n        </div>\n      )}\n      {tooltipData.type === \"event\" && (\n        <div>\n          <div className=\"tt-event-header\">\n            {tooltipData.eventType === \"template\" && \"\u25b2 \"}\n            {tooltipData.eventType === \"system\" && \"\u25c6 \"}\n            {tooltipData.eventType === \"action\" && \"\u25cf \"}\n            {tooltipData.label}\n          </div>\n          <div className=\"tt-event-tick\">Tick {tooltipData.tick}</div>\n        </div>\n      )}\n    </TooltipWithBounds>\n  );\n}", "parameters": [{"name": "{ tooltipData, tooltipLeft, tooltipTop, tooltipOpen }", "type": "{ tooltipData: any; tooltipLeft: any; tooltipTop: any; tooltipOpen: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}]