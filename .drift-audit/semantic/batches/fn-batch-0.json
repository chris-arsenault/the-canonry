[{"id": "packages/world-store/src/index.ts::getSlotRecord", "name": "getSlotRecord", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getSlotRecord(\n  projectId: string,\n  slotIndex: number,\n): Promise<SimulationSlotRecord | null> {\n  const db = await openDb();\n  const record = await getRecord<SimulationSlotRecord>(db, SLOTS_STORE, [projectId, slotIndex]);\n  db.close();\n  return record;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<SimulationSlotRecord | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getWorldSchema", "name": "getWorldSchema", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getWorldSchema(projectId: string): Promise<CanonrySchemaSlice | null> {\n  const db = await openDb();\n  const record = await getRecord<WorldSchemaRecord>(db, SCHEMAS_STORE, projectId);\n  db.close();\n  return record?.schema ?? null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<CanonrySchemaSlice | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getCoordinateState", "name": "getCoordinateState", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getCoordinateState(simulationRunId: string): Promise<CoordinateState | null> {\n  const db = await openDb();\n  const record = await getRecord<CoordinateStateRecord>(db, COORDINATE_STORE, simulationRunId);\n  db.close();\n  return record?.coordinateState ?? null;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CoordinateState | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getEntities", "name": "getEntities", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getEntities(simulationRunId: string): Promise<WorldEntity[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<WorldEntity & { simulationRunId?: string }>(\n    db,\n    ENTITIES_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as WorldEntity[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<WorldEntity[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getRelationships", "name": "getRelationships", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getRelationships(simulationRunId: string): Promise<WorldRelationship[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<WorldRelationship & { simulationRunId?: string }>(\n    db,\n    RELATIONSHIPS_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as WorldRelationship[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<WorldRelationship[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getNarrativeEvents", "name": "getNarrativeEvents", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getNarrativeEvents(simulationRunId: string): Promise<NarrativeEvent[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<NarrativeEvent & { simulationRunId?: string }>(\n    db,\n    EVENTS_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records.map(stripSimulationRunId) as NarrativeEvent[];\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<NarrativeEvent[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getChronicles", "name": "getChronicles", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getChronicles(simulationRunId: string): Promise<ChronicleRecord[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<ChronicleRecord>(\n    db,\n    CHRONICLES_STORE,\n    'simulationRunId',\n    simulationRunId,\n  );\n  db.close();\n  return records;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::getStaticPages", "name": "getStaticPages", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function getStaticPages(projectId: string): Promise<StaticPageRecord[]> {\n  const db = await openDb();\n  const records = await getAllByIndex<StaticPageRecord>(\n    db,\n    STATIC_PAGES_STORE,\n    'projectId',\n    projectId,\n  );\n  db.close();\n  return records;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPageRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "packages/world-store/src/index.ts::buildWorldStateForSlot", "name": "buildWorldStateForSlot", "kind": "function", "filePath": "packages/world-store/src/index.ts", "sourceCode": "export async function buildWorldStateForSlot(\n  projectId: string,\n  slotIndex: number,\n): Promise<WorldOutput | null> {\n  const slot = await getSlotRecord(projectId, slotIndex);\n  if (!slot?.simulationRunId) return null;\n\n  const [schema, entities, relationships, narrativeHistory, coordinateState] = await Promise.all([\n    getWorldSchema(projectId),\n    getEntities(slot.simulationRunId),\n    getRelationships(slot.simulationRunId),\n    getNarrativeEvents(slot.simulationRunId),\n    getCoordinateState(slot.simulationRunId),\n  ]);\n\n  const eraName = resolveEraName(entities, slot.finalEraId);\n\n  return {\n    schema: schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    metadata: {\n      simulationRunId: slot.simulationRunId,\n      tick: typeof slot.finalTick === 'number' ? slot.finalTick : 0,\n      epoch: 0,\n      era: eraName,\n      entityCount: entities.length,\n      relationshipCount: relationships.length,\n    },\n    hardState: entities,\n    relationships,\n    pressures: {},\n    narrativeHistory: narrativeHistory.length > 0 ? narrativeHistory : undefined,\n    coordinateState: coordinateState || undefined,\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<WorldOutput | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["CanonrySchemaSlice", "CoordinateState", "NarrativeEvent", "WorldEntity", "WorldRelationship", "WorldOutput"], "category": "external"}]}, {"id": "apps/archivist/webui/src/ArchivistRemote.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/ArchivistRemote.tsx", "sourceCode": "export default function ArchivistRemote({\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n}: Readonly<ArchivistRemoteProps>) {\n  const [worldDataState, setWorldDataState] = useState<WorldState | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [loadError, setLoadError] = useState<string | null>(null);\n\n  const effectiveWorldData = projectId ? worldDataState : null;\n  const effectiveLoading = projectId ? loading : false;\n  const effectiveLoadError = projectId ? loadError : null;\n  const schemaIssues = useMemo(\n    () => (effectiveWorldData ? validateWorldData(effectiveWorldData) : []),\n    [effectiveWorldData]\n  );\n\n  useEffect(() => {\n    if (!projectId) return;\n\n    let cancelled = false;\n    queueMicrotask(() => {\n      if (cancelled) return;\n      setLoading(true);\n      setLoadError(null);\n    });\n\n    buildWorldStateForSlot(projectId, activeSlotIndex)\n      .then((loaded) => {\n        if (cancelled) return;\n        setWorldDataState(loaded);\n      })\n      .catch((err: unknown) => {\n        if (cancelled) return;\n        console.error(\"[ArchivistRemote] Failed to load world data:\", err);\n        setWorldDataState(null);\n        setLoadError(err instanceof Error ? err.message : \"Failed to load world data from Dexie.\");\n      })\n      .finally(() => {\n        if (cancelled) return;\n        setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [activeSlotIndex, dexieSeededAt, projectId]);\n\n  if (effectiveLoading) {\n    return (\n      <div className=\"archivist-empty-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u23f3</div>\n          <div className=\"archivist-state-title\">Loading World Data</div>\n          <div className=\"archivist-state-message\">Reading from local storage\u2026</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (effectiveLoadError) {\n    return (\n      <div className=\"archivist-error-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u274c</div>\n          <div className=\"archivist-state-title\">World data unavailable</div>\n          <div className=\"archivist-state-message\">{effectiveLoadError}</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!effectiveWorldData) {\n    return (\n      <div className=\"archivist-empty-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\ud83d\udcdc</div>\n          <div className=\"archivist-state-title\">No World Data</div>\n          <div className=\"archivist-state-message\">\n            Run a simulation in Lore Weave and click &quot;View in Archivist&quot; to explore your world.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (schemaIssues.length > 0) {\n    return (\n      <div className=\"archivist-error-state\">\n        <div className=\"archivist-state-content\">\n          <div className=\"archivist-state-icon\">\u274c</div>\n          <div className=\"archivist-state-title\">World data is missing required schema fields</div>\n          <ul className=\"archivist-state-list\">\n            {schemaIssues.map((issue, index) => (\n              <li key={`${issue}-${index}`}>{issue}</li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    );\n  }\n\n  return <WorldExplorer worldData={effectiveWorldData} loreData={null} />;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n}", "type": "Readonly<ArchivistRemoteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useMemo", "useState"], "category": "framework"}, {"source": "./index.css", "specifiers": [], "category": "internal"}, {"source": "./components/WorldExplorer.tsx", "specifiers": ["WorldExplorer"], "category": "internal"}, {"source": "./types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "./utils/schemaValidation.ts", "specifiers": ["validateWorldData"], "category": "internal"}, {"source": "@the-canonry/world-store", "specifiers": ["buildWorldStateForSlot"], "category": "external"}]}, {"id": "apps/archivist/webui/src/components/ChainLinkSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/ChainLinkSection.tsx", "sourceCode": "export default function ChainLinkSection({ lore }: Readonly<ChainLinkSectionProps>) {\n  // Parse the text which is formatted as \"observation | clue\"\n  const parts = lore.text.split(\"|\").map((p) => p.trim());\n  const observation = parts[0] || \"\";\n  const clue = parts[1] || \"\";\n\n  return (\n    <div className=\"chain-link-section\">\n      <div className=\"chain-link-header\">\n        <span className=\"chain-link-icon\">\ud83d\udd0d</span>\n        <span className=\"chain-link-title\">Mystery Clue</span>\n      </div>\n\n      <div className=\"chain-link-flow\">\n        <span className=\"chain-link-location\">{lore.metadata.sourceLocation}</span>\n        <span className=\"chain-link-arrow\">\u2192</span>\n        <span className=\"chain-link-location\">{lore.targetId}</span>\n      </div>\n\n      <div className=\"chain-link-theme\">\n        <span className=\"chain-link-theme-label\">Theme:</span>\n        <span className=\"chain-link-theme-badge\">\n          {lore.metadata.revealedTheme.replace(/_/g, \" \")}\n        </span>\n      </div>\n\n      <div className=\"chain-link-content\">\n        <div className=\"chain-link-observation\">\n          <div className=\"chain-link-section-label\">Observation</div>\n          <div className=\"chain-link-text\">{observation}</div>\n        </div>\n        <div className=\"chain-link-clue\">\n          <div className=\"chain-link-section-label\">Clue</div>\n          <div className=\"chain-link-text\">{clue}</div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore }", "type": "Readonly<ChainLinkSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["ChainLinkLore"], "category": "internal"}, {"source": "./ChainLinkSection.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/archivist/webui/src/components/CoordinateMapView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/CoordinateMapView.tsx", "sourceCode": "export default function CoordinateMapView({\n  data,\n  selectedNodeId,\n  onNodeSelect\n}: Readonly<CoordinateMapViewProps>) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({\n    width: 800,\n    height: 600\n  });\n  const [mapKind, setMapKind] = useState<string>(() => {\n    const firstKind = data.schema.entityKinds.find(kind => kind.semanticPlane)?.kind;\n    return firstKind ?? \"\";\n  }); // Which entity kind's map to show\n  const [showRelatedKinds, setShowRelatedKinds] = useState<boolean>(true); // Show related entities from other kinds\n  const [visibleLayers, setVisibleLayers] = useState<Set<string>>(new Set([\"regions\", \"entities\", \"relationships\"]));\n  const [hoveredEntity, setHoveredEntity] = useState<HardState | null>(null);\n  const [hoveredRegion, setHoveredRegion] = useState<Region | null>(null);\n  const [mousePos, setMousePos] = useState<{\n    x: number;\n    y: number;\n  } | null>(null);\n\n  // Get entity kind schemas\n  const entityKindSchemas = data.schema.entityKinds;\n  const kindDisplayNames = useMemo(() => {\n    return new Map(entityKindSchemas.map(kind => [kind.kind, getKindDisplayName(kind)]));\n  }, [entityKindSchemas]);\n  const axisDefinitions = useMemo(() => data.schema.axisDefinitions || [], [data.schema.axisDefinitions]);\n  const axisById = useMemo(() => {\n    return new Map(axisDefinitions.map(axis => [axis.id, axis]));\n  }, [axisDefinitions]);\n  const mappableKindSchemas = useMemo(() => entityKindSchemas.filter(kind => kind.semanticPlane), [entityKindSchemas]);\n  const mappableKinds = mappableKindSchemas.map(kind => kind.kind);\n\n  // Derive effective map kind: if current selection is invalid, fall back to first available\n  const effectiveMapKind = mappableKinds.includes(mapKind) ? mapKind : mappableKinds[0] ?? mapKind;\n\n  // Get per-kind map config and regions (seed + emergent)\n  const activeKindDef = mappableKindSchemas.find(kind => kind.kind === effectiveMapKind);\n  if (!activeKindDef || !activeKindDef.semanticPlane) {\n    throw new Error(\"Archivist: map view requires a semantic plane on the selected entity kind.\");\n  }\n  const displayName = getKindDisplayName(activeKindDef);\n  const planeAxes = activeKindDef.semanticPlane.axes;\n  const xAxis = planeAxes?.x?.axisId ? axisById.get(planeAxes.x.axisId) : undefined;\n  const yAxis = planeAxes?.y?.axisId ? axisById.get(planeAxes.y.axisId) : undefined;\n  if (planeAxes?.x?.axisId && !xAxis) {\n    throw new Error(`Archivist: axis \"${planeAxes.x.axisId}\" not found in schema.axisDefinitions.`);\n  }\n  if (planeAxes?.y?.axisId && !yAxis) {\n    throw new Error(`Archivist: axis \"${planeAxes.y.axisId}\" not found in schema.axisDefinitions.`);\n  }\n  const mapDescription = `Coordinate space for ${displayName} entities`;\n  const seedRegions = activeKindDef.semanticPlane.regions ?? [];\n  const emergentRegions = data.coordinateState?.emergentRegions?.[effectiveMapKind] ?? [];\n  const regions = mergeRegions(seedRegions, emergentRegions);\n  const bounds = {\n    min: 0,\n    max: 100\n  };\n\n  // Filter entities for the current map - primary kind always shown, related kinds optionally\n  const mapEntities = useMemo(() => {\n    const primaryEntities = data.hardState.filter(e => e.kind === effectiveMapKind);\n    if (!showRelatedKinds) {\n      return primaryEntities;\n    }\n\n    // Find entities related to primary entities\n    const primaryIds = new Set(primaryEntities.map(e => e.id));\n    const relatedIds = new Set<string>();\n    data.relationships.forEach(rel => {\n      if (primaryIds.has(rel.src)) relatedIds.add(rel.dst);\n      if (primaryIds.has(rel.dst)) relatedIds.add(rel.src);\n    });\n    const relatedEntities = data.hardState.filter(e => relatedIds.has(e.id) && !primaryIds.has(e.id));\n    return [...primaryEntities, ...relatedEntities];\n  }, [data.hardState, data.relationships, effectiveMapKind, showRelatedKinds]);\n\n  // Build entity color map\n  const entityColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    entityKindSchemas.forEach(ek => {\n      if (!ek.style?.color) {\n        throw new Error(`Archivist: entity kind \"${ek.kind}\" is missing style.color.`);\n      }\n      map.set(ek.kind, ek.style.color);\n    });\n    return map;\n  }, [entityKindSchemas]);\n\n  // Calculate entity positions with force layout\n  const entityPositions = useMemo(() => {\n    const nodes: LayoutNode[] = [];\n\n    // All entities get coordinates\n    mapEntities.forEach(entity => {\n      const coords = getEntityCoords(entity);\n      nodes.push({\n        id: entity.id,\n        x: coords.x,\n        y: coords.y,\n        vx: 0,\n        vy: 0,\n        // Only anchor primary kind entities\n        anchored: entity.kind === effectiveMapKind,\n        entity\n      });\n    });\n\n    // Run force layout - only include relationships between visible entities\n    const visibleIds = new Set(mapEntities.map(e => e.id));\n    const relationships = data.relationships.filter(r => visibleIds.has(r.src) && visibleIds.has(r.dst)).map(r => ({\n      src: r.src,\n      dst: r.dst,\n      strength: r.strength\n    }));\n    runForceLayout(nodes, relationships);\n    return new Map(nodes.map(n => [n.id, {\n      x: n.x,\n      y: n.y,\n      anchored: n.anchored\n    }]));\n  }, [mapEntities, data.relationships, effectiveMapKind]);\n\n  // Use uniform scale to preserve aspect ratio (circles stay circular)\n  const padding = 40;\n  const worldRange = bounds.max - bounds.min || 1; // Prevent division by zero\n  const availableWidth = Math.max(1, dimensions.width - padding * 2);\n  const availableHeight = Math.max(1, dimensions.height - padding * 2);\n  // Use the smaller scale so everything fits\n  const uniformScale = Math.max(0.001, Math.min(availableWidth, availableHeight) / worldRange);\n  // Center the content in the larger dimension\n  const offsetX = padding + (availableWidth - worldRange * uniformScale) / 2;\n  const offsetY = padding + (availableHeight - worldRange * uniformScale) / 2;\n\n  // Convert world coordinates to canvas coordinates\n  const worldToCanvas = (x: number, y: number): {\n    x: number;\n    y: number;\n  } => {\n    return {\n      x: offsetX + (x - bounds.min) * uniformScale,\n      y: dimensions.height - offsetY - (y - bounds.min) * uniformScale // Flip Y for canvas\n    };\n  };\n\n  // Convert canvas coordinates to world coordinates\n  const canvasToWorld = (canvasX: number, canvasY: number): {\n    x: number;\n    y: number;\n  } => {\n    return {\n      x: bounds.min + (canvasX - offsetX) / uniformScale,\n      y: bounds.min + (dimensions.height - offsetY - canvasY) / uniformScale\n    };\n  };\n\n  // Convert world distance to canvas pixels (for radius calculations)\n  const worldToCanvasDistance = (worldDistance: number): number => {\n    return worldDistance * uniformScale;\n  };\n\n  // Handle resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        setDimensions({\n          width: containerRef.current.clientWidth,\n          height: containerRef.current.clientHeight\n        });\n      }\n    };\n    updateDimensions();\n    window.addEventListener(\"resize\", updateDimensions);\n    return () => window.removeEventListener(\"resize\", updateDimensions);\n  }, []);\n\n  // Draw the map\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.fillStyle = \"#0a1929\";\n    ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n\n    // Draw grid\n    ctx.strokeStyle = \"rgba(59, 130, 246, 0.1)\";\n    ctx.lineWidth = 1;\n    const gridStep = 10;\n    for (let i = bounds.min; i <= bounds.max; i += gridStep) {\n      const start = worldToCanvas(i, bounds.min);\n      const end = worldToCanvas(i, bounds.max);\n      ctx.beginPath();\n      ctx.moveTo(start.x, start.y);\n      ctx.lineTo(end.x, end.y);\n      ctx.stroke();\n      const hStart = worldToCanvas(bounds.min, i);\n      const hEnd = worldToCanvas(bounds.max, i);\n      ctx.beginPath();\n      ctx.moveTo(hStart.x, hStart.y);\n      ctx.lineTo(hEnd.x, hEnd.y);\n      ctx.stroke();\n    }\n\n    // Draw axis labels - semantic tags at ends, numeric in middle\n    // Draw semantic axis labels at ends\n    ctx.font = \"bold 11px sans-serif\";\n    ctx.textAlign = \"center\";\n\n    // X-axis labels (low on left, high on right)\n    if (xAxis) {\n      // Low tag (left side)\n      ctx.fillStyle = \"rgba(252, 107, 107, 0.8)\"; // Reddish for low\n      const xLowPos = worldToCanvas(bounds.min + 5, bounds.min);\n      ctx.fillText(`\u2190 ${xAxis.lowTag}`, xLowPos.x + 30, xLowPos.y + 25);\n\n      // Axis name (center bottom)\n      ctx.fillStyle = \"rgba(255, 255, 255, 0.6)\";\n      const xCenterPos = worldToCanvas((bounds.min + bounds.max) / 2, bounds.min);\n      ctx.fillText(xAxis.name, xCenterPos.x, xCenterPos.y + 25);\n\n      // High tag (right side)\n      ctx.fillStyle = \"rgba(107, 252, 156, 0.8)\"; // Greenish for high\n      const xHighPos = worldToCanvas(bounds.max - 5, bounds.min);\n      ctx.fillText(`${xAxis.highTag} \u2192`, xHighPos.x - 30, xHighPos.y + 25);\n    }\n\n    // Y-axis labels (low on bottom, high on top)\n    if (yAxis) {\n      ctx.save();\n\n      // Low tag (bottom)\n      ctx.fillStyle = \"rgba(252, 107, 107, 0.8)\";\n      const yLowPos = worldToCanvas(bounds.min, bounds.min + 5);\n      ctx.translate(yLowPos.x - 25, yLowPos.y - 20);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(`\u2190 ${yAxis.lowTag}`, 0, 0);\n      ctx.restore();\n\n      // Axis name (center left)\n      ctx.save();\n      ctx.fillStyle = \"rgba(255, 255, 255, 0.6)\";\n      const yCenterPos = worldToCanvas(bounds.min, (bounds.min + bounds.max) / 2);\n      ctx.translate(yCenterPos.x - 25, yCenterPos.y);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(yAxis.name, 0, 0);\n      ctx.restore();\n\n      // High tag (top)\n      ctx.save();\n      ctx.fillStyle = \"rgba(107, 252, 156, 0.8)\";\n      const yHighPos = worldToCanvas(bounds.min, bounds.max - 5);\n      ctx.translate(yHighPos.x - 25, yHighPos.y + 20);\n      ctx.rotate(-Math.PI / 2);\n      ctx.fillText(`${yAxis.highTag} \u2192`, 0, 0);\n      ctx.restore();\n    }\n\n    // Draw small numeric labels for reference\n    ctx.fillStyle = \"rgba(59, 130, 246, 0.3)\";\n    ctx.font = \"9px monospace\";\n    ctx.textAlign = \"center\";\n    for (let i = bounds.min + 20; i < bounds.max; i += 20) {\n      const pos = worldToCanvas(i, bounds.min);\n      ctx.fillText(i.toString(), pos.x, pos.y + 12);\n      ctx.textAlign = \"right\";\n      const posY = worldToCanvas(bounds.min, i);\n      ctx.fillText(i.toString(), posY.x - 5, posY.y + 3);\n      ctx.textAlign = \"center\";\n    }\n\n    // Parse selectedNodeId to check if a region is selected\n    const selectedRegionId = selectedNodeId?.startsWith(\"region:\") ? selectedNodeId.split(\":\")[2] : null;\n\n    // Draw regions if layer is visible\n    if (visibleLayers.has(\"regions\")) {\n      regions.forEach(region => {\n        drawRegion(ctx, region, hoveredRegion, selectedRegionId, worldToCanvas, worldToCanvasDistance);\n      });\n    }\n\n    // Draw relationships if layer is visible\n    if (visibleLayers.has(\"relationships\")) {\n      ctx.strokeStyle = \"rgba(255, 255, 255, 0.15)\";\n      ctx.lineWidth = 1;\n      data.relationships.forEach(rel => {\n        const srcPos = entityPositions.get(rel.src);\n        const dstPos = entityPositions.get(rel.dst);\n        if (!srcPos || !dstPos) return;\n        const start = worldToCanvas(srcPos.x, srcPos.y);\n        const end = worldToCanvas(dstPos.x, dstPos.y);\n        ctx.globalAlpha = (rel.strength ?? 0.5) * 0.5;\n        ctx.beginPath();\n        ctx.moveTo(start.x, start.y);\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect\n}", "type": "Readonly<CoordinateMapViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useRef", "useState", "useMemo"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState", "HardState", "Point", "Region"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["EntityKindDefinition"], "category": "external"}, {"source": "./CoordinateMapView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/DiscoveryStory.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/DiscoveryStory.tsx", "sourceCode": "export default function DiscoveryStory({\n  lore,\n  onExplorerClick,\n  onClose,\n  isModal = false,\n}: Readonly<DiscoveryStoryProps>) {\n  const [expandedSection, setExpandedSection] = useState<\"discovery\" | \"significance\" | null>(\n    \"discovery\"\n  );\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose?.();\n    }\n  };\n\n  const toggleSection = (section: \"discovery\" | \"significance\") => {\n    setExpandedSection(expandedSection === section ? null : section);\n  };\n\n  // Check if explorer is an entity ID (starts with known prefixes)\n  const isEntityId = lore.metadata.explorer.match(/^(npc_|faction_|location_)/);\n\n  const content = (\n    <div className={`discovery-story ${isModal ? \"discovery-story-modal-content\" : \"\"}`}>\n      <div className=\"discovery-story-header\">\n        <span className=\"discovery-story-icon\">\ud83e\udded</span>\n        <span className=\"discovery-story-title\">Discovery Story</span>\n      </div>\n\n      <div className=\"discovery-story-meta\">\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">Discovered by:</span>\n          {isEntityId && onExplorerClick ? (\n            <button\n              onClick={() => onExplorerClick(lore.metadata.explorer)}\n              className=\"discovery-story-explorer-link\"\n            >\n              {lore.metadata.explorer}\n            </button>\n          ) : (\n            <span className=\"discovery-story-meta-value\">{lore.metadata.explorer}</span>\n          )}\n        </div>\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">When:</span>\n          <span className=\"discovery-story-meta-value\">Tick {lore.metadata.tick}</span>\n        </div>\n        <div className=\"discovery-story-meta-row\">\n          <span className=\"discovery-story-meta-label\">Method:</span>\n          <span\n            className={`discovery-story-type-badge discovery-story-type-${lore.metadata.discoveryType}`}\n          >\n            {lore.metadata.discoveryType}\n          </span>\n        </div>\n      </div>\n\n      {/* The Discovery */}\n      <div className=\"discovery-story-section\">\n        <button\n          onClick={() => toggleSection(\"discovery\")}\n          className=\"discovery-story-section-header\"\n        >\n          <span className=\"discovery-story-section-icon\">\n            {expandedSection === \"discovery\" ? \"\u25bc\" : \"\u25b6\"}\n          </span>\n          <span className=\"discovery-story-section-title\">The Discovery</span>\n        </button>\n        {expandedSection === \"discovery\" && (\n          <div className=\"discovery-story-section-content\">{lore.text}</div>\n        )}\n      </div>\n\n      {/* Why It Matters */}\n      <div className=\"discovery-story-section\">\n        <button\n          onClick={() => toggleSection(\"significance\")}\n          className=\"discovery-story-section-header\"\n        >\n          <span className=\"discovery-story-section-icon\">\n            {expandedSection === \"significance\" ? \"\u25bc\" : \"\u25b6\"}\n          </span>\n          <span className=\"discovery-story-section-title\">Why It Matters</span>\n        </button>\n        {expandedSection === \"significance\" && (\n          <div className=\"discovery-story-section-content\">{lore.metadata.significance}</div>\n        )}\n      </div>\n\n      {/* Close button for modal mode */}\n      {isModal && onClose && (\n        <div className=\"discovery-story-footer\">\n          <button onClick={onClose} className=\"discovery-story-close\">\n            Close\n          </button>\n        </div>\n      )}\n    </div>\n  );\n\n  // Wrap in modal overlay if in modal mode\n  if (isModal && onClose) {\n    return (\n      <div\n        className=\"discovery-story-overlay\"\n        onMouseDown={handleOverlayMouseDown}\n        onClick={handleOverlayClick}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n      >\n        <div>{content}</div>\n      </div>\n    );\n  }\n\n  return content;\n}", "parameters": [{"name": "{\n  lore,\n  onExplorerClick,\n  onClose,\n  isModal = false,\n}", "type": "Readonly<DiscoveryStoryProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["DiscoveryEventLore"], "category": "internal"}, {"source": "./DiscoveryStory.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/EntityDetail.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/EntityDetail.tsx", "sourceCode": "export default function EntityDetail({\n  entityId,\n  worldData,\n  loreData,\n  onRelatedClick,\n  prominenceScale,\n}: Readonly<EntityDetailProps>) {\n  // Hooks must be called before any early returns\n  const [selectedRelationshipLore, setSelectedRelationshipLore] =\n    useState<RelationshipBackstoryLore | null>(null);\n  const clearRelationshipLore = useCallback(() => setSelectedRelationshipLore(null), []);\n  const [expandedOutgoing, setExpandedOutgoing] = useState<Set<string>>(new Set());\n  const [expandedIncoming, setExpandedIncoming] = useState<Set<string>>(new Set());\n\n  // Look up entity to get imageId for the hook (must be before early returns)\n  const selection = entityId ? parseSelectionId(entityId) : null;\n  const entityForImage =\n    selection?.type === \"entity\" ? getEntityById(worldData, selection.id) : null;\n  const imageId = entityForImage?.enrichment?.image?.imageId;\n  const { url: imageUrl } = useImageUrl(imageId);\n\n  if (!entityId) {\n    return (\n      <div className=\"entity-detail empty\">\n        <div className=\"text-center\">\n          <div\n            className=\"text-5xl mb-4 ed-empty-icon\"\n          >\n            \ud83d\udc48\n          </div>\n          <div className=\"text-blue-300 font-medium\">Select a node to view details</div>\n        </div>\n      </div>\n    );\n  }\n\n  // selection is guaranteed non-null here because entityId is truthy\n  const sel = selection!;\n\n  if (sel.type === \"region\") {\n    const region = findRegion(worldData, sel.entityKind, sel.regionId);\n    if (!region) {\n      return (\n        <div className=\"entity-detail\">\n          <div className=\"text-red-400 font-medium\">Region not found</div>\n        </div>\n      );\n    }\n    return <RegionDetail region={region} entityKind={sel.entityKind} worldData={worldData} />;\n  }\n\n  const entity = getEntityById(worldData, sel.id);\n\n  if (!entity) {\n    return (\n      <div className=\"entity-detail\">\n        <div className=\"text-red-400 font-medium\">Entity not found</div>\n      </div>\n    );\n  }\n\n  const prominenceLabel = prominenceLabelFromScale(entity.prominence, prominenceScale);\n\n  const relatedEntities = getRelatedEntities(worldData, entityId);\n  const relationships = getRelationships(worldData, entityId);\n\n  // Look up culture info\n  const entityCulture = entity.culture\n    ? worldData.schema.cultures.find((c) => c.id === entity.culture)\n    : undefined;\n\n  // Find lore for this entity\n  const descriptionLore = loreData?.records.find(\n    (record) => record.type === \"description\" && record.targetId === entityId\n  ) as DescriptionLore | undefined;\n\n  const chainLinkLore = loreData?.records.find(\n    (record) => record.type === \"chain_link\" && record.targetId === entityId\n  ) as ChainLinkLore | undefined;\n\n  const discoveryEventLore = loreData?.records.find(\n    (record) => record.type === \"discovery_event\" && record.targetId === entityId\n  ) as DiscoveryEventLore | undefined;\n\n  // Image URL loaded via useImageUrl hook (called above, before early returns)\n\n  // Helper to find relationship lore\n  const findRelationshipLore = (\n    srcId: string,\n    dstId: string,\n    kind: string\n  ): RelationshipBackstoryLore | undefined => {\n    return loreData?.records.find((record) => {\n      if (record.type !== \"relationship_backstory\") return false;\n      const relLore = record;\n      return (\n        relLore.relationship.src === srcId &&\n        relLore.relationship.dst === dstId &&\n        relLore.relationship.kind === kind\n      );\n    }) as RelationshipBackstoryLore | undefined;\n  };\n\n  const outgoingRels = relationships.filter((r) => r.src === entityId);\n  const incomingRels = relationships.filter((r) => r.dst === entityId);\n\n  // Debug: Check if distance is present\n  const relsWithDistance = relationships.filter((r) => r.distance !== undefined);\n  if (relsWithDistance.length > 0) {\n    console.log(\n      `Entity ${entityId} has ${relsWithDistance.length} relationships with distance:`,\n      relsWithDistance[0]\n    );\n  }\n\n  const getRelatedEntity = (relId: string) => getEntityById(worldData, relId);\n\n  // Group relationships by kind\n  const groupByKind = (rels: typeof relationships) => {\n    const groups = new Map<string, typeof relationships>();\n    rels.forEach((rel) => {\n      const kind = rel.kind;\n      if (!groups.has(kind)) {\n        groups.set(kind, []);\n      }\n      groups.get(kind)!.push(rel);\n    });\n    return groups;\n  };\n\n  const outgoingGroups = groupByKind(outgoingRels);\n  const incomingGroups = groupByKind(incomingRels);\n\n  const toggleOutgoing = (kind: string) => {\n    const newExpanded = new Set(expandedOutgoing);\n    if (newExpanded.has(kind)) {\n      newExpanded.delete(kind);\n    } else {\n      newExpanded.add(kind);\n    }\n    setExpandedOutgoing(newExpanded);\n  };\n\n  const toggleIncoming = (kind: string) => {\n    const newExpanded = new Set(expandedIncoming);\n    if (newExpanded.has(kind)) {\n      newExpanded.delete(kind);\n    } else {\n      newExpanded.add(kind);\n    }\n    setExpandedIncoming(newExpanded);\n  };\n\n  return (\n    <div className=\"entity-detail\">\n      {/* Header */}\n      <div className=\"entity-detail-header\">\n        <h2 className=\"entity-detail-name\">{entity.name}</h2>\n        <div className=\"entity-detail-badges\">\n          <span className={`entity-badge prominence-${prominenceLabel}`}>{prominenceLabel}</span>\n          <span className=\"entity-badge entity-badge-kind\">{entity.kind}</span>\n          <span className=\"entity-badge entity-badge-subtype\">{entity.subtype}</span>\n          {entityCulture && (\n            <span\n              className=\"entity-badge entity-badge-culture ed-culture-badge\"\n              style={{ '--ed-culture-color': entityCulture.color } as React.CSSProperties}\n            >\n              {entityCulture.name}\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Entity Image */}\n      {imageUrl && (\n        <div className=\"mb-6\">\n          <div className=\"entity-image-container\">\n            <img src={imageUrl} alt={entity.name} className=\"entity-image\" loading=\"lazy\" />\n          </div>\n        </div>\n      )}\n\n      {/* Summary or Lore */}\n      {descriptionLore ? (\n        <LoreSection lore={descriptionLore} />\n      ) : (\n        <div className=\"detail-card\">\n          <div className=\"section-header\">\n            Summary\n            <button\n              onClick={() => {\n                window.dispatchEvent(\n                  new CustomEvent(\"canonry:navigate\", {\n                    detail: { tab: \"chronicler\", pageId: entity.id },\n                  })\n                );\n              }}\n              className=\"chronicler-link\"\n              title=\"View full article in Chronicler\"\n            >\n              (view in chronicler)\n            </button>\n          </div>\n          <p className=\"text-sm text-blue-100 leading-relaxed break-words detail-card-content\">\n            {entity.summary || \"No summary available\"}\n          </p>\n        </div>\n      )}\n\n      {/* Chain Link */}\n      {chainLinkLore && <ChainLinkSection lore={chainLinkLore} />}\n\n      {/* Discovery Story */}\n      {discoveryEventLore && (\n        <DiscoveryStory lore={discoveryEventLore} onExplorerClick={onRelatedClick} />\n      )}\n\n      {/* Status & Timeline */}\n      <div className=\"entity-meta-grid\">\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Status</span>\n          <span className=\"entity-meta-value\">{entity.status}</span>\n        </div>\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Created</span>\n          <span className=\"entity-meta-value\">Tick {entity.createdAt}</span>\n        </div>\n        <div className=\"entity-meta-item\">\n          <span className=\"entity-meta-label\">Updated</span>\n          <span className=\"entity-meta-value\">Tick {entity.updatedAt}</span>\n        </div>\n      </div>\n\n      {/* Tags */}\n      {getTagsArray(entity.tags).length > 0 && (\n        <div className=\"entity-tags-section\">\n          <div className=\"section-header\">Tags</div>\n          <div className=\"tags-container\">\n            {getTagsArray(entity.tags).map((tag) => (\n              <span key={tag} className=\"tag\">\n                {tag}\n              </span>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Outgoing Relationships */}\n      {outgoingRels.length > 0 && (\n        <div className=\"mb-6\">\n          <div className=\"section-header\">Relationships ({outgoingRels.length})</div>\n          <div className=\"accordion-container\">\n            {Array.from(outgoingGroups.entries()).map(([kind, rels]) => {\n              const isExpanded = expandedOutgoing.has(kind);\n              return (\n                <div key={kind} className=\"accordion-item\">\n                  <button onClick={() => toggleOutgoing(kind)} className=\"accordion-header\">\n                    <div className=\"accordion-header-left\">\n                      <span className=\"accordion-icon\">{isExpanded ? \"\u2212\" : \"+\"}</span>\n                      <span className=\"accordion-title\">{kind.replace(/_/g, \" \")}</span>\n                    </div>\n                    <span className=\"accordion-badge\">{rels.length}</span>\n                  </button>\n                  {isExpanded && (\n                    <div className=\"accordion-content\">\n                      {rels.map((rel, i) => {\n                        const target = getRelatedEntity(rel.dst);\n                        const relLore = findRelationshipLore(rel.src, rel.dst, rel.kind);\n                        const strength = rel.strength ?? 0.5;\n                        const distance = rel.distance;\n                        const isHistorical = rel.status === \"historical\";\n                        return target ? (\n                          <div\n                            key={i}\n                            className={`accordion-row ${i % 2 === 0 ? \"even\" : \"odd\"} ${isHistorical ? \"historical\" : \"\"}`}\n                          >\n                            <button\n                              onClick={() => onRelatedClick(target.id)}\n                              className={`accordion-row-button ${isHistorical ? \"ed-row-historical\" : \"\"}`}\n                            >\n                              <div className=\"accordion-row-name\">\n                                {isHistorical && (\n                                  <span className=\"ed-historical-icon\">\n                                    \ud83d\udcdc\n                                  </span>\n                                )}\n                                {target.name}\n                              </div>\n                              <div className=\"accordion-row-kind\">\n                                ({target.kind}){\" \"}\n                                <span\n                                  className={isHistorical ? \"ed-rel-metric-historical\" : \"ed-rel-metric\"}\n                                >\n                                  [S:{strength.toFixed(2)}\n                                  {distance !== undefined ? ` D:${distance.toFixed(2)}` : \"\"}]\n                                </span>\n                                {isHistorical && rel.archivedAt && (\n                                  <span className=\"ed-archived-label\">\n                                    archived @{rel.archivedAt}\n                                  </span>\n// ... (truncated)", "parameters": [{"name": "{\n  entityId,\n  worldData,\n  loreData,\n  onRelatedClick,\n  prominenceScale,\n}", "type": "Readonly<EntityDetailProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "DescriptionLore", "RelationshipBackstoryLore", "ChainLinkLore", "DiscoveryEventLore", "Region"], "category": "internal"}, {"source": "../utils/dataTransform.ts", "specifiers": ["getEntityById", "getRelatedEntities", "getRelationships", "getTagsArray"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "./LoreSection.tsx", "specifiers": ["LoreSection"], "category": "internal"}, {"source": "./RelationshipStoryModal.tsx", "specifiers": ["RelationshipStoryModal"], "category": "internal"}, {"source": "./ChainLinkSection.tsx", "specifiers": ["ChainLinkSection"], "category": "internal"}, {"source": "./DiscoveryStory.tsx", "specifiers": ["DiscoveryStory"], "category": "internal"}, {"source": "./EntityDetail.css", "specifiers": [], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/components/EraNarrative.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/EraNarrative.tsx", "sourceCode": "export default function EraNarrative({ lore, onClose }: Readonly<EraNarrativeProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n  // Extract title from the text (first sentence or before colon)\n  const titleMatch = lore.text.match(/^([^:.]+)[:.]/) || lore.text.match(/^(.{0,50})/);\n  const title = titleMatch ? titleMatch[1].trim() : \"Era Transition\";\n  const narrative = lore.text;\n\n  return (\n    <div\n      className=\"era-narrative-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"era-narrative-modal\">\n        <div className=\"era-narrative-header\">\n          <div className=\"era-narrative-icon\">\u2694\ufe0f</div>\n          <h2 className=\"era-narrative-title\">{title}</h2>\n          <div className=\"era-narrative-icon\">\u2694\ufe0f</div>\n        </div>\n\n        <div className=\"era-narrative-transition\">\n          <span className=\"era-narrative-era era-narrative-era-from\">{lore.metadata.from}</span>\n          <span className=\"era-narrative-arrow\">\u2192</span>\n          <span className=\"era-narrative-era era-narrative-era-to\">{lore.metadata.to}</span>\n        </div>\n\n        <div className=\"era-narrative-content\">{narrative}</div>\n\n        <div className=\"era-narrative-footer\">\n          <span className=\"era-narrative-tick\">Tick {lore.metadata.tick}</span>\n          <button onClick={onClose} className=\"era-narrative-close\">\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore, onClose }", "type": "Readonly<EraNarrativeProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useRef"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["EraNarrativeLore"], "category": "internal"}, {"source": "./EraNarrative.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/FilterPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/FilterPanel.tsx", "sourceCode": "export default function FilterPanel({\n  filters,\n  onChange,\n  worldData,\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}: Readonly<FilterPanelProps>) {\n  const allTags = getAllTags(worldData);\n  const relationshipTypeCounts = getRelationshipTypeCounts(worldData);\n  const maxTick = worldData.metadata.tick;\n\n  const allRelationshipTypes = worldData.schema.relationshipKinds.map((rel) => rel.kind);\n  // Sort relationship types by count (descending)\n  const sortedRelationshipTypes = [...allRelationshipTypes].sort((a, b) => {\n    return (relationshipTypeCounts[b] || 0) - (relationshipTypeCounts[a] || 0);\n  });\n\n  const [isRelTypesExpanded, setIsRelTypesExpanded] = useState(false);\n\n  const entityKindSchemas = worldData.schema.entityKinds;\n  const entityKinds: EntityKind[] = entityKindSchemas.map((ek) => ek.kind);\n\n  const prominenceLevels: Prominence[] = getProminenceLevels(worldData.schema);\n\n  // Build a map from kind to display name (from schema if available, otherwise use kind as-is)\n  const kindDisplayNames = Object.fromEntries(\n    entityKindSchemas.map((ek) => [ek.kind, ek.style?.displayName || ek.description || ek.kind])\n  );\n\n  const toggleKind = (kind: EntityKind) => {\n    const kinds = filters.kinds.includes(kind)\n      ? filters.kinds.filter((k) => k !== kind)\n      : [...filters.kinds, kind];\n    onChange({ ...filters, kinds });\n  };\n\n  const toggleTag = (tag: string) => {\n    const tags = filters.tags.includes(tag)\n      ? filters.tags.filter((t) => t !== tag)\n      : [...filters.tags, tag];\n    onChange({ ...filters, tags });\n  };\n\n  const toggleRelationshipType = (type: string) => {\n    let relationshipTypes: string[];\n\n    if (filters.relationshipTypes.length === 0) {\n      // Currently showing all - user wants to filter to ONLY this type\n      relationshipTypes = [type];\n    } else if (filters.relationshipTypes.includes(type)) {\n      // Type is selected, uncheck it\n      relationshipTypes = filters.relationshipTypes.filter((t) => t !== type);\n      // If nothing left selected, go back to showing all\n      // (empty array = no filter = show all)\n    } else {\n      // Type not selected, add it\n      relationshipTypes = [...filters.relationshipTypes, type];\n    }\n\n    onChange({ ...filters, relationshipTypes });\n  };\n\n  return (\n    <div className=\"filter-panel\">\n      {/* View Controls */}\n      <div className=\"view-controls\">\n        <div className=\"view-mode-buttons\">\n          <button\n            className={`view-mode-btn ${viewMode === \"graph3d\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"graph3d\")}\n            title=\"3D Graph View\"\n          >\n            3D\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"graph2d\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"graph2d\")}\n            title=\"2D Graph View\"\n          >\n            2D\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"map\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"map\")}\n            title=\"Coordinate Map View\"\n          >\n            Map\n          </button>\n          <button\n            className={`view-mode-btn ${viewMode === \"timeline\" ? \"active\" : \"\"}`}\n            onClick={() => onViewModeChange(\"timeline\")}\n            title=\"Timeline View - Eras along axis\"\n          >\n            Time\n          </button>\n        </div>\n        <div className=\"view-actions\">\n          <button\n            className=\"view-action-btn\"\n            onClick={onRecalculateLayout}\n            title=\"Recalculate Layout\"\n          >\n            \u267b\ufe0f\n          </button>\n          <button className=\"view-action-btn\" onClick={onToggleStats} title=\"Toggle Stats Panel\">\n            \ud83d\udcca\n          </button>\n        </div>\n      </div>\n\n      {/* Edge Metric (for graph views) */}\n      {(viewMode === \"graph3d\" || viewMode === \"graph2d\") && (\n        <div className=\"edge-metric-section\">\n          <span className=\"filter-section-label\">Edge Spring</span>\n          <div className=\"edge-metric-buttons\">\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"strength\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"strength\")}\n            >\n              Strength\n            </button>\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"distance\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"distance\")}\n            >\n              Distance\n            </button>\n            <button\n              className={`edge-metric-btn ${edgeMetric === \"none\" ? \"active\" : \"\"}`}\n              onClick={() => onEdgeMetricChange(\"none\")}\n            >\n              Equal\n            </button>\n          </div>\n        </div>\n      )}\n\n      <div className=\"filter-panel-divider\"></div>\n\n      {/* Search */}\n      <div className=\"filter-section\">\n        <label htmlFor=\"search\" className=\"filter-section-label\">Search</label>\n        <input id=\"search\"\n          type=\"text\"\n          value={filters.searchQuery}\n          onChange={(e) => onChange({ ...filters, searchQuery: e.target.value })}\n          placeholder=\"Search entities...\"\n          className=\"filter-search-input\"\n        />\n      </div>\n\n      {/* Entity Types */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">Entity Types</span>\n        <div className=\"filter-checkbox-group\">\n          {entityKinds.map((kind) => (\n            <label key={kind} className=\"filter-checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={filters.kinds.includes(kind)}\n                onChange={() => toggleKind(kind)}\n              />\n              <span>{kindDisplayNames[kind] ?? kind}</span>\n            </label>\n          ))}\n        </div>\n      </div>\n\n      {/* Relationship Types */}\n      <div className=\"filter-section\">\n        <div className=\"filter-accordion-container\">\n          <button\n            onClick={() => setIsRelTypesExpanded(!isRelTypesExpanded)}\n            className=\"filter-accordion-header\"\n          >\n            <div className=\"filter-accordion-header-left\">\n              <span className=\"filter-accordion-icon\">{isRelTypesExpanded ? \"\u2212\" : \"+\"}</span>\n              <span className=\"filter-accordion-title\">Relationship Types</span>\n            </div>\n            <span className=\"filter-accordion-badge\">\n              {filters.relationshipTypes.length === 0 ? \"All\" : filters.relationshipTypes.length}\n            </span>\n          </button>\n          {isRelTypesExpanded && (\n            <div className=\"filter-accordion-content\">\n              <div className=\"filter-accordion-controls\">\n                <button\n                  onClick={() => onChange({ ...filters, relationshipTypes: [] })}\n                  className=\"filter-accordion-control-btn\"\n                >\n                  Show All\n                </button>\n              </div>\n              {sortedRelationshipTypes.map((type) => {\n                // Empty array = show all (all appear checked)\n                // Non-empty = only selected types are checked\n                const isChecked =\n                  filters.relationshipTypes.length === 0\n                    ? true\n                    : filters.relationshipTypes.includes(type);\n                return (\n                  <label key={type} className=\"filter-checkbox-label\">\n                    <input\n                      type=\"checkbox\"\n                      checked={isChecked}\n                      onChange={() => toggleRelationshipType(type)}\n                    />\n                    <span>\n                      {type.replace(/_/g, \" \")} ({relationshipTypeCounts[type]})\n                    </span>\n                  </label>\n                );\n              })}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Minimum Prominence */}\n      <div className=\"filter-section\">\n        <label htmlFor=\"minimum-prominence\" className=\"filter-section-label\">Minimum Prominence</label>\n        <select id=\"minimum-prominence\"\n          value={filters.minProminence}\n          onChange={(e) => onChange({ ...filters, minProminence: e.target.value as Prominence })}\n          className=\"filter-select\"\n        >\n          {prominenceLevels.map((level) => (\n            <option key={level} value={level}>\n              {level}\n            </option>\n          ))}\n        </select>\n      </div>\n\n      {/* Time Range */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">Time Range</span>\n        <div className=\"time-range-box\">\n          <div className=\"time-range-labels\">\n            <span className=\"time-range-label\">\n              Start: <span className=\"time-range-label-value\">{filters.timeRange[0]}</span>\n            </span>\n            <span className=\"time-range-label\">\n              End: <span className=\"time-range-label-value\">{filters.timeRange[1]}</span>\n            </span>\n          </div>\n          <div className=\"time-range-sliders\">\n            <input\n              type=\"range\"\n              min={0}\n              max={maxTick}\n              value={filters.timeRange[0]}\n              onChange={(e) =>\n                onChange({\n                  ...filters,\n                  timeRange: [parseInt(e.target.value), filters.timeRange[1]],\n                })\n              }\n            />\n            <input\n              type=\"range\"\n              min={0}\n              max={maxTick}\n              value={filters.timeRange[1]}\n              onChange={(e) =>\n                onChange({\n                  ...filters,\n                  timeRange: [filters.timeRange[0], parseInt(e.target.value)],\n                })\n              }\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Tags */}\n      <div className=\"filter-section\">\n        <span className=\"filter-section-label\">\n          Tags <span className=\"text-blue-400 font-normal\">({filters.tags.length} selected)</span>\n        </span>\n        <div className=\"tags-box\">\n          {allTags.map((tag) => (\n            <label key={tag} className=\"filter-checkbox-label\">\n              <input\n                type=\"checkbox\"\n                checked={filters.tags.includes(tag)}\n                onChange={() => toggleTag(tag)}\n              />\n              <span>{tag}</span>\n            </label>\n          ))}\n        </div>\n      </div>\n\n      {/* Minimum Relationship Strength */}\n      <div className=\"filter-section\">\n// ... (truncated)", "parameters": [{"name": "{\n  filters,\n  onChange,\n  worldData,\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}", "type": "Readonly<FilterPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["EntityKind", "Filters", "Prominence", "WorldState"], "category": "internal"}, {"source": "../utils/dataTransform.ts", "specifiers": ["getAllTags", "getProminenceLevels", "getRelationshipTypeCounts"], "category": "internal"}, {"source": "./FilterPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/GraphView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/GraphView.tsx", "sourceCode": "export default function GraphView({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  onRecalculateLayoutRef,\n  prominenceScale,\n}: Readonly<GraphViewProps>) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const cyRef = useRef<Core | null>(null);\n  const isInitializedRef = useRef(false);\n\n  // Get entity kind schemas from canonical schema\n  const entityKindSchemas = useMemo(() => data.schema.entityKinds, [data.schema.entityKinds]);\n\n  // Stable ref for onNodeSelect so the init effect doesn't re-run when callback changes\n  const onNodeSelectRef = useRef(onNodeSelect);\n  useEffect(() => {\n    onNodeSelectRef.current = onNodeSelect;\n  }, [onNodeSelect]);\n\n  const handleRecalculateLayout = () => {\n    if (!cyRef.current) return;\n\n    const layout = cyRef.current.layout({\n      name: \"cose-bilkent\",\n      randomize: true, // Add jitter to break out of local minima\n      fit: true,\n      idealEdgeLength: 100,\n      // Non-linear edge strength \u2192 spring length mapping for dramatic clustering\n      edgeLength: (edge: EdgeSingular) => {\n        const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n        // Non-linear scaling: emphasizes extremes away from 0.5\n        // strength 1.0 \u2192 25px (extremely tight clustering)\n        // strength 0.7 \u2192 70px (moderate clustering)\n        // strength 0.5 \u2192 130px (neutral)\n        // strength 0.3 \u2192 230px (loose)\n        // strength 0.0 \u2192 400px (very loose, almost disconnected)\n        const invStrength = 1 - strength;\n        return 25 + Math.pow(invStrength, 1.8) * 375;\n      },\n      nodeRepulsion: 100000,\n      gravity: 0.25,\n      numIter: 2500,\n      tile: true,\n      tilingPaddingVertical: 10,\n      tilingPaddingHorizontal: 10,\n      animate: true,\n      animationDuration: 1000,\n    } as CoseBilkentLayoutOptions);\n\n    layout.run();\n  };\n\n  // Expose recalculate layout handler\n  useEffect(() => {\n    if (onRecalculateLayoutRef) {\n      onRecalculateLayoutRef(handleRecalculateLayout);\n    }\n  }, [onRecalculateLayoutRef]);\n\n  // Initialize graph once\n  useEffect(() => {\n    if (!containerRef.current || isInitializedRef.current) return;\n\n    // Generate entity kind styles dynamically from schema\n    const entityStyles = generateEntityKindStyles(entityKindSchemas);\n\n    const cy = cytoscape({\n      container: containerRef.current,\n      elements: [],\n      style: [\n        {\n          selector: \"node\",\n          style: {\n            label: \"data(name)\",\n            \"text-valign\": \"center\",\n            \"text-halign\": \"center\",\n            \"font-size\": \"10px\",\n            color: \"#fff\",\n            \"text-outline-color\": \"#000\",\n            \"text-outline-width\": 2,\n            width: \"mapData(prominence, 0, 4, 20, 60)\",\n            height: \"mapData(prominence, 0, 4, 20, 60)\",\n            \"background-color\": \"#666\",\n          },\n        },\n        // Dynamic entity kind styles from schema\n        ...entityStyles,\n        {\n          selector: \"node:selected\",\n          style: {\n            \"border-width\": 4,\n            \"border-color\": \"#FFD700\",\n            \"background-color\": \"#FFD700\",\n          },\n        },\n        {\n          // Edge strength visualization: strength values (0-1) control visual prominence\n          // - Width: 0.5-7px (stronger = much thicker)\n          // - Opacity: 0.2-1.0 (stronger = fully opaque, weak = nearly invisible)\n          // Note: mapData doesn't work with colors, so we use fixed color + opacity\n          selector: \"edge\",\n          style: {\n            width: \"mapData(strength, 0, 1, 0.5, 7)\" as unknown as number,\n            \"line-color\": \"#888\",\n            \"target-arrow-color\": \"#888\",\n            \"target-arrow-shape\": \"triangle\",\n            \"curve-style\": \"bezier\",\n            opacity: \"mapData(strength, 0, 1, 0.2, 1)\" as unknown as number,\n            label: \"data(label)\",\n            \"font-size\": \"8px\",\n            color: \"#999\",\n            \"text-rotation\": \"autorotate\",\n            \"text-margin-y\": -10,\n          },\n        },\n        {\n          selector: \"edge.highlighted\",\n          style: {\n            \"line-color\": \"#FFD700\",\n            \"target-arrow-color\": \"#FFD700\",\n            width: 3,\n          },\n        },\n        {\n          // Catalyzed edges - special styling to show meta-relationships\n          selector: \"edge.catalyzed\",\n          style: {\n            \"line-style\": \"dashed\" as cytoscape.Css.LineStyle,\n            \"line-dash-pattern\": [6, 3] as unknown as number[],\n            \"line-color\": \"#a78bfa\", // Purple color for catalyzed relationships\n            \"target-arrow-color\": \"#a78bfa\",\n            width: \"mapData(strength, 0, 1, 1, 4)\" as unknown as number,\n            opacity: 0.9,\n          },\n        },\n      ],\n      layout: {\n        name: \"cose-bilkent\",\n        randomize: true,\n        idealEdgeLength: 100,\n        edgeLength: (edge: EdgeSingular) => {\n          const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n          const invStrength = 1 - strength;\n          return 25 + Math.pow(invStrength, 1.8) * 375;\n        },\n        nodeRepulsion: 100000,\n        gravity: 0.25,\n        numIter: 2500,\n        tile: true,\n        tilingPaddingVertical: 10,\n        tilingPaddingHorizontal: 10,\n      } as CoseBilkentLayoutOptions,\n    });\n\n    // Handle node click\n    cy.on(\"tap\", \"node\", (evt) => {\n      const node = evt.target as NodeSingular;\n      onNodeSelectRef.current(node.id());\n    });\n\n    // Handle background click (deselect)\n    cy.on(\"tap\", (evt) => {\n      if (evt.target === cy) {\n        onNodeSelectRef.current(undefined);\n      }\n    });\n\n    cyRef.current = cy;\n    isInitializedRef.current = true;\n\n    return () => {\n      cy.destroy();\n      isInitializedRef.current = false;\n    };\n  }, [entityKindSchemas]);\n\n  // Update styles when entity kind schema changes\n  useEffect(() => {\n    if (!cyRef.current) return;\n    const entityStyles = generateEntityKindStyles(entityKindSchemas);\n    cyRef.current.style([\n      {\n        selector: \"node\",\n        style: {\n          label: \"data(name)\",\n          \"text-valign\": \"center\",\n          \"text-halign\": \"center\",\n          \"font-size\": \"10px\",\n          color: \"#fff\",\n          \"text-outline-color\": \"#000\",\n          \"text-outline-width\": 2,\n          width: \"mapData(prominence, 0, 4, 20, 60)\",\n          height: \"mapData(prominence, 0, 4, 20, 60)\",\n          \"background-color\": \"#666\",\n        },\n      },\n      ...entityStyles,\n      {\n        selector: \"node:selected\",\n        style: {\n          \"border-width\": 4,\n          \"border-color\": \"#FFD700\",\n          \"background-color\": \"#FFD700\",\n        },\n      },\n      {\n        selector: \"edge\",\n        style: {\n          width: \"mapData(strength, 0, 1, 0.5, 7)\" as unknown as number,\n          \"line-color\": \"#888\",\n          \"target-arrow-color\": \"#888\",\n          \"target-arrow-shape\": \"triangle\",\n          \"curve-style\": \"bezier\",\n          opacity: \"mapData(strength, 0, 1, 0.2, 1)\" as unknown as number,\n          label: \"data(label)\",\n          \"font-size\": \"8px\",\n          color: \"#999\",\n          \"text-rotation\": \"autorotate\",\n          \"text-margin-y\": -10,\n        },\n      },\n      {\n        selector: \"edge.highlighted\",\n        style: {\n          \"line-color\": \"#FFD700\",\n          \"target-arrow-color\": \"#FFD700\",\n          width: 3,\n        },\n      },\n      {\n        selector: \"edge.catalyzed\",\n        style: {\n          \"line-style\": \"dashed\" as cytoscape.Css.LineStyle,\n          \"line-dash-pattern\": [6, 3] as unknown as number[],\n          \"line-color\": \"#a78bfa\",\n          \"target-arrow-color\": \"#a78bfa\",\n          width: \"mapData(strength, 0, 1, 1, 4)\" as unknown as number,\n          opacity: 0.9,\n        },\n      },\n    ]);\n  }, [entityKindSchemas]);\n\n  // Update graph data incrementally when data changes\n  useEffect(() => {\n    if (!cyRef.current) return;\n\n    const cy = cyRef.current;\n    const newElements = transformWorldData(data, showCatalyzedBy, prominenceScale);\n\n    // Get current element IDs\n    const currentNodeIds = new Set(cy.nodes().map((n) => n.id()));\n    const currentEdgeIds = new Set(cy.edges().map((e) => e.id()));\n\n    // Get new element IDs\n    const newNodes = newElements.filter((e) => !(\"source\" in e.data));\n    const newEdges = newElements.filter((e) => \"source\" in e.data);\n    const newNodeIds = new Set(newNodes.map((n) => n.data.id));\n    const newEdgeIds = new Set(newEdges.map((e) => e.data.id));\n\n    // Remove elements that no longer exist\n    cy.nodes().forEach((node) => {\n      if (!newNodeIds.has(node.id())) {\n        cy.remove(node);\n      }\n    });\n    cy.edges().forEach((edge) => {\n      if (!newEdgeIds.has(edge.id())) {\n        cy.remove(edge);\n      }\n    });\n\n    // Add new elements\n    const elementsToAdd = newElements.filter((e) => {\n      const id = e.data.id;\n      if (\"source\" in e.data) {\n        return !currentEdgeIds.has(id);\n      } else {\n        return !currentNodeIds.has(id);\n      }\n    });\n\n    if (elementsToAdd.length > 0) {\n      cy.add(elementsToAdd);\n\n      // If we're adding many nodes or have few existing nodes, do a full randomized layout\n      const currentNodeCount = cy.nodes().length;\n      const shouldFullLayout =\n        elementsToAdd.filter((e) => !(\"source\" in e.data)).length > currentNodeCount * 0.3;\n\n      const layout = cy.layout({\n        name: \"cose-bilkent\",\n        randomize: shouldFullLayout,\n        fit: shouldFullLayout,\n        idealEdgeLength: 100,\n        edgeLength: (edge: EdgeSingular) => {\n          const strength = (edge.data(\"strength\") as number | undefined) ?? 0.5;\n          const invStrength = 1 - strength;\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  onRecalculateLayoutRef,\n  prominenceScale,\n}", "type": "Readonly<GraphViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useRef", "useMemo"], "category": "framework"}, {"source": "cytoscape", "specifiers": ["cytoscape"], "category": "external"}, {"source": "cytoscape", "specifiers": ["Core", "EdgeSingular", "NodeSingular", "StylesheetJsonBlock", "LayoutOptions"], "category": "external"}, {"source": "cytoscape-cose-bilkent", "specifiers": ["coseBilkent"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["EntityKindDefinition", "ProminenceScale"], "category": "external"}, {"source": "../utils/dataTransform.ts", "specifiers": ["transformWorldData"], "category": "internal"}, {"source": "./GraphView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/GraphView3D.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/GraphView3D.tsx", "sourceCode": "export default function GraphView3D({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}: Readonly<GraphView3DProps>) {\n  const fgRef = useRef<ForceGraphInstance>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  // Delay render by one frame to let any stale animation callbacks clear\n  const [isReady, setIsReady] = useState(false);\n  // Unique ID per mount to ensure ForceGraph gets a fresh instance\n  const [mountId] = useState(() => Date.now());\n\n  useEffect(() => {\n    if (!webglAvailable) return;\n    const frameId = requestAnimationFrame(() => {\n      setIsReady(true);\n    });\n    return () => cancelAnimationFrame(frameId);\n  }, []);\n\n  // Get container dimensions\n  useEffect(() => {\n    if (!webglAvailable) return;\n    if (containerRef.current) {\n      const updateDimensions = () => {\n        if (containerRef.current) {\n          setDimensions({\n            width: containerRef.current.clientWidth,\n            height: containerRef.current.clientHeight,\n          });\n        }\n      };\n\n      updateDimensions();\n\n      // Update on window resize\n      window.addEventListener(\"resize\", updateDimensions);\n      return () => window.removeEventListener(\"resize\", updateDimensions);\n    }\n  }, []);\n\n  // Transform data to force-graph format\n  // We need both useMemo (for sync computation) and imperative update (library mutates data)\n  const graphData = useMemo(() => {\n    const nodes: GraphNode[] = data.hardState.map((entity) => ({\n      id: entity.id,\n      name: entity.name,\n      kind: entity.kind,\n      prominence: prominenceToNumber(entity.prominence, data.schema, prominenceScale),\n      color: getKindColor(entity.kind, data.schema),\n      val: prominenceToNumber(entity.prominence, data.schema, prominenceScale) + 1, // Size multiplier (1-5)\n    }));\n\n    const links: GraphLink[] = data.relationships.map((rel) => {\n      const catalyzedBy = rel.catalyzedBy;\n      return {\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        strength: rel.strength ?? 0.5,\n        distance: rel.distance,\n        catalyzed: showCatalyzedBy && !!catalyzedBy,\n      };\n    });\n\n    return { nodes, links };\n  }, [data, showCatalyzedBy, prominenceScale]);\n\n  // Generate a stable key - includes mountId for fresh instance on remount,\n  // and entity count for clean reset when filters change\n  const graphKey = useMemo(() => {\n    return `graph-${mountId}-${data.hardState.length}`;\n  }, [mountId, data.hardState.length]);\n\n  const legendItems = useMemo(() => {\n    return data.schema.entityKinds.map((kind) => {\n      const label = kind.style?.displayName || kind.description || kind.kind;\n      return {\n        kind: kind.kind,\n        label,\n        color: getKindColor(kind.kind, data.schema),\n      };\n    });\n  }, [data.schema]);\n\n  // Calculate link distance based on selected metric\n  const linkDistance = useCallback(\n    (link: GraphLink) => {\n      if (edgeMetric === \"none\") {\n        return 100; // Equal distance for all links\n      } else if (edgeMetric === \"distance\") {\n        // Lower distance = more similar = shorter spring (pull closer together)\n        // distance is 0-1, so we scale it: 0 -> 30px, 1 -> 200px\n        const dist = link.distance ?? 0.5;\n        return 30 + dist * 170;\n      } else {\n        // strength metric (default)\n        // Higher strength = shorter spring (pull closer together)\n        // strength is 0-1, so we invert it: 1 -> 30px, 0 -> 200px\n        const strength = link.strength ?? 0.5;\n        return 30 + (1 - strength) * 170;\n      }\n    },\n    [edgeMetric]\n  );\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node: GraphNode) => {\n      onNodeSelect(node.id);\n    },\n    [onNodeSelect]\n  );\n\n  // Handle background click\n  const handleBackgroundClick = useCallback(() => {\n    onNodeSelect(undefined);\n  }, [onNodeSelect]);\n\n  // Custom node appearance with text label\n  const nodeThreeObject = useCallback(\n    (node: GraphNode) => {\n      const group = new THREE.Group();\n\n      // Node sphere\n      const geometry = new THREE.SphereGeometry(node.val * 2, 16, 16);\n      const material = new THREE.MeshLambertMaterial({\n        color: node.color,\n        transparent: true,\n        opacity: node.id === selectedNodeId ? 1 : 0.9,\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      group.add(mesh);\n\n      // Add glow for selected node\n      if (node.id === selectedNodeId) {\n        const glowGeometry = new THREE.SphereGeometry(node.val * 2.5, 16, 16);\n        const glowMaterial = new THREE.MeshBasicMaterial({\n          color: \"#FFD700\",\n          transparent: true,\n          opacity: 0.3,\n        });\n        const glow = new THREE.Mesh(glowGeometry, glowMaterial);\n        group.add(glow);\n      }\n\n      // Create text sprite\n      const canvas = document.createElement(\"canvas\");\n      const context = canvas.getContext(\"2d\");\n      if (context) {\n        canvas.width = 256;\n        canvas.height = 64;\n\n        context.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n\n        context.font = \"Bold 20px Arial\";\n        context.fillStyle = \"white\";\n        context.textAlign = \"center\";\n        context.textBaseline = \"middle\";\n        context.fillText(node.name, canvas.width / 2, canvas.height / 2);\n\n        const texture = new THREE.CanvasTexture(canvas);\n        const spriteMaterial = new THREE.SpriteMaterial({\n          map: texture,\n          transparent: true,\n          opacity: 0.9,\n        });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(20, 5, 1);\n        sprite.position.set(0, node.val * 2 + 5, 0); // Position above the node\n        group.add(sprite);\n      }\n\n      return group;\n    },\n    [selectedNodeId]\n  );\n\n  // Custom link appearance\n  const linkColor = useCallback((link: GraphLink) => {\n    if (link.catalyzed) {\n      return \"#a78bfa\"; // Purple for catalyzed\n    }\n    // Fade color based on strength\n    const opacity = Math.floor(link.strength * 255)\n      .toString(16)\n      .padStart(2, \"0\");\n    return `#ffffff${opacity}`;\n  }, []);\n\n  const linkWidth = useCallback((link: GraphLink) => {\n    return link.strength * 2; // 0-2px width based on strength\n  }, []);\n\n  // Set initial camera position and cleanup on unmount\n  useEffect(() => {\n    if (!fgRef.current) return;\n    const fg = fgRef.current;\n    const camera = fg.camera();\n    camera.position.set(0, 0, 500);\n\n    // Cleanup: pause animation when component unmounts to prevent stale tick errors\n    return () => {\n      fg.pauseAnimation?.();\n      // Also stop the d3 simulation\n      const simulation = fg.d3Force(\"simulation\");\n      simulation?.stop?.();\n    };\n  }, []);\n\n  // Configure d3 forces when metric changes\n  useEffect(() => {\n    if (fgRef.current) {\n      const fg = fgRef.current;\n\n      // Configure the d3 link force to use our distance function\n      const linkForce = fg.d3Force(\"link\");\n      if (linkForce) {\n        linkForce\n          .distance((link: GraphLink) => {\n            if (edgeMetric === \"none\") {\n              return 100;\n            } else if (edgeMetric === \"distance\") {\n              const dist = link.distance ?? 0.5;\n              return 30 + dist * 170;\n            } else {\n              const strength = link.strength ?? 0.5;\n              return 30 + (1 - strength) * 170;\n            }\n          })\n          .strength(2.0); // Higher strength so distances have stronger effect\n\n        // Restart the simulation to apply new forces\n        fg.d3ReheatSimulation();\n      }\n    }\n  }, [edgeMetric]);\n\n  if (!webglAvailable) {\n    return (\n      <div className=\"gv3d-no-webgl\">\n        <div className=\"gv3d-no-webgl-inner\">\n          <div className=\"gv3d-no-webgl-icon\">&#x1F4A0;</div>\n          <div className=\"gv3d-no-webgl-title\">\n            WebGL not available\n          </div>\n          <div className=\"gv3d-no-webgl-message\">\n            3D graph view requires WebGL. Switch to the <strong>2D Graph</strong> or{\" \"}\n            <strong>Map</strong> view instead.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className=\"gv3d-container\">\n      {isReady && (\n        <ForceGraph3D\n          key={graphKey}\n          ref={fgRef}\n          graphData={graphData}\n          width={dimensions.width}\n          height={dimensions.height}\n          nodeId=\"id\"\n          nodeLabel=\"name\"\n          nodeColor=\"color\"\n          nodeVal=\"val\"\n          nodeThreeObject={nodeThreeObject}\n          onNodeClick={handleNodeClick}\n          onBackgroundClick={handleBackgroundClick}\n          linkSource=\"source\"\n          linkTarget=\"target\"\n          linkColor={linkColor}\n          linkWidth={linkWidth}\n          linkOpacity={0.6}\n          // @ts-expect-error react-force-graph supports linkDistance\n          linkDistance={linkDistance}\n          linkDirectionalArrowLength={3}\n          linkDirectionalArrowRelPos={1}\n          enableNodeDrag={true}\n          enableNavigationControls={true}\n          showNavInfo={false}\n          backgroundColor=\"#0a1929\"\n          d3VelocityDecay={0.4}\n          d3AlphaDecay={0.015}\n          d3AlphaMin={0.001}\n          warmupTicks={200}\n          cooldownTicks={Infinity}\n          cooldownTime={20000}\n        />\n      )}\n\n      {/* Legend */}\n      <div\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}", "type": "Readonly<GraphView3DProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useRef", "useCallback", "useState", "useMemo"], "category": "framework"}, {"source": "react-force-graph-3d", "specifiers": ["ForceGraph3D"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "../utils/dataTransform.ts", "specifiers": ["getKindColor", "prominenceToNumber"], "category": "internal"}, {"source": "three", "specifiers": ["* as THREE"], "category": "external"}, {"source": "./GraphView3D.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/HeaderMenu.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/HeaderMenu.tsx", "sourceCode": "export default function HeaderMenu({\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}: Readonly<HeaderMenuProps>) {\n  const [isOpen, setIsOpen] = useState(false);\n  const menuRef = useRef<HTMLDivElement>(null);\n\n  // Close menu when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }\n  }, [isOpen]);\n\n  const handleMenuItemClick = (action: () => void) => {\n    action();\n    setIsOpen(false);\n  };\n\n  return (\n    <div className=\"header-menu\" ref={menuRef}>\n      <button onClick={() => setIsOpen(!isOpen)} className=\"header-menu-button\" title=\"Menu\">\n        <span className=\"header-menu-icon\">\u2630</span>\n      </button>\n\n      {isOpen && (\n        <div className=\"header-menu-dropdown\">\n          <div className=\"header-menu-section\">\n            <div className=\"header-menu-section-title\">View Mode</div>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"graph3d\"))}\n              className={`header-menu-item ${viewMode === \"graph3d\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"graph3d\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>3D Graph</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"graph2d\"))}\n              className={`header-menu-item ${viewMode === \"graph2d\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"graph2d\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>2D Graph</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onViewModeChange(\"map\"))}\n              className={`header-menu-item ${viewMode === \"map\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{viewMode === \"map\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Coordinate Map</span>\n            </button>\n          </div>\n\n          <div className=\"header-menu-section\">\n            <div className=\"header-menu-section-title\">Edge Spring Metric</div>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"strength\"))}\n              className={`header-menu-item ${edgeMetric === \"strength\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"strength\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Strength</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"distance\"))}\n              className={`header-menu-item ${edgeMetric === \"distance\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"distance\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>Distance</span>\n            </button>\n            <button\n              onClick={() => handleMenuItemClick(() => onEdgeMetricChange(\"none\"))}\n              className={`header-menu-item ${edgeMetric === \"none\" ? \"active\" : \"\"}`}\n            >\n              <span className=\"header-menu-item-icon\">{edgeMetric === \"none\" ? \"\u2713\" : \"\u25cb\"}</span>\n              <span>None (Equal)</span>\n            </button>\n          </div>\n\n          <button\n            onClick={() => handleMenuItemClick(onRecalculateLayout)}\n            className=\"header-menu-item\"\n          >\n            <span className=\"header-menu-item-icon\">\u267b\ufe0f</span>\n            <span>Recalculate Layout</span>\n          </button>\n\n          <button onClick={() => handleMenuItemClick(onToggleStats)} className=\"header-menu-item\">\n            <span className=\"header-menu-item-icon\">\ud83d\udcca</span>\n            <span>Toggle Stats</span>\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  viewMode,\n  edgeMetric,\n  onViewModeChange,\n  onEdgeMetricChange,\n  onRecalculateLayout,\n  onToggleStats,\n}", "type": "Readonly<HeaderMenuProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "./HeaderMenu.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/LoreSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/LoreSection.tsx", "sourceCode": "export default function LoreSection({ lore }: Readonly<LoreSectionProps>) {\n  return (\n    <div className=\"lore-section\">\n      <div className=\"lore-header\">\n        <span className=\"lore-icon\">\ud83d\udcd6</span>\n        <span className=\"lore-title\">Lore</span>\n      </div>\n      <div className=\"lore-content\">{lore.text}</div>\n    </div>\n  );\n}", "parameters": [{"name": "{ lore }", "type": "Readonly<LoreSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["DescriptionLore"], "category": "internal"}, {"source": "./LoreSection.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/archivist/webui/src/components/RelationshipStoryModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/RelationshipStoryModal.tsx", "sourceCode": "export default function RelationshipStoryModal({\n  lore,\n  worldData,\n  onClose,\n}: Readonly<RelationshipStoryModalProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: React.MouseEvent) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: React.MouseEvent) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n  const srcEntity = getEntityById(worldData, lore.relationship.src);\n  const dstEntity = getEntityById(worldData, lore.relationship.dst);\n\n  // Parse the text which is formatted as \"backstory | stakes | perception\"\n  const parts = lore.text.split(\"|\").map((p) => p.trim());\n  const backstory = parts[0] || \"\";\n  const stakes = parts[1]?.replace(/^Stakes:\\s*/i, \"\") || \"\";\n  const perception = parts[2]?.replace(/^Perception:\\s*/i, \"\") || \"\";\n\n  return (\n    <div\n      className=\"relationship-story-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"relationship-story-modal\">\n        {/* Header */}\n        <div className=\"relationship-story-header\">\n          <div className=\"relationship-story-entities\">\n            <span className=\"relationship-story-entity\">\n              {srcEntity?.name || lore.relationship.src}\n            </span>\n            <span className=\"relationship-story-kind\">\n              {lore.relationship.kind.replace(/_/g, \" \")}\n            </span>\n            <span className=\"relationship-story-entity\">\n              {dstEntity?.name || lore.relationship.dst}\n            </span>\n          </div>\n          <button onClick={onClose} className=\"relationship-story-close\">\n            \u00d7\n          </button>\n        </div>\n\n        {/* Backstory */}\n        <div className=\"relationship-story-section\">\n          <div className=\"relationship-story-section-header\">\n            <span className=\"relationship-story-section-icon\">\ud83d\udcd6</span>\n            <span className=\"relationship-story-section-title\">How It Began</span>\n          </div>\n          <div className=\"relationship-story-section-content\">{backstory}</div>\n        </div>\n\n        {/* Stakes */}\n        {stakes && (\n          <div className=\"relationship-story-section\">\n            <div className=\"relationship-story-section-header\">\n              <span className=\"relationship-story-section-icon\">\u26a0\ufe0f</span>\n              <span className=\"relationship-story-section-title\">What&apos;s at Stake</span>\n            </div>\n            <div className=\"relationship-story-section-content\">{stakes}</div>\n          </div>\n        )}\n\n        {/* Perception */}\n        {perception && (\n          <div className=\"relationship-story-section\">\n            <div className=\"relationship-story-section-header\">\n              <span className=\"relationship-story-section-icon\">\ud83d\udc41\ufe0f</span>\n              <span className=\"relationship-story-section-title\">Different Perspectives</span>\n            </div>\n            <div className=\"relationship-story-section-content\">{perception}</div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  lore,\n  worldData,\n  onClose,\n}", "type": "Readonly<RelationshipStoryModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useRef"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["RelationshipBackstoryLore", "WorldState"], "category": "internal"}, {"source": "../utils/dataTransform.ts", "specifiers": ["getEntityById"], "category": "internal"}, {"source": "./RelationshipStoryModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/StatsPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/StatsPanel.tsx", "sourceCode": "export default function StatsPanel({ worldData, isOpen, onToggle }: Readonly<StatsPanelProps>) {\n  const { pressures, validation } = worldData;\n\n  // Get pressure entries and sort by value\n  const pressureEntries = Object.entries(pressures).sort((a, b) => b[1] - a[1]);\n\n  return (\n    <>\n      {/* Stats Panel */}\n      {isOpen && (\n        <div className=\"stats-panel\">\n          <div className=\"stats-panel-header\">\n            <h3 className=\"stats-panel-title\">World Statistics</h3>\n            <button onClick={onToggle} className=\"stats-panel-close\">\n              \u2715\n            </button>\n          </div>\n\n          <div className=\"stats-panel-content\">\n            {/* Validation Status */}\n            {validation && (\n              <div className=\"stats-section\">\n                <h4 className=\"stats-section-title\">Validation</h4>\n                <div className=\"validation-summary\">\n                  <div className=\"validation-stat\">\n                    <span className=\"validation-label\">Passed:</span>\n                    <span className=\"validation-value passed\">\n                      {validation.passed}/{validation.totalChecks}\n                    </span>\n                  </div>\n                  {validation.failed > 0 && (\n                    <div className=\"validation-stat\">\n                      <span className=\"validation-label\">Failed:</span>\n                      <span className=\"validation-value failed\">{validation.failed}</span>\n                    </div>\n                  )}\n                </div>\n                <div className=\"validation-results\">\n                  {validation.results.map((result, i) => (\n                    <div\n                      key={i}\n                      className={`validation-result ${result.passed ? \"passed\" : \"failed\"}`}\n                    >\n                      <div className=\"validation-result-header\">\n                        <span className=\"validation-result-icon\">{result.passed ? \"\u2713\" : \"\u2717\"}</span>\n                        <span className=\"validation-result-name\">{result.name}</span>\n                        {!result.passed && (\n                          <span className=\"validation-result-count\">({result.failureCount})</span>\n                        )}\n                      </div>\n                      {!result.passed && (\n                        <div className=\"validation-result-details\">{result.details}</div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Pressures */}\n            <div className=\"stats-section\">\n              <h4 className=\"stats-section-title\">World Pressures</h4>\n              <div className=\"pressures-grid\">\n                {pressureEntries.map(([name, value]) => {\n                  const clamped = Math.max(-100, Math.min(100, value));\n                  const percentage = (clamped + 100) / 2; // -100..100 \u2192 0..100\n                  const magnitude = Math.abs(clamped);\n                  let intensity: string;\n                  if (magnitude >= 75) {\n                    intensity = \"high\";\n                  } else if (magnitude >= 50) {\n                    intensity = \"medium\";\n                  } else if (magnitude >= 25) {\n                    intensity = \"low\";\n                  } else {\n                    intensity = \"minimal\";\n                  }\n                  return (\n                    <div key={name} className=\"pressure-item\">\n                      <div className=\"pressure-header\">\n                        <span className=\"pressure-name\">{name.replace(/_/g, \" \")}</span>\n                        <span className=\"pressure-value\">{value.toFixed(1)}</span>\n                      </div>\n                      <div className=\"pressure-bar\">\n                        <div\n                          className={`pressure-bar-fill ${intensity}`}\n                          style={{ '--sp-pressure-width': `${percentage}%` } as React.CSSProperties}\n                        />\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ worldData, isOpen, onToggle }", "type": "Readonly<StatsPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "./StatsPanel.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/archivist/webui/src/components/TimelineControl.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/TimelineControl.tsx", "sourceCode": "export default function TimelineControl({\n  worldData,\n  loreData,\n  currentTick,\n  onTickChange\n}: Readonly<TimelineControlProps>) {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playSpeed, setPlaySpeed] = useState(1);\n  const [isExpanded, setIsExpanded] = useState(true);\n  const [selectedEraNarrative, setSelectedEraNarrative] = useState<EraNarrativeLore | null>(null);\n  const [selectedEraTransition, setSelectedEraTransition] = useState<EraTransitionMilestone | null>(null);\n  const [selectedDiscovery, setSelectedDiscovery] = useState<DiscoveryEventLore | null>(null);\n  const previousTickRef = useRef(currentTick);\n  const clearEraNarrative = useCallback(() => setSelectedEraNarrative(null), []);\n  const clearDiscovery = useCallback(() => setSelectedDiscovery(null), []);\n  const noopExplorerClick = useCallback(() => {}, []);\n  const maxTick = worldData.metadata.tick;\n  const minTick = 0;\n\n  // Get all era narratives from lore (if available)\n  const eraNarratives = useMemo(() => {\n    return loreData?.records?.filter(record => record.type === \"era_narrative\") as EraNarrativeLore[] || [];\n  }, [loreData]);\n\n  // Get all discovery events from lore (if available)\n  const discoveryEvents = useMemo(() => {\n    return loreData?.records?.filter(record => record.type === \"discovery_event\") as DiscoveryEventLore[] || [];\n  }, [loreData]);\n\n  // Get era transitions from narrativeHistory (fallback when no loreData)\n  const eraTransitions = useMemo(() => {\n    const history = worldData.narrativeHistory as NarrativeEvent[] | undefined;\n    if (!history) return [];\n    return history.filter(e => e.eventKind === \"era_transition\").map(e => ({\n      id: e.id,\n      tick: e.tick,\n      era: e.era,\n      description: e.description\n    }));\n  }, [worldData]);\n\n  // Use eraNarratives if available, otherwise use eraTransitions\n  const hasLoreNarratives = eraNarratives.length > 0;\n\n  // Get events at the current tick from narrativeHistory (significance > 0.75 only)\n  const currentEvents = useMemo(() => {\n    const history = worldData.narrativeHistory as NarrativeEvent[] | undefined;\n    if (!history) return [];\n\n    // Get high-significance events at exact tick, sorted by significance\n    return history.filter(e => e.tick === currentTick && e.eventKind !== \"era_transition\" && e.significance > 0.75).sort((a, b) => b.significance - a.significance).slice(0, 5) // Limit to 5 most significant events\n    .map(e => ({\n      type: e.eventKind,\n      description: e.description,\n      significance: e.significance\n    }));\n  }, [worldData, currentTick]);\n\n  // Detect when crossing era transition ticks\n  useEffect(() => {\n    const previousTick = previousTickRef.current;\n    previousTickRef.current = currentTick;\n\n    // Check if we crossed an era transition from lore\n    if (hasLoreNarratives) {\n      const crossedNarrative = eraNarratives.find(narrative => {\n        const tick = narrative.metadata.tick;\n        return previousTick < tick && currentTick >= tick || previousTick > tick && currentTick <= tick;\n      });\n      if (crossedNarrative && isPlaying) {\n        setSelectedEraNarrative(crossedNarrative);\n        setIsPlaying(false);\n      }\n    } else {\n      // Check narrativeHistory era transitions\n      const crossedTransition = eraTransitions.find(transition => {\n        const tick = transition.tick;\n        return previousTick < tick && currentTick >= tick || previousTick > tick && currentTick <= tick;\n      });\n      if (crossedTransition && isPlaying) {\n        setSelectedEraTransition(crossedTransition);\n        setIsPlaying(false);\n      }\n    }\n  }, [currentTick, eraNarratives, eraTransitions, hasLoreNarratives, isPlaying]);\n\n  // Auto-play functionality\n  useEffect(() => {\n    if (!isPlaying) return;\n    const interval = setInterval(() => {\n      const nextTick = currentTick + playSpeed;\n      if (nextTick >= maxTick) {\n        setIsPlaying(false);\n        onTickChange(maxTick);\n      } else {\n        onTickChange(nextTick);\n      }\n    }, 200);\n    return () => clearInterval(interval);\n  }, [isPlaying, playSpeed, maxTick, currentTick, onTickChange]);\n\n  // Determine the era at the current tick by finding the most recent era created before/at this tick\n  const currentEra = useMemo(() => {\n    const eras = worldData.hardState.filter(e => e.kind === \"era\").sort((a, b) => a.createdAt - b.createdAt);\n\n    // Find the last era that was created at or before the current tick\n    let activeEra = eras[0]?.name || \"unknown\";\n    for (const era of eras) {\n      if (era.createdAt <= currentTick) {\n        activeEra = era.name;\n      } else {\n        break;\n      }\n    }\n    return activeEra;\n  }, [worldData.hardState, currentTick]);\n\n  // Count entities and relationships at current tick\n  const entitiesAtTick = worldData.hardState.filter(e => e.createdAt <= currentTick).length;\n  const relationshipsAtTick = worldData.relationships.filter(r => {\n    const srcEntity = worldData.hardState.find(e => e.id === r.src);\n    const dstEntity = worldData.hardState.find(e => e.id === r.dst);\n    return srcEntity && dstEntity && srcEntity.createdAt <= currentTick && dstEntity.createdAt <= currentTick;\n  }).length;\n  const handlePlayPause = () => {\n    if (currentTick >= maxTick) {\n      onTickChange(minTick);\n    }\n    setIsPlaying(!isPlaying);\n  };\n  const handleReset = () => {\n    setIsPlaying(false);\n    onTickChange(minTick);\n  };\n  const handleToEnd = () => {\n    setIsPlaying(false);\n    onTickChange(maxTick);\n  };\n  return <div className={`timeline-control ${isExpanded ? \"expanded\" : \"collapsed\"}`}>\n      <div className=\"timeline-header\">\n        <button className=\"timeline-expand-btn\" onClick={() => setIsExpanded(!isExpanded)} title={isExpanded ? \"Collapse timeline\" : \"Expand timeline\"}>\n          {isExpanded ? \"\u25bc\" : \"\u25b2\"}\n        </button>\n        <div className=\"timeline-title\">\n          <span className=\"timeline-icon\">\u23f1\ufe0f</span>\n          <span>Timeline</span>\n        </div>\n        <div className=\"timeline-stats\">\n          <span className=\"timeline-stat\">Tick {currentTick}</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat era-badge\">{currentEra}</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat\">{entitiesAtTick} entities</span>\n          <span className=\"timeline-divider\">\u2022</span>\n          <span className=\"timeline-stat\">{relationshipsAtTick} links</span>\n        </div>\n      </div>\n\n      {isExpanded && <>\n          <div className=\"timeline-slider-container\">\n            <input type=\"range\" min={minTick} max={maxTick} value={currentTick} onChange={e => {\n          setIsPlaying(false);\n          onTickChange(parseInt(e.target.value));\n        }} className=\"timeline-slider\" />\n            {/* Era Milestones - positioned over the slider */}\n            {(eraNarratives.length > 0 || eraTransitions.length > 0 || discoveryEvents.length > 0) && <div className=\"timeline-milestones\">\n                {/* Era Narratives from loreData */}\n                {eraNarratives.map(narrative => {\n            const tick = narrative.metadata.tick;\n            return <button key={narrative.id} className={`timeline-milestone timeline-milestone-era ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedEraNarrative(narrative)} title={`${narrative.metadata.from} \u2192 ${narrative.metadata.to} (Tick ${tick})`}>\n                      \ud83d\udcdc\n                    </button>;\n          })}\n                {/* Era Transitions from narrativeHistory (fallback) */}\n                {!hasLoreNarratives && eraTransitions.map(transition => {\n            const tick = transition.tick;\n            return <button key={transition.id} className={`timeline-milestone timeline-milestone-era ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedEraTransition(transition)} title={`Era: ${transition.era} (Tick ${tick})`}>\n                        \ud83c\udfdb\ufe0f\n                      </button>;\n          })}\n                {/* Discovery Events */}\n                {discoveryEvents.map(discovery => {\n            const tick = discovery.metadata.tick;\n            return <button key={discovery.id} className={`timeline-milestone timeline-milestone-discovery timeline-milestone-${discovery.metadata.discoveryType} ${currentTick === tick ? \"active\" : \"\"}`} onClick={() => setSelectedDiscovery(discovery)} title={`Discovery by ${discovery.metadata.explorer} (Tick ${tick})`}>\n                      \ud83e\udded\n                    </button>;\n          })}\n              </div>}\n            <div className=\"timeline-markers\">\n              <span>{minTick}</span>\n              <span>{maxTick}</span>\n            </div>\n          </div>\n\n          <div className=\"timeline-controls\">\n            <button onClick={handleReset} className=\"timeline-btn\" title=\"Reset to start\">\n              \u23ee\n            </button>\n            <button onClick={handlePlayPause} className=\"timeline-btn timeline-btn-play\">\n              {isPlaying ? \"\u23f8\" : \"\u25b6\"}\n            </button>\n            <button onClick={handleToEnd} className=\"timeline-btn\" title=\"Jump to end\">\n              \u23ed\n            </button>\n\n            <div className=\"timeline-speed\">\n              <label htmlFor=\"speed\">Speed:</label>\n              <select id=\"speed\" value={playSpeed} onChange={e => setPlaySpeed(Number(e.target.value))} className=\"timeline-speed-select\">\n                <option value={1}>1x</option>\n                <option value={2}>2x</option>\n                <option value={5}>5x</option>\n                <option value={10}>10x</option>\n              </select>\n            </div>\n          </div>\n\n          <div className=\"timeline-events\">\n            <div className=\"timeline-events-header\">\n              {currentEvents.length > 0 ? `Events at Tick ${currentTick}:` : \"No events at this tick\"}\n            </div>\n            <div className=\"timeline-events-ticker\">\n              {currentEvents.length > 0 ? currentEvents.map((event, idx) => <div key={idx} className={`timeline-event timeline-event-${event.type}`}>\n                    <span className=\"timeline-event-type\">{getEventIcon(event.type)}</span>\n                    <span className=\"timeline-event-desc\">{event.description}</span>\n                  </div>) : <div className=\"timeline-event-empty\">\n                  Scrub through time to see historical events unfold\n                </div>}\n            </div>\n          </div>\n        </>}\n\n      {/* Era Narrative Modal (from loreData) */}\n      {selectedEraNarrative && <EraNarrative lore={selectedEraNarrative} onClose={clearEraNarrative} />}\n\n      {/* Era Transition Modal (from narrativeHistory) */}\n      {selectedEraTransition && <div className=\"era-transition-modal\" onClick={() => setSelectedEraTransition(null)} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n          <div className=\"era-transition-content\" onClick={e => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={e => {\n        if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n      }}>\n            <div className=\"era-transition-header\">\n              <span className=\"era-transition-icon\">\ud83c\udfdb\ufe0f</span>\n              <h2>Era Transition</h2>\n              <button className=\"era-transition-close\" onClick={() => setSelectedEraTransition(null)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"era-transition-body\">\n              <div className=\"era-transition-era\">{selectedEraTransition.era}</div>\n              <div className=\"era-transition-tick\">Tick {selectedEraTransition.tick}</div>\n              <p className=\"era-transition-description\">{selectedEraTransition.description}</p>\n            </div>\n          </div>\n        </div>}\n\n      {/* Discovery Story Modal */}\n      {selectedDiscovery && <DiscoveryStory lore={selectedDiscovery} onExplorerClick={noopExplorerClick} onClose={clearDiscovery} isModal={true} />}\n    </div>;\n}", "parameters": [{"name": "{\n  worldData,\n  loreData,\n  currentTick,\n  onTickChange\n}", "type": "Readonly<TimelineControlProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useRef", "useMemo", "useCallback"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "EraNarrativeLore", "DiscoveryEventLore"], "category": "internal"}, {"source": "./EraNarrative.tsx", "specifiers": ["EraNarrative"], "category": "internal"}, {"source": "./DiscoveryStory.tsx", "specifiers": ["DiscoveryStory"], "category": "internal"}, {"source": "./TimelineControl.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/TimelineView3D.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/TimelineView3D.tsx", "sourceCode": "export default function TimelineView3D({\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}: Readonly<TimelineView3DProps>) {\n  const fgRef = useRef<ForceGraphInstance>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  // Delay render by one frame to let any stale animation callbacks clear\n  const [isReady, setIsReady] = useState(false);\n  // Unique ID per mount to ensure ForceGraph gets a fresh instance\n  const [mountId] = useState(() => Date.now());\n\n  useEffect(() => {\n    if (!webglAvailable) return;\n    const frameId = requestAnimationFrame(() => {\n      setIsReady(true);\n    });\n    return () => cancelAnimationFrame(frameId);\n  }, []);\n\n  // Get container dimensions\n  useEffect(() => {\n    if (!webglAvailable) return;\n    if (containerRef.current) {\n      const updateDimensions = () => {\n        if (containerRef.current) {\n          setDimensions({\n            width: containerRef.current.clientWidth,\n            height: containerRef.current.clientHeight,\n          });\n        }\n      };\n\n      updateDimensions();\n      window.addEventListener(\"resize\", updateDimensions);\n      return () => window.removeEventListener(\"resize\", updateDimensions);\n    }\n  }, []);\n\n  // Identify eras and sort by createdAt\n  const { eraPositions, entityEraMap } = useMemo(() => {\n    const eras = data.hardState\n      .filter((e) => e.kind === \"era\")\n      .sort((a, b) => a.createdAt - b.createdAt);\n\n    const positions = new Map<string, number>();\n    eras.forEach((era, index) => {\n      // Center the timeline: first era at negative X, progressing to positive\n      const centerOffset = ((eras.length - 1) * ERA_SPACING) / 2;\n      positions.set(era.id, index * ERA_SPACING - centerOffset);\n    });\n\n    // Build entity -> era mapping\n    // Priority: 1. eraId field, 2. created_during relationship, 3. first era\n    const entityToEra = new Map<string, string>();\n    const firstEraId = eras.length > 0 ? eras[0].id : null;\n\n    // First pass: use eraId field directly\n    data.hardState.forEach((entity) => {\n      if (entity.kind !== \"era\" && entity.eraId) {\n        entityToEra.set(entity.id, entity.eraId);\n      }\n    });\n\n    // Second pass: use created_during relationships for entities without eraId\n    data.relationships.forEach((rel) => {\n      if (rel.kind === \"created_during\" && !entityToEra.has(rel.src)) {\n        // created_during: src is entity, dst is era\n        if (positions.has(rel.dst)) {\n          entityToEra.set(rel.src, rel.dst);\n        }\n      }\n    });\n\n    // Third pass: entities still without era get assigned to first era\n    data.hardState.forEach((entity) => {\n      if (entity.kind !== \"era\" && !entityToEra.has(entity.id) && firstEraId) {\n        entityToEra.set(entity.id, firstEraId);\n      }\n    });\n\n    return { eraPositions: positions, entityEraMap: entityToEra };\n  }, [data.hardState, data.relationships]);\n\n  const legendItems = useMemo(() => {\n    return data.schema.entityKinds\n      .filter((kind) => kind.kind !== \"era\")\n      .map((kind) => {\n        const label = kind.style?.displayName || kind.description || kind.kind;\n        return {\n          kind: kind.kind,\n          label,\n          color: getKindColor(kind.kind, data.schema),\n        };\n      });\n  }, [data.schema]);\n\n  // Transform data to force-graph format\n  const graphData = useMemo(() => {\n    const nodes: GraphNode[] = data.hardState.map((entity) => {\n      const isEra = entity.kind === \"era\";\n\n      // For eras: use their fixed position\n      // For entities: get their era's X position as a soft target (not fixed)\n      let eraX: number | undefined;\n      if (isEra) {\n        eraX = eraPositions.get(entity.id);\n      } else {\n        const entityEraId = entityEraMap.get(entity.id);\n        if (entityEraId) {\n          eraX = eraPositions.get(entityEraId);\n        }\n      }\n\n      return {\n        id: entity.id,\n        name: entity.name,\n        kind: entity.kind,\n        prominence: prominenceToNumber(entity.prominence, data.schema, prominenceScale),\n        color: isEra ? \"#FFD700\" : getKindColor(entity.kind, data.schema), // Gold for eras\n        val: isEra ? 6 : prominenceToNumber(entity.prominence, data.schema, prominenceScale) + 1, // Eras are larger\n        createdAt: entity.createdAt,\n        // Fix era positions along X-axis, but not entity positions\n        fx: isEra ? eraX : undefined,\n        fy: isEra ? ERA_Y_POSITION : undefined,\n        fz: isEra ? ERA_Z_POSITION : undefined,\n        // Store the target X position for non-era entities (used by force simulation)\n        _targetX: isEra ? undefined : eraX,\n      } as SimulationNode;\n    });\n\n    const links: GraphLink[] = data.relationships.map((rel) => {\n      const catalyzedBy = rel.catalyzedBy;\n      // Both active_during and created_during link entities to eras\n      const isEraLink = ERA_RELATIONSHIP_KINDS.includes(rel.kind);\n\n      return {\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        strength: rel.strength ?? 0.5,\n        distance: rel.distance,\n        catalyzed: showCatalyzedBy && !!catalyzedBy,\n        isCreatedDuring: isEraLink, // Renamed to isEraLink semantically, but keeping field name for compatibility\n      };\n    });\n\n    return { nodes, links };\n  }, [data, showCatalyzedBy, eraPositions, entityEraMap, prominenceScale]);\n\n  // Generate a stable key - includes mountId for fresh instance on remount,\n  // and entity count for clean reset when filters change\n  const graphKey = useMemo(() => {\n    return `timeline-${mountId}-${data.hardState.length}`;\n  }, [mountId, data.hardState.length]);\n\n  // Calculate link distance based on selected metric and relationship type\n  const linkDistance = useCallback(\n    (link: GraphLink) => {\n      // created_during links should be shorter to pull entities toward their era\n      if (link.isCreatedDuring) {\n        return 50; // Short distance to cluster near era\n      }\n\n      if (edgeMetric === \"none\") {\n        return 100;\n      } else if (edgeMetric === \"distance\") {\n        const dist = link.distance ?? 0.5;\n        return 30 + dist * 170;\n      } else {\n        const strength = link.strength ?? 0.5;\n        return 30 + (1 - strength) * 170;\n      }\n    },\n    [edgeMetric]\n  );\n\n  // Handle node click\n  const handleNodeClick = useCallback(\n    (node: GraphNode) => {\n      onNodeSelect(node.id);\n    },\n    [onNodeSelect]\n  );\n\n  // Handle background click\n  const handleBackgroundClick = useCallback(() => {\n    onNodeSelect(undefined);\n  }, [onNodeSelect]);\n\n  // Custom node appearance with text label\n  const nodeThreeObject = useCallback(\n    (node: GraphNode) => {\n      const group = new THREE.Group();\n      const isEra = node.kind === \"era\";\n      const isSelected = node.id === selectedNodeId;\n\n      addNodeMesh(group, node, isEra, isSelected);\n      if (isSelected) {\n        addSelectionGlow(group, node, isEra);\n      }\n      addTextSprite(group, node, isEra);\n\n      return group;\n    },\n    [selectedNodeId]\n  );\n\n  // Custom link appearance\n  const linkColor = useCallback((link: GraphLink) => {\n    if (link.isCreatedDuring) {\n      return \"#FFD70088\"; // Golden for created_during links\n    }\n    if (link.catalyzed) {\n      return \"#a78bfa\";\n    }\n    const opacity = Math.floor(link.strength * 255)\n      .toString(16)\n      .padStart(2, \"0\");\n    return `#ffffff${opacity}`;\n  }, []);\n\n  const linkWidth = useCallback((link: GraphLink) => {\n    if (link.isCreatedDuring) {\n      return 1; // Thinner for created_during to reduce visual clutter\n    }\n    return link.strength * 2;\n  }, []);\n\n  // Set initial camera position and cleanup on unmount\n  useEffect(() => {\n    if (!isReady || !fgRef.current) {\n      return;\n    }\n\n    const fg = fgRef.current;\n    const camera = fg.camera();\n    // Position camera to see timeline from the side\n    camera.position.set(0, 200, 500);\n\n    // Cleanup: pause animation when component unmounts to prevent stale tick errors\n    return () => {\n      fg.pauseAnimation?.();\n      // Also stop the d3 simulation\n      const simulation = fg.d3Force(\"simulation\");\n      simulation?.stop?.();\n    };\n  }, [isReady]);\n\n  // Configure d3 forces for timeline layout\n  useEffect(() => {\n    if (!isReady || !fgRef.current) {\n      return;\n    }\n\n    const fg = fgRef.current;\n\n    // Configure the d3 link force\n    const linkForce = fg.d3Force(\"link\");\n    if (linkForce) {\n      linkForce\n        .distance((link: GraphLink) => {\n          // Era links (active_during, created_during) are shorter to cluster near era\n          if (link.isCreatedDuring) {\n            return 50;\n          }\n          if (edgeMetric === \"none\") {\n            return 100;\n          } else if (edgeMetric === \"distance\") {\n            const dist = link.distance ?? 0.5;\n            return 30 + dist * 170;\n          } else {\n            const strength = link.strength ?? 0.5;\n            return 30 + (1 - strength) * 170;\n          }\n        })\n        .strength((link: GraphLink) => {\n          // Era links have higher strength to pull entities toward eras\n          if (link.isCreatedDuring) {\n            return 1.5;\n          }\n          return 0.5;\n        });\n\n      fg.d3ReheatSimulation();\n    }\n\n    // Add custom force to pull entities toward their era's X position\n    // This works even for entities without direct era relationships\n    fg.d3Force(\"eraX\", (alpha: number) => {\n      (graphData.nodes as SimulationNode[]).forEach((node) => {\n        if (node.kind !== \"era\" && node._targetX !== undefined && node.fx === undefined) {\n          // Pull toward era's X position\n          const dx = node._targetX - (node.x ?? 0);\n          node.vx = (node.vx || 0) + dx * alpha * 0.1;\n        }\n// ... (truncated)", "parameters": [{"name": "{\n  data,\n  selectedNodeId,\n  onNodeSelect,\n  showCatalyzedBy = false,\n  edgeMetric = \"strength\",\n  prominenceScale,\n}", "type": "Readonly<TimelineView3DProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useRef", "useCallback", "useState", "useMemo"], "category": "framework"}, {"source": "react-force-graph-3d", "specifiers": ["ForceGraph3D"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["ProminenceScale"], "category": "external"}, {"source": "../utils/dataTransform.ts", "specifiers": ["getKindColor", "prominenceToNumber"], "category": "internal"}, {"source": "three", "specifiers": ["* as THREE"], "category": "external"}, {"source": "./TimelineView3D.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/archivist/webui/src/components/WorldExplorer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/archivist/webui/src/components/WorldExplorer.tsx", "sourceCode": "export default function WorldExplorer({ worldData, loreData }: Readonly<WorldExplorerProps>) {\n  // Initialize from hash on mount\n  const [selectedEntityId, setSelectedEntityId] = useState<string | undefined>(() =>\n    parseHashEntityId()\n  );\n  const [currentTick, setCurrentTick] = useState<number>(worldData.metadata.tick);\n  const [isStatsPanelOpen, setIsStatsPanelOpen] = useState(false);\n  const [viewMode, setViewMode] = useState<ViewMode>(webglAvailable ? \"graph3d\" : \"graph2d\");\n  const [edgeMetric, setEdgeMetric] = useState<EdgeMetric>(\"strength\");\n  const recalculateLayoutRef = useRef<(() => void) | null>(null);\n  const handleRecalculateLayout = useCallback(() => recalculateLayoutRef.current?.(), []);\n  const handleToggleStats = useCallback(() => setIsStatsPanelOpen(prev => !prev), []);\n  const handleRecalculateLayoutRef = useCallback(\n    (handler: (() => void) | null) => { recalculateLayoutRef.current = handler; },\n    []\n  );\n\n  // Sync hash changes to state (for back/forward buttons)\n  useEffect(() => {\n    const handleHashChange = () => {\n      const entityId = parseHashEntityId();\n      setSelectedEntityId(entityId);\n    };\n\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, []);\n\n  // Handle entity selection - updates hash which triggers state update via hashchange\n  const handleEntitySelect = useCallback((entityId: string | undefined) => {\n    const newHash = buildEntityHash(entityId);\n    if (window.location.hash !== newHash) {\n      window.location.hash = newHash;\n    }\n  }, []);\n\n  // Get UI configuration from schema\n  const entityKinds = worldData.schema.entityKinds.map((ek) => ek.kind);\n  const defaultMinProminence = getProminenceLevels(worldData.schema)[0];\n  const prominenceScale = useMemo<ProminenceScale>(() => {\n    const values = worldData.hardState\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [worldData]);\n\n  const [filters, setFilters] = useState<Filters>({\n    kinds: entityKinds,\n    minProminence: defaultMinProminence,\n    timeRange: [0, worldData.metadata.tick],\n    tags: [],\n    searchQuery: \"\",\n    relationshipTypes: [],\n    minStrength: 0.0,\n    showCatalyzedBy: false,\n    showHistoricalRelationships: false,\n  });\n\n  // Apply temporal filter first, then regular filters\n  const temporalData = applyTemporalFilter(worldData, currentTick);\n  const filteredData = applyFilters(temporalData, filters, prominenceScale);\n  const loadingFallback = useMemo(() => <div className=\"world-loading\">Loading view\u2026</div>, []);\n\n  return (\n    <div className=\"world-explorer\">\n      {/* Main Content */}\n      <div className=\"world-main\">\n        {/* Filter Panel */}\n        <FilterPanel\n          filters={filters}\n          onChange={setFilters}\n          worldData={worldData}\n          viewMode={viewMode}\n          edgeMetric={edgeMetric}\n          onViewModeChange={setViewMode}\n          onEdgeMetricChange={setEdgeMetric}\n          onRecalculateLayout={handleRecalculateLayout}\n          onToggleStats={handleToggleStats}\n        />\n\n        {/* Graph View */}\n        <main className=\"world-graph-container\">\n          <Suspense fallback={loadingFallback}>\n            {viewMode === \"graph3d\" && (\n              <GraphView3D\n                key={`3d-view-${edgeMetric}`}\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                edgeMetric={edgeMetric}\n                prominenceScale={prominenceScale}\n              />\n            )}\n            {viewMode === \"graph2d\" && (\n              <GraphView\n                key=\"2d-view\"\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                onRecalculateLayoutRef={handleRecalculateLayoutRef}\n                prominenceScale={prominenceScale}\n              />\n            )}\n            {viewMode === \"timeline\" && (\n              <TimelineView3D\n                key={`timeline-view-${edgeMetric}`}\n                data={filteredData}\n                selectedNodeId={selectedEntityId}\n                onNodeSelect={handleEntitySelect}\n                showCatalyzedBy={filters.showCatalyzedBy}\n                edgeMetric={edgeMetric}\n                prominenceScale={prominenceScale}\n              />\n            )}\n          </Suspense>\n          {viewMode === \"map\" && (\n            <CoordinateMapView\n              key=\"map-view\"\n              data={filteredData}\n              selectedNodeId={selectedEntityId}\n              onNodeSelect={handleEntitySelect}\n            />\n          )}\n        </main>\n\n        {/* Entity Detail Panel */}\n        <EntityDetail\n          entityId={selectedEntityId}\n          worldData={worldData}\n          loreData={loreData}\n          onRelatedClick={handleEntitySelect}\n          prominenceScale={prominenceScale}\n        />\n      </div>\n\n      {/* Timeline Control */}\n      <TimelineControl\n        worldData={worldData}\n        loreData={loreData}\n        currentTick={currentTick}\n        onTickChange={setCurrentTick}\n      />\n\n      {/* Stats Panel */}\n      <StatsPanel\n        worldData={worldData}\n        isOpen={isStatsPanelOpen}\n        onToggle={handleToggleStats}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{ worldData, loreData }", "type": "Readonly<WorldExplorerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "lazy", "Suspense", "useMemo", "useEffect", "useCallback"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState", "Filters", "LoreData"], "category": "internal"}, {"source": "../utils/dataTransform.ts", "specifiers": ["applyFilters", "applyTemporalFilter", "getProminenceLevels"], "category": "internal"}, {"source": "./CoordinateMapView.tsx", "specifiers": ["CoordinateMapView"], "category": "internal"}, {"source": "./FilterPanel.tsx", "specifiers": ["FilterPanel"], "category": "internal"}, {"source": "./EntityDetail.tsx", "specifiers": ["EntityDetail"], "category": "internal"}, {"source": "./TimelineControl.tsx", "specifiers": ["TimelineControl"], "category": "internal"}, {"source": "./StatsPanel.tsx", "specifiers": ["StatsPanel"], "category": "internal"}, {"source": "./WorldExplorer.css", "specifiers": [], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getTagsArray", "name": "getTagsArray", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "// Helper to get tags as array (canonical KVP format)\nexport function getTagsArray(tags: Record<string, string | boolean>): string[] {\n  return Object.keys(tags);\n}", "parameters": [{"name": "tags", "type": "Record<string, string | boolean>", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getProminenceLevels", "name": "getProminenceLevels", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "// Get prominence levels from schema (no fallbacks)\nexport function getProminenceLevels(schema?: Schema): Prominence[] {\n  const levels = schema?.uiConfig?.prominenceLevels;\n  if (!levels || levels.length === 0) {\n    throw new Error(\"Archivist: schema.uiConfig.prominenceLevels is required.\");\n  }\n  const invalidLevels = levels.filter((level) => !VALID_PROMINENCE_LEVELS.has(level as Prominence));\n  if (invalidLevels.length > 0) {\n    throw new Error(`Archivist: unsupported prominence levels: ${invalidLevels.join(\", \")}.`);\n  }\n  return levels as Prominence[];\n}", "parameters": [{"name": "schema", "type": "Schema", "optional": true}], "returnType": "Prominence[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getProminenceColor", "name": "getProminenceColor", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getProminenceColor(prominence: Prominence, schema?: Schema): string {\n  const colors = schema?.uiConfig?.prominenceColors;\n  if (!colors) {\n    throw new Error(\"Archivist: schema.uiConfig.prominenceColors is required.\");\n  }\n  const color = colors[prominence];\n  if (!color) {\n    throw new Error(`Archivist: prominence color missing for \"${prominence}\".`);\n  }\n  return color;\n}", "parameters": [{"name": "prominence", "type": "Prominence", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::prominenceToNumber", "name": "prominenceToNumber", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function prominenceToNumber(\n  prominence: Prominence | number,\n  schema?: Schema,\n  prominenceScale?: ProminenceScale\n): number {\n  if (typeof prominence === \"number\" && Number.isFinite(prominence)) {\n    const scale = resolveProminenceScale(prominenceScale);\n    const label = prominenceLabelFromScale(prominence, scale);\n    const index = scale.labels.indexOf(label);\n    return index >= 0 ? index : 0;\n  }\n\n  const levels = getProminenceLevels(schema);\n  const index = levels.indexOf(prominence as Prominence);\n  if (index < 0) {\n    throw new Error(\n      `Archivist: prominence \"${String(prominence)}\" not found in schema.uiConfig.prominenceLevels.`\n    );\n  }\n  return index;\n}", "parameters": [{"name": "prominence", "type": "Prominence | number", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getKindColor", "name": "getKindColor", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getKindColor(kind: string, schema?: Schema): string {\n  const entityKind = schema?.entityKinds?.find((ek) => ek.kind === kind);\n  if (!entityKind) {\n    throw new Error(`Archivist: entity kind \"${kind}\" not found in schema.`);\n  }\n  if (!entityKind.style?.color) {\n    throw new Error(`Archivist: entity kind \"${kind}\" is missing style.color.`);\n  }\n  return entityKind.style.color;\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}, {"name": "schema", "type": "Schema", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::transformWorldData", "name": "transformWorldData", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function transformWorldData(\n  worldState: WorldState,\n  showCatalyzedBy: boolean = false,\n  prominenceScale?: ProminenceScale\n) {\n  const resolvedScale = resolveProminenceScale(prominenceScale);\n  const nodes = worldState.hardState.map((entity) => ({\n    data: {\n      id: entity.id,\n      name: entity.name,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      prominence: prominenceToNumber(entity.prominence, worldState.schema, resolvedScale),\n      prominenceLabel:\n        typeof entity.prominence === \"number\"\n          ? prominenceLabelFromScale(entity.prominence, resolvedScale)\n          : entity.prominence,\n      status: entity.status,\n      tags: entity.tags,\n      description: entity.description,\n      createdAt: entity.createdAt,\n      updatedAt: entity.updatedAt,\n    },\n    classes: `${entity.kind} ${entity.subtype} ${entity.prominence}`,\n  }));\n\n  const edges = worldState.relationships.map((rel) => {\n    // Check if this relationship was catalyzed by an event or entity\n    // In a full implementation, this would check for catalyzedBy metadata\n    const catalyzedBy = rel.catalyzedBy;\n    const hasCatalyst = !!catalyzedBy;\n\n    return {\n      data: {\n        id: `edge-${rel.src}-${rel.dst}-${rel.kind}`,\n        source: rel.src,\n        target: rel.dst,\n        kind: rel.kind,\n        label: rel.kind.replace(/_/g, \" \"),\n        strength: rel.strength ?? 0.5,\n        catalyzedBy: catalyzedBy,\n        hasCatalyst: hasCatalyst,\n      },\n      classes: [rel.kind.replace(/_/g, \"-\"), hasCatalyst && showCatalyzedBy ? \"catalyzed\" : \"\"]\n        .filter(Boolean)\n        .join(\" \"),\n    };\n  });\n\n  return [...nodes, ...edges];\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "showCatalyzedBy", "type": "boolean", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "({ data: { id: string; name: string; kind: string; subtype: string; prominence: number; prominenceLabel: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").ProminenceLabel; status: string; tags: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").EntityTags; description: string; createdAt: number; updatedAt: number; }; classes: string; } | { data: { id: string; source: string; target: string; kind: string; label: string; strength: number; catalyzedBy: string | undefined; hasCatalyst: boolean; }; classes: string; })[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::applyFilters", "name": "applyFilters", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function applyFilters(\n  worldState: WorldState,\n  filters: Filters,\n  prominenceScale?: ProminenceScale\n): WorldState {\n  const prominenceOrder = getProminenceLevels(worldState.schema);\n  const minProminenceIndex = prominenceOrder.indexOf(filters.minProminence);\n  const resolvedScale = resolveProminenceScale(prominenceScale);\n\n  const filtered = worldState.hardState.filter((entity) => {\n    // Filter by kind\n    if (!filters.kinds.includes(entity.kind)) return false;\n\n    // Filter by prominence\n    const entityProminenceLabel =\n      typeof entity.prominence === \"number\"\n        ? prominenceLabelFromScale(entity.prominence, resolvedScale)\n        : entity.prominence;\n    const entityProminenceIndex = prominenceOrder.indexOf(entityProminenceLabel);\n    if (entityProminenceIndex < minProminenceIndex) return false;\n\n    // Filter by time range\n    if (entity.createdAt < filters.timeRange[0] || entity.createdAt > filters.timeRange[1]) {\n      return false;\n    }\n\n    // Filter by tags\n    if (filters.tags.length > 0) {\n      const entityTags = getTagsArray(entity.tags);\n      const hasMatchingTag = filters.tags.some((tag) => entityTags.includes(tag));\n      if (!hasMatchingTag) return false;\n    }\n\n    // Filter by search query\n    if (filters.searchQuery) {\n      const query = filters.searchQuery.toLowerCase();\n      const entityTags = getTagsArray(entity.tags);\n      const matches =\n        entity.name.toLowerCase().includes(query) ||\n        entity.description.toLowerCase().includes(query) ||\n        entityTags.some((tag) => tag.toLowerCase().includes(query));\n      if (!matches) return false;\n    }\n\n    return true;\n  });\n\n  // Get IDs of filtered entities\n  const filteredIds = new Set(filtered.map((e) => e.id));\n\n  // Get all unique relationship types for comparison\n  const allRelTypes = new Set(worldState.relationships.map((r) => r.kind));\n\n  // Filter relationships to only include those between filtered entities\n  // Also filter by relationship type and strength if specified\n  const filteredRelationships = worldState.relationships.filter((rel) => {\n    // Must be between visible entities\n    if (!filteredIds.has(rel.src) || !filteredIds.has(rel.dst)) return false;\n\n    // Filter by minimum strength\n    const strength = rel.strength ?? 0.5;\n    if (strength < filters.minStrength) return false;\n\n    // If relationship type filter has ALL types selected, show none (special \"clear all\" case)\n    if (\n      filters.relationshipTypes.length === allRelTypes.size &&\n      filters.relationshipTypes.length > 0\n    ) {\n      return false;\n    }\n\n    // If relationship type filter is active and not empty, check if this type is included\n    if (filters.relationshipTypes.length > 0) {\n      return filters.relationshipTypes.includes(rel.kind);\n    }\n\n    // Filter historical relationships unless explicitly shown\n    if (!filters.showHistoricalRelationships && rel.status === \"historical\") {\n      return false;\n    }\n\n    // Empty array means show all\n    return true;\n  });\n\n  return {\n    ...worldState,\n    hardState: filtered,\n    relationships: filteredRelationships,\n    metadata: {\n      ...worldState.metadata,\n      entityCount: filtered.length,\n      relationshipCount: filteredRelationships.length,\n    },\n  };\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "filters", "type": "Filters", "optional": false}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "WorldState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getAllTags", "name": "getAllTags", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getAllTags(worldState: WorldState): string[] {\n  const tagSet = new Set<string>();\n  worldState.hardState.forEach((entity) => {\n    getTagsArray(entity.tags).forEach((tag) => tagSet.add(tag));\n  });\n  return Array.from(tagSet).sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getAllRelationshipTypes", "name": "getAllRelationshipTypes", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getAllRelationshipTypes(worldState: WorldState): string[] {\n  const typeSet = new Set<string>();\n  worldState.relationships.forEach((rel) => {\n    typeSet.add(rel.kind);\n  });\n  return Array.from(typeSet).sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelationshipTypeCounts", "name": "getRelationshipTypeCounts", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelationshipTypeCounts(worldState: WorldState): Record<string, number> {\n  const counts: Record<string, number> = {};\n  worldState.relationships.forEach((rel) => {\n    counts[rel.kind] = (counts[rel.kind] || 0) + 1;\n  });\n  return counts;\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}], "returnType": "Record<string, number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getEntityById", "name": "getEntityById", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getEntityById(worldState: WorldState, id: string): HardState | undefined {\n  return worldState.hardState.find((e) => e.id === id);\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "HardState | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelatedEntities", "name": "getRelatedEntities", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelatedEntities(worldState: WorldState, entityId: string): HardState[] {\n  const relatedIds = new Set<string>();\n\n  worldState.relationships.forEach((rel) => {\n    if (rel.src === entityId) {\n      relatedIds.add(rel.dst);\n    }\n    if (rel.dst === entityId) {\n      relatedIds.add(rel.src);\n    }\n  });\n\n  return worldState.hardState.filter((e) => relatedIds.has(e.id));\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::getRelationships", "name": "getRelationships", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function getRelationships(worldState: WorldState, entityId: string) {\n  return worldState.relationships.filter((rel) => rel.src === entityId || rel.dst === entityId);\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/world\").WorldRelationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/dataTransform.ts::applyTemporalFilter", "name": "applyTemporalFilter", "kind": "function", "filePath": "apps/archivist/webui/src/utils/dataTransform.ts", "sourceCode": "export function applyTemporalFilter(worldState: WorldState, maxTick: number): WorldState {\n  // Filter entities created at or before maxTick\n  const filteredEntities = worldState.hardState.filter((entity) => entity.createdAt <= maxTick);\n\n  // Filter relationships where both source and destination entities exist at maxTick\n  const filteredRelationships = worldState.relationships.filter((rel) => {\n    const srcEntity = worldState.hardState.find((e) => e.id === rel.src);\n    const dstEntity = worldState.hardState.find((e) => e.id === rel.dst);\n    return (\n      srcEntity && dstEntity && srcEntity.createdAt <= maxTick && dstEntity.createdAt <= maxTick\n    );\n  });\n\n  return {\n    ...worldState,\n    hardState: filteredEntities,\n    relationships: filteredRelationships,\n    metadata: {\n      ...worldState.metadata,\n      tick: maxTick,\n      entityCount: filteredEntities.length,\n      relationshipCount: filteredRelationships.length,\n    },\n  };\n}", "parameters": [{"name": "worldState", "type": "WorldState", "optional": false}, {"name": "maxTick", "type": "number", "optional": false}], "returnType": "WorldState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["HardState", "Prominence", "WorldState", "Filters", "Schema"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}]}, {"id": "apps/archivist/webui/src/utils/schemaValidation.ts::validateWorldData", "name": "validateWorldData", "kind": "function", "filePath": "apps/archivist/webui/src/utils/schemaValidation.ts", "sourceCode": "export function validateWorldData(worldData: WorldState): string[] {\n  const issues: string[] = [];\n  let overflow = 0;\n\n  const addIssue = (message: string) => {\n    if (issues.length < MAX_ISSUES) {\n      issues.push(message);\n    } else {\n      overflow += 1;\n    }\n  };\n\n  if (!worldData?.schema) {\n    addIssue(\"World data is missing schema.\");\n    return issues;\n  }\n\n  const { schema } = worldData;\n\n  if (!schema.entityKinds || schema.entityKinds.length === 0) {\n    addIssue(\"Schema requires entityKinds.\");\n  }\n\n  if (!schema.relationshipKinds || schema.relationshipKinds.length === 0) {\n    addIssue(\"Schema requires relationshipKinds.\");\n  }\n\n  if (!schema.cultures || schema.cultures.length === 0) {\n    addIssue(\"Schema requires cultures.\");\n  }\n\n  if (!schema.uiConfig) {\n    addIssue(\"Schema requires uiConfig.\");\n  }\n\n  const prominenceLevels = schema.uiConfig?.prominenceLevels;\n  const prominenceColors = schema.uiConfig?.prominenceColors;\n\n  if (!prominenceLevels || prominenceLevels.length === 0) {\n    addIssue(\"Schema.uiConfig.prominenceLevels is required.\");\n  }\n\n  if (!prominenceColors || Object.keys(prominenceColors).length === 0) {\n    addIssue(\"Schema.uiConfig.prominenceColors is required.\");\n  }\n\n  if (prominenceLevels && prominenceColors) {\n    prominenceLevels.forEach((level) => {\n      if (!prominenceColors[level]) {\n        addIssue(`Schema.uiConfig.prominenceColors missing \"${level}\".`);\n      }\n    });\n  }\n\n  const axisIds = new Set((schema.axisDefinitions || []).map((axis) => axis.id));\n  const kindById = new Map(schema.entityKinds?.map((kind) => [kind.kind, kind]));\n  const cultureIds = new Set(schema.cultures?.map((culture) => culture.id));\n  const relationshipKinds = new Set(schema.relationshipKinds?.map((kind) => kind.kind));\n\n  schema.entityKinds?.forEach((kind) => {\n    if (!kind.style?.color) {\n      addIssue(`Entity kind \"${kind.kind}\" is missing style.color.`);\n    }\n\n    kind.requiredRelationships?.forEach((rule) => {\n      if (!relationshipKinds.has(rule.kind)) {\n        addIssue(`Entity kind \"${kind.kind}\" requires unknown relationship \"${rule.kind}\".`);\n      }\n    });\n\n    const axes = kind.semanticPlane?.axes;\n    const axisRefs = [axes?.x?.axisId, axes?.y?.axisId, axes?.z?.axisId].filter(\n      Boolean\n    ) as string[];\n    axisRefs.forEach((axisId) => {\n      if (!axisIds.has(axisId)) {\n        addIssue(\n          `Axis \"${axisId}\" referenced by kind \"${kind.kind}\" is missing in schema.axisDefinitions.`\n        );\n      }\n    });\n\n    kind.semanticPlane?.regions?.forEach((region) => {\n      if (!region.color) {\n        addIssue(`Region \"${region.id}\" in kind \"${kind.kind}\" is missing color.`);\n      }\n    });\n  });\n\n  schema.cultures?.forEach((culture) => {\n    if (!culture.color) {\n      addIssue(`Culture \"${culture.id}\" is missing color.`);\n    }\n  });\n\n  if (worldData.coordinateState?.emergentRegions) {\n    Object.entries(worldData.coordinateState.emergentRegions).forEach(([kind, regions]) => {\n      regions.forEach((region) => {\n        if (!region.color) {\n          addIssue(`Emergent region \"${region.id}\" for kind \"${kind}\" is missing color.`);\n        }\n      });\n    });\n  }\n\n  worldData.hardState.forEach((entity) => {\n    if (!kindById.has(entity.kind)) {\n      addIssue(`Entity \"${entity.id}\" references unknown kind \"${entity.kind}\".`);\n    }\n\n    if (entity.culture && !cultureIds.has(entity.culture)) {\n      addIssue(`Entity \"${entity.id}\" references unknown culture \"${entity.culture}\".`);\n    }\n\n    if (prominenceLevels) {\n      const prom: unknown = entity.prominence;\n      if (typeof prom === \"string\") {\n        if (!prominenceLevels.includes(prom)) {\n          addIssue(\n            `Entity \"${entity.id}\" uses prominence \"${prom}\" not in schema.uiConfig.prominenceLevels.`\n          );\n        }\n      } else if (typeof prom === \"number\") {\n        if (!Number.isFinite(prom) || prom < 0 || prom > 5) {\n          addIssue(`Entity \"${entity.id}\" has invalid numeric prominence \"${String(prom)}\".`);\n        }\n      } else {\n        addIssue(`Entity \"${entity.id}\" has invalid prominence \"${String(prom)}\".`);\n      }\n    }\n\n    const coords = entity.coordinates;\n    if (\n      !coords ||\n      typeof coords.x !== \"number\" ||\n      typeof coords.y !== \"number\" ||\n      typeof coords.z !== \"number\"\n    ) {\n      addIssue(`Entity \"${entity.id}\" is missing valid coordinates.`);\n    }\n  });\n\n  worldData.relationships.forEach((rel) => {\n    if (rel.kind && !relationshipKinds.has(rel.kind)) {\n      addIssue(`Relationship \"${rel.kind}\" is not defined in schema.relationshipKinds.`);\n    }\n  });\n\n  if (overflow > 0) {\n    issues.push(`...and ${overflow} more issues.`);\n  }\n\n  return issues;\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/ChroniclerRemote.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/ChroniclerRemote.tsx", "sourceCode": "export default function ChroniclerRemote({\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedWorldData,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}: Readonly<ChroniclerRemoteProps>) {\n  const { worldData, loading, loadError } = useWorldDataLoader({\n    projectId,\n    activeSlotIndex,\n    dexieSeededAt,\n    preloadedWorldData,\n  });\n\n  if (loading || loadError || !worldData) {\n    return <ChroniclerStatusScreen loading={loading} loadError={loadError} />;\n  }\n\n  return (\n    <WikiExplorer\n      projectId={projectId}\n      worldData={worldData}\n      loreData={null}\n      requestedPageId={requestedPageId}\n      onRequestedPageConsumed={onRequestedPageConsumed}\n      preloadedChronicles={preloadedChronicles}\n      preloadedStaticPages={preloadedStaticPages}\n      preloadedEraNarratives={preloadedEraNarratives}\n      prebakedParchmentUrl={prebakedParchmentUrl}\n      precomputedPageIndex={precomputedPageIndex}\n    />\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedWorldData,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}", "type": "Readonly<ChroniclerRemoteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./styles/variables.css", "specifiers": [], "category": "internal"}, {"source": "./components/WikiExplorer.tsx", "specifiers": ["WikiExplorer"], "category": "internal"}, {"source": "./components/ChroniclerStatusScreen.tsx", "specifiers": ["ChroniclerStatusScreen"], "category": "internal"}, {"source": "./types/world.ts", "specifiers": ["WorldState", "SerializedPageIndex"], "category": "internal"}, {"source": "./lib/chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./lib/staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./lib/eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./hooks/useWorldDataLoader.ts", "specifiers": ["useWorldDataLoader"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/components/ChronicleIndex.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ChronicleIndex.tsx", "sourceCode": "export default function ChronicleIndex({\n  chronicles,\n  eraNarrativePages = [],\n  filter,\n  onNavigate,\n}: Readonly<ChronicleIndexProps>) {\n  const [sortMode, setSortMode] = useState(\"era_asc\");\n\n  const filtered = useMemo(() => {\n    return chronicles\n      .filter((page) => page.chronicle)\n      .filter((page) => {\n        if (filter.kind === \"all\") return true;\n        if (filter.kind === \"format\") return page.chronicle?.format === filter.format;\n        if (filter.kind === \"type\") return page.chronicle?.narrativeStyleId === filter.typeId;\n        if (filter.kind === \"era\") {\n          const focalEraId = page.chronicle?.temporalContext?.focalEra?.id;\n          if (focalEraId !== filter.eraId) return false;\n          if (filter.format && page.chronicle?.format !== filter.format) return false;\n          return true;\n        }\n        return true;\n      });\n  }, [chronicles, filter]);\n\n  const sorted = useMemo(() => {\n    const getEraInfo = (page: WikiPage) => {\n      const focalEra = page.chronicle?.temporalContext?.focalEra;\n      if (!focalEra) {\n        return { order: Number.POSITIVE_INFINITY, name: \"\", hasEra: false };\n      }\n      if (typeof focalEra.order === \"number\") {\n        return { order: focalEra.order, name: focalEra.name || \"\", hasEra: true };\n      }\n      if (typeof focalEra.startTick === \"number\") {\n        return { order: focalEra.startTick, name: focalEra.name || \"\", hasEra: true };\n      }\n      return { order: Number.POSITIVE_INFINITY, name: focalEra.name || \"\", hasEra: true };\n    };\n\n    return [...filtered].sort((a, b) => {\n      switch (sortMode) {\n        case \"era_asc\": {\n          const eraA = getEraInfo(a);\n          const eraB = getEraInfo(b);\n          if (eraA.hasEra !== eraB.hasEra) return eraA.hasEra ? -1 : 1;\n          if (eraA.order !== eraB.order) return eraA.order - eraB.order;\n          return eraA.name.localeCompare(eraB.name);\n        }\n        case \"era_desc\": {\n          const eraA = getEraInfo(a);\n          const eraB = getEraInfo(b);\n          if (eraA.hasEra !== eraB.hasEra) return eraA.hasEra ? -1 : 1;\n          if (eraA.order !== eraB.order) return eraB.order - eraA.order;\n          return eraB.name.localeCompare(eraA.name);\n        }\n        case \"updated_desc\":\n        default:\n          return (b.lastUpdated || 0) - (a.lastUpdated || 0);\n      }\n    });\n  }, [filtered, sortMode]);\n\n  // Build era narrative lookup by era name (label used in groups)\n  const eraNarrativeByEraName = useMemo(() => {\n    const map = new Map<string, WikiPage>();\n    for (const page of eraNarrativePages) {\n      if (page.eraNarrative) {\n        map.set(page.title, page); // era narrative title = era name\n      }\n    }\n    return map;\n  }, [eraNarrativePages]);\n\n  const groupedByEra = useMemo(() => {\n    const groups = new Map<\n      string,\n      { label: string; order: number; hasEra: boolean; items: WikiPage[] }\n    >();\n\n    const getEraInfo = (page: WikiPage) => {\n      const focalEra = page.chronicle?.temporalContext?.focalEra;\n      if (!focalEra) {\n        return { order: Number.POSITIVE_INFINITY, label: \"Unknown Era\", hasEra: false };\n      }\n      if (typeof focalEra.order === \"number\") {\n        return { order: focalEra.order, label: focalEra.name || \"Unknown Era\", hasEra: true };\n      }\n      if (typeof focalEra.startTick === \"number\") {\n        return { order: focalEra.startTick, label: focalEra.name || \"Unknown Era\", hasEra: true };\n      }\n      return {\n        order: Number.POSITIVE_INFINITY,\n        label: focalEra.name || \"Unknown Era\",\n        hasEra: true,\n      };\n    };\n\n    for (const page of sorted) {\n      const info = getEraInfo(page);\n      if (!groups.has(info.label)) {\n        groups.set(info.label, {\n          label: info.label,\n          order: info.order,\n          hasEra: info.hasEra,\n          items: [],\n        });\n      }\n      groups.get(info.label)?.items.push(page);\n    }\n\n    const entries = Array.from(groups.values());\n    if (sortMode === \"era_asc\" || sortMode === \"era_desc\") {\n      entries.sort((a, b) => {\n        if (a.hasEra !== b.hasEra) return a.hasEra ? -1 : 1;\n        if (a.order !== b.order) {\n          return sortMode === \"era_asc\" ? a.order - b.order : b.order - a.order;\n        }\n        return a.label.localeCompare(b.label);\n      });\n    }\n    return entries;\n  }, [sorted, sortMode]);\n\n  // Get era name for era-based filters\n  const eraName = useMemo(() => {\n    if (filter.kind !== \"era\") return null;\n    const chronicle = chronicles.find(\n      (c) => c.chronicle?.temporalContext?.focalEra?.id === filter.eraId\n    );\n    return chronicle?.chronicle?.temporalContext?.focalEra?.name || \"Unknown Era\";\n  }, [chronicles, filter]);\n\n  let heading: string;\n  if (filter.kind === \"format\") {\n    heading = filter.format === \"story\" ? \"Stories\" : \"Documents\";\n  } else if (filter.kind === \"type\") {\n    heading = `${formatChronicleSubtype(filter.typeId)} Chronicles`;\n  } else if (filter.kind === \"era\") {\n    if (filter.format === \"story\") {\n      heading = `Stories: ${eraName}`;\n    } else if (filter.format === \"document\") {\n      heading = `Documents: ${eraName}`;\n    } else {\n      heading = `Chronicles: ${eraName}`;\n    }\n  } else {\n    heading = \"Chronicles\";\n  }\n\n  let description: string;\n  if (filter.kind === \"all\") {\n    description = \"Accepted chronicles from Illuminator.\";\n  } else if (filter.kind === \"format\") {\n    const formatLabel = filter.format === \"story\" ? \"stories\" : \"documents\";\n    description = `Accepted ${formatLabel} from Illuminator.`;\n  } else if (filter.kind === \"era\") {\n    if (filter.format) {\n      const eraFormatLabel = filter.format === \"story\" ? \"Stories\" : \"Documents\";\n      description = `${eraFormatLabel} set during the ${eraName}.`;\n    } else {\n      description = `Chronicles set during the ${eraName}.`;\n    }\n  } else {\n    description = `Accepted chronicles of type ${formatChronicleSubtype(filter.typeId)}.`;\n  }\n\n  if (sorted.length === 0) {\n    return (\n      <div className={styles.container}>\n        <h1 className={styles.heading}>{heading}</h1>\n        <p className={styles.description}>{description}</p>\n        <div className={styles.empty}>No chronicles found.</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <h1 className={styles.heading}>{heading}</h1>\n      <div className={styles.descriptionRow}>\n        <p className={styles.description}>{description}</p>\n        <div className={styles.controls}>\n          <div className={styles.sortControl}>\n            <span className={styles.sortLabel}>Sort</span>\n            <select\n              className={styles.sortSelect}\n              value={sortMode}\n              onChange={(event) => setSortMode(event.target.value)}\n            >\n              {SORT_OPTIONS.map((option) => (\n                <option key={option.value} value={option.value}>\n                  {option.label}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      </div>\n\n      <div className={styles.list}>\n        {groupedByEra.map((group) => (\n          <div key={group.label} className={styles.group}>\n            <div className={styles.groupHeader}>{group.label}</div>\n            <div className={styles.groupItems}>\n              {/* Era narrative at the top of the group */}\n              {eraNarrativeByEraName.has(group.label) &&\n                (() => {\n                  const narrativePage = eraNarrativeByEraName.get(group.label)!;\n                  const thesis = narrativePage.content?.summary || \"\";\n                  return (\n                    <button\n                      key={narrativePage.id}\n                      className={styles.item}\n                      onClick={() => onNavigate(narrativePage.id)}\n                    >\n                      <div className={styles.itemHeader}>\n                        <span className={styles.itemTitle}>{narrativePage.title}</span>\n                        <div className={styles.badgeGroup}>\n                          <span className={styles.badge}>Era Narrative</span>\n                          <span className={styles.badgeSecondary}>synthetic</span>\n                        </div>\n                      </div>\n                      {thesis && <div className={styles.itemSummary}>{thesis}</div>}\n                    </button>\n                  );\n                })()}\n              {group.items.map((page) => {\n                const eraLabel = page.chronicle?.temporalContext?.focalEra?.name || \"Unknown Era\";\n                const isMultiEra = page.chronicle?.temporalContext?.isMultiEra;\n                const formatLabel = page.chronicle?.format === \"document\" ? \"Document\" : \"Story\";\n                const subtypeLabel = page.chronicle?.narrativeStyleId\n                  ? formatChronicleSubtype(page.chronicle.narrativeStyleId)\n                  : null;\n                const primaryEntities = (page.chronicle?.roleAssignments || [])\n                  .filter((role) => role.isPrimary)\n                  .map((role) => role.entityName)\n                  .filter(Boolean);\n                const primaryLabel = primaryEntities.length > 0 ? primaryEntities.join(\", \") : null;\n                const summary = page.content?.summary || \"\";\n\n                return (\n                  <button key={page.id} className={styles.item} onClick={() => onNavigate(page.id)}>\n                    <div className={styles.itemHeader}>\n                      <span className={styles.itemTitle}>{page.title}</span>\n                      <div className={styles.badgeGroup}>\n                        <span className={styles.badge}>{formatLabel}</span>\n                        {subtypeLabel && (\n                          <span className={styles.badgeSecondary}>{subtypeLabel}</span>\n                        )}\n                      </div>\n                    </div>\n                    <div className={styles.itemMeta}>\n                      <span>Era: {eraLabel}</span>\n                      {isMultiEra && <span>Multi-era</span>}\n                      {primaryLabel && <span>Primary: {primaryLabel}</span>}\n                    </div>\n                    {summary && <div className={styles.itemSummary}>{summary}</div>}\n                  </button>\n                );\n              })}\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  chronicles,\n  eraNarrativePages = [],\n  filter,\n  onNavigate,\n}", "type": "Readonly<ChronicleIndexProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WikiPage"], "category": "internal"}, {"source": "./ChronicleIndex.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/ChroniclerStatusScreen.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ChroniclerStatusScreen.tsx", "sourceCode": "export default function ChroniclerStatusScreen({\n  loading,\n  loadError,\n}: Readonly<ChroniclerStatusScreenProps>) {\n  if (loading) {\n    return (\n      <div className={styles.container}>\n        <div className={styles.content}>\n          <div className={styles.title}>Loading World Data</div>\n          <div className={styles.detail}>Reading from local storage...</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (loadError) {\n    return (\n      <div className={styles.container}>\n        <div className={styles.content}>\n          <div className={styles.icon}>&#x2756;</div>\n          <div className={styles.title}>World Data Unavailable</div>\n          <div className={styles.detail}>{loadError}</div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.content}>\n        <div className={styles.icon}>&#x2756;</div>\n        <div className={styles.title}>No World Data</div>\n        <div className={styles.detail}>\n          Run a simulation in Lore Weave and enrich it with Illuminator to view the world chronicle.\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  loading,\n  loadError,\n}", "type": "Readonly<ChroniclerStatusScreenProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./ChroniclerStatusScreen.module.css", "specifiers": ["styles"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/components/EntityTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/EntityTimeline.tsx", "sourceCode": "export default function EntityTimeline({\n  events,\n  entityId,\n  entityIndex,\n  onNavigate,\n  onHoverEnter,\n  onHoverLeave,\n  loading = false,\n}: Readonly<EntityTimelineProps>) {\n  // Multi-expand state: set of expanded event IDs\n  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());\n  // Whether to show prominence-only events (default: hidden)\n  const [showProminenceOnly, setShowProminenceOnly] = useState(false);\n\n  /**\n   * Check if an event is \"prominence-only\" for this entity.\n   * An event is prominence-only if ALL of its effects for this entity\n   * are field_changed effects on the 'prominence' field.\n   */\n  const isProminenceOnlyEvent = useCallback(\n    (event: NarrativeEvent): boolean => {\n      const participant = event.participantEffects?.find((p) => p.entity.id === entityId);\n      if (!participant || participant.effects.length === 0) return false;\n\n      // Check if ALL effects are prominence field changes\n      return participant.effects.every(\n        (effect) => effect.type === \"field_changed\" && effect.field === \"prominence\"\n      );\n    },\n    [entityId]\n  );\n\n  // Filter and process events for this entity\n  const relevantEvents = useMemo(() => {\n    return events\n      .filter((event) => {\n        // Check if entity appears in participantEffects\n        if (!event.participantEffects?.some((p) => p.entity.id === entityId)) {\n          return false;\n        }\n        // Exclude prominence-only events unless checkbox is checked\n        if (!showProminenceOnly && isProminenceOnlyEvent(event)) {\n          return false;\n        }\n        return true;\n      })\n      .sort((a, b) => a.tick - b.tick); // Chronological order\n  }, [events, entityId, isProminenceOnlyEvent, showProminenceOnly]);\n\n  // Get participant effects for the current entity\n  const getEntityEffects = useCallback(\n    (event: NarrativeEvent): EntityEffect[] => {\n      const participant = event.participantEffects?.find((p) => p.entity.id === entityId);\n      return participant?.effects ?? [];\n    },\n    [entityId]\n  );\n\n  // Toggle expand state for an event\n  const toggleExpand = useCallback((eventId: string) => {\n    setExpandedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(eventId)) {\n        next.delete(eventId);\n      } else {\n        next.add(eventId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Get era name from entity index\n  const getEraName = useCallback(\n    (eraId: string): string => {\n      const era = entityIndex.get(eraId);\n      return era?.name ?? eraId;\n    },\n    [entityIndex]\n  );\n\n  // Build linkable entities list for entity linking\n  const linkableEntities = useMemo(() => {\n    return Array.from(entityIndex.values()).map((e) => ({ name: e.name, id: e.id }));\n  }, [entityIndex]);\n\n  // Render description with wiki links\n  const renderDescription = useCallback(\n    // eslint-disable-next-line sonarjs/function-return-type -- returns React.ReactNode by design\n    (event: NarrativeEvent): React.ReactNode => {\n      const description = event.description || \"\";\n      return linkifyText(description, linkableEntities, onNavigate, {\n        linkStyle: entityLinkStyle,\n        onHoverEnter,\n        onHoverLeave,\n      });\n    },\n    [linkableEntities, onNavigate, onHoverEnter, onHoverLeave]\n  );\n\n  if (relevantEvents.length === 0 && !showProminenceOnly) {\n    return (\n      <div className={styles.container}>\n        <label className={styles.filterRow}>\n          <input\n            type=\"checkbox\"\n            checked={showProminenceOnly}\n            onChange={(e) => setShowProminenceOnly(e.target.checked)}\n            className={styles.checkbox}\n          />\n          <span className={styles.checkboxLabel}>Show prominence-only events</span>\n        </label>\n        <div className={styles.emptyState}>\n          {loading\n            ? \"Loading narrative history...\"\n            : \"No timeline events recorded for this entity.\"}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <label className={styles.filterRow}>\n        <input\n          type=\"checkbox\"\n          checked={showProminenceOnly}\n          onChange={(e) => setShowProminenceOnly(e.target.checked)}\n          className={styles.checkbox}\n        />\n        <span className={styles.checkboxLabel}>Show prominence-only events</span>\n      </label>\n      <table className={styles.table}>\n        <thead>\n          <tr className={styles.headerRow}>\n            <th className={styles.thTick}>Tick</th>\n            <th className={styles.thEra}>Era</th>\n            <th className={styles.th}>Event</th>\n            <th className={styles.thExpand}></th>\n          </tr>\n        </thead>\n        <tbody>\n          {relevantEvents.map((event) => {\n            const isExpanded = expandedIds.has(event.id);\n            const effects = getEntityEffects(event);\n            const canExpand = effects.length > 0;\n\n            return (\n              <React.Fragment key={event.id}>\n                {/* Main event row */}\n                <tr\n                  className={isExpanded ? styles.rowExpanded : styles.row}\n                  onClick={() => canExpand && toggleExpand(event.id)}\n                >\n                  <td className={`${styles.td} ${styles.tdTick}`}>{event.tick}</td>\n                  <td className={`${styles.td} ${styles.tdEra}`}>{getEraName(event.era)}</td>\n                  <td\n                    className={`${styles.td} ${styles.tdEvent} ${getWeightClass(getWeightTier(event.significance ?? 0.5))}`}\n                  >\n                    {renderDescription(event)}\n                  </td>\n                  <td className={`${styles.td} ${styles.tdExpand}`}>\n                    {canExpand && (\n                      <span\n                        className={`${styles.expandIcon} ${isExpanded ? styles.expandIconOpen : \"\"}`}\n                      >\n                        \u25b6\n                      </span>\n                    )}\n                  </td>\n                </tr>\n\n                {/* Expanded effects row */}\n                {isExpanded && (\n                  <tr className={styles.effectsRow}>\n                    <td colSpan={4} className={styles.effectsCell}>\n                      {effects.length > 0 ? (\n                        <ul className={styles.effectsList}>\n                          {effects.map((effect, idx) => {\n                            const { icon, colorClass } = getEffectStyle(effect.type);\n                            return (\n                              <li key={idx} className={styles.effectItem}>\n                                <span className={`${styles.effectIcon} ${colorClass}`}>{icon}</span>\n                                <span className={styles.effectDescription}>\n                                  {linkifyText(effect.description, linkableEntities, onNavigate, {\n                                    linkStyle: entityLinkStyle,\n                                    onHoverEnter,\n                                    onHoverLeave,\n                                  })}\n                                </span>\n                              </li>\n                            );\n                          })}\n                        </ul>\n                      ) : (\n                        <span className={styles.noEffects}>No specific effects recorded</span>\n                      )}\n                    </td>\n                  </tr>\n                )}\n              </React.Fragment>\n            );\n          })}\n        </tbody>\n      </table>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  events,\n  entityId,\n  entityIndex,\n  onNavigate,\n  onHoverEnter,\n  onHoverLeave,\n  loading = false,\n}", "type": "Readonly<EntityTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeEvent", "EntityEffect"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["HardState"], "category": "internal"}, {"source": "../lib/entityLinking.ts", "specifiers": ["linkifyText"], "category": "internal"}, {"source": "./EntityTimeline.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/ImageLightbox.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ImageLightbox.tsx", "sourceCode": "export default function ImageLightbox({\n  isOpen,\n  imageUrl,\n  title,\n  summary,\n  onClose,\n}: Readonly<ImageLightboxProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: MouseEvent<HTMLDivElement>) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: MouseEvent<HTMLDivElement>) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (!isOpen) return undefined;\n    document.addEventListener(\"keydown\", handleKeyDown);\n    const previousOverflow = document.body.style.overflow;\n    document.body.style.overflow = \"hidden\";\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = previousOverflow;\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen || !imageUrl) return null;\n\n  return (\n    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions, jsx-a11y/no-noninteractive-tabindex -- dialog overlay needs interaction handlers\n    <div\n      className={styles.overlay}\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={title || \"Image viewer\"}\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <button onClick={onClose} className={styles.closeButton}>\n        Close\n      </button>\n      <div className={styles.content}>\n        <img src={imageUrl} alt={title || \"Expanded view\"} className={styles.image} />\n        <div className={styles.caption}>\n          {title && <div className={styles.title}>{title}</div>}\n          {summary && <div className={styles.summary}>{summary}</div>}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  imageUrl,\n  title,\n  summary,\n  onClose,\n}", "type": "Readonly<ImageLightboxProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "react", "specifiers": ["MouseEvent"], "category": "framework"}, {"source": "./ImageLightbox.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/ProminenceTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ProminenceTimeline.tsx", "sourceCode": "export default function ProminenceTimeline({\n  events,\n  entityId,\n  initialProminence = 2.5,\n  prominenceScale,\n}: Readonly<ProminenceTimelineProps>) {\n  const [hoveredPoint, setHoveredPoint] = useState<{\n    point: ProminenceDataPoint;\n    x: number;\n    y: number;\n  } | null>(null);\n\n  // Extract prominence data from events\n  const dataPoints = useMemo(\n    () => extractProminenceData(events, entityId, initialProminence, prominenceScale),\n    [events, entityId, initialProminence, prominenceScale]\n  );\n  const prominenceLevels = useMemo(() => {\n    return prominenceScale.labels.map((label, index) => ({\n      threshold: index === 0 ? prominenceScale.min : prominenceScale.thresholds[index - 1],\n      label,\n      color: PROMINENCE_COLORS[label as keyof typeof PROMINENCE_COLORS],\n    }));\n  }, [prominenceScale]);\n\n  // Calculate graph dimensions and scales\n  const graphMetrics = useMemo(() => {\n    if (dataPoints.length === 0) {\n      return null;\n    }\n\n    // Start line from first data point (entity's initial prominence), not tick 0\n    // First point is the previousValue at the first event tick, then each subsequent newValue\n    const firstPoint = { tick: dataPoints[0].tick, value: dataPoints[0].previousValue };\n    const allPoints = [firstPoint, ...dataPoints.map((p) => ({ tick: p.tick, value: p.newValue }))];\n\n    // Ribbon spans full era, but line only starts from first event\n    const minTick = 0;\n    const maxTick = Math.max(...allPoints.map((p) => p.tick), 1);\n    const minValue = 0;\n    const maxValue = 5;\n\n    // Graph dimensions (full width ribbon)\n    const leftPadding = 0;\n    const rightPadding = 0;\n    const topPadding = 0;\n    const bottomPadding = 0;\n\n    return {\n      allPoints,\n      minTick,\n      maxTick,\n      minValue,\n      maxValue,\n      leftPadding,\n      rightPadding,\n      topPadding,\n      bottomPadding,\n      xScale: (tick: number) =>\n        leftPadding + ((tick - minTick) / (maxTick - minTick)) * (100 - leftPadding - rightPadding),\n      yScale: (value: number) =>\n        topPadding +\n        ((maxValue - value) / (maxValue - minValue)) * (100 - topPadding - bottomPadding),\n    };\n  }, [dataPoints]);\n\n  // Find threshold crossings\n  const thresholdCrossings = useMemo(() => {\n    return dataPoints.filter((p) => p.crossesThreshold !== null);\n  }, [dataPoints]);\n\n  // Build SVG path for the line\n  const linePath = useMemo(() => {\n    if (!graphMetrics || graphMetrics.allPoints.length === 0) return \"\";\n\n    const points = graphMetrics.allPoints;\n    const pathParts: string[] = [];\n\n    // Start at first point\n    pathParts.push(\n      `M ${graphMetrics.xScale(points[0].tick)} ${graphMetrics.yScale(points[0].value)}`\n    );\n\n    // Step line (horizontal then vertical to show discrete changes)\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      // Horizontal line to new tick\n      pathParts.push(`L ${graphMetrics.xScale(curr.tick)} ${graphMetrics.yScale(prev.value)}`);\n      // Vertical line to new value\n      pathParts.push(`L ${graphMetrics.xScale(curr.tick)} ${graphMetrics.yScale(curr.value)}`);\n    }\n\n    return pathParts.join(\" \");\n  }, [graphMetrics]);\n\n  // Handle point hover\n  const handlePointHover = useCallback(\n    (point: ProminenceDataPoint | null, e?: React.MouseEvent) => {\n      if (point && e) {\n        const rect = (e.target as SVGElement).closest(\"svg\")?.getBoundingClientRect();\n        if (rect) {\n          setHoveredPoint({\n            point,\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n          });\n        }\n      } else {\n        setHoveredPoint(null);\n      }\n    },\n    []\n  );\n\n  const resolveLabel = (value: number) => prominenceLabelFromScale(value, prominenceScale);\n  const resolveColor = (value: number) => {\n    const label = resolveLabel(value);\n    return PROMINENCE_COLORS[label as keyof typeof PROMINENCE_COLORS];\n  };\n\n  if (dataPoints.length === 0) {\n    return null; // Don't render anything if no prominence changes\n  }\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.title}>Prominence Over Time</div>\n\n      <div className={styles.graphContainer}>\n        <svg className={styles.svg} viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n          {graphMetrics && (\n            <>\n              {/* Background level bands */}\n              {prominenceLevels.map((level, i) => {\n                const nextThreshold = prominenceLevels[i + 1]?.threshold ?? prominenceScale.max;\n                return (\n                  <rect\n                    key={level.label}\n                    x={0}\n                    y={graphMetrics.yScale(nextThreshold)}\n                    width={100}\n                    height={\n                      graphMetrics.yScale(level.threshold) - graphMetrics.yScale(nextThreshold)\n                    }\n                    fill={level.color}\n                    opacity={0.1}\n                  />\n                );\n              })}\n\n              {/* Horizontal grid lines for each level threshold */}\n              {prominenceScale.thresholds.map((threshold) => (\n                <line\n                  key={`grid-${threshold}`}\n                  x1={0}\n                  y1={graphMetrics.yScale(threshold)}\n                  x2={100}\n                  y2={graphMetrics.yScale(threshold)}\n                  stroke={graphColors.levelLine}\n                  strokeWidth={0.2}\n                />\n              ))}\n\n              {/* Main line */}\n              <path\n                d={linePath}\n                fill=\"none\"\n                stroke={graphColors.line}\n                strokeWidth={0.8}\n                vectorEffect=\"non-scaling-stroke\"\n              />\n\n              {/* Threshold crossing markers (vertical lines) */}\n              {thresholdCrossings.map((point, i) => (\n                <g key={`crossing-${i}`}>\n                  <line\n                    x1={graphMetrics.xScale(point.tick)}\n                    y1={0}\n                    x2={graphMetrics.xScale(point.tick)}\n                    y2={100}\n                    stroke={graphColors.marker}\n                    strokeWidth={0.5}\n                    opacity={0.7}\n                  />\n                </g>\n              ))}\n\n              {/* Data points - only show threshold crossings as dots */}\n              {thresholdCrossings.map((point, i) => (\n                <circle\n                  key={`point-${i}`}\n                  cx={graphMetrics.xScale(point.tick)}\n                  cy={graphMetrics.yScale(point.newValue)}\n                  r={2}\n                  fill={graphColors.marker}\n                  className={styles.dataPoint}\n                  onMouseEnter={(e) => handlePointHover(point, e)}\n                  onMouseLeave={() => handlePointHover(null)}\n                />\n              ))}\n            </>\n          )}\n        </svg>\n\n        {/* Tooltip - shows narrative description on hover */}\n        {hoveredPoint && (\n          <div\n            className={styles.tooltip}\n            // eslint-disable-next-line local/no-inline-styles -- dynamic position from mouse event\n            style={\n              {\n                \"--tooltip-left\": `${hoveredPoint.x + 10}px`,\n                \"--tooltip-top\": `${hoveredPoint.y - 40}px`,\n              } as React.CSSProperties\n            }\n          >\n            <div className={styles.tooltipValue}>\n              { }\n              <span\n                style={\n                  {\n                    \"--prominence-color\": resolveColor(hoveredPoint.point.previousValue),\n                  } as React.CSSProperties\n                }\n                className={styles.transitionColor}\n              >\n                {resolveLabel(hoveredPoint.point.previousValue)}\n              </span>\n              { }\n              <span\n                style={{ \"--prominence-color\": graphColors.textMuted } as React.CSSProperties}\n                className={styles.transitionColor}\n              >\n                &rarr;\n              </span>\n              { }\n              <span\n                style={\n                  {\n                    \"--prominence-color\": resolveColor(hoveredPoint.point.newValue),\n                  } as React.CSSProperties\n                }\n                className={styles.transitionColor}\n              >\n                {resolveLabel(hoveredPoint.point.newValue)}\n              </span>\n            </div>\n            <div className={styles.tooltipDescription}>{hoveredPoint.point.description}</div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  events,\n  entityId,\n  initialProminence = 2.5,\n  prominenceScale,\n}", "type": "Readonly<ProminenceTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "ProminenceScale", "NarrativeEvent"], "category": "external"}, {"source": "./ProminenceTimeline.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/WikiExplorer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiExplorer.tsx", "sourceCode": "export default function WikiExplorer({\n  projectId,\n  worldData,\n  loreData,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}: Readonly<WikiExplorerProps>) {\n  // Initialize from hash on mount\n  const [currentPageId, setCurrentPageId] = useState<string | null>(() => parseHashPageId());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n\n  // Responsive layout\n  const breakpoint = useBreakpoint();\n  const isMobile = breakpoint === \"mobile\";\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\n\n  // Chronicles and static pages: use preloaded data when available, else load from IndexedDB\n  const [chronicles, setChronicles] = useState<ChronicleRecord[]>(() =>\n    preloadedChronicles ? normalizeChronicles(preloadedChronicles) : []\n  );\n  const [staticPages, setStaticPages] = useState<StaticPage[]>(() =>\n    preloadedStaticPages ? normalizeStaticPages(preloadedStaticPages) : []\n  );\n  const [eraNarratives, setEraNarratives] = useState<EraNarrativeViewRecord[]>(\n    () => preloadedEraNarratives ?? []\n  );\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [parchmentConfig] = useState<ParchmentConfig>(() => ({ ...DEFAULT_PARCHMENT_CONFIG }));\n  const simulationRunId = (worldData as { metadata?: { simulationRunId?: string } }).metadata\n    ?.simulationRunId;\n\n  // Load chronicles from IndexedDB when simulationRunId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedChronicles) return;\n    if (!simulationRunId) {\n      setChronicles([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadChronicles() {\n      try {\n        const loadedChronicles = await getCompletedChroniclesForSimulation(simulationRunId!);\n        if (!cancelled) {\n          setChronicles(normalizeChronicles(loadedChronicles));\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load chronicles:\", err);\n        if (!cancelled) {\n          setChronicles([]);\n        }\n      }\n    }\n\n    void loadChronicles();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedChronicles, simulationRunId]);\n\n  // Load static pages from IndexedDB when projectId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedStaticPages) return;\n    if (!projectId) {\n      setStaticPages([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadStaticPages() {\n      try {\n        const loadedPages = await getPublishedStaticPagesForProject(projectId!);\n        if (!cancelled) {\n          setStaticPages(normalizeStaticPages(loadedPages));\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load static pages:\", err);\n        if (!cancelled) {\n          setStaticPages([]);\n        }\n      }\n    }\n\n    void loadStaticPages();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedStaticPages, projectId]);\n\n  // Load era narratives from IndexedDB when simulationRunId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedEraNarratives) return;\n    if (!simulationRunId) {\n      setEraNarratives([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadEraNarratives() {\n      try {\n        const loaded = await getCompletedEraNarrativesForSimulation(simulationRunId!);\n        if (!cancelled) {\n          setEraNarratives(loaded);\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load era narratives:\", err);\n        if (!cancelled) {\n          setEraNarratives([]);\n        }\n      }\n    }\n\n    void loadEraNarratives();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedEraNarratives, simulationRunId]);\n\n  // Validate world data before building index\n  // Returns first validation error found, or null if valid\n  const dataError = useMemo((): { message: string; details: string } | null => {\n    for (const entity of worldData.hardState) {\n      // Validate prominence is numeric\n      if (typeof entity.prominence !== \"number\") {\n        const prom: unknown = entity.prominence;\n        return {\n          message: \"Invalid entity data format\",\n          details:\n            `Entity \"${entity.name}\" (${entity.id}) has prominence=\"${String(prom)}\" (${typeof prom}). ` +\n            `Expected a number (0-5). The saved simulation data may be from an older format.`,\n        };\n      }\n    }\n    return null;\n  }, [worldData]);\n\n  const prominenceScale = useMemo(() => {\n    if (dataError) {\n      return buildProminenceScale([], { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n    }\n    const values = worldData.hardState\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [worldData, dataError]);\n\n  // Build lightweight page index (fast) - only if data is valid\n  // When precomputedPageIndex is provided, deserialize it instead of computing from scratch\n  const { pageIndex, entityIndex } = useMemo(() => {\n    if (dataError) {\n      return {\n        pageIndex: {\n          entries: [],\n          byId: new Map<string, PageIndexEntry>(),\n          byName: new Map<string, string>(),\n          byAlias: new Map<string, string>(),\n          bySlug: new Map<string, string>(),\n          categories: [],\n          byBaseName: new Map<string, DisambiguationEntry[]>(),\n        } satisfies WikiPageIndex,\n        entityIndex: new Map<string, HardState>(),\n      };\n    }\n    const idx = precomputedPageIndex\n      ? deserializePageIndex(precomputedPageIndex)\n      : buildPageIndex(\n          worldData,\n          loreData,\n          chronicles,\n          staticPages,\n          prominenceScale,\n          eraNarratives\n        );\n    const entityIdx = new Map<string, HardState>();\n    for (const entity of worldData.hardState) {\n      entityIdx.set(entity.id, entity);\n    }\n    return { pageIndex: idx, entityIndex: entityIdx };\n  }, [\n    worldData,\n    loreData,\n    chronicles,\n    staticPages,\n    dataError,\n    prominenceScale,\n    precomputedPageIndex,\n    eraNarratives,\n  ]);\n\n  const resolvePageId = useCallback(\n    (pageId: string | null): string | null => {\n      if (!pageId) return null;\n      if (pageIndex.byId.has(pageId)) return pageId;\n      const resolved = pageIndex.bySlug.get(pageId);\n      return resolved ?? pageId;\n    },\n    [pageIndex]\n  );\n\n  const resolveUrlId = useCallback(\n    (pageId: string | null): string | null => {\n      if (!pageId) return null;\n      const resolvedId = resolvePageId(pageId);\n      if (!resolvedId) return pageId;\n      const entry = pageIndex.byId.get(resolvedId);\n      const shouldUseSlug =\n        entry &&\n        (entry.type === \"entity\" ||\n          entry.type === \"chronicle\" ||\n          entry.type === \"static\" ||\n          entry.type === \"era_narrative\");\n      return shouldUseSlug && entry?.slug ? entry.slug : pageId;\n    },\n    [pageIndex, resolvePageId]\n  );\n\n  // Sync hash changes to state (for back/forward buttons)\n  useEffect(() => {\n    const handleHashChange = () => {\n      const rawPageId = parseHashPageId();\n      const pageId = resolvePageId(rawPageId);\n      setCurrentPageId(pageId);\n      setSearchQuery(\"\");\n\n      if (rawPageId) {\n        const canonicalUrlId = resolveUrlId(rawPageId);\n        if (canonicalUrlId) {\n          const canonicalHash = buildPageHash(canonicalUrlId);\n          if (window.location.hash !== canonicalHash) {\n            window.history.replaceState(null, \"\", canonicalHash);\n          }\n        }\n      }\n    };\n\n    handleHashChange();\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [resolvePageId, resolveUrlId]);\n\n  // Handle external navigation requests (e.g., from Archivist)\n  // Use useLayoutEffect to update state synchronously before paint, avoiding flash of home page\n  useLayoutEffect(() => {\n    if (!requestedPageId) return;\n\n    // Update state immediately (before paint)\n    const resolvedPageId = resolvePageId(requestedPageId);\n    setCurrentPageId(resolvedPageId);\n    setSearchQuery(\"\");\n\n    // Update hash (this will be picked up by hashchange listener for future back navigation)\n    const urlId = resolveUrlId(requestedPageId) ?? requestedPageId;\n    const newHash = buildPageHash(urlId);\n    if (window.location.hash !== newHash) {\n      window.location.hash = newHash;\n    }\n\n    // Signal that the request has been handled\n    onRequestedPageConsumed?.();\n  }, [requestedPageId, onRequestedPageConsumed, resolvePageId, resolveUrlId]);\n\n  // Page cache - stores fully built pages by ID\n  // Use useMemo to create a NEW cache when data changes, ensuring synchronous invalidation\n  // (useEffect runs after render, which causes stale cache reads when chunks load)\n  const pageCache = useMemo(\n    () => new Map<string, WikiPage>(),\n    [worldData, loreData, chronicles, staticPages, eraNarratives]\n  );\n\n  // Get a page from cache or build it on-demand\n  const getPage = useCallback(\n    (pageId: string): WikiPage | null => {\n      // Resolve slug to canonical ID for consistent caching\n      const canonicalId = pageIndex.byId.has(pageId)\n        ? pageId\n        : (pageIndex.bySlug.get(pageId) ?? pageId);\n\n      if (pageCache.has(canonicalId)) {\n        return pageCache.get(canonicalId)!;\n      }\n\n      const page = buildPageById(\n        canonicalId,\n        worldData,\n        loreData,\n        null,\n        pageIndex,\n        chronicles,\n        staticPages,\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  worldData,\n  loreData,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}", "type": "Readonly<WikiExplorerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect", "useLayoutEffect", "useCallback"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "WikiPage", "WikiPageIndex", "HardState", "SerializedPageIndex", "PageIndexEntry", "DisambiguationEntry"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "../lib/wikiBuilder.ts", "specifiers": ["buildPageIndex", "buildPageById"], "category": "internal"}, {"source": "../lib/chronicleStorage.ts", "specifiers": ["getCompletedChroniclesForSimulation", "ChronicleRecord"], "category": "internal"}, {"source": "../lib/staticPageStorage.ts", "specifiers": ["getPublishedStaticPagesForProject", "StaticPage"], "category": "internal"}, {"source": "../lib/eraNarrativeStorage.ts", "specifiers": ["getCompletedEraNarrativesForSimulation", "EraNarrativeViewRecord"], "category": "internal"}, {"source": "../hooks/useBreakpoint.ts", "specifiers": ["useBreakpoint"], "category": "internal"}, {"source": "./WikiNav.tsx", "specifiers": ["WikiNav"], "category": "internal"}, {"source": "./ChronicleIndex.tsx", "specifiers": ["ChronicleIndex"], "category": "internal"}, {"source": "./WikiPage.tsx", "specifiers": ["WikiPageView"], "category": "internal"}, {"source": "./ImageLightbox.tsx", "specifiers": ["ImageLightbox"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./Ornaments.tsx", "specifiers": ["ParchmentTexture", "PageFrame", "DEFAULT_PARCHMENT_CONFIG", "ParchmentConfig"], "category": "internal"}, {"source": "./WikiExplorer.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/WikiNav.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiNav.tsx", "sourceCode": "export default function WikiNav({\n  categories,\n  pages,\n  chronicles,\n  staticPages,\n  currentPageId,\n  searchQuery,\n  onSearchQueryChange,\n  onNavigate,\n  onGoHome,\n  onRefreshIndex,\n  isRefreshing,\n  isDrawer,\n  onCloseDrawer,\n}: Readonly<WikiNavProps>) {\n  // Collapsible section state\n  const [loreExpanded, setLoreExpanded] = useState(false);\n  const [expandedEras, setExpandedEras] = useState<Set<string>>(new Set());\n  const [appendicesExpanded, setAppendicesExpanded] = useState(false);\n\n  // Get top categories for quick access (entity kinds)\n  const topCategories = categories.filter((c) => c.id.startsWith(\"kind-\")).slice(0, 10);\n\n  // Organize static pages by namespace\n  const frontMatterPages: WikiPage[] = [];\n  const lorePages: WikiPage[] = [];\n  const culturePages: WikiPage[] = [];\n  const systemPages: WikiPage[] = [];\n  const otherPages: WikiPage[] = [];\n\n  for (const page of staticPages) {\n    const title = page.title;\n    // Front matter: specific key pages\n    if (title === \"Lore:Foreword to the Annotated Chronicle\") {\n      frontMatterPages.unshift(page); // Foreword first\n    } else if (title === \"System:About This Project\") {\n      frontMatterPages.push(page); // About second\n    } else if (title.startsWith(\"Lore:\")) {\n      lorePages.push(page);\n    } else if (title.startsWith(\"Cultures:\")) {\n      culturePages.push(page);\n    } else if (title.startsWith(\"System:\")) {\n      systemPages.push(page);\n    } else {\n      otherPages.push(page);\n    }\n  }\n\n  // Sort lore pages alphabetically by title (without prefix)\n  lorePages.sort((a, b) =>\n    a.title.replace(\"Lore:\", \"\").localeCompare(b.title.replace(\"Lore:\", \"\"))\n  );\n  culturePages.sort((a, b) =>\n    a.title.replace(\"Cultures:\", \"\").localeCompare(b.title.replace(\"Cultures:\", \"\"))\n  );\n  systemPages.sort((a, b) =>\n    a.title.replace(\"System:\", \"\").localeCompare(b.title.replace(\"System:\", \"\"))\n  );\n\n  // Random page function\n  const handleRandomPage = () => {\n    const entityPages = pages.filter((p) => p.type === \"entity\" || p.type === \"era\");\n    if (entityPages.length > 0) {\n      // eslint-disable-next-line sonarjs/pseudo-random -- non-security random page selection\n      const randomIndex = Math.floor(Math.random() * entityPages.length);\n      onNavigate(entityPages[randomIndex].id);\n    }\n  };\n\n  const chroniclePages = chronicles.filter((page) => page.chronicle);\n  const storyChronicles = chroniclePages.filter((page) => page.chronicle?.format === \"story\");\n  const documentChronicles = chroniclePages.filter((page) => page.chronicle?.format === \"document\");\n\n  // Build era narrative lookup from all pages (eraId -> page)\n  const eraNarrativeByEraId = new Map<string, WikiPage>();\n  for (const page of pages) {\n    if (page.type === \"era_narrative\" && page.eraNarrative?.eraId) {\n      eraNarrativeByEraId.set(page.eraNarrative.eraId, page);\n    }\n  }\n\n  // Group chronicles by era\n  const chroniclesByEra = chroniclePages.reduce((groups, page) => {\n    const focalEra = page.chronicle?.temporalContext?.focalEra;\n    const eraId = focalEra?.id || \"unknown\";\n    const eraName = focalEra?.name || \"Unknown Era\";\n    const eraOrder = focalEra?.order ?? focalEra?.startTick ?? Infinity;\n\n    if (!groups.has(eraId)) {\n      groups.set(eraId, { eraId, eraName, eraOrder, stories: [], documents: [], all: [] });\n    }\n\n    const group = groups.get(eraId)!;\n    group.all.push(page);\n    if (page.chronicle?.format === \"story\") {\n      group.stories.push(page);\n    } else if (page.chronicle?.format === \"document\") {\n      group.documents.push(page);\n    }\n\n    return groups;\n  }, new Map<string, { eraId: string; eraName: string; eraOrder: number; stories: WikiPage[]; documents: WikiPage[]; all: WikiPage[] }>());\n\n  // Sort eras chronologically (by order or startTick)\n  const sortedEras = Array.from(chroniclesByEra.values()).sort((a, b) => a.eraOrder - b.eraOrder);\n\n  const toggleEra = (eraId: string) => {\n    setExpandedEras((prev) => {\n      const next = new Set(prev);\n      if (next.has(eraId)) {\n        next.delete(eraId);\n      } else {\n        next.add(eraId);\n      }\n      return next;\n    });\n  };\n\n  return (\n    <div className={styles.container}>\n      {/* Drawer header with close button (mobile only) */}\n      {isDrawer && (\n        <div className={styles.drawerHeader}>\n          <span className={styles.drawerTitle}>Navigation</span>\n          <button\n            onClick={onCloseDrawer}\n            className={styles.drawerClose}\n            aria-label=\"Close navigation\"\n          >\n            \u00d7\n          </button>\n        </div>\n      )}\n\n      <nav className={styles.nav}>\n        {/* FRONT MATTER - Key introductory pages */}\n        {frontMatterPages.length > 0 && (\n          <div className={styles.section}>\n            {frontMatterPages.map((page) => {\n              const isActive = currentPageId === page.id;\n              // Display name without namespace prefix\n              const displayName = page.title.includes(\":\") ? page.title.split(\":\")[1] : page.title;\n              return (\n                <button\n                  key={page.id}\n                  className={isActive ? styles.navItemActive : styles.navItem}\n                  onClick={() => onNavigate(page.id)}\n                >\n                  {displayName}\n                </button>\n              );\n            })}\n          </div>\n        )}\n\n        {/* LORE - World essays and background (collapsible) */}\n        {lorePages.length > 0 && (\n          <div className={styles.section}>\n            <button\n              className={styles.sectionTitleCollapsible}\n              onClick={() => setLoreExpanded(!loreExpanded)}\n              aria-expanded={loreExpanded}\n            >\n              <span className={styles.collapseIcon}>{loreExpanded ? \"\u25bc\" : \"\u25b6\"}</span>\n              Lore\n              <span className={styles.badge}>({lorePages.length})</span>\n            </button>\n            {loreExpanded &&\n              lorePages.map((page) => {\n                const isActive = currentPageId === page.id;\n                const displayName = page.title.replace(\"Lore:\", \"\");\n                return (\n                  <button\n                    key={page.id}\n                    className={isActive ? styles.navItemActive : styles.navItem}\n                    onClick={() => onNavigate(page.id)}\n                  >\n                    {displayName}\n                  </button>\n                );\n              })}\n          </div>\n        )}\n\n        {/* CHRONICLES - The stories, organized by era */}\n        {chroniclePages.length > 0 && (\n          <div className={styles.section}>\n            <div className={styles.sectionTitle}>Chronicles</div>\n\n            {/* Era sections */}\n            {sortedEras.map((era) => {\n              const isExpanded = expandedEras.has(era.eraId);\n              const eraAllId = `chronicles-era-${era.eraId}`;\n              const eraStoriesId = `chronicles-era-${era.eraId}-story`;\n              const eraDocsId = `chronicles-era-${era.eraId}-document`;\n\n              return (\n                <div key={era.eraId}>\n                  <button\n                    className={styles.eraSectionTitle}\n                    onClick={() => toggleEra(era.eraId)}\n                    aria-expanded={isExpanded}\n                  >\n                    <span className={styles.collapseIcon}>{isExpanded ? \"\u25bc\" : \"\u25b6\"}</span>\n                    {era.eraName}\n                    <span className={styles.badge}>({era.all.length})</span>\n                  </button>\n                  {isExpanded && (\n                    <>\n                      {eraNarrativeByEraId.has(era.eraId) &&\n                        (() => {\n                          const narrativePage = eraNarrativeByEraId.get(era.eraId)!;\n                          const isActive = currentPageId === narrativePage.id;\n                          return (\n                            <button\n                              className={\n                                isActive\n                                  ? styles.navItemEraNarrativeActive\n                                  : styles.navItemEraNarrative\n                              }\n                              onClick={() => onNavigate(narrativePage.id)}\n                            >\n                              Era Narrative\n                            </button>\n                          );\n                        })()}\n                      <button\n                        className={\n                          currentPageId === eraAllId\n                            ? styles.navItemIndentedActive\n                            : styles.navItemIndented\n                        }\n                        onClick={() => onNavigate(eraAllId)}\n                      >\n                        View All\n                        <span\n                          className={currentPageId === eraAllId ? styles.badgeActive : styles.badge}\n                        >\n                          ({era.all.length})\n                        </span>\n                      </button>\n                      {era.stories.length > 0 && (\n                        <button\n                          className={\n                            currentPageId === eraStoriesId\n                              ? styles.navItemIndentedActive\n                              : styles.navItemIndented\n                          }\n                          onClick={() => onNavigate(eraStoriesId)}\n                        >\n                          Stories\n                          <span\n                            className={\n                              currentPageId === eraStoriesId ? styles.badgeActive : styles.badge\n                            }\n                          >\n                            ({era.stories.length})\n                          </span>\n                        </button>\n                      )}\n                      {era.documents.length > 0 && (\n                        <button\n                          className={\n                            currentPageId === eraDocsId\n                              ? styles.navItemIndentedActive\n                              : styles.navItemIndented\n                          }\n                          onClick={() => onNavigate(eraDocsId)}\n                        >\n                          Documents\n                          <span\n                            className={\n                              currentPageId === eraDocsId ? styles.badgeActive : styles.badge\n                            }\n                          >\n                            ({era.documents.length})\n                          </span>\n                        </button>\n                      )}\n                    </>\n                  )}\n                </div>\n              );\n            })}\n\n            {/* All Stories / All Documents at bottom */}\n            {storyChronicles.length > 0 && (\n              <button\n                className={\n                  currentPageId === \"chronicles-story\" ? styles.navItemActive : styles.navItem\n                }\n                onClick={() => onNavigate(\"chronicles-story\")}\n              >\n                All Stories\n                <span\n                  className={\n                    currentPageId === \"chronicles-story\" ? styles.badgeActive : styles.badge\n                  }\n                >\n                  ({storyChronicles.length})\n// ... (truncated)", "parameters": [{"name": "{\n  categories,\n  pages,\n  chronicles,\n  staticPages,\n  currentPageId,\n  searchQuery,\n  onSearchQueryChange,\n  onNavigate,\n  onGoHome,\n  onRefreshIndex,\n  isRefreshing,\n  isDrawer,\n  onCloseDrawer,\n}", "type": "Readonly<WikiNavProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WikiPage", "WikiCategory"], "category": "internal"}, {"source": "./WikiSearch.tsx", "specifiers": ["WikiSearch"], "category": "internal"}, {"source": "./WikiNav.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/WikiPage.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiPage.tsx", "sourceCode": "export default function WikiPageView({\n  page,\n  pages,\n  entityIndex,\n  disambiguation,\n  onNavigate,\n  onNavigateToEntity,\n  prominenceScale,\n  breakpoint = \"desktop\",\n  layoutOverride,\n}: Readonly<WikiPageViewProps>) {\n  const isMobile = breakpoint === \"mobile\";\n  const isTablet = breakpoint === \"tablet\";\n  const showInfoboxInline = isMobile || isTablet;\n  const isEntityPage = page.type === \"entity\" || page.type === \"era\";\n  const entityIdForTimeline = isEntityPage ? page.id : null;\n  const narrativeEvents = useEntityNarrativeEvents(entityIdForTimeline);\n  const narrativeLoading = useEntityNarrativeLoading(entityIdForTimeline);\n  const [showSeedModal, setShowSeedModal] = useState(false);\n  const [activeImage, setActiveImage] = useState<{\n    url: string;\n    title: string;\n    summary?: string;\n  } | null>(null);\n  const [timelineOpen, setTimelineOpen] = useState(false);\n  const [hoveredBacklink, setHoveredBacklink] = useState<{\n    id: string;\n    position: { x: number; y: number };\n  } | null>(null);\n  const hoverTimeoutRef = useRef<number | null>(null);\n\n  // Handle entity link hover with delay to prevent flicker\n  const handleEntityHoverEnter = useCallback((id: string, e: React.MouseEvent) => {\n    // Capture position immediately - React synthetic events are pooled\n    const x = e.clientX;\n    const y = e.clientY;\n\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n    }\n    hoverTimeoutRef.current = window.setTimeout(() => {\n      setHoveredBacklink({\n        id,\n        position: { x, y },\n      });\n    }, 200); // 200ms delay before showing preview\n  }, []);\n\n  const handleEntityHoverLeave = useCallback(() => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredBacklink(null);\n  }, []);\n\n  // Clear hover when clicking to navigate\n  const handleEntityClick = useCallback(\n    (entityId: string) => {\n      handleEntityHoverLeave();\n      onNavigateToEntity(entityId);\n    },\n    [handleEntityHoverLeave, onNavigateToEntity]\n  );\n\n  // Get hovered entity data for preview\n  const hoveredEntity = useMemo(() => {\n    if (!hoveredBacklink) return null;\n    return entityIndex.get(hoveredBacklink.id) || null;\n  }, [hoveredBacklink, entityIndex]);\n\n  // Get summary for hovered entity\n  const hoveredSummary = useMemo(() => {\n    if (!hoveredBacklink) return undefined;\n    const page = pages.find((p) => p.id === hoveredBacklink.id);\n    return page?.content?.summary;\n  }, [hoveredBacklink, pages]);\n\n  // Load image for hovered entity on demand\n  const hoveredImageId = hoveredEntity?.enrichment?.image?.imageId;\n  const { url: hoveredImageUrl } = useImageUrl(hoveredImageId);\n\n  const pageById = useMemo(() => new Map(pages.map((p) => [p.id, p])), [pages]);\n  const imageIdToEntityId = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const entity of entityIndex.values()) {\n      const imageId = entity.enrichment?.image?.imageId;\n      if (imageId && !map.has(imageId)) {\n        map.set(imageId, entity.id);\n      }\n    }\n    return map;\n  }, [entityIndex]);\n\n  const resolveImageDetails = useCallback(\n    ({\n      entityId,\n      imageId,\n      caption,\n      fallbackTitle,\n      fallbackSummary,\n      suppressSummaryFallback,\n      captionOnly,\n    }: {\n      entityId?: string;\n      imageId?: string;\n      caption?: string;\n      fallbackTitle?: string;\n      fallbackSummary?: string;\n      suppressSummaryFallback?: boolean;\n      captionOnly?: boolean;\n    }) => {\n      if (captionOnly) {\n        return { title: caption || \"\", summary: \"\" };\n      }\n      let resolvedEntityId = entityId;\n      if (!resolvedEntityId && imageId) {\n        resolvedEntityId = imageIdToEntityId.get(imageId);\n      }\n\n      let title = \"\";\n      let summary = \"\";\n\n      if (resolvedEntityId) {\n        const entity = entityIndex.get(resolvedEntityId);\n        const entityPage = pageById.get(resolvedEntityId);\n        title = entity?.name || entityPage?.title || \"\";\n        summary = entityPage?.content.summary || \"\";\n      }\n\n      if (!title) {\n        title = fallbackTitle || caption || page.title;\n      }\n      if (!summary) {\n        if (suppressSummaryFallback) {\n          summary = fallbackSummary || caption || \"\";\n        } else {\n          summary = fallbackSummary || page.content.summary || caption || \"\";\n        }\n      }\n\n      return { title, summary };\n    },\n    [imageIdToEntityId, entityIndex, pageById, page.content.summary, page.title]\n  );\n\n  const openImageModal = useCallback(\n    (\n      imageUrl: string,\n      info: {\n        entityId?: string;\n        imageId?: string;\n        caption?: string;\n        fallbackTitle?: string;\n        fallbackSummary?: string;\n        suppressSummaryFallback?: boolean;\n        captionOnly?: boolean;\n      }\n    ) => {\n      if (!imageUrl) return;\n      const { title, summary } = resolveImageDetails(info);\n      setActiveImage({ url: imageUrl, title, summary });\n    },\n    [resolveImageDetails]\n  );\n\n  const closeImageModal = useCallback(() => {\n    setActiveImage(null);\n  }, []);\n\n  const handleInlineImageOpen = useCallback(\n    async (thumbUrl: string, image: WikiSectionImage) => {\n      // Try to load full-size image for lightbox, fall back to thumbnail\n      let fullUrl = thumbUrl;\n      if (image.imageId) {\n        try {\n          const loaded = await useImageStore.getState().loadUrl(image.imageId, \"full\");\n          if (loaded) fullUrl = loaded;\n        } catch {\n          // Fall back to thumbnail\n        }\n      }\n      openImageModal(fullUrl, {\n        entityId: image.entityId,\n        imageId: image.imageId,\n        caption: image.caption,\n        suppressSummaryFallback: image.type === \"chronicle_image\",\n        captionOnly: image.type === \"chronicle_image\",\n      });\n    },\n    [openImageModal]\n  );\n\n  // Build seed data for chronicle pages\n  const seedData = useMemo((): ChronicleSeedData | null => {\n    if (page.type !== \"chronicle\" || !page.chronicle) return null;\n    const chronicle = page.chronicle;\n    if (!chronicle.narrativeStyleId && !chronicle.roleAssignments?.length) return null;\n\n    // Get entrypoint name\n    const entrypoint = chronicle.entrypointId ? entityIndex.get(chronicle.entrypointId) : undefined;\n\n    return {\n      narrativeStyleId: chronicle.narrativeStyleId || \"\",\n      entrypointId: chronicle.entrypointId,\n      entrypointName: entrypoint?.name,\n      roleAssignments: chronicle.roleAssignments || [],\n      selectedEventIds: chronicle.selectedEventIds || [],\n      selectedRelationshipIds: chronicle.selectedRelationshipIds || [],\n      temporalContext: chronicle.temporalContext,\n    };\n  }, [page, entityIndex]);\n\n  // Compute backlinks\n  const chronicleLinks = useMemo(() => {\n    return pages.filter(\n      (p) =>\n        p.type === \"chronicle\" &&\n        p.chronicle &&\n        p.id !== page.id &&\n        p.linkedEntities.includes(page.id)\n    );\n  }, [pages, page.id]);\n\n  // Era narrative source chronicle pages (resolved from IDs)\n  const sourceChronicleLinks = useMemo(() => {\n    const ids = page.eraNarrative?.sourceChronicleIds;\n    if (!ids || ids.length === 0) return [];\n    return ids.map((id) => pages.find((p) => p.id === id)).filter((p): p is WikiPage => p != null);\n  }, [pages, page.eraNarrative?.sourceChronicleIds]);\n\n  const backlinks = useMemo(() => {\n    return pages.filter(\n      (p) =>\n        p.id !== page.id &&\n        p.type !== \"chronicle\" &&\n        p.type !== \"category\" &&\n        p.linkedEntities.includes(page.id)\n    );\n  }, [pages, page.id]);\n\n  // Build name to ID map for link resolution (entities + static pages)\n  // Use Unicode NFC normalization to ensure consistent string comparison\n  // (important for names with special characters like \u263d, ~, accents, etc.)\n  const entityNameMap = useMemo(() => {\n    const map = new Map<string, string>();\n    // Add entity names\n    for (const [id, entity] of entityIndex) {\n      map.set(entity.name.toLowerCase().normalize(\"NFC\"), id);\n    }\n    // Add static page titles (full title and base name without namespace)\n    for (const p of pages) {\n      if (p.type !== \"static\") continue;\n      const titleLower = p.title.toLowerCase().normalize(\"NFC\");\n      if (!map.has(titleLower)) {\n        map.set(titleLower, p.id);\n      }\n      // Also add base name (e.g., \"The Berg\" from \"World:The Berg\")\n      const colonIdx = p.title.indexOf(\":\");\n      if (colonIdx > 0 && colonIdx < p.title.length - 1) {\n        const baseName = p.title\n          .slice(colonIdx + 1)\n          .trim()\n          .toLowerCase()\n          .normalize(\"NFC\");\n        if (baseName && !map.has(baseName)) {\n          map.set(baseName, p.id);\n        }\n      }\n    }\n    return map;\n  }, [entityIndex, pages]);\n\n  const aliasMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const candidate of pages) {\n      if (candidate.type !== \"entity\" || !candidate.aliases?.length) continue;\n      for (const alias of candidate.aliases) {\n        // Use Unicode NFC normalization for consistent string comparison\n        const normalized = alias.toLowerCase().trim().normalize(\"NFC\");\n        if (!normalized || entityNameMap.has(normalized)) continue;\n        if (!map.has(normalized)) {\n          map.set(normalized, candidate.id);\n        }\n      }\n    }\n    return map;\n  }, [pages, entityNameMap]);\n\n  // Build linkable names for auto-linking (used by applyWikiLinks)\n  const linkableNames = useMemo(() => {\n    const names: Array<{ name: string; id: string }> = [];\n    // Add entity names\n    for (const [id, entity] of entityIndex) {\n      names.push({ name: entity.name, id });\n    }\n    // Add entity aliases\n    for (const candidate of pages) {\n      if (candidate.type !== \"entity\" || !candidate.aliases?.length) continue;\n      for (const alias of candidate.aliases) {\n// ... (truncated)", "parameters": [{"name": "{\n  page,\n  pages,\n  entityIndex,\n  disambiguation,\n  onNavigate,\n  onNavigateToEntity,\n  prominenceScale,\n  breakpoint = \"desktop\",\n  layoutOverride,\n}", "type": "Readonly<WikiPageViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useEffect", "useLayoutEffect", "useRef", "useCallback"], "category": "framework"}, {"source": "@uiw/react-md-editor", "specifiers": ["MDEditor"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["WikiPage", "WikiSection", "WikiSectionImage", "WikiHistorianNote", "HardState", "DisambiguationEntry", "ImageAspect", "PageLayoutOverride", "ChronicleRoleAssignment", "ChronicleTemporalContext"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl", "useImageUrls", "useImageMetadata", "useImageStore"], "category": "external"}, {"source": "@the-canonry/narrative-store", "specifiers": ["useEntityNarrativeEvents", "useEntityNarrativeLoading"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["SeedModal"], "category": "external"}, {"source": "../lib/wikiBuilder.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "../lib/fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "./EntityTimeline.tsx", "specifiers": ["EntityTimeline"], "category": "internal"}, {"source": "./ProminenceTimeline.tsx", "specifiers": ["ProminenceTimeline"], "category": "internal"}, {"source": "./ImageLightbox.tsx", "specifiers": ["ImageLightbox"], "category": "internal"}, {"source": "./Ornaments.tsx", "specifiers": ["SectionDivider", "FrostEdge"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./WikiPage.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/components/WikiSearch.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiSearch.tsx", "sourceCode": "export default function WikiSearch({\n  pages,\n  query,\n  onQueryChange,\n  onSelect,\n  expandDirection = \"down\",\n}: Readonly<WikiSearchProps>) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Build fuse.js search index\n  const fuse = useMemo(() => {\n    return new Fuse(pages, {\n      keys: [\n        { name: \"title\", weight: 2 },\n        { name: \"aliases\", weight: 1.5 },\n        { name: \"content.summary\", weight: 1.2 },\n        { name: \"content.sections.heading\", weight: 0.5 },\n        { name: \"content.sections.content\", weight: 1 },\n      ],\n      threshold: 0.3,\n      includeScore: true,\n      minMatchCharLength: 2,\n    });\n  }, [pages]);\n\n  // Search results\n  const results = useMemo(() => {\n    if (!query || query.length < 2) return [];\n    return fuse.search(query).slice(0, 10);\n  }, [fuse, query]);\n\n  // Handle keyboard navigation\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!isOpen || results.length === 0) return;\n\n    switch (e.key) {\n      case \"ArrowDown\":\n        e.preventDefault();\n        setSelectedIndex((i) => Math.min(i + 1, results.length - 1));\n        break;\n      case \"ArrowUp\":\n        e.preventDefault();\n        setSelectedIndex((i) => Math.max(i - 1, 0));\n        break;\n      case \"Enter\":\n        e.preventDefault();\n        if (results[selectedIndex]) {\n          onSelect(results[selectedIndex].item.id);\n          setIsOpen(false);\n          onQueryChange(\"\");\n        }\n        break;\n      case \"Escape\":\n        setIsOpen(false);\n        break;\n    }\n  };\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  // Reset keyboard selection when result set changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- derived UI selection reset on results refresh\n    setSelectedIndex(0);\n  }, [results]);\n\n  return (\n    <div ref={containerRef} className={styles.container}>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        value={query}\n        onChange={(e) => {\n          onQueryChange(e.target.value);\n          setIsOpen(true);\n        }}\n        onFocus={() => setIsOpen(true)}\n        onKeyDown={handleKeyDown}\n        className={styles.input}\n      />\n\n      {isOpen && query.length >= 2 && (\n        <div className={expandDirection === \"up\" ? styles.dropdownUp : styles.dropdown}>\n          {results.length > 0 ? (\n            results.map((result, index) => (\n              <button\n                key={result.item.id}\n                className={index === selectedIndex ? styles.resultSelected : styles.result}\n                onClick={() => {\n                  onSelect(result.item.id);\n                  setIsOpen(false);\n                  onQueryChange(\"\");\n                }}\n                onMouseEnter={() => setSelectedIndex(index)}\n              >\n                {result.item.title}\n                <span className={styles.resultType}>{result.item.type}</span>\n              </button>\n            ))\n          ) : (\n            <div className={styles.noResults}>No results found</div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  pages,\n  query,\n  onQueryChange,\n  onSelect,\n  expandDirection = \"down\",\n}", "type": "Readonly<WikiSearchProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "fuse.js", "specifiers": ["Fuse"], "category": "external"}, {"source": "../types/world.ts", "specifiers": ["WikiPage"], "category": "internal"}, {"source": "./WikiSearch.module.css", "specifiers": ["styles"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts", "sourceCode": "export default function useWorldDataLoader({\n  projectId,\n  activeSlotIndex,\n  dexieSeededAt,\n  preloadedWorldData,\n}: WorldDataLoaderOptions): WorldDataLoaderResult {\n  const [worldDataState, setWorldDataState] = useState<WorldState | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [loadError, setLoadError] = useState<string | null>(null);\n\n  const narrativeBackend = useMemo(() => new IndexedDBBackend(), []);\n  const hasPreloadedWorld = preloadedWorldData !== undefined;\n\n  const effective = resolveEffectiveState(\n    projectId,\n    hasPreloadedWorld,\n    preloadedWorldData,\n    worldDataState,\n    loading,\n    loadError\n  );\n  const simulationRunId = effective.worldData?.metadata?.simulationRunId ?? null;\n\n  useEffect(() => {\n    if (hasPreloadedWorld) return;\n    if (!projectId) return;\n\n    let cancelled = false;\n    queueMicrotask(() => {\n      if (cancelled) return;\n      setLoading(true);\n      setLoadError(null);\n    });\n\n    buildWorldStateForSlot(projectId, activeSlotIndex)\n      .then((loaded) => {\n        if (cancelled) return;\n        setWorldDataState(loaded);\n      })\n      .catch((err: unknown) => {\n        if (cancelled) return;\n        console.error(\"[ChroniclerRemote] Failed to load world data:\", err);\n        setWorldDataState(null);\n        setLoadError(err instanceof Error ? err.message : \"Failed to load world data from Dexie.\");\n      })\n      .finally(() => {\n        if (cancelled) return;\n        setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [activeSlotIndex, dexieSeededAt, hasPreloadedWorld, projectId]);\n\n  useEffect(() => {\n    const store = useNarrativeStore.getState();\n    store.configureBackend(narrativeBackend);\n    if (store.simulationRunId !== simulationRunId) {\n      store.setSimulationRunId(simulationRunId);\n    }\n  }, [narrativeBackend, simulationRunId]);\n\n  return effective;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  dexieSeededAt,\n  preloadedWorldData,\n}", "type": "WorldDataLoaderOptions", "optional": false}], "returnType": "WorldDataLoaderResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useEffect", "useMemo", "useState"], "category": "framework"}, {"source": "../types/world.ts", "specifiers": ["WorldState"], "category": "internal"}, {"source": "@the-canonry/world-store", "specifiers": ["buildWorldStateForSlot"], "category": "external"}, {"source": "@the-canonry/narrative-store", "specifiers": ["IndexedDBBackend", "useNarrativeStore"], "category": "external"}]}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getCompletedChroniclesForSimulation", "name": "getCompletedChroniclesForSimulation", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get all completed chronicles for a simulation run\n */\nexport async function getCompletedChroniclesForSimulation(\n  simulationRunId: string\n): Promise<ChronicleRecord[]> {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allChronicles = request.result as ChronicleRecord[];\n          // Filter to only completed chronicles\n          const completed = allChronicles.filter((c) => c.status === \"complete\" && c.acceptedAt);\n          // Sort by acceptedAt descending\n          completed.sort((a, b) => (b.acceptedAt || 0) - (a.acceptedAt || 0));\n          resolve(completed);\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getChronicle", "name": "getChronicle", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get a single chronicle by ID\n */\nexport async function getChronicle(chronicleId: string): Promise<ChronicleRecord | null> {\n  if (!chronicleId) return null;\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const request = tx.objectStore(CHRONICLE_STORE_NAME).get(chronicleId);\n\n        request.onsuccess = () => resolve((request.result as ChronicleRecord | undefined) ?? null);\n        request.onerror = () => reject(request.error ?? new Error(\"Failed to get chronicle\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicle:\", err);\n    return null;\n  }\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord | null>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getChronicleContent", "name": "getChronicleContent", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get the content to display for a chronicle\n * Prefers finalContent (accepted), falls back to assembledContent\n */\nexport function getChronicleContent(chronicle: ChronicleRecord): string {\n  return chronicle.finalContent || chronicle.assembledContent || \"\";\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::escapeRegex", "name": "escapeRegex", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "// ============================================================================\n// Core Utilities\n// ============================================================================\n\n/**\n * Escape special regex characters in a string\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::buildNamePattern", "name": "buildNamePattern", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Build a regex pattern for a single name with smart word boundaries.\n *\n * Uses \\b for names starting/ending with word chars ([a-zA-Z0-9_]),\n * but uses lookaround for non-word chars (\u263d, ~, (, ), ', etc.) where \\b fails.\n *\n * Examples:\n * - \"Aurora Berg\" -> \\bAurora Berg\\b\n * - \"The Syndicate (aw-sworn)\" -> \\bThe Syndicate \\(aw-sworn\\)(?!\\w)\n * - \"\u263d'whelm Noctnecsiavcaeis~\" -> (?<!\\w)\u263d'whelm Noctnecsiavcaeis~(?!\\w)\n */\nexport function buildNamePattern(name: string): string {\n  const escaped = escapeRegex(name);\n  const firstChar = name.charAt(0);\n  const lastChar = name.charAt(name.length - 1);\n  const startBoundary = /\\w/.test(firstChar) ? \"\\\\b\" : \"(?<!\\\\w)\";\n  const endBoundary = /\\w/.test(lastChar) ? \"\\\\b\" : \"(?!\\\\w)\";\n  return `${startBoundary}${escaped}${endBoundary}`;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::buildCombinedPattern", "name": "buildCombinedPattern", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Build a combined regex pattern that matches any of the given names.\n * Names are sorted by length (longest first) to ensure longer matches take priority.\n *\n * @param names - Array of names to match (minimum 3 chars each)\n * @param flags - Regex flags (default: 'gi' for global, case-insensitive)\n */\nexport function buildCombinedPattern(names: string[], flags: string = \"gi\"): RegExp | null {\n  const validNames = names.filter((name) => name.length >= 3).sort((a, b) => b.length - a.length); // Longer names first\n\n  if (validNames.length === 0) return null;\n\n  const patterns = validNames.map(buildNamePattern);\n  return new RegExp(`(${patterns.join(\"|\")})`, flags);\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "flags", "type": "string", "optional": true}], "returnType": "RegExp | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Apply wikilinks to content - wraps entity/page name mentions with [[...]] syntax.\n * Only links first occurrence of each name per section (Wikipedia MOS:LINK style).\n * Used at render time to make entity names clickable in markdown content.\n *\n * @param content - Raw text content (may contain markdown headings)\n * @param names - Array of { name, id } for entities and static pages to link\n */\nexport function applyWikiLinks(\n  content: string,\n  names: Array<{ name: string; id: string }>\n): string {\n  const nameStrings = names.map((n) => n.name);\n  const combinedPattern = buildCombinedPattern(nameStrings);\n\n  if (!combinedPattern) return content;\n\n  // Split by section headings (## or #), keeping the delimiter\n  // This regex captures the heading line so we can preserve it\n  const sectionSplitRegex = /^(#{1,3}\\s+.*)$/gm; // eslint-disable-line sonarjs/slow-regex -- single markdown lines, no backtracking risk\n  const parts = content.split(sectionSplitRegex);\n\n  // Process each part - headings pass through, content gets wiki-linked\n  const result: string[] = [];\n  for (const part of parts) {\n    if (part.match(/^#{1,3}\\s+/)) {\n      // This is a heading - pass through unchanged\n      result.push(part);\n    } else {\n      // This is content - apply wiki links (first occurrence per section)\n      result.push(applyWikiLinksToSection(part, combinedPattern));\n    }\n  }\n\n  return result.join(\"\");\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "names", "type": "Array<{ name: string; id: string }>", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::linkifyText", "name": "linkifyText", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Convert text to React nodes with clickable entity links.\n * Used for non-markdown content like timeline tables where we need React elements.\n *\n * @param text - Plain text to process\n * @param entities - Array of { name, id } for entities to link\n * @param onNavigate - Callback when an entity link is clicked\n * @param options - Optional configuration\n */\n// eslint-disable-next-line sonarjs/function-return-type -- returns React.ReactNode by design\nexport function linkifyText(\n  text: string,\n  entities: LinkableEntity[],\n  onNavigate: (entityId: string) => void,\n  options: LinkifyOptions = {}\n): React.ReactNode {\n  const {\n    linkStyle = defaultLinkStyle,\n    firstOccurrenceOnly = true,\n    onHoverEnter,\n    onHoverLeave,\n  } = options;\n\n  // Sort by name length (longest first) to match longer names first\n  const sortedEntities = [...entities].sort((a, b) => b.name.length - a.name.length);\n\n  let result: React.ReactNode[] = [text];\n  const linkedNames = new Set<string>();\n\n  for (const { name, id } of sortedEntities) {\n    if (name.length < 3) continue;\n\n    // Skip if we already linked this name and firstOccurrenceOnly is true\n    const nameLower = name.toLowerCase();\n    if (firstOccurrenceOnly && linkedNames.has(nameLower)) continue;\n\n    const regex = new RegExp(buildNamePattern(name), \"gi\");\n    const newResult: React.ReactNode[] = [];\n    let foundMatch = false;\n\n    for (const part of result) {\n      if (typeof part !== \"string\") {\n        newResult.push(part);\n        continue;\n      }\n\n      // Skip if firstOccurrenceOnly and we already found a match for this name\n      if (firstOccurrenceOnly && foundMatch) {\n        newResult.push(part);\n        continue;\n      }\n\n      let lastIndex = 0;\n      let match: RegExpExecArray | null;\n      const segments: React.ReactNode[] = [];\n\n      while ((match = regex.exec(part)) !== null) {\n        // Add text before match\n        if (match.index > lastIndex) {\n          segments.push(part.slice(lastIndex, match.index));\n        }\n\n        // Add linked entity\n        segments.push(\n          React.createElement(\n            \"span\",\n            {\n              key: `${id}-${match.index}`,\n              style: linkStyle,\n              onClick: (e: React.MouseEvent) => {\n                e.stopPropagation();\n                onNavigate(id);\n              },\n              onMouseEnter: onHoverEnter ? (e: React.MouseEvent) => onHoverEnter(id, e) : undefined,\n              onMouseLeave: onHoverLeave,\n            },\n            match[0]\n          )\n        );\n\n        lastIndex = regex.lastIndex;\n        foundMatch = true;\n\n        // If firstOccurrenceOnly, stop after first match\n        if (firstOccurrenceOnly) break;\n      }\n\n      if (segments.length > 0) {\n        // Add remaining text after last match\n        if (lastIndex < part.length) {\n          segments.push(part.slice(lastIndex));\n        }\n        newResult.push(...segments);\n      } else {\n        newResult.push(part);\n      }\n    }\n\n    if (foundMatch) {\n      linkedNames.add(nameLower);\n    }\n    result = newResult;\n  }\n\n  return React.createElement(React.Fragment, null, ...result);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "entities", "type": "LinkableEntity[]", "optional": false}, {"name": "onNavigate", "type": "(entityId: string) => void", "optional": false}, {"name": "options", "type": "LinkifyOptions", "optional": true}], "returnType": "React.ReactNode", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts::getCompletedEraNarrativesForSimulation", "name": "getCompletedEraNarrativesForSimulation", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts", "sourceCode": "/**\n * Get all completed era narratives for a simulation run.\n * Returns at most one narrative per era (the most recently updated).\n */\nexport async function getCompletedEraNarrativesForSimulation(\n  simulationRunId: string\n): Promise<EraNarrativeViewRecord[]> {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Check if the store exists (older DB versions may not have it)\n      if (!db.objectStoreNames.contains(ERA_NARRATIVE_STORE_NAME)) {\n        return [];\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(ERA_NARRATIVE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(ERA_NARRATIVE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allRecords = request.result as Record<string, unknown>[];\n          const projected = allRecords\n            .map(projectToViewRecord)\n            .filter((r): r is EraNarrativeViewRecord => r !== null);\n\n          // Keep only the latest completed narrative per era\n          const byEra = new Map<string, EraNarrativeViewRecord>();\n          for (const record of projected) {\n            const existing = byEra.get(record.eraId);\n            if (!existing || record.updatedAt > existing.updatedAt) {\n              byEra.set(record.eraId, record);\n            }\n          }\n\n          resolve(Array.from(byEra.values()));\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get era narratives\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[eraNarrativeStorage] Failed to load era narratives:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeViewRecord[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts::getEraNarrativeContent", "name": "getEraNarrativeContent", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts", "sourceCode": "/**\n * Get the display content for an era narrative.\n */\nexport function getEraNarrativeContent(narrative: EraNarrativeViewRecord): string {\n  return narrative.content;\n}", "parameters": [{"name": "narrative", "type": "EraNarrativeViewRecord", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/fuzzyAnchor.ts::resolveAnchorPhrase", "name": "resolveAnchorPhrase", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "/**\n * Resolve an LLM-produced anchor phrase to a verbatim substring in the text.\n *\n * Returns null if no reasonable match is found.\n */\nexport function resolveAnchorPhrase(anchorPhrase: string, text: string): FuzzyAnchorResult | null {\n  if (!anchorPhrase || !text) return null;\n\n  // 1. Exact match (case-insensitive)\n  const lowerText = text.toLowerCase();\n  const lowerPhrase = anchorPhrase.toLowerCase();\n  const exactIdx = lowerText.indexOf(lowerPhrase);\n  if (exactIdx >= 0) {\n    return {\n      phrase: text.slice(exactIdx, exactIdx + anchorPhrase.length),\n      index: exactIdx,\n      method: \"exact\",\n    };\n  }\n\n  // 2. Fuzzy locate: find the region with highest content-word overlap\n  const phraseContentWords = contentWords(anchorPhrase);\n  if (phraseContentWords.length === 0) return null;\n\n  const phraseWordSet = new Set(phraseContentWords);\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  // Window size: match the anchor phrase word count, with some slack\n  const anchorWordCount = anchorPhrase.split(/\\s+/).length;\n  const windowSize = Math.max(anchorWordCount, 4);\n  const halfWindow = Math.floor(windowSize / 2);\n\n  let bestScore = 0;\n  let bestCenter = -1;\n\n  // Score each word position by counting how many content words from the\n  // phrase appear within a window around it\n  for (let i = 0; i < words.length; i++) {\n    let score = 0;\n    const start = Math.max(0, i - halfWindow);\n    const end = Math.min(words.length, i + halfWindow + 1);\n    for (let j = start; j < end; j++) {\n      if (phraseWordSet.has(words[j].normalized)) {\n        score++;\n      }\n    }\n    if (score > bestScore) {\n      bestScore = score;\n      bestCenter = i;\n    }\n  }\n\n  // Require at least 40% of content words to match\n  if (bestScore < Math.max(1, Math.ceil(phraseContentWords.length * 0.4))) {\n    return null;\n  }\n\n  // 3. Extract a verbatim span from the best region\n  // Take a window of similar word count centered on bestCenter\n  const spanStart = Math.max(0, bestCenter - halfWindow);\n  const spanEnd = Math.min(words.length - 1, bestCenter + halfWindow);\n  const charStart = words[spanStart].start;\n  const charEnd = words[spanEnd].end;\n\n  let candidate = text.slice(charStart, charEnd);\n\n  // Trim to sentence boundaries if the span crosses them \u2014 find the\n  // innermost sentence that contains the center word\n  const centerCharStart = words[bestCenter].start;\n  const centerCharEnd = words[bestCenter].end;\n\n  // Find sentence start (look backwards for . ! ? followed by space, or start of text)\n  let sentenceStart = charStart;\n  for (let c = centerCharStart - 1; c >= Math.max(0, charStart - 200); c--) {\n    if (c === 0) {\n      sentenceStart = 0;\n      break;\n    }\n    const ch = text[c];\n    if ((ch === \".\" || ch === \"!\" || ch === \"?\") && c + 1 < text.length && /\\s/.test(text[c + 1])) {\n      sentenceStart = c + 2; // skip punctuation + space\n      break;\n    }\n  }\n\n  // Find sentence end (look forwards for . ! ?)\n  let sentenceEnd = charEnd;\n  for (let c = centerCharEnd; c < Math.min(text.length, charEnd + 200); c++) {\n    const ch = text[c];\n    if (ch === \".\" || ch === \"!\" || ch === \"?\") {\n      sentenceEnd = c + 1;\n      break;\n    }\n  }\n\n  // Use the sentence if it's a reasonable length; otherwise use the raw span\n  const sentence = text.slice(sentenceStart, sentenceEnd).trim();\n  if (sentence.length > 0 && sentence.length <= 300) {\n    candidate = sentence;\n  }\n\n  // Pick a unique sub-span if the candidate appears multiple times\n  // Try progressively shorter unique substrings from the center\n  if (candidate.length > 0) {\n    const firstOccurrence = text.indexOf(candidate);\n    const secondOccurrence = text.indexOf(candidate, firstOccurrence + 1);\n    if (secondOccurrence >= 0) {\n      // Not unique \u2014 try to shorten from the center of the best region\n      // Fall back to using the center word's sentence with more context\n      const uniqueCandidate = findUniqueSpan(text, centerCharStart, anchorWordCount);\n      if (uniqueCandidate) {\n        candidate = uniqueCandidate;\n      }\n    }\n  }\n\n  if (!candidate || candidate.length < 3) return null;\n\n  const finalIdx = text.indexOf(candidate);\n  if (finalIdx < 0) return null;\n\n  return {\n    phrase: candidate,\n    index: finalIdx,\n    method: \"fuzzy\",\n  };\n}", "parameters": [{"name": "anchorPhrase", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "FuzzyAnchorResult | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts::openIlluminatorDb", "name": "openIlluminatorDb", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts", "sourceCode": "export function openIlluminatorDb(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME);\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // If another connection triggers a version upgrade while we're\n      // still open, close immediately so we don't block it.\n      db.onversionchange = () => {\n        db.close();\n      };\n\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(request.error || new Error(\"Failed to open illuminator DB\"));\n    };\n  });\n}", "parameters": [], "returnType": "Promise<IDBDatabase>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts::readPageLayouts", "name": "readPageLayouts", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts", "sourceCode": "/**\n * Read all page layout overrides for a simulation run.\n * Returns a Map keyed by pageId for fast lookup.\n * Gracefully returns empty map if the store doesn't exist yet (pre-v10 DB).\n */\nexport async function readPageLayouts(\n  simulationRunId: string\n): Promise<Map<string, PageLayoutOverride>> {\n  const map = new Map<string, PageLayoutOverride>();\n  if (!simulationRunId) return map;\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Guard: store may not exist if Illuminator hasn't upgraded to v10 yet\n      if (!db.objectStoreNames.contains(PAGE_LAYOUTS_STORE)) {\n        return map;\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(PAGE_LAYOUTS_STORE, \"readonly\");\n        const store = tx.objectStore(PAGE_LAYOUTS_STORE);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const records = request.result as PageLayoutOverride[];\n          for (const r of records) {\n            map.set(r.pageId, r);\n          }\n          resolve(map);\n        };\n        request.onerror = () => reject(request.error || new Error(\"Failed to read page layouts\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[illuminatorDbReader] Failed to load page layouts:\", err);\n    return map;\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, PageLayoutOverride>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world", "specifiers": ["PageLayoutOverride"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/staticPageStorage.ts::getStaticPage", "name": "getStaticPage", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/staticPageStorage.ts", "sourceCode": "// ============================================================================\n// Read-only Storage Operations\n// ============================================================================\n\n/**\n * Get a single static page by ID\n */\nexport async function getStaticPage(pageId: string): Promise<StaticPage | undefined> {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const req = tx.objectStore(STATIC_PAGE_STORE_NAME).get(pageId);\n      req.onsuccess = () => resolve((req.result as StaticPage | undefined) ?? undefined);\n      req.onerror = () => reject(req.error ?? new Error(\"Failed to get static page\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage | undefined>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/staticPageStorage.ts::getPublishedStaticPagesForProject", "name": "getPublishedStaticPagesForProject", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/staticPageStorage.ts", "sourceCode": "/**\n * Get published static pages for a project (main read function for Chronicler)\n */\nexport async function getPublishedStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const req = index.getAll(projectId);\n      req.onsuccess = () => {\n        const pages = (req.result as StaticPage[])\n          .filter((page) => page.status === \"published\")\n          .sort((a, b) => b.updatedAt - a.updatedAt);\n        resolve(pages);\n      };\n      req.onerror = () => reject(req.error || new Error(\"Failed to get static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildWikiPages", "name": "buildWikiPages", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build all wiki pages from world data (legacy full build)\n *\n * @param chronicles - Completed ChronicleRecords from IndexedDB (preferred source for chronicles)\n */\nexport function buildWikiPages(\n  worldData: WorldState,\n  loreData: LoreData | null,\n  imageData: ImageMetadata | null,\n  chronicles: ChronicleRecord[] = [],\n  prominenceScale?: ProminenceScale\n): WikiPage[] {\n  const pages: WikiPage[] = [];\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  const loreIndex = buildLoreIndex(loreData);\n  const aliasIndex = buildAliasIndex(worldData);\n  const imageIndex = buildImageIndex(worldData, imageData);\n\n  // Build entity pages\n  for (const entity of worldData.hardState) {\n    const page = buildEntityPage(\n      entity,\n      worldData,\n      loreIndex,\n      imageIndex,\n      aliasIndex,\n      resolvedProminenceScale,\n      chronicles\n    );\n    pages.push(page);\n  }\n\n  // Build chronicle pages from ChronicleRecords (IndexedDB)\n  const chroniclePages = buildChroniclePagesFromChronicles(chronicles, worldData, aliasIndex);\n  pages.push(...chroniclePages);\n\n  // Build category pages\n  const categories = buildCategories(worldData, pages);\n  for (const category of categories) {\n    pages.push(buildCategoryPage(category, pages));\n  }\n\n  return pages;\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}, {"name": "loreData", "type": "LoreData | null", "optional": false}, {"name": "imageData", "type": "ImageMetadata | null", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "WikiPage[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "ImageMetadata", "WikiPage", "WikiPageIndex", "PageIndexEntry", "WikiSection", "WikiSectionImage", "WikiInfobox", "WikiCategory", "HardState", "LoreRecord", "DisambiguationEntry", "Region", "ImageAspect"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["getChronicleContent"], "category": "internal"}, {"source": "./staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./entityLinking.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildPageIndex", "name": "buildPageIndex", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "export function buildPageIndex(\n  worldData: WorldState,\n  _loreData: LoreData | null,\n  chronicles: ChronicleRecord[] = [],\n  staticPages: StaticPage[] = [],\n  prominenceScale?: ProminenceScale,\n  eraNarratives: EraNarrativeViewRecord[] = []\n): WikiPageIndex {\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  const state: PageIndexState = {\n    entries: [],\n    byId: new Map(),\n    byName: new Map(),\n    byAlias: new Map(),\n    bySlug: new Map(),\n  };\n\n  const entityByName = new Map(worldData.hardState.map((e) => [e.name.toLowerCase(), e.id]));\n\n  const eraNarrativeByEraId = new Map<string, EraNarrativeViewRecord>();\n  for (const narrative of eraNarratives) {\n    if (narrative.status === \"complete\" && narrative.content) {\n      eraNarrativeByEraId.set(narrative.eraId, narrative);\n    }\n  }\n\n  indexEntityEntries(worldData, resolvedProminenceScale, eraNarrativeByEraId, state);\n  indexEraNarrativeEntries(eraNarrativeByEraId, state);\n  indexChronicleEntries(chronicles, state);\n\n  const linkableNames = buildLinkableNames(worldData, staticPages);\n  extractChronicleBacklinks(chronicles, state.entries, linkableNames, worldData, state.byAlias, state.byName);\n  indexStaticPageEntries(staticPages, linkableNames, entityByName, state);\n\n  const categories = indexCategoryEntries(state.entries, state);\n  indexRegionEntries(worldData, state);\n\n  const byBaseName = buildDisambiguationIndex(state.entries);\n\n  return { entries: state.entries, byId: state.byId, byName: state.byName, byAlias: state.byAlias, bySlug: state.bySlug, categories, byBaseName };\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}, {"name": "_loreData", "type": "LoreData | null", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "staticPages", "type": "StaticPage[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}, {"name": "eraNarratives", "type": "EraNarrativeViewRecord[]", "optional": true}], "returnType": "WikiPageIndex", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "ImageMetadata", "WikiPage", "WikiPageIndex", "PageIndexEntry", "WikiSection", "WikiSectionImage", "WikiInfobox", "WikiCategory", "HardState", "LoreRecord", "DisambiguationEntry", "Region", "ImageAspect"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["getChronicleContent"], "category": "internal"}, {"source": "./staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./entityLinking.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildPageById", "name": "buildPageById", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build a single page by ID (on-demand)\n * Returns null if page not found\n *\n * @param chronicles - Completed ChronicleRecords from IndexedDB (for chronicle pages)\n * @param staticPages - Published StaticPages from IndexedDB\n */\nexport function buildPageById(\n  pageId: string,\n  worldData: WorldState,\n  loreData: LoreData | null,\n  imageData: ImageMetadata | null,\n  pageIndex: WikiPageIndex,\n  chronicles: ChronicleRecord[] = [],\n  staticPages: StaticPage[] = [],\n  prominenceScale?: ProminenceScale,\n  eraNarratives: EraNarrativeViewRecord[] = []\n): WikiPage | null {\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  let indexEntry = pageIndex.byId.get(pageId);\n  if (!indexEntry) {\n    // Slug fallback: supports renamed entity URLs and slug-based deep links\n    const resolvedId = pageIndex.bySlug.get(pageId);\n    if (resolvedId) indexEntry = pageIndex.byId.get(resolvedId);\n    if (!indexEntry) return null;\n  }\n\n  const loreIndex = buildLoreIndex(loreData);\n  const imageIndex = buildImageIndex(worldData, imageData);\n\n  // Build alias index from page index\n  const aliasIndex = pageIndex.byAlias;\n\n  // Entity page\n  if (indexEntry.type === \"entity\" || indexEntry.type === \"era\") {\n    const entity = worldData.hardState.find((e) => e.id === pageId);\n    if (!entity) return null;\n    return buildEntityPage(\n      entity,\n      worldData,\n      loreIndex,\n      imageIndex,\n      aliasIndex,\n      resolvedProminenceScale,\n      chronicles\n    );\n  }\n\n  // Era narrative page - long-form era synthesis\n  if (indexEntry.type === \"era_narrative\") {\n    const narrative = eraNarratives.find((n) => n.narrativeId === pageId);\n    if (!narrative) return null;\n    return buildEraNarrativePage(narrative, worldData, aliasIndex, pageIndex.byName);\n  }\n\n  // Chronicle page - look up in ChronicleRecords\n  if (indexEntry.type === \"chronicle\") {\n    const chronicle = chronicles.find((c) => c.chronicleId === pageId);\n    if (!chronicle) return null;\n    return buildChroniclePageFromChronicle(chronicle, worldData, aliasIndex, pageIndex.byName);\n  }\n\n  // Category page\n  if (indexEntry.type === \"category\") {\n    const catId = pageId.replace(\"category-\", \"\");\n    const category = pageIndex.categories.find((c) => c.id === catId);\n    if (!category) return null;\n\n    // Build minimal page list for category\n    const pagesInCategory = pageIndex.entries\n      .filter((e) => e.categories.includes(catId))\n      .map((e) => ({\n        id: e.id,\n        title: e.title,\n        type: e.type,\n        slug: e.slug,\n        content: { sections: [], summary: e.summary },\n        categories: e.categories,\n        linkedEntities: e.linkedEntities,\n        images: [],\n        lastUpdated: e.lastUpdated,\n      })) as WikiPage[];\n\n    return buildCategoryPage(category, pagesInCategory);\n  }\n\n  // Static page - look up in StaticPages\n  if (indexEntry.type === \"static\") {\n    const staticPage = staticPages.find((p) => p.pageId === pageId);\n    if (!staticPage) return null;\n    return buildStaticPageFromStaticPage(\n      staticPage,\n      worldData,\n      loreData,\n      aliasIndex,\n      pageIndex.byName\n    );\n  }\n\n  // Region page\n  if (indexEntry.type === \"region\") {\n    // Extract region ID from page ID (format: \"region:region_id\")\n    const regionId = pageId.replace(\"region:\", \"\");\n    const regionInfo = findRegionById(worldData, regionId);\n    if (!regionInfo) return null;\n    return buildRegionPage(regionInfo.region, regionInfo.entityKind, worldData, aliasIndex);\n  }\n\n  return null;\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}, {"name": "worldData", "type": "WorldState", "optional": false}, {"name": "loreData", "type": "LoreData | null", "optional": false}, {"name": "imageData", "type": "ImageMetadata | null", "optional": false}, {"name": "pageIndex", "type": "WikiPageIndex", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "staticPages", "type": "StaticPage[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}, {"name": "eraNarratives", "type": "EraNarrativeViewRecord[]", "optional": true}], "returnType": "WikiPage | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "ImageMetadata", "WikiPage", "WikiPageIndex", "PageIndexEntry", "WikiSection", "WikiSectionImage", "WikiInfobox", "WikiCategory", "HardState", "LoreRecord", "DisambiguationEntry", "Region", "ImageAspect"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["getChronicleContent"], "category": "internal"}, {"source": "./staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./entityLinking.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildCategories", "name": "buildCategories", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build all categories from pages\n */\nexport function buildCategories(_worldData: WorldState, pages: WikiPage[]): WikiCategory[] {\n  // _worldData reserved for future category enrichment\n  const categoryMap = new Map<string, WikiCategory>();\n\n  // Collect all category IDs from pages\n  for (const page of pages) {\n    for (const catId of page.categories) {\n      if (!categoryMap.has(catId)) {\n        categoryMap.set(catId, {\n          id: catId,\n          name: formatCategoryName(catId),\n          type: \"auto\",\n          pageCount: 0,\n        });\n      }\n      categoryMap.get(catId)!.pageCount++;\n    }\n  }\n\n  return Array.from(categoryMap.values()).sort((a, b) => b.pageCount - a.pageCount);\n}", "parameters": [{"name": "_worldData", "type": "WorldState", "optional": false}, {"name": "pages", "type": "WikiPage[]", "optional": false}], "returnType": "WikiCategory[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "ImageMetadata", "WikiPage", "WikiPageIndex", "PageIndexEntry", "WikiSection", "WikiSectionImage", "WikiInfobox", "WikiCategory", "HardState", "LoreRecord", "DisambiguationEntry", "Region", "ImageAspect"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["getChronicleContent"], "category": "internal"}, {"source": "./staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./entityLinking.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}]}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Apply wikilinks to content - wraps entity/page name mentions with [[...]] syntax.\n * Only links first occurrence of each name per section (Wikipedia MOS:LINK style).\n * Used at render time to make entity names clickable in markdown content.\n *\n * @param content - Raw text content (may contain markdown headings)\n * @param names - Array of { name, id } for entities and static pages to link\n */\nexport function applyWikiLinks(\n  content: string,\n  names: Array<{ name: string; id: string }>\n): string {\n  const nameStrings = names.map((n) => n.name);\n  const combinedPattern = buildCombinedPattern(nameStrings);\n\n  if (!combinedPattern) return content;\n\n  // Split by section headings (## or #), keeping the delimiter\n  // This regex captures the heading line so we can preserve it\n  const sectionSplitRegex = /^(#{1,3}\\s+.*)$/gm; // eslint-disable-line sonarjs/slow-regex -- single markdown lines, no backtracking risk\n  const parts = content.split(sectionSplitRegex);\n\n  // Process each part - headings pass through, content gets wiki-linked\n  const result: string[] = [];\n  for (const part of parts) {\n    if (part.match(/^#{1,3}\\s+/)) {\n      // This is a heading - pass through unchanged\n      result.push(part);\n    } else {\n      // This is content - apply wiki links (first occurrence per section)\n      result.push(applyWikiLinksToSection(part, combinedPattern));\n    }\n  }\n\n  return result.join(\"\");\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "names", "type": "Array<{ name: string; id: string }>", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/world.ts", "specifiers": ["WorldState", "LoreData", "ImageMetadata", "WikiPage", "WikiPageIndex", "PageIndexEntry", "WikiSection", "WikiSectionImage", "WikiInfobox", "WikiCategory", "HardState", "LoreRecord", "DisambiguationEntry", "Region", "ImageAspect"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./chronicleStorage.ts", "specifiers": ["getChronicleContent"], "category": "internal"}, {"source": "./staticPageStorage.ts", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "./eraNarrativeStorage.ts", "specifiers": ["EraNarrativeViewRecord"], "category": "internal"}, {"source": "./entityLinking.ts", "specifiers": ["applyWikiLinks"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "ProminenceScale"], "category": "external"}, {"source": "./fuzzyAnchor.ts", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::generateManifold", "name": "generateManifold", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate a complete manifold configuration from input.\n *\n * This is the main entry point for the library.\n *\n * @param input - Domain specification with planes and hints\n * @returns Complete manifold configuration for lore-weave\n */\nexport function generateManifold(\n  input: CosmographerInput\n): CosmographerOutput {\n  const options = input.options ?? {};\n\n  // Register any custom categories\n  if (input.customCategories) {\n    for (const custom of input.customCategories) {\n      registerCustomCategory({\n        ...custom,\n        domainClass: input.spaceType === 'hybrid' ? 'conceptual' : input.spaceType\n      });\n    }\n  }\n\n  // Classify all planes\n  const classifications = classifyPlanes(input.planes, {\n    domainClass: input.spaceType,\n    keywordWeight: options.weights?.semantic ?? 0.5,\n    embeddingWeight: options.weights?.embedding ?? 0.3,\n    fuzzyWeight: 1 - (options.weights?.semantic ?? 0.5) - (options.weights?.embedding ?? 0.3)\n  });\n\n  // Generate hierarchy\n  const planeHierarchy = generateHierarchy(input, classifications);\n\n  // Generate distances\n  const crossPlaneDistances = generateDistances(input, classifications);\n\n  // Generate axis weights\n  const defaultAxisWeights = generateAxisWeights(input);\n\n  // Build classification metadata if requested\n  let classificationMetadata: Record<string, PlaneClassification> | undefined;\n\n  if (options.includeMetadata !== false) {\n    classificationMetadata = {};\n\n    for (const [planeId, result] of classifications) {\n      const matchedPatterns = getMatchedKeywords(\n        input.planes.find(p => p.id === planeId)!,\n        result.bestMatch\n      );\n\n      classificationMetadata[planeId] = {\n        category: result.bestMatch,\n        confidence: result.confidence,\n        matchedPatterns,\n        candidates: Array.from(result.scores.entries())\n          .sort((a, b) => b[1] - a[1])\n          .slice(0, 5)\n          .map(([category, score]) => ({ category, score }))\n      };\n    }\n  }\n\n  return {\n    domainId: input.domainId,\n    generatedAt: new Date().toISOString(),\n    generator: `cosmographer@${VERSION}`,\n    planeHierarchy,\n    defaultAxisWeights,\n    crossPlaneDistances,\n    saturationStrategy: options.saturationStrategy ?? 'density',\n    densityThreshold: options.densityThreshold ?? 0.7,\n    classifications: classificationMetadata\n  };\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "CosmographerOutput", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::analyzeTerm", "name": "analyzeTerm", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Analyze a single term and return its likely categories.\n *\n * Useful for exploring the ontology interactively.\n *\n * @param term - Term to analyze (e.g., \"underwater cavern\")\n * @param domainClass - Domain class to search within\n * @returns Array of category matches with confidence scores\n */\nexport function analyzeTerm(\n  term: string,\n  domainClass: import('./types/index.js').DomainClass = 'hybrid'\n): Array<{ category: string; confidence: number }> {\n  const fakeSpec = {\n    id: term.toLowerCase().replace(/\\s+/g, '_'),\n    label: term,\n    description: term\n  };\n\n  const result = classifyPlanes([fakeSpec], { domainClass });\n  const classification = result.get(fakeSpec.id);\n\n  if (!classification) {\n    return [];\n  }\n\n  return Array.from(classification.scores.entries())\n    .sort((a, b) => b[1] - a[1])\n    .map(([category, score]) => ({\n      category,\n      confidence: score\n    }));\n}", "parameters": [{"name": "term", "type": "string", "optional": false}, {"name": "domainClass", "type": "import('./types/index.js').DomainClass", "optional": true}], "returnType": "Array<{ category: string; confidence: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::hasEmbeddings", "name": "hasEmbeddings", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Check if embeddings are available.\n */\nexport function hasEmbeddings(): boolean {\n  loadEmbeddings();\n  return embeddings !== null;\n}", "parameters": [], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getEmbedding", "name": "getEmbedding", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get the embedding vector for a word.\n */\nexport function getEmbedding(word: string): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const normalized = word.toLowerCase().replace(/[^a-z]/g, '');\n  return embeddings.words[normalized] ?? null;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number[] | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getEmbeddingSimilarity", "name": "getEmbeddingSimilarity", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get similarity between two words (0-1).\n */\nexport function getEmbeddingSimilarity(word1: string, word2: string): number | null {\n  const v1 = getEmbedding(word1);\n  const v2 = getEmbedding(word2);\n\n  if (!v1 || !v2) return null;\n\n  // Cosine similarity returns -1 to 1, normalize to 0-1\n  const sim = cosineSimilarity(v1, v2);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word1", "type": "string", "optional": false}, {"name": "word2", "type": "string", "optional": false}], "returnType": "number | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::findMostSimilar", "name": "findMostSimilar", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Find the most similar word in vocabulary.\n */\nexport function findMostSimilar(word: string, topK: number = 5): Array<{ word: string; similarity: number }> {\n  loadEmbeddings();\n  if (!embeddings) return [];\n\n  const targetVec = getEmbedding(word);\n  if (!targetVec) return [];\n\n  const similarities: Array<{ word: string; similarity: number }> = [];\n\n  for (const [w, vec] of Object.entries(embeddings.words)) {\n    if (w === word.toLowerCase()) continue;\n\n    const sim = cosineSimilarity(targetVec, vec);\n    similarities.push({ word: w, similarity: (sim + 1) / 2 });\n  }\n\n  return [...similarities]\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, topK);\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "topK", "type": "number", "optional": true}], "returnType": "Array<{ word: string; similarity: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/index.ts::getVocabularyStats", "name": "getVocabularyStats", "kind": "function", "filePath": "apps/cosmographer/lib/index.ts", "sourceCode": "/**\n * Get vocabulary statistics.\n */\nexport function getVocabularyStats(): {\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n} {\n  loadEmbeddings();\n  return {\n    loaded: embeddings !== null,\n    wordCount: embeddings ? Object.keys(embeddings.words).length : 0,\n    dimensions: embeddings?.dimensions ?? 0\n  };\n}", "parameters": [], "returnType": "{\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types/index.js", "specifiers": ["CosmographerInput", "CosmographerOutput", "PlaneClassification"], "category": "internal"}, {"source": "./analysis/index.js", "specifiers": ["classifyPlanes", "getMatchedKeywords"], "category": "internal"}, {"source": "./generator/index.js", "specifiers": ["generateHierarchy", "generateDistances", "generateAxisWeights"], "category": "internal"}, {"source": "./ontology/index.js", "specifiers": ["registerCustomCategory"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "CategoryId", "DomainClass", "SemanticAnalysisResult", "CategoryDefinition"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategoriesForDomain", "getCategory"], "category": "internal"}, {"source": "../embeddings/loader.js", "specifiers": ["getEmbeddingSimilarity", "hasEmbeddings"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "CategoryId", "DomainClass", "SemanticAnalysisResult", "CategoryDefinition"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategoriesForDomain", "getCategory"], "category": "internal"}, {"source": "../embeddings/loader.js", "specifiers": ["getEmbeddingSimilarity", "hasEmbeddings"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/analysis/classifier.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/classifier.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "CategoryId", "DomainClass", "SemanticAnalysisResult", "CategoryDefinition"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategoriesForDomain", "getCategory"], "category": "internal"}, {"source": "../embeddings/loader.js", "specifiers": ["getEmbeddingSimilarity", "hasEmbeddings"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/analysis/index.ts::classifyPlane", "name": "classifyPlane", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Classify a plane specification into a category.\n */\nexport function classifyPlane(\n  plane: PlaneSpecification,\n  config: Partial<ClassifierConfig> = {}\n): SemanticAnalysisResult {\n  const cfg = { ...DEFAULT_CONFIG, ...config };\n\n  // If plane has explicit category hint, use it\n  if (plane.hints?.category) {\n    const hintedCategory = getCategory(plane.hints.category);\n    if (hintedCategory) {\n      return {\n        planeId: plane.id,\n        scores: new Map([[plane.hints.category, 1.0]]),\n        bestMatch: plane.hints.category,\n        confidence: 1.0\n      };\n    }\n  }\n\n  const categories = getCategoriesForDomain(cfg.domainClass);\n  const scores = new Map<CategoryId, number>();\n\n  for (const category of categories) {\n    const kw = keywordScore(plane, category) * cfg.keywordWeight;\n    const fz = fuzzyScore(plane, category) * cfg.fuzzyWeight;\n    const em = cfg.embeddingWeight > 0\n      ? embeddingScore(plane, category) * cfg.embeddingWeight\n      : 0;\n\n    const totalScore = kw + fz + em;\n    if (totalScore >= cfg.minConfidence) {\n      scores.set(category.id, totalScore);\n    }\n  }\n\n  // Find best match\n  let bestMatch: CategoryId = 'surface'; // Default fallback\n  let bestScore = 0;\n\n  for (const [categoryId, score] of scores) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestMatch = categoryId;\n    }\n  }\n\n  // Normalize confidence (max possible is sum of weights)\n  const maxPossible = cfg.keywordWeight + cfg.fuzzyWeight + cfg.embeddingWeight;\n  const confidence = bestScore / maxPossible;\n\n  return {\n    planeId: plane.id,\n    scores,\n    bestMatch,\n    confidence\n  };\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "SemanticAnalysisResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/analysis/index.ts::classifyPlanes", "name": "classifyPlanes", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Classify multiple planes.\n */\nexport function classifyPlanes(\n  planes: PlaneSpecification[],\n  config: Partial<ClassifierConfig> = {}\n): Map<string, SemanticAnalysisResult> {\n  const results = new Map<string, SemanticAnalysisResult>();\n\n  for (const plane of planes) {\n    const result = classifyPlane(plane, config);\n    results.set(plane.id, result);\n  }\n\n  return results;\n}", "parameters": [{"name": "planes", "type": "PlaneSpecification[]", "optional": false}, {"name": "config", "type": "Partial<ClassifierConfig>", "optional": true}], "returnType": "Map<string, SemanticAnalysisResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/analysis/index.ts::getMatchedKeywords", "name": "getMatchedKeywords", "kind": "function", "filePath": "apps/cosmographer/lib/analysis/index.ts", "sourceCode": "/**\n * Get all keywords that matched for a plane.\n */\nexport function getMatchedKeywords(\n  plane: PlaneSpecification,\n  categoryId: CategoryId\n): string[] {\n  const category = getCategory(categoryId);\n  if (!category) return [];\n\n  const planeTokens = new Set([\n    ...tokenize(plane.id),\n    ...tokenize(plane.label),\n    ...(plane.description ? tokenize(plane.description) : [])\n  ]);\n\n  const allKeywords = [...category.keywords, ...(category.synonyms ?? [])];\n  const matched: string[] = [];\n\n  for (const keyword of allKeywords) {\n    const keywordTokens = tokenize(keyword);\n    if (keywordTokens.some(kt => planeTokens.has(kt))) {\n      matched.push(keyword);\n    }\n  }\n\n  return matched;\n}", "parameters": [{"name": "plane", "type": "PlaneSpecification", "optional": false}, {"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::hasEmbeddings", "name": "hasEmbeddings", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Check if embeddings are available.\n */\nexport function hasEmbeddings(): boolean {\n  loadEmbeddings();\n  return embeddings !== null;\n}", "parameters": [], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getEmbedding", "name": "getEmbedding", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get the embedding vector for a word.\n */\nexport function getEmbedding(word: string): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const normalized = word.toLowerCase().replace(/[^a-z]/g, '');\n  return embeddings.words[normalized] ?? null;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}], "returnType": "number[] | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getEmbeddingSimilarity", "name": "getEmbeddingSimilarity", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get similarity between two words (0-1).\n */\nexport function getEmbeddingSimilarity(word1: string, word2: string): number | null {\n  const v1 = getEmbedding(word1);\n  const v2 = getEmbedding(word2);\n\n  if (!v1 || !v2) return null;\n\n  // Cosine similarity returns -1 to 1, normalize to 0-1\n  const sim = cosineSimilarity(v1, v2);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word1", "type": "string", "optional": false}, {"name": "word2", "type": "string", "optional": false}], "returnType": "number | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::findMostSimilar", "name": "findMostSimilar", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Find the most similar word in vocabulary.\n */\nexport function findMostSimilar(word: string, topK: number = 5): Array<{ word: string; similarity: number }> {\n  loadEmbeddings();\n  if (!embeddings) return [];\n\n  const targetVec = getEmbedding(word);\n  if (!targetVec) return [];\n\n  const similarities: Array<{ word: string; similarity: number }> = [];\n\n  for (const [w, vec] of Object.entries(embeddings.words)) {\n    if (w === word.toLowerCase()) continue;\n\n    const sim = cosineSimilarity(targetVec, vec);\n    similarities.push({ word: w, similarity: (sim + 1) / 2 });\n  }\n\n  return [...similarities]\n    .sort((a, b) => b.similarity - a.similarity)\n    .slice(0, topK);\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "topK", "type": "number", "optional": true}], "returnType": "Array<{ word: string; similarity: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Calculate centroid of multiple words.\n */\nexport function calculateCentroid(words: string[]): number[] | null {\n  loadEmbeddings();\n  if (!embeddings) return null;\n\n  const vectors: number[][] = [];\n  for (const word of words) {\n    const vec = getEmbedding(word);\n    if (vec) vectors.push(vec);\n  }\n\n  if (vectors.length === 0) return null;\n\n  const dimensions = embeddings.dimensions;\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\n\n  for (const vec of vectors) {\n    for (let i = 0; i < dimensions; i++) {\n      centroid[i] += vec[i];\n    }\n  }\n\n  for (let i = 0; i < dimensions; i++) {\n    centroid[i] /= vectors.length;\n  }\n\n  return centroid;\n}", "parameters": [{"name": "words", "type": "string[]", "optional": false}], "returnType": "number[] | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::similarityToCentroid", "name": "similarityToCentroid", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get similarity between a word and a centroid.\n */\nexport function similarityToCentroid(word: string, centroid: number[]): number | null {\n  const vec = getEmbedding(word);\n  if (!vec) return null;\n\n  const sim = cosineSimilarity(vec, centroid);\n  return (sim + 1) / 2;\n}", "parameters": [{"name": "word", "type": "string", "optional": false}, {"name": "centroid", "type": "number[]", "optional": false}], "returnType": "number | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/embeddings/loader.ts::getVocabularyStats", "name": "getVocabularyStats", "kind": "function", "filePath": "apps/cosmographer/lib/embeddings/loader.ts", "sourceCode": "/**\n * Get vocabulary statistics.\n */\nexport function getVocabularyStats(): {\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n} {\n  loadEmbeddings();\n  return {\n    loaded: embeddings !== null,\n    wordCount: embeddings ? Object.keys(embeddings.words).length : 0,\n    dimensions: embeddings?.dimensions ?? 0\n  };\n}", "parameters": [], "returnType": "{\n  loaded: boolean;\n  wordCount: number;\n  dimensions: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "fs", "specifiers": ["readFileSync", "existsSync"], "category": "external"}, {"source": "path", "specifiers": ["join", "dirname"], "category": "external"}, {"source": "url", "specifiers": ["fileURLToPath"], "category": "external"}]}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "SemanticAnalysisResult", "GeneratedPlaneHierarchy", "CosmographerInput"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategory", "canBeChildOf", "categoryDistance"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "SemanticAnalysisResult", "GeneratedPlaneHierarchy", "CosmographerInput"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategory", "canBeChildOf", "categoryDistance"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/generator/hierarchy.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/generator/hierarchy.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["PlaneSpecification", "SemanticAnalysisResult", "GeneratedPlaneHierarchy", "CosmographerInput"], "category": "internal"}, {"source": "../ontology/index.js", "specifiers": ["getCategory", "canBeChildOf", "categoryDistance"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/generator/index.ts::generateHierarchy", "name": "generateHierarchy", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate plane hierarchy from input and classifications.\n */\nexport function generateHierarchy(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): GeneratedPlaneHierarchy[] {\n  // Build nodes\n  const nodes = new Map<string, PlaneNode>();\n\n  for (const spec of input.planes) {\n    const classification = classifications.get(spec.id);\n    if (!classification) continue;\n\n    const node: PlaneNode = {\n      id: spec.id,\n      spec,\n      classification,\n      priority: determinePriority(spec, classification),\n      saturationThreshold: determineSaturation(spec, classification),\n      children: [],\n      visited: false\n    };\n\n    nodes.set(spec.id, node);\n  }\n\n  // Determine children for each node\n  for (const node of nodes.values()) {\n    node.children = determineChildren(node, nodes);\n  }\n\n  // Remove circular references (child can't also be ancestor)\n  for (const node of nodes.values()) {\n    const ancestors = new Set<string>();\n\n    // Walk up to find ancestors\n    for (const [id, n] of nodes) {\n      if (n.children.includes(node.id)) {\n        ancestors.add(id);\n      }\n    }\n\n    // Remove any ancestors from children\n    node.children = node.children.filter(id => !ancestors.has(id));\n  }\n\n  // Build traversal order\n  const order = buildHierarchyOrder(nodes);\n\n  // Generate output\n  const hierarchy: GeneratedPlaneHierarchy[] = [];\n\n  for (let i = 0; i < order.length; i++) {\n    const id = order[i];\n    const node = nodes.get(id);\n    if (!node) continue;\n\n    // Filter children to only include those that come after in order\n    const orderSet = new Set(order.slice(i + 1));\n    const validChildren = node.children.filter(c => orderSet.has(c));\n\n    hierarchy.push({\n      planeId: id,\n      children: validChildren,\n      saturationThreshold: node.saturationThreshold,\n      priority: i + 1 // Renumber based on actual order\n    });\n  }\n\n  return hierarchy;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "GeneratedPlaneHierarchy[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/generator/index.ts::generateDistances", "name": "generateDistances", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate cross-plane distance matrix.\n */\nexport function generateDistances(\n  input: CosmographerInput,\n  classifications: Map<string, SemanticAnalysisResult>\n): Record<string, Record<string, number>> {\n  const distances: Record<string, Record<string, number>> = {};\n  const planeIds = input.planes.map(p => p.id);\n\n  // Build hint lookup\n  const hintMap = new Map<string, number>();\n  for (const hint of input.distanceHints ?? []) {\n    const key = `${hint.from}:${hint.to}`;\n    const value = typeof hint.hint === 'number'\n      ? hint.hint\n      : hintToNumber(hint.hint);\n    hintMap.set(key, value);\n    hintMap.set(`${hint.to}:${hint.from}`, value); // Symmetric\n  }\n\n  for (const from of planeIds) {\n    distances[from] = {};\n\n    for (const to of planeIds) {\n      distances[from][to] = computePairDistance(from, to, hintMap, classifications);\n    }\n  }\n\n  return distances;\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}, {"name": "classifications", "type": "Map<string, SemanticAnalysisResult>", "optional": false}], "returnType": "Record<string, Record<string, number>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/generator/index.ts::generateAxisWeights", "name": "generateAxisWeights", "kind": "function", "filePath": "apps/cosmographer/lib/generator/index.ts", "sourceCode": "/**\n * Generate axis weights based on domain class.\n */\nexport function generateAxisWeights(\n  input: CosmographerInput\n): {\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n} {\n  // Base weights depend on space type\n  switch (input.spaceType) {\n    case 'spatial':\n      // Physical space - plane changes expensive\n      return {\n        plane: 10.0,\n        sector_x: 1.0,\n        sector_y: 1.0,\n        cell_x: 0.1,\n        cell_y: 0.1,\n        z_band: 2.0\n      };\n\n    case 'metaphysical':\n      // Spirit planes - more fluid transitions\n      return {\n        plane: 5.0,\n        sector_x: 0.5,\n        sector_y: 0.5,\n        cell_x: 0.05,\n        cell_y: 0.05,\n        z_band: 3.0\n      };\n\n    case 'conceptual':\n      // Abstract systems - sector matters less\n      return {\n        plane: 8.0,\n        sector_x: 0.3,\n        sector_y: 0.3,\n        cell_x: 0.02,\n        cell_y: 0.02,\n        z_band: 1.0\n      };\n\n    case 'hybrid':\n    default:\n      // Balanced\n      return {\n        plane: 7.0,\n        sector_x: 0.7,\n        sector_y: 0.7,\n        cell_x: 0.07,\n        cell_y: 0.07,\n        z_band: 1.5\n      };\n  }\n}", "parameters": [{"name": "input", "type": "CosmographerInput", "optional": false}], "returnType": "{\n  plane: number;\n  sector_x: number;\n  sector_y: number;\n  cell_x: number;\n  cell_y: number;\n  z_band: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::canBeChildOf", "name": "canBeChildOf", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Check if a category can be a child of another.\n */\nexport function canBeChildOf(childId: CategoryId, parentId: CategoryId): boolean {\n  const parent = CATEGORY_REGISTRY.get(parentId);\n  const child = CATEGORY_REGISTRY.get(childId);\n\n  if (!parent || !child) return false;\n\n  // Check if child is in parent's typical children\n  if (parent.typicalChildren.includes(childId)) return true;\n\n  // Check if parent is in child's typical parents\n  if (child.typicalParents.includes(parentId)) return true;\n\n  // Check incompatibility\n  if (parent.incompatibleWith.includes(childId)) return false;\n  if (child.incompatibleWith.includes(parentId)) return false;\n\n  // Default: allow if same domain class or parent is broader\n  return parent.domainClass === child.domainClass;\n}", "parameters": [{"name": "childId", "type": "CategoryId", "optional": false}, {"name": "parentId", "type": "CategoryId", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::getValidChildren", "name": "getValidChildren", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Get valid children for a category.\n */\nexport function getValidChildren(categoryId: CategoryId): CategoryId[] {\n  const category = CATEGORY_REGISTRY.get(categoryId);\n  if (!category) return [];\n\n  const validChildren: CategoryId[] = [];\n\n  for (const [id] of CATEGORY_REGISTRY) {\n    if (id === categoryId) continue;\n    if (canBeChildOf(id, categoryId)) {\n      validChildren.push(id);\n    }\n  }\n\n  return validChildren;\n}", "parameters": [{"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "CategoryId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::categoryDistance", "name": "categoryDistance", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Calculate semantic distance between two categories.\n * Lower = more similar.\n */\nexport function categoryDistance(cat1Id: CategoryId, cat2Id: CategoryId): number {\n  if (cat1Id === cat2Id) return 0;\n\n  const cat1 = CATEGORY_REGISTRY.get(cat1Id);\n  const cat2 = CATEGORY_REGISTRY.get(cat2Id);\n\n  if (!cat1 || !cat2) return Infinity;\n\n  let distance = 1.0;\n\n  // Same domain class = closer\n  if (cat1.domainClass !== cat2.domainClass) {\n    distance += 2.0;\n  }\n\n  // Typical parent-child relationship = closer\n  if (cat1.typicalChildren.includes(cat2Id) || cat2.typicalChildren.includes(cat1Id)) {\n    distance -= 0.5;\n  }\n\n  // Incompatible = farther\n  if (cat1.incompatibleWith.includes(cat2Id)) {\n    distance += 3.0;\n  }\n\n  // Priority difference affects distance\n  distance += Math.abs(cat1.basePriority - cat2.basePriority) * 0.2;\n\n  return Math.max(0, distance);\n}", "parameters": [{"name": "cat1Id", "type": "CategoryId", "optional": false}, {"name": "cat2Id", "type": "CategoryId", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/categories.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/categories.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../types/index.js", "specifiers": ["CategoryDefinition", "CategoryId", "DomainClass"], "category": "internal"}, {"source": "./domains/physical.js", "specifiers": ["PHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/metaphysical.js", "specifiers": ["METAPHYSICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/legal.js", "specifiers": ["LEGAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/magical.js", "specifiers": ["MAGICAL_CATEGORIES"], "category": "internal"}, {"source": "./domains/social.js", "specifiers": ["SOCIAL_CATEGORIES"], "category": "internal"}]}, {"id": "apps/cosmographer/lib/ontology/index.ts::getCategory", "name": "getCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get a category by ID.\n */\nexport function getCategory(id: CategoryId): CategoryDefinition | undefined {\n  return CATEGORY_REGISTRY.get(id);\n}", "parameters": [{"name": "id", "type": "CategoryId", "optional": false}], "returnType": "CategoryDefinition | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::getCategoriesForDomain", "name": "getCategoriesForDomain", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get all categories for a domain class.\n */\nexport function getCategoriesForDomain(domainClass: DomainClass): CategoryDefinition[] {\n  return CATEGORIES_BY_DOMAIN.get(domainClass) ?? [];\n}", "parameters": [{"name": "domainClass", "type": "DomainClass", "optional": false}], "returnType": "CategoryDefinition[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::getAllCategoryIds", "name": "getAllCategoryIds", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get all category IDs.\n */\nexport function getAllCategoryIds(): CategoryId[] {\n  return Array.from(CATEGORY_REGISTRY.keys());\n}", "parameters": [], "returnType": "CategoryId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::canBeChildOf", "name": "canBeChildOf", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Check if a category can be a child of another.\n */\nexport function canBeChildOf(childId: CategoryId, parentId: CategoryId): boolean {\n  const parent = CATEGORY_REGISTRY.get(parentId);\n  const child = CATEGORY_REGISTRY.get(childId);\n\n  if (!parent || !child) return false;\n\n  // Check if child is in parent's typical children\n  if (parent.typicalChildren.includes(childId)) return true;\n\n  // Check if parent is in child's typical parents\n  if (child.typicalParents.includes(parentId)) return true;\n\n  // Check incompatibility\n  if (parent.incompatibleWith.includes(childId)) return false;\n  if (child.incompatibleWith.includes(parentId)) return false;\n\n  // Default: allow if same domain class or parent is broader\n  return parent.domainClass === child.domainClass;\n}", "parameters": [{"name": "childId", "type": "CategoryId", "optional": false}, {"name": "parentId", "type": "CategoryId", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::getValidChildren", "name": "getValidChildren", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Get valid children for a category.\n */\nexport function getValidChildren(categoryId: CategoryId): CategoryId[] {\n  const category = CATEGORY_REGISTRY.get(categoryId);\n  if (!category) return [];\n\n  const validChildren: CategoryId[] = [];\n\n  for (const [id] of CATEGORY_REGISTRY) {\n    if (id === categoryId) continue;\n    if (canBeChildOf(id, categoryId)) {\n      validChildren.push(id);\n    }\n  }\n\n  return validChildren;\n}", "parameters": [{"name": "categoryId", "type": "CategoryId", "optional": false}], "returnType": "CategoryId[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::categoryDistance", "name": "categoryDistance", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Calculate semantic distance between two categories.\n * Lower = more similar.\n */\nexport function categoryDistance(cat1Id: CategoryId, cat2Id: CategoryId): number {\n  if (cat1Id === cat2Id) return 0;\n\n  const cat1 = CATEGORY_REGISTRY.get(cat1Id);\n  const cat2 = CATEGORY_REGISTRY.get(cat2Id);\n\n  if (!cat1 || !cat2) return Infinity;\n\n  let distance = 1.0;\n\n  // Same domain class = closer\n  if (cat1.domainClass !== cat2.domainClass) {\n    distance += 2.0;\n  }\n\n  // Typical parent-child relationship = closer\n  if (cat1.typicalChildren.includes(cat2Id) || cat2.typicalChildren.includes(cat1Id)) {\n    distance -= 0.5;\n  }\n\n  // Incompatible = farther\n  if (cat1.incompatibleWith.includes(cat2Id)) {\n    distance += 3.0;\n  }\n\n  // Priority difference affects distance\n  distance += Math.abs(cat1.basePriority - cat2.basePriority) * 0.2;\n\n  return Math.max(0, distance);\n}", "parameters": [{"name": "cat1Id", "type": "CategoryId", "optional": false}, {"name": "cat2Id", "type": "CategoryId", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/cosmographer/lib/ontology/index.ts::registerCustomCategory", "name": "registerCustomCategory", "kind": "function", "filePath": "apps/cosmographer/lib/ontology/index.ts", "sourceCode": "/**\n * Register a custom category from domain.\n */\nexport function registerCustomCategory(category: CategoryDefinition): void {\n  CATEGORY_REGISTRY.set(category.id, category);\n\n  const domainCategories = CATEGORIES_BY_DOMAIN.get(category.domainClass);\n  if (domainCategories) {\n    domainCategories.push(category);\n  }\n}", "parameters": [{"name": "category", "type": "CategoryDefinition", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/TagSelector.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/TagSelector.jsx", "sourceCode": "export default function TagSelector({\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [highlightedIndex, setHighlightedIndex] = useState(0);\n  const [hoveredInvalidTag, setHoveredInvalidTag] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const tagLookup = useMemo(() => {\n    const lookup = {};\n    tagRegistry.forEach((tagDef) => {\n      lookup[tagDef.tag] = tagDef;\n    });\n    return lookup;\n  }, [tagRegistry]);\n\n  const groupedTags = useMemo(() => {\n    const groups = {};\n    const filtered = tagRegistry.filter((tagDef) => {\n      const normalizedQuery = searchQuery.toLowerCase();\n      const matchesSearch =\n        !searchQuery ||\n        tagDef.tag.toLowerCase().includes(normalizedQuery) ||\n        tagDef.description?.toLowerCase().includes(normalizedQuery);\n      return matchesSearch && !value.includes(tagDef.tag);\n    });\n\n    filtered.forEach((tagDef) => {\n      if (!groups[tagDef.category]) {\n        groups[tagDef.category] = [];\n      }\n      groups[tagDef.category].push(tagDef);\n    });\n\n    return groups;\n  }, [searchQuery, tagRegistry, value]);\n\n  const canCreateTag = useMemo(() => {\n    if (!searchQuery.trim()) return false;\n    const normalized = searchQuery.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');\n    if (!normalized) return false;\n    if (tagLookup[normalized]) return false;\n    if (value.includes(normalized)) return false;\n    return normalized;\n  }, [searchQuery, tagLookup, value]);\n\n  const flatOptions = useMemo(() => {\n    const result = [];\n    Object.entries(groupedTags).forEach(([_category, tags]) => {\n      tags.forEach((tagDef) => result.push({ type: 'existing', ...tagDef }));\n    });\n    if (canCreateTag) {\n      result.push({ type: 'create', tag: canCreateTag });\n    }\n    return result;\n  }, [groupedTags, canCreateTag]);\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (containerRef.current && !containerRef.current.contains(event.target)) {\n        setIsOpen(false);\n        setHoveredInvalidTag(null);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleKeyDown = (event) => {\n    if (!isOpen) {\n      if (event.key === 'Enter' || event.key === 'ArrowDown') {\n        event.preventDefault();\n        setIsOpen(true);\n      }\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.min(index + 1, flatOptions.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.max(index - 1, 0));\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (!flatOptions[highlightedIndex]) return;\n        if (flatOptions[highlightedIndex].type === 'create') {\n          handleCreateAndSelect(flatOptions[highlightedIndex].tag);\n        } else {\n          handleSelectTag(flatOptions[highlightedIndex].tag);\n        }\n        break;\n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        break;\n      case 'Backspace':\n        if (searchQuery === '' && value.length > 0) {\n          handleRemoveTag(value[value.length - 1]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleSelectTag = (tag) => {\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemoveTag = (tag) => {\n    onChange(value.filter((item) => item !== tag));\n  };\n\n  const handleCreateAndSelect = (tag) => {\n    if (onAddToRegistry) {\n      onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n    }\n\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleInvalidTagMouseEnter = (tag) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredInvalidTag(tag);\n  };\n\n  const handleInvalidTagMouseLeave = () => {\n    hoverTimeoutRef.current = setTimeout(() => {\n      setHoveredInvalidTag(null);\n    }, 150);\n  };\n\n  const handlePopupMouseEnter = () => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n  };\n\n  const renderRarityDots = (rarity) => {\n    const count = RARITY_DOTS[rarity] || RARITY_DOTS.common;\n    return (\n      <span className=\"tag-selector-rarity-dots\">\n        {Array.from({ length: count }).map((_, index) => (\n          <span key={index} className={`tag-selector-rarity-dot ${getRarityClass(rarity)}`} />\n        ))}\n      </span>\n    );\n  };\n\n  return (\n    <div ref={containerRef} className=\"tag-selector\">\n      <div\n        className={`tag-selector-input-wrapper ${isOpen ? 'tag-selector-input-wrapper-open' : 'tag-selector-input-wrapper-closed'}`}\n        onClick={() => {\n          setIsOpen(true);\n          inputRef.current?.focus();\n        }}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(event) => {\n          if (event.key === 'Enter' || event.key === ' ') {\n            event.currentTarget.click();\n          }\n        }}\n      >\n        {value.map((tag) => {\n          const tagMeta = tagLookup[tag];\n          const isInvalid = !tagMeta;\n          const categoryClass = isInvalid ? 'tag-selector-category-invalid' : getCategoryClass(tagMeta.category);\n\n          return (\n            <span\n              key={tag}\n              className={`tag-selector-chip ${categoryClass}`}\n              title={isInvalid ? 'Tag not in registry - hover to add' : tagMeta?.description}\n              onMouseEnter={() => isInvalid && onAddToRegistry && handleInvalidTagMouseEnter(tag)}\n              onMouseLeave={() => isInvalid && handleInvalidTagMouseLeave()}\n            >\n              {isInvalid && <span className=\"tag-selector-invalid-warning\">\u26a0</span>}\n              {tag}\n              {tagMeta?.isAxis && <span title=\"Semantic plane axis label\" className=\"tag-selector-axis-indicator\">\u2194</span>}\n              {tagMeta && renderRarityDots(tagMeta.rarity)}\n              <button\n                type=\"button\"\n                className=\"tag-selector-remove-button\"\n                onClick={(event) => {\n                  event.stopPropagation();\n                  handleRemoveTag(tag);\n                }}\n              >\n                \u00d7\n              </button>\n              {isInvalid && hoveredInvalidTag === tag && onAddToRegistry && (\n                <div\n                  className=\"tag-selector-invalid-popup\"\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n                    setHoveredInvalidTag(null);\n                  }}\n                  onMouseEnter={handlePopupMouseEnter}\n                  onMouseLeave={() => setHoveredInvalidTag(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(event) => {\n                    if (event.key === 'Enter' || event.key === ' ') {\n                      event.currentTarget.click();\n                    }\n                  }}\n                >\n                  + Add to registry\n                </div>\n              )}\n            </span>\n          );\n        })}\n\n        <input\n          ref={inputRef}\n          type=\"text\"\n          className=\"tag-selector-search-input\"\n          value={searchQuery}\n          onChange={(event) => {\n            setSearchQuery(event.target.value);\n            setHighlightedIndex(0);\n          }}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsOpen(true)}\n          placeholder={value.length === 0 ? placeholder : ''}\n        />\n      </div>\n\n      {matchAllEnabled && value.length > 1 && (\n        <div className=\"tag-selector-match-all\">\n          <label className=\"tag-selector-match-all-label\">\n            <input\n              type=\"checkbox\"\n              className=\"tag-selector-match-all-checkbox\"\n              checked={matchAll}\n              onChange={(event) => onMatchAllChange?.(event.target.checked)}\n            />\n            Match all tags (AND)\n          </label>\n          <span className=\"tag-selector-match-all-hint\">\n            {matchAll ? 'Entity must have all tags' : 'Entity must have any tag'}\n          </span>\n        </div>\n      )}\n\n      {isOpen && (\n        <div className=\"tag-selector-dropdown\">\n          {canCreateTag && onAddToRegistry && (\n            <div\n              className={`tag-selector-create-option ${highlightedIndex === flatOptions.length - 1 ? 'tag-selector-create-option-highlighted' : ''}`}\n              onClick={() => handleCreateAndSelect(canCreateTag)}\n              onMouseEnter={() => setHighlightedIndex(flatOptions.length - 1)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(event) => {\n                if (event.key === 'Enter' || event.key === ' ') {\n                  event.currentTarget.click();\n                }\n              }}\n            >\n// ... (truncated)", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}", "type": "{ value?: any[]; onChange: any; tagRegistry?: any[]; onAddToRegistry: any; placeholder?: string; matchAllEnabled?: boolean; matchAll?: boolean; onMatchAllChange: any; singleSelect?: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./TagSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/IlluminatorRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/IlluminatorRemote.jsx", "sourceCode": "export default function IlluminatorRemote({\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}) {\n  const activeTab = activeSection || \"entities\";\n  const setActiveTab = onSectionChange || (() => {});\n  const [chronicleRefreshTrigger, setChronicleRefreshTrigger] = useState(0);\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominenceScale = useProminenceScale();\n  const apiKeys = useApiKeys();\n  const { config, updateConfig } = useConfigSync({\n    externalEnrichmentConfig,\n    onEnrichmentConfigChange,\n  });\n  const { worldContext, updateWorldContext } = useWorldContextSync({\n    externalWorldContext,\n    onWorldContextChange,\n  });\n  const guidance = useEntityGuidanceSync({\n    externalEntityGuidance,\n    onEntityGuidanceChange,\n    externalCultureIdentities,\n    onCultureIdentitiesChange,\n  });\n  const { historianConfig, updateHistorianConfig } = useHistorianConfigSync({\n    externalHistorianConfig,\n    onHistorianConfigChange,\n  });\n  const slot = useSlotManagement({ projectId, activeSlotIndex, navEntities });\n  const dataSync = useDataSync({\n    projectId,\n    activeSlotIndex,\n    worldData,\n    hasHardState: Boolean(worldData?.hardState?.length),\n    slotRecord: slot.slotRecord,\n    setSlotRecord: slot.setSlotRecord,\n    simulationRunId: slot.simulationRunId,\n    eraTemporalInfo: slot.eraTemporalInfo,\n  });\n  const setup = useIlluminatorSetup({\n    projectId,\n    worldData,\n    schema,\n    onStyleSelectionChange,\n    config,\n    apiKeys,\n    slotRecord: slot.slotRecord,\n    currentEra: slot.currentEra,\n    simulationRunId: slot.simulationRunId,\n    handleEntityUpdate: dataSync.handleEntityUpdate,\n    reloadEntities: dataSync.reloadEntities,\n    reloadEntitiesAndEvents: dataSync.reloadEntitiesAndEvents,\n    worldContext,\n    historianConfig,\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    navEntities,\n    setChronicleRefreshTrigger,\n  });\n  const { buildPrompt, getVisualConfig } = usePromptBuilder({\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    worldContext,\n    relationshipsByEntity,\n    entityNavMap,\n    currentEra: slot.currentEra,\n    narrativeEvents,\n    prominentByCulture: slot.prominentByCulture,\n    styleSelection: setup.styleSelection,\n    worldSchema: setup.worldSchema,\n    config,\n    prominenceScale,\n    styleLibrary: setup.styleLibrary,\n    eraTemporalInfo: slot.eraTemporalInfo,\n    eraTemporalInfoByKey: slot.eraTemporalInfoByKey,\n  });\n  const flows = useIlluminatorFlows({\n    projectId,\n    simulationRunId: slot.simulationRunId,\n    navEntities,\n    entityNavMap,\n    relationshipsByEntity,\n    relationships,\n    prominenceScale,\n    worldContext,\n    worldSchema: setup.worldSchema,\n    entityGuidance: guidance.entityGuidance,\n    reloadEntities: dataSync.reloadEntities,\n    setChronicleRefreshTrigger,\n    historianConfig,\n    updateWorldContext,\n  });\n  if (!setup.hasWorldData) {\n    return (\n      <EmptyState\n        icon=\"\u2728\"\n        title={setup.canImport ? \"No Local Data Loaded\" : \"No World Data\"}\n        className=\"illuminator-empty-state\"\n      >\n        <div className=\"empty-state-desc\">\n          {setup.canImport ? (\n            \"Dexie is empty for this slot. Import from hard state to begin.\"\n          ) : (\n            <>\n              Run a simulation in <strong>Lore Weave</strong> first, then return here to enrich your\n              world with LLM-generated descriptions and images.\n            </>\n          )}\n        </div>\n        {setup.canImport && (\n          <div className=\"ies-import-actions\">\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-primary\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"patch\")}\n            >\n              {dataSync.isDataSyncing ? \"Importing...\" : \"Patch from Hard State\"}\n            </button>\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-danger\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"overwrite\")}\n            >\n              Overwrite from Hard State\n            </button>\n          </div>\n        )}\n        {dataSync.dataSyncStatus && (\n          <div\n            className={`ies-sync-status ${dataSync.dataSyncStatus.type === \"error\" ? \"ies-sync-status-error\" : \"ies-sync-status-success\"}`}\n          >\n            {dataSync.dataSyncStatus.message}\n          </div>\n        )}\n      </EmptyState>\n    );\n  }\n  const sharedProps = buildSharedProps({\n    activeTab,\n    setActiveTab,\n    worldData,\n    updateWorldContext,\n    guidance,\n    updateHistorianConfig,\n    config,\n    updateConfig,\n    buildPrompt,\n    getVisualConfig,\n    chronicleRefreshTrigger,\n    setChronicleRefreshTrigger,\n    setup,\n    dataSync,\n    flows,\n    apiKeys,\n  });\n  return (\n    <div className=\"illuminator-container\">\n      <IlluminatorSidebar\n        activeTab={activeTab}\n        setActiveTab={setActiveTab}\n        stats={setup.stats}\n        imageGenSettings={setup.imageGenSettings}\n        styleLibrary={setup.styleLibrary}\n        {...apiKeys}\n      />\n      <div className=\"illuminator-main\">\n        {setup.isTemporarySlot && (\n          <div className=\"illuminator-temp-slot-warning\">\n            <span className=\"illuminator-temp-slot-warning-icon\">&#x26A0;</span>\n            <span>\n              You are enriching data in a <strong>temporary slot</strong>, which will be\n              automatically deleted when a new Lore Weave simulation is run.\n            </span>\n          </div>\n        )}\n        {!apiKeys.hasRequiredKeys && activeTab === \"entities\" && (\n          <div className=\"ilr-api-key-warning\">\n            Set your API keys in the sidebar to enable enrichment.\n          </div>\n        )}\n        <IlluminatorTabContent {...sharedProps} />\n      </div>\n      <IlluminatorModals {...sharedProps} />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./App.css", "specifiers": [], "category": "internal"}, {"source": "./IlluminatorRemote.css", "specifiers": [], "category": "internal"}, {"source": "./hooks/useApiKeys", "specifiers": ["useApiKeys"], "category": "internal"}, {"source": "./hooks/useConfigSync", "specifiers": ["useConfigSync"], "category": "internal"}, {"source": "./hooks/useWorldContextSync", "specifiers": ["useWorldContextSync"], "category": "internal"}, {"source": "./hooks/useEntityGuidanceSync", "specifiers": ["useEntityGuidanceSync"], "category": "internal"}, {"source": "./hooks/useHistorianConfigSync", "specifiers": ["useHistorianConfigSync"], "category": "internal"}, {"source": "./hooks/useSlotManagement", "specifiers": ["useSlotManagement"], "category": "internal"}, {"source": "./hooks/useDataSync", "specifiers": ["useDataSync"], "category": "internal"}, {"source": "./hooks/usePromptBuilder", "specifiers": ["usePromptBuilder"], "category": "internal"}, {"source": "./hooks/useRevisionFlow", "specifiers": ["useRevisionFlow"], "category": "internal"}, {"source": "./hooks/useBackportFlow", "specifiers": ["useBackportFlow"], "category": "internal"}, {"source": "./hooks/useHistorianCallbacks", "specifiers": ["useHistorianCallbacks"], "category": "internal"}, {"source": "./hooks/useDynamicsFlow", "specifiers": ["useDynamicsFlow"], "category": "internal"}, {"source": "./hooks/useIlluminatorSetup", "specifiers": ["useIlluminatorSetup"], "category": "internal"}, {"source": "./lib/db/entitySelectors", "specifiers": ["useEntityNavList", "useEntityNavItems"], "category": "internal"}, {"source": "./lib/db/relationshipSelectors", "specifiers": ["useRelationships", "useRelationshipsByEntity"], "category": "internal"}, {"source": "./lib/db/narrativeEventSelectors", "specifiers": ["useNarrativeEvents"], "category": "internal"}, {"source": "./lib/db/indexSelectors", "specifiers": ["useProminenceScale"], "category": "internal"}, {"source": "./lib/db/imageRepository", "specifiers": ["exportImagePrompts", "downloadImagePromptExport"], "category": "internal"}, {"source": "./lib/db/chronicleRepository", "specifiers": ["repairFactCoverageWasFaceted"], "category": "internal"}, {"source": "./lib/db/indexComputation", "specifiers": ["computeRunIndexes"], "category": "internal"}, {"source": "./lib/db/indexRepository", "specifiers": ["upsertRunIndexes"], "category": "internal"}, {"source": "./lib/db/indexStore", "specifiers": ["useIndexStore"], "category": "internal"}, {"source": "./lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "./components/IlluminatorTabContent", "specifiers": ["IlluminatorTabContent"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["EmptyState"], "category": "external"}, {"source": "./components/IlluminatorSidebar", "specifiers": ["IlluminatorSidebar"], "category": "internal"}, {"source": "./components/IlluminatorModals", "specifiers": ["IlluminatorModals"], "category": "internal"}]}, {"id": "packages/shared-components/src/components/CategorySection.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/CategorySection.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ChipSelect.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ChipSelect.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * @typedef {Object} ChronicleRoleAssignment\r\n * @property {string} role\r\n * @property {string} entityId\r\n * @property {string} entityName\r\n * @property {string} entityKind\r\n * @property {boolean} isPrimary\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleTemporalContext\r\n * @property {{ id: string, name: string, summary?: string }} [focalEra]\r\n * @property {[number, number]} [chronicleTickRange]\r\n * @property {string} [temporalScope]\r\n * @property {boolean} [isMultiEra]\r\n * @property {string[]} [touchedEraIds]\r\n * @property {string} [temporalDescription]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleSeedData\r\n * @property {string} narrativeStyleId\r\n * @property {string} [narrativeStyleName]\r\n * @property {string} [entrypointId]\r\n * @property {string} [entrypointName]\r\n * @property {string} [narrativeDirection]\r\n * @property {ChronicleRoleAssignment[]} roleAssignments\r\n * @property {string[]} selectedEventIds\r\n * @property {string[]} selectedRelationshipIds\r\n * @property {ChronicleTemporalContext} [temporalContext]\r\n */\r\n\r\n/**\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames] - Resolved display names for event IDs\r\n * @param {Map<string, string>} [props.relationshipLabels] - Resolved display labels for relationship IDs\r\n */\r\nexport default function ChronicleSeedViewer({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}) {\r\n  const primaryRoles = seed.roleAssignments.filter((r) => r.isPrimary);\r\n  const supportingRoles = seed.roleAssignments.filter((r) => !r.isPrimary);\r\n\r\n  return (\r\n    <div className=\"csv-container\">\r\n      {/* Style & Entry Point */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Generation Settings</div>\r\n        <div className=\"csv-field\">\r\n          <span className=\"csv-field-label\">Style:</span>\r\n          <span className=\"csv-field-value\">{seed.narrativeStyleName || seed.narrativeStyleId}</span>\r\n        </div>\r\n        {seed.entrypointId && (\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Entry Point:</span>\r\n            <span className=\"csv-field-value\">{seed.entrypointName || seed.entrypointId}</span>\r\n          </div>\r\n        )}\r\n        {seed.narrativeDirection && (\r\n          <div className=\"csv-narrative-direction-wrapper\">\r\n            <div className=\"csv-narrative-direction-label\">\r\n              Narrative Direction:\r\n            </div>\r\n            <div\r\n              className=\"csv-narrative-direction-body\"\r\n              title=\"Click to copy\"\r\n              onClick={() => void navigator.clipboard.writeText(seed.narrativeDirection)}\r\n              role=\"button\"\r\n              tabIndex={0}\r\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n            >\r\n              {seed.narrativeDirection}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Role Assignments */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Cast ({seed.roleAssignments.length} entities)</div>\r\n        {seed.roleAssignments.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No roles assigned</div>\r\n        ) : (\r\n          <div className=\"csv-role-list\">\r\n            {primaryRoles.map((role, i) => (\r\n              <div key={`primary-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-primary-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n            {supportingRoles.map((role, i) => (\r\n              <div key={`supporting-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-supporting-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Temporal Context (optional, used by chronicler) */}\r\n      {seed.temporalContext && (\r\n        <div className=\"csv-section\">\r\n          <div className=\"csv-section-title\">Temporal Context</div>\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Focal Era:</span>\r\n            <span className=\"csv-field-value\">\r\n              {seed.temporalContext.focalEra?.name || \"Unknown\"}\r\n            </span>\r\n          </div>\r\n          {seed.temporalContext.focalEra?.summary && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Era Summary:</span>\r\n              <span className=\"csv-field-value\">{seed.temporalContext.focalEra.summary}</span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.temporalDescription && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Scope:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.temporalDescription}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.chronicleTickRange && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Ticks:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.chronicleTickRange[0]}&ndash;\r\n                {seed.temporalContext.chronicleTickRange[1]}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {typeof seed.temporalContext.isMultiEra === \"boolean\" && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Multi-era:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.isMultiEra ? \"Yes\" : \"No\"}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.touchedEraIds?.length ? (\r\n            <div>\r\n              <div className=\"csv-field-label-spaced\">Touched Eras:</div>\r\n              <div className=\"csv-id-list\">\r\n                {seed.temporalContext.touchedEraIds.map((id) => (\r\n                  <span key={id} className=\"csv-id-tag\">\r\n                    {id}\r\n                  </span>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n      )}\r\n\r\n      {/* Selected Events */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Events ({seed.selectedEventIds.length})</div>\r\n        {seed.selectedEventIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No events selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedEventIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {eventNames?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Selected Relationships */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Relationships ({seed.selectedRelationshipIds.length})</div>\r\n        {seed.selectedRelationshipIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No relationships selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedRelationshipIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {relationshipLabels?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleSeedViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "packages/shared-components/src/components/EmptyState.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/EmptyState.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/EnableToggle.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/EnableToggle.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ExpandableCard.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ExpandableCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/FormGroup.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/IconButton.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/IconButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/InfoBox.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/InfoBox.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/NumberInput.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/NumberInput.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/ReferenceDropdown.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/ReferenceDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect", "useId"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/components/SectionHeader.jsx::default", "name": "default", "kind": "function", "filePath": "packages/shared-components/src/components/SectionHeader.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/schemaUsageMap.js::computeSchemaUsage", "name": "computeSchemaUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/schemaUsageMap.js", "sourceCode": "export function computeSchemaUsage({\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}) {\n  const usage = {\n    entityKinds: {},\n    relationshipKinds: {},\n    subtypes: {},\n    statuses: {},\n  };\n\n  // Helper to ensure usage entry exists\n  const ensureEntityKind = (kind) => {\n    if (!usage.entityKinds[kind]) {\n      usage.entityKinds[kind] = { generators: [], systems: [], actions: [], pressures: [], seeds: [] };\n    }\n  };\n\n  const ensureRelationshipKind = (kind) => {\n    if (!usage.relationshipKinds[kind]) {\n      usage.relationshipKinds[kind] = { generators: [], systems: [], actions: [] };\n    }\n  };\n\n  const ensureSubtype = (entityKind, subtype) => {\n    if (!usage.subtypes[entityKind]) {\n      usage.subtypes[entityKind] = {};\n    }\n    if (!usage.subtypes[entityKind][subtype]) {\n      usage.subtypes[entityKind][subtype] = { generators: [], systems: [], seeds: [] };\n    }\n  };\n\n  const ensureStatus = (entityKind, status) => {\n    if (!usage.statuses[entityKind]) {\n      usage.statuses[entityKind] = {};\n    }\n    if (!usage.statuses[entityKind][status]) {\n      usage.statuses[entityKind][status] = { generators: [], systems: [] };\n    }\n  };\n\n  const addEntityKindUsage = (kind, section, id) => {\n    if (!kind || kind === 'any') return;\n    ensureEntityKind(kind);\n    usage.entityKinds[kind][section].push(id);\n  };\n\n  const addRelationshipKindUsage = (kind, section, id) => {\n    if (!kind) return;\n    ensureRelationshipKind(kind);\n    usage.relationshipKinds[kind][section].push(id);\n  };\n\n  const addSubtypeUsage = (kind, subtype, section, id) => {\n    if (!kind || !subtype) return;\n    ensureSubtype(kind, subtype);\n    usage.subtypes[kind][subtype][section].push(id);\n  };\n\n  const addStatusUsage = (kind, status, section, id) => {\n    if (!kind || !status) return;\n    ensureStatus(kind, status);\n    usage.statuses[kind][status][section].push(id);\n  };\n\n  const recordSelectionUsage = (selection, section, id) => {\n    if (!selection) return;\n    if (selection.kind) addEntityKindUsage(selection.kind, section, id);\n    (selection.kinds || []).forEach((kind) => addEntityKindUsage(kind, section, id));\n  };\n\n  const recordConditionUsage = (condition, section, id) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'entity_count':\n        addEntityKindUsage(condition.kind, section, id);\n        if (condition.subtype) addSubtypeUsage(condition.kind, condition.subtype, section, id);\n        if (condition.status) addStatusUsage(condition.kind, condition.status, section, id);\n        break;\n      case 'relationship_count':\n      case 'relationship_exists':\n      case 'entity_has_relationship':\n        addRelationshipKindUsage(condition.relationshipKind, section, id);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => recordConditionUsage(child, section, id));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const recordMutationUsage = (mutation, section, id) => {\n    if (!mutation) return;\n    if (mutation.type === 'create_relationship' || mutation.type === 'adjust_relationship_strength') {\n      addRelationshipKindUsage(mutation.kind, section, id);\n    } else if (mutation.type === 'archive_relationship') {\n      addRelationshipKindUsage(mutation.relationshipKind, section, id);\n    }\n  };\n\n  // Analyze generators\n  generators.forEach((gen) => {\n    const genId = gen.id || gen.name || 'unnamed';\n\n    // Entity kinds produced (in creation array)\n    const creations = gen.creation || [];\n    creations.forEach((c) => {\n      const kind = typeof c.kind === 'string' ? c.kind : null;\n      if (kind) {\n        addEntityKindUsage(kind, 'generators', genId);\n      }\n      if (kind && typeof c.subtype === 'string') {\n        addSubtypeUsage(kind, c.subtype, 'generators', genId);\n      } else if (kind && c.subtype?.random && Array.isArray(c.subtype.random)) {\n        c.subtype.random.forEach((subtype) => addSubtypeUsage(kind, subtype, 'generators', genId));\n      }\n      if (kind && typeof c.status === 'string') {\n        addStatusUsage(kind, c.status, 'generators', genId);\n      }\n    });\n\n    // Selection kind (the kind being selected from)\n    recordSelectionUsage(gen.selection, 'generators', genId);\n\n    // Applicability rules that reference kinds\n    (gen.applicability || []).forEach((rule) => recordConditionUsage(rule, 'generators', genId));\n\n    // Relationships created (in creation or at top level)\n    const relationships = gen.relationships || [];\n    relationships.forEach((rel) => {\n      const relKind = typeof rel === 'string' ? rel : rel.kind;\n      if (relKind) {\n        addRelationshipKindUsage(relKind, 'generators', genId);\n      }\n    });\n\n    // Relationships in creation entries\n    creations.forEach((c) => {\n      if (c.lineage?.relationshipKind) {\n        addRelationshipKindUsage(c.lineage.relationshipKind, 'generators', genId);\n      }\n    });\n\n    // Requirements (entity kinds in conditions)\n    if (gen.requires) {\n      Object.entries(gen.requires).forEach(([key, value]) => {\n        if (key === 'entityKind' || key === 'kind') {\n          addEntityKindUsage(value, 'generators', genId);\n        }\n      });\n    }\n\n    (gen.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n\n    (gen.variants?.options || []).forEach((variant) => {\n      recordConditionUsage(variant.when, 'generators', genId);\n      (variant.apply?.relationships || []).forEach((rel) => {\n        if (rel?.kind) addRelationshipKindUsage(rel.kind, 'generators', genId);\n      });\n      (variant.apply?.stateUpdates || []).forEach((mutation) => recordMutationUsage(mutation, 'generators', genId));\n    });\n  });\n\n  // Analyze systems\n  systems.forEach((sys) => {\n    analyzeSystemSchemaUsage(sys, recordSelectionUsage, addRelationshipKindUsage, addEntityKindUsage, recordConditionUsage, recordMutationUsage);\n  });\n\n  // Analyze actions\n  actions.forEach((action) => {\n    const actionId = action.id || action.name || 'unnamed';\n    recordSelectionUsage(action.actor?.selection, 'actions', actionId);\n    recordSelectionUsage(action.targeting, 'actions', actionId);\n    (action.outcome?.mutations || []).forEach((mutation) => recordMutationUsage(mutation, 'actions', actionId));\n  });\n\n  // Analyze seed entities\n  seedEntities.forEach((entity) => {\n    const entityLabel = entity.name || entity.id || 'unnamed seed';\n\n    if (entity.kind) {\n      ensureEntityKind(entity.kind);\n      usage.entityKinds[entity.kind].seeds.push(entityLabel);\n    }\n\n    if (entity.kind && entity.subtype) {\n      ensureSubtype(entity.kind, entity.subtype);\n      usage.subtypes[entity.kind][entity.subtype].seeds.push(entityLabel);\n    }\n  });\n\n  return usage;\n}", "parameters": [{"name": "{\n  generators = [],\n  systems = [],\n  actions = [],\n  pressures: _pressures = [],\n  seedEntities = [],\n}", "type": "{ generators?: any[]; systems?: any[]; actions?: any[]; pressures?: any[]; seedEntities?: any[]; }", "optional": false}], "returnType": "{ entityKinds: {}; relationshipKinds: {}; subtypes: {}; statuses: {}; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ActivityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ActivityPanel.jsx", "sourceCode": "export default function ActivityPanel({\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}) {\n  const [debugItem, setDebugItem] = useState(null);\n  const mouseDownOnOverlay = useRef(false);\n  const handleOverlayMouseDown = useCallback(e => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n  const handleOverlayClick = useCallback(e => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setDebugItem(null);\n    }\n  }, []);\n\n  // Split queue into categories\n  const {\n    running,\n    queued,\n    completed,\n    errored\n  } = useMemo(() => {\n    const running = queue.filter(item => item.status === \"running\");\n    const queued = queue.filter(item => item.status === \"queued\");\n    const completed = queue.filter(item => item.status === \"complete\").sort((a, b) => (b.completedAt || 0) - (a.completedAt || 0)).slice(0, 20);\n    const errored = queue.filter(item => item.status === \"error\");\n    return {\n      running,\n      queued,\n      completed,\n      errored\n    };\n  }, [queue]);\n  const debugRequest = debugItem?.debug?.request || \"\";\n  const debugResponse = debugItem?.debug?.response || \"\";\n  return <div>\n      {/* Stats header */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Activity</h2>\n          <div className=\"ap-header-actions\">\n            {queue.length > 0 && <button onClick={onCancelAll} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Cancel All\n              </button>}\n            {stats.completed > 0 && <button onClick={onClearCompleted} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Clear Completed\n              </button>}\n          </div>\n        </div>\n\n        {/* Stats */}\n        <div className=\"ap-stats-row\">\n          <div>\n            <span className=\"ap-stat-value\">{stats.queued}</span>\n            <span className=\"ap-stat-label\">queued</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-running\">{stats.running}</span>\n            <span className=\"ap-stat-label\">running</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-completed\">{stats.completed}</span>\n            <span className=\"ap-stat-label\">completed</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-errors\">{stats.errored}</span>\n            <span className=\"ap-stat-label\">errors</span>\n          </div>\n        </div>\n      </div>\n\n      {/* Currently Running */}\n      {running.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Currently Running</div>\n          {running.map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Queued */}\n      {queued.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Queued ({queued.length})</div>\n          {queued.slice(0, 10).map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n          {queued.length > 10 && <div className=\"ap-more-indicator\">... and {queued.length - 10} more</div>}\n        </div>}\n\n      {/* Errors */}\n      {errored.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header ap-section-header-errors\">\n            Errors ({errored.length})\n          </div>\n          {errored.map(item => {\n        const activityError = formatActivityError(item);\n        return <div key={item.id}>\n                <TaskRow item={item} onRetry={onRetry} onViewDebug={setDebugItem} />\n                {activityError && <div className=\"ap-error-detail\">{activityError}</div>}\n              </div>;\n      })}\n        </div>}\n\n      {/* Recent Completed */}\n      {completed.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Recent Completed</div>\n          {completed.map(item => <TaskRow key={item.id} item={item} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Empty state */}\n      {queue.length === 0 && <div className=\"illuminator-card\">\n          <div className=\"ap-empty-state\">\n            No activity yet. Queue some enrichment tasks from the Entities tab.\n          </div>\n        </div>}\n\n      {debugItem && <div className=\"illuminator-modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e);\n    }}>\n          <div className=\"illuminator-modal ap-debug-modal\">\n            <div className=\"illuminator-modal-header\">\n              <h3>Network Debug</h3>\n              <button onClick={() => setDebugItem(null)} className=\"illuminator-modal-close\">\n                &times;\n              </button>\n            </div>\n            <div className=\"illuminator-modal-body ap-debug-body\">\n              <div className=\"ap-debug-entity-info\">\n                {debugItem.entityName}\n                {(() => {\n              if (debugItem.type === \"description\") return \" \u00b7 Description\";\n              if (debugItem.type === \"image\") return \" \u00b7 Image\";\n              return \" \u00b7 Chronicle\";\n            })()}\n              </div>\n              <div>\n                <label htmlFor=\"request-raw\" className=\"ap-debug-label\">Request (raw)</label>\n                <textarea id=\"request-raw\" className=\"illuminator-textarea ap-debug-request-textarea\" value={debugRequest} readOnly />\n              </div>\n              <div>\n                <label htmlFor=\"response-raw\" className=\"ap-debug-label\">Response (raw)</label>\n                <textarea id=\"response-raw\" className=\"illuminator-textarea ap-debug-response-textarea\" value={debugResponse} readOnly />\n              </div>\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}", "type": "{ queue: any; stats: any; onCancel: any; onRetry: any; onCancelAll: any; onClearCompleted: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useRef", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "./ActivityPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BackportConfigModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackportConfigModal.jsx", "sourceCode": "export default function BackportConfigModal({\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}) {\n  const statusMap = useMemo(() => perEntityStatus || {}, [perEntityStatus]);\n\n  // Only pending entities are selectable\n  const pendingEntities = useMemo(() => entities.filter(e => !statusMap[e.id]), [entities, statusMap]);\n  const [selectedIds, setSelectedIds] = useState(() => new Set(pendingEntities.map(e => e.id)));\n  const [customInstructions, setCustomInstructions] = useState(\"\");\n\n  // Reset selections when entities or status change (new modal open)\n  const entityKey = entities.map(e => e.id).join(\",\");\n  const statusKey = Object.keys(statusMap).sort().join(\",\");\n  const resetKey = `${entityKey}|${statusKey}`;\n  const [prevKey, setPrevKey] = useState(resetKey);\n  if (resetKey !== prevKey) {\n    setPrevKey(resetKey);\n    setSelectedIds(new Set(entities.filter(e => !statusMap[e.id]).map(e => e.id)));\n    setCustomInstructions(\"\");\n  }\n  const castEntities = useMemo(() => entities.filter(e => !e.isLens && !e.isTertiary), [entities]);\n  const lensEntities = useMemo(() => entities.filter(e => e.isLens), [entities]);\n  const tertiaryEntities = useMemo(() => entities.filter(e => e.isTertiary), [entities]);\n  const doneCount = entities.filter(e => statusMap[e.id]).length;\n  const selectedCount = selectedIds.size;\n  const allPendingSelected = selectedCount === pendingEntities.length && pendingEntities.length > 0;\n  if (!isOpen) return null;\n  const toggleEntity = id => {\n    if (statusMap[id]) return; // locked\n    setSelectedIds(prev => {\n      const next = new Set(prev);\n      if (next.has(id)) next.delete(id);else next.add(id);\n      return next;\n    });\n  };\n  const toggleAllPending = () => {\n    if (allPendingSelected) {\n      setSelectedIds(new Set());\n    } else {\n      setSelectedIds(new Set(pendingEntities.map(e => e.id)));\n    }\n  };\n  const selectTertiaryOnly = () => {\n    setSelectedIds(new Set(tertiaryEntities.filter(e => !statusMap[e.id]).map(e => e.id)));\n  };\n  const handleMarkNotNeeded = entityId => {\n    onMarkNotNeeded([entityId]);\n  };\n  let progressColor;\n  if (doneCount === entities.length) progressColor = \"#10b981\";else if (doneCount > 0) progressColor = \"#f59e0b\";else progressColor = \"var(--text-muted)\";\n  const renderEntityRow = e => {\n    const status = statusMap[e.id];\n    const isLocked = !!status;\n    return <div key={e.id} className={`bcm-entity-row ${isLocked ? \"bcm-entity-row-locked\" : \"\"}`}>\n        {isLocked ? <span className={`bcm-status-icon ${status === \"backported\" ? \"bcm-status-icon-done\" : \"bcm-status-icon-skipped\"}`}>\n            {status === \"backported\" ? \"\\u2713\" : \"\\u2014\"}\n          </span> : <input type=\"checkbox\" checked={selectedIds.has(e.id)} onChange={() => toggleEntity(e.id)} className=\"bcm-checkbox\" />}\n        <span className={`bcm-entity-name ${isLocked ? \"bcm-entity-name-locked\" : \"bcm-entity-name-clickable\"}`} onClick={() => !isLocked && toggleEntity(e.id)} role=\"button\" tabIndex={0} onKeyDown={e => {\n        if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n      }}>\n          {e.name}\n          <span className=\"bcm-entity-kind\">\n            {e.kind}\n            {e.subtype ? ` / ${e.subtype}` : \"\"}\n          </span>\n        </span>\n        {/* Status / action tags */}\n        {status === \"backported\" && <span className=\"bcm-tag bcm-tag-done\">Done</span>}\n        {status === \"not_needed\" && <span className=\"bcm-tag bcm-tag-skipped\">Skipped</span>}\n        {!status && <button onClick={ev => {\n        ev.stopPropagation();\n        handleMarkNotNeeded(e.id);\n      }} title=\"Mark as no backport needed\" className=\"bcm-skip-btn\">\n            Skip\n          </button>}\n        {e.isLens && <span className=\"bcm-tag bcm-tag-lens\">Lens</span>}\n        {e.isTertiary && <span className=\"bcm-tag bcm-tag-tertiary\">Tertiary</span>}\n      </div>;\n  };\n  return <div className=\"bcm-overlay\">\n      <div className=\"bcm-dialog\">\n        {/* Header */}\n        <div className=\"bcm-header\">\n          <h2 className=\"bcm-title\">Backport Lore to Cast</h2>\n          <div className=\"bcm-subtitle-row\">\n            <p className=\"bcm-chronicle-title\">{chronicleTitle}</p>\n            <span className=\"bcm-progress\"\n          style={{\n            \"--bcm-progress-color\": progressColor\n          }}>\n              {doneCount}/{entities.length} complete\n            </span>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className=\"bcm-body\">\n          {/* Entity selection */}\n          <div className=\"bcm-section\">\n            <div className=\"bcm-section-header\">\n              <span className=\"bcm-section-label\">\n                Entities ({selectedCount} selected\n                {pendingEntities.length < entities.length ? `, ${doneCount} done` : \"\"})\n              </span>\n              <span className=\"bcm-action-group\">\n                {tertiaryEntities.length > 0 && <button onClick={selectTertiaryOnly} className=\"bcm-text-btn bcm-text-btn-tertiary\">\n                    Tertiary only\n                  </button>}\n                {pendingEntities.length > 0 && <button onClick={toggleAllPending} className=\"bcm-text-btn bcm-text-btn-accent\">\n                    {allPendingSelected ? \"Deselect all\" : \"Select all pending\"}\n                  </button>}\n              </span>\n            </div>\n\n            <div className=\"bcm-entity-list\">\n              {castEntities.map(renderEntityRow)}\n              {lensEntities.length > 0 && castEntities.length > 0 && <div className=\"bcm-divider\" />}\n              {lensEntities.map(renderEntityRow)}\n              {tertiaryEntities.length > 0 && (castEntities.length > 0 || lensEntities.length > 0) && <div className=\"bcm-divider\">\n                    <div className=\"bcm-tertiary-label\">Tertiary Cast</div>\n                  </div>}\n              {tertiaryEntities.map(renderEntityRow)}\n            </div>\n          </div>\n\n          {/* Custom instructions */}\n          <div>\n            <label htmlFor=\"custom-instructions-optional\" className=\"bcm-instructions-label\">Custom Instructions (optional)</label>\n            <textarea id=\"custom-instructions-optional\" value={customInstructions} onChange={e => setCustomInstructions(e.target.value)} placeholder={'e.g. \"This chronicle is a fable \\u2014 treat its events as in-universe fiction, not canonical history. Backported lore should reference these events as legends, myths, or disputed accounts.\"'} rows={3} className=\"bcm-textarea\" />\n            <p className=\"bcm-instructions-hint\">\n              These instructions will be injected as critical directives into the backport prompt.\n              Use this for non-canonical chronicles (fables, prophecies, dreamscapes) or any special\n              handling.\n            </p>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"bcm-footer\">\n          <button onClick={onCancel} className=\"illuminator-button illuminator-button-secondary bcm-footer-btn\">\n            Cancel\n          </button>\n          <button onClick={() => onStart(Array.from(selectedIds), customInstructions.trim())} disabled={selectedCount === 0} className=\"illuminator-button illuminator-button-primary bcm-footer-btn\">\n            Start Backport ({selectedCount} {selectedCount === 1 ? \"entity\" : \"entities\"})\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}", "type": "{ isOpen: any; chronicleTitle: any; entities: any; perEntityStatus: any; onStart: any; onMarkNotNeeded: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./BackportConfigModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx", "sourceCode": "/**\n * BackrefImageEditor - Main editor component\n *\n * Props:\n * - entity: Entity with enrichment.chronicleBackrefs\n * - entities: All entities (for resolving entity portraits)\n * - onUpdateBackrefs: (entityId, updatedBackrefs) => void\n */\nexport default function BackrefImageEditor({\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}) {\n  const [chronicles, setChronicles] = useState(new Map());\n  const [expanded, setExpanded] = useState(alwaysExpanded);\n  const backrefs = useMemo(\n    () => entity?.enrichment?.chronicleBackrefs || [],\n    [entity?.enrichment?.chronicleBackrefs]\n  );\n\n  // Stable key for chronicle IDs to use as dependency\n  const backrefChronicleKey = useMemo(\n    () => backrefs.map((b) => b.chronicleId).join(\",\"),\n    [backrefs]\n  );\n\n  // Load chronicle records for all backrefs\n  useEffect(() => {\n    if (backrefs.length === 0) return;\n\n    const chronicleIds = [...new Set(backrefs.map((b) => b.chronicleId))];\n    let cancelled = false;\n\n    Promise.all(chronicleIds.map((id) => getChronicle(id).then((c) => [id, c]))).then((results) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const [id, chronicle] of results) {\n        if (chronicle) map.set(id, chronicle);\n      }\n      setChronicles(map);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [backrefs, backrefChronicleKey]);\n\n  // Collect all image IDs we need to load\n  const allImageIds = useMemo(() => {\n    const ids = [];\n    for (const chronicle of chronicles.values()) {\n      // Cover image\n      if (chronicle.coverImage?.generatedImageId) {\n        ids.push(chronicle.coverImage.generatedImageId);\n      }\n      // Scene images\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.generatedImageId) {\n            ids.push(ref.generatedImageId);\n          }\n        }\n      }\n      // Entity portraits from cast\n      for (const role of chronicle.roleAssignments || []) {\n        const ent = entities.find((e) => e.id === role.entityId);\n        if (ent?.enrichment?.image?.imageId) {\n          ids.push(ent.enrichment.image.imageId);\n        }\n      }\n    }\n    return [...new Set(ids)];\n  }, [chronicles, entities]);\n\n  // Only load blobs when the editor is visible (expanded or alwaysExpanded)\n  const { urls: imageUrls } = useImageUrls(expanded ? allImageIds : []);\n\n  const handleBackrefChange = useCallback(\n    (updatedBackref) => {\n      const updated = backrefs.map((b) =>\n        b.chronicleId === updatedBackref.chronicleId &&\n        b.anchorPhrase === updatedBackref.anchorPhrase\n          ? updatedBackref\n          : b\n      );\n      onUpdateBackrefs(entity.id, updated);\n    },\n    [backrefs, entity.id, onUpdateBackrefs]\n  );\n\n  if (backrefs.length === 0) return null;\n\n  const rowsContent = (\n    <div\n      className={alwaysExpanded ? \"bie-rows-container-expanded\" : \"bie-rows-container-collapsed\"}\n    >\n      {backrefs.map((backref, i) => (\n        <BackrefRow\n          key={`${backref.chronicleId}-${i}`}\n          backref={backref}\n          chronicle={chronicles.get(backref.chronicleId) || null}\n          entities={entities}\n          imageUrls={imageUrls}\n          onChange={handleBackrefChange}\n        />\n      ))}\n    </div>\n  );\n\n  if (alwaysExpanded) {\n    return (\n      <div className=\"bie-wrapper\">\n        <div className=\"bie-heading\">Chronicle Images ({backrefs.length})</div>\n        {rowsContent}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bie-wrapper\">\n      <button onClick={() => setExpanded(!expanded)} className=\"bie-toggle-btn\">\n        <span\n          className={`bie-toggle-arrow ${expanded ? \"bie-toggle-arrow-expanded\" : \"bie-toggle-arrow-collapsed\"}`}\n        >\n          \u25b6\n        </span>\n        <span className=\"bie-toggle-label\">Chronicle Images ({backrefs.length})</span>\n      </button>\n      {expanded && rowsContent}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}", "type": "{ entity: any; entities: any; onUpdateBackrefs: any; alwaysExpanded?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrls"], "category": "external"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle"], "category": "internal"}, {"source": "./BackrefImageEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkBackportModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkBackportModal.jsx", "sourceCode": "export default function BulkBackportModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const chronicles = progress?.chronicles;\n  const realTotal = useMemo(() => chronicles ? chronicles.reduce((sum, c) => sum + c.totalEntities, 0) : 0, [chronicles]);\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const currentChronicle = progress?.chronicles?.[progress.currentChronicleIndex];\n  const globalPercent = progress?.totalEntities > 0 ? Math.round(progress.processedEntities / progress.totalEntities * 100) : 0;\n  const completedChronicles = progress?.chronicles?.filter(c => c.status === \"complete\").length ?? 0;\n  const failedChronicles = progress?.chronicles?.filter(c => c.status === \"failed\").length ?? 0;\n  let progressFillModifier;\n  if (progress?.status === \"failed\") progressFillModifier = \"bbm-progress-fill-failed\";else if (progress?.status === \"cancelled\") progressFillModifier = \"bbm-progress-fill-cancelled\";else progressFillModifier = \"bbm-progress-fill-ok\";\n  const progressFillClass = `bbm-progress-fill ${progressFillModifier}`;\n\n  // Header status text\n  let statusText;\n  if (isConfirming) statusText = `${progress?.chronicles?.length ?? 0} chronicles`;else if (progress?.status === \"running\") statusText = \"Processing...\";else if (progress?.status === \"complete\") statusText = \"Complete\";else if (progress?.status === \"cancelled\") statusText = \"Cancelled\";else if (progress?.status === \"failed\") statusText = \"Failed\";\n\n  // Pill status text when minimized\n  const pillStatusText = progress?.status === \"running\" ? `${progress.processedEntities}/${progress.totalEntities}` : progress?.status;\n  return <BulkOperationShell pillId={PILL_ID} title=\"Bulk Backport\" tabId=\"chronicle\" progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={`Start Backport (${progress?.totalEntities ?? 0} entities)`} statusText={statusText} pillStatusText={pillStatusText} confirmWidth=\"540px\" processWidth=\"480px\">\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && progress.entitySummary && <div className=\"bbm-entity-section\">\n          <div className=\"bbm-entity-header\">\n            <span className=\"bbm-section-label\">\n              Entities ({progress.entitySummary.length})\n            </span>\n            <span className=\"bbm-section-meta\">\n              {progress.totalEntities} updates across {progress.chronicles.length} chronicles\n            </span>\n          </div>\n\n          <div className=\"bbm-entity-list\">\n            {progress.entitySummary.map((entity, i) => <div key={entity.entityId} className={`bbm-entity-row ${i < progress.entitySummary.length - 1 ? \"bbm-entity-row-bordered\" : \"\"}`}>\n                <div className=\"bbm-entity-info\">\n                  <span className=\"bbm-entity-name\">{entity.entityName}</span>\n                  <span className=\"bbm-entity-kind\">\n                    {entity.entityKind}\n                    {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                  </span>\n                </div>\n                <span className=\"bbm-entity-chr\" title={`${entity.chronicleCount} chronicle${entity.chronicleCount !== 1 ? \"s\" : \"\"} will update this entity`}>\n                  {entity.chronicleCount} chr\n                </span>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* ---- Processing screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <div className=\"bbm-progress-section\">\n            <div className=\"bbm-progress-header\">\n              <span className=\"bbm-progress-label\">\n                Chronicle{\" \"}\n                {Math.min(progress.currentChronicleIndex + 1, progress.chronicles.length)} /{\" \"}\n                {progress.chronicles.length}\n              </span>\n              <span className=\"bbm-progress-percent\">{globalPercent}%</span>\n            </div>\n\n            {/* Global progress bar */}\n            <div className=\"bbm-progress-track\">\n              <div className={progressFillClass}\n          style={{\n            \"--bbm-progress-width\": `${globalPercent}%`\n          }} />\n            </div>\n\n            <div className=\"bbm-progress-stats\">\n              <span>\n                {progress.processedEntities} / {realTotal || progress.totalEntities} entities\n              </span>\n              <span>\n                {completedChronicles} / {progress.chronicles.length} chronicles\n              </span>\n            </div>\n          </div>\n\n          {/* Current chronicle detail */}\n          {currentChronicle && !isTerminal && <div className=\"bbm-chronicle-detail\">\n              <div className=\"bbm-chronicle-title\">{currentChronicle.chronicleTitle}</div>\n\n              {currentChronicle.totalBatches > 1 && <div className=\"bbm-chronicle-batch-info\">\n                  <span>\n                    Batch{\" \"}\n                    {Math.min(currentChronicle.completedBatches + 1, currentChronicle.totalBatches)}{\" \"}\n                    / {currentChronicle.totalBatches}\n                  </span>\n                  <span>\n                    {currentChronicle.processedEntities} / {currentChronicle.totalEntities}{\" \"}\n                    entities\n                  </span>\n                </div>}\n\n              {currentChronicle.totalBatches <= 1 && <div className=\"bbm-chronicle-entity-count\">\n                  {currentChronicle.totalEntities} entities\n                </div>}\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              Backported {progress.processedEntities} entities across {completedChronicles}{\" \"}\n              chronicles.\n              {failedChronicles > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {failedChronicles} chronicle(s) failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} entities across{\" \"}\n              {completedChronicles} chronicles.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./BulkOperationShell", "specifiers": ["BulkOperationShell", "BulkTerminalMessage", "BulkCost"], "category": "internal"}, {"source": "./BulkBackportModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx", "sourceCode": "export default function BulkChronicleAnnotationModal({ progress, onConfirm, onCancel, onClose }) {\n  const isClear = progress?.operation === \"clear\";\n  const title = isClear ? \"Clear Annotations\" : \"Run Annotations\";\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  const withNotes = progress?.chronicles?.filter((c) => c.hasNotes).length || 0;\n  const withTones = progress?.chronicles?.filter((c) => c.assignedTone).length || 0;\n\n  const confirmLabel = isClear\n    ? `Clear (${progress?.totalChronicles || 0} chronicles)`\n    : `Annotate (${progress?.totalChronicles || 0} chronicles)`;\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-chronicle-annotation\"\n      title={title}\n      tabId=\"chronicle\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={confirmLabel}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            {isClear ? (\n              <>\n                This will clear all historian annotations from {progress.totalChronicles}{\" \"}\n                chronicle{progress.totalChronicles !== 1 ? \"s\" : \"\"}. Annotations cannot be\n                recovered after clearing.\n              </>\n            ) : (\n              <>\n                Each chronicle gets a historian review using its assigned tone. Results are\n                auto-applied (no manual review step). Chronicles processed sequentially \u2014 one\n                LLM call each.\n                {withTones < progress.totalChronicles && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {progress.totalChronicles - withTones} chronicle\n                    {progress.totalChronicles - withTones !== 1 ? \"s\" : \"\"} have no assigned\n                    tone and will default to &quot;weary&quot;.\n                  </span>\n                )}\n                {withNotes > 0 && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {withNotes} chronicle{withNotes !== 1 ? \"s\" : \"\"} already have annotations \u2014\n                    they will be replaced.\n                  </span>\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Chronicle list */}\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bcam-chronicle-item\">\n                  <span className=\"bcam-chronicle-title\">{chron.title}</span>\n                  {!isClear && (\n                    <span className=\"bcam-chronicle-tone\">\n                      {chron.assignedTone || \"weary\"}\n                      {chron.hasNotes ? \" \u270e\" : \"\"}\n                    </span>\n                  )}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <>\n              <div className=\"bcam-current-title\">\n                {progress.currentTitle || (isClear ? \"Clearing...\" : \"Annotating...\")}\n              </div>\n\n              <BulkProgressBar\n                processed={progress.processedChronicles}\n                total={progress.totalChronicles}\n                status={progress.status}\n              />\n\n              <div className=\"bcam-progress-stats\">\n                <span>\n                  {progress.processedChronicles} / {progress.totalChronicles}{\" \"}\n                  {isClear ? \"cleared\" : \"annotated\"}\n                </span>\n                {!isClear && progress.currentTone && (\n                  <span>tone: {progress.currentTone}</span>\n                )}\n              </div>\n            </>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              {isClear\n                ? `Cleared annotations from ${progress.processedChronicles} chronicle${progress.processedChronicles !== 1 ? \"s\" : \"\"}.`\n                : `Annotated ${progress.processedChronicles} of ${progress.totalChronicles} chronicles.`}\n              {progress.failedChronicles.length > 0 &&\n                ` (${progress.failedChronicles.length} failed)`}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./BulkOperationShell", "specifiers": ["BulkOperationShell", "BulkProgressBar", "BulkTerminalMessage", "BulkFailedList", "BulkCost"], "category": "internal"}, {"source": "./BulkChronicleAnnotationModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx", "sourceCode": "export default function BulkEraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}) {\n  const progress = useBulkEraNarrativeStore(s => s.progress);\n  const prepareBulk = useBulkEraNarrativeStore(s => s.prepareBulk);\n  const confirmBulk = useBulkEraNarrativeStore(s => s.confirmBulk);\n  const cancelBulk = useBulkEraNarrativeStore(s => s.cancelBulk);\n  const closeBulk = useBulkEraNarrativeStore(s => s.closeBulk);\n  const setEraTone = useBulkEraNarrativeStore(s => s.setEraTone);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Build narrative weight map from style library\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Find the active eraNarrative task in the queue for streaming\n  const activeTaskId = useEnrichmentQueueStore(s => {\n    const item = s.queue.find(q => q.type === \"eraNarrative\" && q.status === \"running\");\n    return item?.id || null;\n  });\n\n  // Subscribe to streaming text for the active task\n  const streamEntry = useThinkingStore(s => activeTaskId ? s.entries.get(activeTaskId) : undefined);\n\n  // Refs for values used in the prepare effect that shouldn't trigger re-run\n  const prepareDepsRef = useRef({\n    chronicleItems,\n    wizardEras,\n    eraTemporalInfo,\n    projectId,\n    simulationRunId,\n    narrativeWeightMap,\n    prepareBulk,\n    progress\n  });\n  useEffect(() => {\n    prepareDepsRef.current = {\n      chronicleItems,\n      wizardEras,\n      eraTemporalInfo,\n      projectId,\n      simulationRunId,\n      narrativeWeightMap,\n      prepareBulk,\n      progress\n    };\n  }, [chronicleItems, wizardEras, eraTemporalInfo, projectId, simulationRunId, narrativeWeightMap, prepareBulk, progress]);\n\n  // Prepare when opening\n  useEffect(() => {\n    const {\n      chronicleItems: ci,\n      wizardEras: we,\n      eraTemporalInfo: eti,\n      projectId: pid,\n      simulationRunId: sid,\n      narrativeWeightMap: nwm,\n      prepareBulk: pb,\n      progress: p\n    } = prepareDepsRef.current;\n    if (isOpen && p.status === \"idle\" && ci?.length > 0 && we?.length > 0) {\n      pb(ci, we, eti, pid, sid, \"witty\", nwm);\n    }\n  }, [isOpen]);\n  const progressStatus = progress?.status;\n  const processedEras = progress?.processedEras;\n  const totalEras = progress?.totalEras;\n\n  // Update pill while minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedEras}/${totalEras}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedEras, totalEras]);\n\n  // Remove pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!isOpen) return null;\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isRunning = progress.status === \"running\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalEras > 0 ? Math.round(progress.processedEras / progress.totalEras * 100) : 0;\n  const handleConfirm = () => {\n    confirmBulk();\n  };\n  const handleCancel = () => {\n    cancelBulk();\n    if (progress.status === \"confirming\") {\n      onClose();\n    }\n  };\n  const handleClose = () => {\n    closeBulk();\n    onClose();\n  };\n  let statusColor;\n  if (progress.status === \"complete\") statusColor = \"#10b981\";else if (progress.status === \"failed\") statusColor = \"#ef4444\";else if (progress.status === \"cancelled\") statusColor = \"#f59e0b\";else statusColor = \"var(--text-muted)\";\n  let progressFillModifier;\n  if (progress.status === \"failed\") progressFillModifier = \"benm-progress-fill-failed\";else if (progress.status === \"cancelled\") progressFillModifier = \"benm-progress-fill-cancelled\";else progressFillModifier = \"benm-progress-fill-complete\";\n  const progressFillClass = `benm-progress-fill ${progressFillModifier}`;\n  return <div className=\"benm-overlay\">\n      <div className=\"benm-modal\"\n    style={{\n      \"--benm-modal-width\": isConfirming ? \"540px\" : \"560px\"\n    }}>\n        {/* Header */}\n        <div className=\"benm-header\">\n          <div className=\"benm-header-row\">\n            <h2 className=\"benm-title\">Bulk Era Narrative</h2>\n            <div className=\"benm-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Bulk Era Narrative\",\n              statusText: progress.status === \"running\" ? `${progress.processedEras}/${progress.totalEras}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })(),\n              tabId: \"chronicle\"\n            })} className=\"illuminator-button benm-minimize-btn\" title=\"Minimize to pill\">\n                  {\"\\u2015\"}\n                </button>}\n              <span className=\"benm-status-label\"\n            style={{\n              \"--benm-status-color\": statusColor\n            }}>\n                {isConfirming && `${progress.totalEras} eras`}\n                {isRunning && \"Processing...\"}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`benm-body ${isConfirming ? \"benm-body-confirming\" : \"benm-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              {/* Era list with per-era tone */}\n              <div className=\"benm-era-section\">\n                <div className=\"benm-section-label\">Eras ({progress.eras.length})</div>\n                <div className=\"benm-era-list\">\n                  {progress.eras.map((era, i) => {\n                return <div key={era.eraId} className={`benm-era-row ${i < progress.eras.length - 1 ? \"benm-era-row-bordered\" : \"\"}`}>\n                        <div className=\"benm-era-row-info\">\n                          <span className=\"benm-era-name\">{era.eraName}</span>\n                        </div>\n                        <div className=\"benm-era-row-actions\">\n                          <span className=\"benm-era-prepped\">\n                            {era.preppedCount}/{era.totalCount} prepped\n                          </span>\n                          {era.hasExisting && <span className=\"benm-era-existing\" title=\"Has existing completed narrative\">\n                              {\"\\u2713\"}\n                            </span>}\n                          {/* Per-era tone selector */}\n                          <div className=\"benm-tone-selector\">\n                            {TONE_OPTIONS.map(t => {\n                        const meta = TONE_META[t];\n                        const selected = era.tone === t;\n                        return <button key={t} onClick={() => setEraTone(era.eraId, t)} title={meta?.label} className={`benm-tone-btn ${selected ? \"benm-tone-btn-selected\" : \"benm-tone-btn-default\"}`}>\n                                  {meta?.symbol}\n                                </button>;\n                      })}\n                          </div>\n                        </div>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing + terminal ---- */}\n          {!isConfirming && <>\n              {/* Progress bar */}\n              <div className=\"benm-progress-section\">\n                <div className=\"benm-progress-header\">\n                  <span className=\"benm-progress-era-label\">\n                    Era {Math.min(progress.processedEras + 1, progress.totalEras)} /{\" \"}\n                    {progress.totalEras}\n                  </span>\n                  <span className=\"benm-progress-percent\">{globalPercent}%</span>\n                </div>\n                <div className=\"benm-progress-track\">\n                  <div className={progressFillClass}\n              style={{\n                \"--benm-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n                <div className=\"benm-progress-counts\">\n                  {progress.processedEras} / {progress.totalEras} eras\n                </div>\n              </div>\n\n              {/* Current era \u2014 step progress with live word counts */}\n              {progress.currentEraName && !isTerminal && (() => {\n            const currentEra = progress.eras.find(e => e.eraName === progress.currentEraName);\n            const currentToneMeta = currentEra ? TONE_META[currentEra.tone] : null;\n            const stepOrder = [\"threads\", \"generate\", \"edit\"];\n            const activeIdx = stepOrder.indexOf(progress.currentStep);\n\n            // Live word counts from streaming deltas\n            const thinkingWords = streamEntry?.thinking ? streamEntry.thinking.split(/\\s+/).filter(Boolean).length : 0;\n            const outputWords = streamEntry?.text ? streamEntry.text.split(/\\s+/).filter(Boolean).length : 0;\n            return <div className=\"benm-current-era\">\n                      {/* Era name + tone */}\n                      <div className=\"benm-current-era-name\">\n                        {currentToneMeta && <span className=\"benm-current-era-tone\" title={currentToneMeta.label}>\n                            {currentToneMeta.symbol}\n                          </span>}\n                        {progress.currentEraName}\n                      </div>\n\n                      {/* Step rows */}\n                      <div className=\"benm-steps\">\n                        {stepOrder.map((step, idx) => {\n                  const isDone = idx < activeIdx;\n                  const isActive = idx === activeIdx;\n                  const isPending = idx > activeIdx;\n                  let icon;\n                  if (isDone) icon = \"\\u2713\";else if (isActive) icon = \"\\u25B8\";else icon = \"\\u25CB\";\n                  let iconColor;\n                  if (isDone) iconColor = \"#10b981\";else if (isActive) iconColor = \"#f59e0b\";else iconColor = \"var(--text-muted)\";\n\n                  // Word count bar caps for visual scaling\n                  let barMax;\n                  if (step === \"generate\") barMax = 4000;else if (step === \"threads\") barMax = 2000;else barMax = 3000;\n                  const barPercent = isActive ? Math.min(100, outputWords / barMax * 100) : 0;\n                  return <div key={step}>\n                              <div className=\"benm-step-row\">\n                                <span className=\"benm-step-icon\"\n                      style={{\n                        \"--benm-step-color\": iconColor\n                      }}>\n                                  {icon}\n                                </span>\n                                <span className={`benm-step-label ${isActive ? \"benm-step-label-active\" : \"\"} ${isPending ? \"benm-step-label-pending\" : \"\"}`}>\n                                  {STEP_LABEL[step]}\n                                </span>\n\n                                {isActive && <div className=\"benm-step-active-content\">\n                                    {/* Mini progress bar */}\n                                    <div className=\"benm-step-bar-track\">\n                                      <div className=\"benm-step-bar-fill\"\n                          style={{\n                            \"--benm-bar-width\": `${barPercent}%`\n                          }} />\n                                    </div>\n                                    {/* Live counters */}\n                                    <span className=\"benm-step-counters\">\n                                      {thinkingWords > 0 && <span title=\"Thinking words received\">\n                                          <span className=\"benm-counter-thinking-label\">T</span>{\" \"}\n                                          {thinkingWords.toLocaleString()}\n                                        </span>}\n                                      {thinkingWords > 0 && outputWords > 0 && <span className=\"benm-counter-separator\">/</span>}\n                                      {outputWords > 0 && <span title=\"Output words received\">\n                                          <span className=\"benm-counter-output-label\">O</span>{\" \"}\n                                          {outputWords.toLocaleString()}\n                                        </span>}\n                                    </span>\n                                  </div>}\n\n                                {isDone && <span className=\"benm-step-done\">done</span>}\n                              </div>\n                            </div>;\n                })}\n                      </div>\n                    </div>;\n          })()}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"benm-terminal-msg benm-terminal-msg-complete\">\n                  Generated {progress.processedEras} era narratives.\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; eraTemporalInfo: any; projectId: any; simulationRunId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect", "useMemo", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/bulkEraNarrativeStore", "specifiers": ["useBulkEraNarrativeStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../lib/db/thinkingStore", "specifiers": ["useThinkingStore"], "category": "internal"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkEraNarrativeModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx", "sourceCode": "export default function BulkFactCoverageModal({ progress, onConfirm, onCancel, onClose }) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-fact-coverage\"\n      title=\"Fact Coverage Analysis\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Analyze (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            Analyze each chronicle&apos;s narrative against all canon facts using Haiku. Results are\n            stored per-chronicle and visible in the Reference tab.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">Chronicles ({progress.chronicles.length})</div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          <BulkProgressBar\n            processed={progress.processedChronicles}\n            total={progress.totalChronicles}\n            status={progress.status}\n          />\n\n          <div className=\"bulk-progress-detail\">\n            {progress.processedChronicles} / {progress.totalChronicles} chronicles\n            {progress.failedChronicles?.length > 0 && (\n              <span className=\"bulk-failed-inline\">\n                {\" \"}{progress.failedChronicles.length} failed\n              </span>\n            )}\n          </div>\n\n          {/* Current chronicle */}\n          {progress.currentTitle && !isTerminal && (\n            <div className=\"bulk-current-item\">\n              <div className=\"bulk-current-item-title\">{progress.currentTitle}</div>\n              <div className=\"bulk-current-item-sub\">Analyzing fact coverage...</div>\n            </div>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Analyzed {progress.processedChronicles} chronicles.\n              {progress.failedChronicles?.length > 0 && (\n                <span className=\"bulk-failed-inline\">\n                  {\" \"}{progress.failedChronicles.length} failed.\n                </span>\n              )}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./BulkOperationShell", "specifiers": ["BulkOperationShell", "BulkProgressBar", "BulkTerminalMessage", "BulkFailedList", "BulkCost"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx", "sourceCode": "export default function BulkHistorianModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const isReview = progress?.operation === \"review\";\n  const isClear = progress?.operation === \"clear\";\n  const title = progress ? getTitle(progress) : \"\";\n  return <BulkOperationShell pillId=\"bulk-historian\" title={title} progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={progress ? getConfirmLabel(progress) : \"\"} statusText={progress ? getStatusText(progress) : \"\"} pillStatusText={progress ? getPillText(progress) : \"\"}>\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && <>\n          {/* Tone section (not for clear) */}\n          {!isClear && isReview && (/* Review mode: show tone cycling info */\n      <div className=\"bhm-tone-cycle-box\">\n              <span className=\"bhm-tone-cycle-label\">Tones cycle:</span>\n              {TONE_CYCLE_ORDER.map((t, i) => {\n          const meta = TONE_META[t];\n          return <span key={t}>\n                    {i > 0 && <span className=\"bhm-tone-cycle-arrow\">&rarr;</span>}\n                    <span className=\"bhm-tone-cycle-symbol\">{meta?.symbol}</span> {meta?.label}\n                  </span>;\n        })}\n            </div>)}\n          {!isClear && !isReview && (/* Edition mode: tone picker */\n      <div className=\"bhm-tone-picker\">\n              <div className=\"bhm-section-label\">Historian Tone</div>\n              <div className=\"bhm-tone-options\">\n                {TONE_CYCLE_ORDER.map(t => {\n            const meta = TONE_META[t];\n            const isSelected = progress.tone === t;\n            return <button key={t} onClick={() => onChangeTone(t)} className={`bhm-tone-btn ${isSelected ? \"bhm-tone-btn-selected\" : \"bhm-tone-btn-default\"}`}>\n                      <span className=\"bhm-tone-btn-symbol\">{meta?.symbol}</span>\n                      {meta?.label}\n                    </button>;\n          })}\n              </div>\n            </div>)}\n\n          {/* Entity list */}\n          <div className=\"bhm-entity-section\">\n            <div className=\"bhm-entity-section-label\">\n              Entities ({progress.entities.length})\n            </div>\n\n            <div className=\"bhm-entity-list\">\n              {progress.entities.map((entity, i) => <div key={entity.entityId} className={`bhm-entity-row ${i < progress.entities.length - 1 ? \"bhm-entity-row-bordered\" : \"\"}`}>\n                  <div className=\"bhm-entity-row-info\">\n                    {isReview && entity.tone && <span className=\"bhm-entity-tone-symbol\" title={TONE_META[entity.tone]?.label || entity.tone}>\n                        {TONE_META[entity.tone]?.symbol}\n                      </span>}\n                    <span className=\"bhm-entity-name\">{entity.entityName}</span>\n                    <span className=\"bhm-entity-kind\">\n                      {entity.entityKind}\n                      {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                    </span>\n                  </div>\n                  {!isReview && entity.tokenEstimate > 0 && <span className={`bhm-entity-tokens ${editionMaxTokens && entity.tokenEstimate > editionMaxTokens ? \"bhm-entity-tokens-over\" : \"\"}`} title={`~${entity.tokenEstimate} tokens estimated from word count`}>\n                      ~{entity.tokenEstimate.toLocaleString()}t\n                    </span>}\n                </div>)}\n            </div>\n          </div>\n\n          {/* Token estimate summary for edition mode */}\n          {!isReview && !isClear && (() => {\n        const estimates = progress.entities.map(e => e.tokenEstimate || 0).filter(t => t > 0);\n        if (estimates.length === 0) return null;\n        const maxEst = Math.max(...estimates);\n        const overCount = editionMaxTokens ? estimates.filter(t => t > editionMaxTokens).length : 0;\n        return <div className={`bhm-token-summary ${overCount > 0 ? \"bhm-token-summary-over\" : \"bhm-token-summary-ok\"}`}>\n                  <div>\n                    Largest description: <strong>~{maxEst.toLocaleString()} tokens</strong>\n                    {editionMaxTokens > 0 && <span className=\"bhm-token-limit-note\">\n                        (output limit: <strong>{editionMaxTokens.toLocaleString()}</strong>)\n                      </span>}\n                  </div>\n                  {overCount > 0 && <div className=\"bhm-token-over-warning\">\n                      {overCount} {overCount === 1 ? \"entity exceeds\" : \"entities exceed\"} the\n                      current output token limit \u2014 results may be truncated.\n                    </div>}\n                </div>;\n      })()}\n        </>}\n\n      {/* ---- Processing / Terminal screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <BulkProgressBar processed={progress.processedEntities} total={progress.totalEntities} status={progress.status} />\n\n          <div className=\"bhm-progress-counts\">\n            {progress.processedEntities} / {progress.totalEntities} entities\n            {progress.failedEntities.length > 0 && <span className=\"bhm-progress-failed-count\">\n                {progress.failedEntities.length} failed\n              </span>}\n          </div>\n\n          {/* Current entity detail */}\n          {progress.currentEntityName && !isTerminal && <div className=\"bhm-current-entity\">\n              <div className=\"bhm-current-entity-name\">\n                {progress.currentEntityTone && TONE_META[progress.currentEntityTone] && <span className=\"bhm-current-entity-tone\">\n                    {TONE_META[progress.currentEntityTone].symbol}\n                  </span>}\n                {progress.currentEntityName}\n              </div>\n              <div className=\"bhm-current-entity-status\">\n                {(() => {\n            if (isClear) return \"Clearing annotations...\";\n            if (isReview) return \"Generating annotations...\";\n            return \"Generating copy edit...\";\n          })()}\n              </div>\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              {(() => {\n          if (isClear) return `Cleared annotations from ${progress.processedEntities} entities.`;\n          if (isReview) return `Annotated ${progress.processedEntities} entities.`;\n          return `Copy-edited ${progress.processedEntities} entities.`;\n        })()}\n              {progress.failedEntities.length > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {progress.failedEntities.length} failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} of{\" \"}\n              {progress.totalEntities} entities.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Failed entities list */}\n          {isTerminal && <BulkFailedList items={progress.failedEntities} labelKey=\"entityName\" errorKey=\"error\" />}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; onChangeTone: any; editionMaxTokens: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HistorianToneSelector", "specifiers": ["TONE_META"], "category": "internal"}, {"source": "./BulkOperationShell", "specifiers": ["BulkOperationShell", "BulkProgressBar", "BulkTerminalMessage", "BulkFailedList", "BulkCost"], "category": "internal"}, {"source": "./BulkHistorianModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "export default function BulkOperationShell({\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(pillId));\n  const progressStatus = progress?.status;\n\n  // Update pill when minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    useFloatingPillStore.getState().updatePill(pillId, {\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus)\n    });\n  }, [isMinimized, progress, progressStatus, pillId, pillStatusText]);\n\n  // Clean up pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(pillId);\n    }\n  }, [progress, progressStatus, pillId]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const handleMinimize = () => {\n    useFloatingPillStore.getState().minimize({\n      id: pillId,\n      label: title,\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus),\n      tabId\n    });\n  };\n  return <div className=\"bulk-overlay\">\n      <div className=\"bulk-dialog\" style={{\n      \"--bulk-dialog-width\": isConfirming ? confirmWidth : processWidth\n    }}>\n        {/* Header */}\n        <div className=\"bulk-header\">\n          <div className=\"bulk-header-row\">\n            <h2 className=\"bulk-title\">{title}</h2>\n            <div className=\"bulk-header-actions\">\n              {!isConfirming && <button onClick={handleMinimize} className=\"illuminator-button bulk-minimize-btn\" title=\"Minimize to pill\">\n                  \u2015\n                </button>}\n              <span className={`bulk-status bulk-status-${progress.status}`}>\n                {statusText}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`bulk-body ${isConfirming ? \"bulk-body-confirming\" : \"bulk-body-processing\"}`}>\n          {children}\n        </div>\n\n        {/* Footer */}\n        <div className=\"bulk-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary bulk-footer-btn\">\n                {confirmLabel}\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button bulk-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}", "type": "{ pillId: any; title: any; tabId?: string; progress: any; onConfirm: any; onCancel: any; onClose: any; confirmLabel: any; statusText: any; pillStatusText: any; confirmWidth?: string; processWidth?: string; children: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./BulkOperationShell.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx", "sourceCode": "export default function BulkToneRankingModal({ progress, onConfirm, onCancel, onClose }) {\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-tone-ranking\"\n      title=\"Tone Ranking\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Rank (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {progress?.status === \"confirming\" && (\n        <>\n          <div className=\"bulk-info-box\">\n            Chronicles are split into batches of ~35-45. Each batch gets its own LLM call so the\n            model maintains attention across all entries.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {progress?.status !== \"confirming\" && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <BulkProgressBar\n              processed={progress.processedChronicles}\n              total={progress.totalChronicles}\n              status={progress.status}\n            />\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Ranked {progress.processedChronicles} of {progress.totalChronicles} chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./BulkOperationShell", "specifiers": ["BulkOperationShell", "BulkProgressBar", "BulkTerminalMessage", "BulkCost"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx", "sourceCode": "export default function ChronicleImagePanel({\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}: Readonly<ChronicleImagePanelProps>) {\n  // Use external style selection directly (managed globally by ImageSettingsDrawer)\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Image modal state\n  const [imageModal, setImageModal] = useState<{ open: boolean; imageId: string; title: string }>({\n    open: false,\n    imageId: \"\",\n    title: \"\",\n  });\n  const handleImageClick = useCallback((imageId: string, title: string) => {\n    setImageModal({ open: true, imageId, title });\n  }, []);\n\n  // Image picker state\n  const [pickerRef, setPickerRef] = useState<PromptRequestRef | null>(null);\n  const handleOpenPicker = useCallback((ref: PromptRequestRef) => {\n    setPickerRef(ref);\n  }, []);\n  const handleClosePicker = useCallback(() => {\n    setPickerRef(null);\n  }, []);\n  const handleSelectImage = useCallback(\n    (imageId: string) => {\n      if (pickerRef && onSelectExistingImage) {\n        onSelectExistingImage(pickerRef, imageId);\n      }\n      setPickerRef(null);\n    },\n    [pickerRef, onSelectExistingImage]\n  );\n\n  // Culture selection from global settings\n  const selectedCultureId = imageGenSettings?.selectedCultureId || \"\";\n\n  // Derive primary culture from chronicle entities if not manually selected\n  const derivedCultureId = useMemo(() => {\n    if (selectedCultureId) return selectedCultureId;\n\n    // Try to find dominant culture from entities involved in the chronicle\n    const cultureCounts = new Map<string, number>();\n    for (const entity of entities.values()) {\n      if (entity.culture && entity.culture !== \"universal\") {\n        cultureCounts.set(entity.culture, (cultureCounts.get(entity.culture) || 0) + 1);\n      }\n    }\n\n    let maxCulture = \"\";\n    let maxCount = 0;\n    for (const [culture, count] of cultureCounts) {\n      if (count > maxCount) {\n        maxCulture = culture;\n        maxCount = count;\n      }\n    }\n\n    return maxCulture;\n  }, [selectedCultureId, entities]);\n\n  // Separate entity refs and prompt requests\n  const { entityRefs, promptRequests } = useMemo(() => {\n    if (!imageRefs?.refs) return { entityRefs: [], promptRequests: [] };\n\n    const entityRefs: EntityImageRef[] = [];\n    const promptRequests: PromptRequestRef[] = [];\n\n    for (const ref of imageRefs.refs) {\n      if (ref.type === \"entity_ref\") {\n        entityRefs.push(ref);\n      } else {\n        promptRequests.push(ref);\n      }\n    }\n\n    return { entityRefs, promptRequests };\n  }, [imageRefs]);\n\n  // Count by status\n  const stats = useMemo(() => {\n    const pending = promptRequests.filter((r) => r.status === \"pending\").length;\n    const generating = promptRequests.filter((r) => r.status === \"generating\").length;\n    const complete = promptRequests.filter((r) => r.status === \"complete\").length;\n    const failed = promptRequests.filter((r) => r.status === \"failed\").length;\n\n    return { pending, generating, complete, failed };\n  }, [promptRequests]);\n\n  // Build style info for image generation\n  const buildStyleInfo = useCallback((): StyleInfo => {\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityCultureId: derivedCultureId,\n      entityKind: DEFAULT_VISUAL_IDENTITY_KIND,\n      cultures: cultures || [],\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n\n    // Get visual identity for the selected culture\n    const cultureVisualIdentity = cultureIdentities?.visual?.[derivedCultureId] || {};\n    const allowedKeys =\n      cultureIdentities?.visualKeysByKind?.[DEFAULT_VISUAL_IDENTITY_KIND] ||\n      Object.keys(cultureVisualIdentity); // Use all keys if no kind-specific filtering\n\n    const filteredVisualIdentity: Record<string, string> = {};\n    for (const key of allowedKeys) {\n      if (cultureVisualIdentity[key]) {\n        filteredVisualIdentity[key] = cultureVisualIdentity[key];\n      }\n    }\n\n    return {\n      artisticPromptFragment: (resolved.artisticStyle as { promptFragment?: string } | null)?.promptFragment,\n      compositionPromptFragment: (resolved.compositionStyle as { promptFragment?: string } | null)?.promptFragment,\n      colorPalettePromptFragment: (resolved.colorPalette as { promptFragment?: string } | null)?.promptFragment,\n    };\n  }, [styleSelection, derivedCultureId, cultures, styleLibrary, cultureIdentities]);\n\n  // Handle generating a single image\n  const handleGenerateImage = useCallback(\n    (ref: PromptRequestRef) => {\n      if (!onGenerateImage) return;\n\n      const styleInfo = buildStyleInfo();\n\n      const prompt = buildChronicleScenePrompt(\n        {\n          sceneDescription: ref.sceneDescription,\n          size: ref.size,\n          chronicleTitle,\n          world: worldContext\n            ? {\n                name: worldContext.name || \"Unknown World\",\n                description: worldContext.description,\n                speciesConstraint: worldContext.speciesConstraint,\n              }\n            : undefined,\n        },\n        styleInfo\n      );\n\n      onGenerateImage(ref, prompt, styleInfo);\n    },\n    [onGenerateImage, buildStyleInfo, chronicleTitle, worldContext]\n  );\n\n  // No image refs yet\n  if (!imageRefs) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references generated yet. Use the &quot;Generate&quot; button above to create image\n        placement suggestions.\n      </div>\n    );\n  }\n\n  const totalRefs = entityRefs.length + promptRequests.length;\n\n  if (totalRefs === 0) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references in this chronicle.\n      </div>\n    );\n  }\n\n  const hasSceneImages = promptRequests.length > 0;\n\n  return (\n    <div>\n      {/* Header with stats */}\n      <div className=\"cip-header-row\">\n        <div className=\"cip-header-title\">Image References ({totalRefs})</div>\n        <div className=\"cip-header-stats\">\n          <span className=\"cip-stat-muted\">Entity refs: {entityRefs.length}</span>\n          <span className=\"cip-stat-muted\">Scenes: {promptRequests.length}</span>\n          {stats.pending > 0 && <span className=\"cip-stat-pending\">Pending: {stats.pending}</span>}\n          {stats.complete > 0 && (\n            <span className=\"cip-stat-complete\">Complete: {stats.complete}</span>\n          )}\n        </div>\n      </div>\n\n      {/* Image Settings Summary - show when there are scene images */}\n      {hasSceneImages && imageGenSettings && onOpenImageSettings && (\n        <ImageSettingsSummary\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary || null}\n          onOpenSettings={onOpenImageSettings}\n        />\n      )}\n\n      {/* Entity Refs Section */}\n      {entityRefs.length > 0 && (\n        <div className=\"cip-section\">\n          <div className=\"cip-section-title\">\n            Entity Images ({entityRefs.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {entityRefs.map((ref) => (\n              <EntityImageRefCard\n                key={ref.refId}\n                imageRef={ref}\n                entity={entities.get(ref.entityId)}\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Prompt Requests Section */}\n      {promptRequests.length > 0 && (\n        <div>\n          <div className=\"cip-section-title\">\n            Scene Images ({promptRequests.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {promptRequests.map((ref) => (\n              <PromptRequestCard\n                key={ref.refId}\n                imageRef={ref}\n                onGenerate={() => handleGenerateImage(ref)}\n                onReset={onResetImage ? () => onResetImage(ref) : undefined}\n                onRegenerateDescription={\n                  onRegenerateDescription ? () => onRegenerateDescription(ref) : undefined\n                }\n                onSelectExisting={\n                  onSelectExistingImage && projectId ? () => handleOpenPicker(ref) : undefined\n                }\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n                entities={entities}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Metadata footer */}\n      <div className=\"cip-metadata-footer\">\n        Generated: {new Date(imageRefs.generatedAt).toLocaleString()} \u2022 Model: {imageRefs.model}\n      </div>\n\n      <ImageModal\n        isOpen={imageModal.open}\n        imageId={imageModal.imageId}\n// ... (truncated)", "parameters": [{"name": "{\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}", "type": "Readonly<ChronicleImagePanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "./ImageModal", "specifiers": ["ImageModal"], "category": "internal"}, {"source": "./ChronicleImagePicker", "specifiers": ["ChronicleImagePicker"], "category": "internal"}, {"source": "./StyleSelector", "specifiers": ["resolveStyleSelection"], "category": "internal"}, {"source": "./ImageSettingsDrawer", "specifiers": ["ImageSettingsSummary"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["buildChronicleScenePrompt"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["ChronicleImageRefs", "EntityImageRef", "PromptRequestRef"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["StyleInfo"], "category": "internal"}, {"source": "./ChronicleImagePanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx", "sourceCode": "export default function ChronicleImagePicker({\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n\n  // Filter state - both default ON\n  const [filterByRef, setFilterByRef] = useState(true);\n  const [filterByChronicle, setFilterByChronicle] = useState(true);\n\n  const mouseDownOnOverlay = useRef(false);\n\n  // Reset state when opening\n  useEffect(() => {\n    if (isOpen) {\n      setImages([]);\n      setSelectedImageId(null);\n      setFilterByRef(true);\n      setFilterByChronicle(true);\n      setHasMore(false);\n      setTotal(0);\n    }\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen || !projectId) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {\n          projectId,\n          limit: PAGE_SIZE,\n          offset: 0,\n        };\n\n        // Apply filters based on checkbox state\n        // If filterByRef is ON, filter by imageRefId (most specific)\n        // If filterByRef is OFF but filterByChronicle is ON, filter by chronicleId\n        // If both OFF, show all chronicle images for project\n        if (filterByRef && imageRefId) {\n          filters.imageRefId = imageRefId;\n          // When filtering by ref, also filter by chronicle for efficiency\n          if (chronicleId) filters.chronicleId = chronicleId;\n        } else if (filterByChronicle && chronicleId) {\n          filters.chronicleId = chronicleId;\n        }\n\n        const result = await searchChronicleImages(filters);\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n      } catch (err) {\n        console.error(\"Failed to load chronicle images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, projectId, chronicleId, imageRefId, filterByRef, filterByChronicle]);\n\n  // Load more handler\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const filters = {\n        projectId,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      };\n\n      if (filterByRef && imageRefId) {\n        filters.imageRefId = imageRefId;\n        if (chronicleId) filters.chronicleId = chronicleId;\n      } else if (filterByChronicle && chronicleId) {\n        filters.chronicleId = chronicleId;\n      }\n\n      const result = await searchChronicleImages(filters);\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [\n    loading,\n    hasMore,\n    projectId,\n    chronicleId,\n    imageRefId,\n    filterByRef,\n    filterByChronicle,\n    images.length,\n  ]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    onClose();\n  }, [onClose]);\n\n  // Overlay click handling\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n\n  // Close on escape\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") handleClose();\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal cip-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Existing Image</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body cip-body\">\n          {/* Filters */}\n          <div className=\"cip-filters\">\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByRef}\n                onChange={(e) => setFilterByRef(e.target.checked)}\n              />\n              This ref only\n            </label>\n\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByChronicle}\n                onChange={(e) => setFilterByChronicle(e.target.checked)}\n              />\n              This chronicle only\n            </label>\n\n            <span className=\"cip-filter-count\">\n              {total} image{total !== 1 ? \"s\" : \"\"}\n            </span>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"cip-grid-area\">\n            {loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">\n                No images found. Try unchecking filters to see more.\n              </div>\n            )}\n            {images.length > 0 && (\n              <>\n                <div className=\"cip-grid\">\n                  {images.map((img) => {\n                    const isSelected = selectedImageId === img.imageId;\n                    const isCurrent = currentImageId === img.imageId;\n\n                    return (\n                      <div\n                        key={img.imageId}\n                        onClick={() => setSelectedImageId(img.imageId)}\n                        className={(() => {\n                          if (isSelected) return \"cip-image-card cip-image-card-selected\";\n                          if (isCurrent) return \"cip-image-card cip-image-card-current\";\n                          return \"cip-image-card\";\n                        })()}\n                        role=\"button\"\n                        tabIndex={0}\n                        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                      >\n                        <LazyThumbnail\n                          imageId={img.imageId}\n                          alt={img.sceneDescription || \"Chronicle image\"}\n                          className=\"cip-thumb-container\"\n                        />\n\n                        {/* Current indicator */}\n                        {isCurrent && <div className=\"cip-current-badge\">Current</div>}\n\n                        {/* Date overlay */}\n                        <div className=\"cip-date-overlay\">{formatDate(img.generatedAt)}</div>\n                      </div>\n                    );\n                  })}\n                </div>\n\n                {/* Load more button */}\n                {hasMore && (\n                  <div className=\"cip-load-more-wrapper\">\n                    <button\n                      onClick={() => void handleLoadMore()}\n                      disabled={loading}\n                      className=\"cip-load-more-btn\"\n                    >\n                      {loading ? \"Loading...\" : `Load More (${total - images.length} remaining)`}\n                    </button>\n                  </div>\n                )}\n              </>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer cip-footer\">\n          <button onClick={handleClose} className=\"cip-cancel-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId}\n            className={`cip-select-btn ${selectedImageId ? \"cip-select-btn-active\" : \"cip-select-btn-disabled\"}`}\n          >\n            Select Image\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; projectId: any; chronicleId: any; imageRefId: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/imageRepository", "specifiers": ["searchChronicleImages", "loadImage"], "category": "internal"}, {"source": "./ChronicleImagePicker.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChroniclePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePanel.jsx", "sourceCode": "export default function ChroniclePanel({\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}) {\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  // Full entities from Dexie for generation context (tags, description, coordinates, etc.)\n  const [fullEntities, setFullEntities] = useState([]);\n  const fullEntityMapRef = useRef(new Map());\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const [selectedItemId, setSelectedItemId] = useState(() => {\n    const saved = localStorage.getItem(\"illuminator:chronicle:selectedItemId\");\n    return saved || null;\n  });\n  const [groupByType, setGroupByType] = useState(false);\n  const [sortMode, setSortMode] = useState(\"era_asc\");\n  const [statusFilter, setStatusFilter] = useState(\"all\");\n  const [focusFilter, setFocusFilter] = useState(\"all\");\n  const [entitySearchQuery, setEntitySearchQuery] = useState(\"\");\n  const [entitySearchSelectedId, setEntitySearchSelectedId] = useState(null);\n  const [showEntitySuggestions, setShowEntitySuggestions] = useState(false);\n  const [navVisibleCount, setNavVisibleCount] = useState(NAV_PAGE_SIZE);\n  const navListRef = useRef(null);\n  const navLoadMoreRef = useRef(null);\n  // Load full entities from Dexie for generation operations (tags, description, coordinates, etc.)\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    getEntitiesForRun(simulationRunId).then(ents => {\n      if (cancelled) return;\n      setFullEntities(ents);\n      fullEntityMapRef.current = new Map(ents.map(e => [e.id, e]));\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const chronicleWorldData = useMemo(() => ({\n    entities: fullEntities,\n    relationships: relationships || [],\n    narrativeHistory: narrativeEvents || []\n  }), [fullEntities, relationships, narrativeEvents]);\n  useEffect(() => {\n    if (selectedItemId) {\n      localStorage.setItem(\"illuminator:chronicle:selectedItemId\", selectedItemId);\n    } else {\n      localStorage.removeItem(\"illuminator:chronicle:selectedItemId\");\n    }\n  }, [selectedItemId]);\n\n  // State for restart confirmation modal\n  const [showRestartModal, setShowRestartModal] = useState(false);\n  const [pendingRestartChronicleId, setPendingRestartChronicleId] = useState(null);\n\n  // State for reset backport flags modal\n  const [showResetBackportModal, setShowResetBackportModal] = useState(false);\n  const [resetBackportResult, setResetBackportResult] = useState(null);\n\n  // State for reconcile backport status\n  const [reconcileBackportResult, setReconcileBackportResult] = useState(null);\n\n  // State for era summary refresh\n  const [eraSummaryRefreshResult, setEraSummaryRefreshResult] = useState(null);\n\n  // State for bulk temporal check\n  const [temporalCheckResult, setTemporalCheckResult] = useState(null);\n\n  // State for bulk tertiary re-detect\n  const [tertiaryDetectResult, setTertiaryDetectResult] = useState(null);\n\n  // State for bulk summary generation\n  const [bulkSummaryResult, setBulkSummaryResult] = useState(null);\n\n  // Collapsible bulk actions panel\n  const [showBulkActions, setShowBulkActions] = useState(false);\n\n  // State for chronology modal\n  const [showChronologyModal, setShowChronologyModal] = useState(false);\n\n  // Era narrative modal \u2014 state lives in Zustand store to survive tab switches\n  const eraNarrativeModal = useIlluminatorModals(s => s.eraNarrativeModal);\n\n  // Bulk historian prep: skip chronicles that already have prep\n  const [skipCompletedPrep, setSkipCompletedPrep] = useState(true);\n\n  // Bulk era narrative modal\n  const [showBulkEraNarrative, setShowBulkEraNarrative] = useState(false);\n  const bulkEraNarrativeProgress = useBulkEraNarrativeStore(s => s.progress);\n\n  // Era narrative nav items (loaded from IndexedDB, merged into chronicle list)\n  const [eraNarrativeNavItems, setEraNarrativeNavItems] = useState([]);\n\n  // Fact coverage bulk analysis\n  const {\n    progress: factCoverageProgress,\n    isActive: isFactCoverageActive,\n    prepareFactCoverage,\n    confirmFactCoverage,\n    cancelFactCoverage,\n    closeFactCoverage\n  } = useFactCoverage();\n\n  // Tone ranking & assignment\n  const {\n    progress: toneRankingProgress,\n    isActive: isToneRankingActive,\n    prepareToneRanking,\n    prepareAssignment\n  } = useToneRanking();\n\n  // Bulk chronicle annotations (clear / run)\n  const bulkAnnotationProgress = useBulkChronicleAnnotationStore(s => s.progress);\n  const prepareBulkAnnotation = useBulkChronicleAnnotationStore(s => s.prepareAnnotation);\n  const isBulkAnnotationActive = bulkAnnotationProgress.status === \"running\" || bulkAnnotationProgress.status === \"confirming\";\n\n  // Interleaved annotation (chronicle + entity)\n  const prepareInterleaved = useInterleavedAnnotationStore(s => s.prepareInterleaved);\n  const interleavedProgress = useInterleavedAnnotationStore(s => s.progress);\n  const isInterleavedActive = interleavedProgress.status === \"running\" || interleavedProgress.status === \"confirming\";\n  const entityNavItems = useEntityStore(s => s.navItems);\n\n  // State for wizard modal\n  const [showWizard, setShowWizard] = useState(false);\n  // Seed for restarting with previous settings\n  const [wizardSeed, setWizardSeed] = useState(null);\n\n  // Derive style/size/quality from global imageGenSettings\n  const chronicleImageSize = imageGenSettings.imageSize;\n  const chronicleImageQuality = imageGenSettings.imageQuality;\n  const chronicleStyleSelection = useMemo(() => ({\n    artisticStyleId: imageGenSettings.artisticStyleId,\n    compositionStyleId: imageGenSettings.compositionStyleId,\n    colorPaletteId: imageGenSettings.colorPaletteId\n  }), [imageGenSettings.artisticStyleId, imageGenSettings.compositionStyleId, imageGenSettings.colorPaletteId]);\n\n  // Name bank for invented characters (culture ID -> array of names)\n  const [nameBank, setNameBank] = useState({});\n\n  // Style library loading state (derived from prop)\n  const stylesLoading = !styleLibrary;\n\n  // Initialize chronicle store when simulation changes\n  useEffect(() => {\n    if (simulationRunId) {\n      useChronicleStore.getState().initialize(simulationRunId);\n    }\n  }, [simulationRunId]);\n\n  // Enqueue-dependent actions (generate, compare, combine)\n  const {\n    generateV2,\n    generateSummary,\n    generateTitle,\n    regenerateWithSampling,\n    regenerateFull,\n    regenerateCreative,\n    compareVersions,\n    combineVersions,\n    copyEdit,\n    temporalCheck,\n    quickCheck\n  } = useChronicleActions();\n\n  // Lifecycle actions from store (no queue dependency)\n  const acceptChronicle = useChronicleStore(s => s.acceptChronicle);\n  const cancelChronicle = useChronicleStore(s => s.cancelChronicle);\n  const restartChronicle = useChronicleStore(s => s.restartChronicle);\n\n  // Scope the \"generating\" lock to the selected chronicle so other chronicles remain interactive.\n  const isGenerating = Boolean(selectedItemId) && queue.some(item => item.type === \"entityChronicle\" && item.chronicleId === selectedItemId && (item.status === \"queued\" || item.status === \"running\"));\n\n  // Refresh helpers\n  const refresh = useCallback(() => useChronicleStore.getState().refreshAll(), []);\n  const refreshChronicle = useCallback(id => useChronicleStore.getState().refreshChronicle(id), []);\n\n  // Assign tone to a chronicle without triggering annotation\n  const handleSetAssignedTone = useCallback(async (chronicleId, tone) => {\n    await updateChronicleAssignedTone(chronicleId, tone);\n    refreshChronicle(chronicleId);\n  }, [refreshChronicle]);\n\n  // Detect tone for a single chronicle via LLM\n  const handleDetectTone = useCallback(async (chronicleId, title) => {\n    const record = await getChronicle(chronicleId);\n    if (!record?.summary) return;\n    const payload = {\n      chronicleId,\n      summary: record.summary,\n      format: record.format || \"story\",\n      narrativeStyleName: record.narrativeStyle?.name,\n      brief: record.perspectiveSynthesis?.brief\n    };\n    const entity = {\n      id: chronicleId,\n      name: title || \"Chronicle\",\n      kind: \"chronicle\",\n      subtype: \"\",\n      prominence: \"recognized\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {}\n    };\n    onEnqueue([{\n      entity,\n      type: \"toneRanking\",\n      prompt: JSON.stringify(payload),\n      chronicleId\n    }]);\n  }, [onEnqueue]);\n\n  // External refresh trigger (e.g. after lore backport)\n  useEffect(() => {\n    if (refreshTrigger > 0) refresh();\n  }, [refreshTrigger, refresh]);\n  const entitySuggestions = useMemo(() => {\n    const query = entitySearchQuery.trim().toLowerCase();\n    if (!query || !navEntities?.length) return [];\n    return navEntities.filter(entity => entity.name?.toLowerCase().includes(query)).slice(0, 8);\n  }, [navEntities, entitySearchQuery]);\n  const narrativeStyleNameMap = useMemo(() => {\n    const map = new Map();\n    const styles = styleLibrary?.narrativeStyles || [];\n    for (const style of styles) {\n      if (style?.id) {\n        map.set(style.id, style.name || style.id);\n      }\n    }\n    return map;\n  }, [styleLibrary?.narrativeStyles]);\n\n  // Helper to get status considering both IndexedDB and queue state\n  const getEffectiveStatus = useCallback((chronicleId, baseStatus) => {\n    // First check queue for running/queued tasks for this chronicle\n    const queueTask = queue.find(item => item.type === \"entityChronicle\" && item.chronicleId === chronicleId && !REFINEMENT_STEPS.has(item.chronicleStep || \"\"));\n    if (queueTask) {\n      if (queueTask.status === \"running\") {\n        // Map chronicleStep to status\n        switch (queueTask.chronicleStep) {\n          case \"validate\":\n            return \"validating\";\n          case \"edit\":\n            return \"editing\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n      if (queueTask.status === \"queued\") {\n        switch (queueTask.chronicleStep) {\n          case \"edit\":\n            return \"editing\";\n          case \"validate\":\n            return \"validating\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n    }\n\n    // Fall back to IndexedDB-derived status\n    return baseStatus;\n  }, [queue]);\n\n  // Lightweight nav items from Zustand store (shallow-compared, only re-renders on nav-relevant changes)\n  const chronicleItems = useChronicleNavItems(getEffectiveStatus);\n  const getChronicleTypeLabel = useCallback(item => {\n    if (item?.itemType === \"era_narrative\") return \"Era Narrative\";\n    if (item?.narrativeStyleName) return item.narrativeStyleName;\n// ... (truncated)", "parameters": [{"name": "{\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}", "type": "{ worldData: any; queue: any; onEnqueue: any; onCancel: any; worldContext: any; projectId: any; simulationRunId: any; buildPrompt: any; styleLibrary: any; imageGenSettings: any; entityGuidance: any; cultureIdentities: any; onBackportLore: any; onStartBulkBackport: any; isBulkBackportActive: any; refreshTrigger: any; imageModel: any; onOpenImageSettings: any; onHistorianReview: any; isHistorianActive: any; historianConfigured: any; historianConfig: any; onUpdateHistorianNote: any; onRefreshEra...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChroniclePanel.css", "specifiers": [], "category": "internal"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList", "useEntityNavItems"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["getEntitiesForRun", "resetEntitiesToPreBackportState"], "category": "internal"}, {"source": "../lib/db/relationshipSelectors", "specifiers": ["useRelationships"], "category": "internal"}, {"source": "../lib/db/narrativeEventSelectors", "specifiers": ["useNarrativeEvents"], "category": "internal"}, {"source": "./ChronicleReviewPanel", "specifiers": ["ChronicleReviewPanel"], "category": "internal"}, {"source": "./ChronicleWizard", "specifiers": ["ChronicleWizard"], "category": "internal"}, {"source": "../lib/chronicleContextBuilder", "specifiers": ["buildChronicleContext", "buildEventHeadline"], "category": "internal"}, {"source": "../lib/chronicle/nameBank", "specifiers": ["generateNameBank", "extractCultureIds"], "category": "internal"}, {"source": "../hooks/useChronicleGeneration", "specifiers": ["deriveStatus"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleSelectors", "specifiers": ["useChronicleNavItems", "useSelectedChronicle"], "category": "internal"}, {"source": "../hooks/useChronicleActions", "specifiers": ["useChronicleActions"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["buildChronicleScenePrompt"], "category": "internal"}, {"source": "./StyleSelector", "specifiers": ["resolveStyleSelection"], "category": "internal"}, {"source": "../lib/coverImageStyles", "specifiers": ["getCoverImageConfig"], "category": "internal"}, {"source": "../lib/chronicle/selectionWizard", "specifiers": ["computeTemporalContext"], "category": "internal"}, {"source": "./ChronologyModal", "specifiers": ["ChronologyModal"], "category": "internal"}, {"source": "./EraNarrativeModal", "specifiers": ["EraNarrativeModal"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["updateChronicleImageRef", "updateChronicleTemporalContext", "updateChronicleActiveVersion", "updateChronicleCombineInstructions", "unpublishChronicle", "updateChronicleCoverImageStatus", "generateChronicleId", "deriveTitleFromRoles", "createChronicleShell", "resetAllBackportFlags", "reconcileBackportStatusFromEntities", "deleteChronicleVersion", "applyImageRefSelections", "getChronicle", "updateChronicleTertiaryCast", "updateChronicleAssignedTone", "getChroniclesForSimulation", "updateChronicleHistorianPrep"], "category": "internal"}, {"source": "../lib/wikiLinkService", "specifiers": ["findEntityMentions"], "category": "internal"}, {"source": "../lib/chronicleExport", "specifiers": ["downloadChronicleExport", "downloadBulkToneReviewExport", "downloadBulkAnnotationReviewExport"], "category": "internal"}, {"source": "../lib/llmModelSettings", "specifiers": ["getCallConfig"], "category": "internal"}, {"source": "../hooks/useFactCoverage", "specifiers": ["useFactCoverage"], "category": "internal"}, {"source": "./BulkFactCoverageModal", "specifiers": ["BulkFactCoverageModal"], "category": "internal"}, {"source": "../hooks/useToneRanking", "specifiers": ["useToneRanking"], "category": "internal"}, {"source": "../lib/db/bulkChronicleAnnotationStore", "specifiers": ["useBulkChronicleAnnotationStore"], "category": "internal"}, {"source": "../lib/db/interleavedAnnotationStore", "specifiers": ["useInterleavedAnnotationStore"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/annotateEntityNames", "specifiers": ["annotateEntityNames"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["getEraNarrativesForSimulation"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/eraNarrativeNav", "specifiers": ["buildEraNarrativeNavItem"], "category": "internal"}, {"source": "./EraNarrativeViewer", "specifiers": ["EraNarrativeViewer"], "category": "internal"}, {"source": "./BulkEraNarrativeModal", "specifiers": ["BulkEraNarrativeModal"], "category": "internal"}, {"source": "../lib/db/bulkEraNarrativeStore", "specifiers": ["useBulkEraNarrativeStore"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx", "sourceCode": "export default function ChroniclePlanEditor({\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}) {\n  const sectionCount = plan.sections?.length || 0;\n\n  const eventStats = useMemo(() => {\n    const eventIds = new Set();\n    plan.sections?.forEach((section) => {\n      section.eventIds?.forEach((id) => eventIds.add(id));\n    });\n    return eventIds.size;\n  }, [plan.sections]);\n\n  return (\n    <div className=\"cpe-root\">\n      <PlanHeader plan={plan} />\n      <OutlineSummary plan={plan} />\n      <FocusSummary plan={plan} entityMap={entityMap} />\n      <PlotSummary plan={plan} />\n      <EntityRoleList plan={plan} entityMap={entityMap} />\n\n      <div className=\"cpe-stats-row\">\n        <div className=\"cpe-stat-box\">\n          <strong>Sections:</strong> {sectionCount}\n        </div>\n        <div className=\"cpe-stat-box\">\n          <strong>Referenced Events:</strong> {eventStats}\n        </div>\n      </div>\n\n      <SectionsList plan={plan} entityMap={entityMap} eventMap={eventMap} />\n\n      <div className=\"cpe-action-bar\">\n        <button\n          onClick={onRegenerate}\n          disabled={isGenerating}\n          className={`illuminator-button cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Regenerate Plan\n        </button>\n        <button\n          onClick={onApprove}\n          disabled={isGenerating}\n          className={`illuminator-button illuminator-button-primary cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Approve Plan\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}", "type": "{ plan: any; entityMap: any; eventMap: any; onRegenerate: any; onApprove: any; isGenerating?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChroniclePlanEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function ChronicleReviewPanel({\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  if (!item) return null;\n\n  // ---------------------------------------------------------------------------\n  // Assembly Ready & Complete \u2192 Tabbed Workspace\n  // ---------------------------------------------------------------------------\n  if (\n    (item.status === \"assembly_ready\" && item.assembledContent) ||\n    (item.status === \"complete\" && item.finalContent)\n  ) {\n    return (\n      <ChronicleWorkspace\n        item={item}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onRegenerateFull={onRegenerateFull}\n        onRegenerateCreative={onRegenerateCreative}\n        onCompareVersions={onCompareVersions}\n        onCombineVersions={onCombineVersions}\n        onCopyEdit={onCopyEdit}\n        onTemporalCheck={onTemporalCheck}\n        onQuickCheck={onQuickCheck}\n        onValidate={onValidate}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateTitle={onGenerateTitle}\n        onAcceptPendingTitle={onAcceptPendingTitle}\n        onRejectPendingTitle={onRejectPendingTitle}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onRegenerateDescription={onRegenerateDescription}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleTemporalContext={onUpdateChronicleTemporalContext}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        onUpdateCombineInstructions={onUpdateCombineInstructions}\n        onUnpublish={onUnpublish}\n        onGenerateCoverImageScene={onGenerateCoverImageScene}\n        onGenerateCoverImage={onGenerateCoverImage}\n        styleSelection={styleSelection}\n        imageSize={imageSize}\n        imageQuality={imageQuality}\n        imageModel={imageModel}\n        imageGenSettings={imageGenSettings}\n        onOpenImageSettings={onOpenImageSettings}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onApplyImageRefSelections={onApplyImageRefSelections}\n        onSelectExistingImage={onSelectExistingImage}\n        onSelectExistingCoverImage={onSelectExistingCoverImage}\n        onExport={onExport}\n        onBackportLore={onBackportLore}\n        onHistorianReview={onHistorianReview}\n        onSetAssignedTone={onSetAssignedTone}\n        onDetectTone={onDetectTone}\n        isHistorianActive={isHistorianActive}\n        onUpdateHistorianNote={onUpdateHistorianNote}\n        onGeneratePrep={onGeneratePrep}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        simulationRunId={simulationRunId}\n        worldSchema={worldSchema}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n        eras={eras}\n        events={events}\n        onNavigateToTab={onNavigateToTab}\n      />\n    );\n  }\n\n  // ---------------------------------------------------------------------------\n  // Validation Ready \u2192 Inline layout (not tabbed)\n  // ---------------------------------------------------------------------------\n  if (item.status === \"validation_ready\") {\n    return (\n      <ValidationReadyView\n        item={item}\n        onExport={onExport}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onCorrectSuggestions={onCorrectSuggestions}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onRevalidate={onRevalidate}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n      />\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onContinueToValidation: any; onValidate: any; onAddImages: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onRevalidate: any; onGenerateChronicleImage: a...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useCallback", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "diff", "specifiers": ["diffWords"], "category": "external"}, {"source": "./CohesionReportViewer", "specifiers": ["CohesionReportViewer"], "category": "internal"}, {"source": "./ImageModal", "specifiers": ["ImageModal"], "category": "internal"}, {"source": "./chronicle-workspace/ChronicleWorkspace", "specifiers": ["ChronicleWorkspace"], "category": "internal"}, {"source": "./chronicle-workspace/ChronicleVersionSelector", "specifiers": ["ChronicleVersionSelector"], "category": "internal"}, {"source": "./ChronicleReviewPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronologyModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronologyModal.jsx", "sourceCode": "export default function ChronologyModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [expandedReasoning, setExpandedReasoning] = useState({});\n\n  const { run, isActive, startChronology, adjustYear, applyChronology, cancelChronology } =\n    useHistorianChronology(onEnqueue);\n\n  // Build era options from wizardEras\n  const eraOptions = useMemo(() => {\n    return wizardEras.map((era) => {\n      const eraChronicles = chronicleItems.filter((c) => c.focalEraName === era.name);\n      return {\n        id: era.id,\n        name: era.name,\n        startTick: era.startTick,\n        endTick: era.endTick,\n        count: eraChronicles.length,\n        preppedCount: eraChronicles.filter((c) => c.hasHistorianPrep).length,\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n\n  // Get chronicles for the selected era\n  const selectedEra = eraOptions.find((e) => e.id === selectedEraId);\n\n  // Chronicles in the selected era for the list display\n  const selectedEraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems\n      .filter((c) => c.focalEraName === era.name)\n      .sort((a, b) => (a.eraYear || 0) - (b.eraYear || 0) || a.name.localeCompare(b.name));\n  }, [selectedEra, selectedEraId, wizardEras, chronicleItems]);\n\n  // Build context and start\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return;\n\n    // Get chronicles in this era\n    const eraChronicles = chronicleItems.filter((item) => item.focalEraName === era.name);\n\n    // Load full records for summaries\n    const store = useChronicleStore.getState();\n    const chronicleEntries = [];\n\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record) continue;\n\n      // Resolve event headlines for this chronicle\n      const chronicleEventIds = new Set(record.selectedEventIds || []);\n      const events = (wizardEvents || [])\n        .filter((e) => chronicleEventIds.has(e.id))\n        .map((e) => ({ tick: e.tick, headline: e.headline }));\n\n      // Cast from role assignments\n      const cast = (record.roleAssignments || []).map((r) => ({\n        entityName: r.entityName,\n        role: r.roleName || (r.isPrimary ? \"primary\" : \"supporting\"),\n        kind: r.entityKind || \"\",\n      }));\n\n      // Prefer historian prep, then summary, then opening text\n      const content = record.finalContent || record.assembledContent || \"\";\n      const openingText = content.slice(0, 300).split(/\\n\\n/).slice(0, 2).join(\"\\n\\n\");\n\n      chronicleEntries.push({\n        chronicleId: record.chronicleId,\n        title: record.title || item.name,\n        tickRange: record.temporalContext?.chronicleTickRange || [0, 0],\n        temporalScope: record.temporalContext?.temporalScope || \"unknown\",\n        isMultiEra: record.temporalContext?.isMultiEra || false,\n        cast,\n        events,\n        prep: record.historianPrep || undefined,\n        summary: record.historianPrep ? undefined : record.summary,\n        openingText: record.historianPrep || record.summary ? undefined : openingText,\n      });\n    }\n\n    // Previous eras for context\n    const previousEras = wizardEras\n      .filter((e) => e.order < era.order)\n      .sort((a, b) => a.order - b.order)\n      .map((e) => ({\n        name: e.name,\n        startTick: e.startTick,\n        endTick: e.endTick,\n        summary: e.summary,\n      }));\n\n    const contextJson = JSON.stringify({\n      era: {\n        eraId: era.id,\n        eraName: era.name,\n        eraSummary: era.summary,\n        startTick: era.startTick,\n        endTick: era.endTick,\n      },\n      previousEras,\n      chronicles: chronicleEntries,\n    });\n\n    startChronology({\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      contextJson,\n      historianConfig,\n      tone: \"scholarly\",\n    });\n  }, [\n    selectedEra,\n    selectedEraId,\n    wizardEras,\n    chronicleItems,\n    wizardEvents,\n    projectId,\n    simulationRunId,\n    historianConfig,\n    startChronology,\n  ]);\n\n  // Apply assignments to chronicle records\n  const handleApply = useCallback(async () => {\n    const assignments = applyChronology();\n    if (assignments.length === 0) return;\n\n    await batchUpdateChronicleEraYears(\n      assignments.map((a) => ({\n        chronicleId: a.chronicleId,\n        eraYear: a.year,\n        eraYearReasoning: a.reasoning,\n      }))\n    );\n\n    onApplied();\n  }, [applyChronology, onApplied]);\n\n  // Cancel\n  const handleCancel = useCallback(() => {\n    cancelChronology();\n  }, [cancelChronology]);\n\n  // Close modal (cancel if active)\n  const handleClose = useCallback(() => {\n    if (isActive) cancelChronology();\n    onClose();\n  }, [isActive, cancelChronology, onClose]);\n\n  if (!isOpen) return null;\n\n  const isGenerating = run?.status === \"pending\" || run?.status === \"generating\";\n  const isReviewing = run?.status === \"reviewing\";\n  const isFailed = run?.status === \"failed\";\n  const assignments = run?.chronologyAssignments || [];\n  const sortedAssignments = [...assignments].sort((a, b) => a.year - b.year);\n\n  // Find chronicle title by ID\n  const titleMap = {};\n  for (const item of chronicleItems) {\n    titleMap[item.chronicleId] = item.name;\n  }\n\n  const canStart = selectedEraId && selectedEra?.count > 0;\n\n  return (\n    <div\n      className=\"chm-overlay\"\n      onClick={(e) => {\n        if (e.target === e.currentTarget) handleClose();\n      }}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      <div className=\"chm-dialog\">\n        {/* Header */}\n        <div className=\"chm-header\">\n          <span className=\"chm-header-title\">\n            {isReviewing ? `Chronology: ${run?.targetName}` : \"Historian Chronology\"}\n          </span>\n          <button onClick={handleClose} className=\"chm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Body */}\n        <div className=\"chm-body\">\n          {/* Setup state */}\n          {!isActive && !isReviewing && !isFailed && (\n            <>\n              <div className=\"chm-field\">\n                <label htmlFor=\"era\" className=\"chm-field-label\">Era</label>\n                <select id=\"era\"\n                  className=\"illuminator-select chm-era-select\"\n                  value={selectedEraId}\n                  onChange={(e) => setSelectedEraId(e.target.value)}\n                >\n                  <option value=\"\">Select an era...</option>\n                  {eraOptions.map((era) => (\n                    <option key={era.id} value={era.id}>\n                      {era.name} ({era.count} chronicles, Y{era.startTick}\n                      {\"\\u2013\"}Y{era.endTick})\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Chronicle list for selected era */}\n              {selectedEra && selectedEraChronicles.length > 0 && (\n                <div className=\"chm-field\">\n                  <div className=\"chm-list-header\">\n                    <span>Chronicles ({selectedEraChronicles.length})</span>\n                    <span className=\"chm-list-header-right\">\n                      {selectedEra.preppedCount}/{selectedEraChronicles.length} prepped\n                    </span>\n                  </div>\n                  <div className=\"chm-chronicle-list\">\n                    {selectedEraChronicles.map((c, i) => (\n                      <div\n                        key={c.chronicleId}\n                        className={`chm-chronicle-row ${i < selectedEraChronicles.length - 1 ? \"chm-chronicle-row-bordered\" : \"\"}`}\n                      >\n                        <span\n                          className={`chm-prep-icon ${c.hasHistorianPrep ? \"chm-prep-icon-ready\" : \"chm-prep-icon-none\"}`}\n                          title={\n                            c.hasHistorianPrep ? \"Historian prep available\" : \"No historian prep\"\n                          }\n                        >\n                          {c.hasHistorianPrep ? \"\\u25C6\" : \"\\u25C7\"}\n                        </span>\n                        <span className=\"chm-chronicle-name\">{c.name}</span>\n                        {c.eraYear != null && <span className=\"chm-era-year\">Y{c.eraYear}</span>}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n\n              <button\n                onClick={() => void handleStart()}\n                disabled={!canStart}\n                className={`illuminator-button chm-start-btn ${canStart ? \"chm-start-btn-active\" : \"chm-start-btn-disabled\"}`}\n              >\n                Assign Years\n              </button>\n            </>\n          )}\n\n          {/* Generating state */}\n          {isGenerating && (\n            <div className=\"chm-generating\">\n              <div className=\"chm-generating-msg\">The historian is ordering chronicles...</div>\n              <div className=\"chm-generating-target\">{run?.targetName}</div>\n            </div>\n          )}\n\n          {/* Failed state */}\n          {isFailed && (\n            <div className=\"chm-failed\">\n              <div className=\"chm-failed-msg\">Chronology failed</div>\n              <div className=\"chm-failed-error\">{run?.error}</div>\n              <button onClick={handleCancel} className=\"illuminator-button\">\n                Dismiss\n              </button>\n            </div>\n          )}\n\n          {/* Review state */}\n          {isReviewing && sortedAssignments.length > 0 && (\n            <>\n              <div className=\"chm-review-hint\">\n                {sortedAssignments.length} chronicles ordered. Adjust years if needed, then apply.\n              </div>\n\n              <div className=\"chm-assignments\">\n                {sortedAssignments.map((a) => (\n                  <div key={a.chronicleId} className=\"chm-assignment-card\">\n                    <div className=\"chm-assignment-row\">\n                      <input\n                        type=\"number\"\n                        value={a.year}\n                        min={selectedEra?.startTick}\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; wizardEvents: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; onApplied: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["batchUpdateChronicleEraYears"], "category": "internal"}, {"source": "../hooks/useHistorianChronology", "specifiers": ["useHistorianChronology"], "category": "internal"}, {"source": "./ChronologyModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx", "sourceCode": "export default function CohesionReportViewer({\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}) {\n  const [activeTab, setActiveTab] = useState(\"summary\");\n\n  // Calculate assessment\n  const assessment = useMemo(() => {\n    if (!report) return null;\n    const criticalIssues = report.issues.filter(i => i.severity === \"critical\");\n    const minorIssues = report.issues.filter(i => i.severity === \"minor\");\n    const failedChecks = [];\n    if (!report.checks.plotStructure.pass) failedChecks.push(\"Structure\");\n    if (!report.checks.entityConsistency.pass) failedChecks.push(\"Entity Consistency\");\n    if (!report.checks.resolution.pass) failedChecks.push(\"Resolution\");\n    if (!report.checks.factualAccuracy.pass) failedChecks.push(\"Factual Accuracy\");\n    if (!report.checks.themeExpression.pass) failedChecks.push(\"Theme Expression\");\n    const failedSectionGoals = report.checks.sectionGoals.filter(sg => !sg.pass);\n    let status;\n    if (report.overallScore >= 90) status = \"excellent\";else if (report.overallScore >= 75) status = \"good\";else if (report.overallScore >= 60) status = \"acceptable\";else status = \"needs_revision\";\n    return {\n      status,\n      criticalIssueCount: criticalIssues.length,\n      minorIssueCount: minorIssues.length,\n      failedChecks,\n      failedSectionGoals\n    };\n  }, [report]);\n  if (!report) {\n    return <div className=\"crv-empty\">No validation report available.</div>;\n  }\n  const statusStyle = STATUS_STYLES[assessment?.status || \"needs_revision\"];\n  const resolveSectionLabel = sectionId => sectionId;\n  const hasIssues = report.issues.length > 0;\n  const formatTimestamp = timestamp => new Date(timestamp).toLocaleString();\n  const summaryState = refinements?.summary || {};\n  const imageRefsState = refinements?.imageRefs || {};\n  const disabledClass = condition => condition ? \"crv-btn-disabled\" : \"\";\n  return <div className=\"crv\">\n      {/* Header with score and actions */}\n      <div className=\"crv-header\">\n        <div className=\"crv-header-left\">\n          <ScoreGauge score={report.overallScore} />\n          <div>\n            {}\n            <div className={`crv-status-badge crv-status-badge-${assessment?.status || \"needs_revision\"}`}>\n              {statusStyle.label}\n            </div>\n            <div className=\"crv-issue-count\">\n              {assessment?.criticalIssueCount || 0} critical issues \u2022{\" \"}\n              {assessment?.minorIssueCount || 0} minor issues\n            </div>\n            <div className=\"crv-edit-version\">Edit version: {editVersion}</div>\n            {assessment?.failedChecks.length > 0 && <div className=\"crv-failed-checks\">Failed: {assessment.failedChecks.join(\", \")}</div>}\n          </div>\n        </div>\n\n        <div className=\"crv-actions\">\n          {onCorrectSuggestions && <button onClick={onCorrectSuggestions} disabled={isGenerating || !hasIssues} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating || !hasIssues)}`} title={!hasIssues ? \"No issues to correct\" : \"Apply remediation suggestions\"}>\n              \u270e Correct Suggestions\n            </button>}\n          <button onClick={onRegenerate} disabled={isGenerating} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating)}`}>\n            \u27f3 Regenerate All\n          </button>\n          <button onClick={onAccept} disabled={isGenerating} className={`crv-btn crv-btn-primary ${report.overallScore >= 60 ? \"crv-btn-accept-ready\" : \"crv-btn-accept-warning\"} ${disabledClass(isGenerating)}`}>\n            {report.overallScore >= 60 ? \"Accept Chronicle \u2713\" : \"Accept with Issues \u26a0\"}\n          </button>\n        </div>\n      </div>\n\n      {isValidationStale && <div className=\"crv-stale-warning\">\n          <div className=\"crv-stale-text\">\n            Validation is stale after edits. Revalidate to refresh the report.\n          </div>\n          {onRevalidate && <button onClick={onRevalidate} disabled={isGenerating} className={`crv-btn crv-btn-small ${disabledClass(isGenerating)}`}>\n              Revalidate\n            </button>}\n        </div>}\n\n      <div className=\"crv-refinements\">\n        <div className=\"crv-refinements-title\">Optional Refinements</div>\n        <div className=\"crv-refinements-list\">\n          {/* Summary */}\n          <div className=\"crv-refinement-row\">\n            <div>\n              <div className=\"crv-refinement-name\">Add Summary</div>\n              <div className=\"crv-refinement-desc\">\n                Generate a short summary for chronicle listings.\n              </div>\n              {summaryState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(summaryState.generatedAt)}\n                  {summaryState.model ? ` - ${summaryState.model}` : \"\"}\n                </div>}\n              {summaryIndicator && summaryState.generatedAt && <div className=\"crv-refinement-status-tight\">{summaryIndicator}</div>}\n              {!summaryState.generatedAt && !summaryState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {summaryState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateSummary && <button onClick={onGenerateSummary} disabled={isGenerating || summaryState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || summaryState.running)}`}>\n                {summaryState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* 3. Image Refs - finds image placement opportunities in the narrative */}\n          <div className=\"crv-refinement-row\">\n            <div className=\"crv-refinement-content\">\n              <div className=\"crv-refinement-name\">Add Image Refs</div>\n              <div className=\"crv-refinement-desc\">\n                Generate image placement suggestions for this chronicle.\n              </div>\n              {imageRefsState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(imageRefsState.generatedAt)}\n                  {imageRefsState.model ? ` - ${imageRefsState.model}` : \"\"}\n                </div>}\n              {imageRefsIndicator && imageRefsState.generatedAt && <div className=\"crv-refinement-status-tight\">{imageRefsIndicator}</div>}\n              {!imageRefsState.generatedAt && !imageRefsState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {imageRefsState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateImageRefs && <button onClick={onGenerateImageRefs} disabled={isGenerating || imageRefsState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || imageRefsState.running)}`}>\n                {imageRefsState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* Show ChronicleImagePanel when imageRefs are available */}\n          {imageRefs && entityMap && <div className=\"crv-image-panel-wrap\">\n              <ChronicleImagePanel imageRefs={imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} chronicleText={chronicleText || undefined} isGenerating={isGenerating} styleLibrary={styleLibrary} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={chronicleTitle} />\n            </div>}\n        </div>\n      </div>\n\n      {/* Generation Context (expandable) */}\n      {seedData && <ExpandableSeedSection seed={seedData} defaultExpanded={false} />}\n\n      {/* Tabs */}\n      <div className=\"crv-tabs\">\n        {[\"summary\", \"checks\", \"issues\"].map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`crv-tab ${activeTab === tab ? \"crv-tab-active\" : \"\"}`}>\n            {tab}\n            {tab === \"issues\" && report.issues.length > 0 && <span className={`crv-tab-badge ${assessment?.criticalIssueCount > 0 ? \"crv-tab-badge-critical\" : \"crv-tab-badge-minor\"}`}>\n                {report.issues.length}\n              </span>}\n          </button>)}\n      </div>\n\n      {/* Tab content */}\n      {activeTab === \"summary\" && <div className=\"crv-panel\">\n          <h3 className=\"crv-panel-title\">Validation Summary</h3>\n\n          <div className=\"crv-summary-grid\">\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.plotStructure.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.plotStructure.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Structure</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.entityConsistency.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.entityConsistency.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Entity Consistency</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.resolution.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.resolution.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Resolution</div>\n            </div>\n          </div>\n\n          {report.checks.plotStructure.notes && <div className=\"crv-notes-section\">\n              <div className=\"crv-notes-label\">Structure Notes:</div>\n              <div className=\"crv-notes-text\">{report.checks.plotStructure.notes}</div>\n            </div>}\n\n          {report.checks.themeExpression.notes && <div>\n              <div className=\"crv-notes-label\">Theme Expression:</div>\n              <div className=\"crv-notes-text\">{report.checks.themeExpression.notes}</div>\n            </div>}\n        </div>}\n\n      {activeTab === \"checks\" && <div className=\"crv-checks-panel\">\n          <CheckItem label=\"Structure\" check={report.checks.plotStructure} />\n          <CheckItem label=\"Entity Consistency\" check={report.checks.entityConsistency} />\n          <CheckItem label=\"Resolution\" check={report.checks.resolution} />\n          <CheckItem label=\"Factual Accuracy\" check={report.checks.factualAccuracy} />\n          <CheckItem label=\"Theme Expression\" check={report.checks.themeExpression} />\n\n          <div className=\"crv-section-goals-header\">\n            Section Goals ({report.checks.sectionGoals.filter(sg => sg.pass).length}/\n            {report.checks.sectionGoals.length} passed)\n          </div>\n          {report.checks.sectionGoals.map(sg => <div key={sg.sectionId} className=\"crv-section-goal-row\">\n              <div className=\"crv-section-goal-check\">\n                <CheckItem label={resolveSectionLabel(sg.sectionId)} check={sg} isSection />\n              </div>\n              {!sg.pass && <span className=\"crv-section-goal-label\">Needs revision</span>}\n            </div>)}\n        </div>}\n\n      {activeTab === \"issues\" && <div>\n          {report.issues.length === 0 ? <div className=\"crv-no-issues\">\n              <div className=\"crv-no-issues-icon\">\ud83c\udf89</div>\n              <div className=\"crv-no-issues-text\">No issues found!</div>\n            </div> : <>\n              {/* Critical issues first */}\n              {report.issues.filter(i => i.severity === \"critical\").length > 0 && <div className=\"crv-issues-group\">\n                  <h4 className=\"crv-issues-heading crv-issues-heading-critical\">\n                    Critical Issues ({report.issues.filter(i => i.severity === \"critical\").length}\n                    )\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"critical\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n\n              {/* Minor issues */}\n              {report.issues.filter(i => i.severity === \"minor\").length > 0 && <div>\n                  <h4 className=\"crv-issues-heading crv-issues-heading-minor\">\n                    Minor Issues ({report.issues.filter(i => i.severity === \"minor\").length})\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"minor\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n            </>}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}", "type": "{ report: any; seedData?: any; onAccept: any; onRegenerate: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateImageRefs: any; onRevalidate: any; refinements: any; isValidationStale?: boolean; editVersion?: number; isGenerating?: boolean; imageRefs?: any; entityMap?: any; onGenerateChronicleImage?: any; onResetChronicleImage?: any; onUpdateChronicleAnchorText?: any; onUpdateChronicleImageSize?: any; onUpdateChronicleImageJustification?: any; chronicleText?: any; summaryIndicato...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleImagePanel", "specifiers": ["ChronicleImagePanel"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["ExpandableSeedSection"], "category": "external"}, {"source": "./CohesionReportViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ConfigPanel.jsx", "sourceCode": "export default function ConfigPanel({ config, onConfigChange }) {\n  const handleModelChange = (newModel) => {\n    onConfigChange({ imageModel: newModel });\n  };\n\n  return (\n    <div>\n      {/* LLM Call Configuration - per-call model and thinking settings */}\n      <LLMCallConfigPanel />\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Generation</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"model-openai\" className=\"illuminator-label\">Model (OpenAI)</label>\n          <select id=\"model-openai\"\n            value={config.imageModel}\n            onChange={(e) => handleModelChange(e.target.value)}\n            className=\"illuminator-select\"\n          >\n            {IMAGE_MODELS.map((model) => (\n              <option key={model.value} value={model.value}>\n                {model.label}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <p className=\"cfgp-hint\">\n          Size and quality settings are in the Image Settings panel (sidebar).\n        </p>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Multishot Prompting</h2>\n        </div>\n        <p className=\"cfgp-section-desc\">Improve image generation by chaining multiple AI calls.</p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"requireDescription\"\n            checked={config.requireDescription || false}\n            onChange={(e) => onConfigChange({ requireDescription: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"requireDescription\">Require description before image</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint\">\n          Enforces description generation before image generation. The description will be included\n          in the image prompt.\n        </p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"useClaudeForImagePrompt\"\n            checked={config.useClaudeForImagePrompt || false}\n            onChange={(e) => onConfigChange({ useClaudeForImagePrompt: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"useClaudeForImagePrompt\">Use Claude to format image prompt</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint-tight\">\n          Sends the image prompt through Claude first to optimize it for the image model.\n        </p>\n\n        {config.useClaudeForImagePrompt && (\n          <>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Global Image Rules\n              <LocalTextArea\n                value={config.globalImageRules || \"\"}\n                onChange={(value) => onConfigChange({ globalImageRules: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder=\"SPECIES RULE: This world contains only [species]. Any figures depicted must be explicitly described as [species], never as humans or generic figures.\"\n                rows={4}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Domain-specific rules injected into all image prompts. Use this to enforce species,\n                setting constraints, or other world-specific requirements.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Entity image prompt template\n              <LocalTextArea\n                value={config.claudeImagePromptTemplate || DEFAULT_IMAGE_PROMPT_TEMPLATE}\n                onChange={(value) => onConfigChange({ claudeImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for entity portrait images. Use {\"{{modelName}}\"} for the image model name,{\" \"}\n                {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the global\n                rules above.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Chronicle image prompt template\n              <LocalTextArea\n                value={\n                  config.claudeChronicleImagePromptTemplate ||\n                  DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE\n                }\n                onChange={(value) => onConfigChange({ claudeChronicleImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for chronicle cover and scene images. Use {\"{{modelName}}\"} for the image model\n                name, {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the\n                global rules above.\n              </p>\n            </div>\n          </>\n        )}\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Performance</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <span className=\"illuminator-label\">Parallel workers</span>\n          <div className=\"cfgp-workers-row\">\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"8\"\n              value={config.numWorkers || 4}\n              onChange={(e) => onConfigChange({ numWorkers: parseInt(e.target.value, 10) })}\n              className=\"cfgp-range-input\"\n            />\n            <span className=\"cfgp-worker-count\">{config.numWorkers || 4}</span>\n          </div>\n          <p className=\"cfgp-hint\">\n            Number of concurrent API calls. Higher = faster but may hit rate limits.\n          </p>\n        </div>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">About</h2>\n        </div>\n        <p className=\"cfgp-about-text\">\n          Illuminator enriches your world simulation with LLM-generated content. Use the{\" \"}\n          <strong>Entities</strong> tab to generate descriptions and images for entities. Use the{\" \"}\n          <strong>Chronicle</strong> tab to generate multi-entity narratives and in-world documents.\n        </p>\n        <p className=\"cfgp-about-text-spaced\">\n          All enrichments are saved automatically to your current world slot.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onConfigChange }", "type": "{ config: any; onConfigChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./LLMCallConfigPanel", "specifiers": ["LLMCallConfigPanel"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["LocalTextArea"], "category": "external"}, {"source": "../lib/imageSettings", "specifiers": ["IMAGE_MODELS"], "category": "internal"}, {"source": "./ConfigPanel.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function CorpusFindReplace() {\n  const navEntities = useEntityNavList();\n  const chronicleNavItems = useChronicleStore((s) => s.navItems);\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [find, setFind] = useState(\"\");\n  const [replace, setReplace] = useState(\"\");\n  const [caseSensitive, setCaseSensitive] = useState(true);\n  const [contexts, setContexts] = useState<Set<SearchContext>>(\n    new Set([\n      \"chronicleContent\",\n      \"chronicleTitles\",\n      \"chronicleAnnotations\",\n      \"entityAnnotations\",\n      \"eraNarrativeContent\",\n    ])\n  );\n  const [llmMode, setLlmMode] = useState(false);\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [matches, setMatches] = useState<CorpusMatch[]>([]);\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const [scanProgress, setScanProgress] = useState(\"\");\n\n  // LLM mode state\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const dispatchTimeRef = useRef<number>(0);\n  const expectedBatchCountRef = useRef<number>(0);\n  const matchesRef = useRef<CorpusMatch[]>([]);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) inputRef.current.focus();\n  }, [phase]);\n\n  useEffect(() => {\n    matchesRef.current = matches;\n  }, [matches]);\n\n  const hasAnnotationContext =\n    contexts.has(\"chronicleAnnotations\") || contexts.has(\"entityAnnotations\");\n\n  const toggleContext = useCallback((ctx: SearchContext) => {\n    setContexts((prev) => {\n      const next = new Set(prev);\n      if (next.has(ctx)) next.delete(ctx);\n      else next.add(ctx);\n      return next;\n    });\n  }, []);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    if (!find || contexts.size === 0) return;\n    setPhase(\"scanning\");\n    setError(null);\n    const allMatches: CorpusMatch[] = [];\n\n    // 1. Chronicle content\n    if (contexts.has(\"chronicleContent\")) {\n      const completeIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.status === \"complete\")\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < completeIds.length; i++) {\n        setScanProgress(`Chronicle content ${i + 1}/${completeIds.length}`);\n        const record = await getChronicle(completeIds[i]);\n        if (!record) continue;\n        const name = record.title || chronicleNavItems[completeIds[i]]?.name || \"Untitled\";\n\n        if (record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.finalContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"final\",\n              \"Published\",\n              undefined,\n              undefined\n            )\n          );\n        }\n        if (record.assembledContent && record.assembledContent !== record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.assembledContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"assembled\",\n              \"Current Draft\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    // 2. Chronicle titles\n    if (contexts.has(\"chronicleTitles\")) {\n      const allIds = Object.values(chronicleNavItems).map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < allIds.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Chronicle titles ${i + 1}/${allIds.length}`);\n        const record = await getChronicle(allIds[i]);\n        if (!record?.title) continue;\n        allMatches.push(\n          ...scanText(\n            record.title,\n            find,\n            caseSensitive,\n            record.title,\n            \"chronicleTitles\",\n            allIds[i],\n            \"title\",\n            \"Title\",\n            undefined,\n            undefined\n          )\n        );\n      }\n    }\n\n    // 3. Chronicle annotations\n    if (contexts.has(\"chronicleAnnotations\")) {\n      const annotatedIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.historianNoteCount > 0)\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < annotatedIds.length; i++) {\n        setScanProgress(`Chronicle annotations ${i + 1}/${annotatedIds.length}`);\n        const record = await getChronicle(annotatedIds[i]);\n        if (!record?.historianNotes) continue;\n        const name = record.title || chronicleNavItems[annotatedIds[i]]?.name || \"Untitled\";\n\n        for (const note of record.historianNotes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleAnnotations\",\n              annotatedIds[i],\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          // Also scan anchor phrases\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                name + \" (anchor)\",\n                \"chronicleAnnotations\",\n                annotatedIds[i],\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 4. Entity annotations\n    if (contexts.has(\"entityAnnotations\")) {\n      const annotatedNavs = navEntities.filter((n) => n.hasHistorianNotes);\n      setScanProgress(`Entity annotations: loading ${annotatedNavs.length} entities`);\n\n      const fullEntities = await useEntityStore\n        .getState()\n        .loadEntities(annotatedNavs.map((n) => n.id));\n\n      for (let i = 0; i < fullEntities.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Entity annotations ${i + 1}/${fullEntities.length}`);\n        const entity = fullEntities[i];\n        const notes = entity.enrichment?.historianNotes;\n        if (!notes) continue;\n\n        for (const note of notes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              entity.name,\n              \"entityAnnotations\",\n              entity.id,\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                entity.name + \" (anchor)\",\n                \"entityAnnotations\",\n                entity.id,\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 5. Era narrative content\n    if (contexts.has(\"eraNarrativeContent\")) {\n      const simRunId = useChronicleStore.getState().simulationRunId;\n      if (simRunId) {\n        const allNarratives = await getEraNarrativesForSimulation(simRunId);\n        const completedNarratives = allNarratives.filter(\n          (n) => n.status === \"complete\" || n.status === \"step_complete\"\n        );\n\n        for (let i = 0; i < completedNarratives.length; i++) {\n          setScanProgress(`Era narratives ${i + 1}/${completedNarratives.length}`);\n          const record = completedNarratives[i];\n          const { content } = resolveActiveContent(record);\n          if (!content) continue;\n          allMatches.push(\n            ...scanText(\n              content,\n              find,\n              caseSensitive,\n              record.eraName,\n              \"eraNarrativeContent\",\n              record.narrativeId,\n              \"activeContent\",\n              \"Active Version\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    setScanProgress(\"\");\n    setMatches(allMatches);\n\n    const initial: Record<string, boolean> = {};\n    for (const m of allMatches) initial[m.id] = true;\n    setDecisions(initial);\n\n    // Expand first group per context\n    const firstKeys = new Set<string>();\n    const seen = new Set<SearchContext>();\n    for (const m of allMatches) {\n      if (!seen.has(m.context)) {\n        firstKeys.add(`${m.context}:${m.sourceId}`);\n        seen.add(m.context);\n      }\n    }\n    setExpandedGroups(firstKeys);\n\n    setPhase(allMatches.length > 0 ? \"preview\" : \"empty\");\n  }, [find, caseSensitive, contexts, chronicleNavItems, navEntities]);\n\n  // --- Generate LLM Variants ---\n  const handleGenerate = useCallback(() => {\n    setPhase(\"generating\");\n    setError(null);\n\n    // Only annotation matches go through LLM\n    const annotationMatches = matches.filter(\n      (m) => m.context === \"chronicleAnnotations\" || m.context === \"entityAnnotations\"\n    );\n\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "./CorpusFindReplace.css", "specifiers": [], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChronicle", "putChronicle", "updateChronicleHistorianNotes"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["setHistorianNotes"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../hooks/useEntityCrud", "specifiers": ["reloadEntities"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isNoteActive"], "category": "internal"}, {"source": "../workers/tasks/motifVariationTask", "specifiers": ["MotifVariationPayload", "MotifVariationResult"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["getEraNarrativesForSimulation", "getEraNarrative", "updateEraNarrative", "resolveActiveContent"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/CostsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CostsPanel.jsx", "sourceCode": "export default function CostsPanel({ queue, projectId, simulationRunId }) {\n  // Cost data from IndexedDB\n  const [simulationCosts, setSimulationCosts] = useState(null);\n  const [projectCosts, setProjectCosts] = useState(null);\n  const [allTimeCosts, setAllTimeCosts] = useState(null);\n  const [refreshTrigger, setRefreshTrigger] = useState(0);\n\n  // Track running tasks to know when to refresh\n  const runningTaskCount = useMemo(() => {\n    return queue.filter((item) => item.status === \"queued\" || item.status === \"running\").length;\n  }, [queue]);\n\n  // Fetch costs from IndexedDB\n  const fetchCosts = useCallback(async () => {\n    try {\n      // All-time costs\n      const allRecords = await getAllCosts();\n      setAllTimeCosts(summarizeCosts(allRecords));\n\n      // Project costs\n      if (projectId) {\n        const projectRecords = await getCostsForProject(projectId);\n        setProjectCosts(summarizeCosts(projectRecords));\n      } else {\n        setProjectCosts(null);\n      }\n\n      // Simulation costs\n      if (simulationRunId) {\n        const simRecords = await getCostsForSimulation(simulationRunId);\n        setSimulationCosts(summarizeCosts(simRecords));\n      } else {\n        setSimulationCosts(null);\n      }\n    } catch (err) {\n      console.error(\"[CostsPanel] Failed to fetch costs:\", err);\n    }\n  }, [projectId, simulationRunId]);\n\n  // Fetch on mount and when dependencies change\n  useEffect(() => {\n    fetchCosts();\n  }, [fetchCosts, refreshTrigger]);\n\n  // Refresh when queue changes (tasks complete)\n  useEffect(() => {\n    // Only refresh when queue length decreases (task completed)\n    const timer = setTimeout(() => {\n      setRefreshTrigger((prev) => prev + 1);\n    }, 500);\n    return () => clearTimeout(timer);\n  }, [queue.length, runningTaskCount]);\n\n  // Calculate pending queue costs (estimated)\n  const queueCosts = useMemo(() => {\n    let textEstimated = 0;\n    let imageEstimated = 0;\n    let chronicleEstimated = 0;\n\n    for (const item of queue) {\n      if (item.status === \"complete\") continue;\n      if (item.estimatedCost) {\n        if (item.type === \"image\") {\n          imageEstimated += item.estimatedCost;\n        } else if (item.type === \"entityChronicle\") {\n          chronicleEstimated += item.estimatedCost;\n        } else {\n          textEstimated += item.estimatedCost;\n        }\n      } else if (item.type === \"entityChronicle\" && item.status !== \"complete\") {\n        // Estimate chronicle cost if not available (~$0.05-0.15 per chronicle depending on length)\n        chronicleEstimated += 0.08;\n      }\n    }\n\n    return {\n      textEstimated,\n      imageEstimated,\n      chronicleEstimated,\n      total: textEstimated + imageEstimated + chronicleEstimated,\n    };\n  }, [queue]);\n\n  // Categorize costs for display\n  const simCategorized = simulationCosts ? categorizeCosts(simulationCosts) : null;\n  const projCategorized = projectCosts ? categorizeCosts(projectCosts) : null;\n  const allCategorized = allTimeCosts ? categorizeCosts(allTimeCosts) : null;\n\n  const handleClearHistory = async () => {\n    if (confirm(\"Clear all cost history? This cannot be undone.\")) {\n      await clearAllCosts();\n      setRefreshTrigger((prev) => prev + 1);\n    }\n  };\n\n  return (\n    <div>\n      {/* Current Simulation */}\n      {simCategorized && (\n        <CostCard title=\"Current Simulation\">\n          <div className=\"cpanel-section-hint\">Costs from this simulation run.</div>\n          <CostRow label=\"Text generations\" value={simCategorized.text.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.text.count} requests`}\n            value={simCategorized.text.actual}\n          />\n          <CostRow label=\"Image generations\" value={simCategorized.image.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.image.count} images`}\n            value={simCategorized.image.actual}\n          />\n          <CostRow label=\"Chronicle generations\" value={simCategorized.chronicle.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.chronicle.count} steps`}\n            value={simCategorized.chronicle.actual}\n          />\n          <CostRow label=\"Dynamics generation\" value={simCategorized.dynamics.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.dynamics.count} turns`}\n            value={simCategorized.dynamics.actual}\n          />\n          <CostRow label=\"Summary revision\" value={simCategorized.revision.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.revision.count} batches`}\n            value={simCategorized.revision.actual}\n          />\n          <CostRow label=\"Simulation Total\" value={simulationCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* Pending Queue */}\n      {queueCosts.total > 0 && (\n        <CostCard title=\"Pending Queue (Estimated)\">\n          <div className=\"cpanel-section-hint\">\n            Estimated costs for queued tasks not yet completed.\n          </div>\n          <CostRow label=\"Text generations\" value={queueCosts.textEstimated} isEstimated />\n          <CostRow label=\"Image generations\" value={queueCosts.imageEstimated} isEstimated />\n          <CostRow\n            label=\"Chronicle generations\"\n            value={queueCosts.chronicleEstimated}\n            isEstimated\n          />\n          <CostRow label=\"Queue Total\" value={queueCosts.total} isTotal isEstimated />\n        </CostCard>\n      )}\n\n      {/* By Model */}\n      {simulationCosts && Object.keys(simulationCosts.byModel).length > 0 && (\n        <CostCard title=\"By Model (Simulation)\">\n          <div className=\"cpanel-section-hint\">Cost breakdown by model used.</div>\n          {Object.entries(simulationCosts.byModel)\n            .sort((a, b) => b[1].actual - a[1].actual)\n            .map(([model, data]) => (\n              <CostRow key={model} label={model} value={data.actual} />\n            ))}\n        </CostCard>\n      )}\n\n      {/* Project Total */}\n      {projCategorized && (\n        <CostCard title=\"Project Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs for this project across all simulations.\n          </div>\n          <CostRow label=\"Text generations\" value={projCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={projCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={projCategorized.chronicle.actual} />\n          <CostRow label=\"Project Total\" value={projectCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* All Time */}\n      {allCategorized && (\n        <CostCard title=\"All Time Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs across all projects and sessions.\n          </div>\n          <CostRow label=\"Text generations\" value={allCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={allCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={allCategorized.chronicle.actual} />\n          <CostRow label=\"All Time Total\" value={allTimeCosts.totalActual} isTotal />\n          <CostRow\n            label={`  \\u2514 ${allTimeCosts.count} total records`}\n            value={allTimeCosts.totalActual}\n          />\n\n          <button\n            onClick={() => void handleClearHistory()}\n            className=\"illuminator-button-link cpanel-clear-button\"\n          >\n            Clear History\n          </button>\n        </CostCard>\n      )}\n\n      {/* Empty state */}\n      {!simulationCosts && !allTimeCosts && queueCosts.total === 0 && (\n        <CostCard title=\"Cost Tracking\">\n          <div className=\"cpanel-empty-hint\">\n            No costs recorded yet. Costs will appear here as you generate content.\n          </div>\n        </CostCard>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ queue, projectId, simulationRunId }", "type": "{ queue: any; projectId: any; simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useEffect", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/costEstimation", "specifiers": ["formatCost"], "category": "internal"}, {"source": "../lib/db/costRepository", "specifiers": ["getCostsForSimulation", "getCostsForProject", "getAllCosts", "summarizeCosts", "clearAllCosts"], "category": "internal"}, {"source": "./CostsPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/CoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CoveragePanel.jsx", "sourceCode": "export default function CoveragePanel({\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}) {\n  const [chronicles, setChronicles] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [expanded, setExpanded] = useState(true);\n  const [disabledChronicles, setDisabledChronicles] = useState(() => {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (!raw) return {};\n      const parsed = JSON.parse(raw);\n      if (parsed && typeof parsed === \"object\") return parsed;\n    } catch {}\n    return {};\n  });\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(disabledChronicles));\n    } catch {}\n  }, [disabledChronicles]);\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    setLoading(true);\n    getChroniclesForSimulation(simulationRunId).then(records => {\n      if (!cancelled) setChronicles(records);\n    }).catch(err => {\n      console.error(\"[Coverage] Failed to load chronicles:\", err);\n      if (!cancelled) setChronicles([]);\n    }).finally(() => {\n      if (!cancelled) setLoading(false);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const toggleChronicle = useCallback(chronicleId => {\n    setDisabledChronicles(prev => ({\n      ...prev,\n      [chronicleId]: !prev[chronicleId]\n    }));\n  }, []);\n  const toggleFact = useCallback(factId => {\n    if (!onWorldContextChange) return;\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const updated = rawFacts.map(f => f.id === factId ? {\n      ...f,\n      disabled: !f.disabled,\n      required: !f.disabled ? false : f.required\n    } : f);\n    onWorldContextChange({\n      canonFactsWithMetadata: updated\n    });\n  }, [onWorldContextChange, worldContext?.canonFactsWithMetadata]);\n  const analysis = useMemo(() => {\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const normalizedWorldFacts = rawFacts.map((fact, index) => normalizeFact(fact, index)).filter(Boolean);\n    const chronicleList = [...(chronicles || [])].sort(sortChronicles);\n    const facts = normalizedWorldFacts.filter(fact => fact.type !== \"generation_constraint\");\n    const enabledFacts = facts.filter(fact => !fact.disabled);\n    const allFactIdSet = new Set(facts.map(fact => fact.id));\n    const rows = chronicleList.map(chronicle => {\n      const synthesis = chronicle.perspectiveSynthesis || null;\n      const facetIds = new Set();\n      let unparsedCount = 0;\n      for (const facet of synthesis?.facets || []) {\n        if (!facet?.factId) continue;\n        if (allFactIdSet.has(facet.factId)) {\n          facetIds.add(facet.factId);\n        } else {\n          unparsedCount += 1;\n        }\n      }\n      return {\n        chronicle,\n        synthesis,\n        facetIds,\n        unparsedCount,\n        isIncluded: !disabledChronicles[chronicle.chronicleId]\n      };\n    });\n    const factTotals = new Map(facts.map(fact => [fact.id, 0]));\n    const disabledFactIds = new Set(facts.filter(f => f.disabled).map(f => f.id));\n    let totalSelections = 0;\n    let unparsedTotal = 0;\n    let includedCount = 0;\n    const processedRows = rows.map(row => {\n      if (row.isIncluded) {\n        includedCount += 1;\n        for (const factId of row.facetIds) {\n          factTotals.set(factId, (factTotals.get(factId) || 0) + 1);\n        }\n        let enabledHits = 0;\n        for (const factId of row.facetIds) {\n          if (!disabledFactIds.has(factId)) enabledHits += 1;\n        }\n        totalSelections += enabledHits;\n        unparsedTotal += row.unparsedCount || 0;\n      }\n      let rowEnabledTotal = 0;\n      for (const factId of row.facetIds) {\n        if (!disabledFactIds.has(factId)) rowEnabledTotal += 1;\n      }\n      return {\n        ...row,\n        rowTotal: rowEnabledTotal\n      };\n    });\n    const chroniclesWithSynthesis = processedRows.filter(row => row.synthesis).length;\n    const unusedFacts = enabledFacts.filter(fact => (factTotals.get(fact.id) || 0) === 0).length;\n    const disabledFactCount = facts.filter(fact => fact.disabled).length;\n    const constraintCount = normalizedWorldFacts.filter(fact => fact.type === \"generation_constraint\").length;\n    return {\n      facts,\n      factTotals,\n      rows: processedRows,\n      totalSelections,\n      unparsedTotal,\n      includedCount,\n      chroniclesWithSynthesis,\n      chronicleCount: processedRows.length,\n      unusedFacts,\n      disabledFactCount,\n      constraintCount\n    };\n  }, [chronicles, worldContext, disabledChronicles]);\n  const {\n    facts,\n    factTotals,\n    rows,\n    totalSelections,\n    unparsedTotal,\n    includedCount,\n    chroniclesWithSynthesis,\n    chronicleCount,\n    unusedFacts,\n    disabledFactCount,\n    constraintCount\n  } = analysis;\n\n  // Fact coverage analysis stats (from LLM ratings)\n  const coverageStats = useMemo(() => {\n    const chroniclesWithReport = chronicles.filter(c => c.factCoverageReport?.entries?.length);\n    if (!chroniclesWithReport.length || !facts.length) return null;\n\n    // Per-fact aggregation: count how many chronicles rated each fact at each level\n    const perFact = new Map();\n    for (const fact of facts) {\n      perFact.set(fact.id, {\n        integral: 0,\n        prevalent: 0,\n        mentioned: 0,\n        missing: 0,\n        total: 0\n      });\n    }\n    for (const chronicle of chroniclesWithReport) {\n      for (const entry of chronicle.factCoverageReport.entries) {\n        const agg = perFact.get(entry.factId);\n        if (agg && entry.rating) {\n          if (agg[entry.rating] !== undefined) agg[entry.rating]++;\n          agg.total++;\n        }\n      }\n    }\n\n    // Global totals\n    let totalEntries = 0;\n    const globalCounts = {\n      integral: 0,\n      prevalent: 0,\n      mentioned: 0,\n      missing: 0\n    };\n    for (const [, agg] of perFact) {\n      for (const r of [\"integral\", \"prevalent\", \"mentioned\", \"missing\"]) {\n        globalCounts[r] += agg[r];\n      }\n      totalEntries += agg.total;\n    }\n    return {\n      chroniclesAnalyzed: chroniclesWithReport.length,\n      totalEntries,\n      globalCounts,\n      perFact\n    };\n  }, [chronicles, facts]);\n  const disableAll = useCallback(() => {\n    const next = {};\n    for (const row of rows) {\n      next[row.chronicle.chronicleId] = true;\n    }\n    setDisabledChronicles(next);\n  }, [rows]);\n  const enableAll = useCallback(() => {\n    setDisabledChronicles({});\n  }, []);\n  if (!simulationRunId) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">No active simulation run.</div>\n      </div>;\n  }\n  if (loading && chronicleCount === 0) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">Loading chronicles...</div>\n      </div>;\n  }\n  if (!facts.length) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n          <span className=\"illuminator-card-subtitle\">Perspective synthesis fact coverage</span>\n        </div>\n        <div className=\"cvp-empty-msg\">\n          No canon facts configured. Add facts in the Context tab to enable coverage tracking.\n        </div>\n      </div>;\n  }\n  return <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header cvp-header-clickable\" onClick={() => setExpanded(prev => !prev)} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        <span className=\"cvp-expand-icon\">{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <h2 className=\"illuminator-card-title\">Lore Coverage</h2>\n        {!expanded && <span className=\"illuminator-card-subtitle cvp-collapsed-subtitle\">\n            {chronicleCount} chronicles, {facts.length - disabledFactCount} facts\n            {unusedFacts > 0 ? `, ${unusedFacts} unused` : \"\"}\n          </span>}\n      </div>\n\n      {expanded && <>\n          <div className=\"illuminator-coverage-summary\">\n            <div>\n              <strong>Chronicles</strong>: {chronicleCount} total, {includedCount} counted,{\" \"}\n              {chroniclesWithSynthesis} with synthesis\n            </div>\n            <div>\n              <strong>Facts</strong>: {facts.length - disabledFactCount} active ({unusedFacts}{\" \"}\n              unused){disabledFactCount > 0 && `, ${disabledFactCount} disabled`}\n            </div>\n            <div>\n              <strong>Total selections</strong>: {totalSelections}\n            </div>\n            <div>\n              <strong>Unparsed facets</strong>: {unparsedTotal}\n            </div>\n            {constraintCount > 0 && <div>\n                <strong>Constraints excluded</strong>: {constraintCount}\n              </div>}\n            <div className=\"cvp-summary-controls\">\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={enableAll}>\n                Count all\n              </button>\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={disableAll}>\n                Count none\n              </button>\n            </div>\n          </div>\n\n          <div className=\"illuminator-coverage-table\">\n            <table>\n              <thead>\n                <tr>\n                  <th className=\"illuminator-coverage-sticky\">Chronicle</th>\n                  <th className=\"illuminator-coverage-toggle-col\">Counted</th>\n                  {facts.map(fact => {\n                const factText = fact.text ? `: ${fact.text}` : \"\";\n                const requiredLabel = fact.required ? \" (required)\" : \"\";\n                const disabledLabel = fact.disabled ? \" (disabled \\u2014 click to enable)\" : \" (click to disable)\";\n                const factTitle = `${fact.id}${factText}${requiredLabel}${disabledLabel}`;\n                return <th key={fact.id} title={factTitle} onClick={onWorldContextChange ? () => toggleFact(fact.id) : undefined} className={onWorldContextChange ? \"cvp-fact-header-clickable\" : undefined}>\n                      <div className={`illuminator-coverage-fact-header ${fact.disabled ? \"cvp-fact-header-disabled\" : \"\"}`}>\n                        <span className=\"illuminator-coverage-fact-id\">{fact.id}</span>\n                        {fact.required && <span className=\"illuminator-coverage-required\">R</span>}\n                        {fact.disabled && <span className=\"cvp-fact-disabled-label\">off</span>}\n                      </div>\n                    </th>;\n              })}\n                  <th className=\"illuminator-coverage-unparsed-col\">Unparsed</th>\n                  <th className=\"illuminator-coverage-total-col\">Total</th>\n                </tr>\n              </thead>\n              <tbody>\n                <tr className=\"illuminator-coverage-total-row\">\n                  <td className=\"illuminator-coverage-sticky\">Total usage</td>\n                  <td className=\"illuminator-coverage-toggle-col\">{includedCount}</td>\n                  {facts.map(fact => <td key={`total-${fact.id}`} className={fact.disabled ? \"cvp-cell-disabled\" : undefined}>\n                      {factTotals.get(fact.id) || 0}\n                    </td>)}\n                  <td className=\"illuminator-coverage-unparsed-col\">{unparsedTotal}</td>\n                  <td className=\"illuminator-coverage-total-col\">{totalSelections}</td>\n                </tr>\n// ... (truncated)", "parameters": [{"name": "{\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}", "type": "{ worldContext: any; simulationRunId: any; onWorldContextChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useEffect", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChroniclesForSimulation"], "category": "internal"}, {"source": "./CoveragePanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/CreateEntityModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CreateEntityModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Component\n// ---------------------------------------------------------------------------\n\nexport default function CreateEntityModal({\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}: Readonly<CreateEntityModalProps>) {\n  const isEdit = Boolean(editEntity);\n  const entityKinds = useMemo(\n    () => (worldSchema.entityKinds || []).filter((k) => !k.isFramework),\n    [worldSchema.entityKinds]\n  );\n  const cultures = worldSchema.cultures || [];\n  const d = isEdit ? undefined : defaults; // ignore defaults in edit mode\n\n  // Form state \u2014 initialized from editEntity (edit mode) or defaults (create mode)\n  const [kind, setKind] = useState(() => editEntity?.kind || d?.kind || entityKinds[0]?.kind || \"\");\n  const [name] = useState(() => editEntity?.name || \"\");\n  const [nameInput, setNameInput] = useState(() => editEntity?.name || d?.name || \"\");\n  const [culture, setCulture] = useState(\n    () => editEntity?.culture || d?.culture || cultures[0]?.id || \"\"\n  );\n  const [prominence, setProminence] = useState(() => editEntity?.prominence ?? 1);\n  const [description, setDescription] = useState(() => editEntity?.description || \"\");\n  const [eraId, setEraId] = useState(() => editEntity?.eraId || d?.eraId || \"\");\n  const [startTick, setStartTick] = useState(() => {\n    if (editEntity?.temporal?.startTick != null) return String(editEntity.temporal.startTick);\n    if (d?.startTick != null) return String(d.startTick);\n    return \"\";\n  });\n  const [endTick, setEndTick] = useState(() => {\n    if (editEntity?.temporal?.endTick != null) return String(editEntity.temporal.endTick);\n    if (d?.endTick != null) return String(d.endTick);\n    return \"\";\n  });\n  const [tags, setTags] = useState<Record<string, string>>(() =>\n    tagsToStringRecord(editEntity?.tags)\n  );\n  const [tagKey, setTagKey] = useState(\"\");\n  const [tagValue, setTagValue] = useState(\"\");\n\n  // Derived from selected kind\n  const kindDef = useMemo(() => entityKinds.find((k) => k.kind === kind), [entityKinds, kind]);\n  const subtypes = kindDef?.subtypes || [];\n  const statuses = kindDef?.statuses || [];\n  const defaultStatus = kindDef?.defaultStatus || statuses[0]?.id || \"active\";\n\n  const [subtype, setSubtype] = useState(\n    () => editEntity?.subtype || d?.subtype || subtypes[0]?.id || \"\"\n  );\n  const [status, setStatus] = useState(() => editEntity?.status || defaultStatus);\n\n  // Cascade subtype and status when kind changes (only in create mode or explicit change)\n  const handleKindChange = useCallback(\n    (newKind: string) => {\n      setKind(newKind);\n      const def = entityKinds.find((k) => k.kind === newKind);\n      setSubtype(def?.subtypes[0]?.id || \"\");\n      setStatus(def?.defaultStatus || def?.statuses[0]?.id || \"active\");\n    },\n    [entityKinds]\n  );\n\n  // Tag management\n  const addTag = useCallback(() => {\n    const k = tagKey.trim();\n    if (!k) return;\n    setTags((prev) => ({ ...prev, [k]: tagValue }));\n    setTagKey(\"\");\n    setTagValue(\"\");\n  }, [tagKey, tagValue]);\n\n  const removeTag = useCallback((key: string) => {\n    setTags((prev) => {\n      const next = { ...prev };\n      delete next[key];\n      return next;\n    });\n  }, []);\n\n  // Submit\n  const effectiveName = isEdit ? name : nameInput;\n  const canSubmit = effectiveName.trim().length > 0 && kind;\n\n  const handleSubmit = useCallback(() => {\n    if (!canSubmit) return;\n    const entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\"> = {\n      kind,\n      subtype,\n      name: effectiveName.trim(),\n      culture,\n      status,\n      prominence,\n      description,\n      tags,\n      coordinates: editEntity?.coordinates || { x: 0, y: 0, z: 0 },\n    };\n    if (eraId) entity.eraId = eraId;\n    const parsedStart = Number(startTick);\n    const parsedEnd = endTick ? Number(endTick) : null;\n    if (Number.isFinite(parsedStart)) {\n      entity.temporal = { startTick: parsedStart, endTick: parsedEnd };\n    }\n    onSubmit(entity);\n  }, [\n    canSubmit,\n    kind,\n    subtype,\n    effectiveName,\n    culture,\n    status,\n    prominence,\n    description,\n    tags,\n    eraId,\n    startTick,\n    endTick,\n    editEntity,\n    onSubmit,\n  ]);\n\n  const title = isEdit ? \"Edit Entity\" : \"Create Entity\";\n  const submitLabel = isEdit ? \"Save Changes\" : \"Create Entity\";\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"cem-backdrop\">\n        <div className=\"cem-card\">\n          <div className=\"cem-header\">\n            <h2 className=\"cem-title\">{title}</h2>\n          </div>\n          <div className=\"cem-empty-body\">\n            No entity kinds available in the schema.\n          </div>\n          <div className=\"cem-footer\">\n            <button onClick={onClose} className=\"illuminator-button illuminator-button-secondary\">\n              Close\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"cem-backdrop\">\n      <div className=\"cem-card\">\n        {/* Header */}\n        <div className=\"cem-header\">\n          <h2 className=\"cem-title\">{title}</h2>\n          {isEdit && (\n            <p className=\"cem-edit-subtitle\">\n              {name}\n            </p>\n          )}\n        </div>\n\n        {/* Body */}\n        <div className=\"cem-body\">\n          {/* Kind + Subtype row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"kind\" className=\"cem-label\">Kind</label>\n              <select id=\"kind\"\n                value={kind}\n                onChange={(e) => handleKindChange(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {entityKinds.map((k) => (\n                  <option key={k.kind} value={k.kind}>\n                    {k.description || k.kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"subtype\" className=\"cem-label\">Subtype</label>\n              <select id=\"subtype\"\n                value={subtype}\n                onChange={(e) => setSubtype(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n                disabled={subtypes.length === 0}\n              >\n                {subtypes.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n                {subtypes.length === 0 && <option value=\"\">None</option>}\n              </select>\n            </div>\n          </div>\n\n          {/* Name \u2014 only editable in create mode */}\n          {!isEdit && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"name\" className=\"cem-label\">Name *</label>\n              <input id=\"name\"\n                type=\"text\"\n                value={nameInput}\n                onChange={(e) => setNameInput(e.target.value)}\n                placeholder=\"Entity name\"\n                className=\"illuminator-select cem-full-width-box\"\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n\n          {/* Culture + Status row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"culture\" className=\"cem-label\">Culture</label>\n              <select id=\"culture\"\n                value={culture}\n                onChange={(e) => setCulture(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {cultures.map((c) => (\n                  <option key={c.id} value={c.id}>\n                    {c.name || c.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"status\" className=\"cem-label\">Status</label>\n              <select id=\"status\"\n                value={status}\n                onChange={(e) => setStatus(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {statuses.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          </div>\n\n          {/* Prominence */}\n          <div className=\"cem-field-group\">\n            <label htmlFor=\"prominence\" className=\"cem-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={prominence}\n              onChange={(e) => setProminence(Number(e.target.value))}\n              className=\"illuminator-select cem-full-width\"\n            >\n              {PROMINENCE_OPTIONS.map((opt) => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.label}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          {/* Era */}\n          {eras.length > 0 && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"era\" className=\"cem-label\">Era</label>\n              <select id=\"era\"\n                value={eraId}\n                onChange={(e) => setEraId(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                <option value=\"\">None</option>\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name || era.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          )}\n\n          {/* Temporal */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"start-tick\" className=\"cem-label\">Start Tick</label>\n              <input id=\"start-tick\"\n                type=\"number\"\n                value={startTick}\n                onChange={(e) => setStartTick(e.target.value)}\n                placeholder=\"Optional\"\n                className=\"illuminator-select cem-full-width-box\"\n              />\n            </div>\n            <div>\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}", "type": "Readonly<CreateEntityModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["WorldEntity", "EntityKindDefinition", "CultureDefinition"], "category": "external"}, {"source": "./CreateEntityModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx", "sourceCode": "// ============================================================================\n// Modal\n// ============================================================================\n\nexport default function DescriptionMotifWeaver({ onClose }: Readonly<{ onClose: () => void }>) {\n  const navEntities = useEntityNavList();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [phase, setPhase] = useState<Phase>(\"scan\");\n  const [candidates, setCandidates] = useState<WeaveCandidate[]>([]);\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n\n  const dispatchTimeRef = useRef<number>(0);\n  const candidatesRef = useRef<WeaveCandidate[]>([]);\n\n  useEffect(() => {\n    candidatesRef.current = candidates;\n  }, [candidates]);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    setPhase(\"scanning\");\n    setError(null);\n\n    // Load all entities with descriptions\n    const allNavs = navEntities.filter((n) => n.kind !== \"era\" && n.kind !== \"occurrence\");\n    if (allNavs.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    const fullEntities = await useEntityStore.getState().loadEntities(allNavs.map((n) => n.id));\n\n    let globalIndex = 0;\n    const allCandidates: WeaveCandidate[] = [];\n\n    for (const entity of fullEntities) {\n      if (!entity.description) continue;\n      const entityCandidates = scanDescriptionForConcepts(\n        entity.id,\n        entity.name,\n        entity.description,\n        globalIndex\n      );\n      allCandidates.push(...entityCandidates);\n      globalIndex += entityCandidates.length;\n    }\n\n    if (allCandidates.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    setCandidates(allCandidates);\n    // Default: reject all (light touch \u2014 user opts in)\n    const initial: Record<string, boolean> = {};\n    for (const c of allCandidates) initial[c.id] = false;\n    setDecisions(initial);\n    if (allCandidates.length > 0) {\n      setExpandedGroups(new Set([allCandidates[0].entityId]));\n    }\n\n    // Stop for confirmation before LLM calls\n    setPhase(\"confirm\");\n  }, [navEntities]);\n\n  // --- Generate ---\n  const handleGenerate = useCallback((scanCandidates: WeaveCandidate[]) => {\n    setPhase(\"generating\");\n\n    const batches: WeaveCandidate[][] = [];\n    for (let i = 0; i < scanCandidates.length; i += BATCH_SIZE) {\n      batches.push(scanCandidates.slice(i, i + BATCH_SIZE));\n    }\n\n    const dispatchTime = Date.now();\n    dispatchTimeRef.current = dispatchTime;\n\n    for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {\n      const batch = batches[batchIdx];\n      const payload: MotifWeavePayload = {\n        mode: \"weave\",\n        targetPhrase: TARGET_PHRASE,\n        instances: batch.map((c) => ({\n          index: c.batchIndex,\n          entityName: c.entityName,\n          sentence: c.sentence,\n          surroundingContext: c.contextBefore + c.contextAfter,\n        })),\n      };\n\n      const syntheticEntity = {\n        id: `weave_batch_${dispatchTime}_${batchIdx}`,\n        name: `Weave: ${TARGET_PHRASE} (batch ${batchIdx + 1})`,\n        kind: \"motif\" as string,\n        subtype: \"weave\" as string,\n        prominence: \"marginal\" as unknown as string,\n        culture: \"\" as string,\n        status: \"active\" as string,\n        description: \"\" as string,\n        tags: {} as Record<string, unknown>,\n      };\n\n      try {\n        getEnqueue()([\n          {\n            entity: syntheticEntity,\n            type: \"motifVariation\" as const,\n            prompt: JSON.stringify(payload),\n          },\n        ]);\n      } catch (err) {\n        setError(`Failed to dispatch batch ${batchIdx + 1}: ${err}`);\n        setPhase(\"scan\");\n        return;\n      }\n    }\n  }, []);\n\n  // --- Watch queue for completion ---\n  useEffect(() => {\n    if (phase !== \"generating\") return;\n    const dispatchTime = dispatchTimeRef.current;\n    if (!dispatchTime) return;\n\n    const motifItems = queue.filter(\n      (item) => item.type === \"motifVariation\" && item.queuedAt >= dispatchTime\n    );\n    if (motifItems.length === 0) return;\n\n    const running = motifItems.filter(\n      (item) => item.status === \"running\" || item.status === \"queued\"\n    );\n    const completed = motifItems.filter((item) => item.status === \"complete\");\n    const errored = motifItems.filter((item) => item.status === \"error\");\n\n    if (running.length === 0 && (completed.length > 0 || errored.length > 0)) {\n      if (errored.length > 0) {\n        setError(`${errored.length} batch(es) failed: ${errored[0].error || \"Unknown error\"}`);\n      }\n\n      const variantMap = new Map<string, string>();\n      const currentCandidates = candidatesRef.current;\n\n      for (const item of completed) {\n        if (!item.result?.description) continue;\n        try {\n          const results: MotifVariationResult[] = JSON.parse(item.result.description);\n          for (const r of results) {\n            const candidate = currentCandidates.find((c) => c.batchIndex === r.index);\n            if (candidate) {\n              variantMap.set(candidate.id, r.variant);\n            }\n          }\n        } catch {\n          // Skip unparseable results\n        }\n      }\n\n      setVariants(variantMap);\n      setPhase(variantMap.size > 0 ? \"review\" : \"empty\");\n    }\n  }, [phase, queue]);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    setPhase(\"applying\");\n\n    // Group accepted changes by entity\n    const changesByEntity = new Map<\n      string,\n      Array<{ sentenceStart: number; sentenceEnd: number; original: string; rewritten: string }>\n    >();\n\n    for (const c of candidates) {\n      if (!decisions[c.id]) continue;\n      const variant = variants.get(c.id);\n      if (!variant) continue;\n\n      if (!changesByEntity.has(c.entityId)) {\n        changesByEntity.set(c.entityId, []);\n      }\n      changesByEntity.get(c.entityId).push({\n        sentenceStart: c.sentenceStart,\n        sentenceEnd: c.sentenceEnd,\n        original: c.sentence,\n        rewritten: variant,\n      });\n    }\n\n    // Build patches by applying sentence replacements to descriptions\n    const patches: Array<{ entityId: string; description: string }> = [];\n    const updatedEntityIds: string[] = [];\n    let total = 0;\n\n    for (const [entityId, changes] of changesByEntity) {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity?.description) continue;\n\n      // Sort changes descending by position (apply from end to preserve earlier positions)\n      const sorted = [...changes].sort((a, b) => b.sentenceStart - a.sentenceStart);\n      let description = entity.description;\n      for (const change of sorted) {\n        // Verify the original sentence still exists at the expected position\n        const actual = description.slice(change.sentenceStart, change.sentenceEnd);\n        if (actual === change.original) {\n          description =\n            description.slice(0, change.sentenceStart) +\n            change.rewritten +\n            description.slice(change.sentenceEnd);\n          total++;\n        }\n      }\n\n      if (description !== entity.description) {\n        patches.push({ entityId, description });\n        updatedEntityIds.push(entityId);\n      }\n    }\n\n    if (patches.length > 0) {\n      await applyRevisionPatches(patches, \"motif-weave\");\n      await reloadEntities(updatedEntityIds);\n    }\n\n    setResultCount(total);\n    setPhase(\"done\");\n  }, [candidates, decisions, variants]);\n\n  // --- Decision helpers ---\n  const toggleDecision = useCallback((id: string) => {\n    setDecisions((prev) => ({ ...prev, [id]: !prev[id] }));\n  }, []);\n\n  const acceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) {\n        if (variants.has(c.id)) next[c.id] = true;\n      }\n      return next;\n    });\n  }, [candidates, variants]);\n\n  const rejectAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) next[c.id] = false;\n      return next;\n    });\n  }, [candidates]);\n\n  const acceptGroup = useCallback(\n    (groupCandidates: WeaveCandidate[]) => {\n      setDecisions((prev) => {\n        const next = { ...prev };\n        for (const c of groupCandidates) {\n          if (variants.has(c.id)) next[c.id] = true;\n        }\n        return next;\n      });\n    },\n    [variants]\n  );\n\n  const rejectGroup = useCallback((groupCandidates: WeaveCandidate[]) => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of groupCandidates) next[c.id] = false;\n      return next;\n    });\n  }, []);\n\n  const toggleExpand = useCallback((key: string) => {\n    setExpandedGroups((prev) => {\n      const next = new Set(prev);\n      if (next.has(key)) next.delete(key);\n      else next.add(key);\n      return next;\n    });\n  }, []);\n\n  // --- Stats ---\n  const acceptCount = useMemo(() => Object.values(decisions).filter(Boolean).length, [decisions]);\n\n  // --- Groups (by entity) ---\n  const groups = useMemo(() => {\n    const map = new Map<\n      string,\n      { entityId: string; entityName: string; candidates: WeaveCandidate[] }\n    >();\n    for (const c of candidates) {\n      if (!map.has(c.entityId)) {\n        map.set(c.entityId, { entityId: c.entityId, entityName: c.entityName, candidates: [] });\n      }\n      map.get(c.entityId).candidates.push(c);\n// ... (truncated)", "parameters": [{"name": "{ onClose }", "type": "Readonly<{ onClose: () => void }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["applyRevisionPatches"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../hooks/useEntityCrud", "specifiers": ["reloadEntities"], "category": "internal"}, {"source": "../workers/tasks/motifVariationTask", "specifiers": ["MotifWeavePayload", "MotifVariationResult"], "category": "internal"}, {"source": "./DescriptionMotifWeaver.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function DynamicsGenerationModal({\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}) {\n  const [feedback, setFeedback] = useState(\"\");\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to bottom on new messages\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.messages?.length, run?.proposedDynamics?.length]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isReviewable = run.status === \"awaiting_review\";\n  const isFailed = run.status === \"failed\";\n\n  const handleSubmitFeedback = () => {\n    if (!feedback.trim()) return;\n    onSubmitFeedback(feedback.trim());\n    setFeedback(\"\");\n  };\n\n  const handleKeyDown = (e) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmitFeedback();\n    }\n  };\n\n  const displayMessages = run.messages || [];\n\n  return (\n    <div className=\"dgm-overlay\">\n      <div className=\"dgm-dialog\">\n        {/* Header */}\n        <div className=\"dgm-header\">\n          <div>\n            <h2 className=\"dgm-title\">Generate World Dynamics</h2>\n            <p className=\"dgm-subtitle\">\n              Multi-turn conversation with the LLM to synthesize dynamics from lore\n            </p>\n          </div>\n          <div className=\"dgm-header-actions\">\n            {run.totalActualCost > 0 && (\n              <span className=\"dgm-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary dgm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content area: messages + proposed dynamics */}\n        <div className=\"dgm-content\">\n          {displayMessages.map((msg, i) => (\n            <MessageBubble key={i} message={msg} />\n          ))}\n\n          {isGenerating && <div className=\"dgm-generating\">Generating...</div>}\n\n          {isFailed && <div className=\"dgm-failed\">{run.error || \"Generation failed\"}</div>}\n\n          {/* Proposed dynamics inside scrollable area */}\n          {isReviewable && run.proposedDynamics && (\n            <ProposedDynamicsList dynamics={run.proposedDynamics} />\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Footer: feedback input + actions (always visible) */}\n        <div className=\"dgm-footer\">\n          {/* Feedback input */}\n          {(isReviewable || isFailed) && (\n            <div className=\"dgm-feedback-row\">\n              <textarea\n                value={feedback}\n                onChange={(e) => setFeedback(e.target.value)}\n                onKeyDown={handleKeyDown}\n                placeholder={\n                  isFailed\n                    ? \"Provide feedback and retry...\"\n                    : 'Steer the dynamics (e.g., \"focus more on trade conflicts\", \"add era-specific tensions\")...'\n                }\n                className=\"illuminator-input dgm-feedback-input\"\n              />\n            </div>\n          )}\n\n          {/* Action buttons */}\n          <div className=\"dgm-actions\">\n            {(isReviewable || isFailed) && (\n              <button\n                onClick={handleSubmitFeedback}\n                disabled={!feedback.trim()}\n                className=\"illuminator-button illuminator-button-secondary dgm-action-btn\"\n              >\n                {isFailed ? \"Retry with Feedback\" : \"Refine\"}\n              </button>\n            )}\n            {isReviewable && (\n              <button\n                onClick={onAccept}\n                className=\"illuminator-button illuminator-button-primary dgm-action-btn\"\n              >\n                Accept Dynamics ({run.proposedDynamics?.length || 0})\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}", "type": "{ run: any; isActive: any; onSubmitFeedback: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./DynamicsGenerationModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx", "sourceCode": "export default function EnrichmentQueue({\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}) {\n  const [selectedTasks, setSelectedTasks] = useState(new Set());\n  const [expandedEntities, setExpandedEntities] = useState(new Set());\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterProminence, setFilterProminence] = useState(\"all\");\n  const [filterStatus, setFilterStatus] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    if (prominenceScale) return prominenceScale;\n    const values = tasks\n      .map((task) => task.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [prominenceScale, tasks]);\n\n  // Group tasks by entity\n  const groupedTasks = useMemo(() => {\n    const groups = new Map();\n\n    for (const task of tasks) {\n      if (!groups.has(task.entityId)) {\n        groups.set(task.entityId, {\n          entityId: task.entityId,\n          entityName: task.entityName,\n          entityKind: task.entityKind,\n          entitySubtype: task.entitySubtype,\n          prominence: task.prominence,\n          tasks: [],\n        });\n      }\n      groups.get(task.entityId).tasks.push(task);\n    }\n\n    return Array.from(groups.values());\n  }, [tasks]);\n\n  // Apply filters\n  const filteredGroups = useMemo(() => {\n    return groupedTasks.filter((group) => {\n      if (filterKind !== \"all\" && group.entityKind !== filterKind) return false;\n      if (filterProminence !== \"all\") {\n        // Filter to entities with at least the selected prominence level\n        const entityProminence = typeof group.prominence === \"number\" ? group.prominence : 0;\n        const filterThreshold = prominenceThresholdFromScale(\n          filterProminence,\n          effectiveProminenceScale\n        );\n        if (entityProminence < filterThreshold) return false;\n      }\n      if (filterStatus !== \"all\") {\n        const hasMatchingTask = group.tasks.some((t) => t.status === filterStatus);\n        if (!hasMatchingTask) return false;\n      }\n      return true;\n    });\n  }, [groupedTasks, filterKind, filterProminence, filterStatus, effectiveProminenceScale]);\n\n  // Get unique entity kinds\n  const entityKinds = useMemo(() => {\n    const kinds = new Set(tasks.map((t) => t.entityKind));\n    return Array.from(kinds);\n  }, [tasks]);\n\n  const toggleTask = (taskId) => {\n    setSelectedTasks((prev) => {\n      const next = new Set(prev);\n      if (next.has(taskId)) {\n        next.delete(taskId);\n      } else {\n        next.add(taskId);\n      }\n      return next;\n    });\n  };\n\n  const toggleEntity = (entityId) => {\n    setExpandedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const runSelected = () => {\n    onRunTasks(Array.from(selectedTasks));\n  };\n\n  const totalPending = tasks.filter((t) => t.status === \"pending\").length;\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Queue</h2>\n          <div className=\"eq-header-actions\">\n            <button\n              onClick={onRunAll}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys || totalPending === 0}\n            >\n              Run All ({totalPending})\n            </button>\n          </div>\n        </div>\n\n        {!hasRequiredKeys && (\n          <div className=\"eq-api-warning\">Set API keys in the sidebar to run enrichment tasks</div>\n        )}\n\n        {/* Filters */}\n        <div className=\"eq-filters\">\n          <div>\n            <label htmlFor=\"entity-kind\" className=\"eq-filter-label\">Entity Kind</label>\n            <select id=\"entity-kind\"\n              value={filterKind}\n              onChange={(e) => setFilterKind(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {entityKinds.map((kind) => (\n                <option key={kind} value={kind}>\n                  {kind}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"prominence\" className=\"eq-filter-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={filterProminence}\n              onChange={(e) => setFilterProminence(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {PROMINENCE_LEVELS.map((level) => (\n                <option key={level} value={level}>\n                  {level}+\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"status\" className=\"eq-filter-label\">Status</label>\n            <select id=\"status\"\n              value={filterStatus}\n              onChange={(e) => setFilterStatus(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              <option value=\"pending\">Pending</option>\n              <option value=\"complete\">Complete</option>\n              <option value=\"error\">Error</option>\n            </select>\n          </div>\n\n          <div className=\"eq-filter-summary\">\n            <span className=\"eq-filter-summary-text\">\n              {filteredGroups.length} entities, {tasks.length} tasks\n            </span>\n          </div>\n        </div>\n\n        {/* Task groups */}\n        <div>\n          {filteredGroups.map((group) => (\n            <EntityTaskGroup\n              key={group.entityId}\n              {...group}\n              selectedTasks={selectedTasks}\n              onToggleTask={toggleTask}\n              onRunTask={(taskId) => onRunTasks([taskId])}\n              expanded={expandedEntities.has(group.entityId)}\n              onToggleExpand={() => toggleEntity(group.entityId)}\n              prominenceScale={effectiveProminenceScale}\n            />\n          ))}\n\n          {filteredGroups.length === 0 && (\n            <div className=\"eq-empty\">No tasks match current filters</div>\n          )}\n        </div>\n      </div>\n\n      {/* Selection actions */}\n      {selectedTasks.size > 0 && (\n        <div className=\"eq-selection-bar\">\n          <span className=\"eq-selection-count\">\n            {selectedTasks.size} task{selectedTasks.size !== 1 ? \"s\" : \"\"} selected\n          </span>\n          <div className=\"eq-selection-actions\">\n            <button\n              onClick={() => setSelectedTasks(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button\n              onClick={runSelected}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys}\n            >\n              Run Selected\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}", "type": "{ tasks: any; onRunTasks: any; onRunAll: any; worldSchema: any; hasRequiredKeys: any; prominenceScale: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale", "prominenceThresholdFromScale"], "category": "external"}, {"source": "./EnrichmentQueue.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityBrowser.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityBrowser.jsx", "sourceCode": "export default function EntityBrowser({\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}) {\n  const navEntities = useEntityNavList();\n  const { handleAssignImage, handleDeleteEntity } = useEntityCrud();\n  const { historianConfigured } = useHistorianActions();\n  const { openCreateEntity, openEditEntity, openImageSettings } =\n    useIlluminatorModals();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [searchOpen, setSearchOpen] = useState(false);\n  const [searchText, setSearchText] = useState(false);\n  const searchInputRef = useRef(null);\n  const [filters, setFilters] = useState({\n    kind: \"all\",\n    prominence: \"all\",\n    status: \"all\",\n    culture: \"all\",\n    chronicleImage: \"all\",\n  });\n  const prominenceScale = useProminenceScale();\n  const [hideCompleted, setHideCompleted] = useState(false);\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [imagePickerEntity, setImagePickerEntity] = useState(null);\n  const [showMotifWeaver, setShowMotifWeaver] = useState(false);\n  // Get unique values for filters\n  const filterOptions = useMemo(() => {\n    const kinds = new Set();\n    const cultures = new Set();\n\n    for (const entity of navEntities) {\n      kinds.add(entity.kind);\n      if (entity.culture) cultures.add(entity.culture);\n    }\n\n    return {\n      kinds: Array.from(kinds).sort(),\n      cultures: Array.from(cultures).sort(),\n    };\n  }, [navEntities]);\n\n  // Entity search \u2014 partial match on name, aliases, and optionally summary text\n  const searchResults = useMemo(() => {\n    const q = searchQuery.trim().toLowerCase();\n    if (!q || q.length < 2) return [];\n    const results = [];\n    for (const entity of navEntities) {\n      const matches = [];\n      // Name match\n      const nameIdx = entity.name.toLowerCase().indexOf(q);\n      if (nameIdx !== -1) {\n        matches.push({ field: \"name\", value: entity.name, matchIndex: nameIdx });\n      }\n      // Alias matches\n      for (const alias of entity.aliases) {\n        if (typeof alias !== \"string\") continue;\n        const aliasIdx = alias.toLowerCase().indexOf(q);\n        if (aliasIdx !== -1) {\n          matches.push({ field: \"alias\", value: alias, matchIndex: aliasIdx });\n        }\n      }\n      // Slug alias matches\n      for (const slug of entity.slugAliases) {\n        if (typeof slug !== \"string\") continue;\n        const slugIdx = slug.toLowerCase().indexOf(q);\n        if (slugIdx !== -1) {\n          matches.push({ field: \"slug alias\", value: slug, matchIndex: slugIdx });\n        }\n      }\n      // Summary text matches (only when searchText enabled)\n      if (searchText && entity.summary) {\n        const sumIdx = entity.summary.toLowerCase().indexOf(q);\n        if (sumIdx !== -1) {\n          matches.push({ field: \"summary\", value: entity.summary, matchIndex: sumIdx });\n        }\n      }\n      if (matches.length > 0) {\n        results.push({ entity, matches });\n      }\n    }\n    // Sort: name matches first, then by name alphabetically\n    results.sort((a, b) => {\n      const aHasName = a.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      const bHasName = b.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      if (aHasName !== bHasName) return aHasName - bHasName;\n      return a.entity.name.localeCompare(b.entity.name);\n    });\n    return results;\n  }, [navEntities, searchQuery, searchText]);\n\n  const handleSearchSelect = useCallback((entityId) => {\n    setSelectedEntityId(entityId);\n    setSearchOpen(false);\n    setSearchQuery(\"\");\n  }, []);\n\n  // Get enrichment status for a nav item\n  const getStatus = useCallback(\n    (nav, type) => {\n      // Check queue first\n      const queueItem = queue.find((item) => item.entityId === nav.id && item.type === type);\n      if (queueItem) {\n        return queueItem.status;\n      }\n\n      // Check nav item flags\n      if (type === \"description\" && nav.hasDescription) return \"complete\";\n      if (type === \"visualThesis\" && nav.hasVisualThesis) return \"complete\";\n      if (type === \"image\" && nav.imageId) return \"complete\";\n\n      return \"missing\";\n    },\n    [queue]\n  );\n\n  // Filter entities via nav items\n  const filteredNavItems = useMemo(() => {\n    return navEntities.filter((nav) => {\n      if (filters.kind !== \"all\" && nav.kind !== filters.kind) return false;\n      if (\n        filters.prominence !== \"all\" &&\n        prominenceLabelFromScale(nav.prominence, prominenceScale) !== filters.prominence\n      ) {\n        return false;\n      }\n      if (filters.culture !== \"all\" && nav.culture !== filters.culture) return false;\n\n      const descStatus = getStatus(nav, \"description\");\n      const imgStatus = getStatus(nav, \"image\");\n\n      // Hide completed filter\n      if (hideCompleted && descStatus === \"complete\" && imgStatus === \"complete\") {\n        return false;\n      }\n\n      if (filters.status !== \"all\") {\n        if (filters.status === \"missing\" && descStatus !== \"missing\" && imgStatus !== \"missing\") {\n          return false;\n        }\n        if (filters.status === \"complete\" && descStatus !== \"complete\") {\n          return false;\n        }\n        if (filters.status === \"queued\" && descStatus !== \"queued\" && imgStatus !== \"queued\") {\n          return false;\n        }\n        if (filters.status === \"running\" && descStatus !== \"running\" && imgStatus !== \"running\") {\n          return false;\n        }\n        if (filters.status === \"error\" && descStatus !== \"error\" && imgStatus !== \"error\") {\n          return false;\n        }\n      }\n\n      // Chronicle image filter\n      if (filters.chronicleImage !== \"all\") {\n        if (filters.chronicleImage === \"none\" && nav.backrefCount > 0) return false;\n        if (filters.chronicleImage === \"unconfigured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount === 0) return false;\n        }\n        if (filters.chronicleImage === \"configured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount > 0) return false;\n        }\n      }\n\n      return true;\n    });\n  }, [navEntities, filters, hideCompleted, getStatus, prominenceScale]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((entityId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredNavItems.map((e) => e.id)));\n  }, [filteredNavItems]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  // Queue single item \u2014 load full entity from store for prompt building\n  const queueItem = useCallback(\n    async (entityId, type) => {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity) return;\n      const prompt = buildPrompt(entity, type === \"visualThesis\" ? \"description\" : type);\n      const visualConfig =\n        (type === \"description\" || type === \"visualThesis\") && getVisualConfig\n          ? getVisualConfig(entity)\n          : {};\n      const imageOverrides =\n        type === \"image\"\n          ? { imageSize: imageGenSettings.imageSize, imageQuality: imageGenSettings.imageQuality }\n          : {};\n      getEnqueue()([{ entity, type, prompt, ...visualConfig, ...imageOverrides }]);\n    },\n    [buildPrompt, getVisualConfig, imageGenSettings.imageSize, imageGenSettings.imageQuality]\n  );\n\n  // Cancel single item\n  const cancelItem = useCallback(\n    (entityId, type) => {\n      const queueItem = queue.find((item) => item.entityId === entityId && item.type === type);\n      if (queueItem) {\n        getCancel()(queueItem.id);\n      }\n    },\n    [queue]\n  );\n\n  // Queue all missing descriptions for selected \u2014 filter on nav items, load full for prompt\n  const queueSelectedDescriptions = useCallback(async () => {\n    const missingIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (nav && getStatus(nav, \"description\") === \"missing\") {\n        missingIds.push(entityId);\n      }\n    }\n    if (missingIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(missingIds);\n    const items = fullEntities.map((entity) => {\n      const visualConfig = getVisualConfig ? getVisualConfig(entity) : {};\n      return {\n        entity,\n        type: \"description\",\n        prompt: buildPrompt(entity, \"description\"),\n        ...visualConfig,\n      };\n    });\n    if (items.length > 0) getEnqueue()(items);\n  }, [selectedIds, navEntities, getStatus, buildPrompt, getVisualConfig]);\n\n  // Queue all missing images for selected\n  const queueSelectedImages = useCallback(async () => {\n    const eligibleIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (\n        nav &&\n        prominenceAtLeast(nav.prominence, config.minProminenceForImage, prominenceScale) &&\n        getStatus(nav, \"image\") === \"missing\" &&\n        (!config.requireDescription || nav.hasDescription)\n      ) {\n        eligibleIds.push(entityId);\n      }\n    }\n    if (eligibleIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(eligibleIds);\n    const items = fullEntities.map((entity) => ({\n      entity,\n      type: \"image\",\n      prompt: buildPrompt(entity, \"image\"),\n      imageSize: imageGenSettings.imageSize,\n      imageQuality: imageGenSettings.imageQuality,\n    }));\n    if (items.length > 0) getEnqueue()(items);\n  }, [\n    selectedIds,\n    navEntities,\n    getStatus,\n    buildPrompt,\n    config.minProminenceForImage,\n    config.requireDescription,\n    imageGenSettings.imageSize,\n    imageGenSettings.imageQuality,\n    prominenceScale,\n  ]);\n\n  // Regenerate all descriptions for selected\n  const regenSelectedDescriptions = useCallback(async () => {\n    const completeIds = [];\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}", "type": "{ worldSchema: any; config: any; onConfigChange: any; buildPrompt: any; getVisualConfig: any; styleLibrary: any; imageGenSettings: any; onStartRevision: any; isRevising: any; onBulkHistorianReview: any; onBulkHistorianEdition: any; onBulkHistorianClear: any; isBulkHistorianActive: any; onNavigateToTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useProminenceScale"], "category": "internal"}, {"source": "../hooks/useEntityCrud", "specifiers": ["useEntityCrud", "reloadEntities"], "category": "internal"}, {"source": "../hooks/useHistorianActions", "specifiers": ["useHistorianActions"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["convertLongEditionsToLegacy"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueBridge", "specifiers": ["getEnqueue", "getCancel"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "./DescriptionMotifWeaver", "specifiers": ["DescriptionMotifWeaver"], "category": "internal"}, {"source": "./ImageModal", "specifiers": ["ImageModal"], "category": "internal"}, {"source": "./ImagePickerModal", "specifiers": ["ImagePickerModal"], "category": "internal"}, {"source": "./EntityDetailView", "specifiers": ["EntityDetailView"], "category": "internal"}, {"source": "./ImageSettingsDrawer", "specifiers": ["ImageSettingsSummary"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "../lib/costEstimation", "specifiers": ["formatCost"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "prominenceThresholdFromScale"], "category": "external"}, {"source": "./EntityBrowser.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx", "sourceCode": "export default function EntityCoveragePanel({\n  simulationRunId\n}) {\n  // Events and relationships are always in memory (simple store pattern, no nav/detail split)\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n\n  // Full entity + chronicle data loaded on demand when user clicks \"Calculate\"\n  const [analysisData, setAnalysisData] = useState(null);\n  const [calculating, setCalculating] = useState(false);\n  const [expandedSections, setExpandedSections] = useState(new Set());\n\n  // Reset when simulation run changes\n  useEffect(() => {\n    setAnalysisData(null);\n  }, [simulationRunId]);\n  const handleCalculate = useCallback(async () => {\n    if (!simulationRunId) return;\n    setCalculating(true);\n    try {\n      const [fullEntities, chronicles] = await Promise.all([getEntitiesForRun(simulationRunId), getChroniclesForSimulation(simulationRunId)]);\n      const safeEvents = narrativeEvents || [];\n      const safeRelationships = relationships || [];\n      const analysis = computeCoreAnalysis(fullEntities, chronicles, safeEvents, safeRelationships);\n      setAnalysisData({\n        fullEntities,\n        chronicles,\n        analysis,\n        events: safeEvents,\n        relationships: safeRelationships\n      });\n    } catch (err) {\n      console.error(\"[EntityCoverage] Failed to calculate:\", err);\n    } finally {\n      setCalculating(false);\n    }\n  }, [simulationRunId, narrativeEvents, relationships]);\n  const toggleSection = useCallback(sectionId => {\n    setExpandedSections(prev => {\n      const next = new Set(prev);\n      if (next.has(sectionId)) next.delete(sectionId);else next.add(sectionId);\n      return next;\n    });\n  }, []);\n  if (!simulationRunId) return null;\n\n  // Before calculation \u2014 show button\n  if (!analysisData) {\n    return <div className=\"ecp-pre-calc\">\n        <div className=\"illuminator-card\">\n          <div className=\"ecp-pre-calc-inner\">\n            <div className=\"ecp-pre-calc-header\">\n              <span className=\"ecp-pre-calc-title\">Entity Coverage Analysis</span>\n            </div>\n            <p className=\"ecp-pre-calc-desc\">\n              Analyzes coverage gaps across entities, chronicles, events, and relationships. Loads\n              full entity data on demand.\n            </p>\n            <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-btn-pad-sm\">\n              {calculating ? \"Calculating...\" : \"Calculate Statistics\"}\n            </button>\n          </div>\n        </div>\n      </div>;\n  }\n  const {\n    fullEntities,\n    analysis,\n    events: safeEvents,\n    relationships: safeRelationships\n  } = analysisData;\n\n  // Compute underutil counts for collapsed section headers\n  const sectionUnderutilCounts = {};\n  for (const sectionId of SECTION_IDS) {\n    if (!expandedSections.has(sectionId)) {\n      switch (sectionId) {\n        case \"suggestions\":\n          sectionUnderutilCounts[sectionId] = (() => {\n            const groupsWithUncovered = new Set();\n            for (const e of safeEvents) {\n              if ((analysis.eventCoverage.get(e.id) ?? 0) <= 0) {\n                groupsWithUncovered.add(eventGroupKey(e));\n              }\n            }\n            return groupsWithUncovered.size;\n          })();\n          break;\n        case \"backrefs\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            const expected = expectedForProminence(e.prominence);\n            if (expected === 0) return false;\n            const count = e.enrichment?.chronicleBackrefs?.length ?? 0;\n            return count / expected < 1;\n          }).length;\n          break;\n        case \"history\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            return (e.enrichment?.chronicleBackrefs?.length ?? 0) > 0 && (e.enrichment?.descriptionHistory?.length ?? 0) === 0;\n          }).length;\n          break;\n        case \"culture\":\n          sectionUnderutilCounts[sectionId] = [...(analysis.cultureEntities?.entries() || [])].filter(([, data]) => {\n            if (data.count < 3) return false;\n            let appeared = 0;\n            for (const id of data.entityIds) {\n              if (analysis.entityUsage.has(id)) appeared++;\n            }\n            return appeared / data.count < 0.3;\n          }).length;\n          break;\n        case \"events\":\n          sectionUnderutilCounts[sectionId] = safeEvents.filter(e => {\n            return e.significance >= 0.7 && (e.participantEffects?.length ?? 0) >= 3 && (analysis.eventCoverage.get(e.id) ?? 0) <= 0;\n          }).length;\n          break;\n        case \"potential\":\n          sectionUnderutilCounts[sectionId] = null; // expensive, skip for collapsed\n          break;\n        case \"eras\":\n          {\n            const allEraIds = new Set([...analysis.eraChronicles.keys(), ...analysis.eraEntityCounts.keys(), ...analysis.eraEventCounts.keys()]);\n            sectionUnderutilCounts[sectionId] = [...allEraIds].filter(eraId => {\n              return (analysis.eraChronicles.get(eraId)?.total ?? 0) <= 0 && ((analysis.eraEntityCounts.get(eraId) || 0) > 0 || (analysis.eraEventCounts.get(eraId) || 0) > 0);\n            }).length;\n            break;\n          }\n        case \"integration\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            if ((Number(e.prominence) || 0) < 2) return false;\n            let gaps = 0;\n            if (!e.description) gaps++;\n            if ((e.enrichment?.chronicleBackrefs?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.descriptionHistory?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.historianNotes?.length ?? 0) <= 0) gaps++;\n            if (!e.enrichment?.image?.imageId) gaps++;\n            return gaps >= 3;\n          }).length;\n          break;\n      }\n    }\n  }\n  const sectionProps = {\n    suggestions: {\n      Component: SuggestionsSection,\n      props: {\n        events: safeEvents,\n        entities: fullEntities,\n        eventCoverage: analysis.eventCoverage,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    backrefs: {\n      Component: BackrefsSection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    history: {\n      Component: HistorySection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    culture: {\n      Component: CultureSection,\n      props: {\n        entities: fullEntities,\n        cultureRoles: analysis.cultureRoles,\n        cultureEntities: analysis.cultureEntities,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    events: {\n      Component: EventsSection,\n      props: {\n        events: safeEvents,\n        eventCoverage: analysis.eventCoverage\n      }\n    },\n    potential: {\n      Component: PotentialSection,\n      props: {\n        entities: fullEntities,\n        narrativeEvents: safeEvents,\n        relationships: safeRelationships,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    eras: {\n      Component: ErasSection,\n      props: {\n        entities: fullEntities,\n        events: safeEvents,\n        eraChronicles: analysis.eraChronicles,\n        eraEntityCounts: analysis.eraEntityCounts,\n        eraEventCounts: analysis.eraEventCounts\n      }\n    },\n    integration: {\n      Component: IntegrationSection,\n      props: {\n        entities: fullEntities,\n        entityBackportedCount: analysis.entityBackportedCount\n      }\n    }\n  };\n  return <div className=\"ecp-wrapper\">\n      <div className=\"illuminator-card ecp-header-card\">\n        <div className=\"ecp-header-bar\">\n          <span className=\"ecp-header-title\">Entity Coverage Analysis</span>\n          <span className=\"ecp-header-stats\">\n            {analysis.nonEraEntities.length} entities, {analysis.activeChronicles.length}{\" \"}\n            chronicles, {safeEvents.length} events\n          </span>\n          <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-recalc-btn\" title=\"Reload data from database and recalculate all statistics\">\n            {calculating ? \"Recalculating...\" : \"Recalculate\"}\n          </button>\n        </div>\n      </div>\n\n      <div className=\"ec-grid\">\n        {SECTION_IDS.map(sectionId => {\n        const isExpanded = expandedSections.has(sectionId);\n        const underutil = sectionUnderutilCounts[sectionId];\n        const {\n          Component,\n          props\n        } = sectionProps[sectionId];\n        return <div key={sectionId} className=\"illuminator-card ec-grid-cell\">\n              <SectionHeader sectionId={sectionId} expanded={isExpanded} onToggle={() => toggleSection(sectionId)} label={SECTION_LABELS[sectionId]} description={SECTION_DESCRIPTIONS[sectionId]} underutilCount={underutil} />\n              {isExpanded && <Component {...props} expanded={true} />}\n            </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  simulationRunId\n}", "type": "{ simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useEffect", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/relationshipSelectors", "specifiers": ["useRelationships"], "category": "internal"}, {"source": "../lib/db/narrativeEventSelectors", "specifiers": ["useNarrativeEvents"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["getEntitiesForRun"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChroniclesForSimulation"], "category": "internal"}, {"source": "../lib/chronicle/storyPotential", "specifiers": ["computeAllStoryPotentials", "scoreToRating"], "category": "internal"}, {"source": "./EntityCoveragePanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityDetailView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityDetailView.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// EntityDetailView\n// ---------------------------------------------------------------------------\n\nexport default function EntityDetailView({ entity, entities, onBack }: Readonly<EntityDetailViewProps>) {\n  const prominenceScale = useProminenceScale();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const {\n    handleUpdateBackrefs,\n    handleUndoDescription,\n    handleUpdateAliases,\n    handleUpdateDescription,\n    handleUpdateSummary,\n    handleClearNotes,\n    handleRestoreDescription,\n  } = useEntityCrud();\n  const {\n    historianConfigured,\n    isHistorianEditionActive,\n    isHistorianActive,\n    handleHistorianEdition,\n    handleHistorianReview,\n    handleUpdateHistorianNote,\n    editionPreview,\n    handleEditionPreviewProceed,\n    handleEditionPreviewCancel,\n  } = useHistorianActions();\n  const { openRename, openPatchEvents } = useIlluminatorModals();\n\n  const enrichment = entity.enrichment;\n  const textEnrichment = enrichment?.text;\n\n  // Inline editing state\n  const [editingSummary, setEditingSummary] = useState(false);\n  const [summaryDraft, setSummaryDraft] = useState(\"\");\n  const [editingDescription, setEditingDescription] = useState(false);\n  const [descriptionDraft, setDescriptionDraft] = useState(\"\");\n\n  const startEditSummary = useCallback(() => {\n    setSummaryDraft(entity.summary || \"\");\n    setEditingSummary(true);\n  }, [entity.summary]);\n\n  const saveSummary = useCallback(() => {\n    const trimmed = summaryDraft.trim();\n    if (trimmed && trimmed !== entity.summary) {\n      void handleUpdateSummary(entity.id, trimmed);\n    }\n    setEditingSummary(false);\n  }, [handleUpdateSummary, summaryDraft, entity.summary, entity.id]);\n\n  const cancelSummary = useCallback(() => {\n    setEditingSummary(false);\n    setSummaryDraft(\"\");\n  }, []);\n\n  const startEditDescription = useCallback(() => {\n    setDescriptionDraft(entity.description || \"\");\n    setEditingDescription(true);\n  }, [entity.description]);\n\n  const saveDescription = useCallback(() => {\n    const trimmed = descriptionDraft.trim();\n    if (trimmed && trimmed !== entity.description) {\n      void handleUpdateDescription(entity.id, trimmed);\n    }\n    setEditingDescription(false);\n  }, [handleUpdateDescription, descriptionDraft, entity.description, entity.id]);\n\n  const cancelDescription = useCallback(() => {\n    setEditingDescription(false);\n    setDescriptionDraft(\"\");\n  }, []);\n\n  // Chain debug (narrative -> thesis -> traits)\n  const chainDebug: DescriptionChainDebug | undefined = textEnrichment?.chainDebug;\n\n  // Legacy single debug\n  let legacyDebug: NetworkDebugInfo | undefined = textEnrichment?.debug;\n  if (!legacyDebug && !chainDebug) {\n    const descriptionQueueItem = queue.find(\n      (item) => item.entityId === entity.id && item.type === \"description\" && item.debug\n    );\n    legacyDebug = descriptionQueueItem?.debug;\n  }\n\n  // Escape key goes back (unless editing inline)\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === \"Escape\" && !editingSummary && !editingDescription) onBack();\n    },\n    [onBack, editingSummary, editingDescription]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Description history\n  const historyLen = enrichment?.descriptionHistory?.length || 0;\n  const lastEntry = historyLen > 0 ? enrichment.descriptionHistory[historyLen - 1] : null;\n\n  return (\n    <>\n      <div className=\"edv\">\n        {/* Header bar */}\n        <div className=\"edv-header\">\n          <button onClick={onBack} className=\"edv-back-btn\">\n            \u2190 Back\n          </button>\n          <div className=\"edv-header-info\">\n            <div className=\"edv-entity-name\">{entity.name}</div>\n            <div className=\"edv-entity-meta\">\n              {entity.kind}/{entity.subtype} \u00b7{\" \"}\n              {prominenceLabelFromScale(entity.prominence, prominenceScale)}\n              {entity.culture && ` \u00b7 ${entity.culture}`}\n            </div>\n          </div>\n          <div className=\"edv-esc-hint\">Esc to go back</div>\n        </div>\n\n        {/* Two-column body */}\n        <div className=\"edv-body\">\n          {/* Main content */}\n          <div className=\"edv-main\">\n            {/* Summary */}\n            {(entity.summary || handleUpdateSummary) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label\">\n                  Summary\n                  {handleUpdateSummary && !editingSummary && (\n                    <button\n                      onClick={startEditSummary}\n                      title=\"Edit summary\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                </div>\n                {editingSummary ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={summaryDraft}\n                    onChange={(e) => setSummaryDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveSummary();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelSummary();\n                      }\n                    }}\n                    onBlur={saveSummary}\n                    className=\"edv-summary-textarea\"\n                  />\n                ) : (\n                  <p className=\"edv-summary-text\">\n                    {entity.summary || <span className=\"edv-placeholder\">No summary</span>}\n                  </p>\n                )}\n              </div>\n            )}\n\n            {/* Visual Thesis */}\n            {textEnrichment?.visualThesis && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-visual-thesis\">\n                  Visual Thesis\n                </div>\n                <p className=\"edv-visual-thesis\">{textEnrichment.visualThesis}</p>\n              </div>\n            )}\n\n            {/* Full Description */}\n            {(entity.description || handleUpdateDescription) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-wrap\">\n                  Full Description\n                  {historyLen > 0 && (\n                    <span className=\"edv-version-hint\">\n                      v{historyLen + 1} ({historyLen} previous)\n                    </span>\n                  )}\n                  {historyLen > 0 && handleUndoDescription && (\n                    <button\n                      onClick={() => void handleUndoDescription(entity.id)}\n                      title={`Revert to previous version (from ${lastEntry?.source || \"unknown\"}, ${lastEntry?.replacedAt ? new Date(lastEntry.replacedAt).toLocaleDateString() : \"unknown\"})`}\n                      className=\"edv-inline-btn\"\n                    >\n                      \u21a9 Undo\n                    </button>\n                  )}\n                  {handleUpdateDescription && !editingDescription && (\n                    <button\n                      onClick={startEditDescription}\n                      title=\"Edit description\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                  <button\n                    onClick={() => openRename(entity.id)}\n                    title=\"Rename this entity with full propagation across all references\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Rename\n                  </button>\n                  <button\n                    onClick={() => openPatchEvents(entity.id)}\n                    title=\"Repair stale names in narrative event history for this entity\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Patch Events\n                  </button>\n                </div>\n                {historianConfigured && (\n                  <>\n                    <div className=\"edv-section-label\">\n                      Historian\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone)}\n                        disabled={isHistorianEditionActive}\n                        label=\"Copy Edit\"\n                        hasNotes={false}\n                      />\n                      {enrichment?.descriptionHistory?.some(\n                        (h: { source?: string }) => h.source === \"historian-edition\"\n                      ) && (\n                        <HistorianToneSelector\n                          onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone, true)}\n                          disabled={isHistorianEditionActive}\n                          label=\"Re-Edit\"\n                          hasNotes={false}\n                        />\n                      )}\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianReview(entity.id, tone)}\n                        disabled={isHistorianActive}\n                        label=\"Annotate\"\n                        hasNotes={\n                          enrichment?.historianNotes && enrichment.historianNotes.length > 0\n                        }\n                      />\n                      {handleClearNotes &&\n                        enrichment?.historianNotes &&\n                        enrichment.historianNotes.length > 0 && (\n                          <button\n                            onClick={() => void handleClearNotes(entity.id)}\n                            title=\"Remove all annotations from this entity\"\n                            className=\"edv-inline-btn-ghost\"\n                          >\n                            Clear Notes\n                          </button>\n                        )}\n                    </div>\n                    {enrichment?.descriptionHistory?.some(\n                      (h: { source?: string }) =>\n                        h.source === \"historian-edition\" || h.source === \"legacy-copy-edit\"\n                    ) &&\n                      entity.description && (\n                        <HistorianEditionComparison\n                          entityId={entity.id}\n                          currentDescription={entity.description}\n                          descriptionHistory={enrichment.descriptionHistory}\n                          historianNotes={enrichment.historianNotes}\n                          onRestoreVersion={(entityId, historyIndex) => void handleRestoreDescription(entityId, historyIndex)}\n                        />\n                      )}\n                  </>\n                )}\n                {editingDescription ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={descriptionDraft}\n                    onChange={(e) => setDescriptionDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveDescription();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelDescription();\n                      }\n                    }}\n                    onBlur={saveDescription}\n                    className=\"edv-desc-textarea\"\n                  />\n                ) : (\n                  <>\n                    {entity.description ? (\n                      <div className=\"edv-description entity-description-md\">\n                        <ReactMarkdown\n// ... (truncated)", "parameters": [{"name": "{ entity, entities, onBack }", "type": "Readonly<EntityDetailViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback"], "category": "framework"}, {"source": "../lib/enrichmentTypes", "specifiers": ["NetworkDebugInfo", "DescriptionChainDebug", "ChronicleBackref"], "category": "internal"}, {"source": "./HistorianMarginNotes", "specifiers": ["HistorianMarginNotes"], "category": "internal"}, {"source": "./HistorianToneSelector", "specifiers": ["HistorianToneSelector"], "category": "internal"}, {"source": "./HistorianEditionComparison", "specifiers": ["HistorianEditionComparison"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale"], "category": "external"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useProminenceScale"], "category": "internal"}, {"source": "../hooks/useEntityCrud", "specifiers": ["useEntityCrud"], "category": "internal"}, {"source": "../hooks/useHistorianActions", "specifiers": ["useHistorianActions"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "./HistoryCompressionPreviewModal", "specifiers": ["HistoryCompressionPreviewModal"], "category": "internal"}, {"source": "./BackrefImageEditor", "specifiers": ["BackrefImageEditor"], "category": "internal"}, {"source": "react-markdown", "specifiers": ["ReactMarkdown"], "category": "external"}, {"source": "remark-gfm", "specifiers": ["remarkGfm"], "category": "external"}, {"source": "./EntityDetailView.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx", "sourceCode": "export default function EntityGuidanceEditor({\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}) {\n  const entities = useEntityNavList();\n  const entityNavItems = useEntityNavItems();\n  const [selectedType, setSelectedType] = useState(\"description\");\n  const [selectedKind, setSelectedKind] = useState(\"npc\");\n  const [selectedEntityId, setSelectedEntityId] = useState(\"\");\n  const [showVisualSteps, setShowVisualSteps] = useState(false);\n  const [selectedFullEntity, setSelectedFullEntity] = useState(null);\n\n  // Use external entity guidance or default\n  const entityGuidance = useMemo(\n    () => externalEntityGuidance || createDefaultEntityGuidance(),\n    [externalEntityGuidance]\n  );\n\n  // Empty culture identities for preview (editing happens in VisualIdentityPanel)\n  const cultureIdentities = useMemo(() => createDefaultCultureIdentities(), []);\n\n  // Get entity kinds from schema\n  const entityKinds = useMemo(() => {\n    return worldSchema?.entityKinds || [];\n  }, [worldSchema]);\n\n  // Auto-select first kind if none selected\n  useMemo(() => {\n    if (!selectedKind && entityKinds.length > 0) {\n      setSelectedKind(entityKinds[0].kind);\n    }\n  }, [selectedKind, entityKinds]);\n\n  const prominenceScale = useProminenceScale();\n  const notableThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"recognized\", prominenceScale),\n    [prominenceScale]\n  );\n  const renownedThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"renowned\", prominenceScale),\n    [prominenceScale]\n  );\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominentByCulture = useMemo(() => {\n    const map = new Map();\n    for (const entity of entities) {\n      if (!entity.culture) continue;\n      if (entity.prominence < notableThreshold) continue;\n      const entry = { id: entity.id, name: entity.name };\n      const existing = map.get(entity.culture);\n      if (existing) {\n        existing.push(entry);\n      } else {\n        map.set(entity.culture, [entry]);\n      }\n    }\n    return map;\n  }, [entities, notableThreshold]);\n\n  // Get example entities for preview, filtered by selected kind\n  const exampleEntities = useMemo(() => {\n    if (!entities || entities.length === 0) return [];\n    return entities.filter((e) => e.kind === selectedKind).slice(0, 10);\n  }, [entities, selectedKind]);\n\n  const selectedNavEntity = useMemo(() => {\n    if (!selectedEntityId) return exampleEntities[0] || null;\n    return entities.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, entities, exampleEntities]);\n\n  // Load full entity for preview (needs description, tags, visualThesis, etc.)\n  useEffect(() => {\n    const entityId = selectedNavEntity?.id;\n    if (entityId) {\n      useEntityStore.getState().loadEntity(entityId).then(setSelectedFullEntity);\n    } else {\n      setSelectedFullEntity(null);\n    }\n  }, [selectedNavEntity?.id]);\n\n  // Use full entity for context building, fall back to nav entity for display\n  const selectedEntity = selectedFullEntity || selectedNavEntity;\n\n  const selectedRelationships = useMemo(() => {\n    if (!selectedEntity) return [];\n    return resolveRelationships(selectedEntity, entityNavItems, relationshipsByEntity);\n  }, [selectedEntity, entityNavItems, relationshipsByEntity]);\n\n  // Get current guidance for selected kind\n  const currentGuidance = useMemo(() => {\n    return entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n  }, [entityGuidance, selectedKind]);\n\n  // Build live preview\n  const preview = useMemo(() => {\n    // Derive flat values from structured fields for entity description prompts\n    const wc = {\n      name: worldContext?.name || \"[World Name]\",\n      description: worldContext?.description || \"[World description not set]\",\n      toneFragments: worldContext?.toneFragments || { core: \"\" },\n      canonFactsWithMetadata: worldContext?.canonFactsWithMetadata || [],\n    };\n\n    const entityContext = buildEntityContext(\n      selectedEntity,\n      prominentByCulture,\n      entityNavItems,\n      relationshipsByEntity,\n      simulationMetadata,\n      renownedThreshold\n    );\n\n    if (selectedType === \"description\") {\n      return buildDescriptionPromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext\n      );\n    } else {\n      return buildImagePromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext,\n        {} // No style info for preview\n      );\n    }\n  }, [\n    entityGuidance,\n    cultureIdentities,\n    selectedType,\n    selectedKind,\n    selectedEntity,\n    worldContext,\n    prominentByCulture,\n    entityNavItems,\n    relationshipsByEntity,\n    simulationMetadata,\n    renownedThreshold,\n  ]);\n\n  // Handle guidance changes\n  const handleSectionChange = useCallback(\n    (sectionKey, value) => {\n      if (!onEntityGuidanceChange) return;\n\n      // Get current guidance or create default\n      const currentKindGuidance =\n        entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n\n      // Update the specific field (handles nested paths like 'visualThesis.domain')\n      const updatedKindGuidance = setNestedValue(currentKindGuidance, sectionKey, value);\n\n      // Update the full entity guidance\n      const newEntityGuidance = {\n        ...entityGuidance,\n        [selectedKind]: updatedKindGuidance,\n      };\n\n      onEntityGuidanceChange(newEntityGuidance);\n    },\n    [entityGuidance, selectedKind, onEntityGuidanceChange]\n  );\n\n  // Reset when switching kinds - use entity of that kind for preview\n  const handleKindSelect = useCallback((kind) => {\n    setSelectedKind(kind);\n    setSelectedEntityId(\"\"); // Reset to first entity of new kind\n  }, []);\n\n  return (\n    <div className=\"illuminator-template-editor\">\n      {/* Header Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Entity Guidance</h2>\n          <span className=\"illuminator-card-subtitle\">\n            Configure per-kind instructions for entity descriptions and images\n          </span>\n        </div>\n\n        {/* Task Type Tabs */}\n        <div className=\"illuminator-prompt-tabs\">\n          {TASK_TYPES.map((type) => (\n            <button\n              key={type.id}\n              onClick={() => setSelectedType(type.id)}\n              className={`illuminator-prompt-tab ${selectedType === type.id ? \"active\" : \"\"}`}\n            >\n              <span>{type.icon}</span>\n              <span>{type.label}</span>\n            </button>\n          ))}\n        </div>\n\n        {/* Kind Selector */}\n        {entityKinds.length > 0 && (\n          <div className=\"illuminator-template-kind-section\">\n            <div className=\"illuminator-template-kind-header\">\n              <span className=\"illuminator-label\">Entity Kind</span>\n            </div>\n            <KindSelector\n              kinds={entityKinds}\n              selectedKind={selectedKind}\n              onSelectKind={handleKindSelect}\n            />\n          </div>\n        )}\n      </div>\n\n      {/* Editor Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            {selectedKind} {selectedType === \"description\" ? \"Description\" : \"Image\"} Settings\n          </h2>\n        </div>\n\n        {selectedType === \"description\" ? (\n          // Description editing - Focus + Relationship Guidance + Prose Hint\n          <div className=\"illuminator-template-sections\">\n            {DESCRIPTION_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Info about world tone */}\n            <div className=\"illuminator-template-info-box\">\n              <strong>Note:</strong> The world&apos;s tone and style guidance from the Context tab is\n              automatically included in all description prompts. The Focus field above should\n              contain only entity-specific instructions.\n            </div>\n          </div>\n        ) : (\n          // Image editing\n          <div className=\"illuminator-template-sections\">\n            {IMAGE_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Visual Step Overrides */}\n            <div className=\"illuminator-template-visual-steps\">\n              <button\n                className=\"illuminator-template-visual-steps-toggle\"\n                onClick={() => setShowVisualSteps(!showVisualSteps)}\n              >\n                <span>{showVisualSteps ? \"\\u25BC\" : \"\\u25B6\"}</span>\n                <span>Visual Generation Steps</span>\n                <span className=\"illuminator-template-visual-steps-hint\">\n                  Configure thesis/traits prompts for this kind\n                </span>\n              </button>\n              {showVisualSteps && (\n                <div className=\"illuminator-template-visual-steps-content\">\n                  {VISUAL_STEP_SECTIONS.map((section) => (\n                    <TemplateSection\n                      key={section.key}\n                      section={section}\n                      value={getNestedValue(currentGuidance, section.key)}\n                      onChange={handleSectionChange}\n                    />\n                  ))}\n                  <div className=\"illuminator-template-visual-steps-info\">\n                    These prompts control the 3-step visual generation chain: Description \u2192 Visual\n                    Thesis \u2192 Visual Traits. The thesis provides the primary silhouette feature;\n                    traits add supporting details.\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Live Preview Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Live Preview</h2>\n          {exampleEntities.length > 0 && (\n            <select\n              value={selectedEntityId}\n              onChange={(e) => setSelectedEntityId(e.target.value)}\n              className=\"illuminator-select ege-preview-select\"\n            >\n              <option value=\"\">\n                {exampleEntities[0]?.name || \"Example\"} ({exampleEntities[0]?.subtype})\n              </option>\n// ... (truncated)", "parameters": [{"name": "{\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}", "type": "{ entityGuidance: any; onEntityGuidanceChange: any; worldContext: any; worldSchema: any; simulationMetadata: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["LocalTextArea"], "category": "external"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList", "useEntityNavItems"], "category": "internal"}, {"source": "../lib/db/entityStore", "specifiers": ["useEntityStore"], "category": "internal"}, {"source": "../lib/db/relationshipSelectors", "specifiers": ["useRelationshipsByEntity"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["buildDescriptionPromptFromGuidance", "buildImagePromptFromGuidance", "createDefaultEntityGuidance", "createDefaultCultureIdentities"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["prominenceLabelFromScale", "prominenceThresholdFromScale"], "category": "external"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useProminenceScale"], "category": "internal"}, {"source": "./EntityGuidanceEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx", "sourceCode": "export default function EntityLinkPicker({ onSelect, onClose }) {\n  const entities = useEntityNavList();\n  const [search, setSearch] = useState(\"\");\n\n  const filteredEntities = useMemo(() => {\n    if (!entities?.length) return [];\n\n    const searchLower = search.toLowerCase();\n    return entities\n      .filter((entity) => {\n        if (!search) return true;\n        return (\n          entity.name.toLowerCase().includes(searchLower) ||\n          entity.kind.toLowerCase().includes(searchLower) ||\n          (entity.subtype && entity.subtype.toLowerCase().includes(searchLower))\n        );\n      })\n      .slice(0, 50); // Limit results for performance\n  }, [entities, search]);\n\n  const handleSelect = (entity) => {\n    onSelect(`[[${entity.name}]]`);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Entity Link\" className=\"entity-link-picker-modal\">\n      <input\n        type=\"text\"\n        value={search}\n        onChange={(e) => setSearch(e.target.value)}\n        placeholder=\"Search entities...\"\n        className=\"static-page-search-input\"\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus\n      />\n\n      <div className=\"entity-link-list\">\n        {filteredEntities.length === 0 ? (\n          <div className=\"entity-link-empty\">\n            {search ? \"No entities match your search\" : \"No entities available\"}\n          </div>\n        ) : (\n          filteredEntities.map((entity) => (\n            <button\n              key={entity.id}\n              className=\"entity-link-item\"\n              onClick={() => handleSelect(entity)}\n            >\n              <span className=\"entity-link-name\">{entity.name}</span>\n              <span className=\"entity-link-meta\">\n                {entity.subtype || entity.kind}\n                {entity.culture && ` \u2022 ${entity.culture}`}\n              </span>\n            </button>\n          ))\n        )}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ onSelect, onClose }", "type": "{ onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EntityRenameModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityRenameModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Main Modal\n// ---------------------------------------------------------------------------\n\nexport default function EntityRenameModal({\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}: Readonly<EntityRenameModalProps>) {\n  const navEntities = useEntityNavList();\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const entity = useMemo(() => navEntities.find((e) => e.id === entityId), [navEntities, entityId]);\n\n  const isPatch = mode === \"patch\";\n\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [addOldNameAsAlias, setAddOldNameAsAlias] = useState(true);\n  // In patch mode: newName = entity.name (current, correct), oldNameInput = user-entered stale name\n  const [newName, setNewName] = useState(isPatch ? entity?.name || \"\" : \"\");\n  const [oldNameInput, setOldNameInput] = useState(\n    isPatch ? entityId.replace(/-/g, \" \").replace(/\\b\\w/g, (c) => c.toUpperCase()) : \"\"\n  );\n  const [scanResult, setScanResult] = useState<RenameScanResult | null>(null);\n  const [decisions, setDecisions] = useState<Map<string, DecisionState>>(new Map());\n  const [expandedSources, setExpandedSources] = useState<Set<string>>(new Set());\n  const [applyProgress, setApplyProgress] = useState(\"\");\n  const [applyResult, setApplyResult] = useState(\"\");\n  const [isRolling, setIsRolling] = useState(false);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [phase]);\n\n  // --- Name rolling ---\n  const handleRollName = useCallback(async () => {\n    if (!entity?.culture) return;\n    const cultureDef = cultures.find((c) => c.id === entity.culture);\n    if (!cultureDef) return;\n    const culture = toCulture(cultureDef);\n    if (!culture) return;\n\n    setIsRolling(true);\n    try {\n      const result = await generate(culture, {\n        kind: entity.kind,\n        subtype: entity.subtype,\n        count: 1,\n        seed: `rename-${Date.now()}`,\n      });\n      if (result.names.length > 0) {\n        setNewName(result.names[0]);\n      }\n    } catch (err) {\n      console.warn(\"[EntityRename] Name generation failed:\", err);\n    } finally {\n      setIsRolling(false);\n    }\n  }, [entity, cultures]);\n\n  // --- Scanning ---\n  const scanOldName = isPatch ? oldNameInput.trim() : entity.name;\n\n  const handleScan = useCallback(async () => {\n    if (isPatch ? !oldNameInput.trim() : !newName.trim()) return;\n    setPhase(\"scanning\");\n\n    console.log(\"[EntityRenameModal] handleScan starting\", {\n      scanOldName,\n      newName,\n      narrativeEventCount: narrativeEvents?.length ?? 0,\n    });\n\n    // Sample a narrative event to check if it has patched or original text\n    if (narrativeEvents && narrativeEvents.length > 0) {\n      const sample = narrativeEvents[0];\n      console.log(\"[EntityRenameModal] Sample narrative event\", {\n        id: sample.id,\n        description: sample.description?.substring(0, 200),\n        action: sample.action?.substring(0, 200),\n        hasSimulationRunId: \"simulationRunId\" in sample,\n      });\n    }\n\n    try {\n      const [chronicles, fullEntities] = await Promise.all([\n        getChroniclesForSimulation(simulationRunId),\n        entityRepo.getEntitiesForRun(simulationRunId),\n      ]);\n      const result = scanForReferences(\n        entityId,\n        scanOldName,\n        fullEntities,\n        chronicles,\n        relationships,\n        narrativeEvents\n      );\n      // Filter out no-op matches where the matched text already equals the new name\n      const effectiveName = isPatch ? entity.name : newName;\n      result.matches = result.matches.filter(\n        (m) => m.matchType === \"id_slug\" || m.matchedText !== effectiveName\n      );\n\n      console.log(\"[EntityRenameModal] Scan result\", {\n        totalMatches: result.matches.length,\n        eventMatches: result.matches.filter((m) => m.sourceType === \"event\").length,\n      });\n      setScanResult(result);\n\n      // Initialize decisions: accept for full+metadata, reject for partial.\n      // id_slug matches are informational only \u2014 no decision needed.\n      const initial = new Map<string, DecisionState>();\n      for (const match of result.matches) {\n        if (match.matchType === \"id_slug\") continue;\n        initial.set(match.id, {\n          action: match.matchType === \"partial\" ? \"reject\" : \"accept\",\n          editText: newName,\n        });\n      }\n      setDecisions(initial);\n\n      // Self entity starts expanded\n      setExpandedSources(new Set([entityId]));\n      setPhase(\"preview\");\n    } catch (err) {\n      console.error(\"[EntityRename] Scan failed:\", err);\n      setPhase(\"input\");\n    }\n  }, [\n    newName,\n    oldNameInput,\n    isPatch,\n    scanOldName,\n    entity,\n    entityId,\n    simulationRunId,\n    relationships,\n    narrativeEvents,\n  ]);\n\n  // --- Decision handling ---\n  const handleChangeAction = useCallback(\n    (matchId: string, action: DecisionAction) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"reject\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, action });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  const handleChangeEditText = useCallback(\n    (matchId: string, text: string) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"edit\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, editText: text });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  // --- Bulk actions (global) ---\n  const handleAcceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const [id, state] of next) {\n        next.set(id, { ...state, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectAllPartials = useCallback(() => {\n    if (!scanResult) return;\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const match of scanResult.matches) {\n        if (match.matchType === \"partial\") {\n          const current = next.get(match.id);\n          if (current) {\n            next.set(match.id, { ...current, action: \"reject\" });\n          }\n        }\n      }\n      return next;\n    });\n  }, [scanResult]);\n\n  // --- Bulk actions (per-source) ---\n  const handleAcceptSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"reject\" });\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Expand/collapse ---\n  const toggleSource = useCallback((sourceId: string) => {\n    setExpandedSources((prev) => {\n      const next = new Set(prev);\n      if (next.has(sourceId)) {\n        next.delete(sourceId);\n      } else {\n        next.add(sourceId);\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    if (!scanResult) return;\n    setPhase(\"applying\");\n\n    try {\n      const decisionArray: MatchDecision[] = [];\n      for (const [matchId, state] of decisions) {\n        decisionArray.push({\n          matchId,\n          action: state.action,\n          editText: state.action === \"edit\" ? state.editText : undefined,\n        });\n      }\n\n      setApplyProgress(\"Building patches...\");\n      const patches = buildRenamePatches(scanResult, newName, decisionArray);\n      console.log(\"[EntityRenameModal] Built patches\", {\n        entityPatchCount: patches.entityPatches.length,\n        eventPatchCount: patches.eventPatches.length,\n        chroniclePatchCount: patches.chroniclePatches.length,\n        eventPatchIds: patches.eventPatches.map((p) => p.eventId),\n        eventPatchKeys: patches.eventPatches.map((p) => Object.keys(p.changes)),\n      });\n\n      // Apply chronicle patches directly (chronicles have their own IDB store)\n      let chronicleCount = 0;\n      if (patches.chroniclePatches.length > 0) {\n        setApplyProgress(`Updating ${patches.chroniclePatches.length} chronicles...`);\n        chronicleCount = await applyChroniclePatches(\n          patches.chroniclePatches,\n          getChronicle,\n          putChronicle\n        );\n      }\n\n      setApplyProgress(`Persisting ${patches.entityPatches.length} entity patches...`);\n\n      const parts = [`${patches.entityPatches.length} entities`, `${chronicleCount} chronicles`];\n      if (patches.eventPatches.length > 0) {\n        parts.push(`${patches.eventPatches.length} events`);\n      }\n      setApplyResult(`Updated ${parts.join(\", \")}.`);\n\n      // Pass patch manifest to parent \u2014 parent handles Dexie persistence\n      onApply({\n        entityPatches: patches.entityPatches,\n        eventPatches: patches.eventPatches,\n        targetEntityId: isPatch ? null : entityId,\n        newName,\n        addOldNameAsAlias: isPatch ? false : addOldNameAsAlias,\n      });\n      setPhase(\"done\");\n    } catch (err) {\n      console.error(\"[EntityRename] Apply failed:\", err);\n      setApplyProgress(`Error: ${err}`);\n    }\n  }, [scanResult, decisions, newName, entityId, onApply, isPatch, addOldNameAsAlias]);\n\n// ... (truncated)", "parameters": [{"name": "{\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}", "type": "Readonly<EntityRenameModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["* as entityRepo"], "category": "internal"}, {"source": "../lib/db/relationshipSelectors", "specifiers": ["useRelationships"], "category": "internal"}, {"source": "../lib/db/narrativeEventSelectors", "specifiers": ["useNarrativeEvents"], "category": "internal"}, {"source": "name-forge", "specifiers": ["generate"], "category": "external"}, {"source": "../lib/chronicle/nameBank", "specifiers": ["toCulture"], "category": "internal"}, {"source": "../lib/entityRename", "specifiers": ["scanForReferences", "buildRenamePatches", "applyChroniclePatches", "adjustReplacementForGrammar", "RenameMatch", "MatchDecision", "RenameScanResult", "EntityPatch", "EventPatch"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChroniclesForSimulation", "getChronicle", "putChronicle"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["CultureDefinition"], "category": "external"}, {"source": "./EntityRenameModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx", "sourceCode": "export default function EraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [tone, setTone] = useState(\"witty\");\n  const [arcDirection, setArcDirection] = useState(\"\");\n  const [existingNarratives, setExistingNarratives] = useState([]);\n  const [previousEraThesis, setPreviousEraThesis] = useState(null);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const {\n    narrative,\n    isActive,\n    startNarrative,\n    startHeadless,\n    resumeNarrative,\n    advanceStep,\n    skipEdit,\n    rerunCopyEdit,\n    deleteVersion,\n    setActiveVersion,\n    cancel\n  } = useEraNarrative(onEnqueue);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Access world context stores (must be before effects that reference it)\n  const eraTemporalInfo = useEraTemporalInfo();\n\n  // Check for existing narratives when era selection changes + look up previous era thesis\n  useEffect(() => {\n    if (!selectedEraId || !simulationRunId) {\n      setExistingNarratives([]);\n      setPreviousEraThesis(null);\n      return;\n    }\n    getEraNarrativesForEra(simulationRunId, selectedEraId).then(records => {\n      // Show non-complete records (resumable) and recent completed ones\n      const resumable = records.filter(r => r.status !== \"cancelled\").sort((a, b) => b.updatedAt - a.updatedAt);\n      setExistingNarratives(resumable);\n    });\n\n    // Look up thesis from previous era's completed narrative\n    const focalInfo = eraTemporalInfo.find(e => e.id === selectedEraId);\n    const focalOrder = focalInfo?.order ?? -1;\n    const prevInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    if (prevInfo) {\n      getEraNarrativesForEra(simulationRunId, prevInfo.id).then(prevRecords => {\n        const completed = prevRecords.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n        setPreviousEraThesis(completed.length > 0 ? {\n          eraName: prevInfo.name,\n          thesis: completed[0].threadSynthesis.thesis\n        } : null);\n      });\n    } else {\n      setPreviousEraThesis(null);\n    }\n  }, [selectedEraId, simulationRunId, eraTemporalInfo]);\n\n  // Group chronicles by era and count prep coverage\n  const eraOptions = useMemo(() => {\n    return wizardEras.map(era => {\n      const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n      const preppedCount = eraChronicles.filter(c => c.hasHistorianPrep).length;\n      return {\n        id: era.id,\n        name: era.name,\n        count: eraChronicles.length,\n        preppedCount\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n  const selectedEra = eraOptions.find(e => e.id === selectedEraId);\n\n  // Build a weight lookup from the live style library (record snapshots may be stale)\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Chronicles for the selected era \u2014 for the setup enumeration\n  const eraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems.filter(c => c.focalEraName === era.name).sort((a, b) => (a.eraYear ?? Infinity) - (b.eraYear ?? Infinity));\n  }, [chronicleItems, wizardEras, selectedEraId, selectedEra]);\n\n  // Build the narrative config (shared by interactive and headless start)\n  const buildConfig = useCallback(async () => {\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return null;\n\n    // Load prep briefs from chronicles in this era\n    const store = useChronicleStore.getState();\n    const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n    const prepBriefs = [];\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record?.historianPrep) continue;\n      prepBriefs.push({\n        chronicleId: record.chronicleId,\n        chronicleTitle: record.title || item.name,\n        eraYear: record.eraYear,\n        weight: record.narrativeStyle?.eraNarrativeWeight || narrativeWeightMap[record.narrativeStyleId] || undefined,\n        prep: record.historianPrep\n      });\n    }\n\n    // Build world-level context\n    const configStore = useIlluminatorConfigStore.getState();\n    const worldDynamics = configStore.worldContext?.worldDynamics || [];\n    const cultureIds = configStore.cultureIdentities || {};\n\n    // Resolve dynamics for focal era \u2014 only include dynamics that have an override for this era\n    const resolvedDynamics = worldDynamics.filter(d => d.eraOverrides?.[era.id]).map(d => {\n      const override = d.eraOverrides[era.id];\n      return override.replace ? override.text : `${d.text || \"\"} ${override.text}`;\n    }).filter(Boolean);\n\n    // Find focal + adjacent eras from temporal info\n    const focalEraInfo = eraTemporalInfo.find(e => e.id === era.id);\n    const focalOrder = focalEraInfo?.order ?? -1;\n    const previousEraInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    const nextEraInfo = eraTemporalInfo.find(e => e.order === focalOrder + 1);\n    const toSummary = info => info ? {\n      id: info.id,\n      name: info.name,\n      summary: info.summary || \"\"\n    } : undefined;\n\n    // Look up the previous era's completed narrative thesis for continuity\n    let previousEraThesis;\n    if (previousEraInfo) {\n      const prevNarratives = await getEraNarrativesForEra(simulationRunId, previousEraInfo.id);\n      const completedPrev = prevNarratives.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n      if (completedPrev.length > 0) {\n        previousEraThesis = completedPrev[0].threadSynthesis.thesis;\n      }\n    }\n    const worldContext = focalEraInfo ? {\n      focalEra: toSummary(focalEraInfo),\n      previousEra: toSummary(previousEraInfo),\n      nextEra: toSummary(nextEraInfo),\n      previousEraThesis,\n      resolvedDynamics,\n      culturalIdentities: cultureIds\n    } : undefined;\n    return {\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      tone,\n      arcDirection: arcDirection.trim() || undefined,\n      historianConfig,\n      prepBriefs,\n      worldContext\n    };\n  }, [selectedEraId, wizardEras, chronicleItems, projectId, simulationRunId, historianConfig, tone, arcDirection, eraTemporalInfo]);\n\n  // Start interactive narrative\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startNarrative(config);\n  }, [selectedEra, buildConfig, startNarrative]);\n\n  // Start headless narrative (all steps, no pauses)\n  const handleStartHeadless = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startHeadless(config);\n  }, [selectedEra, buildConfig, startHeadless]);\n\n  // Resume an existing narrative\n  const handleResume = useCallback(async narrativeId => {\n    await resumeNarrative(narrativeId);\n  }, [resumeNarrative]);\n\n  // Delete an existing narrative from the list\n  const handleDeleteExisting = useCallback(async narrativeId => {\n    await deleteEraNarrative(narrativeId);\n    setExistingNarratives(prev => prev.filter(r => r.narrativeId !== narrativeId));\n  }, []);\n  const handleClose = useCallback(() => {\n    if (isActive && narrative?.status !== \"complete\") {\n      if (narrative?.status === \"generating\" || narrative?.status === \"pending\") {\n        // Minimize instead of closing \u2014 keep isOpen true so pill can restore\n        useFloatingPillStore.getState().minimize({\n          id: PILL_ID,\n          label: `Era: ${narrative?.eraName || \"Narrative\"}`,\n          statusText: narrative?.currentStep || \"Working\",\n          statusColor: \"#f59e0b\",\n          tabId: \"chronicle\"\n        });\n        return;\n      }\n      cancel();\n    }\n    onClose();\n  }, [isActive, narrative, cancel, onClose]);\n\n  // Update pill status when state changes while minimized\n  useEffect(() => {\n    if (!isMinimized || !narrative) return;\n    const stepLabel = {\n      threads: \"Threads\",\n      generate: \"Writing\",\n      edit: \"Editing\"\n    };\n    let statusColor;\n    if (narrative.status === \"generating\" || narrative.status === \"pending\") statusColor = \"#f59e0b\";else if (narrative.status === \"step_complete\") statusColor = \"#3b82f6\";else if (narrative.status === \"complete\") statusColor = \"#10b981\";else if (narrative.status === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    let statusText;\n    if (narrative.status === \"complete\") statusText = \"Complete\";else if (narrative.status === \"failed\") statusText = \"Failed\";else statusText = stepLabel[narrative.currentStep] || narrative.currentStep;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, narrative?.status, narrative?.currentStep]);\n\n  // Clean up pill when process reaches terminal state\n  useEffect(() => {\n    if (!narrative || narrative.status === \"complete\" || narrative.status === \"failed\" || narrative.status === \"cancelled\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [narrative?.status]);\n\n  // Sync narrativeId to modal store so it survives ChroniclePanel unmount\n  useEffect(() => {\n    if (narrative?.narrativeId) {\n      useIlluminatorModals.getState().setEraNarrativeId(narrative.narrativeId);\n    }\n  }, [narrative?.narrativeId]);\n\n  // Auto-resume from store when modal re-mounts with a stored narrativeId\n  useEffect(() => {\n    if (isOpen && resumeNarrativeId && !isActive && !narrative) {\n      resumeNarrative(resumeNarrativeId);\n    }\n  }, [isOpen, resumeNarrativeId, isActive, narrative, resumeNarrative]);\n\n  // Resolve thread names for movement display (must be before early return)\n  const synthesis = narrative?.threadSynthesis;\n  const threadNameMap = useMemo(() => {\n    if (!synthesis) return {};\n    const map = {};\n    for (const t of synthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [synthesis]);\n\n  // Resolve versioned content from the narrative record\n  const resolved = useMemo(() => {\n    if (!narrative) return {\n      content: undefined,\n      versions: [],\n      activeVersionId: undefined\n    };\n    return resolveActiveContent(narrative);\n  }, [narrative]);\n\n  // Sync selectedVersionId to activeVersionId when versions change\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      // Reset selection when active version changes (e.g., after re-run edit completes)\n      // or when no version is selected yet\n      if (!selectedVersionId || !resolved.versions.some(v => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n  if (!isOpen) return null;\n  if (isMinimized) return null;\n  const isGenerating = narrative?.status === \"pending\" || narrative?.status === \"generating\";\n  const isStepComplete = narrative?.status === \"step_complete\";\n  const isFailed = narrative?.status === \"failed\";\n  const isComplete = narrative?.status === \"complete\";\n  const narrativeContent = narrative?.narrative;\n\n  // Currently viewed version (for version selector)\n  const viewedVersion = resolved.versions.find(v => v.versionId === selectedVersionId) || resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // Determine what to show\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; resumeNarrativeId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../hooks/useEraNarrative", "specifiers": ["useEraNarrative"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useEraTemporalInfo"], "category": "internal"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["getEraNarrativesForEra", "deleteEraNarrative", "resolveActiveContent"], "category": "internal"}, {"source": "./EraNarrativeModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx", "sourceCode": "export default function EraNarrativeViewer({\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}: Readonly<EraNarrativeViewerProps>) {\n  const [record, setRecord] = useState<EraNarrativeRecord | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [showThreads, setShowThreads] = useState(false);\n  const [showBriefs, setShowBriefs] = useState(false);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState<string | null>(null);\n  const [showInsertion, setShowInsertion] = useState(false);\n  const [insertionText, setInsertionText] = useState(\"\");\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const pollReasonRef = useRef<\"edit\" | \"cover_image\" | \"image_refs\" | null>(null);\n\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Load record from IndexedDB\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getEraNarrative(narrativeId).then((r) => {\n      if (cancelled) return;\n      setRecord(r ?? null);\n      setLoading(false);\n      setSelectedVersionId(\"\");\n      setConfirmingDeleteId(null);\n      setInsertionText(r?.editInsertion || \"\");\n      // Resume polling if record is stuck in a generating state\n      if (r && (r.status === \"pending\" || r.status === \"generating\")) {\n        startPolling(\"edit\");\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [narrativeId]);\n\n  // Stop polling helper\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Poll while generating (for re-run copy edit, cover image, image refs)\n  const startPolling = useCallback(\n    (reason: \"edit\" | \"cover_image\" | \"image_refs\" = \"edit\") => {\n      stopPolling();\n      pollReasonRef.current = reason;\n      const snapshotCoverImage = record?.coverImage;\n      const snapshotImageRefs = record?.imageRefs;\n\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getEraNarrative(narrativeId);\n          if (!updated) return;\n          setRecord(updated);\n\n          const r = pollReasonRef.current;\n\n          // Edit polling: stop on terminal states or step_complete\n          if (r === \"edit\") {\n            if (\n              updated.status === \"complete\" ||\n              updated.status === \"failed\" ||\n              updated.status === \"step_complete\"\n            ) {\n              if (updated.status === \"step_complete\" && updated.currentStep === \"edit\") {\n                await updateEraNarrative(updated.narrativeId, { status: \"complete\" });\n                const final = await getEraNarrative(narrativeId);\n                if (final) setRecord(final);\n              }\n              stopPolling();\n            }\n            return;\n          }\n\n          // Cover image polling: stop when coverImage appears or changes\n          if (r === \"cover_image\") {\n            const hasCover = updated.coverImage?.sceneDescription;\n            const hadCover = snapshotCoverImage?.sceneDescription;\n            if (hasCover && hasCover !== hadCover) {\n              stopPolling();\n            }\n            return;\n          }\n\n          // Image refs polling: stop when imageRefs appears or changes\n          if (r === \"image_refs\") {\n            const hasRefs = updated.imageRefs?.generatedAt;\n            const hadRefs = snapshotImageRefs?.generatedAt;\n            if (hasRefs && hasRefs !== hadRefs) {\n              stopPolling();\n            }\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [narrativeId, stopPolling, record?.coverImage, record?.imageRefs]\n  );\n\n  const threadNameMap = useMemo(() => {\n    if (!record?.threadSynthesis) return {};\n    const map: Record<string, string> = {};\n    for (const t of record.threadSynthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [record?.threadSynthesis]);\n\n  // Resolve versioned content\n  const resolved = useMemo(() => {\n    if (!record) return { content: undefined, versions: [], activeVersionId: undefined };\n    return resolveActiveContent(record);\n  }, [record]);\n\n  // Sync selectedVersionId to activeVersionId\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      if (!selectedVersionId || !resolved.versions.some((v) => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n\n  const viewedVersion =\n    resolved.versions.find((v) => v.versionId === selectedVersionId) ||\n    resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // =========================================================================\n  // Actions\n  // =========================================================================\n\n  const handleExport = useCallback(() => {\n    if (!record) return;\n    try {\n      downloadEraNarrativeExport(record);\n    } catch (err) {\n      console.error(\"[EraNarrativeViewer] Export failed:\", err);\n    }\n  }, [record]);\n\n  const handleRerunCopyEdit = useCallback(async () => {\n    if (!record) return;\n    await updateEraNarrative(record.narrativeId, {\n      status: \"pending\",\n      currentStep: \"edit\",\n      editInsertion: insertionText || undefined,\n    });\n    setSelectedVersionId(\"\");\n\n    onEnqueue([\n      {\n        entity: SENTINEL_ENTITY,\n        type: \"eraNarrative\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: record.narrativeId,\n      },\n    ]);\n\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n    startPolling();\n  }, [record, onEnqueue, startPolling, insertionText]);\n\n  const handleForceComplete = useCallback(async () => {\n    if (!record) return;\n    stopPolling();\n    await updateEraNarrative(record.narrativeId, { status: \"complete\" });\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n  }, [record, stopPolling]);\n\n  const handleDeleteVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await deleteEraNarrativeVersion(record.narrativeId, versionId);\n      setRecord(updated);\n      setConfirmingDeleteId(null);\n      if (updated.activeVersionId) setSelectedVersionId(updated.activeVersionId);\n    },\n    [record]\n  );\n\n  const handleSetActiveVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await setEraNarrativeActiveVersion(record.narrativeId, versionId);\n      setRecord(updated);\n    },\n    [record]\n  );\n\n  // =========================================================================\n  // Era Narrative Sub-Step Dispatch\n  // =========================================================================\n\n  const dispatchEraNarrativeStep = useCallback(\n    (step: string, extras?: Record<string, unknown>) => {\n      if (!record) return;\n      onEnqueue([\n        {\n          entity: SENTINEL_ENTITY,\n          type: \"eraNarrative\" as EnrichmentType,\n          prompt: \"\",\n          chronicleId: record.narrativeId,\n          eraNarrativeStep: step,\n          ...extras,\n        },\n      ]);\n    },\n    [record, onEnqueue]\n  );\n\n  // =========================================================================\n  // Cover Image Handlers\n  // =========================================================================\n\n  const handleGenerateCoverImageScene = useCallback(() => {\n    dispatchEraNarrativeStep(\"cover_image_scene\");\n    startPolling(\"cover_image\");\n  }, [dispatchEraNarrativeStep, startPolling]);\n\n  const handleGenerateCoverImage = useCallback(() => {\n    if (!record?.coverImage?.sceneDescription) return;\n\n    // Mark as generating\n    void updateEraNarrativeCoverImageStatus(record.narrativeId, \"generating\")\n      .then(() => getEraNarrative(record.narrativeId))\n      .then((updated) => {\n        if (updated) setRecord(updated);\n      });\n\n    // Build style info\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityKind: \"chronicle\",\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n    const styleInfo: StyleInfo = {\n      compositionPromptFragment:\n        \"cinematic montage composition, overlapping character silhouettes and scene elements, layered movie-poster layout, multiple focal points at different scales, dramatic depth layering, figures and settings blending into each other, NO TEXT NO TITLES NO LETTERING\",\n      artisticPromptFragment: resolved.artisticStyle?.promptFragment,\n      colorPalettePromptFragment: resolved.colorPalette?.promptFragment,\n    };\n\n    const prompt = buildChronicleScenePrompt(\n      {\n        sceneDescription: record.coverImage.sceneDescription,\n        size: \"medium\",\n        chronicleTitle: record.eraName,\n        world: worldContext\n          ? {\n              name: worldContext.name || \"Unknown World\",\n              description: worldContext.description,\n              speciesConstraint: worldContext.speciesConstraint,\n            }\n          : undefined,\n      },\n      styleInfo\n    );\n\n    onEnqueue([\n      {\n        entity: { id: \"__era_narrative__\", name: record.eraName, kind: \"era_narrative\" },\n        type: \"image\" as EnrichmentType,\n        prompt,\n        chronicleId: record.narrativeId,\n        imageRefId: \"__cover_image__\",\n        sceneDescription: record.coverImage.sceneDescription,\n        imageType: \"era_narrative\",\n        imageSize: imageSize || \"1024x1024\",\n        imageQuality: imageQuality || \"standard\",\n      },\n    ]);\n// ... (truncated)", "parameters": [{"name": "{\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}", "type": "Readonly<EraNarrativeViewerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useMemo", "useCallback", "useRef"], "category": "framework"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["getEraNarrative", "updateEraNarrative", "updateEraNarrativeCoverImageStatus", "updateEraNarrativeImageRefStatus", "updateEraNarrativeImageRefField", "resolveActiveContent", "deleteEraNarrativeVersion", "setEraNarrativeActiveVersion"], "category": "internal"}, {"source": "../lib/db/chronicleStore", "specifiers": ["useChronicleStore"], "category": "internal"}, {"source": "../lib/chronicleExport", "specifiers": ["downloadEraNarrativeExport"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["buildChronicleScenePrompt"], "category": "internal"}, {"source": "./StyleSelector", "specifiers": ["resolveStyleSelection"], "category": "internal"}, {"source": "./CoverImageControls", "specifiers": ["CoverImageControls"], "category": "internal"}, {"source": "./ChronicleImagePanel", "specifiers": ["ChronicleImagePanel"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord", "ChronicleImageRef as NarrativeChronicleRef"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["ChronicleImageRefs", "PromptRequestRef"], "category": "internal"}, {"source": "../lib/enrichmentTypes", "specifiers": ["EnrichmentType"], "category": "internal"}, {"source": "../workers/tasks/eraNarrativeTask", "specifiers": ["AvailableChronicleImage"], "category": "internal"}, {"source": "../lib/promptBuilders", "specifiers": ["StyleInfo"], "category": "internal"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./EraNarrativeViewer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/EventsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EventsPanel.jsx", "sourceCode": "export default function EventsPanel({\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}) {\n  const [significanceFilter, setSignificanceFilter] = useState(0);\n  const [kindFilter, setKindFilter] = useState(\"all\");\n  const [eraFilter, setEraFilter] = useState(\"all\");\n  const [tagFilter, setTagFilter] = useState(\"\");\n  const [expandedEvents, setExpandedEvents] = useState(new Set());\n  const [displayLimit, setDisplayLimit] = useState(DEFAULT_DISPLAY_LIMIT);\n  const events = narrativeEvents || [];\n\n  // Get unique values for filters\n  const {\n    uniqueKinds,\n    uniqueEras,\n    uniqueTags\n  } = useMemo(() => {\n    const kinds = new Set();\n    const eras = new Set();\n    const tags = new Set();\n    for (const event of events) {\n      kinds.add(event.eventKind);\n      if (event.era) eras.add(event.era);\n      for (const tag of event.narrativeTags || []) {\n        tags.add(tag);\n      }\n    }\n    return {\n      uniqueKinds: Array.from(kinds).sort(),\n      uniqueEras: Array.from(eras).sort(),\n      uniqueTags: Array.from(tags).sort()\n    };\n  }, [events]);\n\n  // Filter events\n  const filteredEvents = useMemo(() => {\n    return events.filter(event => {\n      if (event.significance < significanceFilter) return false;\n      if (kindFilter !== \"all\" && event.eventKind !== kindFilter) return false;\n      if (eraFilter !== \"all\" && event.era !== eraFilter) return false;\n      if (tagFilter && !event.narrativeTags?.includes(tagFilter)) return false;\n      return true;\n    });\n  }, [events, significanceFilter, kindFilter, eraFilter, tagFilter]);\n\n  // Sort by significance (highest first)\n  const sortedEvents = useMemo(() => {\n    return [...filteredEvents].sort((a, b) => b.significance - a.significance);\n  }, [filteredEvents]);\n\n  // Limit displayed events for performance\n  const displayedEvents = useMemo(() => {\n    return sortedEvents.slice(0, displayLimit);\n  }, [sortedEvents, displayLimit]);\n  const hasMoreEvents = sortedEvents.length > displayLimit;\n  const handleLoadMore = () => {\n    setDisplayLimit(prev => prev + LOAD_MORE_INCREMENT);\n  };\n\n  // Reset display limit when filters change\n  useEffect(() => {\n    setDisplayLimit(DEFAULT_DISPLAY_LIMIT);\n  }, [significanceFilter, kindFilter, eraFilter, tagFilter]);\n  const toggleExpanded = eventId => {\n    setExpandedEvents(prev => {\n      const next = new Set(prev);\n      if (next.has(eventId)) {\n        next.delete(eventId);\n      } else {\n        next.add(eventId);\n      }\n      return next;\n    });\n  };\n  const handleExportEvents = () => {\n    if (events.length === 0) return;\n    const json = JSON.stringify(events, null, 2);\n    const blob = new Blob([json], {\n      type: \"application/json\"\n    });\n    const url = URL.createObjectURL(blob);\n    const anchor = document.createElement(\"a\");\n    const safeRunId = simulationRunId ? simulationRunId.replace(/[^a-zA-Z0-9_-]+/g, \"_\") : \"all\";\n    anchor.href = url;\n    anchor.download = `narrative-events-${safeRunId}.json`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    anchor.remove();\n    URL.revokeObjectURL(url);\n  };\n  if (events.length === 0) {\n    return <div className=\"events-panel-empty\">\n        <div className=\"events-panel-empty-icon\">\n          <span role=\"img\" aria-label=\"events\">\n            &#x1F4DC;\n          </span>\n        </div>\n        <h3 className=\"events-panel-empty-title\">No Narrative Events</h3>\n        <p className=\"events-panel-empty-text\">\n          Narrative events are captured during simulation when &quot;Enable event tracking&quot; is turned on\n          in the Lore Weave simulation parameters.\n        </p>\n        <div className=\"events-panel-empty-instructions\">\n          <div className=\"events-panel-empty-instructions-title\">To enable event tracking:</div>\n          <ol className=\"events-panel-empty-instructions-list\">\n            <li>Go to the Lore Weave tab</li>\n            <li>Open &quot;Run Simulation&quot;</li>\n            <li>Enable &quot;Narrative Events&quot; in parameters</li>\n            <li>Run a new simulation</li>\n          </ol>\n        </div>\n      </div>;\n  }\n  return <div className=\"events-panel-root\">\n      {/* Filter bar */}\n      <div className=\"events-panel-filter-bar\">\n        <div className=\"events-panel-filter-header\">\n          <div className=\"events-panel-filter-count\">\n            {displayedEvents.length === filteredEvents.length ? `${filteredEvents.length} of ${events.length} events` : `Showing ${displayedEvents.length} of ${filteredEvents.length} filtered (${events.length} total)`}\n          </div>\n          <div className=\"events-panel-filter-actions\">\n            <div className=\"events-panel-filter-sort-label\">Sorted by significance</div>\n            <button onClick={handleExportEvents} disabled={events.length === 0} className=\"events-panel-export-btn\">\n              Export JSON\n            </button>\n          </div>\n        </div>\n\n        <div className=\"events-panel-filters-row\">\n          {/* Significance slider */}\n          <div className=\"events-panel-significance-filter\">\n            <label htmlFor=\"min-significance\" className=\"events-panel-filter-label\">Min significance:</label>\n            <input id=\"min-significance\" type=\"range\" min={0} max={1} step={0.1} value={significanceFilter} onChange={e => setSignificanceFilter(parseFloat(e.target.value))} className=\"events-panel-significance-slider\" />\n            <span className=\"events-panel-significance-value\">\n              {Math.round(significanceFilter * 100)}%\n            </span>\n          </div>\n\n          {/* Kind filter */}\n          <select value={kindFilter} onChange={e => setKindFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All kinds</option>\n            {uniqueKinds.map(kind => <option key={kind} value={kind}>\n                {kind.replace(/_/g, \" \")}\n              </option>)}\n          </select>\n\n          {/* Era filter */}\n          <select value={eraFilter} onChange={e => setEraFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All eras</option>\n            {uniqueEras.map(era => <option key={era} value={era}>\n                {entityMap?.get(era)?.name || era}\n              </option>)}\n          </select>\n\n          {/* Tag filter */}\n          {uniqueTags.length > 0 && <select value={tagFilter} onChange={e => setTagFilter(e.target.value)} className=\"events-panel-filter-select\">\n              <option value=\"\">All tags</option>\n              {uniqueTags.map(tag => <option key={tag} value={tag}>\n                  {tag}\n                </option>)}\n            </select>}\n\n          {/* Clear filters */}\n          {(significanceFilter > 0 || kindFilter !== \"all\" || eraFilter !== \"all\" || tagFilter) && <button onClick={() => {\n          setSignificanceFilter(0);\n          setKindFilter(\"all\");\n          setEraFilter(\"all\");\n          setTagFilter(\"\");\n        }} className=\"events-panel-clear-filters-btn\">\n              Clear filters\n            </button>}\n        </div>\n      </div>\n\n      {/* Events list */}\n      <div className=\"events-panel-list\">\n        {sortedEvents.length === 0 ? <div className=\"events-panel-no-match\">No events match the current filters</div> : <>\n            {displayedEvents.map(event => <EventCard key={event.id} event={event} entityMap={entityMap} expanded={expandedEvents.has(event.id)} onToggle={() => toggleExpanded(event.id)} />)}\n\n            {/* Load more button */}\n            {hasMoreEvents && <div className=\"events-panel-load-more-row\">\n                <button onClick={handleLoadMore} className=\"events-panel-load-more-btn\">\n                  Load {Math.min(LOAD_MORE_INCREMENT, sortedEvents.length - displayLimit)} more\n                  <span className=\"events-panel-load-more-remaining\">\n                    ({sortedEvents.length - displayLimit} remaining)\n                  </span>\n                </button>\n              </div>}\n          </>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}", "type": "{ narrativeEvents?: any[]; simulationRunId: any; entityMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./EventsPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/FinalEditTab.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/FinalEditTab.tsx", "sourceCode": "export default function FinalEditTab() {\n  return (\n    <div>\n      <div className=\"fet-section\">\n        <h3 className=\"fet-heading\">Corpus Find & Replace</h3>\n        <p className=\"fet-subtitle\">\n          Search and replace across chronicle content, chronicle annotations, and entity annotations\n        </p>\n      </div>\n      <CorpusFindReplace />\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./CorpusFindReplace", "specifiers": ["CorpusFindReplace"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./FinalEditTab.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx", "sourceCode": "// ============================================================================\n// Main Editor\n// ============================================================================\n\nexport default function HistorianConfigEditor({ config, onChange }) {\n  const update = useCallback(\n    (field, value) => {\n      onChange({ ...config, [field]: value });\n    },\n    [config, onChange]\n  );\n\n  const [reloadStatus, setReloadStatus] = useState(null); // null | 'confirm' | 'loading' | 'done' | 'error'\n\n  const handleReloadFromDefaults = useCallback(async () => {\n    try {\n      setReloadStatus(\"loading\");\n      const response = await fetch(\"/default-project/historianConfig.json\");\n      if (!response.ok) throw new Error(`HTTP ${response.status}`);\n      const defaultConfig = await response.json();\n      onChange(defaultConfig);\n      setReloadStatus(\"done\");\n      setTimeout(() => setReloadStatus(null), 2000);\n    } catch (err) {\n      setReloadStatus(\"error\");\n      console.error(\"Failed to reload historian config:\", err);\n      setTimeout(() => setReloadStatus(null), 3000);\n    }\n  }, [onChange]);\n\n  const isConfigured = config.name.trim().length > 0 && config.background.trim().length > 0;\n\n  return (\n    <div className=\"hce-root\">\n      {/* Header */}\n      <div className=\"hce-header\">\n        <div className=\"hce-header-top\">\n          <div className=\"hce-header-title\">Historian Persona</div>\n          <button\n            onClick={() => setReloadStatus(\"confirm\")}\n            disabled={reloadStatus === \"loading\"}\n            className=\"illuminator-button illuminator-button-secondary hce-reload-btn\"\n            title=\"Reload historian config from the default project template\"\n          >\n            {(() => {\n              if (reloadStatus === \"loading\") return \"Loading...\";\n              if (reloadStatus === \"done\") return \"Reloaded \\u2713\";\n              if (reloadStatus === \"error\") return \"Failed \\u2717\";\n              return \"Reload Defaults\";\n            })()}\n          </button>\n        </div>\n        <div className=\"hce-header-description\">\n          Define the scholarly voice behind both <strong>annotations</strong> (margin notes \u2014\n          corrections, observations, asides) and <strong>copy edits</strong> (full description\n          rewrites synthesized from the description archive). The same persona drives both\n          operations in a consistent voice across all content.\n        </div>\n        {!isConfigured && (\n          <div className=\"hce-unconfigured-notice\">\n            Configure at least a name and background to enable historian annotations and copy edits.\n          </div>\n        )}\n      </div>\n\n      {/* Fields */}\n      <div className=\"hce-fields\">\n        {/* Name */}\n        <div>\n          <FieldLabel\n            label=\"Name & Title\"\n            description='e.g., \"Aldric Fenworth, Third Archivist of the Pale Library\"'\n          />\n          <input\n            type=\"text\"\n            value={config.name}\n            onChange={(e) => update(\"name\", e.target.value)}\n            placeholder=\"Enter the historian's name and title\"\n            className=\"hce-full-input\"\n          />\n        </div>\n\n        {/* Background */}\n        <div>\n          <FieldLabel\n            label=\"Background\"\n            description=\"Credentials, institutional affiliation, era they're writing from\"\n          />\n          <textarea\n            value={config.background}\n            onChange={(e) => update(\"background\", e.target.value)}\n            placeholder=\"A seasoned archivist who has spent forty years cataloguing the histories of the realm. Has outlived most of the people described in these texts. Still shows up to work.\"\n            className=\"hce-textarea hce-textarea-bg\"\n          />\n        </div>\n\n        {/* Personality Traits */}\n        <div>\n          <FieldLabel\n            label=\"Personality Traits\"\n            description=\"Short phrases that define the historian's character \u2014 think weary, not wacky\"\n          />\n          <TagInput\n            value={config.personalityTraits}\n            onChange={(v) => update(\"personalityTraits\", v)}\n            placeholder='e.g., \"world-weary\", \"quietly compassionate\"'\n          />\n        </div>\n\n        {/* Biases */}\n        <div>\n          <FieldLabel\n            label=\"Biases & Blind Spots\"\n            description=\"What they trust, distrust, or have given up arguing about\"\n          />\n          <TagInput\n            value={config.biases}\n            onChange={(v) => update(\"biases\", v)}\n            placeholder='e.g., \"distrusts oral histories\"'\n          />\n        </div>\n\n        {/* Stance */}\n        <div>\n          <FieldLabel\n            label=\"Stance Toward Source Material\"\n            description=\"Their overall relationship to the texts they're working with\"\n          />\n          <textarea\n            value={config.stance}\n            onChange={(e) => update(\"stance\", e.target.value)}\n            placeholder='e.g., \"Has read too many of these accounts to be surprised, but still occasionally moved by the human cost of events others reduce to dates and outcomes\"'\n            className=\"hce-textarea hce-textarea-stance\"\n          />\n        </div>\n\n        {/* Private Facts */}\n        <div>\n          <FieldLabel\n            label=\"Private Facts\"\n            description=\"Things the historian knows that aren't in the canon facts. May surface in annotations and shape editorial choices in copy edits.\"\n          />\n          <ListEditor\n            value={config.privateFacts}\n            onChange={(v) => update(\"privateFacts\", v)}\n            placeholder=\"Add a fact\"\n            itemPlaceholder='e.g., \"The real cause of the Great Fire was arson, not the dragon\"'\n          />\n        </div>\n\n        {/* Running Gags */}\n        <div>\n          <FieldLabel\n            label=\"Recurring Preoccupations\"\n            description=\"Refrains, motifs, or things the historian keeps circling back to \u2014 not jokes, but patterns they can't stop noticing\"\n          />\n          <ListEditor\n            value={config.runningGags}\n            onChange={(v) => update(\"runningGags\", v)}\n            placeholder=\"Add a preoccupation\"\n            itemPlaceholder='e.g., \"The way institutions always outlive the people who built them\"'\n          />\n        </div>\n      </div>\n\n      {/* Reload confirmation modal */}\n      {reloadStatus === \"confirm\" && (\n        <div\n          className=\"hce-modal-overlay\"\n          onClick={(e) => {\n            if (e.target === e.currentTarget) setReloadStatus(null);\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <div className=\"hce-modal-box\">\n            <div className=\"hce-modal-title\">Reload from Defaults?</div>\n            <div className=\"hce-modal-body\">\n              This will overwrite your current historian configuration with the default project\n              template. Any edits you&apos;ve made will be lost.\n            </div>\n            <div className=\"hce-modal-actions\">\n              <button\n                onClick={() => setReloadStatus(null)}\n                className=\"illuminator-button illuminator-button-secondary hce-modal-btn\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={() => handleReloadFromDefaults()}\n                className=\"illuminator-button hce-modal-btn\"\n              >\n                Reload\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onChange }", "type": "{ config: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HistorianConfigEditor.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx", "sourceCode": "export default function HistorianEditionComparison({\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}: Readonly<HistorianEditionComparisonProps>) {\n  const [expanded, setExpanded] = useState(false);\n\n  const versions = useMemo(() => {\n    // Find all historian-edition and legacy-copy-edit entries with their original indices\n    const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n    const historianEntries = descriptionHistory\n      .map((entry, index) => ({ ...entry, historyIndex: index }))\n      .filter((entry) => editionSources.has(entry.source || \"\"));\n\n    if (historianEntries.length === 0) return [];\n\n    const editionVersions: EditionVersion[] = [];\n\n    // First entry = pre-historian baseline\n    const baseline = historianEntries[0];\n    editionVersions.push({\n      label: \"Pre-Historian\",\n      description: baseline.description,\n      historyIndex: baseline.historyIndex,\n      isCurrent: false,\n      wordCount: baseline.description.split(/\\s+/).length,\n      date: baseline.replacedAt ? new Date(baseline.replacedAt).toLocaleDateString() : undefined,\n    });\n\n    // Subsequent entries = prior historian/legacy outputs pushed to history when replaced\n    for (let i = 1; i < historianEntries.length; i++) {\n      const entry = historianEntries[i];\n      const isLegacy = entry.source === \"legacy-copy-edit\";\n      editionVersions.push({\n        label: `Edition ${i}${isLegacy ? \" (legacy)\" : \"\"}`,\n        description: entry.description,\n        historyIndex: entry.historyIndex,\n        isCurrent: false,\n        wordCount: entry.description.split(/\\s+/).length,\n        date: entry.replacedAt ? new Date(entry.replacedAt).toLocaleDateString() : undefined,\n      });\n    }\n\n    // Current description = latest edition\n    editionVersions.push({\n      label: `Edition ${historianEntries.length} (active)`,\n      description: currentDescription,\n      historyIndex: -1,\n      isCurrent: true,\n      wordCount: currentDescription.split(/\\s+/).length,\n    });\n\n    return editionVersions;\n  }, [descriptionHistory, currentDescription]);\n\n  // Exportable when we have 3+ versions: pre-historian baseline, at least one prior edition, and active.\n  // versions[0] = pre-historian, versions[last] = active, everything in between = prior editions.\n  const exportData = useMemo(() => {\n    if (versions.length < 3) return null;\n    const active = versions[versions.length - 1];\n    if (!active?.isCurrent) return null;\n    const data: Record<string, unknown> = {\n      preHistorian: versions[0].description,\n      legacyCopyEdit: versions[versions.length - 2].description,\n      active: active.description,\n    };\n    // Include non-disabled annotations when present\n    const activeNotes = historianNotes?.filter((n) => n.display !== \"disabled\");\n    if (activeNotes && activeNotes.length > 0) {\n      data.annotations = activeNotes.map((n) => ({\n        type: n.type,\n        display: n.display || \"full\",\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      }));\n    }\n    return data;\n  }, [versions, historianNotes]);\n\n  const [selectedIdx, setSelectedIdx] = useState(() => versions.length - 1);\n  const [compareIdx, setCompareIdx] = useState(() =>\n    versions.length > 1 ? versions.length - 2 : -1\n  );\n\n  if (versions.length < 2) return null;\n\n  const selected = versions[selectedIdx] || versions[versions.length - 1];\n  const compare = compareIdx >= 0 ? versions[compareIdx] : null;\n\n  const wordDelta = compare ? selected.wordCount - compare.wordCount : 0;\n  const deltaSign = wordDelta >= 0 ? \"+\" : \"\";\n\n  return (\n    <div className=\"hec-wrapper\">\n      <div\n        onClick={() => setExpanded(!expanded)}\n        className=\"hec-toggle\"\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <span>{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <span className=\"hec-toggle-label\">\n          Edition Comparison\n        </span>\n        <span\n          title={`${versions.length - 1} historian edition${versions.length - 1 !== 1 ? \"s\" : \"\"} + pre-historian baseline`}\n        >\n          {\"\\u25C7\"} {versions.length} versions\n        </span>\n      </div>\n\n      {expanded && (\n        <div className=\"hec-expanded\">\n          {/* Version selectors */}\n          <div className=\"hec-selector-row\">\n            <select\n              value={selectedIdx}\n              onChange={(e) => setSelectedIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-select\"\n            >\n              {versions.map((v, i) => (\n                <option key={i} value={i}>\n                  {v.label} ({v.wordCount}w){v.date ? ` \u2014 ${v.date}` : \"\"}\n                </option>\n              ))}\n            </select>\n            <select\n              value={compareIdx}\n              onChange={(e) => setCompareIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-compare-select\"\n              title=\"Select a version to diff against\"\n            >\n              <option value={-1}>Compare to...</option>\n              {versions\n                .filter((_, i) => i !== selectedIdx)\n                .map((v) => {\n                  const realIdx = versions.indexOf(v);\n                  return (\n                    <option key={realIdx} value={realIdx}>\n                      {v.label} ({v.wordCount}w)\n                    </option>\n                  );\n                })}\n            </select>\n            {selected.isCurrent ? (\n              <span className=\"hec-active-badge\">\n                Active\n              </span>\n            ) : (\n              <button\n                onClick={() => onRestoreVersion(entityId, selected.historyIndex)}\n                className=\"hec-make-active-btn\"\n              >\n                Make Active\n              </button>\n            )}\n            {exportData && (\n              <button\n                onClick={() => {\n                  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                    type: \"application/json\",\n                  });\n                  const url = URL.createObjectURL(blob);\n                  const ts = new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, 19);\n                  const a = document.createElement(\"a\");\n                  a.href = url;\n                  a.download = `edition-comparison-${entityId}-${ts}.json`;\n                  a.click();\n                  URL.revokeObjectURL(url);\n                }}\n                className=\"hec-export-btn\"\n                title=\"Export pre-historian, legacy, and active versions as JSON\"\n              >\n                Export\n              </button>\n            )}\n          </div>\n\n          {/* Word count summary */}\n          {compare && (\n            <div className=\"hec-word-summary\">\n\n              <span>\n                {\"\\u25C6\"} {selected.label}: {selected.wordCount.toLocaleString()}w\n              </span>\n              <span>\n                {\"\\u25C6\"} {compare.label}: {compare.wordCount.toLocaleString()}w\n              </span>\n              <span\n                className=\"hec-word-delta\"\n                style={{\n                  \"--hec-delta-color\":\n                    wordDelta < 0 ? \"#22c55e\" : wordDelta > 0 ? \"#f59e0b\" : \"var(--text-muted)\",\n                } as React.CSSProperties}\n              >\n                {deltaSign}\n                {wordDelta.toLocaleString()}w ({deltaSign}\n                {compare.wordCount > 0 ? Math.round((wordDelta / compare.wordCount) * 100) : 0}%)\n              </span>\n            </div>\n          )}\n\n          {/* Diff view */}\n          {compare ? (\n            <DiffView older={compare.description} newer={selected.description} />\n          ) : (\n            <div className=\"hec-text-view\">\n\n              {selected.description}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}", "type": "Readonly<HistorianEditionComparisonProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "diff", "specifiers": ["diffWords"], "category": "external"}, {"source": "./HistorianEditionComparison.css", "specifiers": [], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function HistorianMarginNotes({\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}) {\n  const counts = useMemo(() => {\n    if (!notes || notes.length === 0) return {\n      full: 0,\n      popout: 0,\n      disabled: 0\n    };\n    let full = 0,\n      popout = 0,\n      disabled = 0;\n    for (const n of notes) {\n      const d = noteDisplayMode(n);\n      if (d === \"full\") full++;else if (d === \"popout\") popout++;else disabled++;\n    }\n    return {\n      full,\n      popout,\n      disabled\n    };\n  }, [notes]);\n  if (!notes || notes.length === 0) return null;\n  const summaryParts = [];\n  if (counts.full > 0) summaryParts.push(`${counts.full} full`);\n  if (counts.popout > 0) summaryParts.push(`${counts.popout} popout`);\n  if (counts.disabled > 0) summaryParts.push(`${counts.disabled} disabled`);\n  return (\n    <div className={className || undefined}>\n      <div className=\"hmn-header\">\n        <span className=\"hmn-title\">Historian Notes</span>\n        <span className=\"hmn-summary\">{summaryParts.join(\", \")}</span>\n      </div>\n\n      {/* All notes in original order \u2014 no regrouping */}\n      {notes.map(note => <NoteItem key={note.noteId} note={note} sourceText={sourceText} onUpdateNote={onUpdateNote} />)}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}", "type": "{ notes: any; sourceText: any; className: any; onUpdateNote: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "./HistorianMarginNotes.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function HistorianReviewModal({\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}) {\n  if (!isActive || !run) return null;\n  const isGenerating = run.status === \"pending\" || run.status === \"generating\";\n  const isReviewing = run.status === \"reviewing\";\n  const isFailed = run.status === \"failed\";\n  const notes = run.notes || [];\n  const acceptedCount = notes.filter(n => run.noteDecisions[n.noteId] !== false).length;\n  return <div className=\"hrm-overlay\">\n      <div className=\"hrm-modal\">\n        {/* Header */}\n        <div className=\"hrm-modal-header\">\n          <div>\n            <div className=\"hrm-modal-title\">Historian Review &mdash; {run.targetName}</div>\n            <div className=\"hrm-modal-subtitle\">\n              {run.targetType === \"entity\" ? \"Entity Description\" : \"Chronicle Narrative\"}\n              {run.tone && TONE_META[run.tone] && <span className=\"hrm-modal-tone\">\n                  {TONE_META[run.tone].symbol} {TONE_META[run.tone].label}\n                </span>}\n              {isReviewing && ` \\u00b7 ${acceptedCount}/${notes.length} notes accepted`}\n            </div>\n          </div>\n          <button onClick={onCancel} className=\"hrm-modal-cancel-btn\">\n            Cancel\n          </button>\n        </div>\n\n        {/* Content */}\n        <div className=\"hrm-modal-content\">\n          {isGenerating && <div className=\"hrm-generating-message\">The historian is reviewing the text\\u2026</div>}\n\n          {isFailed && <div className=\"hrm-failed-message\">Review failed: {run.error || \"Unknown error\"}</div>}\n\n          {isReviewing && <div className=\"hrm-review-layout\">\n              {/* Annotated source text */}\n              <div>\n                <div className=\"hrm-section-label\">Source Text (annotations highlighted)</div>\n                <AnnotatedText sourceText={run.sourceText} notes={notes} noteDecisions={run.noteDecisions} />\n              </div>\n\n              {/* Notes list */}\n              <div>\n                <div className=\"hrm-section-label\">Historian Notes ({notes.length})</div>\n                {notes.map(note => <NoteCard key={note.noteId} note={note} accepted={run.noteDecisions[note.noteId]} onToggle={onToggleNote} onEditText={onEditNoteText} />)}\n              </div>\n            </div>}\n        </div>\n\n        {/* Footer */}\n        {isReviewing && <div className=\"hrm-modal-footer\">\n            <button onClick={onCancel} className=\"hrm-discard-btn\">\n              Discard All\n            </button>\n            <button onClick={onAccept} disabled={acceptedCount === 0} className={`hrm-apply-btn ${acceptedCount > 0 ? \"hrm-apply-btn-active\" : \"hrm-apply-btn-disabled\"}`}>\n              Apply {acceptedCount} Note{acceptedCount !== 1 ? \"s\" : \"\"}\n            </button>\n          </div>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}", "type": "{ run: any; isActive: any; onToggleNote: any; onEditNoteText: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HistorianToneSelector", "specifiers": ["TONE_META"], "category": "internal"}, {"source": "./HistorianReviewModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx", "sourceCode": "// ============================================================================\n// Component\n// ============================================================================\n\nexport default function HistorianToneSelector({\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const containerRef = useRef(null);\n\n  // Close on outside click\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleClickOutside = e => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [isOpen]);\n  const handleSelect = tone => {\n    setIsOpen(false);\n    onSelect(tone);\n  };\n  return <div ref={containerRef} className={`htsel-container${className ? ` ${className}` : \"\"}`}>\n      <button onClick={() => setIsOpen(!isOpen)} disabled={disabled} title=\"Select historian tone and generate annotations\" className={`htsel-trigger ${disabled ? \"htsel-trigger-disabled\" : \"\"}`}>\n        {label || (hasNotes ? \"Re-annotate\" : \"Historian\")} \u25be\n      </button>\n\n      {isOpen && <div className=\"htsel-dropdown\">\n          <div className=\"htsel-dropdown-header\">Historian Tone</div>\n          {TONE_OPTIONS.map(option => <button key={option.value} onClick={() => handleSelect(option.value)} className=\"htsel-option\">\n              <span className=\"htsel-option-symbol\">{option.symbol}</span>\n              <div className=\"htsel-option-content\">\n                <div className=\"htsel-option-label\">{option.label}</div>\n                <div className=\"htsel-option-description\">{option.description}</div>\n              </div>\n            </button>)}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}", "type": "{ onSelect: any; disabled: any; hasNotes: any; className: any; label: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HistorianToneSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx", "sourceCode": "export default function HistoryCompressionPreviewModal({\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}) {\n  if (!compressed || compressed.length === 0) return null;\n\n  const removedCount = originalCount - compressed.length;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary hcpm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={onProceed}\n        className=\"illuminator-button illuminator-button-primary hcpm-footer-btn\"\n      >\n        Proceed with Copy Edit\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Description Archive\" className=\"hcpm-dialog\" footer={footer}>\n      <div className=\"hcpm-meta\">\n        <span className=\"hcpm-entity-name\">{entityName}</span>\n        <p className=\"hcpm-subtitle\">\n          {removedCount > 0\n            ? `${originalCount} versions \u2192 ${compressed.length} milestones (${removedCount} near-duplicate passes consolidated)`\n            : `${originalCount} versions \u2014 no compression needed`}\n        </p>\n      </div>\n\n      {/* Scrollable content */}\n      <div className=\"hcpm-content\">\n        {compressed.map((entry, i) => {\n          const date = new Date(entry.replacedAt).toISOString().split(\"T\")[0];\n          const isConsolidated = entry.consolidatedCount > 1;\n          const earliestDate = entry.earliestDate\n            ? new Date(entry.earliestDate).toISOString().split(\"T\")[0]\n            : null;\n\n          return (\n            <div\n              key={i}\n              className={`hcpm-entry ${isConsolidated ? \"hcpm-entry-consolidated\" : \"hcpm-entry-normal\"}`}\n            >\n              {/* Header */}\n              <div className=\"hcpm-entry-header\">\n                <div className=\"hcpm-entry-header-left\">\n                  <span className=\"hcpm-entry-index\">[{i + 1}]</span>\n                  <span className=\"hcpm-entry-source\">{entry.source}</span>\n                  {isConsolidated && (\n                    <span className=\"hcpm-entry-consolidated-label\">\n                      {entry.consolidatedCount} passes consolidated\n                    </span>\n                  )}\n                </div>\n                <span className=\"hcpm-entry-date\">\n                  {isConsolidated && earliestDate ? `${earliestDate} \u2192 ${date}` : date}\n                </span>\n              </div>\n\n              {/* Preview */}\n              <div className=\"hcpm-entry-preview\">{entry.description.slice(0, 300)}</div>\n            </div>\n          );\n        })}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}", "type": "{ entityName: any; originalCount: any; compressed: any; onProceed: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./HistoryCompressionPreviewModal.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/components/IlluminatorModals.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorModals.jsx", "sourceCode": "/**\n * Orchestrator component for all Illuminator modal dialogs.\n *\n * Flow objects (revisionFlow, backportFlow, etc.) are passed as grouped props\n * rather than flat-spreading ~100 properties.\n */\nexport default function IlluminatorModals({\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}) {\n  return (\n    <>\n      <ImageSettingsSection\n        imageGenSettings={props.imageGenSettings}\n        updateImageGenSettings={props.updateImageGenSettings}\n        styleLibrary={props.styleLibrary}\n        worldSchema={props.worldSchema}\n        config={props.config}\n      />\n      <DynamicsSection dynamicsFlow={dynamicsFlow} />\n      <RevisionSection revisionFlow={revisionFlow} />\n      <BackportSection backportFlow={backportFlow} revisionFlow={revisionFlow} />\n      <HistorianSection historianFlow={historianFlow} revisionFlow={revisionFlow} />\n      <EntityModals\n        worldSchema={props.worldSchema}\n        handleRenameApplied={props.handleRenameApplied}\n        handleCreateEntity={props.handleCreateEntity}\n        handleEditEntity={props.handleEditEntity}\n      />\n      <ToneAndAnnotationModals />\n      <ThinkingViewer />\n      <FloatingPills onNavigate={props.setActiveTab} />\n    </>\n  );\n}", "parameters": [{"name": "{\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}", "type": "{ [x: string]: any; revisionFlow: any; backportFlow: any; historianFlow: any; dynamicsFlow: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ImageSettingsDrawer", "specifiers": ["ImageSettingsDrawer"], "category": "internal"}, {"source": "./DynamicsGenerationModal", "specifiers": ["DynamicsGenerationModal"], "category": "internal"}, {"source": "./RevisionFilterModal", "specifiers": ["RevisionFilterModal"], "category": "internal"}, {"source": "./SummaryRevisionModal", "specifiers": ["SummaryRevisionModal"], "category": "internal"}, {"source": "./BackportConfigModal", "specifiers": ["BackportConfigModal"], "category": "internal"}, {"source": "./BulkBackportModal", "specifiers": ["BulkBackportModal"], "category": "internal"}, {"source": "./BulkHistorianModal", "specifiers": ["BulkHistorianModal"], "category": "internal"}, {"source": "./HistorianReviewModal", "specifiers": ["HistorianReviewModal"], "category": "internal"}, {"source": "./EntityRenameModal", "specifiers": ["EntityRenameModal"], "category": "internal"}, {"source": "./CreateEntityModal", "specifiers": ["CreateEntityModal"], "category": "internal"}, {"source": "./BulkToneRankingModal", "specifiers": ["BulkToneRankingModal"], "category": "internal"}, {"source": "./ToneAssignmentPreviewModal", "specifiers": ["ToneAssignmentPreviewModal"], "category": "internal"}, {"source": "./BulkChronicleAnnotationModal", "specifiers": ["BulkChronicleAnnotationModal"], "category": "internal"}, {"source": "./InterleavedAnnotationModal", "specifiers": ["InterleavedAnnotationModal"], "category": "internal"}, {"source": "./ThinkingViewer", "specifiers": ["ThinkingViewer"], "category": "internal"}, {"source": "./FloatingPills", "specifiers": ["FloatingPills"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useEraTemporalInfo"], "category": "internal"}, {"source": "../lib/db/toneRankingStore", "specifiers": ["useToneRankingStore"], "category": "internal"}, {"source": "../lib/db/bulkChronicleAnnotationStore", "specifiers": ["useBulkChronicleAnnotationStore"], "category": "internal"}, {"source": "../lib/db/interleavedAnnotationStore", "specifiers": ["useInterleavedAnnotationStore"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx", "sourceCode": "export default function IlluminatorSidebar({\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}) {\n  return (\n    <div className=\"illuminator-sidebar\">\n      <nav className=\"illuminator-nav\">\n        {TABS.map((tab) => (\n          <NavButton\n            key={tab.id}\n            tab={tab}\n            activeTab={activeTab}\n            setActiveTab={setActiveTab}\n            stats={stats}\n          />\n        ))}\n      </nav>\n\n      <div className=\"isb-spacer\" />\n\n      {/* Image Settings trigger */}\n      <div className=\"isb-image-settings\">\n        <ImageSettingsTrigger\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary}\n          onClick={() => useIlluminatorModals.getState().openImageSettings()}\n        />\n      </div>\n\n      {/* API Key section */}\n      <ApiKeySection\n        showApiKeyInput={showApiKeyInput}\n        setShowApiKeyInput={setShowApiKeyInput}\n        hasRequiredKeys={hasRequiredKeys}\n        anthropicApiKey={anthropicApiKey}\n        setAnthropicApiKey={setAnthropicApiKey}\n        openaiApiKey={openaiApiKey}\n        setOpenaiApiKey={setOpenaiApiKey}\n        persistApiKeys={persistApiKeys}\n        setPersistApiKeys={setPersistApiKeys}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}", "type": "{ activeTab: any; setActiveTab: any; stats: any; imageGenSettings: any; styleLibrary: any; showApiKeyInput: any; setShowApiKeyInput: any; hasRequiredKeys: any; anthropicApiKey: any; setAnthropicApiKey: any; openaiApiKey: any; setOpenaiApiKey: any; persistApiKeys: any; setPersistApiKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./ImageSettingsDrawer", "specifiers": ["ImageSettingsTrigger"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./IlluminatorSidebar.css", "specifiers": [], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx", "sourceCode": "export default function IlluminatorTabContent({ activeTab, ...props }) {\n  const TabComponent = TAB_COMPONENTS[activeTab];\n  return TabComponent ? <TabComponent {...props} /> : null;\n}", "parameters": [{"name": "{ activeTab, ...props }", "type": "{ [x: string]: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./IlluminatorTabContent.css", "specifiers": [], "category": "internal"}, {"source": "./EntityBrowser", "specifiers": ["EntityBrowser"], "category": "internal"}, {"source": "./ChroniclePanel", "specifiers": ["ChroniclePanel"], "category": "internal"}, {"source": "./WorldContextEditor", "specifiers": ["WorldContextEditor"], "category": "internal"}, {"source": "./EntityGuidanceEditor", "specifiers": ["EntityGuidanceEditor"], "category": "internal"}, {"source": "./VisualIdentityPanel", "specifiers": ["VisualIdentityPanel"], "category": "internal"}, {"source": "./ActivityPanel", "specifiers": ["ActivityPanel"], "category": "internal"}, {"source": "./ConfigPanel", "specifiers": ["ConfigPanel"], "category": "internal"}, {"source": "./CostsPanel", "specifiers": ["CostsPanel"], "category": "internal"}, {"source": "./StoragePanel", "specifiers": ["StoragePanel"], "category": "internal"}, {"source": "./TraitPaletteSection", "specifiers": ["TraitPaletteSection"], "category": "internal"}, {"source": "./StyleLibraryEditor", "specifiers": ["StyleLibraryEditor"], "category": "internal"}, {"source": "./StaticPagesPanel", "specifiers": ["StaticPagesPanel"], "category": "internal"}, {"source": "./CoveragePanel", "specifiers": ["CoveragePanel"], "category": "internal"}, {"source": "./FinalEditTab", "specifiers": ["FinalEditTab"], "category": "internal"}, {"source": "./EntityCoveragePanel", "specifiers": ["EntityCoveragePanel"], "category": "internal"}, {"source": "./HistorianConfigEditor", "specifiers": ["HistorianConfigEditor"], "category": "internal"}, {"source": "./PrePrintPanel", "specifiers": ["PrePrintPanel"], "category": "internal"}, {"source": "../lib/historianTypes", "specifiers": ["isHistorianConfigured"], "category": "internal"}, {"source": "../lib/db/modalStore", "specifiers": ["useIlluminatorModals"], "category": "internal"}, {"source": "../lib/db/illuminatorConfigStore", "specifiers": ["useIlluminatorConfigStore"], "category": "internal"}, {"source": "../lib/db/enrichmentQueueStore", "specifiers": ["useEnrichmentQueueStore"], "category": "internal"}, {"source": "../lib/db/indexSelectors", "specifiers": ["useEraTemporalInfo"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}]}, {"id": "apps/illuminator/webui/src/components/ImageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageModal.jsx", "sourceCode": "export default function ImageModal({ isOpen, imageId, title, onClose }) {\n  const { url: imageUrl, loading, error, metadata } = useImageUrl(isOpen ? imageId : null);\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  // Close on escape key\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener(\"keydown\", handleKeyDown);\n      // Prevent body scroll when modal is open\n      document.body.style.overflow = \"hidden\";\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen) return null;\n\n  const hasSidebar = sidebarOpen && metadata;\n\n  return (\n    <div className=\"imod-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      {/* Header with title and close button */}\n      <div\n        className={`imod-header ${hasSidebar ? \"imod-header-sidebar-open\" : \"imod-header-sidebar-closed\"}`}\n        onClick={(e) => e.stopPropagation()}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <h3 className=\"imod-title\">{title}</h3>\n        <button onClick={onClose} className=\"imod-close-btn\">\n          Close (Esc)\n        </button>\n      </div>\n\n      {/* Image container - adjusted for sidebar */}\n      <div\n        className={`imod-image-container ${hasSidebar ? \"imod-image-container-sidebar-open\" : \"imod-image-container-sidebar-closed\"}`}\n      >\n        {loading && (\n          <div className=\"imod-loading\">Loading image...</div>\n        )}\n        {!loading && (error || !imageUrl) && (\n          <div className=\"imod-error\">\n            <div className=\"imod-error-title\">Image not available</div>\n            <div className=\"imod-error-detail\">{error || \"Image not found in storage\"}</div>\n          </div>\n        )}\n        {!loading && !error && imageUrl && (\n          <img\n            src={imageUrl}\n            alt={title}\n            className=\"imod-full-image\"\n            onClick={(e) => e.stopPropagation()}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          />\n        )}\n      </div>\n\n      {/* Metadata sidebar */}\n      <MetadataSidebar\n        metadata={metadata}\n        isOpen={sidebarOpen}\n        onToggle={() => setSidebarOpen(!sidebarOpen)}\n      />\n\n      {/* Hint at bottom */}\n      <div\n        className={`imod-hint ${hasSidebar ? \"imod-hint-sidebar-open\" : \"imod-hint-sidebar-closed\"}`}\n      >\n        Click anywhere or press Escape to close\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, imageId, title, onClose }", "type": "{ isOpen: any; imageId: any; title: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageUrl"], "category": "external"}, {"source": "./ImageModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ImagePickerModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImagePickerModal.jsx", "sourceCode": "export default function ImagePickerModal({\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n  const [loading, setLoading] = useState(true);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterCulture, setFilterCulture] = useState(\"all\");\n  const [filterModel, setFilterModel] = useState(\"all\");\n  const [searchText, setSearchText] = useState(\"\");\n  const [expandedPrompt, setExpandedPrompt] = useState(null);\n  const [filterOptions, setFilterOptions] = useState({ kinds: [], cultures: [], models: [] });\n\n  // Load filter options when modal opens\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadFilterOptions() {\n      try {\n        const [kinds, cultures, models] = await Promise.all([\n          getImageFilterOptions(\"entity-kind\"),\n          getImageFilterOptions(\"entityCulture\"),\n          getImageFilterOptions(\"model\"),\n        ]);\n        setFilterOptions({ kinds, cultures, models });\n      } catch (err) {\n        console.error(\"Failed to load filter options:\", err);\n      }\n    }\n\n    loadFilterOptions();\n    // Reset filters on open\n    setFilterKind(\"all\");\n    setFilterCulture(\"all\");\n    setFilterModel(\"all\");\n    setSearchText(\"\");\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {};\n        if (filterKind !== \"all\") filters.entityKind = filterKind;\n        if (filterCulture !== \"all\") filters.entityCulture = filterCulture;\n        if (filterModel !== \"all\") filters.model = filterModel;\n        if (searchText.trim()) filters.searchText = searchText.trim();\n\n        const results = await searchImages(filters);\n        setImages(results);\n      } catch (err) {\n        console.error(\"Failed to load images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, filterKind, filterCulture, filterModel, searchText]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      // Find the selected image to get its metadata\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    setExpandedPrompt(null);\n    onClose();\n  }, [onClose]);\n\n  // Close on escape key\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") {\n        handleClose();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal ipm-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Image from Library</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body ipm-body\">\n          {/* Filters */}\n          <div className=\"ipm-filters\">\n            <div>\n              <label htmlFor=\"search\" className=\"ipm-filter-label\">Search</label>\n              <input id=\"search\"\n                type=\"text\"\n                value={searchText}\n                onChange={(e) => setSearchText(e.target.value)}\n                placeholder=\"Name or prompt...\"\n                className=\"illuminator-input ipm-search-input\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"entity-kind\" className=\"ipm-filter-label\">Entity Kind</label>\n              <select id=\"entity-kind\"\n                value={filterKind}\n                onChange={(e) => setFilterKind(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Kinds</option>\n                {filterOptions.kinds.map((kind) => (\n                  <option key={kind} value={kind}>\n                    {kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"culture\" className=\"ipm-filter-label\">Culture</label>\n              <select id=\"culture\"\n                value={filterCulture}\n                onChange={(e) => setFilterCulture(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Cultures</option>\n                {filterOptions.cultures.map((culture) => (\n                  <option key={culture} value={culture}>\n                    {culture}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"model\" className=\"ipm-filter-label\">Model</label>\n              <select id=\"model\"\n                value={filterModel}\n                onChange={(e) => setFilterModel(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Models</option>\n                {filterOptions.models.map((model) => (\n                  <option key={model} value={model}>\n                    {model}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"ipm-filter-count-wrapper\">\n              <span className=\"ipm-filter-count\">{images.length} images</span>\n            </div>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"ipm-grid-container\">\n            {loading && (\n              <div className=\"ipm-loading\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"ipm-empty\">\n                No images found. Try adjusting the filters or generate some images first.\n              </div>\n            )}\n            {!loading && images.length > 0 && (\n              <div className=\"ipm-grid\">\n                {images.map((img) => {\n                  const isSelected = selectedImageId === img.imageId;\n                  const isCurrent = currentImageId === img.imageId;\n\n                  return (\n                    <div\n                      key={img.imageId}\n                      onClick={() => setSelectedImageId(img.imageId)}\n                      className={`ipm-card ${isSelected ? \"ipm-card-selected\" : \"\"} ${isCurrent ? \"ipm-card-current\" : \"\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {/* Current badge */}\n                      {isCurrent && <div className=\"ipm-current-badge\">CURRENT</div>}\n\n                      {/* Thumbnail \u2014 lazy-loaded via IntersectionObserver */}\n                      <LazyThumbnail\n                        imageId={img.imageId}\n                        alt={img.entityName || img.imageId}\n                        className=\"ipm-thumbnail-wrapper\"\n                      />\n\n                      {/* Info */}\n                      <div className=\"ipm-card-info\">\n                        <div className=\"ipm-card-name\" title={img.entityName}>\n                          {img.entityName || \"Unknown\"}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {img.entityKind}\n                          {img.entityCulture && ` \u00b7 ${img.entityCulture}`}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {formatDate(img.generatedAt)} \u00b7 {formatBytes(img.size || 0)}\n                        </div>\n\n                        {/* Prompt preview */}\n                        {(img.finalPrompt || img.originalPrompt) && (\n                          <div\n                            className={`ipm-card-prompt ${expandedPrompt === img.imageId ? \"ipm-card-prompt-expanded\" : \"ipm-card-prompt-collapsed\"}`}\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              setExpandedPrompt(\n                                expandedPrompt === img.imageId ? null : img.imageId\n                              );\n                            }}\n                            title=\"Click to expand/collapse prompt\"\n                            role=\"button\"\n                            tabIndex={0}\n                            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                          >\n                            {img.finalPrompt || img.originalPrompt}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer ipm-footer\">\n          <button onClick={handleClose} className=\"illuminator-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId || selectedImageId === currentImageId}\n            className=\"illuminator-btn illuminator-btn-primary\"\n          >\n            {selectedImageId === currentImageId ? \"Already Assigned\" : \"Assign Image\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; entityKind: any; entityCulture: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/db/imageRepository", "specifiers": ["searchImagesWithFilters as searchImages", "getImageFilterOptions", "loadImage", "formatBytes"], "category": "internal"}, {"source": "./ImagePickerModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ImageRefPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageRefPicker.jsx", "sourceCode": "export default function ImageRefPicker({ projectId, onSelect, onClose }) {\n  const [images, setImages] = useState([]);\n  const [imageUrls, setImageUrls] = useState({}); // imageId -> dataUrl cache\n  const [loading, setLoading] = useState(false);\n  const [search, setSearch] = useState(\"\");\n  const [debouncedSearch, setDebouncedSearch] = useState(\"\");\n  const [caption, setCaption] = useState(\"\");\n  const [selectedImage, setSelectedImage] = useState(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const searchTimeoutRef = useRef(null);\n\n  // Debounce search input\n  useEffect(() => {\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n    searchTimeoutRef.current = setTimeout(() => {\n      setDebouncedSearch(search);\n    }, 300);\n\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, [search]);\n\n  // Load images when search changes\n  useEffect(() => {\n    let cancelled = false;\n\n    async function loadImages() {\n      setLoading(true);\n      try {\n        const result = await searchImages({\n          projectId,\n          search: debouncedSearch || undefined,\n          limit: PAGE_SIZE,\n          offset: 0,\n        });\n\n        if (cancelled) return;\n\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n        setSelectedImage(null);\n        setCaption(\"\");\n      } catch (err) {\n        console.error(\"Failed to search images:\", err);\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    }\n\n    loadImages();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, debouncedSearch]);\n\n  // Load more images (pagination)\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const result = await searchImages({\n        projectId,\n        search: debouncedSearch || undefined,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      });\n\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [projectId, debouncedSearch, images.length, loading, hasMore]);\n\n  // Lazy load image thumbnail when it comes into view\n  const loadImageUrl = useCallback(\n    async (imageId) => {\n      if (imageUrls[imageId]) return; // Already loaded\n\n      try {\n        const dataUrl = await getImageDataUrl(imageId);\n        if (dataUrl) {\n          setImageUrls((prev) => ({ ...prev, [imageId]: dataUrl }));\n        }\n      } catch (err) {\n        console.warn(`Failed to load image ${imageId}:`, err);\n      }\n    },\n    [imageUrls]\n  );\n\n  const handleInsert = () => {\n    if (!selectedImage) return;\n    const imageRef = caption\n      ? `![${caption}](image:${selectedImage.imageId})`\n      : `![](image:${selectedImage.imageId})`;\n    onSelect(imageRef);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Image\" className=\"image-picker-modal\">\n      <div className=\"image-picker-toolbar\">\n        <input\n          type=\"text\"\n          value={search}\n          onChange={(e) => setSearch(e.target.value)}\n          placeholder=\"Search by entity name...\"\n          className=\"static-page-search-input\"\n          // eslint-disable-next-line jsx-a11y/no-autofocus\n          autoFocus\n        />\n        {total > 0 && <span className=\"image-picker-count\">{total} images</span>}\n      </div>\n\n      {loading && images.length === 0 && (\n        <div className=\"image-picker-loading\">Searching images...</div>\n      )}\n      {!(loading && images.length === 0) && images.length === 0 && (\n        <div className=\"image-picker-empty\">\n          {search ? \"No images match your search\" : \"No images available\"}\n        </div>\n      )}\n      {images.length > 0 && (\n        <>\n          <div className=\"image-picker-grid\">\n            {images.map((img) => (\n              <ImageThumbnail\n                key={img.imageId}\n                image={img}\n                dataUrl={imageUrls[img.imageId]}\n                isSelected={selectedImage?.imageId === img.imageId}\n                onSelect={() => setSelectedImage(img)}\n                onVisible={() => loadImageUrl(img.imageId)}\n              />\n            ))}\n          </div>\n\n          {hasMore && (\n            <button\n              className=\"static-page-button image-picker-load-more\"\n              onClick={() => void handleLoadMore()}\n              disabled={loading}\n            >\n              {loading ? \"Loading...\" : `Load more (${images.length} of ${total})`}\n            </button>\n          )}\n        </>\n      )}\n\n      {selectedImage && (\n        <div className=\"image-picker-caption-section\">\n          <label className=\"image-picker-caption-label\">\n            Caption (optional):\n            <input\n              type=\"text\"\n              value={caption}\n              onChange={(e) => setCaption(e.target.value)}\n              placeholder=\"Enter image caption...\"\n              className=\"static-page-search-input\"\n            />\n          </label>\n          <button className=\"static-page-button primary\" onClick={handleInsert}>\n            Insert Image\n          </button>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ projectId, onSelect, onClose }", "type": "{ projectId: any; onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ModalShell"], "category": "external"}, {"source": "../lib/db/imageRepository", "specifiers": ["searchImages", "getImageDataUrl"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ImageSettingsDrawer({\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}: ImageSettingsDrawerProps) {\n  const drawerRef = useRef<HTMLDivElement>(null);\n\n  // Local copy of settings for instant UI feedback.\n  // Changes render immediately here, then propagate to parent via rAF.\n  const [settings, setLocalSettings] = useState(externalSettings);\n  const pendingFlush = useRef<number | null>(null);\n\n  // Sync local state when external settings change (e.g. on mount or external update)\n  useEffect(() => {\n    setLocalSettings(externalSettings);\n  }, [externalSettings]);\n\n  // Debounced push to parent \u2014 renders locally first, then flushes\n  const onSettingsChange = useCallback((partial: Partial<ImageGenSettings>) => {\n    setLocalSettings(prev => ({\n      ...prev,\n      ...partial\n    }));\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n    pendingFlush.current = requestAnimationFrame(() => {\n      pendingFlush.current = null;\n      externalOnChange(partial);\n    });\n  }, [externalOnChange]);\n\n  // Cleanup on unmount\n  useEffect(() => () => {\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n  }, []);\n\n  // Close on Escape\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") onClose();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [isOpen, onClose]);\n\n  // Section collapse state\n  const collapsedSet = useMemo(() => new Set(settings.collapsedSections), [settings.collapsedSections]);\n  const toggleSection = useCallback((key: string) => {\n    const next = new Set(collapsedSet);\n    if (next.has(key)) next.delete(key);else next.add(key);\n    onSettingsChange({\n      collapsedSections: Array.from(next)\n    });\n  }, [collapsedSet, onSettingsChange]);\n\n  // Group compositions by category\n  const groupedCompositions = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.compositionStyles>();\n    const map = new Map<string, typeof styleLibrary.compositionStyles>();\n    for (const style of styleLibrary.compositionStyles) {\n      const cat = style.targetCategory || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Group artistic styles by category\n  const groupedArtisticStyles = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.artisticStyles>();\n    const map = new Map<string, typeof styleLibrary.artisticStyles>();\n    for (const style of styleLibrary.artisticStyles) {\n      const cat = style.category || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Derive initial category tab from current selection\n  const selectedCompositionCategory = useMemo(() => {\n    if (!styleLibrary) return COMPOSITION_CATEGORY_ORDER[0];\n    const selected = styleLibrary.compositionStyles.find(s => s.id === settings.compositionStyleId);\n    return selected?.targetCategory || COMPOSITION_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.compositionStyleId]);\n  const selectedArtisticCategory = useMemo(() => {\n    if (!styleLibrary) return ARTISTIC_CATEGORY_ORDER[0];\n    const selected = styleLibrary.artisticStyles.find(s => s.id === settings.artisticStyleId);\n    return selected?.category || ARTISTIC_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.artisticStyleId]);\n\n  // Active category tabs \u2014 initialized from selection, then user-controllable\n  const [activeCompositionCategory, setActiveCompositionCategory] = useState(selectedCompositionCategory);\n  const [activeArtisticCategory, setActiveArtisticCategory] = useState(selectedArtisticCategory);\n\n  // Sync tab when selection changes to a different category (e.g. picking from a different tab)\n  useEffect(() => {\n    setActiveCompositionCategory(selectedCompositionCategory);\n  }, [selectedCompositionCategory]);\n  useEffect(() => {\n    setActiveArtisticCategory(selectedArtisticCategory);\n  }, [selectedArtisticCategory]);\n\n  // Available category tabs (only those with styles)\n  const availableCompositionCategories = useMemo(() => {\n    return COMPOSITION_CATEGORY_ORDER.filter(cat => groupedCompositions.has(cat));\n  }, [groupedCompositions]);\n  const availableArtisticCategories = useMemo(() => {\n    return ARTISTIC_CATEGORY_ORDER.filter(cat => groupedArtisticStyles.has(cat));\n  }, [groupedArtisticStyles]);\n\n  // Resolve display names for badge\n  const artisticName = useMemo(() => {\n    if (settings.artisticStyleId === RANDOM_ID) return \"Random\";\n    if (settings.artisticStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.artisticStyles.find(s => s.id === settings.artisticStyleId)?.name || settings.artisticStyleId;\n  }, [settings.artisticStyleId, styleLibrary]);\n  const compositionName = useMemo(() => {\n    if (settings.compositionStyleId === RANDOM_ID) return \"Random\";\n    if (settings.compositionStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.compositionStyles.find(s => s.id === settings.compositionStyleId)?.name || settings.compositionStyleId;\n  }, [settings.compositionStyleId, styleLibrary]);\n  const paletteName = useMemo(() => {\n    if (settings.colorPaletteId === RANDOM_ID) return \"Random\";\n    if (settings.colorPaletteId === NONE_ID) return \"None\";\n    return styleLibrary?.colorPalettes.find(s => s.id === settings.colorPaletteId)?.name || settings.colorPaletteId;\n  }, [settings.colorPaletteId, styleLibrary]);\n\n  // Group palettes by pre-defined groups\n  const palettesByGroup = useMemo(() => {\n    if (!styleLibrary) return [];\n    const paletteMap = new Map(styleLibrary.colorPalettes.map(p => [p.id, p]));\n    return PALETTE_GROUPS.map(group => ({\n      label: group.label,\n      palettes: group.ids.map(id => paletteMap.get(id)).filter(Boolean)\n    })).filter(g => g.palettes.length > 0);\n  }, [styleLibrary]);\n\n  // Size/quality options for current model\n  const sizeOptions = useMemo(() => getSizeOptions(imageModel), [imageModel]);\n  const qualityOptions = useMemo(() => getQualityOptions(imageModel), [imageModel]);\n\n  // Is the current selection a special value?\n  const isSpecialArtistic = settings.artisticStyleId === RANDOM_ID || settings.artisticStyleId === NONE_ID;\n  const isSpecialComposition = settings.compositionStyleId === RANDOM_ID || settings.compositionStyleId === NONE_ID;\n  const isSpecialPalette = settings.colorPaletteId === RANDOM_ID || settings.colorPaletteId === NONE_ID;\n\n  // Pool count info for random selection with exclusion filtering\n  const artisticPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialComposition) return undefined;\n    const total = styleLibrary.artisticStyles.length;\n    const filtered = filterStylesForComposition(styleLibrary.artisticStyles as any, settings.compositionStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.compositionStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.compositionStyleId, isSpecialComposition]);\n  const compositionPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialArtistic) return undefined;\n    const total = styleLibrary.compositionStyles.length;\n    const filtered = filterCompositionsForStyle(styleLibrary.compositionStyles as any, settings.artisticStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.artisticStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.artisticStyleId, isSpecialArtistic]);\n  if (!isOpen) return null;\n  return createPortal(<>\n      {/* Backdrop */}\n      <div onClick={onClose} className=\"isd-backdrop\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") onClose(e);\n    }} />\n\n      {/* Drawer */}\n      <div ref={drawerRef} onClick={e => e.stopPropagation()} className=\"isd-drawer\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        {/* Header */}\n        <div className=\"isd-header\">\n          <span className=\"isd-header-title\">Image Settings</span>\n          <button onClick={onClose} className=\"isd-close-btn\">\n            &#10005;\n          </button>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"isd-scroll\">\n          {!styleLibrary ? <div className=\"isd-loading\">Loading styles...</div> : <>\n              {/* \u2500\u2500\u2500 Visual Style \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Visual Style\" sectionKey=\"artistic\" collapsed={collapsedSet.has(\"artistic\")} onToggle={toggleSection} badge={artisticName}>\n                <SpecialToggle value={isSpecialArtistic ? settings.artisticStyleId : \"\"} onChange={id => onSettingsChange({\n              artisticStyleId: id\n            })} poolInfo={artisticPoolInfo} />\n\n                {/* Artistic category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableArtisticCategories.map(cat => <button key={cat} onClick={() => setActiveArtisticCategory(cat)} className=\"isd-category-tab\" data-active={activeArtisticCategory === cat}>\n                      {ARTISTIC_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Artistic style list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedArtisticStyles.get(activeArtisticCategory) || []).map(style => {\n                const isSelected = settings.artisticStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  artisticStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Composition \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Composition\" sectionKey=\"composition\" collapsed={collapsedSet.has(\"composition\")} onToggle={toggleSection} badge={compositionName}>\n                <SpecialToggle value={isSpecialComposition ? settings.compositionStyleId : \"\"} onChange={id => onSettingsChange({\n              compositionStyleId: id\n            })} poolInfo={compositionPoolInfo} />\n\n                {/* Category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableCompositionCategories.map(cat => <button key={cat} onClick={() => setActiveCompositionCategory(cat)} className=\"isd-category-tab\" data-active={activeCompositionCategory === cat}>\n                      {COMPOSITION_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Composition list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedCompositions.get(activeCompositionCategory) || []).map(style => {\n                const isSelected = settings.compositionStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  compositionStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name-composition\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Color Palette \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Color Palette\" sectionKey=\"palette\" collapsed={collapsedSet.has(\"palette\")} onToggle={toggleSection} badge={paletteName}>\n                <SpecialToggle value={isSpecialPalette ? settings.colorPaletteId : \"\"} onChange={id => onSettingsChange({\n              colorPaletteId: id\n            })} />\n\n                {palettesByGroup.map(group => <div key={group.label} className=\"isd-palette-group\">\n                    <div className=\"isd-palette-group-label\">{group.label}</div>\n                    <div className=\"isd-palette-grid\">\n                      {group.palettes.map(palette => {\n                  const isSelected = settings.colorPaletteId === palette.id;\n                  return <button key={palette.id} onClick={() => onSettingsChange({\n                    colorPaletteId: palette.id\n                  })} title={palette.description} className=\"isd-palette-btn\" data-selected={isSelected}>\n                            {palette.swatchColors && palette.swatchColors.length > 0 && <div className=\"isd-palette-swatch-row\">\n                                <SwatchStrip colors={palette.swatchColors} />\n                              </div>}\n                            <div className=\"isd-palette-name\">{palette.name}</div>\n                          </button>;\n                })}\n                    </div>\n                  </div>)}\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Output Settings \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Output\" sectionKey=\"output\" collapsed={collapsedSet.has(\"output\")} onToggle={toggleSection}>\n                {/* Size - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Size</div>\n                  <div className=\"isd-output-btns\">\n                    {sizeOptions.map(opt => {\n                  const isSelected = settings.imageSize === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageSize: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n                })}\n                  </div>\n                </div>\n\n                {/* Quality - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Quality</div>\n                  <div className=\"isd-output-btns\">\n                    {qualityOptions.map(opt => {\n                  const isSelected = settings.imageQuality === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageQuality: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}", "type": "ImageSettingsDrawerProps", "optional": false}], "returnType": "React.ReactPortal", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "react-dom", "specifiers": ["createPortal"], "category": "framework"}, {"source": "../lib/imageSettings", "specifiers": ["getSizeOptions", "getQualityOptions"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["DEFAULT_RANDOM_EXCLUSIONS", "filterStylesForComposition", "filterCompositionsForStyle"], "category": "external"}, {"source": "../hooks/useImageGenSettings", "specifiers": ["ImageGenSettings"], "category": "internal"}, {"source": "./ImageSettingsDrawer.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx", "sourceCode": "export default function InterleavedAnnotationModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n  const progressStatus = progress?.status;\n  const processedItems = progress?.processedItems;\n  const totalItems = progress?.totalItems;\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedItems}/${totalItems}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedItems, totalItems]);\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalItems > 0 ? Math.round(progress.processedItems / progress.totalItems * 100) : 0;\n  return <div className=\"iam-overlay\">\n      <div className=\"iam-dialog\" style={{\n      \"--iam-dialog-width\": isConfirming ? \"560px\" : \"480px\"\n    }}>\n        {/* Header */}\n        <div className=\"iam-header\">\n          <div className=\"iam-header-row\">\n            <h2 className=\"iam-title\">Interleaved Annotation</h2>\n            <div className=\"iam-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Interleaved Annotation\",\n              statusText: progress.status === \"running\" ? `${progress.processedItems}/${progress.totalItems}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })()\n            })} className=\"illuminator-button iam-minimize-btn\" title=\"Minimize to pill\">\n                  \u2014\n                </button>}\n              <span className=\"iam-status-text\" style={{\n              \"--iam-status-color\": (() => {\n                if (progress.status === \"complete\") return \"#10b981\";\n                if (progress.status === \"failed\") return \"#ef4444\";\n                if (progress.status === \"cancelled\") return \"#f59e0b\";\n                return \"var(--text-muted)\";\n              })()\n            }}>\n                {isConfirming && `${progress.totalItems} items`}\n                {progress.status === \"running\" && `${progress.processedItems}/${progress.totalItems}`}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`iam-body ${isConfirming ? \"iam-body-confirming\" : \"iam-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              <div className=\"iam-confirm-info\">\n                Chronicles in chronological order, each followed by its referenced entities. Results\n                auto-applied. Voice digest accumulates across both types.\n                <div className=\"iam-confirm-summary\">\n                  {progress.chronicleCount} chronicles + {progress.entityCount} entities ={\" \"}\n                  {progress.totalItems} total\n                </div>\n              </div>\n\n              {/* Work list \u2014 grouped */}\n              <div className=\"iam-worklist-section\">\n                <div className=\"iam-section-label\">Work List</div>\n\n                <div className=\"iam-worklist\">\n                  {progress.workItems.map(item => {\n                const isChronicle = item.type === \"chronicle\";\n                const toneMeta = TONE_META[item.tone];\n                return <div key={isChronicle ? `c-${item.chronicleId}` : `e-${item.entityId}`} className={`iam-work-item ${isChronicle ? \"iam-work-item-chronicle\" : \"iam-work-item-entity\"}`}>\n                        <div className=\"iam-work-item-left\">\n                          <span className={`iam-work-item-icon ${isChronicle ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                            {isChronicle ? \"\\u25a0\" : \"\\u25cb\"}\n                          </span>\n                          <span className={`iam-work-item-name ${isChronicle ? \"iam-work-item-name-chronicle\" : \"iam-work-item-name-entity\"}`}>\n                            {isChronicle ? item.title : item.entityName}\n                          </span>\n                          {!isChronicle && <span className=\"iam-work-item-kind\">{item.entityKind}</span>}\n                        </div>\n                        <span className=\"iam-work-item-tone\" title={toneMeta?.label || item.tone}>\n                          {toneMeta?.symbol || item.tone}\n                        </span>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing screen ---- */}\n          {!isConfirming && <>\n              <div className=\"iam-progress-section\">\n                <div className=\"iam-progress-header\">\n                  <span className=\"iam-progress-label\">\n                    Item {Math.min(progress.processedItems + 1, progress.totalItems)} /{\" \"}\n                    {progress.totalItems}\n                  </span>\n                  <span className=\"iam-progress-percent\">{globalPercent}%</span>\n                </div>\n\n                {/* Progress bar */}\n                <div className=\"iam-progress-track\">\n                  <div className=\"iam-progress-fill\" style={{\n                \"--iam-progress-bg\": (() => {\n                  if (progress.status === \"failed\") return \"#ef4444\";\n                  if (progress.status === \"cancelled\") return \"#f59e0b\";\n                  return \"#10b981\";\n                })(),\n                \"--iam-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n\n                <div className=\"iam-progress-detail\">\n                  <span>\n                    Chronicles: {progress.processedChronicles}/{progress.chronicleCount}\n                    {\" \\u00b7 \"}\n                    Entities: {progress.processedEntities}/{progress.entityCount}\n                  </span>\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-count\">{progress.failedItems.length} failed</span>}\n                </div>\n              </div>\n\n              {/* Current item */}\n              {progress.currentItem && !isTerminal && <div className=\"iam-current-item\">\n                  <div className=\"iam-current-item-header\">\n                    <span className={`iam-current-item-icon ${progress.currentItem.type === \"chronicle\" ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                      {progress.currentItem.type === \"chronicle\" ? \"\\u25a0\" : \"\\u25cb\"}\n                    </span>\n                    {progress.currentItem.type === \"chronicle\" ? progress.currentItem.title : progress.currentItem.entityName}\n                    {TONE_META[progress.currentItem.tone] && <span className=\"iam-current-item-tone\">\n                        {TONE_META[progress.currentItem.tone].symbol}\n                      </span>}\n                  </div>\n                  <div className=\"iam-current-item-sub\">\n                    {progress.currentItem.type === \"chronicle\" ? \"Annotating chronicle...\" : \"Annotating entity...\"}\n                  </div>\n                </div>}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"iam-terminal-complete\">\n                  Annotated {progress.processedChronicles} chronicles and{\" \"}\n                  {progress.processedEntities} entities.\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-inline\">\n                      {\" \"}\n                      {progress.failedItems.length} failed.\n                    </span>}\n                </div>}\n\n              {progress.status === \"cancelled\" && <div className=\"iam-terminal-cancelled\">\n                  Cancelled after {progress.processedItems} of {progress.totalItems} items (\n                  {progress.processedChronicles} chronicles, {progress.processedEntities} entities).\n                </div>}\n\n              {progress.status === \"failed\" && <div className=\"iam-terminal-failed\">\n                  {progress.error || \"An unexpected error occurred.\"}\n                </div>}\n\n              {/* Failed items list */}\n              {isTerminal && progress.failedItems.length > 0 && <div className=\"iam-failed-section\">\n                  <div className=\"iam-failed-label\">Failed ({progress.failedItems.length})</div>\n                  {progress.failedItems.map((f, i) => <div key={i} className=\"iam-failed-item\">\n                      {f.item.type === \"chronicle\" ? f.item.title : f.item.entityName}: {f.error}\n                    </div>)}\n                </div>}\n\n              {/* Cost */}\n              {progress.totalCost > 0 && <div className=\"iam-cost\">Cost: ${progress.totalCost.toFixed(4)}</div>}\n            </>}\n        </div>\n\n        {/* Footer */}\n        <div className=\"iam-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary iam-footer-btn\">\n                Start ({progress.totalItems} items)\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button iam-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HistorianToneSelector", "specifiers": ["TONE_META"], "category": "internal"}, {"source": "../lib/db/floatingPillStore", "specifiers": ["useFloatingPillStore"], "category": "internal"}, {"source": "./InterleavedAnnotationModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx", "sourceCode": "export default function LLMCallConfigPanel() {\n  const [settings, setSettings] = useState(() => getLLMModelSettings());\n  const [, forceUpdate] = useState(0);\n\n  const overrideCount = getOverrideCount();\n  const callTypesByCategory = getCallTypesByCategory();\n\n  const handleUpdate = useCallback(\n    (callType, config) => {\n      const next = {\n        ...settings,\n        callOverrides: {\n          ...settings.callOverrides,\n        },\n      };\n\n      if (\n        !config.model &&\n        config.thinkingBudget === undefined &&\n        config.maxTokens === undefined &&\n        config.streamTimeout === undefined &&\n        config.disableStreaming === undefined &&\n        config.runInBrowser === undefined\n      ) {\n        delete next.callOverrides[callType];\n      } else {\n        next.callOverrides[callType] = config;\n      }\n\n      setSettings(next);\n      saveLLMModelSettings(next);\n      forceUpdate((n) => n + 1);\n    },\n    [settings]\n  );\n\n  const handleResetAll = useCallback(() => {\n    resetToDefaults();\n    setSettings(getLLMModelSettings());\n    forceUpdate((n) => n + 1);\n  }, []);\n\n  const categories = [\n    \"description\",\n    \"perspective\",\n    \"chronicle\",\n    \"image\",\n    \"palette\",\n    \"dynamics\",\n    \"revision\",\n    \"historian\",\n  ];\n\n  return (\n    <div className=\"illuminator-card llm-config-panel\">\n      <div className=\"llm-config-header\">\n        <div className=\"llm-config-title-row\">\n          <h2 className=\"illuminator-card-title\">LLM Call Configuration</h2>\n          {overrideCount > 0 && (\n            <span className=\"llm-config-override-count\">{overrideCount} modified</span>\n          )}\n        </div>\n        <div className=\"llm-config-actions\">\n          {overrideCount > 0 && (\n            <button onClick={handleResetAll} className=\"llm-config-reset-all\">\n              Reset All\n            </button>\n          )}\n        </div>\n      </div>\n\n      <div className=\"llm-table-container\">\n        <table className=\"llm-table\">\n          <thead>\n            <tr className=\"llm-table-header\">\n              <th className=\"llm-table-th llm-table-th-label\">Call Type</th>\n              <th className=\"llm-table-th llm-table-th-model\">Model</th>\n              <th className=\"llm-table-th llm-table-th-thinking\">Thinking</th>\n              <th className=\"llm-table-th llm-table-th-temp\">Temp</th>\n              <th className=\"llm-table-th llm-table-th-top-p\">Low P</th>\n              <th className=\"llm-table-th llm-table-th-max\">Max Tokens</th>\n              <th className=\"llm-table-th llm-table-th-timeout\">Timeout</th>\n              <th className=\"llm-table-th llm-table-th-sync\">No Stream</th>\n              <th className=\"llm-table-th llm-table-th-browser\">Browser</th>\n              <th className=\"llm-table-th llm-table-th-action\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {categories.map((category) => {\n              const callTypes = callTypesByCategory[category];\n              return [\n                <CategoryHeader key={`cat-${category}`} category={category} />,\n                ...callTypes.map((callType, idx) => {\n                  const resolved = getCallConfig(callType);\n                  const isDefault = !hasOverrides(callType);\n                  return (\n                    <CallTypeRow\n                      key={callType}\n                      callType={callType}\n                      config={resolved}\n                      isDefault={isDefault}\n                      onUpdate={handleUpdate}\n                      isLast={idx === callTypes.length - 1}\n                    />\n                  );\n                }),\n              ];\n            })}\n          </tbody>\n        </table>\n      </div>\n\n      <div className=\"llm-config-footer\">\n        <span className=\"llm-config-hint\">* = default</span>\n        <span className=\"llm-config-hint\">Hover call type for description</span>\n      </div>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../lib/llmModelSettings", "specifiers": ["getLLMModelSettings", "saveLLMModelSettings", "getCallConfig", "resetToDefaults", "hasOverrides", "getOverrideCount"], "category": "internal"}, {"source": "../lib/llmCallTypes", "specifiers": ["LLM_CALL_METADATA", "AVAILABLE_MODELS", "THINKING_BUDGET_OPTIONS", "MAX_TOKENS_OPTIONS", "THINKING_CAPABLE_MODELS", "CATEGORY_LABELS", "getCallTypesByCategory"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/PrePrintPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/PrePrintPanel.tsx", "sourceCode": "export default function PrePrintPanel({ projectId, simulationRunId }: Readonly<PrePrintPanelProps>) {\n  const navEntities = useEntityNavList();\n  const [activeSubTab, setActiveSubTab] = useState<SubTab>(\"stats\");\n  const [fullEntities, setFullEntities] = useState<PersistedEntity[]>([]);\n  const [chronicles, setChronicles] = useState<ChronicleRecord[]>([]);\n  const [allImages, setAllImages] = useState<ImageMetadataRecord[]>([]);\n  const [staticPages, setStaticPages] = useState<StaticPage[]>([]);\n  const [eraNarratives, setEraNarratives] = useState<EraNarrativeRecord[]>([]);\n  const [treeState, setTreeState] = useState<ContentTreeState | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (!projectId || !simulationRunId) {\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    void Promise.all([\n      getChroniclesForSimulation(simulationRunId),\n      getAllImages(),\n      getStaticPagesForProject(projectId),\n      loadTree(projectId, simulationRunId),\n      getEntitiesForRun(simulationRunId),\n      getEraNarrativesForSimulation(simulationRunId),\n    ]).then(([chrons, allImgs, pages, tree, ents, narrs]) => {\n      if (cancelled) return;\n      setChronicles(chrons);\n      // Keep project-scoped images; further filtering happens in memo below.\n      setAllImages(allImgs.filter((img) => img.projectId === projectId));\n      setStaticPages(pages);\n      setTreeState(tree);\n      setFullEntities(ents);\n      setEraNarratives(narrs);\n      setLoading(false);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, simulationRunId]);\n\n  const handleTreeChange = useCallback((newTree: ContentTreeState) => {\n    setTreeState(newTree);\n    void saveTree(newTree);\n  }, []);\n\n  // Era order map: eraId \u2192 sort index (by startTick)\n  const eraOrderMap = useMemo(() => {\n    const eraEntities = fullEntities.filter((e) => e.kind === \"era\" && (e as any).temporal);\n    const sorted = [...eraEntities].sort(\n      (a, b) => ((a as any).temporal.startTick || 0) - ((b as any).temporal.startTick || 0)\n    );\n    const map = new Map<string, number>();\n    sorted.forEach((era, index) => {\n      const eraId = (era as any).eraId || era.id;\n      map.set(eraId, index);\n    });\n    return map;\n  }, [fullEntities]);\n\n  const images = useMemo(() => {\n    if (allImages.length === 0) return [];\n\n    const referencedIds = new Set<string>();\n\n    for (const entity of navEntities) {\n      if (entity.imageId) referencedIds.add(entity.imageId);\n    }\n\n    const publishableChronicles = chronicles.filter(\n      (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n    );\n\n    for (const chronicle of publishableChronicles) {\n      const coverId = chronicle.coverImage?.generatedImageId;\n      if (coverId && chronicle.coverImage?.status === \"complete\") {\n        referencedIds.add(coverId);\n      }\n\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    // Era narrative images\n    for (const narr of eraNarratives) {\n      if (narr.coverImage?.status === \"complete\" && narr.coverImage.generatedImageId) {\n        referencedIds.add(narr.coverImage.generatedImageId);\n      }\n      if (narr.imageRefs?.refs) {\n        for (const ref of narr.imageRefs.refs) {\n          if (ref.type === \"chronicle_ref\") {\n            referencedIds.add(ref.imageId);\n          } else if (\n            ref.type === \"prompt_request\" &&\n            ref.status === \"complete\" &&\n            ref.generatedImageId\n          ) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    if (referencedIds.size === 0) return [];\n    return allImages.filter((img) => referencedIds.has(img.imageId));\n  }, [allImages, navEntities, chronicles, eraNarratives]);\n\n  if (loading) {\n    return (\n      <div className=\"ppp-empty-state\">\n        Loading pre-print data...\n      </div>\n    );\n  }\n\n  if (!projectId || !simulationRunId) {\n    return (\n      <div className=\"ppp-empty-state\">\n        No active project. Load a simulation run to use pre-print features.\n      </div>\n    );\n  }\n\n  const subTabs: { id: SubTab; label: string }[] = [\n    { id: \"stats\", label: \"Stats\" },\n    { id: \"tree\", label: \"Content Tree\" },\n    { id: \"export\", label: \"Export\" },\n  ];\n\n  return (\n    <div className=\"preprint-panel\">\n      <div className=\"preprint-subtabs\">\n        {subTabs.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => setActiveSubTab(tab.id)}\n            className={`preprint-subtab ${activeSubTab === tab.id ? \"active\" : \"\"}`}\n          >\n            {tab.label}\n          </button>\n        ))}\n      </div>\n\n      <div className=\"preprint-content\">\n        {activeSubTab === \"stats\" && (\n          <StatsView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n          />\n        )}\n\n        {activeSubTab === \"tree\" && (\n          <ContentTreeView\n            entities={fullEntities}\n            chronicles={chronicles}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            eraOrderMap={eraOrderMap}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n            onTreeChange={handleTreeChange}\n          />\n        )}\n\n        {activeSubTab === \"export\" && (\n          <ExportView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, simulationRunId }", "type": "Readonly<PrePrintPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useEffect", "useCallback", "useMemo"], "category": "framework"}, {"source": "../lib/db/entitySelectors", "specifiers": ["useEntityNavList"], "category": "internal"}, {"source": "../lib/db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../lib/chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../lib/preprint/prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../lib/staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../lib/eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../lib/preprint/prePrintTypes", "specifiers": ["ContentTreeState"], "category": "internal"}, {"source": "../lib/db/chronicleRepository", "specifiers": ["getChroniclesForSimulation"], "category": "internal"}, {"source": "../lib/db/imageRepository", "specifiers": ["getAllImages"], "category": "internal"}, {"source": "../lib/db/staticPageRepository", "specifiers": ["getStaticPagesForProject"], "category": "internal"}, {"source": "../lib/db/contentTreeRepository", "specifiers": ["loadTree", "saveTree"], "category": "internal"}, {"source": "../lib/db/entityRepository", "specifiers": ["getEntitiesForRun"], "category": "internal"}, {"source": "../lib/db/eraNarrativeRepository", "specifiers": ["getEraNarrativesForSimulation"], "category": "internal"}, {"source": "./preprint/StatsView", "specifiers": ["StatsView"], "category": "internal"}, {"source": "./preprint/ContentTreeView", "specifiers": ["ContentTreeView"], "category": "internal"}, {"source": "./preprint/ExportView", "specifiers": ["ExportView"], "category": "internal"}, {"source": "./PrePrintPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ProgressPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ProgressPanel.jsx", "sourceCode": "export default function ProgressPanel({\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}) {\n  const isRunning = status === \"running\";\n  const isPaused = status === \"paused\";\n  const isIdle = status === \"idle\";\n  const isComplete = status === \"complete\";\n  const completedTasks = useMemo(() => tasks.filter(t => t.status === \"complete\"), [tasks]);\n  const errorTasks = useMemo(() => tasks.filter(t => t.status === \"error\"), [tasks]);\n  const runningTasks = useMemo(() => tasks.filter(t => t.status === \"running\"), [tasks]);\n  const pendingTasks = useMemo(() => tasks.filter(t => t.status === \"pending\"), [tasks]);\n  const progressPercent = progress.total > 0 ? Math.round(progress.completed / progress.total * 100) : 0;\n  return <div>\n      {/* Status card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Progress</h2>\n          <div className=\"pp-button-group\">\n            {isIdle && <button onClick={onRunAll} className=\"illuminator-button\" disabled={!hasRequiredKeys || pendingTasks.length === 0}>\n                Start Enrichment\n              </button>}\n            {isRunning && <button onClick={onPause} className=\"illuminator-button illuminator-button-secondary\">\n                Pause\n              </button>}\n            {isPaused && <button onClick={onResume} className=\"illuminator-button\">\n                Resume\n              </button>}\n            {(isRunning || isPaused) && <button onClick={onAbort} className=\"pp-abort-btn\">\n                Abort\n              </button>}\n          </div>\n        </div>\n\n        {!hasRequiredKeys && isIdle && <div className=\"pp-key-warning\">Set API keys in the sidebar to start enrichment</div>}\n\n        {/* Progress bar */}\n        <div className=\"pp-progress-section\">\n          <div className=\"pp-progress-header\">\n            <span className=\"pp-progress-completed\">\n              {progress.completed} / {progress.total} tasks\n            </span>\n            <span className=\"pp-progress-percent\">{progressPercent}%</span>\n          </div>\n          <div className=\"illuminator-progress\">\n            <div className=\"illuminator-progress-bar\" style={{\n            \"--pp-bar-width\": `${progressPercent}%`\n          }} />\n          </div>\n        </div>\n\n        {/* Current task */}\n        {runningTasks.length > 0 && <div className=\"pp-current-task\">\n            <div className=\"pp-current-task-label\">Currently processing:</div>\n            {runningTasks.map(task => <div key={task.id} className=\"pp-current-task-item\">\n                {task.entityName} - {task.type}\n              </div>)}\n          </div>}\n\n        {/* Stats */}\n        <div className=\"pp-stats-grid\">\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{completedTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-completed\">Completed</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{runningTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-running\">Running</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{pendingTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-pending\">Pending</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className={`pp-stat-value${errorTasks.length > 0 ? \" pp-stat-value-danger\" : \"\"}`}>\n              {errorTasks.length}\n            </div>\n            <div className=\"pp-stat-label pp-stat-label-errors\">Errors</div>\n          </div>\n        </div>\n      </div>\n\n      {/* Error log */}\n      {errorTasks.length > 0 && <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title pp-error-title\">Errors ({errorTasks.length})</h2>\n          </div>\n          <div className=\"pp-error-list\">\n            {errorTasks.map(task => <div key={task.id} className=\"pp-error-item\">\n                <div className=\"pp-error-item-name\">\n                  {task.entityName} - {task.type}\n                </div>\n                <div className=\"pp-error-item-message\">{task.error || \"Unknown error\"}</div>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* Completion message */}\n      {isComplete && <div className=\"illuminator-card\">\n          <div className=\"pp-complete-section\">\n            <div className=\"pp-complete-icon\">&#x2728;</div>\n            <div className=\"pp-complete-title\">Enrichment Complete!</div>\n            <div className=\"pp-complete-summary\">\n              {completedTasks.length} tasks completed\n              {errorTasks.length > 0 && `, ${errorTasks.length} errors`}\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}", "type": "{ status: any; progress: any; tasks: any; onPause: any; onResume: any; onAbort: any; onRunAll: any; hasRequiredKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ProgressPanel.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/QuickCheckModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/QuickCheckModal.jsx", "sourceCode": "// ---------------------------------------------------------------------------\n// QuickCheckModal\n// ---------------------------------------------------------------------------\n\nexport default function QuickCheckModal({\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}) {\n  if (!report) return null;\n  const {\n    suspects,\n    assessment,\n    summary\n  } = report;\n  return <div className=\"qcm-overlay\" onClick={e => {\n    if (e.target === e.currentTarget) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"qcm-dialog\">\n        {/* Header */}\n        <div className=\"qcm-header\">\n          <div>\n            <div className=\"qcm-header-title\">Quick Check \u2014 Unanchored References</div>\n            <div className=\"qcm-header-subtitle\">\n              <span className=\"qcm-assessment-label\"\n            style={{\n              \"--qcm-assessment-color\": ASSESSMENT_COLORS[assessment] || \"var(--text-muted)\"\n            }}>\n                {ASSESSMENT_LABELS[assessment] || assessment}\n              </span>{\" \"}\n              &bull; {suspects.length} suspect{suspects.length !== 1 ? \"s\" : \"\"}\n            </div>\n          </div>\n          <button onClick={onClose} className=\"qcm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Summary */}\n        <div className=\"qcm-summary\">{summary}</div>\n\n        {/* Suspects list */}\n        <div className=\"qcm-suspects-list\">\n          {suspects.length === 0 ? <div className=\"qcm-empty-message\">No unanchored references detected.</div> : suspects.map((suspect, i) => <SuspectCard key={i} suspect={suspect} entities={entities} onCreateEntity={onCreateEntity} />)}\n        </div>\n\n        {/* Footer */}\n        <div className=\"qcm-footer\">\n          <button onClick={onClose} className=\"illuminator-button qcm-footer-btn\">\n            Dismiss\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}", "type": "{ report: any; entities: any; onCreateEntity: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./QuickCheckModal.css", "specifiers": [], "category": "internal"}]}]