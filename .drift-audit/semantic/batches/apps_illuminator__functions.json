[{"id": "apps/illuminator/webui/src/IlluminatorRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/IlluminatorRemote.jsx", "sourceCode": "export default function IlluminatorRemote({\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}) {\n  const activeTab = activeSection || \"entities\";\n  const setActiveTab = onSectionChange || (() => {});\n  const [chronicleRefreshTrigger, setChronicleRefreshTrigger] = useState(0);\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominenceScale = useProminenceScale();\n  const apiKeys = useApiKeys();\n  const { config, updateConfig } = useConfigSync({\n    externalEnrichmentConfig,\n    onEnrichmentConfigChange,\n  });\n  const { worldContext, updateWorldContext } = useWorldContextSync({\n    externalWorldContext,\n    onWorldContextChange,\n  });\n  const guidance = useEntityGuidanceSync({\n    externalEntityGuidance,\n    onEntityGuidanceChange,\n    externalCultureIdentities,\n    onCultureIdentitiesChange,\n  });\n  const { historianConfig, updateHistorianConfig } = useHistorianConfigSync({\n    externalHistorianConfig,\n    onHistorianConfigChange,\n  });\n  const slot = useSlotManagement({ projectId, activeSlotIndex, navEntities });\n  const dataSync = useDataSync({\n    projectId,\n    activeSlotIndex,\n    worldData,\n    hasHardState: Boolean(worldData?.hardState?.length),\n    slotRecord: slot.slotRecord,\n    setSlotRecord: slot.setSlotRecord,\n    simulationRunId: slot.simulationRunId,\n    eraTemporalInfo: slot.eraTemporalInfo,\n  });\n  const setup = useIlluminatorSetup({\n    projectId,\n    worldData,\n    schema,\n    onStyleSelectionChange,\n    config,\n    apiKeys,\n    slotRecord: slot.slotRecord,\n    currentEra: slot.currentEra,\n    simulationRunId: slot.simulationRunId,\n    handleEntityUpdate: dataSync.handleEntityUpdate,\n    reloadEntities: dataSync.reloadEntities,\n    reloadEntitiesAndEvents: dataSync.reloadEntitiesAndEvents,\n    worldContext,\n    historianConfig,\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    navEntities,\n    setChronicleRefreshTrigger,\n  });\n  const { buildPrompt, getVisualConfig } = usePromptBuilder({\n    entityGuidance: guidance.entityGuidance,\n    cultureIdentities: guidance.cultureIdentities,\n    worldContext,\n    relationshipsByEntity,\n    entityNavMap,\n    currentEra: slot.currentEra,\n    narrativeEvents,\n    prominentByCulture: slot.prominentByCulture,\n    styleSelection: setup.styleSelection,\n    worldSchema: setup.worldSchema,\n    config,\n    prominenceScale,\n    styleLibrary: setup.styleLibrary,\n    eraTemporalInfo: slot.eraTemporalInfo,\n    eraTemporalInfoByKey: slot.eraTemporalInfoByKey,\n  });\n  const flows = useIlluminatorFlows({\n    projectId,\n    simulationRunId: slot.simulationRunId,\n    navEntities,\n    entityNavMap,\n    relationshipsByEntity,\n    relationships,\n    prominenceScale,\n    worldContext,\n    worldSchema: setup.worldSchema,\n    entityGuidance: guidance.entityGuidance,\n    reloadEntities: dataSync.reloadEntities,\n    setChronicleRefreshTrigger,\n    historianConfig,\n    updateWorldContext,\n  });\n  if (!setup.hasWorldData) {\n    return (\n      <EmptyState\n        icon=\"\u2728\"\n        title={setup.canImport ? \"No Local Data Loaded\" : \"No World Data\"}\n        className=\"illuminator-empty-state\"\n      >\n        <div className=\"empty-state-desc\">\n          {setup.canImport ? (\n            \"Dexie is empty for this slot. Import from hard state to begin.\"\n          ) : (\n            <>\n              Run a simulation in <strong>Lore Weave</strong> first, then return here to enrich your\n              world with LLM-generated descriptions and images.\n            </>\n          )}\n        </div>\n        {setup.canImport && (\n          <div className=\"ies-import-actions\">\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-primary\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"patch\")}\n            >\n              {dataSync.isDataSyncing ? \"Importing...\" : \"Patch from Hard State\"}\n            </button>\n            <button\n              type=\"button\"\n              className=\"illuminator-btn illuminator-btn-danger\"\n              disabled={dataSync.isDataSyncing}\n              onClick={() => dataSync.handleDataSync(\"overwrite\")}\n            >\n              Overwrite from Hard State\n            </button>\n          </div>\n        )}\n        {dataSync.dataSyncStatus && (\n          <div\n            className={`ies-sync-status ${dataSync.dataSyncStatus.type === \"error\" ? \"ies-sync-status-error\" : \"ies-sync-status-success\"}`}\n          >\n            {dataSync.dataSyncStatus.message}\n          </div>\n        )}\n      </EmptyState>\n    );\n  }\n  const sharedProps = buildSharedProps({\n    activeTab,\n    setActiveTab,\n    worldData,\n    updateWorldContext,\n    guidance,\n    updateHistorianConfig,\n    config,\n    updateConfig,\n    buildPrompt,\n    getVisualConfig,\n    chronicleRefreshTrigger,\n    setChronicleRefreshTrigger,\n    setup,\n    dataSync,\n    flows,\n    apiKeys,\n  });\n  return (\n    <div className=\"illuminator-container\">\n      <IlluminatorSidebar\n        activeTab={activeTab}\n        setActiveTab={setActiveTab}\n        stats={setup.stats}\n        imageGenSettings={setup.imageGenSettings}\n        styleLibrary={setup.styleLibrary}\n        {...apiKeys}\n      />\n      <div className=\"illuminator-main\">\n        {setup.isTemporarySlot && (\n          <div className=\"illuminator-temp-slot-warning\">\n            <span className=\"illuminator-temp-slot-warning-icon\">&#x26A0;</span>\n            <span>\n              You are enriching data in a <strong>temporary slot</strong>, which will be\n              automatically deleted when a new Lore Weave simulation is run.\n            </span>\n          </div>\n        )}\n        {!apiKeys.hasRequiredKeys && activeTab === \"entities\" && (\n          <div className=\"ilr-api-key-warning\">\n            Set your API keys in the sidebar to enable enrichment.\n          </div>\n        )}\n        <IlluminatorTabContent {...sharedProps} />\n      </div>\n      <IlluminatorModals {...sharedProps} />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext: externalWorldContext,\n  onWorldContextChange,\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities: externalCultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig: externalEnrichmentConfig,\n  onEnrichmentConfigChange,\n  onStyleSelectionChange,\n  historianConfig: externalHistorianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex = 0,\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex?: number; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ActivityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ActivityPanel.jsx", "sourceCode": "export default function ActivityPanel({\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}) {\n  const [debugItem, setDebugItem] = useState(null);\n  const mouseDownOnOverlay = useRef(false);\n  const handleOverlayMouseDown = useCallback(e => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n  const handleOverlayClick = useCallback(e => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setDebugItem(null);\n    }\n  }, []);\n\n  // Split queue into categories\n  const {\n    running,\n    queued,\n    completed,\n    errored\n  } = useMemo(() => {\n    const running = queue.filter(item => item.status === \"running\");\n    const queued = queue.filter(item => item.status === \"queued\");\n    const completed = queue.filter(item => item.status === \"complete\").sort((a, b) => (b.completedAt || 0) - (a.completedAt || 0)).slice(0, 20);\n    const errored = queue.filter(item => item.status === \"error\");\n    return {\n      running,\n      queued,\n      completed,\n      errored\n    };\n  }, [queue]);\n  const debugRequest = debugItem?.debug?.request || \"\";\n  const debugResponse = debugItem?.debug?.response || \"\";\n  return <div>\n      {/* Stats header */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Activity</h2>\n          <div className=\"ap-header-actions\">\n            {queue.length > 0 && <button onClick={onCancelAll} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Cancel All\n              </button>}\n            {stats.completed > 0 && <button onClick={onClearCompleted} className=\"illuminator-button illuminator-button-secondary ap-header-btn\">\n                Clear Completed\n              </button>}\n          </div>\n        </div>\n\n        {/* Stats */}\n        <div className=\"ap-stats-row\">\n          <div>\n            <span className=\"ap-stat-value\">{stats.queued}</span>\n            <span className=\"ap-stat-label\">queued</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-running\">{stats.running}</span>\n            <span className=\"ap-stat-label\">running</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-completed\">{stats.completed}</span>\n            <span className=\"ap-stat-label\">completed</span>\n          </div>\n          <div>\n            <span className=\"ap-stat-value ap-stat-value-errors\">{stats.errored}</span>\n            <span className=\"ap-stat-label\">errors</span>\n          </div>\n        </div>\n      </div>\n\n      {/* Currently Running */}\n      {running.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Currently Running</div>\n          {running.map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Queued */}\n      {queued.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Queued ({queued.length})</div>\n          {queued.slice(0, 10).map(item => <TaskRow key={item.id} item={item} onCancel={onCancel} onViewDebug={setDebugItem} />)}\n          {queued.length > 10 && <div className=\"ap-more-indicator\">... and {queued.length - 10} more</div>}\n        </div>}\n\n      {/* Errors */}\n      {errored.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header ap-section-header-errors\">\n            Errors ({errored.length})\n          </div>\n          {errored.map(item => {\n        const activityError = formatActivityError(item);\n        return <div key={item.id}>\n                <TaskRow item={item} onRetry={onRetry} onViewDebug={setDebugItem} />\n                {activityError && <div className=\"ap-error-detail\">{activityError}</div>}\n              </div>;\n      })}\n        </div>}\n\n      {/* Recent Completed */}\n      {completed.length > 0 && <div className=\"illuminator-card ap-section-card\">\n          <div className=\"ap-section-header\">Recent Completed</div>\n          {completed.map(item => <TaskRow key={item.id} item={item} onViewDebug={setDebugItem} />)}\n        </div>}\n\n      {/* Empty state */}\n      {queue.length === 0 && <div className=\"illuminator-card\">\n          <div className=\"ap-empty-state\">\n            No activity yet. Queue some enrichment tasks from the Entities tab.\n          </div>\n        </div>}\n\n      {debugItem && <div className=\"illuminator-modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e);\n    }}>\n          <div className=\"illuminator-modal ap-debug-modal\">\n            <div className=\"illuminator-modal-header\">\n              <h3>Network Debug</h3>\n              <button onClick={() => setDebugItem(null)} className=\"illuminator-modal-close\">\n                &times;\n              </button>\n            </div>\n            <div className=\"illuminator-modal-body ap-debug-body\">\n              <div className=\"ap-debug-entity-info\">\n                {debugItem.entityName}\n                {(() => {\n              if (debugItem.type === \"description\") return \" \u00b7 Description\";\n              if (debugItem.type === \"image\") return \" \u00b7 Image\";\n              return \" \u00b7 Chronicle\";\n            })()}\n              </div>\n              <div>\n                <label htmlFor=\"request-raw\" className=\"ap-debug-label\">Request (raw)</label>\n                <textarea id=\"request-raw\" className=\"illuminator-textarea ap-debug-request-textarea\" value={debugRequest} readOnly />\n              </div>\n              <div>\n                <label htmlFor=\"response-raw\" className=\"ap-debug-label\">Response (raw)</label>\n                <textarea id=\"response-raw\" className=\"illuminator-textarea ap-debug-response-textarea\" value={debugResponse} readOnly />\n              </div>\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  queue,\n  stats,\n  onCancel,\n  onRetry,\n  onCancelAll,\n  onClearCompleted\n}", "type": "{ queue: any; stats: any; onCancel: any; onRetry: any; onCancelAll: any; onClearCompleted: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BackportConfigModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackportConfigModal.jsx", "sourceCode": "export default function BackportConfigModal({\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}) {\n  const statusMap = useMemo(() => perEntityStatus || {}, [perEntityStatus]);\n\n  // Only pending entities are selectable\n  const pendingEntities = useMemo(() => entities.filter(e => !statusMap[e.id]), [entities, statusMap]);\n  const [selectedIds, setSelectedIds] = useState(() => new Set(pendingEntities.map(e => e.id)));\n  const [customInstructions, setCustomInstructions] = useState(\"\");\n\n  // Reset selections when entities or status change (new modal open)\n  const entityKey = entities.map(e => e.id).join(\",\");\n  const statusKey = Object.keys(statusMap).sort().join(\",\");\n  const resetKey = `${entityKey}|${statusKey}`;\n  const [prevKey, setPrevKey] = useState(resetKey);\n  if (resetKey !== prevKey) {\n    setPrevKey(resetKey);\n    setSelectedIds(new Set(entities.filter(e => !statusMap[e.id]).map(e => e.id)));\n    setCustomInstructions(\"\");\n  }\n  const castEntities = useMemo(() => entities.filter(e => !e.isLens && !e.isTertiary), [entities]);\n  const lensEntities = useMemo(() => entities.filter(e => e.isLens), [entities]);\n  const tertiaryEntities = useMemo(() => entities.filter(e => e.isTertiary), [entities]);\n  const doneCount = entities.filter(e => statusMap[e.id]).length;\n  const selectedCount = selectedIds.size;\n  const allPendingSelected = selectedCount === pendingEntities.length && pendingEntities.length > 0;\n  if (!isOpen) return null;\n  const toggleEntity = id => {\n    if (statusMap[id]) return; // locked\n    setSelectedIds(prev => {\n      const next = new Set(prev);\n      if (next.has(id)) next.delete(id);else next.add(id);\n      return next;\n    });\n  };\n  const toggleAllPending = () => {\n    if (allPendingSelected) {\n      setSelectedIds(new Set());\n    } else {\n      setSelectedIds(new Set(pendingEntities.map(e => e.id)));\n    }\n  };\n  const selectTertiaryOnly = () => {\n    setSelectedIds(new Set(tertiaryEntities.filter(e => !statusMap[e.id]).map(e => e.id)));\n  };\n  const handleMarkNotNeeded = entityId => {\n    onMarkNotNeeded([entityId]);\n  };\n  let progressColor;\n  if (doneCount === entities.length) progressColor = \"#10b981\";else if (doneCount > 0) progressColor = \"#f59e0b\";else progressColor = \"var(--text-muted)\";\n  const renderEntityRow = e => {\n    const status = statusMap[e.id];\n    const isLocked = !!status;\n    return <div key={e.id} className={`bcm-entity-row ${isLocked ? \"bcm-entity-row-locked\" : \"\"}`}>\n        {isLocked ? <span className={`bcm-status-icon ${status === \"backported\" ? \"bcm-status-icon-done\" : \"bcm-status-icon-skipped\"}`}>\n            {status === \"backported\" ? \"\\u2713\" : \"\\u2014\"}\n          </span> : <input type=\"checkbox\" checked={selectedIds.has(e.id)} onChange={() => toggleEntity(e.id)} className=\"bcm-checkbox\" />}\n        <span className={`bcm-entity-name ${isLocked ? \"bcm-entity-name-locked\" : \"bcm-entity-name-clickable\"}`} onClick={() => !isLocked && toggleEntity(e.id)} role=\"button\" tabIndex={0} onKeyDown={e => {\n        if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n      }}>\n          {e.name}\n          <span className=\"bcm-entity-kind\">\n            {e.kind}\n            {e.subtype ? ` / ${e.subtype}` : \"\"}\n          </span>\n        </span>\n        {/* Status / action tags */}\n        {status === \"backported\" && <span className=\"bcm-tag bcm-tag-done\">Done</span>}\n        {status === \"not_needed\" && <span className=\"bcm-tag bcm-tag-skipped\">Skipped</span>}\n        {!status && <button onClick={ev => {\n        ev.stopPropagation();\n        handleMarkNotNeeded(e.id);\n      }} title=\"Mark as no backport needed\" className=\"bcm-skip-btn\">\n            Skip\n          </button>}\n        {e.isLens && <span className=\"bcm-tag bcm-tag-lens\">Lens</span>}\n        {e.isTertiary && <span className=\"bcm-tag bcm-tag-tertiary\">Tertiary</span>}\n      </div>;\n  };\n  return <div className=\"bcm-overlay\">\n      <div className=\"bcm-dialog\">\n        {/* Header */}\n        <div className=\"bcm-header\">\n          <h2 className=\"bcm-title\">Backport Lore to Cast</h2>\n          <div className=\"bcm-subtitle-row\">\n            <p className=\"bcm-chronicle-title\">{chronicleTitle}</p>\n            <span className=\"bcm-progress\"\n          style={{\n            \"--bcm-progress-color\": progressColor\n          }}>\n              {doneCount}/{entities.length} complete\n            </span>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className=\"bcm-body\">\n          {/* Entity selection */}\n          <div className=\"bcm-section\">\n            <div className=\"bcm-section-header\">\n              <span className=\"bcm-section-label\">\n                Entities ({selectedCount} selected\n                {pendingEntities.length < entities.length ? `, ${doneCount} done` : \"\"})\n              </span>\n              <span className=\"bcm-action-group\">\n                {tertiaryEntities.length > 0 && <button onClick={selectTertiaryOnly} className=\"bcm-text-btn bcm-text-btn-tertiary\">\n                    Tertiary only\n                  </button>}\n                {pendingEntities.length > 0 && <button onClick={toggleAllPending} className=\"bcm-text-btn bcm-text-btn-accent\">\n                    {allPendingSelected ? \"Deselect all\" : \"Select all pending\"}\n                  </button>}\n              </span>\n            </div>\n\n            <div className=\"bcm-entity-list\">\n              {castEntities.map(renderEntityRow)}\n              {lensEntities.length > 0 && castEntities.length > 0 && <div className=\"bcm-divider\" />}\n              {lensEntities.map(renderEntityRow)}\n              {tertiaryEntities.length > 0 && (castEntities.length > 0 || lensEntities.length > 0) && <div className=\"bcm-divider\">\n                    <div className=\"bcm-tertiary-label\">Tertiary Cast</div>\n                  </div>}\n              {tertiaryEntities.map(renderEntityRow)}\n            </div>\n          </div>\n\n          {/* Custom instructions */}\n          <div>\n            <label htmlFor=\"custom-instructions-optional\" className=\"bcm-instructions-label\">Custom Instructions (optional)</label>\n            <textarea id=\"custom-instructions-optional\" value={customInstructions} onChange={e => setCustomInstructions(e.target.value)} placeholder={'e.g. \"This chronicle is a fable \\u2014 treat its events as in-universe fiction, not canonical history. Backported lore should reference these events as legends, myths, or disputed accounts.\"'} rows={3} className=\"bcm-textarea\" />\n            <p className=\"bcm-instructions-hint\">\n              These instructions will be injected as critical directives into the backport prompt.\n              Use this for non-canonical chronicles (fables, prophecies, dreamscapes) or any special\n              handling.\n            </p>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"bcm-footer\">\n          <button onClick={onCancel} className=\"illuminator-button illuminator-button-secondary bcm-footer-btn\">\n            Cancel\n          </button>\n          <button onClick={() => onStart(Array.from(selectedIds), customInstructions.trim())} disabled={selectedCount === 0} className=\"illuminator-button illuminator-button-primary bcm-footer-btn\">\n            Start Backport ({selectedCount} {selectedCount === 1 ? \"entity\" : \"entities\"})\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  isOpen,\n  chronicleTitle,\n  entities,\n  perEntityStatus,\n  // Record<string, 'backported' | 'not_needed'> \u2014 already-resolved status per entity\n  onStart,\n  onMarkNotNeeded,\n  // (entityIds: string[]) => void \u2014 mark entities as not needing backport\n  onCancel\n}", "type": "{ isOpen: any; chronicleTitle: any; entities: any; perEntityStatus: any; onStart: any; onMarkNotNeeded: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BackrefImageEditor.jsx", "sourceCode": "/**\n * BackrefImageEditor - Main editor component\n *\n * Props:\n * - entity: Entity with enrichment.chronicleBackrefs\n * - entities: All entities (for resolving entity portraits)\n * - onUpdateBackrefs: (entityId, updatedBackrefs) => void\n */\nexport default function BackrefImageEditor({\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}) {\n  const [chronicles, setChronicles] = useState(new Map());\n  const [expanded, setExpanded] = useState(alwaysExpanded);\n  const backrefs = useMemo(\n    () => entity?.enrichment?.chronicleBackrefs || [],\n    [entity?.enrichment?.chronicleBackrefs]\n  );\n\n  // Stable key for chronicle IDs to use as dependency\n  const backrefChronicleKey = useMemo(\n    () => backrefs.map((b) => b.chronicleId).join(\",\"),\n    [backrefs]\n  );\n\n  // Load chronicle records for all backrefs\n  useEffect(() => {\n    if (backrefs.length === 0) return;\n\n    const chronicleIds = [...new Set(backrefs.map((b) => b.chronicleId))];\n    let cancelled = false;\n\n    Promise.all(chronicleIds.map((id) => getChronicle(id).then((c) => [id, c]))).then((results) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const [id, chronicle] of results) {\n        if (chronicle) map.set(id, chronicle);\n      }\n      setChronicles(map);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [backrefs, backrefChronicleKey]);\n\n  // Collect all image IDs we need to load\n  const allImageIds = useMemo(() => {\n    const ids = [];\n    for (const chronicle of chronicles.values()) {\n      // Cover image\n      if (chronicle.coverImage?.generatedImageId) {\n        ids.push(chronicle.coverImage.generatedImageId);\n      }\n      // Scene images\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.generatedImageId) {\n            ids.push(ref.generatedImageId);\n          }\n        }\n      }\n      // Entity portraits from cast\n      for (const role of chronicle.roleAssignments || []) {\n        const ent = entities.find((e) => e.id === role.entityId);\n        if (ent?.enrichment?.image?.imageId) {\n          ids.push(ent.enrichment.image.imageId);\n        }\n      }\n    }\n    return [...new Set(ids)];\n  }, [chronicles, entities]);\n\n  // Only load blobs when the editor is visible (expanded or alwaysExpanded)\n  const { urls: imageUrls } = useImageUrls(expanded ? allImageIds : []);\n\n  const handleBackrefChange = useCallback(\n    (updatedBackref) => {\n      const updated = backrefs.map((b) =>\n        b.chronicleId === updatedBackref.chronicleId &&\n        b.anchorPhrase === updatedBackref.anchorPhrase\n          ? updatedBackref\n          : b\n      );\n      onUpdateBackrefs(entity.id, updated);\n    },\n    [backrefs, entity.id, onUpdateBackrefs]\n  );\n\n  if (backrefs.length === 0) return null;\n\n  const rowsContent = (\n    <div\n      className={alwaysExpanded ? \"bie-rows-container-expanded\" : \"bie-rows-container-collapsed\"}\n    >\n      {backrefs.map((backref, i) => (\n        <BackrefRow\n          key={`${backref.chronicleId}-${i}`}\n          backref={backref}\n          chronicle={chronicles.get(backref.chronicleId) || null}\n          entities={entities}\n          imageUrls={imageUrls}\n          onChange={handleBackrefChange}\n        />\n      ))}\n    </div>\n  );\n\n  if (alwaysExpanded) {\n    return (\n      <div className=\"bie-wrapper\">\n        <div className=\"bie-heading\">Chronicle Images ({backrefs.length})</div>\n        {rowsContent}\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bie-wrapper\">\n      <button onClick={() => setExpanded(!expanded)} className=\"bie-toggle-btn\">\n        <span\n          className={`bie-toggle-arrow ${expanded ? \"bie-toggle-arrow-expanded\" : \"bie-toggle-arrow-collapsed\"}`}\n        >\n          \u25b6\n        </span>\n        <span className=\"bie-toggle-label\">Chronicle Images ({backrefs.length})</span>\n      </button>\n      {expanded && rowsContent}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  entities,\n  onUpdateBackrefs,\n  alwaysExpanded = false,\n}", "type": "{ entity: any; entities: any; onUpdateBackrefs: any; alwaysExpanded?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkBackportModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkBackportModal.jsx", "sourceCode": "export default function BulkBackportModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const chronicles = progress?.chronicles;\n  const realTotal = useMemo(() => chronicles ? chronicles.reduce((sum, c) => sum + c.totalEntities, 0) : 0, [chronicles]);\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const currentChronicle = progress?.chronicles?.[progress.currentChronicleIndex];\n  const globalPercent = progress?.totalEntities > 0 ? Math.round(progress.processedEntities / progress.totalEntities * 100) : 0;\n  const completedChronicles = progress?.chronicles?.filter(c => c.status === \"complete\").length ?? 0;\n  const failedChronicles = progress?.chronicles?.filter(c => c.status === \"failed\").length ?? 0;\n  let progressFillModifier;\n  if (progress?.status === \"failed\") progressFillModifier = \"bbm-progress-fill-failed\";else if (progress?.status === \"cancelled\") progressFillModifier = \"bbm-progress-fill-cancelled\";else progressFillModifier = \"bbm-progress-fill-ok\";\n  const progressFillClass = `bbm-progress-fill ${progressFillModifier}`;\n\n  // Header status text\n  let statusText;\n  if (isConfirming) statusText = `${progress?.chronicles?.length ?? 0} chronicles`;else if (progress?.status === \"running\") statusText = \"Processing...\";else if (progress?.status === \"complete\") statusText = \"Complete\";else if (progress?.status === \"cancelled\") statusText = \"Cancelled\";else if (progress?.status === \"failed\") statusText = \"Failed\";\n\n  // Pill status text when minimized\n  const pillStatusText = progress?.status === \"running\" ? `${progress.processedEntities}/${progress.totalEntities}` : progress?.status;\n  return <BulkOperationShell pillId={PILL_ID} title=\"Bulk Backport\" tabId=\"chronicle\" progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={`Start Backport (${progress?.totalEntities ?? 0} entities)`} statusText={statusText} pillStatusText={pillStatusText} confirmWidth=\"540px\" processWidth=\"480px\">\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && progress.entitySummary && <div className=\"bbm-entity-section\">\n          <div className=\"bbm-entity-header\">\n            <span className=\"bbm-section-label\">\n              Entities ({progress.entitySummary.length})\n            </span>\n            <span className=\"bbm-section-meta\">\n              {progress.totalEntities} updates across {progress.chronicles.length} chronicles\n            </span>\n          </div>\n\n          <div className=\"bbm-entity-list\">\n            {progress.entitySummary.map((entity, i) => <div key={entity.entityId} className={`bbm-entity-row ${i < progress.entitySummary.length - 1 ? \"bbm-entity-row-bordered\" : \"\"}`}>\n                <div className=\"bbm-entity-info\">\n                  <span className=\"bbm-entity-name\">{entity.entityName}</span>\n                  <span className=\"bbm-entity-kind\">\n                    {entity.entityKind}\n                    {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                  </span>\n                </div>\n                <span className=\"bbm-entity-chr\" title={`${entity.chronicleCount} chronicle${entity.chronicleCount !== 1 ? \"s\" : \"\"} will update this entity`}>\n                  {entity.chronicleCount} chr\n                </span>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* ---- Processing screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <div className=\"bbm-progress-section\">\n            <div className=\"bbm-progress-header\">\n              <span className=\"bbm-progress-label\">\n                Chronicle{\" \"}\n                {Math.min(progress.currentChronicleIndex + 1, progress.chronicles.length)} /{\" \"}\n                {progress.chronicles.length}\n              </span>\n              <span className=\"bbm-progress-percent\">{globalPercent}%</span>\n            </div>\n\n            {/* Global progress bar */}\n            <div className=\"bbm-progress-track\">\n              <div className={progressFillClass}\n          style={{\n            \"--bbm-progress-width\": `${globalPercent}%`\n          }} />\n            </div>\n\n            <div className=\"bbm-progress-stats\">\n              <span>\n                {progress.processedEntities} / {realTotal || progress.totalEntities} entities\n              </span>\n              <span>\n                {completedChronicles} / {progress.chronicles.length} chronicles\n              </span>\n            </div>\n          </div>\n\n          {/* Current chronicle detail */}\n          {currentChronicle && !isTerminal && <div className=\"bbm-chronicle-detail\">\n              <div className=\"bbm-chronicle-title\">{currentChronicle.chronicleTitle}</div>\n\n              {currentChronicle.totalBatches > 1 && <div className=\"bbm-chronicle-batch-info\">\n                  <span>\n                    Batch{\" \"}\n                    {Math.min(currentChronicle.completedBatches + 1, currentChronicle.totalBatches)}{\" \"}\n                    / {currentChronicle.totalBatches}\n                  </span>\n                  <span>\n                    {currentChronicle.processedEntities} / {currentChronicle.totalEntities}{\" \"}\n                    entities\n                  </span>\n                </div>}\n\n              {currentChronicle.totalBatches <= 1 && <div className=\"bbm-chronicle-entity-count\">\n                  {currentChronicle.totalEntities} entities\n                </div>}\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              Backported {progress.processedEntities} entities across {completedChronicles}{\" \"}\n              chronicles.\n              {failedChronicles > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {failedChronicles} chronicle(s) failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} entities across{\" \"}\n              {completedChronicles} chronicles.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkChronicleAnnotationModal.jsx", "sourceCode": "export default function BulkChronicleAnnotationModal({ progress, onConfirm, onCancel, onClose }) {\n  const isClear = progress?.operation === \"clear\";\n  const title = isClear ? \"Clear Annotations\" : \"Run Annotations\";\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  const withNotes = progress?.chronicles?.filter((c) => c.hasNotes).length || 0;\n  const withTones = progress?.chronicles?.filter((c) => c.assignedTone).length || 0;\n\n  const confirmLabel = isClear\n    ? `Clear (${progress?.totalChronicles || 0} chronicles)`\n    : `Annotate (${progress?.totalChronicles || 0} chronicles)`;\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-chronicle-annotation\"\n      title={title}\n      tabId=\"chronicle\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={confirmLabel}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            {isClear ? (\n              <>\n                This will clear all historian annotations from {progress.totalChronicles}{\" \"}\n                chronicle{progress.totalChronicles !== 1 ? \"s\" : \"\"}. Annotations cannot be\n                recovered after clearing.\n              </>\n            ) : (\n              <>\n                Each chronicle gets a historian review using its assigned tone. Results are\n                auto-applied (no manual review step). Chronicles processed sequentially \u2014 one\n                LLM call each.\n                {withTones < progress.totalChronicles && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {progress.totalChronicles - withTones} chronicle\n                    {progress.totalChronicles - withTones !== 1 ? \"s\" : \"\"} have no assigned\n                    tone and will default to &quot;weary&quot;.\n                  </span>\n                )}\n                {withNotes > 0 && (\n                  <span className=\"bcam-warning-text\">\n                    {\" \"}\n                    {withNotes} chronicle{withNotes !== 1 ? \"s\" : \"\"} already have annotations \u2014\n                    they will be replaced.\n                  </span>\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Chronicle list */}\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bcam-chronicle-item\">\n                  <span className=\"bcam-chronicle-title\">{chron.title}</span>\n                  {!isClear && (\n                    <span className=\"bcam-chronicle-tone\">\n                      {chron.assignedTone || \"weary\"}\n                      {chron.hasNotes ? \" \u270e\" : \"\"}\n                    </span>\n                  )}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <>\n              <div className=\"bcam-current-title\">\n                {progress.currentTitle || (isClear ? \"Clearing...\" : \"Annotating...\")}\n              </div>\n\n              <BulkProgressBar\n                processed={progress.processedChronicles}\n                total={progress.totalChronicles}\n                status={progress.status}\n              />\n\n              <div className=\"bcam-progress-stats\">\n                <span>\n                  {progress.processedChronicles} / {progress.totalChronicles}{\" \"}\n                  {isClear ? \"cleared\" : \"annotated\"}\n                </span>\n                {!isClear && progress.currentTone && (\n                  <span>tone: {progress.currentTone}</span>\n                )}\n              </div>\n            </>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              {isClear\n                ? `Cleared annotations from ${progress.processedChronicles} chronicle${progress.processedChronicles !== 1 ? \"s\" : \"\"}.`\n                : `Annotated ${progress.processedChronicles} of ${progress.totalChronicles} chronicles.`}\n              {progress.failedChronicles.length > 0 &&\n                ` (${progress.failedChronicles.length} failed)`}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkEraNarrativeModal.jsx", "sourceCode": "export default function BulkEraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}) {\n  const progress = useBulkEraNarrativeStore(s => s.progress);\n  const prepareBulk = useBulkEraNarrativeStore(s => s.prepareBulk);\n  const confirmBulk = useBulkEraNarrativeStore(s => s.confirmBulk);\n  const cancelBulk = useBulkEraNarrativeStore(s => s.cancelBulk);\n  const closeBulk = useBulkEraNarrativeStore(s => s.closeBulk);\n  const setEraTone = useBulkEraNarrativeStore(s => s.setEraTone);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Build narrative weight map from style library\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Find the active eraNarrative task in the queue for streaming\n  const activeTaskId = useEnrichmentQueueStore(s => {\n    const item = s.queue.find(q => q.type === \"eraNarrative\" && q.status === \"running\");\n    return item?.id || null;\n  });\n\n  // Subscribe to streaming text for the active task\n  const streamEntry = useThinkingStore(s => activeTaskId ? s.entries.get(activeTaskId) : undefined);\n\n  // Refs for values used in the prepare effect that shouldn't trigger re-run\n  const prepareDepsRef = useRef({\n    chronicleItems,\n    wizardEras,\n    eraTemporalInfo,\n    projectId,\n    simulationRunId,\n    narrativeWeightMap,\n    prepareBulk,\n    progress\n  });\n  useEffect(() => {\n    prepareDepsRef.current = {\n      chronicleItems,\n      wizardEras,\n      eraTemporalInfo,\n      projectId,\n      simulationRunId,\n      narrativeWeightMap,\n      prepareBulk,\n      progress\n    };\n  }, [chronicleItems, wizardEras, eraTemporalInfo, projectId, simulationRunId, narrativeWeightMap, prepareBulk, progress]);\n\n  // Prepare when opening\n  useEffect(() => {\n    const {\n      chronicleItems: ci,\n      wizardEras: we,\n      eraTemporalInfo: eti,\n      projectId: pid,\n      simulationRunId: sid,\n      narrativeWeightMap: nwm,\n      prepareBulk: pb,\n      progress: p\n    } = prepareDepsRef.current;\n    if (isOpen && p.status === \"idle\" && ci?.length > 0 && we?.length > 0) {\n      pb(ci, we, eti, pid, sid, \"witty\", nwm);\n    }\n  }, [isOpen]);\n  const progressStatus = progress?.status;\n  const processedEras = progress?.processedEras;\n  const totalEras = progress?.totalEras;\n\n  // Update pill while minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedEras}/${totalEras}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedEras, totalEras]);\n\n  // Remove pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!isOpen) return null;\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isRunning = progress.status === \"running\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalEras > 0 ? Math.round(progress.processedEras / progress.totalEras * 100) : 0;\n  const handleConfirm = () => {\n    confirmBulk();\n  };\n  const handleCancel = () => {\n    cancelBulk();\n    if (progress.status === \"confirming\") {\n      onClose();\n    }\n  };\n  const handleClose = () => {\n    closeBulk();\n    onClose();\n  };\n  let statusColor;\n  if (progress.status === \"complete\") statusColor = \"#10b981\";else if (progress.status === \"failed\") statusColor = \"#ef4444\";else if (progress.status === \"cancelled\") statusColor = \"#f59e0b\";else statusColor = \"var(--text-muted)\";\n  let progressFillModifier;\n  if (progress.status === \"failed\") progressFillModifier = \"benm-progress-fill-failed\";else if (progress.status === \"cancelled\") progressFillModifier = \"benm-progress-fill-cancelled\";else progressFillModifier = \"benm-progress-fill-complete\";\n  const progressFillClass = `benm-progress-fill ${progressFillModifier}`;\n  return <div className=\"benm-overlay\">\n      <div className=\"benm-modal\"\n    style={{\n      \"--benm-modal-width\": isConfirming ? \"540px\" : \"560px\"\n    }}>\n        {/* Header */}\n        <div className=\"benm-header\">\n          <div className=\"benm-header-row\">\n            <h2 className=\"benm-title\">Bulk Era Narrative</h2>\n            <div className=\"benm-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Bulk Era Narrative\",\n              statusText: progress.status === \"running\" ? `${progress.processedEras}/${progress.totalEras}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })(),\n              tabId: \"chronicle\"\n            })} className=\"illuminator-button benm-minimize-btn\" title=\"Minimize to pill\">\n                  {\"\\u2015\"}\n                </button>}\n              <span className=\"benm-status-label\"\n            style={{\n              \"--benm-status-color\": statusColor\n            }}>\n                {isConfirming && `${progress.totalEras} eras`}\n                {isRunning && \"Processing...\"}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`benm-body ${isConfirming ? \"benm-body-confirming\" : \"benm-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              {/* Era list with per-era tone */}\n              <div className=\"benm-era-section\">\n                <div className=\"benm-section-label\">Eras ({progress.eras.length})</div>\n                <div className=\"benm-era-list\">\n                  {progress.eras.map((era, i) => {\n                return <div key={era.eraId} className={`benm-era-row ${i < progress.eras.length - 1 ? \"benm-era-row-bordered\" : \"\"}`}>\n                        <div className=\"benm-era-row-info\">\n                          <span className=\"benm-era-name\">{era.eraName}</span>\n                        </div>\n                        <div className=\"benm-era-row-actions\">\n                          <span className=\"benm-era-prepped\">\n                            {era.preppedCount}/{era.totalCount} prepped\n                          </span>\n                          {era.hasExisting && <span className=\"benm-era-existing\" title=\"Has existing completed narrative\">\n                              {\"\\u2713\"}\n                            </span>}\n                          {/* Per-era tone selector */}\n                          <div className=\"benm-tone-selector\">\n                            {TONE_OPTIONS.map(t => {\n                        const meta = TONE_META[t];\n                        const selected = era.tone === t;\n                        return <button key={t} onClick={() => setEraTone(era.eraId, t)} title={meta?.label} className={`benm-tone-btn ${selected ? \"benm-tone-btn-selected\" : \"benm-tone-btn-default\"}`}>\n                                  {meta?.symbol}\n                                </button>;\n                      })}\n                          </div>\n                        </div>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing + terminal ---- */}\n          {!isConfirming && <>\n              {/* Progress bar */}\n              <div className=\"benm-progress-section\">\n                <div className=\"benm-progress-header\">\n                  <span className=\"benm-progress-era-label\">\n                    Era {Math.min(progress.processedEras + 1, progress.totalEras)} /{\" \"}\n                    {progress.totalEras}\n                  </span>\n                  <span className=\"benm-progress-percent\">{globalPercent}%</span>\n                </div>\n                <div className=\"benm-progress-track\">\n                  <div className={progressFillClass}\n              style={{\n                \"--benm-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n                <div className=\"benm-progress-counts\">\n                  {progress.processedEras} / {progress.totalEras} eras\n                </div>\n              </div>\n\n              {/* Current era \u2014 step progress with live word counts */}\n              {progress.currentEraName && !isTerminal && (() => {\n            const currentEra = progress.eras.find(e => e.eraName === progress.currentEraName);\n            const currentToneMeta = currentEra ? TONE_META[currentEra.tone] : null;\n            const stepOrder = [\"threads\", \"generate\", \"edit\"];\n            const activeIdx = stepOrder.indexOf(progress.currentStep);\n\n            // Live word counts from streaming deltas\n            const thinkingWords = streamEntry?.thinking ? streamEntry.thinking.split(/\\s+/).filter(Boolean).length : 0;\n            const outputWords = streamEntry?.text ? streamEntry.text.split(/\\s+/).filter(Boolean).length : 0;\n            return <div className=\"benm-current-era\">\n                      {/* Era name + tone */}\n                      <div className=\"benm-current-era-name\">\n                        {currentToneMeta && <span className=\"benm-current-era-tone\" title={currentToneMeta.label}>\n                            {currentToneMeta.symbol}\n                          </span>}\n                        {progress.currentEraName}\n                      </div>\n\n                      {/* Step rows */}\n                      <div className=\"benm-steps\">\n                        {stepOrder.map((step, idx) => {\n                  const isDone = idx < activeIdx;\n                  const isActive = idx === activeIdx;\n                  const isPending = idx > activeIdx;\n                  let icon;\n                  if (isDone) icon = \"\\u2713\";else if (isActive) icon = \"\\u25B8\";else icon = \"\\u25CB\";\n                  let iconColor;\n                  if (isDone) iconColor = \"#10b981\";else if (isActive) iconColor = \"#f59e0b\";else iconColor = \"var(--text-muted)\";\n\n                  // Word count bar caps for visual scaling\n                  let barMax;\n                  if (step === \"generate\") barMax = 4000;else if (step === \"threads\") barMax = 2000;else barMax = 3000;\n                  const barPercent = isActive ? Math.min(100, outputWords / barMax * 100) : 0;\n                  return <div key={step}>\n                              <div className=\"benm-step-row\">\n                                <span className=\"benm-step-icon\"\n                      style={{\n                        \"--benm-step-color\": iconColor\n                      }}>\n                                  {icon}\n                                </span>\n                                <span className={`benm-step-label ${isActive ? \"benm-step-label-active\" : \"\"} ${isPending ? \"benm-step-label-pending\" : \"\"}`}>\n                                  {STEP_LABEL[step]}\n                                </span>\n\n                                {isActive && <div className=\"benm-step-active-content\">\n                                    {/* Mini progress bar */}\n                                    <div className=\"benm-step-bar-track\">\n                                      <div className=\"benm-step-bar-fill\"\n                          style={{\n                            \"--benm-bar-width\": `${barPercent}%`\n                          }} />\n                                    </div>\n                                    {/* Live counters */}\n                                    <span className=\"benm-step-counters\">\n                                      {thinkingWords > 0 && <span title=\"Thinking words received\">\n                                          <span className=\"benm-counter-thinking-label\">T</span>{\" \"}\n                                          {thinkingWords.toLocaleString()}\n                                        </span>}\n                                      {thinkingWords > 0 && outputWords > 0 && <span className=\"benm-counter-separator\">/</span>}\n                                      {outputWords > 0 && <span title=\"Output words received\">\n                                          <span className=\"benm-counter-output-label\">O</span>{\" \"}\n                                          {outputWords.toLocaleString()}\n                                        </span>}\n                                    </span>\n                                  </div>}\n\n                                {isDone && <span className=\"benm-step-done\">done</span>}\n                              </div>\n                            </div>;\n                })}\n                      </div>\n                    </div>;\n          })()}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"benm-terminal-msg benm-terminal-msg-complete\">\n                  Generated {progress.processedEras} era narratives.\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  eraTemporalInfo,\n  projectId,\n  simulationRunId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; eraTemporalInfo: any; projectId: any; simulationRunId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkFactCoverageModal.jsx", "sourceCode": "export default function BulkFactCoverageModal({ progress, onConfirm, onCancel, onClose }) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal =\n    progress?.status === \"complete\" ||\n    progress?.status === \"cancelled\" ||\n    progress?.status === \"failed\";\n\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-fact-coverage\"\n      title=\"Fact Coverage Analysis\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Analyze (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {isConfirming && (\n        <>\n          <div className=\"bulk-info-box\">\n            Analyze each chronicle&apos;s narrative against all canon facts using Haiku. Results are\n            stored per-chronicle and visible in the Reference tab.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">Chronicles ({progress.chronicles.length})</div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {!isConfirming && progress?.status !== \"idle\" && (\n        <>\n          <BulkProgressBar\n            processed={progress.processedChronicles}\n            total={progress.totalChronicles}\n            status={progress.status}\n          />\n\n          <div className=\"bulk-progress-detail\">\n            {progress.processedChronicles} / {progress.totalChronicles} chronicles\n            {progress.failedChronicles?.length > 0 && (\n              <span className=\"bulk-failed-inline\">\n                {\" \"}{progress.failedChronicles.length} failed\n              </span>\n            )}\n          </div>\n\n          {/* Current chronicle */}\n          {progress.currentTitle && !isTerminal && (\n            <div className=\"bulk-current-item\">\n              <div className=\"bulk-current-item-title\">{progress.currentTitle}</div>\n              <div className=\"bulk-current-item-sub\">Analyzing fact coverage...</div>\n            </div>\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Analyzed {progress.processedChronicles} chronicles.\n              {progress.failedChronicles?.length > 0 && (\n                <span className=\"bulk-failed-inline\">\n                  {\" \"}{progress.failedChronicles.length} failed.\n                </span>\n              )}\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          {isTerminal && (\n            <BulkFailedList\n              items={progress.failedChronicles}\n              labelKey=\"title\"\n              errorKey=\"error\"\n            />\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkHistorianModal.jsx", "sourceCode": "export default function BulkHistorianModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}) {\n  const isConfirming = progress?.status === \"confirming\";\n  const isTerminal = progress?.status === \"complete\" || progress?.status === \"cancelled\" || progress?.status === \"failed\";\n  const isReview = progress?.operation === \"review\";\n  const isClear = progress?.operation === \"clear\";\n  const title = progress ? getTitle(progress) : \"\";\n  return <BulkOperationShell pillId=\"bulk-historian\" title={title} progress={progress} onConfirm={onConfirm} onCancel={onCancel} onClose={onClose} confirmLabel={progress ? getConfirmLabel(progress) : \"\"} statusText={progress ? getStatusText(progress) : \"\"} pillStatusText={progress ? getPillText(progress) : \"\"}>\n      {/* ---- Confirmation screen ---- */}\n      {isConfirming && <>\n          {/* Tone section (not for clear) */}\n          {!isClear && isReview && (/* Review mode: show tone cycling info */\n      <div className=\"bhm-tone-cycle-box\">\n              <span className=\"bhm-tone-cycle-label\">Tones cycle:</span>\n              {TONE_CYCLE_ORDER.map((t, i) => {\n          const meta = TONE_META[t];\n          return <span key={t}>\n                    {i > 0 && <span className=\"bhm-tone-cycle-arrow\">&rarr;</span>}\n                    <span className=\"bhm-tone-cycle-symbol\">{meta?.symbol}</span> {meta?.label}\n                  </span>;\n        })}\n            </div>)}\n          {!isClear && !isReview && (/* Edition mode: tone picker */\n      <div className=\"bhm-tone-picker\">\n              <div className=\"bhm-section-label\">Historian Tone</div>\n              <div className=\"bhm-tone-options\">\n                {TONE_CYCLE_ORDER.map(t => {\n            const meta = TONE_META[t];\n            const isSelected = progress.tone === t;\n            return <button key={t} onClick={() => onChangeTone(t)} className={`bhm-tone-btn ${isSelected ? \"bhm-tone-btn-selected\" : \"bhm-tone-btn-default\"}`}>\n                      <span className=\"bhm-tone-btn-symbol\">{meta?.symbol}</span>\n                      {meta?.label}\n                    </button>;\n          })}\n              </div>\n            </div>)}\n\n          {/* Entity list */}\n          <div className=\"bhm-entity-section\">\n            <div className=\"bhm-entity-section-label\">\n              Entities ({progress.entities.length})\n            </div>\n\n            <div className=\"bhm-entity-list\">\n              {progress.entities.map((entity, i) => <div key={entity.entityId} className={`bhm-entity-row ${i < progress.entities.length - 1 ? \"bhm-entity-row-bordered\" : \"\"}`}>\n                  <div className=\"bhm-entity-row-info\">\n                    {isReview && entity.tone && <span className=\"bhm-entity-tone-symbol\" title={TONE_META[entity.tone]?.label || entity.tone}>\n                        {TONE_META[entity.tone]?.symbol}\n                      </span>}\n                    <span className=\"bhm-entity-name\">{entity.entityName}</span>\n                    <span className=\"bhm-entity-kind\">\n                      {entity.entityKind}\n                      {entity.entitySubtype ? ` / ${entity.entitySubtype}` : \"\"}\n                    </span>\n                  </div>\n                  {!isReview && entity.tokenEstimate > 0 && <span className={`bhm-entity-tokens ${editionMaxTokens && entity.tokenEstimate > editionMaxTokens ? \"bhm-entity-tokens-over\" : \"\"}`} title={`~${entity.tokenEstimate} tokens estimated from word count`}>\n                      ~{entity.tokenEstimate.toLocaleString()}t\n                    </span>}\n                </div>)}\n            </div>\n          </div>\n\n          {/* Token estimate summary for edition mode */}\n          {!isReview && !isClear && (() => {\n        const estimates = progress.entities.map(e => e.tokenEstimate || 0).filter(t => t > 0);\n        if (estimates.length === 0) return null;\n        const maxEst = Math.max(...estimates);\n        const overCount = editionMaxTokens ? estimates.filter(t => t > editionMaxTokens).length : 0;\n        return <div className={`bhm-token-summary ${overCount > 0 ? \"bhm-token-summary-over\" : \"bhm-token-summary-ok\"}`}>\n                  <div>\n                    Largest description: <strong>~{maxEst.toLocaleString()} tokens</strong>\n                    {editionMaxTokens > 0 && <span className=\"bhm-token-limit-note\">\n                        (output limit: <strong>{editionMaxTokens.toLocaleString()}</strong>)\n                      </span>}\n                  </div>\n                  {overCount > 0 && <div className=\"bhm-token-over-warning\">\n                      {overCount} {overCount === 1 ? \"entity exceeds\" : \"entities exceed\"} the\n                      current output token limit \u2014 results may be truncated.\n                    </div>}\n                </div>;\n      })()}\n        </>}\n\n      {/* ---- Processing / Terminal screen ---- */}\n      {!isConfirming && progress?.status !== \"idle\" && <>\n          {/* Global progress */}\n          <BulkProgressBar processed={progress.processedEntities} total={progress.totalEntities} status={progress.status} />\n\n          <div className=\"bhm-progress-counts\">\n            {progress.processedEntities} / {progress.totalEntities} entities\n            {progress.failedEntities.length > 0 && <span className=\"bhm-progress-failed-count\">\n                {progress.failedEntities.length} failed\n              </span>}\n          </div>\n\n          {/* Current entity detail */}\n          {progress.currentEntityName && !isTerminal && <div className=\"bhm-current-entity\">\n              <div className=\"bhm-current-entity-name\">\n                {progress.currentEntityTone && TONE_META[progress.currentEntityTone] && <span className=\"bhm-current-entity-tone\">\n                    {TONE_META[progress.currentEntityTone].symbol}\n                  </span>}\n                {progress.currentEntityName}\n              </div>\n              <div className=\"bhm-current-entity-status\">\n                {(() => {\n            if (isClear) return \"Clearing annotations...\";\n            if (isReview) return \"Generating annotations...\";\n            return \"Generating copy edit...\";\n          })()}\n              </div>\n            </div>}\n\n          {/* Terminal state messages */}\n          {progress.status === \"complete\" && <BulkTerminalMessage status=\"complete\">\n              {(() => {\n          if (isClear) return `Cleared annotations from ${progress.processedEntities} entities.`;\n          if (isReview) return `Annotated ${progress.processedEntities} entities.`;\n          return `Copy-edited ${progress.processedEntities} entities.`;\n        })()}\n              {progress.failedEntities.length > 0 && <span className=\"bulk-failed-inline\">\n                  {\" \"}\n                  {progress.failedEntities.length} failed.\n                </span>}\n            </BulkTerminalMessage>}\n\n          {progress.status === \"cancelled\" && <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after processing {progress.processedEntities} of{\" \"}\n              {progress.totalEntities} entities.\n            </BulkTerminalMessage>}\n\n          {progress.status === \"failed\" && <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>}\n\n          {/* Failed entities list */}\n          {isTerminal && <BulkFailedList items={progress.failedEntities} labelKey=\"entityName\" errorKey=\"error\" />}\n\n          {/* Cost */}\n          <BulkCost cost={progress.totalCost} />\n        </>}\n    </BulkOperationShell>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  onChangeTone,\n  editionMaxTokens\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; onChangeTone: any; editionMaxTokens: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkOperationShell.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkOperationShell.jsx", "sourceCode": "export default function BulkOperationShell({\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(pillId));\n  const progressStatus = progress?.status;\n\n  // Update pill when minimized\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    useFloatingPillStore.getState().updatePill(pillId, {\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus)\n    });\n  }, [isMinimized, progress, progressStatus, pillId, pillStatusText]);\n\n  // Clean up pill when idle\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(pillId);\n    }\n  }, [progress, progressStatus, pillId]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const handleMinimize = () => {\n    useFloatingPillStore.getState().minimize({\n      id: pillId,\n      label: title,\n      statusText: pillStatusText || progressStatus,\n      statusColor: getStatusColor(progressStatus),\n      tabId\n    });\n  };\n  return <div className=\"bulk-overlay\">\n      <div className=\"bulk-dialog\" style={{\n      \"--bulk-dialog-width\": isConfirming ? confirmWidth : processWidth\n    }}>\n        {/* Header */}\n        <div className=\"bulk-header\">\n          <div className=\"bulk-header-row\">\n            <h2 className=\"bulk-title\">{title}</h2>\n            <div className=\"bulk-header-actions\">\n              {!isConfirming && <button onClick={handleMinimize} className=\"illuminator-button bulk-minimize-btn\" title=\"Minimize to pill\">\n                  \u2015\n                </button>}\n              <span className={`bulk-status bulk-status-${progress.status}`}>\n                {statusText}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`bulk-body ${isConfirming ? \"bulk-body-confirming\" : \"bulk-body-processing\"}`}>\n          {children}\n        </div>\n\n        {/* Footer */}\n        <div className=\"bulk-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary bulk-footer-btn\">\n                {confirmLabel}\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button bulk-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button bulk-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  pillId,\n  title,\n  tabId = \"chronicle\",\n  progress,\n  onConfirm,\n  onCancel,\n  onClose,\n  confirmLabel,\n  statusText,\n  pillStatusText,\n  confirmWidth = \"540px\",\n  processWidth = \"480px\",\n  children\n}", "type": "{ pillId: any; title: any; tabId?: string; progress: any; onConfirm: any; onCancel: any; onClose: any; confirmLabel: any; statusText: any; pillStatusText: any; confirmWidth?: string; processWidth?: string; children: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/BulkToneRankingModal.jsx", "sourceCode": "export default function BulkToneRankingModal({ progress, onConfirm, onCancel, onClose }) {\n  return (\n    <BulkOperationShell\n      pillId=\"bulk-tone-ranking\"\n      title=\"Tone Ranking\"\n      progress={progress}\n      onConfirm={onConfirm}\n      onCancel={onCancel}\n      onClose={onClose}\n      confirmLabel={`Rank (${progress?.totalChronicles || 0} chronicles)`}\n      statusText={progress ? getStatusText(progress) : \"\"}\n      pillStatusText={progress ? getPillText(progress) : \"\"}\n    >\n      {/* Confirmation screen */}\n      {progress?.status === \"confirming\" && (\n        <>\n          <div className=\"bulk-info-box\">\n            Chronicles are split into batches of ~35-45. Each batch gets its own LLM call so the\n            model maintains attention across all entries.\n          </div>\n\n          <div className=\"bulk-item-list-section\">\n            <div className=\"bulk-section-label\">\n              Chronicles ({progress.chronicles.length})\n            </div>\n            <div className=\"bulk-item-list\">\n              {progress.chronicles.map((chron) => (\n                <div key={chron.chronicleId} className=\"bulk-item-list-entry\">\n                  {chron.title}\n                </div>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n\n      {/* Processing / Terminal screen */}\n      {progress?.status !== \"confirming\" && progress?.status !== \"idle\" && (\n        <>\n          {progress.status === \"running\" && (\n            <BulkProgressBar\n              processed={progress.processedChronicles}\n              total={progress.totalChronicles}\n              status={progress.status}\n            />\n          )}\n\n          {progress.status === \"complete\" && (\n            <BulkTerminalMessage status=\"complete\">\n              Ranked {progress.processedChronicles} of {progress.totalChronicles} chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"cancelled\" && (\n            <BulkTerminalMessage status=\"cancelled\">\n              Cancelled after {progress.processedChronicles} of {progress.totalChronicles}{\" \"}\n              chronicles.\n            </BulkTerminalMessage>\n          )}\n\n          {progress.status === \"failed\" && (\n            <BulkTerminalMessage status=\"failed\">\n              {progress.error || \"An unexpected error occurred.\"}\n            </BulkTerminalMessage>\n          )}\n\n          <BulkCost cost={progress.totalCost} />\n        </>\n      )}\n    </BulkOperationShell>\n  );\n}", "parameters": [{"name": "{ progress, onConfirm, onCancel, onClose }", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePanel.tsx", "sourceCode": "export default function ChronicleImagePanel({\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}: Readonly<ChronicleImagePanelProps>) {\n  // Use external style selection directly (managed globally by ImageSettingsDrawer)\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Image modal state\n  const [imageModal, setImageModal] = useState<{ open: boolean; imageId: string; title: string }>({\n    open: false,\n    imageId: \"\",\n    title: \"\",\n  });\n  const handleImageClick = useCallback((imageId: string, title: string) => {\n    setImageModal({ open: true, imageId, title });\n  }, []);\n\n  // Image picker state\n  const [pickerRef, setPickerRef] = useState<PromptRequestRef | null>(null);\n  const handleOpenPicker = useCallback((ref: PromptRequestRef) => {\n    setPickerRef(ref);\n  }, []);\n  const handleClosePicker = useCallback(() => {\n    setPickerRef(null);\n  }, []);\n  const handleSelectImage = useCallback(\n    (imageId: string) => {\n      if (pickerRef && onSelectExistingImage) {\n        onSelectExistingImage(pickerRef, imageId);\n      }\n      setPickerRef(null);\n    },\n    [pickerRef, onSelectExistingImage]\n  );\n\n  // Culture selection from global settings\n  const selectedCultureId = imageGenSettings?.selectedCultureId || \"\";\n\n  // Derive primary culture from chronicle entities if not manually selected\n  const derivedCultureId = useMemo(() => {\n    if (selectedCultureId) return selectedCultureId;\n\n    // Try to find dominant culture from entities involved in the chronicle\n    const cultureCounts = new Map<string, number>();\n    for (const entity of entities.values()) {\n      if (entity.culture && entity.culture !== \"universal\") {\n        cultureCounts.set(entity.culture, (cultureCounts.get(entity.culture) || 0) + 1);\n      }\n    }\n\n    let maxCulture = \"\";\n    let maxCount = 0;\n    for (const [culture, count] of cultureCounts) {\n      if (count > maxCount) {\n        maxCulture = culture;\n        maxCount = count;\n      }\n    }\n\n    return maxCulture;\n  }, [selectedCultureId, entities]);\n\n  // Separate entity refs and prompt requests\n  const { entityRefs, promptRequests } = useMemo(() => {\n    if (!imageRefs?.refs) return { entityRefs: [], promptRequests: [] };\n\n    const entityRefs: EntityImageRef[] = [];\n    const promptRequests: PromptRequestRef[] = [];\n\n    for (const ref of imageRefs.refs) {\n      if (ref.type === \"entity_ref\") {\n        entityRefs.push(ref);\n      } else {\n        promptRequests.push(ref);\n      }\n    }\n\n    return { entityRefs, promptRequests };\n  }, [imageRefs]);\n\n  // Count by status\n  const stats = useMemo(() => {\n    const pending = promptRequests.filter((r) => r.status === \"pending\").length;\n    const generating = promptRequests.filter((r) => r.status === \"generating\").length;\n    const complete = promptRequests.filter((r) => r.status === \"complete\").length;\n    const failed = promptRequests.filter((r) => r.status === \"failed\").length;\n\n    return { pending, generating, complete, failed };\n  }, [promptRequests]);\n\n  // Build style info for image generation\n  const buildStyleInfo = useCallback((): StyleInfo => {\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityCultureId: derivedCultureId,\n      entityKind: DEFAULT_VISUAL_IDENTITY_KIND,\n      cultures: cultures || [],\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n\n    // Get visual identity for the selected culture\n    const cultureVisualIdentity = cultureIdentities?.visual?.[derivedCultureId] || {};\n    const allowedKeys =\n      cultureIdentities?.visualKeysByKind?.[DEFAULT_VISUAL_IDENTITY_KIND] ||\n      Object.keys(cultureVisualIdentity); // Use all keys if no kind-specific filtering\n\n    const filteredVisualIdentity: Record<string, string> = {};\n    for (const key of allowedKeys) {\n      if (cultureVisualIdentity[key]) {\n        filteredVisualIdentity[key] = cultureVisualIdentity[key];\n      }\n    }\n\n    return {\n      artisticPromptFragment: (resolved.artisticStyle as { promptFragment?: string } | null)?.promptFragment,\n      compositionPromptFragment: (resolved.compositionStyle as { promptFragment?: string } | null)?.promptFragment,\n      colorPalettePromptFragment: (resolved.colorPalette as { promptFragment?: string } | null)?.promptFragment,\n    };\n  }, [styleSelection, derivedCultureId, cultures, styleLibrary, cultureIdentities]);\n\n  // Handle generating a single image\n  const handleGenerateImage = useCallback(\n    (ref: PromptRequestRef) => {\n      if (!onGenerateImage) return;\n\n      const styleInfo = buildStyleInfo();\n\n      const prompt = buildChronicleScenePrompt(\n        {\n          sceneDescription: ref.sceneDescription,\n          size: ref.size,\n          chronicleTitle,\n          world: worldContext\n            ? {\n                name: worldContext.name || \"Unknown World\",\n                description: worldContext.description,\n                speciesConstraint: worldContext.speciesConstraint,\n              }\n            : undefined,\n        },\n        styleInfo\n      );\n\n      onGenerateImage(ref, prompt, styleInfo);\n    },\n    [onGenerateImage, buildStyleInfo, chronicleTitle, worldContext]\n  );\n\n  // No image refs yet\n  if (!imageRefs) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references generated yet. Use the &quot;Generate&quot; button above to create image\n        placement suggestions.\n      </div>\n    );\n  }\n\n  const totalRefs = entityRefs.length + promptRequests.length;\n\n  if (totalRefs === 0) {\n    return (\n      <div className=\"cip-empty-state\">\n        No image references in this chronicle.\n      </div>\n    );\n  }\n\n  const hasSceneImages = promptRequests.length > 0;\n\n  return (\n    <div>\n      {/* Header with stats */}\n      <div className=\"cip-header-row\">\n        <div className=\"cip-header-title\">Image References ({totalRefs})</div>\n        <div className=\"cip-header-stats\">\n          <span className=\"cip-stat-muted\">Entity refs: {entityRefs.length}</span>\n          <span className=\"cip-stat-muted\">Scenes: {promptRequests.length}</span>\n          {stats.pending > 0 && <span className=\"cip-stat-pending\">Pending: {stats.pending}</span>}\n          {stats.complete > 0 && (\n            <span className=\"cip-stat-complete\">Complete: {stats.complete}</span>\n          )}\n        </div>\n      </div>\n\n      {/* Image Settings Summary - show when there are scene images */}\n      {hasSceneImages && imageGenSettings && onOpenImageSettings && (\n        <ImageSettingsSummary\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary || null}\n          onOpenSettings={onOpenImageSettings}\n        />\n      )}\n\n      {/* Entity Refs Section */}\n      {entityRefs.length > 0 && (\n        <div className=\"cip-section\">\n          <div className=\"cip-section-title\">\n            Entity Images ({entityRefs.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {entityRefs.map((ref) => (\n              <EntityImageRefCard\n                key={ref.refId}\n                imageRef={ref}\n                entity={entities.get(ref.entityId)}\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Prompt Requests Section */}\n      {promptRequests.length > 0 && (\n        <div>\n          <div className=\"cip-section-title\">\n            Scene Images ({promptRequests.length})\n          </div>\n          <div className=\"cip-card-list\">\n            {promptRequests.map((ref) => (\n              <PromptRequestCard\n                key={ref.refId}\n                imageRef={ref}\n                onGenerate={() => handleGenerateImage(ref)}\n                onReset={onResetImage ? () => onResetImage(ref) : undefined}\n                onRegenerateDescription={\n                  onRegenerateDescription ? () => onRegenerateDescription(ref) : undefined\n                }\n                onSelectExisting={\n                  onSelectExistingImage && projectId ? () => handleOpenPicker(ref) : undefined\n                }\n                onImageClick={handleImageClick}\n                onUpdateAnchorText={\n                  onUpdateAnchorText ? (next) => onUpdateAnchorText(ref, next) : undefined\n                }\n                onUpdateSize={onUpdateSize ? (size) => onUpdateSize(ref, size) : undefined}\n                onUpdateJustification={\n                  onUpdateJustification\n                    ? (justification) => onUpdateJustification(ref, justification)\n                    : undefined\n                }\n                chronicleText={chronicleText}\n                isGenerating={isGenerating}\n                entities={entities}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Metadata footer */}\n      <div className=\"cip-metadata-footer\">\n        Generated: {new Date(imageRefs.generatedAt).toLocaleString()} \u2022 Model: {imageRefs.model}\n      </div>\n\n      <ImageModal\n        isOpen={imageModal.open}\n        imageId={imageModal.imageId}\n// ... (truncated)", "parameters": [{"name": "{\n  imageRefs,\n  entities,\n  onGenerateImage,\n  onResetImage,\n  onRegenerateDescription,\n  onUpdateAnchorText,\n  onUpdateSize,\n  onUpdateJustification,\n  onSelectExistingImage,\n  projectId,\n  chronicleId,\n  chronicleText,\n  isGenerating = false,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  chronicleTitle,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n}", "type": "Readonly<ChronicleImagePanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleImagePicker.jsx", "sourceCode": "export default function ChronicleImagePicker({\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n\n  // Filter state - both default ON\n  const [filterByRef, setFilterByRef] = useState(true);\n  const [filterByChronicle, setFilterByChronicle] = useState(true);\n\n  const mouseDownOnOverlay = useRef(false);\n\n  // Reset state when opening\n  useEffect(() => {\n    if (isOpen) {\n      setImages([]);\n      setSelectedImageId(null);\n      setFilterByRef(true);\n      setFilterByChronicle(true);\n      setHasMore(false);\n      setTotal(0);\n    }\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen || !projectId) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {\n          projectId,\n          limit: PAGE_SIZE,\n          offset: 0,\n        };\n\n        // Apply filters based on checkbox state\n        // If filterByRef is ON, filter by imageRefId (most specific)\n        // If filterByRef is OFF but filterByChronicle is ON, filter by chronicleId\n        // If both OFF, show all chronicle images for project\n        if (filterByRef && imageRefId) {\n          filters.imageRefId = imageRefId;\n          // When filtering by ref, also filter by chronicle for efficiency\n          if (chronicleId) filters.chronicleId = chronicleId;\n        } else if (filterByChronicle && chronicleId) {\n          filters.chronicleId = chronicleId;\n        }\n\n        const result = await searchChronicleImages(filters);\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n      } catch (err) {\n        console.error(\"Failed to load chronicle images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, projectId, chronicleId, imageRefId, filterByRef, filterByChronicle]);\n\n  // Load more handler\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const filters = {\n        projectId,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      };\n\n      if (filterByRef && imageRefId) {\n        filters.imageRefId = imageRefId;\n        if (chronicleId) filters.chronicleId = chronicleId;\n      } else if (filterByChronicle && chronicleId) {\n        filters.chronicleId = chronicleId;\n      }\n\n      const result = await searchChronicleImages(filters);\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [\n    loading,\n    hasMore,\n    projectId,\n    chronicleId,\n    imageRefId,\n    filterByRef,\n    filterByChronicle,\n    images.length,\n  ]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    onClose();\n  }, [onClose]);\n\n  // Overlay click handling\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n\n  // Close on escape\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") handleClose();\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal cip-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Existing Image</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body cip-body\">\n          {/* Filters */}\n          <div className=\"cip-filters\">\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByRef}\n                onChange={(e) => setFilterByRef(e.target.checked)}\n              />\n              This ref only\n            </label>\n\n            <label className=\"cip-filter-label\">\n              <input\n                type=\"checkbox\"\n                checked={filterByChronicle}\n                onChange={(e) => setFilterByChronicle(e.target.checked)}\n              />\n              This chronicle only\n            </label>\n\n            <span className=\"cip-filter-count\">\n              {total} image{total !== 1 ? \"s\" : \"\"}\n            </span>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"cip-grid-area\">\n            {loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"cip-empty-state\">\n                No images found. Try unchecking filters to see more.\n              </div>\n            )}\n            {images.length > 0 && (\n              <>\n                <div className=\"cip-grid\">\n                  {images.map((img) => {\n                    const isSelected = selectedImageId === img.imageId;\n                    const isCurrent = currentImageId === img.imageId;\n\n                    return (\n                      <div\n                        key={img.imageId}\n                        onClick={() => setSelectedImageId(img.imageId)}\n                        className={(() => {\n                          if (isSelected) return \"cip-image-card cip-image-card-selected\";\n                          if (isCurrent) return \"cip-image-card cip-image-card-current\";\n                          return \"cip-image-card\";\n                        })()}\n                        role=\"button\"\n                        tabIndex={0}\n                        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                      >\n                        <LazyThumbnail\n                          imageId={img.imageId}\n                          alt={img.sceneDescription || \"Chronicle image\"}\n                          className=\"cip-thumb-container\"\n                        />\n\n                        {/* Current indicator */}\n                        {isCurrent && <div className=\"cip-current-badge\">Current</div>}\n\n                        {/* Date overlay */}\n                        <div className=\"cip-date-overlay\">{formatDate(img.generatedAt)}</div>\n                      </div>\n                    );\n                  })}\n                </div>\n\n                {/* Load more button */}\n                {hasMore && (\n                  <div className=\"cip-load-more-wrapper\">\n                    <button\n                      onClick={() => void handleLoadMore()}\n                      disabled={loading}\n                      className=\"cip-load-more-btn\"\n                    >\n                      {loading ? \"Loading...\" : `Load More (${total - images.length} remaining)`}\n                    </button>\n                  </div>\n                )}\n              </>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer cip-footer\">\n          <button onClick={handleClose} className=\"cip-cancel-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId}\n            className={`cip-select-btn ${selectedImageId ? \"cip-select-btn-active\" : \"cip-select-btn-disabled\"}`}\n          >\n            Select Image\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  projectId,\n  chronicleId,\n  imageRefId,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; projectId: any; chronicleId: any; imageRefId: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChroniclePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePanel.jsx", "sourceCode": "export default function ChroniclePanel({\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}) {\n  const navEntities = useEntityNavList();\n  const entityNavMap = useEntityNavItems();\n  // Full entities from Dexie for generation context (tags, description, coordinates, etc.)\n  const [fullEntities, setFullEntities] = useState([]);\n  const fullEntityMapRef = useRef(new Map());\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const [selectedItemId, setSelectedItemId] = useState(() => {\n    const saved = localStorage.getItem(\"illuminator:chronicle:selectedItemId\");\n    return saved || null;\n  });\n  const [groupByType, setGroupByType] = useState(false);\n  const [sortMode, setSortMode] = useState(\"era_asc\");\n  const [statusFilter, setStatusFilter] = useState(\"all\");\n  const [focusFilter, setFocusFilter] = useState(\"all\");\n  const [entitySearchQuery, setEntitySearchQuery] = useState(\"\");\n  const [entitySearchSelectedId, setEntitySearchSelectedId] = useState(null);\n  const [showEntitySuggestions, setShowEntitySuggestions] = useState(false);\n  const [navVisibleCount, setNavVisibleCount] = useState(NAV_PAGE_SIZE);\n  const navListRef = useRef(null);\n  const navLoadMoreRef = useRef(null);\n  // Load full entities from Dexie for generation operations (tags, description, coordinates, etc.)\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    getEntitiesForRun(simulationRunId).then(ents => {\n      if (cancelled) return;\n      setFullEntities(ents);\n      fullEntityMapRef.current = new Map(ents.map(e => [e.id, e]));\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const chronicleWorldData = useMemo(() => ({\n    entities: fullEntities,\n    relationships: relationships || [],\n    narrativeHistory: narrativeEvents || []\n  }), [fullEntities, relationships, narrativeEvents]);\n  useEffect(() => {\n    if (selectedItemId) {\n      localStorage.setItem(\"illuminator:chronicle:selectedItemId\", selectedItemId);\n    } else {\n      localStorage.removeItem(\"illuminator:chronicle:selectedItemId\");\n    }\n  }, [selectedItemId]);\n\n  // State for restart confirmation modal\n  const [showRestartModal, setShowRestartModal] = useState(false);\n  const [pendingRestartChronicleId, setPendingRestartChronicleId] = useState(null);\n\n  // State for reset backport flags modal\n  const [showResetBackportModal, setShowResetBackportModal] = useState(false);\n  const [resetBackportResult, setResetBackportResult] = useState(null);\n\n  // State for reconcile backport status\n  const [reconcileBackportResult, setReconcileBackportResult] = useState(null);\n\n  // State for era summary refresh\n  const [eraSummaryRefreshResult, setEraSummaryRefreshResult] = useState(null);\n\n  // State for bulk temporal check\n  const [temporalCheckResult, setTemporalCheckResult] = useState(null);\n\n  // State for bulk tertiary re-detect\n  const [tertiaryDetectResult, setTertiaryDetectResult] = useState(null);\n\n  // State for bulk summary generation\n  const [bulkSummaryResult, setBulkSummaryResult] = useState(null);\n\n  // Collapsible bulk actions panel\n  const [showBulkActions, setShowBulkActions] = useState(false);\n\n  // State for chronology modal\n  const [showChronologyModal, setShowChronologyModal] = useState(false);\n\n  // Era narrative modal \u2014 state lives in Zustand store to survive tab switches\n  const eraNarrativeModal = useIlluminatorModals(s => s.eraNarrativeModal);\n\n  // Bulk historian prep: skip chronicles that already have prep\n  const [skipCompletedPrep, setSkipCompletedPrep] = useState(true);\n\n  // Bulk era narrative modal\n  const [showBulkEraNarrative, setShowBulkEraNarrative] = useState(false);\n  const bulkEraNarrativeProgress = useBulkEraNarrativeStore(s => s.progress);\n\n  // Era narrative nav items (loaded from IndexedDB, merged into chronicle list)\n  const [eraNarrativeNavItems, setEraNarrativeNavItems] = useState([]);\n\n  // Fact coverage bulk analysis\n  const {\n    progress: factCoverageProgress,\n    isActive: isFactCoverageActive,\n    prepareFactCoverage,\n    confirmFactCoverage,\n    cancelFactCoverage,\n    closeFactCoverage\n  } = useFactCoverage();\n\n  // Tone ranking & assignment\n  const {\n    progress: toneRankingProgress,\n    isActive: isToneRankingActive,\n    prepareToneRanking,\n    prepareAssignment\n  } = useToneRanking();\n\n  // Bulk chronicle annotations (clear / run)\n  const bulkAnnotationProgress = useBulkChronicleAnnotationStore(s => s.progress);\n  const prepareBulkAnnotation = useBulkChronicleAnnotationStore(s => s.prepareAnnotation);\n  const isBulkAnnotationActive = bulkAnnotationProgress.status === \"running\" || bulkAnnotationProgress.status === \"confirming\";\n\n  // Interleaved annotation (chronicle + entity)\n  const prepareInterleaved = useInterleavedAnnotationStore(s => s.prepareInterleaved);\n  const interleavedProgress = useInterleavedAnnotationStore(s => s.progress);\n  const isInterleavedActive = interleavedProgress.status === \"running\" || interleavedProgress.status === \"confirming\";\n  const entityNavItems = useEntityStore(s => s.navItems);\n\n  // State for wizard modal\n  const [showWizard, setShowWizard] = useState(false);\n  // Seed for restarting with previous settings\n  const [wizardSeed, setWizardSeed] = useState(null);\n\n  // Derive style/size/quality from global imageGenSettings\n  const chronicleImageSize = imageGenSettings.imageSize;\n  const chronicleImageQuality = imageGenSettings.imageQuality;\n  const chronicleStyleSelection = useMemo(() => ({\n    artisticStyleId: imageGenSettings.artisticStyleId,\n    compositionStyleId: imageGenSettings.compositionStyleId,\n    colorPaletteId: imageGenSettings.colorPaletteId\n  }), [imageGenSettings.artisticStyleId, imageGenSettings.compositionStyleId, imageGenSettings.colorPaletteId]);\n\n  // Name bank for invented characters (culture ID -> array of names)\n  const [nameBank, setNameBank] = useState({});\n\n  // Style library loading state (derived from prop)\n  const stylesLoading = !styleLibrary;\n\n  // Initialize chronicle store when simulation changes\n  useEffect(() => {\n    if (simulationRunId) {\n      useChronicleStore.getState().initialize(simulationRunId);\n    }\n  }, [simulationRunId]);\n\n  // Enqueue-dependent actions (generate, compare, combine)\n  const {\n    generateV2,\n    generateSummary,\n    generateTitle,\n    regenerateWithSampling,\n    regenerateFull,\n    regenerateCreative,\n    compareVersions,\n    combineVersions,\n    copyEdit,\n    temporalCheck,\n    quickCheck\n  } = useChronicleActions();\n\n  // Lifecycle actions from store (no queue dependency)\n  const acceptChronicle = useChronicleStore(s => s.acceptChronicle);\n  const cancelChronicle = useChronicleStore(s => s.cancelChronicle);\n  const restartChronicle = useChronicleStore(s => s.restartChronicle);\n\n  // Scope the \"generating\" lock to the selected chronicle so other chronicles remain interactive.\n  const isGenerating = Boolean(selectedItemId) && queue.some(item => item.type === \"entityChronicle\" && item.chronicleId === selectedItemId && (item.status === \"queued\" || item.status === \"running\"));\n\n  // Refresh helpers\n  const refresh = useCallback(() => useChronicleStore.getState().refreshAll(), []);\n  const refreshChronicle = useCallback(id => useChronicleStore.getState().refreshChronicle(id), []);\n\n  // Assign tone to a chronicle without triggering annotation\n  const handleSetAssignedTone = useCallback(async (chronicleId, tone) => {\n    await updateChronicleAssignedTone(chronicleId, tone);\n    refreshChronicle(chronicleId);\n  }, [refreshChronicle]);\n\n  // Detect tone for a single chronicle via LLM\n  const handleDetectTone = useCallback(async (chronicleId, title) => {\n    const record = await getChronicle(chronicleId);\n    if (!record?.summary) return;\n    const payload = {\n      chronicleId,\n      summary: record.summary,\n      format: record.format || \"story\",\n      narrativeStyleName: record.narrativeStyle?.name,\n      brief: record.perspectiveSynthesis?.brief\n    };\n    const entity = {\n      id: chronicleId,\n      name: title || \"Chronicle\",\n      kind: \"chronicle\",\n      subtype: \"\",\n      prominence: \"recognized\",\n      culture: \"\",\n      status: \"active\",\n      description: \"\",\n      tags: {}\n    };\n    onEnqueue([{\n      entity,\n      type: \"toneRanking\",\n      prompt: JSON.stringify(payload),\n      chronicleId\n    }]);\n  }, [onEnqueue]);\n\n  // External refresh trigger (e.g. after lore backport)\n  useEffect(() => {\n    if (refreshTrigger > 0) refresh();\n  }, [refreshTrigger, refresh]);\n  const entitySuggestions = useMemo(() => {\n    const query = entitySearchQuery.trim().toLowerCase();\n    if (!query || !navEntities?.length) return [];\n    return navEntities.filter(entity => entity.name?.toLowerCase().includes(query)).slice(0, 8);\n  }, [navEntities, entitySearchQuery]);\n  const narrativeStyleNameMap = useMemo(() => {\n    const map = new Map();\n    const styles = styleLibrary?.narrativeStyles || [];\n    for (const style of styles) {\n      if (style?.id) {\n        map.set(style.id, style.name || style.id);\n      }\n    }\n    return map;\n  }, [styleLibrary?.narrativeStyles]);\n\n  // Helper to get status considering both IndexedDB and queue state\n  const getEffectiveStatus = useCallback((chronicleId, baseStatus) => {\n    // First check queue for running/queued tasks for this chronicle\n    const queueTask = queue.find(item => item.type === \"entityChronicle\" && item.chronicleId === chronicleId && !REFINEMENT_STEPS.has(item.chronicleStep || \"\"));\n    if (queueTask) {\n      if (queueTask.status === \"running\") {\n        // Map chronicleStep to status\n        switch (queueTask.chronicleStep) {\n          case \"validate\":\n            return \"validating\";\n          case \"edit\":\n            return \"editing\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n      if (queueTask.status === \"queued\") {\n        switch (queueTask.chronicleStep) {\n          case \"edit\":\n            return \"editing\";\n          case \"validate\":\n            return \"validating\";\n          case \"generate_v2\":\n            return \"generating\";\n          case \"regenerate_temperature\":\n            return \"generating\";\n          default:\n            return baseStatus;\n        }\n      }\n    }\n\n    // Fall back to IndexedDB-derived status\n    return baseStatus;\n  }, [queue]);\n\n  // Lightweight nav items from Zustand store (shallow-compared, only re-renders on nav-relevant changes)\n  const chronicleItems = useChronicleNavItems(getEffectiveStatus);\n  const getChronicleTypeLabel = useCallback(item => {\n    if (item?.itemType === \"era_narrative\") return \"Era Narrative\";\n    if (item?.narrativeStyleName) return item.narrativeStyleName;\n// ... (truncated)", "parameters": [{"name": "{\n  worldData,\n  queue,\n  onEnqueue,\n  onCancel: _onCancel,\n  worldContext,\n  projectId,\n  simulationRunId,\n  buildPrompt: _buildPrompt,\n  styleLibrary,\n  imageGenSettings,\n  entityGuidance,\n  cultureIdentities,\n  onBackportLore,\n  onStartBulkBackport,\n  isBulkBackportActive,\n  refreshTrigger,\n  imageModel,\n  onOpenImageSettings,\n  onHistorianReview,\n  isHistorianActive,\n  historianConfigured,\n  historianConfig,\n  onUpdateHistorianNote,\n  onRefreshEraSummaries,\n  onNavigateToTab\n}", "type": "{ worldData: any; queue: any; onEnqueue: any; onCancel: any; worldContext: any; projectId: any; simulationRunId: any; buildPrompt: any; styleLibrary: any; imageGenSettings: any; entityGuidance: any; cultureIdentities: any; onBackportLore: any; onStartBulkBackport: any; isBulkBackportActive: any; refreshTrigger: any; imageModel: any; onOpenImageSettings: any; onHistorianReview: any; isHistorianActive: any; historianConfigured: any; historianConfig: any; onUpdateHistorianNote: any; onRefreshEra...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChroniclePlanEditor.jsx", "sourceCode": "export default function ChroniclePlanEditor({\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}) {\n  const sectionCount = plan.sections?.length || 0;\n\n  const eventStats = useMemo(() => {\n    const eventIds = new Set();\n    plan.sections?.forEach((section) => {\n      section.eventIds?.forEach((id) => eventIds.add(id));\n    });\n    return eventIds.size;\n  }, [plan.sections]);\n\n  return (\n    <div className=\"cpe-root\">\n      <PlanHeader plan={plan} />\n      <OutlineSummary plan={plan} />\n      <FocusSummary plan={plan} entityMap={entityMap} />\n      <PlotSummary plan={plan} />\n      <EntityRoleList plan={plan} entityMap={entityMap} />\n\n      <div className=\"cpe-stats-row\">\n        <div className=\"cpe-stat-box\">\n          <strong>Sections:</strong> {sectionCount}\n        </div>\n        <div className=\"cpe-stat-box\">\n          <strong>Referenced Events:</strong> {eventStats}\n        </div>\n      </div>\n\n      <SectionsList plan={plan} entityMap={entityMap} eventMap={eventMap} />\n\n      <div className=\"cpe-action-bar\">\n        <button\n          onClick={onRegenerate}\n          disabled={isGenerating}\n          className={`illuminator-button cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Regenerate Plan\n        </button>\n        <button\n          onClick={onApprove}\n          disabled={isGenerating}\n          className={`illuminator-button illuminator-button-primary cpe-btn ${isGenerating ? \"cpe-btn-disabled\" : \"\"}`}\n        >\n          Approve Plan\n        </button>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  plan,\n  entityMap,\n  eventMap,\n  onRegenerate,\n  onApprove,\n  isGenerating = false,\n}", "type": "{ plan: any; entityMap: any; eventMap: any; onRegenerate: any; onApprove: any; isGenerating?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleReviewPanel.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function ChronicleReviewPanel({\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  if (!item) return null;\n\n  // ---------------------------------------------------------------------------\n  // Assembly Ready & Complete \u2192 Tabbed Workspace\n  // ---------------------------------------------------------------------------\n  if (\n    (item.status === \"assembly_ready\" && item.assembledContent) ||\n    (item.status === \"complete\" && item.finalContent)\n  ) {\n    return (\n      <ChronicleWorkspace\n        item={item}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onRegenerateFull={onRegenerateFull}\n        onRegenerateCreative={onRegenerateCreative}\n        onCompareVersions={onCompareVersions}\n        onCombineVersions={onCombineVersions}\n        onCopyEdit={onCopyEdit}\n        onTemporalCheck={onTemporalCheck}\n        onQuickCheck={onQuickCheck}\n        onValidate={onValidate}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateTitle={onGenerateTitle}\n        onAcceptPendingTitle={onAcceptPendingTitle}\n        onRejectPendingTitle={onRejectPendingTitle}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onRegenerateDescription={onRegenerateDescription}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleTemporalContext={onUpdateChronicleTemporalContext}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        onUpdateCombineInstructions={onUpdateCombineInstructions}\n        onUnpublish={onUnpublish}\n        onGenerateCoverImageScene={onGenerateCoverImageScene}\n        onGenerateCoverImage={onGenerateCoverImage}\n        styleSelection={styleSelection}\n        imageSize={imageSize}\n        imageQuality={imageQuality}\n        imageModel={imageModel}\n        imageGenSettings={imageGenSettings}\n        onOpenImageSettings={onOpenImageSettings}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onApplyImageRefSelections={onApplyImageRefSelections}\n        onSelectExistingImage={onSelectExistingImage}\n        onSelectExistingCoverImage={onSelectExistingCoverImage}\n        onExport={onExport}\n        onBackportLore={onBackportLore}\n        onHistorianReview={onHistorianReview}\n        onSetAssignedTone={onSetAssignedTone}\n        onDetectTone={onDetectTone}\n        isHistorianActive={isHistorianActive}\n        onUpdateHistorianNote={onUpdateHistorianNote}\n        onGeneratePrep={onGeneratePrep}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        simulationRunId={simulationRunId}\n        worldSchema={worldSchema}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n        eras={eras}\n        events={events}\n        onNavigateToTab={onNavigateToTab}\n      />\n    );\n  }\n\n  // ---------------------------------------------------------------------------\n  // Validation Ready \u2192 Inline layout (not tabbed)\n  // ---------------------------------------------------------------------------\n  if (item.status === \"validation_ready\") {\n    return (\n      <ValidationReadyView\n        item={item}\n        onExport={onExport}\n        onRegenerateWithSampling={onRegenerateWithSampling}\n        onAccept={onAccept}\n        onRegenerate={onRegenerate}\n        onCorrectSuggestions={onCorrectSuggestions}\n        onGenerateSummary={onGenerateSummary}\n        onGenerateImageRefs={onGenerateImageRefs}\n        onRevalidate={onRevalidate}\n        onGenerateChronicleImage={onGenerateChronicleImage}\n        onResetChronicleImage={onResetChronicleImage}\n        onUpdateChronicleAnchorText={onUpdateChronicleAnchorText}\n        onUpdateChronicleImageSize={onUpdateChronicleImageSize}\n        onUpdateChronicleImageJustification={onUpdateChronicleImageJustification}\n        onUpdateChronicleActiveVersion={onUpdateChronicleActiveVersion}\n        onDeleteVersion={onDeleteVersion}\n        isGenerating={isGenerating}\n        refinements={refinements}\n        entities={entities}\n        styleLibrary={styleLibrary}\n        cultures={cultures}\n        cultureIdentities={cultureIdentities}\n        worldContext={worldContext}\n      />\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onContinueToValidation,\n  onValidate,\n  onAddImages,\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onRevalidate,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data for refinements\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  entityGuidance,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onContinueToValidation: any; onValidate: any; onAddImages: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onRevalidate: any; onGenerateChronicleImage: a...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronologyModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronologyModal.jsx", "sourceCode": "export default function ChronologyModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [expandedReasoning, setExpandedReasoning] = useState({});\n\n  const { run, isActive, startChronology, adjustYear, applyChronology, cancelChronology } =\n    useHistorianChronology(onEnqueue);\n\n  // Build era options from wizardEras\n  const eraOptions = useMemo(() => {\n    return wizardEras.map((era) => {\n      const eraChronicles = chronicleItems.filter((c) => c.focalEraName === era.name);\n      return {\n        id: era.id,\n        name: era.name,\n        startTick: era.startTick,\n        endTick: era.endTick,\n        count: eraChronicles.length,\n        preppedCount: eraChronicles.filter((c) => c.hasHistorianPrep).length,\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n\n  // Get chronicles for the selected era\n  const selectedEra = eraOptions.find((e) => e.id === selectedEraId);\n\n  // Chronicles in the selected era for the list display\n  const selectedEraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems\n      .filter((c) => c.focalEraName === era.name)\n      .sort((a, b) => (a.eraYear || 0) - (b.eraYear || 0) || a.name.localeCompare(b.name));\n  }, [selectedEra, selectedEraId, wizardEras, chronicleItems]);\n\n  // Build context and start\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n\n    const era = wizardEras.find((e) => e.id === selectedEraId);\n    if (!era) return;\n\n    // Get chronicles in this era\n    const eraChronicles = chronicleItems.filter((item) => item.focalEraName === era.name);\n\n    // Load full records for summaries\n    const store = useChronicleStore.getState();\n    const chronicleEntries = [];\n\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record) continue;\n\n      // Resolve event headlines for this chronicle\n      const chronicleEventIds = new Set(record.selectedEventIds || []);\n      const events = (wizardEvents || [])\n        .filter((e) => chronicleEventIds.has(e.id))\n        .map((e) => ({ tick: e.tick, headline: e.headline }));\n\n      // Cast from role assignments\n      const cast = (record.roleAssignments || []).map((r) => ({\n        entityName: r.entityName,\n        role: r.roleName || (r.isPrimary ? \"primary\" : \"supporting\"),\n        kind: r.entityKind || \"\",\n      }));\n\n      // Prefer historian prep, then summary, then opening text\n      const content = record.finalContent || record.assembledContent || \"\";\n      const openingText = content.slice(0, 300).split(/\\n\\n/).slice(0, 2).join(\"\\n\\n\");\n\n      chronicleEntries.push({\n        chronicleId: record.chronicleId,\n        title: record.title || item.name,\n        tickRange: record.temporalContext?.chronicleTickRange || [0, 0],\n        temporalScope: record.temporalContext?.temporalScope || \"unknown\",\n        isMultiEra: record.temporalContext?.isMultiEra || false,\n        cast,\n        events,\n        prep: record.historianPrep || undefined,\n        summary: record.historianPrep ? undefined : record.summary,\n        openingText: record.historianPrep || record.summary ? undefined : openingText,\n      });\n    }\n\n    // Previous eras for context\n    const previousEras = wizardEras\n      .filter((e) => e.order < era.order)\n      .sort((a, b) => a.order - b.order)\n      .map((e) => ({\n        name: e.name,\n        startTick: e.startTick,\n        endTick: e.endTick,\n        summary: e.summary,\n      }));\n\n    const contextJson = JSON.stringify({\n      era: {\n        eraId: era.id,\n        eraName: era.name,\n        eraSummary: era.summary,\n        startTick: era.startTick,\n        endTick: era.endTick,\n      },\n      previousEras,\n      chronicles: chronicleEntries,\n    });\n\n    startChronology({\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      contextJson,\n      historianConfig,\n      tone: \"scholarly\",\n    });\n  }, [\n    selectedEra,\n    selectedEraId,\n    wizardEras,\n    chronicleItems,\n    wizardEvents,\n    projectId,\n    simulationRunId,\n    historianConfig,\n    startChronology,\n  ]);\n\n  // Apply assignments to chronicle records\n  const handleApply = useCallback(async () => {\n    const assignments = applyChronology();\n    if (assignments.length === 0) return;\n\n    await batchUpdateChronicleEraYears(\n      assignments.map((a) => ({\n        chronicleId: a.chronicleId,\n        eraYear: a.year,\n        eraYearReasoning: a.reasoning,\n      }))\n    );\n\n    onApplied();\n  }, [applyChronology, onApplied]);\n\n  // Cancel\n  const handleCancel = useCallback(() => {\n    cancelChronology();\n  }, [cancelChronology]);\n\n  // Close modal (cancel if active)\n  const handleClose = useCallback(() => {\n    if (isActive) cancelChronology();\n    onClose();\n  }, [isActive, cancelChronology, onClose]);\n\n  if (!isOpen) return null;\n\n  const isGenerating = run?.status === \"pending\" || run?.status === \"generating\";\n  const isReviewing = run?.status === \"reviewing\";\n  const isFailed = run?.status === \"failed\";\n  const assignments = run?.chronologyAssignments || [];\n  const sortedAssignments = [...assignments].sort((a, b) => a.year - b.year);\n\n  // Find chronicle title by ID\n  const titleMap = {};\n  for (const item of chronicleItems) {\n    titleMap[item.chronicleId] = item.name;\n  }\n\n  const canStart = selectedEraId && selectedEra?.count > 0;\n\n  return (\n    <div\n      className=\"chm-overlay\"\n      onClick={(e) => {\n        if (e.target === e.currentTarget) handleClose();\n      }}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      <div className=\"chm-dialog\">\n        {/* Header */}\n        <div className=\"chm-header\">\n          <span className=\"chm-header-title\">\n            {isReviewing ? `Chronology: ${run?.targetName}` : \"Historian Chronology\"}\n          </span>\n          <button onClick={handleClose} className=\"chm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Body */}\n        <div className=\"chm-body\">\n          {/* Setup state */}\n          {!isActive && !isReviewing && !isFailed && (\n            <>\n              <div className=\"chm-field\">\n                <label htmlFor=\"era\" className=\"chm-field-label\">Era</label>\n                <select id=\"era\"\n                  className=\"illuminator-select chm-era-select\"\n                  value={selectedEraId}\n                  onChange={(e) => setSelectedEraId(e.target.value)}\n                >\n                  <option value=\"\">Select an era...</option>\n                  {eraOptions.map((era) => (\n                    <option key={era.id} value={era.id}>\n                      {era.name} ({era.count} chronicles, Y{era.startTick}\n                      {\"\\u2013\"}Y{era.endTick})\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Chronicle list for selected era */}\n              {selectedEra && selectedEraChronicles.length > 0 && (\n                <div className=\"chm-field\">\n                  <div className=\"chm-list-header\">\n                    <span>Chronicles ({selectedEraChronicles.length})</span>\n                    <span className=\"chm-list-header-right\">\n                      {selectedEra.preppedCount}/{selectedEraChronicles.length} prepped\n                    </span>\n                  </div>\n                  <div className=\"chm-chronicle-list\">\n                    {selectedEraChronicles.map((c, i) => (\n                      <div\n                        key={c.chronicleId}\n                        className={`chm-chronicle-row ${i < selectedEraChronicles.length - 1 ? \"chm-chronicle-row-bordered\" : \"\"}`}\n                      >\n                        <span\n                          className={`chm-prep-icon ${c.hasHistorianPrep ? \"chm-prep-icon-ready\" : \"chm-prep-icon-none\"}`}\n                          title={\n                            c.hasHistorianPrep ? \"Historian prep available\" : \"No historian prep\"\n                          }\n                        >\n                          {c.hasHistorianPrep ? \"\\u25C6\" : \"\\u25C7\"}\n                        </span>\n                        <span className=\"chm-chronicle-name\">{c.name}</span>\n                        {c.eraYear != null && <span className=\"chm-era-year\">Y{c.eraYear}</span>}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n\n              <button\n                onClick={() => void handleStart()}\n                disabled={!canStart}\n                className={`illuminator-button chm-start-btn ${canStart ? \"chm-start-btn-active\" : \"chm-start-btn-disabled\"}`}\n              >\n                Assign Years\n              </button>\n            </>\n          )}\n\n          {/* Generating state */}\n          {isGenerating && (\n            <div className=\"chm-generating\">\n              <div className=\"chm-generating-msg\">The historian is ordering chronicles...</div>\n              <div className=\"chm-generating-target\">{run?.targetName}</div>\n            </div>\n          )}\n\n          {/* Failed state */}\n          {isFailed && (\n            <div className=\"chm-failed\">\n              <div className=\"chm-failed-msg\">Chronology failed</div>\n              <div className=\"chm-failed-error\">{run?.error}</div>\n              <button onClick={handleCancel} className=\"illuminator-button\">\n                Dismiss\n              </button>\n            </div>\n          )}\n\n          {/* Review state */}\n          {isReviewing && sortedAssignments.length > 0 && (\n            <>\n              <div className=\"chm-review-hint\">\n                {sortedAssignments.length} chronicles ordered. Adjust years if needed, then apply.\n              </div>\n\n              <div className=\"chm-assignments\">\n                {sortedAssignments.map((a) => (\n                  <div key={a.chronicleId} className=\"chm-assignment-card\">\n                    <div className=\"chm-assignment-row\">\n                      <input\n                        type=\"number\"\n                        value={a.year}\n                        min={selectedEra?.startTick}\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  wizardEvents,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  onApplied,\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; wizardEvents: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; onApplied: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CohesionReportViewer.jsx", "sourceCode": "export default function CohesionReportViewer({\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}) {\n  const [activeTab, setActiveTab] = useState(\"summary\");\n\n  // Calculate assessment\n  const assessment = useMemo(() => {\n    if (!report) return null;\n    const criticalIssues = report.issues.filter(i => i.severity === \"critical\");\n    const minorIssues = report.issues.filter(i => i.severity === \"minor\");\n    const failedChecks = [];\n    if (!report.checks.plotStructure.pass) failedChecks.push(\"Structure\");\n    if (!report.checks.entityConsistency.pass) failedChecks.push(\"Entity Consistency\");\n    if (!report.checks.resolution.pass) failedChecks.push(\"Resolution\");\n    if (!report.checks.factualAccuracy.pass) failedChecks.push(\"Factual Accuracy\");\n    if (!report.checks.themeExpression.pass) failedChecks.push(\"Theme Expression\");\n    const failedSectionGoals = report.checks.sectionGoals.filter(sg => !sg.pass);\n    let status;\n    if (report.overallScore >= 90) status = \"excellent\";else if (report.overallScore >= 75) status = \"good\";else if (report.overallScore >= 60) status = \"acceptable\";else status = \"needs_revision\";\n    return {\n      status,\n      criticalIssueCount: criticalIssues.length,\n      minorIssueCount: minorIssues.length,\n      failedChecks,\n      failedSectionGoals\n    };\n  }, [report]);\n  if (!report) {\n    return <div className=\"crv-empty\">No validation report available.</div>;\n  }\n  const statusStyle = STATUS_STYLES[assessment?.status || \"needs_revision\"];\n  const resolveSectionLabel = sectionId => sectionId;\n  const hasIssues = report.issues.length > 0;\n  const formatTimestamp = timestamp => new Date(timestamp).toLocaleString();\n  const summaryState = refinements?.summary || {};\n  const imageRefsState = refinements?.imageRefs || {};\n  const disabledClass = condition => condition ? \"crv-btn-disabled\" : \"\";\n  return <div className=\"crv\">\n      {/* Header with score and actions */}\n      <div className=\"crv-header\">\n        <div className=\"crv-header-left\">\n          <ScoreGauge score={report.overallScore} />\n          <div>\n            {}\n            <div className={`crv-status-badge crv-status-badge-${assessment?.status || \"needs_revision\"}`}>\n              {statusStyle.label}\n            </div>\n            <div className=\"crv-issue-count\">\n              {assessment?.criticalIssueCount || 0} critical issues \u2022{\" \"}\n              {assessment?.minorIssueCount || 0} minor issues\n            </div>\n            <div className=\"crv-edit-version\">Edit version: {editVersion}</div>\n            {assessment?.failedChecks.length > 0 && <div className=\"crv-failed-checks\">Failed: {assessment.failedChecks.join(\", \")}</div>}\n          </div>\n        </div>\n\n        <div className=\"crv-actions\">\n          {onCorrectSuggestions && <button onClick={onCorrectSuggestions} disabled={isGenerating || !hasIssues} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating || !hasIssues)}`} title={!hasIssues ? \"No issues to correct\" : \"Apply remediation suggestions\"}>\n              \u270e Correct Suggestions\n            </button>}\n          <button onClick={onRegenerate} disabled={isGenerating} className={`crv-btn crv-btn-secondary ${disabledClass(isGenerating)}`}>\n            \u27f3 Regenerate All\n          </button>\n          <button onClick={onAccept} disabled={isGenerating} className={`crv-btn crv-btn-primary ${report.overallScore >= 60 ? \"crv-btn-accept-ready\" : \"crv-btn-accept-warning\"} ${disabledClass(isGenerating)}`}>\n            {report.overallScore >= 60 ? \"Accept Chronicle \u2713\" : \"Accept with Issues \u26a0\"}\n          </button>\n        </div>\n      </div>\n\n      {isValidationStale && <div className=\"crv-stale-warning\">\n          <div className=\"crv-stale-text\">\n            Validation is stale after edits. Revalidate to refresh the report.\n          </div>\n          {onRevalidate && <button onClick={onRevalidate} disabled={isGenerating} className={`crv-btn crv-btn-small ${disabledClass(isGenerating)}`}>\n              Revalidate\n            </button>}\n        </div>}\n\n      <div className=\"crv-refinements\">\n        <div className=\"crv-refinements-title\">Optional Refinements</div>\n        <div className=\"crv-refinements-list\">\n          {/* Summary */}\n          <div className=\"crv-refinement-row\">\n            <div>\n              <div className=\"crv-refinement-name\">Add Summary</div>\n              <div className=\"crv-refinement-desc\">\n                Generate a short summary for chronicle listings.\n              </div>\n              {summaryState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(summaryState.generatedAt)}\n                  {summaryState.model ? ` - ${summaryState.model}` : \"\"}\n                </div>}\n              {summaryIndicator && summaryState.generatedAt && <div className=\"crv-refinement-status-tight\">{summaryIndicator}</div>}\n              {!summaryState.generatedAt && !summaryState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {summaryState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateSummary && <button onClick={onGenerateSummary} disabled={isGenerating || summaryState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || summaryState.running)}`}>\n                {summaryState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* 3. Image Refs - finds image placement opportunities in the narrative */}\n          <div className=\"crv-refinement-row\">\n            <div className=\"crv-refinement-content\">\n              <div className=\"crv-refinement-name\">Add Image Refs</div>\n              <div className=\"crv-refinement-desc\">\n                Generate image placement suggestions for this chronicle.\n              </div>\n              {imageRefsState.generatedAt && <div className=\"crv-refinement-status\">\n                  Done - {formatTimestamp(imageRefsState.generatedAt)}\n                  {imageRefsState.model ? ` - ${imageRefsState.model}` : \"\"}\n                </div>}\n              {imageRefsIndicator && imageRefsState.generatedAt && <div className=\"crv-refinement-status-tight\">{imageRefsIndicator}</div>}\n              {!imageRefsState.generatedAt && !imageRefsState.running && <div className=\"crv-refinement-status\">Not run yet</div>}\n              {imageRefsState.running && <div className=\"crv-refinement-status\">Running...</div>}\n            </div>\n            {onGenerateImageRefs && <button onClick={onGenerateImageRefs} disabled={isGenerating || imageRefsState.running} className={`crv-btn crv-btn-generate ${disabledClass(isGenerating || imageRefsState.running)}`}>\n                {imageRefsState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>}\n          </div>\n\n          {/* Show ChronicleImagePanel when imageRefs are available */}\n          {imageRefs && entityMap && <div className=\"crv-image-panel-wrap\">\n              <ChronicleImagePanel imageRefs={imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} chronicleText={chronicleText || undefined} isGenerating={isGenerating} styleLibrary={styleLibrary} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={chronicleTitle} />\n            </div>}\n        </div>\n      </div>\n\n      {/* Generation Context (expandable) */}\n      {seedData && <ExpandableSeedSection seed={seedData} defaultExpanded={false} />}\n\n      {/* Tabs */}\n      <div className=\"crv-tabs\">\n        {[\"summary\", \"checks\", \"issues\"].map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`crv-tab ${activeTab === tab ? \"crv-tab-active\" : \"\"}`}>\n            {tab}\n            {tab === \"issues\" && report.issues.length > 0 && <span className={`crv-tab-badge ${assessment?.criticalIssueCount > 0 ? \"crv-tab-badge-critical\" : \"crv-tab-badge-minor\"}`}>\n                {report.issues.length}\n              </span>}\n          </button>)}\n      </div>\n\n      {/* Tab content */}\n      {activeTab === \"summary\" && <div className=\"crv-panel\">\n          <h3 className=\"crv-panel-title\">Validation Summary</h3>\n\n          <div className=\"crv-summary-grid\">\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.plotStructure.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.plotStructure.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Structure</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.entityConsistency.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.entityConsistency.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Entity Consistency</div>\n            </div>\n            <div className=\"crv-summary-card\">\n              {}\n              <div className={report.checks.resolution.pass ? \"crv-summary-card-icon crv-summary-card-icon-pass\" : \"crv-summary-card-icon crv-summary-card-icon-fail\"}>\n                {report.checks.resolution.pass ? \"\u2713\" : \"\u2715\"}\n              </div>\n              <div className=\"crv-summary-card-label\">Resolution</div>\n            </div>\n          </div>\n\n          {report.checks.plotStructure.notes && <div className=\"crv-notes-section\">\n              <div className=\"crv-notes-label\">Structure Notes:</div>\n              <div className=\"crv-notes-text\">{report.checks.plotStructure.notes}</div>\n            </div>}\n\n          {report.checks.themeExpression.notes && <div>\n              <div className=\"crv-notes-label\">Theme Expression:</div>\n              <div className=\"crv-notes-text\">{report.checks.themeExpression.notes}</div>\n            </div>}\n        </div>}\n\n      {activeTab === \"checks\" && <div className=\"crv-checks-panel\">\n          <CheckItem label=\"Structure\" check={report.checks.plotStructure} />\n          <CheckItem label=\"Entity Consistency\" check={report.checks.entityConsistency} />\n          <CheckItem label=\"Resolution\" check={report.checks.resolution} />\n          <CheckItem label=\"Factual Accuracy\" check={report.checks.factualAccuracy} />\n          <CheckItem label=\"Theme Expression\" check={report.checks.themeExpression} />\n\n          <div className=\"crv-section-goals-header\">\n            Section Goals ({report.checks.sectionGoals.filter(sg => sg.pass).length}/\n            {report.checks.sectionGoals.length} passed)\n          </div>\n          {report.checks.sectionGoals.map(sg => <div key={sg.sectionId} className=\"crv-section-goal-row\">\n              <div className=\"crv-section-goal-check\">\n                <CheckItem label={resolveSectionLabel(sg.sectionId)} check={sg} isSection />\n              </div>\n              {!sg.pass && <span className=\"crv-section-goal-label\">Needs revision</span>}\n            </div>)}\n        </div>}\n\n      {activeTab === \"issues\" && <div>\n          {report.issues.length === 0 ? <div className=\"crv-no-issues\">\n              <div className=\"crv-no-issues-icon\">\ud83c\udf89</div>\n              <div className=\"crv-no-issues-text\">No issues found!</div>\n            </div> : <>\n              {/* Critical issues first */}\n              {report.issues.filter(i => i.severity === \"critical\").length > 0 && <div className=\"crv-issues-group\">\n                  <h4 className=\"crv-issues-heading crv-issues-heading-critical\">\n                    Critical Issues ({report.issues.filter(i => i.severity === \"critical\").length}\n                    )\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"critical\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n\n              {/* Minor issues */}\n              {report.issues.filter(i => i.severity === \"minor\").length > 0 && <div>\n                  <h4 className=\"crv-issues-heading crv-issues-heading-minor\">\n                    Minor Issues ({report.issues.filter(i => i.severity === \"minor\").length})\n                  </h4>\n                  {report.issues.filter(i => i.severity === \"minor\").map((issue, idx) => <IssueCard key={idx} issue={issue} sectionTitle={issue.sectionId ? resolveSectionLabel(issue.sectionId) : undefined} />)}\n                </div>}\n            </>}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  seedData = null,\n  onAccept,\n  onRegenerate,\n  onCorrectSuggestions,\n  onGenerateSummary,\n  onGenerateImageRefs,\n  onRevalidate,\n  refinements,\n  isValidationStale = false,\n  editVersion = 0,\n  isGenerating = false,\n  imageRefs = null,\n  entityMap = null,\n  onGenerateChronicleImage = null,\n  onResetChronicleImage = null,\n  onUpdateChronicleAnchorText = null,\n  onUpdateChronicleImageSize = null,\n  onUpdateChronicleImageJustification = null,\n  chronicleText = null,\n  summaryIndicator = null,\n  imageRefsIndicator = null,\n  // Style library integration props\n  styleLibrary = null,\n  cultures = null,\n  cultureIdentities = null,\n  worldContext = null,\n  chronicleTitle = null\n}", "type": "{ report: any; seedData?: any; onAccept: any; onRegenerate: any; onCorrectSuggestions: any; onGenerateSummary: any; onGenerateImageRefs: any; onRevalidate: any; refinements: any; isValidationStale?: boolean; editVersion?: number; isGenerating?: boolean; imageRefs?: any; entityMap?: any; onGenerateChronicleImage?: any; onResetChronicleImage?: any; onUpdateChronicleAnchorText?: any; onUpdateChronicleImageSize?: any; onUpdateChronicleImageJustification?: any; chronicleText?: any; summaryIndicato...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ConfigPanel.jsx", "sourceCode": "export default function ConfigPanel({ config, onConfigChange }) {\n  const handleModelChange = (newModel) => {\n    onConfigChange({ imageModel: newModel });\n  };\n\n  return (\n    <div>\n      {/* LLM Call Configuration - per-call model and thinking settings */}\n      <LLMCallConfigPanel />\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Generation</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"model-openai\" className=\"illuminator-label\">Model (OpenAI)</label>\n          <select id=\"model-openai\"\n            value={config.imageModel}\n            onChange={(e) => handleModelChange(e.target.value)}\n            className=\"illuminator-select\"\n          >\n            {IMAGE_MODELS.map((model) => (\n              <option key={model.value} value={model.value}>\n                {model.label}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <p className=\"cfgp-hint\">\n          Size and quality settings are in the Image Settings panel (sidebar).\n        </p>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Multishot Prompting</h2>\n        </div>\n        <p className=\"cfgp-section-desc\">Improve image generation by chaining multiple AI calls.</p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"requireDescription\"\n            checked={config.requireDescription || false}\n            onChange={(e) => onConfigChange({ requireDescription: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"requireDescription\">Require description before image</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint\">\n          Enforces description generation before image generation. The description will be included\n          in the image prompt.\n        </p>\n\n        <div className=\"illuminator-checkbox-group cfgp-checkbox-spacer\">\n          <input\n            type=\"checkbox\"\n            id=\"useClaudeForImagePrompt\"\n            checked={config.useClaudeForImagePrompt || false}\n            onChange={(e) => onConfigChange({ useClaudeForImagePrompt: e.target.checked })}\n            className=\"illuminator-checkbox\"\n          />\n          <label htmlFor=\"useClaudeForImagePrompt\">Use Claude to format image prompt</label>\n        </div>\n        <p className=\"cfgp-checkbox-hint-tight\">\n          Sends the image prompt through Claude first to optimize it for the image model.\n        </p>\n\n        {config.useClaudeForImagePrompt && (\n          <>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Global Image Rules\n              <LocalTextArea\n                value={config.globalImageRules || \"\"}\n                onChange={(value) => onConfigChange({ globalImageRules: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder=\"SPECIES RULE: This world contains only [species]. Any figures depicted must be explicitly described as [species], never as humans or generic figures.\"\n                rows={4}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Domain-specific rules injected into all image prompts. Use this to enforce species,\n                setting constraints, or other world-specific requirements.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Entity image prompt template\n              <LocalTextArea\n                value={config.claudeImagePromptTemplate || DEFAULT_IMAGE_PROMPT_TEMPLATE}\n                onChange={(value) => onConfigChange({ claudeImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for entity portrait images. Use {\"{{modelName}}\"} for the image model name,{\" \"}\n                {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the global\n                rules above.\n              </p>\n            </div>\n            <div className=\"illuminator-form-group cfgp-indented-group\">\n              <label className=\"illuminator-label\">Chronicle image prompt template\n              <LocalTextArea\n                value={\n                  config.claudeChronicleImagePromptTemplate ||\n                  DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE\n                }\n                onChange={(value) => onConfigChange({ claudeChronicleImagePromptTemplate: value })}\n                className=\"illuminator-template-textarea\"\n                placeholder={DEFAULT_CHRONICLE_IMAGE_PROMPT_TEMPLATE}\n              />\n              </label>\n              <p className=\"cfgp-hint\">\n                Used for chronicle cover and scene images. Use {\"{{modelName}}\"} for the image model\n                name, {\"{{prompt}}\"} for the original prompt, and {\"{{globalImageRules}}\"} for the\n                global rules above.\n              </p>\n            </div>\n          </>\n        )}\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Performance</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <span className=\"illuminator-label\">Parallel workers</span>\n          <div className=\"cfgp-workers-row\">\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"8\"\n              value={config.numWorkers || 4}\n              onChange={(e) => onConfigChange({ numWorkers: parseInt(e.target.value, 10) })}\n              className=\"cfgp-range-input\"\n            />\n            <span className=\"cfgp-worker-count\">{config.numWorkers || 4}</span>\n          </div>\n          <p className=\"cfgp-hint\">\n            Number of concurrent API calls. Higher = faster but may hit rate limits.\n          </p>\n        </div>\n      </div>\n\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">About</h2>\n        </div>\n        <p className=\"cfgp-about-text\">\n          Illuminator enriches your world simulation with LLM-generated content. Use the{\" \"}\n          <strong>Entities</strong> tab to generate descriptions and images for entities. Use the{\" \"}\n          <strong>Chronicle</strong> tab to generate multi-entity narratives and in-world documents.\n        </p>\n        <p className=\"cfgp-about-text-spaced\">\n          All enrichments are saved automatically to your current world slot.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onConfigChange }", "type": "{ config: any; onConfigChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CorpusFindReplace.tsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function CorpusFindReplace() {\n  const navEntities = useEntityNavList();\n  const chronicleNavItems = useChronicleStore((s) => s.navItems);\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [find, setFind] = useState(\"\");\n  const [replace, setReplace] = useState(\"\");\n  const [caseSensitive, setCaseSensitive] = useState(true);\n  const [contexts, setContexts] = useState<Set<SearchContext>>(\n    new Set([\n      \"chronicleContent\",\n      \"chronicleTitles\",\n      \"chronicleAnnotations\",\n      \"entityAnnotations\",\n      \"eraNarrativeContent\",\n    ])\n  );\n  const [llmMode, setLlmMode] = useState(false);\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [matches, setMatches] = useState<CorpusMatch[]>([]);\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const [scanProgress, setScanProgress] = useState(\"\");\n\n  // LLM mode state\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const dispatchTimeRef = useRef<number>(0);\n  const expectedBatchCountRef = useRef<number>(0);\n  const matchesRef = useRef<CorpusMatch[]>([]);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) inputRef.current.focus();\n  }, [phase]);\n\n  useEffect(() => {\n    matchesRef.current = matches;\n  }, [matches]);\n\n  const hasAnnotationContext =\n    contexts.has(\"chronicleAnnotations\") || contexts.has(\"entityAnnotations\");\n\n  const toggleContext = useCallback((ctx: SearchContext) => {\n    setContexts((prev) => {\n      const next = new Set(prev);\n      if (next.has(ctx)) next.delete(ctx);\n      else next.add(ctx);\n      return next;\n    });\n  }, []);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    if (!find || contexts.size === 0) return;\n    setPhase(\"scanning\");\n    setError(null);\n    const allMatches: CorpusMatch[] = [];\n\n    // 1. Chronicle content\n    if (contexts.has(\"chronicleContent\")) {\n      const completeIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.status === \"complete\")\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < completeIds.length; i++) {\n        setScanProgress(`Chronicle content ${i + 1}/${completeIds.length}`);\n        const record = await getChronicle(completeIds[i]);\n        if (!record) continue;\n        const name = record.title || chronicleNavItems[completeIds[i]]?.name || \"Untitled\";\n\n        if (record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.finalContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"final\",\n              \"Published\",\n              undefined,\n              undefined\n            )\n          );\n        }\n        if (record.assembledContent && record.assembledContent !== record.finalContent) {\n          allMatches.push(\n            ...scanText(\n              record.assembledContent,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleContent\",\n              completeIds[i],\n              \"assembled\",\n              \"Current Draft\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    // 2. Chronicle titles\n    if (contexts.has(\"chronicleTitles\")) {\n      const allIds = Object.values(chronicleNavItems).map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < allIds.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Chronicle titles ${i + 1}/${allIds.length}`);\n        const record = await getChronicle(allIds[i]);\n        if (!record?.title) continue;\n        allMatches.push(\n          ...scanText(\n            record.title,\n            find,\n            caseSensitive,\n            record.title,\n            \"chronicleTitles\",\n            allIds[i],\n            \"title\",\n            \"Title\",\n            undefined,\n            undefined\n          )\n        );\n      }\n    }\n\n    // 3. Chronicle annotations\n    if (contexts.has(\"chronicleAnnotations\")) {\n      const annotatedIds = Object.values(chronicleNavItems)\n        .filter((nav) => nav.historianNoteCount > 0)\n        .map((nav) => nav.chronicleId);\n\n      for (let i = 0; i < annotatedIds.length; i++) {\n        setScanProgress(`Chronicle annotations ${i + 1}/${annotatedIds.length}`);\n        const record = await getChronicle(annotatedIds[i]);\n        if (!record?.historianNotes) continue;\n        const name = record.title || chronicleNavItems[annotatedIds[i]]?.name || \"Untitled\";\n\n        for (const note of record.historianNotes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              name,\n              \"chronicleAnnotations\",\n              annotatedIds[i],\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          // Also scan anchor phrases\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                name + \" (anchor)\",\n                \"chronicleAnnotations\",\n                annotatedIds[i],\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 4. Entity annotations\n    if (contexts.has(\"entityAnnotations\")) {\n      const annotatedNavs = navEntities.filter((n) => n.hasHistorianNotes);\n      setScanProgress(`Entity annotations: loading ${annotatedNavs.length} entities`);\n\n      const fullEntities = await useEntityStore\n        .getState()\n        .loadEntities(annotatedNavs.map((n) => n.id));\n\n      for (let i = 0; i < fullEntities.length; i++) {\n        if (i % 50 === 0) setScanProgress(`Entity annotations ${i + 1}/${fullEntities.length}`);\n        const entity = fullEntities[i];\n        const notes = entity.enrichment?.historianNotes;\n        if (!notes) continue;\n\n        for (const note of notes) {\n          if (!isNoteActive(note)) continue;\n          allMatches.push(\n            ...scanText(\n              note.text,\n              find,\n              caseSensitive,\n              entity.name,\n              \"entityAnnotations\",\n              entity.id,\n              undefined,\n              undefined,\n              note.noteId,\n              note.text\n            )\n          );\n          if (note.anchorPhrase) {\n            allMatches.push(\n              ...scanText(\n                note.anchorPhrase,\n                find,\n                caseSensitive,\n                entity.name + \" (anchor)\",\n                \"entityAnnotations\",\n                entity.id,\n                undefined,\n                undefined,\n                note.noteId,\n                note.text\n              )\n            );\n          }\n        }\n      }\n    }\n\n    // 5. Era narrative content\n    if (contexts.has(\"eraNarrativeContent\")) {\n      const simRunId = useChronicleStore.getState().simulationRunId;\n      if (simRunId) {\n        const allNarratives = await getEraNarrativesForSimulation(simRunId);\n        const completedNarratives = allNarratives.filter(\n          (n) => n.status === \"complete\" || n.status === \"step_complete\"\n        );\n\n        for (let i = 0; i < completedNarratives.length; i++) {\n          setScanProgress(`Era narratives ${i + 1}/${completedNarratives.length}`);\n          const record = completedNarratives[i];\n          const { content } = resolveActiveContent(record);\n          if (!content) continue;\n          allMatches.push(\n            ...scanText(\n              content,\n              find,\n              caseSensitive,\n              record.eraName,\n              \"eraNarrativeContent\",\n              record.narrativeId,\n              \"activeContent\",\n              \"Active Version\",\n              undefined,\n              undefined\n            )\n          );\n        }\n      }\n    }\n\n    setScanProgress(\"\");\n    setMatches(allMatches);\n\n    const initial: Record<string, boolean> = {};\n    for (const m of allMatches) initial[m.id] = true;\n    setDecisions(initial);\n\n    // Expand first group per context\n    const firstKeys = new Set<string>();\n    const seen = new Set<SearchContext>();\n    for (const m of allMatches) {\n      if (!seen.has(m.context)) {\n        firstKeys.add(`${m.context}:${m.sourceId}`);\n        seen.add(m.context);\n      }\n    }\n    setExpandedGroups(firstKeys);\n\n    setPhase(allMatches.length > 0 ? \"preview\" : \"empty\");\n  }, [find, caseSensitive, contexts, chronicleNavItems, navEntities]);\n\n  // --- Generate LLM Variants ---\n  const handleGenerate = useCallback(() => {\n    setPhase(\"generating\");\n    setError(null);\n\n    // Only annotation matches go through LLM\n    const annotationMatches = matches.filter(\n      (m) => m.context === \"chronicleAnnotations\" || m.context === \"entityAnnotations\"\n    );\n\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CostsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CostsPanel.jsx", "sourceCode": "export default function CostsPanel({ queue, projectId, simulationRunId }) {\n  // Cost data from IndexedDB\n  const [simulationCosts, setSimulationCosts] = useState(null);\n  const [projectCosts, setProjectCosts] = useState(null);\n  const [allTimeCosts, setAllTimeCosts] = useState(null);\n  const [refreshTrigger, setRefreshTrigger] = useState(0);\n\n  // Track running tasks to know when to refresh\n  const runningTaskCount = useMemo(() => {\n    return queue.filter((item) => item.status === \"queued\" || item.status === \"running\").length;\n  }, [queue]);\n\n  // Fetch costs from IndexedDB\n  const fetchCosts = useCallback(async () => {\n    try {\n      // All-time costs\n      const allRecords = await getAllCosts();\n      setAllTimeCosts(summarizeCosts(allRecords));\n\n      // Project costs\n      if (projectId) {\n        const projectRecords = await getCostsForProject(projectId);\n        setProjectCosts(summarizeCosts(projectRecords));\n      } else {\n        setProjectCosts(null);\n      }\n\n      // Simulation costs\n      if (simulationRunId) {\n        const simRecords = await getCostsForSimulation(simulationRunId);\n        setSimulationCosts(summarizeCosts(simRecords));\n      } else {\n        setSimulationCosts(null);\n      }\n    } catch (err) {\n      console.error(\"[CostsPanel] Failed to fetch costs:\", err);\n    }\n  }, [projectId, simulationRunId]);\n\n  // Fetch on mount and when dependencies change\n  useEffect(() => {\n    fetchCosts();\n  }, [fetchCosts, refreshTrigger]);\n\n  // Refresh when queue changes (tasks complete)\n  useEffect(() => {\n    // Only refresh when queue length decreases (task completed)\n    const timer = setTimeout(() => {\n      setRefreshTrigger((prev) => prev + 1);\n    }, 500);\n    return () => clearTimeout(timer);\n  }, [queue.length, runningTaskCount]);\n\n  // Calculate pending queue costs (estimated)\n  const queueCosts = useMemo(() => {\n    let textEstimated = 0;\n    let imageEstimated = 0;\n    let chronicleEstimated = 0;\n\n    for (const item of queue) {\n      if (item.status === \"complete\") continue;\n      if (item.estimatedCost) {\n        if (item.type === \"image\") {\n          imageEstimated += item.estimatedCost;\n        } else if (item.type === \"entityChronicle\") {\n          chronicleEstimated += item.estimatedCost;\n        } else {\n          textEstimated += item.estimatedCost;\n        }\n      } else if (item.type === \"entityChronicle\" && item.status !== \"complete\") {\n        // Estimate chronicle cost if not available (~$0.05-0.15 per chronicle depending on length)\n        chronicleEstimated += 0.08;\n      }\n    }\n\n    return {\n      textEstimated,\n      imageEstimated,\n      chronicleEstimated,\n      total: textEstimated + imageEstimated + chronicleEstimated,\n    };\n  }, [queue]);\n\n  // Categorize costs for display\n  const simCategorized = simulationCosts ? categorizeCosts(simulationCosts) : null;\n  const projCategorized = projectCosts ? categorizeCosts(projectCosts) : null;\n  const allCategorized = allTimeCosts ? categorizeCosts(allTimeCosts) : null;\n\n  const handleClearHistory = async () => {\n    if (confirm(\"Clear all cost history? This cannot be undone.\")) {\n      await clearAllCosts();\n      setRefreshTrigger((prev) => prev + 1);\n    }\n  };\n\n  return (\n    <div>\n      {/* Current Simulation */}\n      {simCategorized && (\n        <CostCard title=\"Current Simulation\">\n          <div className=\"cpanel-section-hint\">Costs from this simulation run.</div>\n          <CostRow label=\"Text generations\" value={simCategorized.text.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.text.count} requests`}\n            value={simCategorized.text.actual}\n          />\n          <CostRow label=\"Image generations\" value={simCategorized.image.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.image.count} images`}\n            value={simCategorized.image.actual}\n          />\n          <CostRow label=\"Chronicle generations\" value={simCategorized.chronicle.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.chronicle.count} steps`}\n            value={simCategorized.chronicle.actual}\n          />\n          <CostRow label=\"Dynamics generation\" value={simCategorized.dynamics.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.dynamics.count} turns`}\n            value={simCategorized.dynamics.actual}\n          />\n          <CostRow label=\"Summary revision\" value={simCategorized.revision.actual} />\n          <CostRow\n            label={`  \\u2514 ${simCategorized.revision.count} batches`}\n            value={simCategorized.revision.actual}\n          />\n          <CostRow label=\"Simulation Total\" value={simulationCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* Pending Queue */}\n      {queueCosts.total > 0 && (\n        <CostCard title=\"Pending Queue (Estimated)\">\n          <div className=\"cpanel-section-hint\">\n            Estimated costs for queued tasks not yet completed.\n          </div>\n          <CostRow label=\"Text generations\" value={queueCosts.textEstimated} isEstimated />\n          <CostRow label=\"Image generations\" value={queueCosts.imageEstimated} isEstimated />\n          <CostRow\n            label=\"Chronicle generations\"\n            value={queueCosts.chronicleEstimated}\n            isEstimated\n          />\n          <CostRow label=\"Queue Total\" value={queueCosts.total} isTotal isEstimated />\n        </CostCard>\n      )}\n\n      {/* By Model */}\n      {simulationCosts && Object.keys(simulationCosts.byModel).length > 0 && (\n        <CostCard title=\"By Model (Simulation)\">\n          <div className=\"cpanel-section-hint\">Cost breakdown by model used.</div>\n          {Object.entries(simulationCosts.byModel)\n            .sort((a, b) => b[1].actual - a[1].actual)\n            .map(([model, data]) => (\n              <CostRow key={model} label={model} value={data.actual} />\n            ))}\n        </CostCard>\n      )}\n\n      {/* Project Total */}\n      {projCategorized && (\n        <CostCard title=\"Project Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs for this project across all simulations.\n          </div>\n          <CostRow label=\"Text generations\" value={projCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={projCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={projCategorized.chronicle.actual} />\n          <CostRow label=\"Project Total\" value={projectCosts.totalActual} isTotal />\n        </CostCard>\n      )}\n\n      {/* All Time */}\n      {allCategorized && (\n        <CostCard title=\"All Time Total\">\n          <div className=\"cpanel-section-hint\">\n            Accumulated costs across all projects and sessions.\n          </div>\n          <CostRow label=\"Text generations\" value={allCategorized.text.actual} />\n          <CostRow label=\"Image generations\" value={allCategorized.image.actual} />\n          <CostRow label=\"Chronicle generations\" value={allCategorized.chronicle.actual} />\n          <CostRow label=\"All Time Total\" value={allTimeCosts.totalActual} isTotal />\n          <CostRow\n            label={`  \\u2514 ${allTimeCosts.count} total records`}\n            value={allTimeCosts.totalActual}\n          />\n\n          <button\n            onClick={() => void handleClearHistory()}\n            className=\"illuminator-button-link cpanel-clear-button\"\n          >\n            Clear History\n          </button>\n        </CostCard>\n      )}\n\n      {/* Empty state */}\n      {!simulationCosts && !allTimeCosts && queueCosts.total === 0 && (\n        <CostCard title=\"Cost Tracking\">\n          <div className=\"cpanel-empty-hint\">\n            No costs recorded yet. Costs will appear here as you generate content.\n          </div>\n        </CostCard>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ queue, projectId, simulationRunId }", "type": "{ queue: any; projectId: any; simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CoveragePanel.jsx", "sourceCode": "export default function CoveragePanel({\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}) {\n  const [chronicles, setChronicles] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [expanded, setExpanded] = useState(true);\n  const [disabledChronicles, setDisabledChronicles] = useState(() => {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (!raw) return {};\n      const parsed = JSON.parse(raw);\n      if (parsed && typeof parsed === \"object\") return parsed;\n    } catch {}\n    return {};\n  });\n  useEffect(() => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(disabledChronicles));\n    } catch {}\n  }, [disabledChronicles]);\n  useEffect(() => {\n    if (!simulationRunId) return;\n    let cancelled = false;\n    setLoading(true);\n    getChroniclesForSimulation(simulationRunId).then(records => {\n      if (!cancelled) setChronicles(records);\n    }).catch(err => {\n      console.error(\"[Coverage] Failed to load chronicles:\", err);\n      if (!cancelled) setChronicles([]);\n    }).finally(() => {\n      if (!cancelled) setLoading(false);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId]);\n  const toggleChronicle = useCallback(chronicleId => {\n    setDisabledChronicles(prev => ({\n      ...prev,\n      [chronicleId]: !prev[chronicleId]\n    }));\n  }, []);\n  const toggleFact = useCallback(factId => {\n    if (!onWorldContextChange) return;\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const updated = rawFacts.map(f => f.id === factId ? {\n      ...f,\n      disabled: !f.disabled,\n      required: !f.disabled ? false : f.required\n    } : f);\n    onWorldContextChange({\n      canonFactsWithMetadata: updated\n    });\n  }, [onWorldContextChange, worldContext?.canonFactsWithMetadata]);\n  const analysis = useMemo(() => {\n    const rawFacts = worldContext?.canonFactsWithMetadata || [];\n    const normalizedWorldFacts = rawFacts.map((fact, index) => normalizeFact(fact, index)).filter(Boolean);\n    const chronicleList = [...(chronicles || [])].sort(sortChronicles);\n    const facts = normalizedWorldFacts.filter(fact => fact.type !== \"generation_constraint\");\n    const enabledFacts = facts.filter(fact => !fact.disabled);\n    const allFactIdSet = new Set(facts.map(fact => fact.id));\n    const rows = chronicleList.map(chronicle => {\n      const synthesis = chronicle.perspectiveSynthesis || null;\n      const facetIds = new Set();\n      let unparsedCount = 0;\n      for (const facet of synthesis?.facets || []) {\n        if (!facet?.factId) continue;\n        if (allFactIdSet.has(facet.factId)) {\n          facetIds.add(facet.factId);\n        } else {\n          unparsedCount += 1;\n        }\n      }\n      return {\n        chronicle,\n        synthesis,\n        facetIds,\n        unparsedCount,\n        isIncluded: !disabledChronicles[chronicle.chronicleId]\n      };\n    });\n    const factTotals = new Map(facts.map(fact => [fact.id, 0]));\n    const disabledFactIds = new Set(facts.filter(f => f.disabled).map(f => f.id));\n    let totalSelections = 0;\n    let unparsedTotal = 0;\n    let includedCount = 0;\n    const processedRows = rows.map(row => {\n      if (row.isIncluded) {\n        includedCount += 1;\n        for (const factId of row.facetIds) {\n          factTotals.set(factId, (factTotals.get(factId) || 0) + 1);\n        }\n        let enabledHits = 0;\n        for (const factId of row.facetIds) {\n          if (!disabledFactIds.has(factId)) enabledHits += 1;\n        }\n        totalSelections += enabledHits;\n        unparsedTotal += row.unparsedCount || 0;\n      }\n      let rowEnabledTotal = 0;\n      for (const factId of row.facetIds) {\n        if (!disabledFactIds.has(factId)) rowEnabledTotal += 1;\n      }\n      return {\n        ...row,\n        rowTotal: rowEnabledTotal\n      };\n    });\n    const chroniclesWithSynthesis = processedRows.filter(row => row.synthesis).length;\n    const unusedFacts = enabledFacts.filter(fact => (factTotals.get(fact.id) || 0) === 0).length;\n    const disabledFactCount = facts.filter(fact => fact.disabled).length;\n    const constraintCount = normalizedWorldFacts.filter(fact => fact.type === \"generation_constraint\").length;\n    return {\n      facts,\n      factTotals,\n      rows: processedRows,\n      totalSelections,\n      unparsedTotal,\n      includedCount,\n      chroniclesWithSynthesis,\n      chronicleCount: processedRows.length,\n      unusedFacts,\n      disabledFactCount,\n      constraintCount\n    };\n  }, [chronicles, worldContext, disabledChronicles]);\n  const {\n    facts,\n    factTotals,\n    rows,\n    totalSelections,\n    unparsedTotal,\n    includedCount,\n    chroniclesWithSynthesis,\n    chronicleCount,\n    unusedFacts,\n    disabledFactCount,\n    constraintCount\n  } = analysis;\n\n  // Fact coverage analysis stats (from LLM ratings)\n  const coverageStats = useMemo(() => {\n    const chroniclesWithReport = chronicles.filter(c => c.factCoverageReport?.entries?.length);\n    if (!chroniclesWithReport.length || !facts.length) return null;\n\n    // Per-fact aggregation: count how many chronicles rated each fact at each level\n    const perFact = new Map();\n    for (const fact of facts) {\n      perFact.set(fact.id, {\n        integral: 0,\n        prevalent: 0,\n        mentioned: 0,\n        missing: 0,\n        total: 0\n      });\n    }\n    for (const chronicle of chroniclesWithReport) {\n      for (const entry of chronicle.factCoverageReport.entries) {\n        const agg = perFact.get(entry.factId);\n        if (agg && entry.rating) {\n          if (agg[entry.rating] !== undefined) agg[entry.rating]++;\n          agg.total++;\n        }\n      }\n    }\n\n    // Global totals\n    let totalEntries = 0;\n    const globalCounts = {\n      integral: 0,\n      prevalent: 0,\n      mentioned: 0,\n      missing: 0\n    };\n    for (const [, agg] of perFact) {\n      for (const r of [\"integral\", \"prevalent\", \"mentioned\", \"missing\"]) {\n        globalCounts[r] += agg[r];\n      }\n      totalEntries += agg.total;\n    }\n    return {\n      chroniclesAnalyzed: chroniclesWithReport.length,\n      totalEntries,\n      globalCounts,\n      perFact\n    };\n  }, [chronicles, facts]);\n  const disableAll = useCallback(() => {\n    const next = {};\n    for (const row of rows) {\n      next[row.chronicle.chronicleId] = true;\n    }\n    setDisabledChronicles(next);\n  }, [rows]);\n  const enableAll = useCallback(() => {\n    setDisabledChronicles({});\n  }, []);\n  if (!simulationRunId) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">No active simulation run.</div>\n      </div>;\n  }\n  if (loading && chronicleCount === 0) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n        </div>\n        <div className=\"cvp-empty-msg\">Loading chronicles...</div>\n      </div>;\n  }\n  if (!facts.length) {\n    return <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Coverage</h2>\n          <span className=\"illuminator-card-subtitle\">Perspective synthesis fact coverage</span>\n        </div>\n        <div className=\"cvp-empty-msg\">\n          No canon facts configured. Add facts in the Context tab to enable coverage tracking.\n        </div>\n      </div>;\n  }\n  return <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header cvp-header-clickable\" onClick={() => setExpanded(prev => !prev)} role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        <span className=\"cvp-expand-icon\">{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <h2 className=\"illuminator-card-title\">Lore Coverage</h2>\n        {!expanded && <span className=\"illuminator-card-subtitle cvp-collapsed-subtitle\">\n            {chronicleCount} chronicles, {facts.length - disabledFactCount} facts\n            {unusedFacts > 0 ? `, ${unusedFacts} unused` : \"\"}\n          </span>}\n      </div>\n\n      {expanded && <>\n          <div className=\"illuminator-coverage-summary\">\n            <div>\n              <strong>Chronicles</strong>: {chronicleCount} total, {includedCount} counted,{\" \"}\n              {chroniclesWithSynthesis} with synthesis\n            </div>\n            <div>\n              <strong>Facts</strong>: {facts.length - disabledFactCount} active ({unusedFacts}{\" \"}\n              unused){disabledFactCount > 0 && `, ${disabledFactCount} disabled`}\n            </div>\n            <div>\n              <strong>Total selections</strong>: {totalSelections}\n            </div>\n            <div>\n              <strong>Unparsed facets</strong>: {unparsedTotal}\n            </div>\n            {constraintCount > 0 && <div>\n                <strong>Constraints excluded</strong>: {constraintCount}\n              </div>}\n            <div className=\"cvp-summary-controls\">\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={enableAll}>\n                Count all\n              </button>\n              <button className=\"illuminator-button illuminator-button-secondary cvp-summary-btn\" onClick={disableAll}>\n                Count none\n              </button>\n            </div>\n          </div>\n\n          <div className=\"illuminator-coverage-table\">\n            <table>\n              <thead>\n                <tr>\n                  <th className=\"illuminator-coverage-sticky\">Chronicle</th>\n                  <th className=\"illuminator-coverage-toggle-col\">Counted</th>\n                  {facts.map(fact => {\n                const factText = fact.text ? `: ${fact.text}` : \"\";\n                const requiredLabel = fact.required ? \" (required)\" : \"\";\n                const disabledLabel = fact.disabled ? \" (disabled \\u2014 click to enable)\" : \" (click to disable)\";\n                const factTitle = `${fact.id}${factText}${requiredLabel}${disabledLabel}`;\n                return <th key={fact.id} title={factTitle} onClick={onWorldContextChange ? () => toggleFact(fact.id) : undefined} className={onWorldContextChange ? \"cvp-fact-header-clickable\" : undefined}>\n                      <div className={`illuminator-coverage-fact-header ${fact.disabled ? \"cvp-fact-header-disabled\" : \"\"}`}>\n                        <span className=\"illuminator-coverage-fact-id\">{fact.id}</span>\n                        {fact.required && <span className=\"illuminator-coverage-required\">R</span>}\n                        {fact.disabled && <span className=\"cvp-fact-disabled-label\">off</span>}\n                      </div>\n                    </th>;\n              })}\n                  <th className=\"illuminator-coverage-unparsed-col\">Unparsed</th>\n                  <th className=\"illuminator-coverage-total-col\">Total</th>\n                </tr>\n              </thead>\n              <tbody>\n                <tr className=\"illuminator-coverage-total-row\">\n                  <td className=\"illuminator-coverage-sticky\">Total usage</td>\n                  <td className=\"illuminator-coverage-toggle-col\">{includedCount}</td>\n                  {facts.map(fact => <td key={`total-${fact.id}`} className={fact.disabled ? \"cvp-cell-disabled\" : undefined}>\n                      {factTotals.get(fact.id) || 0}\n                    </td>)}\n                  <td className=\"illuminator-coverage-unparsed-col\">{unparsedTotal}</td>\n                  <td className=\"illuminator-coverage-total-col\">{totalSelections}</td>\n                </tr>\n// ... (truncated)", "parameters": [{"name": "{\n  worldContext,\n  simulationRunId,\n  onWorldContextChange\n}", "type": "{ worldContext: any; simulationRunId: any; onWorldContextChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/CreateEntityModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/CreateEntityModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Component\n// ---------------------------------------------------------------------------\n\nexport default function CreateEntityModal({\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}: Readonly<CreateEntityModalProps>) {\n  const isEdit = Boolean(editEntity);\n  const entityKinds = useMemo(\n    () => (worldSchema.entityKinds || []).filter((k) => !k.isFramework),\n    [worldSchema.entityKinds]\n  );\n  const cultures = worldSchema.cultures || [];\n  const d = isEdit ? undefined : defaults; // ignore defaults in edit mode\n\n  // Form state \u2014 initialized from editEntity (edit mode) or defaults (create mode)\n  const [kind, setKind] = useState(() => editEntity?.kind || d?.kind || entityKinds[0]?.kind || \"\");\n  const [name] = useState(() => editEntity?.name || \"\");\n  const [nameInput, setNameInput] = useState(() => editEntity?.name || d?.name || \"\");\n  const [culture, setCulture] = useState(\n    () => editEntity?.culture || d?.culture || cultures[0]?.id || \"\"\n  );\n  const [prominence, setProminence] = useState(() => editEntity?.prominence ?? 1);\n  const [description, setDescription] = useState(() => editEntity?.description || \"\");\n  const [eraId, setEraId] = useState(() => editEntity?.eraId || d?.eraId || \"\");\n  const [startTick, setStartTick] = useState(() => {\n    if (editEntity?.temporal?.startTick != null) return String(editEntity.temporal.startTick);\n    if (d?.startTick != null) return String(d.startTick);\n    return \"\";\n  });\n  const [endTick, setEndTick] = useState(() => {\n    if (editEntity?.temporal?.endTick != null) return String(editEntity.temporal.endTick);\n    if (d?.endTick != null) return String(d.endTick);\n    return \"\";\n  });\n  const [tags, setTags] = useState<Record<string, string>>(() =>\n    tagsToStringRecord(editEntity?.tags)\n  );\n  const [tagKey, setTagKey] = useState(\"\");\n  const [tagValue, setTagValue] = useState(\"\");\n\n  // Derived from selected kind\n  const kindDef = useMemo(() => entityKinds.find((k) => k.kind === kind), [entityKinds, kind]);\n  const subtypes = kindDef?.subtypes || [];\n  const statuses = kindDef?.statuses || [];\n  const defaultStatus = kindDef?.defaultStatus || statuses[0]?.id || \"active\";\n\n  const [subtype, setSubtype] = useState(\n    () => editEntity?.subtype || d?.subtype || subtypes[0]?.id || \"\"\n  );\n  const [status, setStatus] = useState(() => editEntity?.status || defaultStatus);\n\n  // Cascade subtype and status when kind changes (only in create mode or explicit change)\n  const handleKindChange = useCallback(\n    (newKind: string) => {\n      setKind(newKind);\n      const def = entityKinds.find((k) => k.kind === newKind);\n      setSubtype(def?.subtypes[0]?.id || \"\");\n      setStatus(def?.defaultStatus || def?.statuses[0]?.id || \"active\");\n    },\n    [entityKinds]\n  );\n\n  // Tag management\n  const addTag = useCallback(() => {\n    const k = tagKey.trim();\n    if (!k) return;\n    setTags((prev) => ({ ...prev, [k]: tagValue }));\n    setTagKey(\"\");\n    setTagValue(\"\");\n  }, [tagKey, tagValue]);\n\n  const removeTag = useCallback((key: string) => {\n    setTags((prev) => {\n      const next = { ...prev };\n      delete next[key];\n      return next;\n    });\n  }, []);\n\n  // Submit\n  const effectiveName = isEdit ? name : nameInput;\n  const canSubmit = effectiveName.trim().length > 0 && kind;\n\n  const handleSubmit = useCallback(() => {\n    if (!canSubmit) return;\n    const entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\"> = {\n      kind,\n      subtype,\n      name: effectiveName.trim(),\n      culture,\n      status,\n      prominence,\n      description,\n      tags,\n      coordinates: editEntity?.coordinates || { x: 0, y: 0, z: 0 },\n    };\n    if (eraId) entity.eraId = eraId;\n    const parsedStart = Number(startTick);\n    const parsedEnd = endTick ? Number(endTick) : null;\n    if (Number.isFinite(parsedStart)) {\n      entity.temporal = { startTick: parsedStart, endTick: parsedEnd };\n    }\n    onSubmit(entity);\n  }, [\n    canSubmit,\n    kind,\n    subtype,\n    effectiveName,\n    culture,\n    status,\n    prominence,\n    description,\n    tags,\n    eraId,\n    startTick,\n    endTick,\n    editEntity,\n    onSubmit,\n  ]);\n\n  const title = isEdit ? \"Edit Entity\" : \"Create Entity\";\n  const submitLabel = isEdit ? \"Save Changes\" : \"Create Entity\";\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"cem-backdrop\">\n        <div className=\"cem-card\">\n          <div className=\"cem-header\">\n            <h2 className=\"cem-title\">{title}</h2>\n          </div>\n          <div className=\"cem-empty-body\">\n            No entity kinds available in the schema.\n          </div>\n          <div className=\"cem-footer\">\n            <button onClick={onClose} className=\"illuminator-button illuminator-button-secondary\">\n              Close\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"cem-backdrop\">\n      <div className=\"cem-card\">\n        {/* Header */}\n        <div className=\"cem-header\">\n          <h2 className=\"cem-title\">{title}</h2>\n          {isEdit && (\n            <p className=\"cem-edit-subtitle\">\n              {name}\n            </p>\n          )}\n        </div>\n\n        {/* Body */}\n        <div className=\"cem-body\">\n          {/* Kind + Subtype row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"kind\" className=\"cem-label\">Kind</label>\n              <select id=\"kind\"\n                value={kind}\n                onChange={(e) => handleKindChange(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {entityKinds.map((k) => (\n                  <option key={k.kind} value={k.kind}>\n                    {k.description || k.kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"subtype\" className=\"cem-label\">Subtype</label>\n              <select id=\"subtype\"\n                value={subtype}\n                onChange={(e) => setSubtype(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n                disabled={subtypes.length === 0}\n              >\n                {subtypes.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n                {subtypes.length === 0 && <option value=\"\">None</option>}\n              </select>\n            </div>\n          </div>\n\n          {/* Name \u2014 only editable in create mode */}\n          {!isEdit && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"name\" className=\"cem-label\">Name *</label>\n              <input id=\"name\"\n                type=\"text\"\n                value={nameInput}\n                onChange={(e) => setNameInput(e.target.value)}\n                placeholder=\"Entity name\"\n                className=\"illuminator-select cem-full-width-box\"\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n\n          {/* Culture + Status row */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"culture\" className=\"cem-label\">Culture</label>\n              <select id=\"culture\"\n                value={culture}\n                onChange={(e) => setCulture(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {cultures.map((c) => (\n                  <option key={c.id} value={c.id}>\n                    {c.name || c.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              <label htmlFor=\"status\" className=\"cem-label\">Status</label>\n              <select id=\"status\"\n                value={status}\n                onChange={(e) => setStatus(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                {statuses.map((s) => (\n                  <option key={s.id} value={s.id}>\n                    {s.name || s.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          </div>\n\n          {/* Prominence */}\n          <div className=\"cem-field-group\">\n            <label htmlFor=\"prominence\" className=\"cem-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={prominence}\n              onChange={(e) => setProminence(Number(e.target.value))}\n              className=\"illuminator-select cem-full-width\"\n            >\n              {PROMINENCE_OPTIONS.map((opt) => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.label}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          {/* Era */}\n          {eras.length > 0 && (\n            <div className=\"cem-field-group\">\n              <label htmlFor=\"era\" className=\"cem-label\">Era</label>\n              <select id=\"era\"\n                value={eraId}\n                onChange={(e) => setEraId(e.target.value)}\n                className=\"illuminator-select cem-full-width\"\n              >\n                <option value=\"\">None</option>\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name || era.id}\n                  </option>\n                ))}\n              </select>\n            </div>\n          )}\n\n          {/* Temporal */}\n          <div\n            className=\"cem-two-column-grid\"\n          >\n            <div>\n              <label htmlFor=\"start-tick\" className=\"cem-label\">Start Tick</label>\n              <input id=\"start-tick\"\n                type=\"number\"\n                value={startTick}\n                onChange={(e) => setStartTick(e.target.value)}\n                placeholder=\"Optional\"\n                className=\"illuminator-select cem-full-width-box\"\n              />\n            </div>\n            <div>\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema,\n  eras,\n  editEntity,\n  defaults,\n  onSubmit,\n  onClose,\n}", "type": "Readonly<CreateEntityModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DescriptionMotifWeaver.tsx", "sourceCode": "// ============================================================================\n// Modal\n// ============================================================================\n\nexport default function DescriptionMotifWeaver({ onClose }: Readonly<{ onClose: () => void }>) {\n  const navEntities = useEntityNavList();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n\n  const [phase, setPhase] = useState<Phase>(\"scan\");\n  const [candidates, setCandidates] = useState<WeaveCandidate[]>([]);\n  const [variants, setVariants] = useState<Map<string, string>>(new Map());\n  const [decisions, setDecisions] = useState<Record<string, boolean>>({});\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());\n  const [resultCount, setResultCount] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n\n  const dispatchTimeRef = useRef<number>(0);\n  const candidatesRef = useRef<WeaveCandidate[]>([]);\n\n  useEffect(() => {\n    candidatesRef.current = candidates;\n  }, [candidates]);\n\n  // --- Scan ---\n  const handleScan = useCallback(async () => {\n    setPhase(\"scanning\");\n    setError(null);\n\n    // Load all entities with descriptions\n    const allNavs = navEntities.filter((n) => n.kind !== \"era\" && n.kind !== \"occurrence\");\n    if (allNavs.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    const fullEntities = await useEntityStore.getState().loadEntities(allNavs.map((n) => n.id));\n\n    let globalIndex = 0;\n    const allCandidates: WeaveCandidate[] = [];\n\n    for (const entity of fullEntities) {\n      if (!entity.description) continue;\n      const entityCandidates = scanDescriptionForConcepts(\n        entity.id,\n        entity.name,\n        entity.description,\n        globalIndex\n      );\n      allCandidates.push(...entityCandidates);\n      globalIndex += entityCandidates.length;\n    }\n\n    if (allCandidates.length === 0) {\n      setPhase(\"empty\");\n      return;\n    }\n\n    setCandidates(allCandidates);\n    // Default: reject all (light touch \u2014 user opts in)\n    const initial: Record<string, boolean> = {};\n    for (const c of allCandidates) initial[c.id] = false;\n    setDecisions(initial);\n    if (allCandidates.length > 0) {\n      setExpandedGroups(new Set([allCandidates[0].entityId]));\n    }\n\n    // Stop for confirmation before LLM calls\n    setPhase(\"confirm\");\n  }, [navEntities]);\n\n  // --- Generate ---\n  const handleGenerate = useCallback((scanCandidates: WeaveCandidate[]) => {\n    setPhase(\"generating\");\n\n    const batches: WeaveCandidate[][] = [];\n    for (let i = 0; i < scanCandidates.length; i += BATCH_SIZE) {\n      batches.push(scanCandidates.slice(i, i + BATCH_SIZE));\n    }\n\n    const dispatchTime = Date.now();\n    dispatchTimeRef.current = dispatchTime;\n\n    for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {\n      const batch = batches[batchIdx];\n      const payload: MotifWeavePayload = {\n        mode: \"weave\",\n        targetPhrase: TARGET_PHRASE,\n        instances: batch.map((c) => ({\n          index: c.batchIndex,\n          entityName: c.entityName,\n          sentence: c.sentence,\n          surroundingContext: c.contextBefore + c.contextAfter,\n        })),\n      };\n\n      const syntheticEntity = {\n        id: `weave_batch_${dispatchTime}_${batchIdx}`,\n        name: `Weave: ${TARGET_PHRASE} (batch ${batchIdx + 1})`,\n        kind: \"motif\" as string,\n        subtype: \"weave\" as string,\n        prominence: \"marginal\" as unknown as string,\n        culture: \"\" as string,\n        status: \"active\" as string,\n        description: \"\" as string,\n        tags: {} as Record<string, unknown>,\n      };\n\n      try {\n        getEnqueue()([\n          {\n            entity: syntheticEntity,\n            type: \"motifVariation\" as const,\n            prompt: JSON.stringify(payload),\n          },\n        ]);\n      } catch (err) {\n        setError(`Failed to dispatch batch ${batchIdx + 1}: ${err}`);\n        setPhase(\"scan\");\n        return;\n      }\n    }\n  }, []);\n\n  // --- Watch queue for completion ---\n  useEffect(() => {\n    if (phase !== \"generating\") return;\n    const dispatchTime = dispatchTimeRef.current;\n    if (!dispatchTime) return;\n\n    const motifItems = queue.filter(\n      (item) => item.type === \"motifVariation\" && item.queuedAt >= dispatchTime\n    );\n    if (motifItems.length === 0) return;\n\n    const running = motifItems.filter(\n      (item) => item.status === \"running\" || item.status === \"queued\"\n    );\n    const completed = motifItems.filter((item) => item.status === \"complete\");\n    const errored = motifItems.filter((item) => item.status === \"error\");\n\n    if (running.length === 0 && (completed.length > 0 || errored.length > 0)) {\n      if (errored.length > 0) {\n        setError(`${errored.length} batch(es) failed: ${errored[0].error || \"Unknown error\"}`);\n      }\n\n      const variantMap = new Map<string, string>();\n      const currentCandidates = candidatesRef.current;\n\n      for (const item of completed) {\n        if (!item.result?.description) continue;\n        try {\n          const results: MotifVariationResult[] = JSON.parse(item.result.description);\n          for (const r of results) {\n            const candidate = currentCandidates.find((c) => c.batchIndex === r.index);\n            if (candidate) {\n              variantMap.set(candidate.id, r.variant);\n            }\n          }\n        } catch {\n          // Skip unparseable results\n        }\n      }\n\n      setVariants(variantMap);\n      setPhase(variantMap.size > 0 ? \"review\" : \"empty\");\n    }\n  }, [phase, queue]);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    setPhase(\"applying\");\n\n    // Group accepted changes by entity\n    const changesByEntity = new Map<\n      string,\n      Array<{ sentenceStart: number; sentenceEnd: number; original: string; rewritten: string }>\n    >();\n\n    for (const c of candidates) {\n      if (!decisions[c.id]) continue;\n      const variant = variants.get(c.id);\n      if (!variant) continue;\n\n      if (!changesByEntity.has(c.entityId)) {\n        changesByEntity.set(c.entityId, []);\n      }\n      changesByEntity.get(c.entityId).push({\n        sentenceStart: c.sentenceStart,\n        sentenceEnd: c.sentenceEnd,\n        original: c.sentence,\n        rewritten: variant,\n      });\n    }\n\n    // Build patches by applying sentence replacements to descriptions\n    const patches: Array<{ entityId: string; description: string }> = [];\n    const updatedEntityIds: string[] = [];\n    let total = 0;\n\n    for (const [entityId, changes] of changesByEntity) {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity?.description) continue;\n\n      // Sort changes descending by position (apply from end to preserve earlier positions)\n      const sorted = [...changes].sort((a, b) => b.sentenceStart - a.sentenceStart);\n      let description = entity.description;\n      for (const change of sorted) {\n        // Verify the original sentence still exists at the expected position\n        const actual = description.slice(change.sentenceStart, change.sentenceEnd);\n        if (actual === change.original) {\n          description =\n            description.slice(0, change.sentenceStart) +\n            change.rewritten +\n            description.slice(change.sentenceEnd);\n          total++;\n        }\n      }\n\n      if (description !== entity.description) {\n        patches.push({ entityId, description });\n        updatedEntityIds.push(entityId);\n      }\n    }\n\n    if (patches.length > 0) {\n      await applyRevisionPatches(patches, \"motif-weave\");\n      await reloadEntities(updatedEntityIds);\n    }\n\n    setResultCount(total);\n    setPhase(\"done\");\n  }, [candidates, decisions, variants]);\n\n  // --- Decision helpers ---\n  const toggleDecision = useCallback((id: string) => {\n    setDecisions((prev) => ({ ...prev, [id]: !prev[id] }));\n  }, []);\n\n  const acceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) {\n        if (variants.has(c.id)) next[c.id] = true;\n      }\n      return next;\n    });\n  }, [candidates, variants]);\n\n  const rejectAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of candidates) next[c.id] = false;\n      return next;\n    });\n  }, [candidates]);\n\n  const acceptGroup = useCallback(\n    (groupCandidates: WeaveCandidate[]) => {\n      setDecisions((prev) => {\n        const next = { ...prev };\n        for (const c of groupCandidates) {\n          if (variants.has(c.id)) next[c.id] = true;\n        }\n        return next;\n      });\n    },\n    [variants]\n  );\n\n  const rejectGroup = useCallback((groupCandidates: WeaveCandidate[]) => {\n    setDecisions((prev) => {\n      const next = { ...prev };\n      for (const c of groupCandidates) next[c.id] = false;\n      return next;\n    });\n  }, []);\n\n  const toggleExpand = useCallback((key: string) => {\n    setExpandedGroups((prev) => {\n      const next = new Set(prev);\n      if (next.has(key)) next.delete(key);\n      else next.add(key);\n      return next;\n    });\n  }, []);\n\n  // --- Stats ---\n  const acceptCount = useMemo(() => Object.values(decisions).filter(Boolean).length, [decisions]);\n\n  // --- Groups (by entity) ---\n  const groups = useMemo(() => {\n    const map = new Map<\n      string,\n      { entityId: string; entityName: string; candidates: WeaveCandidate[] }\n    >();\n    for (const c of candidates) {\n      if (!map.has(c.entityId)) {\n        map.set(c.entityId, { entityId: c.entityId, entityName: c.entityName, candidates: [] });\n      }\n      map.get(c.entityId).candidates.push(c);\n// ... (truncated)", "parameters": [{"name": "{ onClose }", "type": "Readonly<{ onClose: () => void }>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/DynamicsGenerationModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function DynamicsGenerationModal({\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}) {\n  const [feedback, setFeedback] = useState(\"\");\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to bottom on new messages\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.messages?.length, run?.proposedDynamics?.length]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isReviewable = run.status === \"awaiting_review\";\n  const isFailed = run.status === \"failed\";\n\n  const handleSubmitFeedback = () => {\n    if (!feedback.trim()) return;\n    onSubmitFeedback(feedback.trim());\n    setFeedback(\"\");\n  };\n\n  const handleKeyDown = (e) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSubmitFeedback();\n    }\n  };\n\n  const displayMessages = run.messages || [];\n\n  return (\n    <div className=\"dgm-overlay\">\n      <div className=\"dgm-dialog\">\n        {/* Header */}\n        <div className=\"dgm-header\">\n          <div>\n            <h2 className=\"dgm-title\">Generate World Dynamics</h2>\n            <p className=\"dgm-subtitle\">\n              Multi-turn conversation with the LLM to synthesize dynamics from lore\n            </p>\n          </div>\n          <div className=\"dgm-header-actions\">\n            {run.totalActualCost > 0 && (\n              <span className=\"dgm-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary dgm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content area: messages + proposed dynamics */}\n        <div className=\"dgm-content\">\n          {displayMessages.map((msg, i) => (\n            <MessageBubble key={i} message={msg} />\n          ))}\n\n          {isGenerating && <div className=\"dgm-generating\">Generating...</div>}\n\n          {isFailed && <div className=\"dgm-failed\">{run.error || \"Generation failed\"}</div>}\n\n          {/* Proposed dynamics inside scrollable area */}\n          {isReviewable && run.proposedDynamics && (\n            <ProposedDynamicsList dynamics={run.proposedDynamics} />\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Footer: feedback input + actions (always visible) */}\n        <div className=\"dgm-footer\">\n          {/* Feedback input */}\n          {(isReviewable || isFailed) && (\n            <div className=\"dgm-feedback-row\">\n              <textarea\n                value={feedback}\n                onChange={(e) => setFeedback(e.target.value)}\n                onKeyDown={handleKeyDown}\n                placeholder={\n                  isFailed\n                    ? \"Provide feedback and retry...\"\n                    : 'Steer the dynamics (e.g., \"focus more on trade conflicts\", \"add era-specific tensions\")...'\n                }\n                className=\"illuminator-input dgm-feedback-input\"\n              />\n            </div>\n          )}\n\n          {/* Action buttons */}\n          <div className=\"dgm-actions\">\n            {(isReviewable || isFailed) && (\n              <button\n                onClick={handleSubmitFeedback}\n                disabled={!feedback.trim()}\n                className=\"illuminator-button illuminator-button-secondary dgm-action-btn\"\n              >\n                {isFailed ? \"Retry with Feedback\" : \"Refine\"}\n              </button>\n            )}\n            {isReviewable && (\n              <button\n                onClick={onAccept}\n                className=\"illuminator-button illuminator-button-primary dgm-action-btn\"\n              >\n                Accept Dynamics ({run.proposedDynamics?.length || 0})\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onSubmitFeedback,\n  onAccept,\n  onCancel,\n}", "type": "{ run: any; isActive: any; onSubmitFeedback: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EnrichmentQueue.jsx", "sourceCode": "export default function EnrichmentQueue({\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}) {\n  const [selectedTasks, setSelectedTasks] = useState(new Set());\n  const [expandedEntities, setExpandedEntities] = useState(new Set());\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterProminence, setFilterProminence] = useState(\"all\");\n  const [filterStatus, setFilterStatus] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    if (prominenceScale) return prominenceScale;\n    const values = tasks\n      .map((task) => task.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [prominenceScale, tasks]);\n\n  // Group tasks by entity\n  const groupedTasks = useMemo(() => {\n    const groups = new Map();\n\n    for (const task of tasks) {\n      if (!groups.has(task.entityId)) {\n        groups.set(task.entityId, {\n          entityId: task.entityId,\n          entityName: task.entityName,\n          entityKind: task.entityKind,\n          entitySubtype: task.entitySubtype,\n          prominence: task.prominence,\n          tasks: [],\n        });\n      }\n      groups.get(task.entityId).tasks.push(task);\n    }\n\n    return Array.from(groups.values());\n  }, [tasks]);\n\n  // Apply filters\n  const filteredGroups = useMemo(() => {\n    return groupedTasks.filter((group) => {\n      if (filterKind !== \"all\" && group.entityKind !== filterKind) return false;\n      if (filterProminence !== \"all\") {\n        // Filter to entities with at least the selected prominence level\n        const entityProminence = typeof group.prominence === \"number\" ? group.prominence : 0;\n        const filterThreshold = prominenceThresholdFromScale(\n          filterProminence,\n          effectiveProminenceScale\n        );\n        if (entityProminence < filterThreshold) return false;\n      }\n      if (filterStatus !== \"all\") {\n        const hasMatchingTask = group.tasks.some((t) => t.status === filterStatus);\n        if (!hasMatchingTask) return false;\n      }\n      return true;\n    });\n  }, [groupedTasks, filterKind, filterProminence, filterStatus, effectiveProminenceScale]);\n\n  // Get unique entity kinds\n  const entityKinds = useMemo(() => {\n    const kinds = new Set(tasks.map((t) => t.entityKind));\n    return Array.from(kinds);\n  }, [tasks]);\n\n  const toggleTask = (taskId) => {\n    setSelectedTasks((prev) => {\n      const next = new Set(prev);\n      if (next.has(taskId)) {\n        next.delete(taskId);\n      } else {\n        next.add(taskId);\n      }\n      return next;\n    });\n  };\n\n  const toggleEntity = (entityId) => {\n    setExpandedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const runSelected = () => {\n    onRunTasks(Array.from(selectedTasks));\n  };\n\n  const totalPending = tasks.filter((t) => t.status === \"pending\").length;\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Queue</h2>\n          <div className=\"eq-header-actions\">\n            <button\n              onClick={onRunAll}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys || totalPending === 0}\n            >\n              Run All ({totalPending})\n            </button>\n          </div>\n        </div>\n\n        {!hasRequiredKeys && (\n          <div className=\"eq-api-warning\">Set API keys in the sidebar to run enrichment tasks</div>\n        )}\n\n        {/* Filters */}\n        <div className=\"eq-filters\">\n          <div>\n            <label htmlFor=\"entity-kind\" className=\"eq-filter-label\">Entity Kind</label>\n            <select id=\"entity-kind\"\n              value={filterKind}\n              onChange={(e) => setFilterKind(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {entityKinds.map((kind) => (\n                <option key={kind} value={kind}>\n                  {kind}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"prominence\" className=\"eq-filter-label\">Prominence</label>\n            <select id=\"prominence\"\n              value={filterProminence}\n              onChange={(e) => setFilterProminence(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              {PROMINENCE_LEVELS.map((level) => (\n                <option key={level} value={level}>\n                  {level}+\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"status\" className=\"eq-filter-label\">Status</label>\n            <select id=\"status\"\n              value={filterStatus}\n              onChange={(e) => setFilterStatus(e.target.value)}\n              className=\"illuminator-select eq-filter-select\"\n            >\n              <option value=\"all\">All</option>\n              <option value=\"pending\">Pending</option>\n              <option value=\"complete\">Complete</option>\n              <option value=\"error\">Error</option>\n            </select>\n          </div>\n\n          <div className=\"eq-filter-summary\">\n            <span className=\"eq-filter-summary-text\">\n              {filteredGroups.length} entities, {tasks.length} tasks\n            </span>\n          </div>\n        </div>\n\n        {/* Task groups */}\n        <div>\n          {filteredGroups.map((group) => (\n            <EntityTaskGroup\n              key={group.entityId}\n              {...group}\n              selectedTasks={selectedTasks}\n              onToggleTask={toggleTask}\n              onRunTask={(taskId) => onRunTasks([taskId])}\n              expanded={expandedEntities.has(group.entityId)}\n              onToggleExpand={() => toggleEntity(group.entityId)}\n              prominenceScale={effectiveProminenceScale}\n            />\n          ))}\n\n          {filteredGroups.length === 0 && (\n            <div className=\"eq-empty\">No tasks match current filters</div>\n          )}\n        </div>\n      </div>\n\n      {/* Selection actions */}\n      {selectedTasks.size > 0 && (\n        <div className=\"eq-selection-bar\">\n          <span className=\"eq-selection-count\">\n            {selectedTasks.size} task{selectedTasks.size !== 1 ? \"s\" : \"\"} selected\n          </span>\n          <div className=\"eq-selection-actions\">\n            <button\n              onClick={() => setSelectedTasks(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button\n              onClick={runSelected}\n              className=\"illuminator-button\"\n              disabled={!hasRequiredKeys}\n            >\n              Run Selected\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  tasks,\n  onRunTasks,\n  onRunAll,\n  worldSchema: _worldSchema,\n  hasRequiredKeys,\n  prominenceScale,\n}", "type": "{ tasks: any; onRunTasks: any; onRunAll: any; worldSchema: any; hasRequiredKeys: any; prominenceScale: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityBrowser.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityBrowser.jsx", "sourceCode": "export default function EntityBrowser({\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}) {\n  const navEntities = useEntityNavList();\n  const { handleAssignImage, handleDeleteEntity } = useEntityCrud();\n  const { historianConfigured } = useHistorianActions();\n  const { openCreateEntity, openEditEntity, openImageSettings } =\n    useIlluminatorModals();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [searchOpen, setSearchOpen] = useState(false);\n  const [searchText, setSearchText] = useState(false);\n  const searchInputRef = useRef(null);\n  const [filters, setFilters] = useState({\n    kind: \"all\",\n    prominence: \"all\",\n    status: \"all\",\n    culture: \"all\",\n    chronicleImage: \"all\",\n  });\n  const prominenceScale = useProminenceScale();\n  const [hideCompleted, setHideCompleted] = useState(false);\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [selectedEntityId, setSelectedEntityId] = useState(null);\n  const [imagePickerEntity, setImagePickerEntity] = useState(null);\n  const [showMotifWeaver, setShowMotifWeaver] = useState(false);\n  // Get unique values for filters\n  const filterOptions = useMemo(() => {\n    const kinds = new Set();\n    const cultures = new Set();\n\n    for (const entity of navEntities) {\n      kinds.add(entity.kind);\n      if (entity.culture) cultures.add(entity.culture);\n    }\n\n    return {\n      kinds: Array.from(kinds).sort(),\n      cultures: Array.from(cultures).sort(),\n    };\n  }, [navEntities]);\n\n  // Entity search \u2014 partial match on name, aliases, and optionally summary text\n  const searchResults = useMemo(() => {\n    const q = searchQuery.trim().toLowerCase();\n    if (!q || q.length < 2) return [];\n    const results = [];\n    for (const entity of navEntities) {\n      const matches = [];\n      // Name match\n      const nameIdx = entity.name.toLowerCase().indexOf(q);\n      if (nameIdx !== -1) {\n        matches.push({ field: \"name\", value: entity.name, matchIndex: nameIdx });\n      }\n      // Alias matches\n      for (const alias of entity.aliases) {\n        if (typeof alias !== \"string\") continue;\n        const aliasIdx = alias.toLowerCase().indexOf(q);\n        if (aliasIdx !== -1) {\n          matches.push({ field: \"alias\", value: alias, matchIndex: aliasIdx });\n        }\n      }\n      // Slug alias matches\n      for (const slug of entity.slugAliases) {\n        if (typeof slug !== \"string\") continue;\n        const slugIdx = slug.toLowerCase().indexOf(q);\n        if (slugIdx !== -1) {\n          matches.push({ field: \"slug alias\", value: slug, matchIndex: slugIdx });\n        }\n      }\n      // Summary text matches (only when searchText enabled)\n      if (searchText && entity.summary) {\n        const sumIdx = entity.summary.toLowerCase().indexOf(q);\n        if (sumIdx !== -1) {\n          matches.push({ field: \"summary\", value: entity.summary, matchIndex: sumIdx });\n        }\n      }\n      if (matches.length > 0) {\n        results.push({ entity, matches });\n      }\n    }\n    // Sort: name matches first, then by name alphabetically\n    results.sort((a, b) => {\n      const aHasName = a.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      const bHasName = b.matches.some((m) => m.field === \"name\") ? 0 : 1;\n      if (aHasName !== bHasName) return aHasName - bHasName;\n      return a.entity.name.localeCompare(b.entity.name);\n    });\n    return results;\n  }, [navEntities, searchQuery, searchText]);\n\n  const handleSearchSelect = useCallback((entityId) => {\n    setSelectedEntityId(entityId);\n    setSearchOpen(false);\n    setSearchQuery(\"\");\n  }, []);\n\n  // Get enrichment status for a nav item\n  const getStatus = useCallback(\n    (nav, type) => {\n      // Check queue first\n      const queueItem = queue.find((item) => item.entityId === nav.id && item.type === type);\n      if (queueItem) {\n        return queueItem.status;\n      }\n\n      // Check nav item flags\n      if (type === \"description\" && nav.hasDescription) return \"complete\";\n      if (type === \"visualThesis\" && nav.hasVisualThesis) return \"complete\";\n      if (type === \"image\" && nav.imageId) return \"complete\";\n\n      return \"missing\";\n    },\n    [queue]\n  );\n\n  // Filter entities via nav items\n  const filteredNavItems = useMemo(() => {\n    return navEntities.filter((nav) => {\n      if (filters.kind !== \"all\" && nav.kind !== filters.kind) return false;\n      if (\n        filters.prominence !== \"all\" &&\n        prominenceLabelFromScale(nav.prominence, prominenceScale) !== filters.prominence\n      ) {\n        return false;\n      }\n      if (filters.culture !== \"all\" && nav.culture !== filters.culture) return false;\n\n      const descStatus = getStatus(nav, \"description\");\n      const imgStatus = getStatus(nav, \"image\");\n\n      // Hide completed filter\n      if (hideCompleted && descStatus === \"complete\" && imgStatus === \"complete\") {\n        return false;\n      }\n\n      if (filters.status !== \"all\") {\n        if (filters.status === \"missing\" && descStatus !== \"missing\" && imgStatus !== \"missing\") {\n          return false;\n        }\n        if (filters.status === \"complete\" && descStatus !== \"complete\") {\n          return false;\n        }\n        if (filters.status === \"queued\" && descStatus !== \"queued\" && imgStatus !== \"queued\") {\n          return false;\n        }\n        if (filters.status === \"running\" && descStatus !== \"running\" && imgStatus !== \"running\") {\n          return false;\n        }\n        if (filters.status === \"error\" && descStatus !== \"error\" && imgStatus !== \"error\") {\n          return false;\n        }\n      }\n\n      // Chronicle image filter\n      if (filters.chronicleImage !== \"all\") {\n        if (filters.chronicleImage === \"none\" && nav.backrefCount > 0) return false;\n        if (filters.chronicleImage === \"unconfigured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount === 0) return false;\n        }\n        if (filters.chronicleImage === \"configured\") {\n          if (nav.backrefCount === 0) return false;\n          if (nav.unconfiguredBackrefCount > 0) return false;\n        }\n      }\n\n      return true;\n    });\n  }, [navEntities, filters, hideCompleted, getStatus, prominenceScale]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((entityId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredNavItems.map((e) => e.id)));\n  }, [filteredNavItems]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  // Queue single item \u2014 load full entity from store for prompt building\n  const queueItem = useCallback(\n    async (entityId, type) => {\n      const entity = await useEntityStore.getState().loadEntity(entityId);\n      if (!entity) return;\n      const prompt = buildPrompt(entity, type === \"visualThesis\" ? \"description\" : type);\n      const visualConfig =\n        (type === \"description\" || type === \"visualThesis\") && getVisualConfig\n          ? getVisualConfig(entity)\n          : {};\n      const imageOverrides =\n        type === \"image\"\n          ? { imageSize: imageGenSettings.imageSize, imageQuality: imageGenSettings.imageQuality }\n          : {};\n      getEnqueue()([{ entity, type, prompt, ...visualConfig, ...imageOverrides }]);\n    },\n    [buildPrompt, getVisualConfig, imageGenSettings.imageSize, imageGenSettings.imageQuality]\n  );\n\n  // Cancel single item\n  const cancelItem = useCallback(\n    (entityId, type) => {\n      const queueItem = queue.find((item) => item.entityId === entityId && item.type === type);\n      if (queueItem) {\n        getCancel()(queueItem.id);\n      }\n    },\n    [queue]\n  );\n\n  // Queue all missing descriptions for selected \u2014 filter on nav items, load full for prompt\n  const queueSelectedDescriptions = useCallback(async () => {\n    const missingIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (nav && getStatus(nav, \"description\") === \"missing\") {\n        missingIds.push(entityId);\n      }\n    }\n    if (missingIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(missingIds);\n    const items = fullEntities.map((entity) => {\n      const visualConfig = getVisualConfig ? getVisualConfig(entity) : {};\n      return {\n        entity,\n        type: \"description\",\n        prompt: buildPrompt(entity, \"description\"),\n        ...visualConfig,\n      };\n    });\n    if (items.length > 0) getEnqueue()(items);\n  }, [selectedIds, navEntities, getStatus, buildPrompt, getVisualConfig]);\n\n  // Queue all missing images for selected\n  const queueSelectedImages = useCallback(async () => {\n    const eligibleIds = [];\n    for (const entityId of selectedIds) {\n      const nav = navEntities.find((e) => e.id === entityId);\n      if (\n        nav &&\n        prominenceAtLeast(nav.prominence, config.minProminenceForImage, prominenceScale) &&\n        getStatus(nav, \"image\") === \"missing\" &&\n        (!config.requireDescription || nav.hasDescription)\n      ) {\n        eligibleIds.push(entityId);\n      }\n    }\n    if (eligibleIds.length === 0) return;\n    const fullEntities = await useEntityStore.getState().loadEntities(eligibleIds);\n    const items = fullEntities.map((entity) => ({\n      entity,\n      type: \"image\",\n      prompt: buildPrompt(entity, \"image\"),\n      imageSize: imageGenSettings.imageSize,\n      imageQuality: imageGenSettings.imageQuality,\n    }));\n    if (items.length > 0) getEnqueue()(items);\n  }, [\n    selectedIds,\n    navEntities,\n    getStatus,\n    buildPrompt,\n    config.minProminenceForImage,\n    config.requireDescription,\n    imageGenSettings.imageSize,\n    imageGenSettings.imageQuality,\n    prominenceScale,\n  ]);\n\n  // Regenerate all descriptions for selected\n  const regenSelectedDescriptions = useCallback(async () => {\n    const completeIds = [];\n// ... (truncated)", "parameters": [{"name": "{\n  worldSchema: _worldSchema,\n  config,\n  onConfigChange,\n  buildPrompt,\n  getVisualConfig,\n  styleLibrary,\n  imageGenSettings,\n  onStartRevision,\n  isRevising,\n  onBulkHistorianReview,\n  onBulkHistorianEdition,\n  onBulkHistorianClear,\n  isBulkHistorianActive,\n  onNavigateToTab,\n}", "type": "{ worldSchema: any; config: any; onConfigChange: any; buildPrompt: any; getVisualConfig: any; styleLibrary: any; imageGenSettings: any; onStartRevision: any; isRevising: any; onBulkHistorianReview: any; onBulkHistorianEdition: any; onBulkHistorianClear: any; isBulkHistorianActive: any; onNavigateToTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityCoveragePanel.jsx", "sourceCode": "export default function EntityCoveragePanel({\n  simulationRunId\n}) {\n  // Events and relationships are always in memory (simple store pattern, no nav/detail split)\n  const narrativeEvents = useNarrativeEvents();\n  const relationships = useRelationships();\n\n  // Full entity + chronicle data loaded on demand when user clicks \"Calculate\"\n  const [analysisData, setAnalysisData] = useState(null);\n  const [calculating, setCalculating] = useState(false);\n  const [expandedSections, setExpandedSections] = useState(new Set());\n\n  // Reset when simulation run changes\n  useEffect(() => {\n    setAnalysisData(null);\n  }, [simulationRunId]);\n  const handleCalculate = useCallback(async () => {\n    if (!simulationRunId) return;\n    setCalculating(true);\n    try {\n      const [fullEntities, chronicles] = await Promise.all([getEntitiesForRun(simulationRunId), getChroniclesForSimulation(simulationRunId)]);\n      const safeEvents = narrativeEvents || [];\n      const safeRelationships = relationships || [];\n      const analysis = computeCoreAnalysis(fullEntities, chronicles, safeEvents, safeRelationships);\n      setAnalysisData({\n        fullEntities,\n        chronicles,\n        analysis,\n        events: safeEvents,\n        relationships: safeRelationships\n      });\n    } catch (err) {\n      console.error(\"[EntityCoverage] Failed to calculate:\", err);\n    } finally {\n      setCalculating(false);\n    }\n  }, [simulationRunId, narrativeEvents, relationships]);\n  const toggleSection = useCallback(sectionId => {\n    setExpandedSections(prev => {\n      const next = new Set(prev);\n      if (next.has(sectionId)) next.delete(sectionId);else next.add(sectionId);\n      return next;\n    });\n  }, []);\n  if (!simulationRunId) return null;\n\n  // Before calculation \u2014 show button\n  if (!analysisData) {\n    return <div className=\"ecp-pre-calc\">\n        <div className=\"illuminator-card\">\n          <div className=\"ecp-pre-calc-inner\">\n            <div className=\"ecp-pre-calc-header\">\n              <span className=\"ecp-pre-calc-title\">Entity Coverage Analysis</span>\n            </div>\n            <p className=\"ecp-pre-calc-desc\">\n              Analyzes coverage gaps across entities, chronicles, events, and relationships. Loads\n              full entity data on demand.\n            </p>\n            <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-btn-pad-sm\">\n              {calculating ? \"Calculating...\" : \"Calculate Statistics\"}\n            </button>\n          </div>\n        </div>\n      </div>;\n  }\n  const {\n    fullEntities,\n    analysis,\n    events: safeEvents,\n    relationships: safeRelationships\n  } = analysisData;\n\n  // Compute underutil counts for collapsed section headers\n  const sectionUnderutilCounts = {};\n  for (const sectionId of SECTION_IDS) {\n    if (!expandedSections.has(sectionId)) {\n      switch (sectionId) {\n        case \"suggestions\":\n          sectionUnderutilCounts[sectionId] = (() => {\n            const groupsWithUncovered = new Set();\n            for (const e of safeEvents) {\n              if ((analysis.eventCoverage.get(e.id) ?? 0) <= 0) {\n                groupsWithUncovered.add(eventGroupKey(e));\n              }\n            }\n            return groupsWithUncovered.size;\n          })();\n          break;\n        case \"backrefs\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            const expected = expectedForProminence(e.prominence);\n            if (expected === 0) return false;\n            const count = e.enrichment?.chronicleBackrefs?.length ?? 0;\n            return count / expected < 1;\n          }).length;\n          break;\n        case \"history\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            return (e.enrichment?.chronicleBackrefs?.length ?? 0) > 0 && (e.enrichment?.descriptionHistory?.length ?? 0) === 0;\n          }).length;\n          break;\n        case \"culture\":\n          sectionUnderutilCounts[sectionId] = [...(analysis.cultureEntities?.entries() || [])].filter(([, data]) => {\n            if (data.count < 3) return false;\n            let appeared = 0;\n            for (const id of data.entityIds) {\n              if (analysis.entityUsage.has(id)) appeared++;\n            }\n            return appeared / data.count < 0.3;\n          }).length;\n          break;\n        case \"events\":\n          sectionUnderutilCounts[sectionId] = safeEvents.filter(e => {\n            return e.significance >= 0.7 && (e.participantEffects?.length ?? 0) >= 3 && (analysis.eventCoverage.get(e.id) ?? 0) <= 0;\n          }).length;\n          break;\n        case \"potential\":\n          sectionUnderutilCounts[sectionId] = null; // expensive, skip for collapsed\n          break;\n        case \"eras\":\n          {\n            const allEraIds = new Set([...analysis.eraChronicles.keys(), ...analysis.eraEntityCounts.keys(), ...analysis.eraEventCounts.keys()]);\n            sectionUnderutilCounts[sectionId] = [...allEraIds].filter(eraId => {\n              return (analysis.eraChronicles.get(eraId)?.total ?? 0) <= 0 && ((analysis.eraEntityCounts.get(eraId) || 0) > 0 || (analysis.eraEventCounts.get(eraId) || 0) > 0);\n            }).length;\n            break;\n          }\n        case \"integration\":\n          sectionUnderutilCounts[sectionId] = fullEntities.filter(e => {\n            if (e.kind === \"era\") return false;\n            if ((Number(e.prominence) || 0) < 2) return false;\n            let gaps = 0;\n            if (!e.description) gaps++;\n            if ((e.enrichment?.chronicleBackrefs?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.descriptionHistory?.length ?? 0) <= 0) gaps++;\n            if ((e.enrichment?.historianNotes?.length ?? 0) <= 0) gaps++;\n            if (!e.enrichment?.image?.imageId) gaps++;\n            return gaps >= 3;\n          }).length;\n          break;\n      }\n    }\n  }\n  const sectionProps = {\n    suggestions: {\n      Component: SuggestionsSection,\n      props: {\n        events: safeEvents,\n        entities: fullEntities,\n        eventCoverage: analysis.eventCoverage,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    backrefs: {\n      Component: BackrefsSection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    history: {\n      Component: HistorySection,\n      props: {\n        entities: fullEntities\n      }\n    },\n    culture: {\n      Component: CultureSection,\n      props: {\n        entities: fullEntities,\n        cultureRoles: analysis.cultureRoles,\n        cultureEntities: analysis.cultureEntities,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    events: {\n      Component: EventsSection,\n      props: {\n        events: safeEvents,\n        eventCoverage: analysis.eventCoverage\n      }\n    },\n    potential: {\n      Component: PotentialSection,\n      props: {\n        entities: fullEntities,\n        narrativeEvents: safeEvents,\n        relationships: safeRelationships,\n        entityUsage: analysis.entityUsage\n      }\n    },\n    eras: {\n      Component: ErasSection,\n      props: {\n        entities: fullEntities,\n        events: safeEvents,\n        eraChronicles: analysis.eraChronicles,\n        eraEntityCounts: analysis.eraEntityCounts,\n        eraEventCounts: analysis.eraEventCounts\n      }\n    },\n    integration: {\n      Component: IntegrationSection,\n      props: {\n        entities: fullEntities,\n        entityBackportedCount: analysis.entityBackportedCount\n      }\n    }\n  };\n  return <div className=\"ecp-wrapper\">\n      <div className=\"illuminator-card ecp-header-card\">\n        <div className=\"ecp-header-bar\">\n          <span className=\"ecp-header-title\">Entity Coverage Analysis</span>\n          <span className=\"ecp-header-stats\">\n            {analysis.nonEraEntities.length} entities, {analysis.activeChronicles.length}{\" \"}\n            chronicles, {safeEvents.length} events\n          </span>\n          <button onClick={() => void handleCalculate()} disabled={calculating} className=\"illuminator-button illuminator-button-secondary ecp-recalc-btn\" title=\"Reload data from database and recalculate all statistics\">\n            {calculating ? \"Recalculating...\" : \"Recalculate\"}\n          </button>\n        </div>\n      </div>\n\n      <div className=\"ec-grid\">\n        {SECTION_IDS.map(sectionId => {\n        const isExpanded = expandedSections.has(sectionId);\n        const underutil = sectionUnderutilCounts[sectionId];\n        const {\n          Component,\n          props\n        } = sectionProps[sectionId];\n        return <div key={sectionId} className=\"illuminator-card ec-grid-cell\">\n              <SectionHeader sectionId={sectionId} expanded={isExpanded} onToggle={() => toggleSection(sectionId)} label={SECTION_LABELS[sectionId]} description={SECTION_DESCRIPTIONS[sectionId]} underutilCount={underutil} />\n              {isExpanded && <Component {...props} expanded={true} />}\n            </div>;\n      })}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  simulationRunId\n}", "type": "{ simulationRunId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityDetailView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityDetailView.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// EntityDetailView\n// ---------------------------------------------------------------------------\n\nexport default function EntityDetailView({ entity, entities, onBack }: Readonly<EntityDetailViewProps>) {\n  const prominenceScale = useProminenceScale();\n  const queue = useEnrichmentQueueStore((s) => s.queue);\n  const {\n    handleUpdateBackrefs,\n    handleUndoDescription,\n    handleUpdateAliases,\n    handleUpdateDescription,\n    handleUpdateSummary,\n    handleClearNotes,\n    handleRestoreDescription,\n  } = useEntityCrud();\n  const {\n    historianConfigured,\n    isHistorianEditionActive,\n    isHistorianActive,\n    handleHistorianEdition,\n    handleHistorianReview,\n    handleUpdateHistorianNote,\n    editionPreview,\n    handleEditionPreviewProceed,\n    handleEditionPreviewCancel,\n  } = useHistorianActions();\n  const { openRename, openPatchEvents } = useIlluminatorModals();\n\n  const enrichment = entity.enrichment;\n  const textEnrichment = enrichment?.text;\n\n  // Inline editing state\n  const [editingSummary, setEditingSummary] = useState(false);\n  const [summaryDraft, setSummaryDraft] = useState(\"\");\n  const [editingDescription, setEditingDescription] = useState(false);\n  const [descriptionDraft, setDescriptionDraft] = useState(\"\");\n\n  const startEditSummary = useCallback(() => {\n    setSummaryDraft(entity.summary || \"\");\n    setEditingSummary(true);\n  }, [entity.summary]);\n\n  const saveSummary = useCallback(() => {\n    const trimmed = summaryDraft.trim();\n    if (trimmed && trimmed !== entity.summary) {\n      void handleUpdateSummary(entity.id, trimmed);\n    }\n    setEditingSummary(false);\n  }, [handleUpdateSummary, summaryDraft, entity.summary, entity.id]);\n\n  const cancelSummary = useCallback(() => {\n    setEditingSummary(false);\n    setSummaryDraft(\"\");\n  }, []);\n\n  const startEditDescription = useCallback(() => {\n    setDescriptionDraft(entity.description || \"\");\n    setEditingDescription(true);\n  }, [entity.description]);\n\n  const saveDescription = useCallback(() => {\n    const trimmed = descriptionDraft.trim();\n    if (trimmed && trimmed !== entity.description) {\n      void handleUpdateDescription(entity.id, trimmed);\n    }\n    setEditingDescription(false);\n  }, [handleUpdateDescription, descriptionDraft, entity.description, entity.id]);\n\n  const cancelDescription = useCallback(() => {\n    setEditingDescription(false);\n    setDescriptionDraft(\"\");\n  }, []);\n\n  // Chain debug (narrative -> thesis -> traits)\n  const chainDebug: DescriptionChainDebug | undefined = textEnrichment?.chainDebug;\n\n  // Legacy single debug\n  let legacyDebug: NetworkDebugInfo | undefined = textEnrichment?.debug;\n  if (!legacyDebug && !chainDebug) {\n    const descriptionQueueItem = queue.find(\n      (item) => item.entityId === entity.id && item.type === \"description\" && item.debug\n    );\n    legacyDebug = descriptionQueueItem?.debug;\n  }\n\n  // Escape key goes back (unless editing inline)\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === \"Escape\" && !editingSummary && !editingDescription) onBack();\n    },\n    [onBack, editingSummary, editingDescription]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Description history\n  const historyLen = enrichment?.descriptionHistory?.length || 0;\n  const lastEntry = historyLen > 0 ? enrichment.descriptionHistory[historyLen - 1] : null;\n\n  return (\n    <>\n      <div className=\"edv\">\n        {/* Header bar */}\n        <div className=\"edv-header\">\n          <button onClick={onBack} className=\"edv-back-btn\">\n            \u2190 Back\n          </button>\n          <div className=\"edv-header-info\">\n            <div className=\"edv-entity-name\">{entity.name}</div>\n            <div className=\"edv-entity-meta\">\n              {entity.kind}/{entity.subtype} \u00b7{\" \"}\n              {prominenceLabelFromScale(entity.prominence, prominenceScale)}\n              {entity.culture && ` \u00b7 ${entity.culture}`}\n            </div>\n          </div>\n          <div className=\"edv-esc-hint\">Esc to go back</div>\n        </div>\n\n        {/* Two-column body */}\n        <div className=\"edv-body\">\n          {/* Main content */}\n          <div className=\"edv-main\">\n            {/* Summary */}\n            {(entity.summary || handleUpdateSummary) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label\">\n                  Summary\n                  {handleUpdateSummary && !editingSummary && (\n                    <button\n                      onClick={startEditSummary}\n                      title=\"Edit summary\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                </div>\n                {editingSummary ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={summaryDraft}\n                    onChange={(e) => setSummaryDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveSummary();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelSummary();\n                      }\n                    }}\n                    onBlur={saveSummary}\n                    className=\"edv-summary-textarea\"\n                  />\n                ) : (\n                  <p className=\"edv-summary-text\">\n                    {entity.summary || <span className=\"edv-placeholder\">No summary</span>}\n                  </p>\n                )}\n              </div>\n            )}\n\n            {/* Visual Thesis */}\n            {textEnrichment?.visualThesis && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-visual-thesis\">\n                  Visual Thesis\n                </div>\n                <p className=\"edv-visual-thesis\">{textEnrichment.visualThesis}</p>\n              </div>\n            )}\n\n            {/* Full Description */}\n            {(entity.description || handleUpdateDescription) && (\n              <div className=\"edv-section\">\n                <div className=\"edv-section-label edv-section-label-wrap\">\n                  Full Description\n                  {historyLen > 0 && (\n                    <span className=\"edv-version-hint\">\n                      v{historyLen + 1} ({historyLen} previous)\n                    </span>\n                  )}\n                  {historyLen > 0 && handleUndoDescription && (\n                    <button\n                      onClick={() => void handleUndoDescription(entity.id)}\n                      title={`Revert to previous version (from ${lastEntry?.source || \"unknown\"}, ${lastEntry?.replacedAt ? new Date(lastEntry.replacedAt).toLocaleDateString() : \"unknown\"})`}\n                      className=\"edv-inline-btn\"\n                    >\n                      \u21a9 Undo\n                    </button>\n                  )}\n                  {handleUpdateDescription && !editingDescription && (\n                    <button\n                      onClick={startEditDescription}\n                      title=\"Edit description\"\n                      className=\"edv-inline-btn\"\n                    >\n                      Edit\n                    </button>\n                  )}\n                  <button\n                    onClick={() => openRename(entity.id)}\n                    title=\"Rename this entity with full propagation across all references\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Rename\n                  </button>\n                  <button\n                    onClick={() => openPatchEvents(entity.id)}\n                    title=\"Repair stale names in narrative event history for this entity\"\n                    className=\"edv-inline-btn\"\n                  >\n                    Patch Events\n                  </button>\n                </div>\n                {historianConfigured && (\n                  <>\n                    <div className=\"edv-section-label\">\n                      Historian\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone)}\n                        disabled={isHistorianEditionActive}\n                        label=\"Copy Edit\"\n                        hasNotes={false}\n                      />\n                      {enrichment?.descriptionHistory?.some(\n                        (h: { source?: string }) => h.source === \"historian-edition\"\n                      ) && (\n                        <HistorianToneSelector\n                          onSelect={(tone: string) => void handleHistorianEdition(entity.id, tone, true)}\n                          disabled={isHistorianEditionActive}\n                          label=\"Re-Edit\"\n                          hasNotes={false}\n                        />\n                      )}\n                      <HistorianToneSelector\n                        onSelect={(tone: string) => void handleHistorianReview(entity.id, tone)}\n                        disabled={isHistorianActive}\n                        label=\"Annotate\"\n                        hasNotes={\n                          enrichment?.historianNotes && enrichment.historianNotes.length > 0\n                        }\n                      />\n                      {handleClearNotes &&\n                        enrichment?.historianNotes &&\n                        enrichment.historianNotes.length > 0 && (\n                          <button\n                            onClick={() => void handleClearNotes(entity.id)}\n                            title=\"Remove all annotations from this entity\"\n                            className=\"edv-inline-btn-ghost\"\n                          >\n                            Clear Notes\n                          </button>\n                        )}\n                    </div>\n                    {enrichment?.descriptionHistory?.some(\n                      (h: { source?: string }) =>\n                        h.source === \"historian-edition\" || h.source === \"legacy-copy-edit\"\n                    ) &&\n                      entity.description && (\n                        <HistorianEditionComparison\n                          entityId={entity.id}\n                          currentDescription={entity.description}\n                          descriptionHistory={enrichment.descriptionHistory}\n                          historianNotes={enrichment.historianNotes}\n                          onRestoreVersion={(entityId, historyIndex) => void handleRestoreDescription(entityId, historyIndex)}\n                        />\n                      )}\n                  </>\n                )}\n                {editingDescription ? (\n                  <textarea\n                    // eslint-disable-next-line jsx-a11y/no-autofocus\n                    autoFocus\n                    value={descriptionDraft}\n                    onChange={(e) => setDescriptionDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n                        e.preventDefault();\n                        saveDescription();\n                      }\n                      if (e.key === \"Escape\") {\n                        e.stopPropagation();\n                        cancelDescription();\n                      }\n                    }}\n                    onBlur={saveDescription}\n                    className=\"edv-desc-textarea\"\n                  />\n                ) : (\n                  <>\n                    {entity.description ? (\n                      <div className=\"edv-description entity-description-md\">\n                        <ReactMarkdown\n// ... (truncated)", "parameters": [{"name": "{ entity, entities, onBack }", "type": "Readonly<EntityDetailViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityGuidanceEditor.jsx", "sourceCode": "export default function EntityGuidanceEditor({\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}) {\n  const entities = useEntityNavList();\n  const entityNavItems = useEntityNavItems();\n  const [selectedType, setSelectedType] = useState(\"description\");\n  const [selectedKind, setSelectedKind] = useState(\"npc\");\n  const [selectedEntityId, setSelectedEntityId] = useState(\"\");\n  const [showVisualSteps, setShowVisualSteps] = useState(false);\n  const [selectedFullEntity, setSelectedFullEntity] = useState(null);\n\n  // Use external entity guidance or default\n  const entityGuidance = useMemo(\n    () => externalEntityGuidance || createDefaultEntityGuidance(),\n    [externalEntityGuidance]\n  );\n\n  // Empty culture identities for preview (editing happens in VisualIdentityPanel)\n  const cultureIdentities = useMemo(() => createDefaultCultureIdentities(), []);\n\n  // Get entity kinds from schema\n  const entityKinds = useMemo(() => {\n    return worldSchema?.entityKinds || [];\n  }, [worldSchema]);\n\n  // Auto-select first kind if none selected\n  useMemo(() => {\n    if (!selectedKind && entityKinds.length > 0) {\n      setSelectedKind(entityKinds[0].kind);\n    }\n  }, [selectedKind, entityKinds]);\n\n  const prominenceScale = useProminenceScale();\n  const notableThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"recognized\", prominenceScale),\n    [prominenceScale]\n  );\n  const renownedThreshold = useMemo(\n    () => prominenceThresholdFromScale(\"renowned\", prominenceScale),\n    [prominenceScale]\n  );\n  const relationshipsByEntity = useRelationshipsByEntity();\n  const prominentByCulture = useMemo(() => {\n    const map = new Map();\n    for (const entity of entities) {\n      if (!entity.culture) continue;\n      if (entity.prominence < notableThreshold) continue;\n      const entry = { id: entity.id, name: entity.name };\n      const existing = map.get(entity.culture);\n      if (existing) {\n        existing.push(entry);\n      } else {\n        map.set(entity.culture, [entry]);\n      }\n    }\n    return map;\n  }, [entities, notableThreshold]);\n\n  // Get example entities for preview, filtered by selected kind\n  const exampleEntities = useMemo(() => {\n    if (!entities || entities.length === 0) return [];\n    return entities.filter((e) => e.kind === selectedKind).slice(0, 10);\n  }, [entities, selectedKind]);\n\n  const selectedNavEntity = useMemo(() => {\n    if (!selectedEntityId) return exampleEntities[0] || null;\n    return entities.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, entities, exampleEntities]);\n\n  // Load full entity for preview (needs description, tags, visualThesis, etc.)\n  useEffect(() => {\n    const entityId = selectedNavEntity?.id;\n    if (entityId) {\n      useEntityStore.getState().loadEntity(entityId).then(setSelectedFullEntity);\n    } else {\n      setSelectedFullEntity(null);\n    }\n  }, [selectedNavEntity?.id]);\n\n  // Use full entity for context building, fall back to nav entity for display\n  const selectedEntity = selectedFullEntity || selectedNavEntity;\n\n  const selectedRelationships = useMemo(() => {\n    if (!selectedEntity) return [];\n    return resolveRelationships(selectedEntity, entityNavItems, relationshipsByEntity);\n  }, [selectedEntity, entityNavItems, relationshipsByEntity]);\n\n  // Get current guidance for selected kind\n  const currentGuidance = useMemo(() => {\n    return entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n  }, [entityGuidance, selectedKind]);\n\n  // Build live preview\n  const preview = useMemo(() => {\n    // Derive flat values from structured fields for entity description prompts\n    const wc = {\n      name: worldContext?.name || \"[World Name]\",\n      description: worldContext?.description || \"[World description not set]\",\n      toneFragments: worldContext?.toneFragments || { core: \"\" },\n      canonFactsWithMetadata: worldContext?.canonFactsWithMetadata || [],\n    };\n\n    const entityContext = buildEntityContext(\n      selectedEntity,\n      prominentByCulture,\n      entityNavItems,\n      relationshipsByEntity,\n      simulationMetadata,\n      renownedThreshold\n    );\n\n    if (selectedType === \"description\") {\n      return buildDescriptionPromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext\n      );\n    } else {\n      return buildImagePromptFromGuidance(\n        entityGuidance,\n        cultureIdentities,\n        wc,\n        entityContext,\n        {} // No style info for preview\n      );\n    }\n  }, [\n    entityGuidance,\n    cultureIdentities,\n    selectedType,\n    selectedKind,\n    selectedEntity,\n    worldContext,\n    prominentByCulture,\n    entityNavItems,\n    relationshipsByEntity,\n    simulationMetadata,\n    renownedThreshold,\n  ]);\n\n  // Handle guidance changes\n  const handleSectionChange = useCallback(\n    (sectionKey, value) => {\n      if (!onEntityGuidanceChange) return;\n\n      // Get current guidance or create default\n      const currentKindGuidance =\n        entityGuidance[selectedKind] || getDefaultKindGuidance(selectedKind);\n\n      // Update the specific field (handles nested paths like 'visualThesis.domain')\n      const updatedKindGuidance = setNestedValue(currentKindGuidance, sectionKey, value);\n\n      // Update the full entity guidance\n      const newEntityGuidance = {\n        ...entityGuidance,\n        [selectedKind]: updatedKindGuidance,\n      };\n\n      onEntityGuidanceChange(newEntityGuidance);\n    },\n    [entityGuidance, selectedKind, onEntityGuidanceChange]\n  );\n\n  // Reset when switching kinds - use entity of that kind for preview\n  const handleKindSelect = useCallback((kind) => {\n    setSelectedKind(kind);\n    setSelectedEntityId(\"\"); // Reset to first entity of new kind\n  }, []);\n\n  return (\n    <div className=\"illuminator-template-editor\">\n      {/* Header Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Entity Guidance</h2>\n          <span className=\"illuminator-card-subtitle\">\n            Configure per-kind instructions for entity descriptions and images\n          </span>\n        </div>\n\n        {/* Task Type Tabs */}\n        <div className=\"illuminator-prompt-tabs\">\n          {TASK_TYPES.map((type) => (\n            <button\n              key={type.id}\n              onClick={() => setSelectedType(type.id)}\n              className={`illuminator-prompt-tab ${selectedType === type.id ? \"active\" : \"\"}`}\n            >\n              <span>{type.icon}</span>\n              <span>{type.label}</span>\n            </button>\n          ))}\n        </div>\n\n        {/* Kind Selector */}\n        {entityKinds.length > 0 && (\n          <div className=\"illuminator-template-kind-section\">\n            <div className=\"illuminator-template-kind-header\">\n              <span className=\"illuminator-label\">Entity Kind</span>\n            </div>\n            <KindSelector\n              kinds={entityKinds}\n              selectedKind={selectedKind}\n              onSelectKind={handleKindSelect}\n            />\n          </div>\n        )}\n      </div>\n\n      {/* Editor Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            {selectedKind} {selectedType === \"description\" ? \"Description\" : \"Image\"} Settings\n          </h2>\n        </div>\n\n        {selectedType === \"description\" ? (\n          // Description editing - Focus + Relationship Guidance + Prose Hint\n          <div className=\"illuminator-template-sections\">\n            {DESCRIPTION_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Info about world tone */}\n            <div className=\"illuminator-template-info-box\">\n              <strong>Note:</strong> The world&apos;s tone and style guidance from the Context tab is\n              automatically included in all description prompts. The Focus field above should\n              contain only entity-specific instructions.\n            </div>\n          </div>\n        ) : (\n          // Image editing\n          <div className=\"illuminator-template-sections\">\n            {IMAGE_SECTIONS.map((section) => (\n              <TemplateSection\n                key={section.key}\n                section={section}\n                value={getNestedValue(currentGuidance, section.key)}\n                onChange={handleSectionChange}\n              />\n            ))}\n\n            {/* Visual Step Overrides */}\n            <div className=\"illuminator-template-visual-steps\">\n              <button\n                className=\"illuminator-template-visual-steps-toggle\"\n                onClick={() => setShowVisualSteps(!showVisualSteps)}\n              >\n                <span>{showVisualSteps ? \"\\u25BC\" : \"\\u25B6\"}</span>\n                <span>Visual Generation Steps</span>\n                <span className=\"illuminator-template-visual-steps-hint\">\n                  Configure thesis/traits prompts for this kind\n                </span>\n              </button>\n              {showVisualSteps && (\n                <div className=\"illuminator-template-visual-steps-content\">\n                  {VISUAL_STEP_SECTIONS.map((section) => (\n                    <TemplateSection\n                      key={section.key}\n                      section={section}\n                      value={getNestedValue(currentGuidance, section.key)}\n                      onChange={handleSectionChange}\n                    />\n                  ))}\n                  <div className=\"illuminator-template-visual-steps-info\">\n                    These prompts control the 3-step visual generation chain: Description \u2192 Visual\n                    Thesis \u2192 Visual Traits. The thesis provides the primary silhouette feature;\n                    traits add supporting details.\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Live Preview Card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Live Preview</h2>\n          {exampleEntities.length > 0 && (\n            <select\n              value={selectedEntityId}\n              onChange={(e) => setSelectedEntityId(e.target.value)}\n              className=\"illuminator-select ege-preview-select\"\n            >\n              <option value=\"\">\n                {exampleEntities[0]?.name || \"Example\"} ({exampleEntities[0]?.subtype})\n              </option>\n// ... (truncated)", "parameters": [{"name": "{\n  entityGuidance: externalEntityGuidance,\n  onEntityGuidanceChange,\n  worldContext,\n  worldSchema,\n  simulationMetadata,\n}", "type": "{ entityGuidance: any; onEntityGuidanceChange: any; worldContext: any; worldSchema: any; simulationMetadata: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityLinkPicker.jsx", "sourceCode": "export default function EntityLinkPicker({ onSelect, onClose }) {\n  const entities = useEntityNavList();\n  const [search, setSearch] = useState(\"\");\n\n  const filteredEntities = useMemo(() => {\n    if (!entities?.length) return [];\n\n    const searchLower = search.toLowerCase();\n    return entities\n      .filter((entity) => {\n        if (!search) return true;\n        return (\n          entity.name.toLowerCase().includes(searchLower) ||\n          entity.kind.toLowerCase().includes(searchLower) ||\n          (entity.subtype && entity.subtype.toLowerCase().includes(searchLower))\n        );\n      })\n      .slice(0, 50); // Limit results for performance\n  }, [entities, search]);\n\n  const handleSelect = (entity) => {\n    onSelect(`[[${entity.name}]]`);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Entity Link\" className=\"entity-link-picker-modal\">\n      <input\n        type=\"text\"\n        value={search}\n        onChange={(e) => setSearch(e.target.value)}\n        placeholder=\"Search entities...\"\n        className=\"static-page-search-input\"\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus\n      />\n\n      <div className=\"entity-link-list\">\n        {filteredEntities.length === 0 ? (\n          <div className=\"entity-link-empty\">\n            {search ? \"No entities match your search\" : \"No entities available\"}\n          </div>\n        ) : (\n          filteredEntities.map((entity) => (\n            <button\n              key={entity.id}\n              className=\"entity-link-item\"\n              onClick={() => handleSelect(entity)}\n            >\n              <span className=\"entity-link-name\">{entity.name}</span>\n              <span className=\"entity-link-meta\">\n                {entity.subtype || entity.kind}\n                {entity.culture && ` \u2022 ${entity.culture}`}\n              </span>\n            </button>\n          ))\n        )}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ onSelect, onClose }", "type": "{ onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EntityRenameModal.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EntityRenameModal.tsx", "sourceCode": "// ---------------------------------------------------------------------------\n// Main Modal\n// ---------------------------------------------------------------------------\n\nexport default function EntityRenameModal({\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}: Readonly<EntityRenameModalProps>) {\n  const navEntities = useEntityNavList();\n  const relationships = useRelationships();\n  const narrativeEvents = useNarrativeEvents();\n  const entity = useMemo(() => navEntities.find((e) => e.id === entityId), [navEntities, entityId]);\n\n  const isPatch = mode === \"patch\";\n\n  const [phase, setPhase] = useState<Phase>(\"input\");\n  const [addOldNameAsAlias, setAddOldNameAsAlias] = useState(true);\n  // In patch mode: newName = entity.name (current, correct), oldNameInput = user-entered stale name\n  const [newName, setNewName] = useState(isPatch ? entity?.name || \"\" : \"\");\n  const [oldNameInput, setOldNameInput] = useState(\n    isPatch ? entityId.replace(/-/g, \" \").replace(/\\b\\w/g, (c) => c.toUpperCase()) : \"\"\n  );\n  const [scanResult, setScanResult] = useState<RenameScanResult | null>(null);\n  const [decisions, setDecisions] = useState<Map<string, DecisionState>>(new Map());\n  const [expandedSources, setExpandedSources] = useState<Set<string>>(new Set());\n  const [applyProgress, setApplyProgress] = useState(\"\");\n  const [applyResult, setApplyResult] = useState(\"\");\n  const [isRolling, setIsRolling] = useState(false);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (phase === \"input\" && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [phase]);\n\n  // --- Name rolling ---\n  const handleRollName = useCallback(async () => {\n    if (!entity?.culture) return;\n    const cultureDef = cultures.find((c) => c.id === entity.culture);\n    if (!cultureDef) return;\n    const culture = toCulture(cultureDef);\n    if (!culture) return;\n\n    setIsRolling(true);\n    try {\n      const result = await generate(culture, {\n        kind: entity.kind,\n        subtype: entity.subtype,\n        count: 1,\n        seed: `rename-${Date.now()}`,\n      });\n      if (result.names.length > 0) {\n        setNewName(result.names[0]);\n      }\n    } catch (err) {\n      console.warn(\"[EntityRename] Name generation failed:\", err);\n    } finally {\n      setIsRolling(false);\n    }\n  }, [entity, cultures]);\n\n  // --- Scanning ---\n  const scanOldName = isPatch ? oldNameInput.trim() : entity.name;\n\n  const handleScan = useCallback(async () => {\n    if (isPatch ? !oldNameInput.trim() : !newName.trim()) return;\n    setPhase(\"scanning\");\n\n    console.log(\"[EntityRenameModal] handleScan starting\", {\n      scanOldName,\n      newName,\n      narrativeEventCount: narrativeEvents?.length ?? 0,\n    });\n\n    // Sample a narrative event to check if it has patched or original text\n    if (narrativeEvents && narrativeEvents.length > 0) {\n      const sample = narrativeEvents[0];\n      console.log(\"[EntityRenameModal] Sample narrative event\", {\n        id: sample.id,\n        description: sample.description?.substring(0, 200),\n        action: sample.action?.substring(0, 200),\n        hasSimulationRunId: \"simulationRunId\" in sample,\n      });\n    }\n\n    try {\n      const [chronicles, fullEntities] = await Promise.all([\n        getChroniclesForSimulation(simulationRunId),\n        entityRepo.getEntitiesForRun(simulationRunId),\n      ]);\n      const result = scanForReferences(\n        entityId,\n        scanOldName,\n        fullEntities,\n        chronicles,\n        relationships,\n        narrativeEvents\n      );\n      // Filter out no-op matches where the matched text already equals the new name\n      const effectiveName = isPatch ? entity.name : newName;\n      result.matches = result.matches.filter(\n        (m) => m.matchType === \"id_slug\" || m.matchedText !== effectiveName\n      );\n\n      console.log(\"[EntityRenameModal] Scan result\", {\n        totalMatches: result.matches.length,\n        eventMatches: result.matches.filter((m) => m.sourceType === \"event\").length,\n      });\n      setScanResult(result);\n\n      // Initialize decisions: accept for full+metadata, reject for partial.\n      // id_slug matches are informational only \u2014 no decision needed.\n      const initial = new Map<string, DecisionState>();\n      for (const match of result.matches) {\n        if (match.matchType === \"id_slug\") continue;\n        initial.set(match.id, {\n          action: match.matchType === \"partial\" ? \"reject\" : \"accept\",\n          editText: newName,\n        });\n      }\n      setDecisions(initial);\n\n      // Self entity starts expanded\n      setExpandedSources(new Set([entityId]));\n      setPhase(\"preview\");\n    } catch (err) {\n      console.error(\"[EntityRename] Scan failed:\", err);\n      setPhase(\"input\");\n    }\n  }, [\n    newName,\n    oldNameInput,\n    isPatch,\n    scanOldName,\n    entity,\n    entityId,\n    simulationRunId,\n    relationships,\n    narrativeEvents,\n  ]);\n\n  // --- Decision handling ---\n  const handleChangeAction = useCallback(\n    (matchId: string, action: DecisionAction) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"reject\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, action });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  const handleChangeEditText = useCallback(\n    (matchId: string, text: string) => {\n      setDecisions((prev) => {\n        const next = new Map(prev);\n        const current = next.get(matchId) || {\n          action: \"edit\",\n          editText: newName,\n        };\n        next.set(matchId, { ...current, editText: text });\n        return next;\n      });\n    },\n    [newName]\n  );\n\n  // --- Bulk actions (global) ---\n  const handleAcceptAll = useCallback(() => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const [id, state] of next) {\n        next.set(id, { ...state, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectAllPartials = useCallback(() => {\n    if (!scanResult) return;\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const match of scanResult.matches) {\n        if (match.matchType === \"partial\") {\n          const current = next.get(match.id);\n          if (current) {\n            next.set(match.id, { ...current, action: \"reject\" });\n          }\n        }\n      }\n      return next;\n    });\n  }, [scanResult]);\n\n  // --- Bulk actions (per-source) ---\n  const handleAcceptSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"accept\" });\n      }\n      return next;\n    });\n  }, []);\n\n  const handleRejectSource = useCallback((matchIds: string[]) => {\n    setDecisions((prev) => {\n      const next = new Map(prev);\n      for (const id of matchIds) {\n        const current = next.get(id);\n        if (current) next.set(id, { ...current, action: \"reject\" });\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Expand/collapse ---\n  const toggleSource = useCallback((sourceId: string) => {\n    setExpandedSources((prev) => {\n      const next = new Set(prev);\n      if (next.has(sourceId)) {\n        next.delete(sourceId);\n      } else {\n        next.add(sourceId);\n      }\n      return next;\n    });\n  }, []);\n\n  // --- Apply ---\n  const handleApply = useCallback(async () => {\n    if (!scanResult) return;\n    setPhase(\"applying\");\n\n    try {\n      const decisionArray: MatchDecision[] = [];\n      for (const [matchId, state] of decisions) {\n        decisionArray.push({\n          matchId,\n          action: state.action,\n          editText: state.action === \"edit\" ? state.editText : undefined,\n        });\n      }\n\n      setApplyProgress(\"Building patches...\");\n      const patches = buildRenamePatches(scanResult, newName, decisionArray);\n      console.log(\"[EntityRenameModal] Built patches\", {\n        entityPatchCount: patches.entityPatches.length,\n        eventPatchCount: patches.eventPatches.length,\n        chroniclePatchCount: patches.chroniclePatches.length,\n        eventPatchIds: patches.eventPatches.map((p) => p.eventId),\n        eventPatchKeys: patches.eventPatches.map((p) => Object.keys(p.changes)),\n      });\n\n      // Apply chronicle patches directly (chronicles have their own IDB store)\n      let chronicleCount = 0;\n      if (patches.chroniclePatches.length > 0) {\n        setApplyProgress(`Updating ${patches.chroniclePatches.length} chronicles...`);\n        chronicleCount = await applyChroniclePatches(\n          patches.chroniclePatches,\n          getChronicle,\n          putChronicle\n        );\n      }\n\n      setApplyProgress(`Persisting ${patches.entityPatches.length} entity patches...`);\n\n      const parts = [`${patches.entityPatches.length} entities`, `${chronicleCount} chronicles`];\n      if (patches.eventPatches.length > 0) {\n        parts.push(`${patches.eventPatches.length} events`);\n      }\n      setApplyResult(`Updated ${parts.join(\", \")}.`);\n\n      // Pass patch manifest to parent \u2014 parent handles Dexie persistence\n      onApply({\n        entityPatches: patches.entityPatches,\n        eventPatches: patches.eventPatches,\n        targetEntityId: isPatch ? null : entityId,\n        newName,\n        addOldNameAsAlias: isPatch ? false : addOldNameAsAlias,\n      });\n      setPhase(\"done\");\n    } catch (err) {\n      console.error(\"[EntityRename] Apply failed:\", err);\n      setApplyProgress(`Error: ${err}`);\n    }\n  }, [scanResult, decisions, newName, entityId, onApply, isPatch, addOldNameAsAlias]);\n\n// ... (truncated)", "parameters": [{"name": "{\n  entityId,\n  cultures,\n  simulationRunId,\n  mode = \"rename\",\n  onApply,\n  onClose,\n}", "type": "Readonly<EntityRenameModalProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeModal.jsx", "sourceCode": "export default function EraNarrativeModal({\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}) {\n  const [selectedEraId, setSelectedEraId] = useState(\"\");\n  const [tone, setTone] = useState(\"witty\");\n  const [arcDirection, setArcDirection] = useState(\"\");\n  const [existingNarratives, setExistingNarratives] = useState([]);\n  const [previousEraThesis, setPreviousEraThesis] = useState(null);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const {\n    narrative,\n    isActive,\n    startNarrative,\n    startHeadless,\n    resumeNarrative,\n    advanceStep,\n    skipEdit,\n    rerunCopyEdit,\n    deleteVersion,\n    setActiveVersion,\n    cancel\n  } = useEraNarrative(onEnqueue);\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n\n  // Access world context stores (must be before effects that reference it)\n  const eraTemporalInfo = useEraTemporalInfo();\n\n  // Check for existing narratives when era selection changes + look up previous era thesis\n  useEffect(() => {\n    if (!selectedEraId || !simulationRunId) {\n      setExistingNarratives([]);\n      setPreviousEraThesis(null);\n      return;\n    }\n    getEraNarrativesForEra(simulationRunId, selectedEraId).then(records => {\n      // Show non-complete records (resumable) and recent completed ones\n      const resumable = records.filter(r => r.status !== \"cancelled\").sort((a, b) => b.updatedAt - a.updatedAt);\n      setExistingNarratives(resumable);\n    });\n\n    // Look up thesis from previous era's completed narrative\n    const focalInfo = eraTemporalInfo.find(e => e.id === selectedEraId);\n    const focalOrder = focalInfo?.order ?? -1;\n    const prevInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    if (prevInfo) {\n      getEraNarrativesForEra(simulationRunId, prevInfo.id).then(prevRecords => {\n        const completed = prevRecords.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n        setPreviousEraThesis(completed.length > 0 ? {\n          eraName: prevInfo.name,\n          thesis: completed[0].threadSynthesis.thesis\n        } : null);\n      });\n    } else {\n      setPreviousEraThesis(null);\n    }\n  }, [selectedEraId, simulationRunId, eraTemporalInfo]);\n\n  // Group chronicles by era and count prep coverage\n  const eraOptions = useMemo(() => {\n    return wizardEras.map(era => {\n      const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n      const preppedCount = eraChronicles.filter(c => c.hasHistorianPrep).length;\n      return {\n        id: era.id,\n        name: era.name,\n        count: eraChronicles.length,\n        preppedCount\n      };\n    });\n  }, [wizardEras, chronicleItems]);\n  const selectedEra = eraOptions.find(e => e.id === selectedEraId);\n\n  // Build a weight lookup from the live style library (record snapshots may be stale)\n  const narrativeWeightMap = useMemo(() => {\n    const map = {};\n    if (styleLibrary?.narrativeStyles) {\n      for (const s of styleLibrary.narrativeStyles) {\n        if (s.eraNarrativeWeight) map[s.id] = s.eraNarrativeWeight;\n      }\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Chronicles for the selected era \u2014 for the setup enumeration\n  const eraChronicles = useMemo(() => {\n    if (!selectedEra) return [];\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return [];\n    return chronicleItems.filter(c => c.focalEraName === era.name).sort((a, b) => (a.eraYear ?? Infinity) - (b.eraYear ?? Infinity));\n  }, [chronicleItems, wizardEras, selectedEraId, selectedEra]);\n\n  // Build the narrative config (shared by interactive and headless start)\n  const buildConfig = useCallback(async () => {\n    const era = wizardEras.find(e => e.id === selectedEraId);\n    if (!era) return null;\n\n    // Load prep briefs from chronicles in this era\n    const store = useChronicleStore.getState();\n    const eraChronicles = chronicleItems.filter(c => c.focalEraName === era.name);\n    const prepBriefs = [];\n    for (const item of eraChronicles) {\n      const record = await store.loadChronicle(item.chronicleId);\n      if (!record?.historianPrep) continue;\n      prepBriefs.push({\n        chronicleId: record.chronicleId,\n        chronicleTitle: record.title || item.name,\n        eraYear: record.eraYear,\n        weight: record.narrativeStyle?.eraNarrativeWeight || narrativeWeightMap[record.narrativeStyleId] || undefined,\n        prep: record.historianPrep\n      });\n    }\n\n    // Build world-level context\n    const configStore = useIlluminatorConfigStore.getState();\n    const worldDynamics = configStore.worldContext?.worldDynamics || [];\n    const cultureIds = configStore.cultureIdentities || {};\n\n    // Resolve dynamics for focal era \u2014 only include dynamics that have an override for this era\n    const resolvedDynamics = worldDynamics.filter(d => d.eraOverrides?.[era.id]).map(d => {\n      const override = d.eraOverrides[era.id];\n      return override.replace ? override.text : `${d.text || \"\"} ${override.text}`;\n    }).filter(Boolean);\n\n    // Find focal + adjacent eras from temporal info\n    const focalEraInfo = eraTemporalInfo.find(e => e.id === era.id);\n    const focalOrder = focalEraInfo?.order ?? -1;\n    const previousEraInfo = focalOrder > 0 ? eraTemporalInfo.find(e => e.order === focalOrder - 1) : undefined;\n    const nextEraInfo = eraTemporalInfo.find(e => e.order === focalOrder + 1);\n    const toSummary = info => info ? {\n      id: info.id,\n      name: info.name,\n      summary: info.summary || \"\"\n    } : undefined;\n\n    // Look up the previous era's completed narrative thesis for continuity\n    let previousEraThesis;\n    if (previousEraInfo) {\n      const prevNarratives = await getEraNarrativesForEra(simulationRunId, previousEraInfo.id);\n      const completedPrev = prevNarratives.filter(r => r.status === \"complete\" && r.threadSynthesis?.thesis).sort((a, b) => b.updatedAt - a.updatedAt);\n      if (completedPrev.length > 0) {\n        previousEraThesis = completedPrev[0].threadSynthesis.thesis;\n      }\n    }\n    const worldContext = focalEraInfo ? {\n      focalEra: toSummary(focalEraInfo),\n      previousEra: toSummary(previousEraInfo),\n      nextEra: toSummary(nextEraInfo),\n      previousEraThesis,\n      resolvedDynamics,\n      culturalIdentities: cultureIds\n    } : undefined;\n    return {\n      projectId,\n      simulationRunId,\n      eraId: era.id,\n      eraName: era.name,\n      tone,\n      arcDirection: arcDirection.trim() || undefined,\n      historianConfig,\n      prepBriefs,\n      worldContext\n    };\n  }, [selectedEraId, wizardEras, chronicleItems, projectId, simulationRunId, historianConfig, tone, arcDirection, eraTemporalInfo]);\n\n  // Start interactive narrative\n  const handleStart = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startNarrative(config);\n  }, [selectedEra, buildConfig, startNarrative]);\n\n  // Start headless narrative (all steps, no pauses)\n  const handleStartHeadless = useCallback(async () => {\n    if (!selectedEra) return;\n    const config = await buildConfig();\n    if (config) startHeadless(config);\n  }, [selectedEra, buildConfig, startHeadless]);\n\n  // Resume an existing narrative\n  const handleResume = useCallback(async narrativeId => {\n    await resumeNarrative(narrativeId);\n  }, [resumeNarrative]);\n\n  // Delete an existing narrative from the list\n  const handleDeleteExisting = useCallback(async narrativeId => {\n    await deleteEraNarrative(narrativeId);\n    setExistingNarratives(prev => prev.filter(r => r.narrativeId !== narrativeId));\n  }, []);\n  const handleClose = useCallback(() => {\n    if (isActive && narrative?.status !== \"complete\") {\n      if (narrative?.status === \"generating\" || narrative?.status === \"pending\") {\n        // Minimize instead of closing \u2014 keep isOpen true so pill can restore\n        useFloatingPillStore.getState().minimize({\n          id: PILL_ID,\n          label: `Era: ${narrative?.eraName || \"Narrative\"}`,\n          statusText: narrative?.currentStep || \"Working\",\n          statusColor: \"#f59e0b\",\n          tabId: \"chronicle\"\n        });\n        return;\n      }\n      cancel();\n    }\n    onClose();\n  }, [isActive, narrative, cancel, onClose]);\n\n  // Update pill status when state changes while minimized\n  useEffect(() => {\n    if (!isMinimized || !narrative) return;\n    const stepLabel = {\n      threads: \"Threads\",\n      generate: \"Writing\",\n      edit: \"Editing\"\n    };\n    let statusColor;\n    if (narrative.status === \"generating\" || narrative.status === \"pending\") statusColor = \"#f59e0b\";else if (narrative.status === \"step_complete\") statusColor = \"#3b82f6\";else if (narrative.status === \"complete\") statusColor = \"#10b981\";else if (narrative.status === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    let statusText;\n    if (narrative.status === \"complete\") statusText = \"Complete\";else if (narrative.status === \"failed\") statusText = \"Failed\";else statusText = stepLabel[narrative.currentStep] || narrative.currentStep;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, narrative?.status, narrative?.currentStep]);\n\n  // Clean up pill when process reaches terminal state\n  useEffect(() => {\n    if (!narrative || narrative.status === \"complete\" || narrative.status === \"failed\" || narrative.status === \"cancelled\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [narrative?.status]);\n\n  // Sync narrativeId to modal store so it survives ChroniclePanel unmount\n  useEffect(() => {\n    if (narrative?.narrativeId) {\n      useIlluminatorModals.getState().setEraNarrativeId(narrative.narrativeId);\n    }\n  }, [narrative?.narrativeId]);\n\n  // Auto-resume from store when modal re-mounts with a stored narrativeId\n  useEffect(() => {\n    if (isOpen && resumeNarrativeId && !isActive && !narrative) {\n      resumeNarrative(resumeNarrativeId);\n    }\n  }, [isOpen, resumeNarrativeId, isActive, narrative, resumeNarrative]);\n\n  // Resolve thread names for movement display (must be before early return)\n  const synthesis = narrative?.threadSynthesis;\n  const threadNameMap = useMemo(() => {\n    if (!synthesis) return {};\n    const map = {};\n    for (const t of synthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [synthesis]);\n\n  // Resolve versioned content from the narrative record\n  const resolved = useMemo(() => {\n    if (!narrative) return {\n      content: undefined,\n      versions: [],\n      activeVersionId: undefined\n    };\n    return resolveActiveContent(narrative);\n  }, [narrative]);\n\n  // Sync selectedVersionId to activeVersionId when versions change\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      // Reset selection when active version changes (e.g., after re-run edit completes)\n      // or when no version is selected yet\n      if (!selectedVersionId || !resolved.versions.some(v => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n  if (!isOpen) return null;\n  if (isMinimized) return null;\n  const isGenerating = narrative?.status === \"pending\" || narrative?.status === \"generating\";\n  const isStepComplete = narrative?.status === \"step_complete\";\n  const isFailed = narrative?.status === \"failed\";\n  const isComplete = narrative?.status === \"complete\";\n  const narrativeContent = narrative?.narrative;\n\n  // Currently viewed version (for version selector)\n  const viewedVersion = resolved.versions.find(v => v.versionId === selectedVersionId) || resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // Determine what to show\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  chronicleItems,\n  wizardEras,\n  projectId,\n  simulationRunId,\n  historianConfig,\n  onEnqueue,\n  resumeNarrativeId,\n  styleLibrary\n}", "type": "{ isOpen: any; onClose: any; chronicleItems: any; wizardEras: any; projectId: any; simulationRunId: any; historianConfig: any; onEnqueue: any; resumeNarrativeId: any; styleLibrary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EraNarrativeViewer.tsx", "sourceCode": "export default function EraNarrativeViewer({\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}: Readonly<EraNarrativeViewerProps>) {\n  const [record, setRecord] = useState<EraNarrativeRecord | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [showThreads, setShowThreads] = useState(false);\n  const [showBriefs, setShowBriefs] = useState(false);\n  const [selectedVersionId, setSelectedVersionId] = useState(\"\");\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState<string | null>(null);\n  const [showInsertion, setShowInsertion] = useState(false);\n  const [insertionText, setInsertionText] = useState(\"\");\n  const pollRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const pollReasonRef = useRef<\"edit\" | \"cover_image\" | \"image_refs\" | null>(null);\n\n  const styleSelection = externalStyleSelection || {\n    artisticStyleId: \"random\",\n    compositionStyleId: \"random\",\n    colorPaletteId: \"random\",\n  };\n\n  // Load record from IndexedDB\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getEraNarrative(narrativeId).then((r) => {\n      if (cancelled) return;\n      setRecord(r ?? null);\n      setLoading(false);\n      setSelectedVersionId(\"\");\n      setConfirmingDeleteId(null);\n      setInsertionText(r?.editInsertion || \"\");\n      // Resume polling if record is stuck in a generating state\n      if (r && (r.status === \"pending\" || r.status === \"generating\")) {\n        startPolling(\"edit\");\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [narrativeId]);\n\n  // Stop polling helper\n  const stopPolling = useCallback(() => {\n    if (pollRef.current) {\n      clearInterval(pollRef.current);\n      pollRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => stopPolling, [stopPolling]);\n\n  // Poll while generating (for re-run copy edit, cover image, image refs)\n  const startPolling = useCallback(\n    (reason: \"edit\" | \"cover_image\" | \"image_refs\" = \"edit\") => {\n      stopPolling();\n      pollReasonRef.current = reason;\n      const snapshotCoverImage = record?.coverImage;\n      const snapshotImageRefs = record?.imageRefs;\n\n      pollRef.current = setInterval(() => {\n        void (async () => {\n          const updated = await getEraNarrative(narrativeId);\n          if (!updated) return;\n          setRecord(updated);\n\n          const r = pollReasonRef.current;\n\n          // Edit polling: stop on terminal states or step_complete\n          if (r === \"edit\") {\n            if (\n              updated.status === \"complete\" ||\n              updated.status === \"failed\" ||\n              updated.status === \"step_complete\"\n            ) {\n              if (updated.status === \"step_complete\" && updated.currentStep === \"edit\") {\n                await updateEraNarrative(updated.narrativeId, { status: \"complete\" });\n                const final = await getEraNarrative(narrativeId);\n                if (final) setRecord(final);\n              }\n              stopPolling();\n            }\n            return;\n          }\n\n          // Cover image polling: stop when coverImage appears or changes\n          if (r === \"cover_image\") {\n            const hasCover = updated.coverImage?.sceneDescription;\n            const hadCover = snapshotCoverImage?.sceneDescription;\n            if (hasCover && hasCover !== hadCover) {\n              stopPolling();\n            }\n            return;\n          }\n\n          // Image refs polling: stop when imageRefs appears or changes\n          if (r === \"image_refs\") {\n            const hasRefs = updated.imageRefs?.generatedAt;\n            const hadRefs = snapshotImageRefs?.generatedAt;\n            if (hasRefs && hasRefs !== hadRefs) {\n              stopPolling();\n            }\n          }\n        })();\n      }, POLL_INTERVAL_MS);\n    },\n    [narrativeId, stopPolling, record?.coverImage, record?.imageRefs]\n  );\n\n  const threadNameMap = useMemo(() => {\n    if (!record?.threadSynthesis) return {};\n    const map: Record<string, string> = {};\n    for (const t of record.threadSynthesis.threads) {\n      map[t.threadId] = t.name;\n    }\n    return map;\n  }, [record?.threadSynthesis]);\n\n  // Resolve versioned content\n  const resolved = useMemo(() => {\n    if (!record) return { content: undefined, versions: [], activeVersionId: undefined };\n    return resolveActiveContent(record);\n  }, [record]);\n\n  // Sync selectedVersionId to activeVersionId\n  useEffect(() => {\n    if (resolved.activeVersionId) {\n      if (!selectedVersionId || !resolved.versions.some((v) => v.versionId === selectedVersionId)) {\n        setSelectedVersionId(resolved.activeVersionId);\n      }\n    }\n  }, [resolved.activeVersionId, resolved.versions.length]);\n\n  const viewedVersion =\n    resolved.versions.find((v) => v.versionId === selectedVersionId) ||\n    resolved.versions[resolved.versions.length - 1];\n  const viewedContent = viewedVersion?.content || resolved.content;\n  const viewedWordCount = viewedVersion?.wordCount || 0;\n\n  // =========================================================================\n  // Actions\n  // =========================================================================\n\n  const handleExport = useCallback(() => {\n    if (!record) return;\n    try {\n      downloadEraNarrativeExport(record);\n    } catch (err) {\n      console.error(\"[EraNarrativeViewer] Export failed:\", err);\n    }\n  }, [record]);\n\n  const handleRerunCopyEdit = useCallback(async () => {\n    if (!record) return;\n    await updateEraNarrative(record.narrativeId, {\n      status: \"pending\",\n      currentStep: \"edit\",\n      editInsertion: insertionText || undefined,\n    });\n    setSelectedVersionId(\"\");\n\n    onEnqueue([\n      {\n        entity: SENTINEL_ENTITY,\n        type: \"eraNarrative\" as EnrichmentType,\n        prompt: \"\",\n        chronicleId: record.narrativeId,\n      },\n    ]);\n\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n    startPolling();\n  }, [record, onEnqueue, startPolling, insertionText]);\n\n  const handleForceComplete = useCallback(async () => {\n    if (!record) return;\n    stopPolling();\n    await updateEraNarrative(record.narrativeId, { status: \"complete\" });\n    const updated = await getEraNarrative(record.narrativeId);\n    if (updated) setRecord(updated);\n  }, [record, stopPolling]);\n\n  const handleDeleteVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await deleteEraNarrativeVersion(record.narrativeId, versionId);\n      setRecord(updated);\n      setConfirmingDeleteId(null);\n      if (updated.activeVersionId) setSelectedVersionId(updated.activeVersionId);\n    },\n    [record]\n  );\n\n  const handleSetActiveVersion = useCallback(\n    async (versionId: string) => {\n      if (!record) return;\n      const updated = await setEraNarrativeActiveVersion(record.narrativeId, versionId);\n      setRecord(updated);\n    },\n    [record]\n  );\n\n  // =========================================================================\n  // Era Narrative Sub-Step Dispatch\n  // =========================================================================\n\n  const dispatchEraNarrativeStep = useCallback(\n    (step: string, extras?: Record<string, unknown>) => {\n      if (!record) return;\n      onEnqueue([\n        {\n          entity: SENTINEL_ENTITY,\n          type: \"eraNarrative\" as EnrichmentType,\n          prompt: \"\",\n          chronicleId: record.narrativeId,\n          eraNarrativeStep: step,\n          ...extras,\n        },\n      ]);\n    },\n    [record, onEnqueue]\n  );\n\n  // =========================================================================\n  // Cover Image Handlers\n  // =========================================================================\n\n  const handleGenerateCoverImageScene = useCallback(() => {\n    dispatchEraNarrativeStep(\"cover_image_scene\");\n    startPolling(\"cover_image\");\n  }, [dispatchEraNarrativeStep, startPolling]);\n\n  const handleGenerateCoverImage = useCallback(() => {\n    if (!record?.coverImage?.sceneDescription) return;\n\n    // Mark as generating\n    void updateEraNarrativeCoverImageStatus(record.narrativeId, \"generating\")\n      .then(() => getEraNarrative(record.narrativeId))\n      .then((updated) => {\n        if (updated) setRecord(updated);\n      });\n\n    // Build style info\n    const resolved = resolveStyleSelection({\n      selection: styleSelection,\n      entityKind: \"chronicle\",\n      styleLibrary: styleLibrary || {\n        artisticStyles: [],\n        compositionStyles: [],\n        colorPalettes: [],\n      },\n    });\n    const styleInfo: StyleInfo = {\n      compositionPromptFragment:\n        \"cinematic montage composition, overlapping character silhouettes and scene elements, layered movie-poster layout, multiple focal points at different scales, dramatic depth layering, figures and settings blending into each other, NO TEXT NO TITLES NO LETTERING\",\n      artisticPromptFragment: resolved.artisticStyle?.promptFragment,\n      colorPalettePromptFragment: resolved.colorPalette?.promptFragment,\n    };\n\n    const prompt = buildChronicleScenePrompt(\n      {\n        sceneDescription: record.coverImage.sceneDescription,\n        size: \"medium\",\n        chronicleTitle: record.eraName,\n        world: worldContext\n          ? {\n              name: worldContext.name || \"Unknown World\",\n              description: worldContext.description,\n              speciesConstraint: worldContext.speciesConstraint,\n            }\n          : undefined,\n      },\n      styleInfo\n    );\n\n    onEnqueue([\n      {\n        entity: { id: \"__era_narrative__\", name: record.eraName, kind: \"era_narrative\" },\n        type: \"image\" as EnrichmentType,\n        prompt,\n        chronicleId: record.narrativeId,\n        imageRefId: \"__cover_image__\",\n        sceneDescription: record.coverImage.sceneDescription,\n        imageType: \"era_narrative\",\n        imageSize: imageSize || \"1024x1024\",\n        imageQuality: imageQuality || \"standard\",\n      },\n    ]);\n// ... (truncated)", "parameters": [{"name": "{\n  narrativeId,\n  onEnqueue,\n  styleLibrary,\n  styleSelection: externalStyleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  cultures,\n  cultureIdentities,\n  worldContext,\n}", "type": "Readonly<EraNarrativeViewerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/EventsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/EventsPanel.jsx", "sourceCode": "export default function EventsPanel({\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}) {\n  const [significanceFilter, setSignificanceFilter] = useState(0);\n  const [kindFilter, setKindFilter] = useState(\"all\");\n  const [eraFilter, setEraFilter] = useState(\"all\");\n  const [tagFilter, setTagFilter] = useState(\"\");\n  const [expandedEvents, setExpandedEvents] = useState(new Set());\n  const [displayLimit, setDisplayLimit] = useState(DEFAULT_DISPLAY_LIMIT);\n  const events = narrativeEvents || [];\n\n  // Get unique values for filters\n  const {\n    uniqueKinds,\n    uniqueEras,\n    uniqueTags\n  } = useMemo(() => {\n    const kinds = new Set();\n    const eras = new Set();\n    const tags = new Set();\n    for (const event of events) {\n      kinds.add(event.eventKind);\n      if (event.era) eras.add(event.era);\n      for (const tag of event.narrativeTags || []) {\n        tags.add(tag);\n      }\n    }\n    return {\n      uniqueKinds: Array.from(kinds).sort(),\n      uniqueEras: Array.from(eras).sort(),\n      uniqueTags: Array.from(tags).sort()\n    };\n  }, [events]);\n\n  // Filter events\n  const filteredEvents = useMemo(() => {\n    return events.filter(event => {\n      if (event.significance < significanceFilter) return false;\n      if (kindFilter !== \"all\" && event.eventKind !== kindFilter) return false;\n      if (eraFilter !== \"all\" && event.era !== eraFilter) return false;\n      if (tagFilter && !event.narrativeTags?.includes(tagFilter)) return false;\n      return true;\n    });\n  }, [events, significanceFilter, kindFilter, eraFilter, tagFilter]);\n\n  // Sort by significance (highest first)\n  const sortedEvents = useMemo(() => {\n    return [...filteredEvents].sort((a, b) => b.significance - a.significance);\n  }, [filteredEvents]);\n\n  // Limit displayed events for performance\n  const displayedEvents = useMemo(() => {\n    return sortedEvents.slice(0, displayLimit);\n  }, [sortedEvents, displayLimit]);\n  const hasMoreEvents = sortedEvents.length > displayLimit;\n  const handleLoadMore = () => {\n    setDisplayLimit(prev => prev + LOAD_MORE_INCREMENT);\n  };\n\n  // Reset display limit when filters change\n  useEffect(() => {\n    setDisplayLimit(DEFAULT_DISPLAY_LIMIT);\n  }, [significanceFilter, kindFilter, eraFilter, tagFilter]);\n  const toggleExpanded = eventId => {\n    setExpandedEvents(prev => {\n      const next = new Set(prev);\n      if (next.has(eventId)) {\n        next.delete(eventId);\n      } else {\n        next.add(eventId);\n      }\n      return next;\n    });\n  };\n  const handleExportEvents = () => {\n    if (events.length === 0) return;\n    const json = JSON.stringify(events, null, 2);\n    const blob = new Blob([json], {\n      type: \"application/json\"\n    });\n    const url = URL.createObjectURL(blob);\n    const anchor = document.createElement(\"a\");\n    const safeRunId = simulationRunId ? simulationRunId.replace(/[^a-zA-Z0-9_-]+/g, \"_\") : \"all\";\n    anchor.href = url;\n    anchor.download = `narrative-events-${safeRunId}.json`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    anchor.remove();\n    URL.revokeObjectURL(url);\n  };\n  if (events.length === 0) {\n    return <div className=\"events-panel-empty\">\n        <div className=\"events-panel-empty-icon\">\n          <span role=\"img\" aria-label=\"events\">\n            &#x1F4DC;\n          </span>\n        </div>\n        <h3 className=\"events-panel-empty-title\">No Narrative Events</h3>\n        <p className=\"events-panel-empty-text\">\n          Narrative events are captured during simulation when &quot;Enable event tracking&quot; is turned on\n          in the Lore Weave simulation parameters.\n        </p>\n        <div className=\"events-panel-empty-instructions\">\n          <div className=\"events-panel-empty-instructions-title\">To enable event tracking:</div>\n          <ol className=\"events-panel-empty-instructions-list\">\n            <li>Go to the Lore Weave tab</li>\n            <li>Open &quot;Run Simulation&quot;</li>\n            <li>Enable &quot;Narrative Events&quot; in parameters</li>\n            <li>Run a new simulation</li>\n          </ol>\n        </div>\n      </div>;\n  }\n  return <div className=\"events-panel-root\">\n      {/* Filter bar */}\n      <div className=\"events-panel-filter-bar\">\n        <div className=\"events-panel-filter-header\">\n          <div className=\"events-panel-filter-count\">\n            {displayedEvents.length === filteredEvents.length ? `${filteredEvents.length} of ${events.length} events` : `Showing ${displayedEvents.length} of ${filteredEvents.length} filtered (${events.length} total)`}\n          </div>\n          <div className=\"events-panel-filter-actions\">\n            <div className=\"events-panel-filter-sort-label\">Sorted by significance</div>\n            <button onClick={handleExportEvents} disabled={events.length === 0} className=\"events-panel-export-btn\">\n              Export JSON\n            </button>\n          </div>\n        </div>\n\n        <div className=\"events-panel-filters-row\">\n          {/* Significance slider */}\n          <div className=\"events-panel-significance-filter\">\n            <label htmlFor=\"min-significance\" className=\"events-panel-filter-label\">Min significance:</label>\n            <input id=\"min-significance\" type=\"range\" min={0} max={1} step={0.1} value={significanceFilter} onChange={e => setSignificanceFilter(parseFloat(e.target.value))} className=\"events-panel-significance-slider\" />\n            <span className=\"events-panel-significance-value\">\n              {Math.round(significanceFilter * 100)}%\n            </span>\n          </div>\n\n          {/* Kind filter */}\n          <select value={kindFilter} onChange={e => setKindFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All kinds</option>\n            {uniqueKinds.map(kind => <option key={kind} value={kind}>\n                {kind.replace(/_/g, \" \")}\n              </option>)}\n          </select>\n\n          {/* Era filter */}\n          <select value={eraFilter} onChange={e => setEraFilter(e.target.value)} className=\"events-panel-filter-select\">\n            <option value=\"all\">All eras</option>\n            {uniqueEras.map(era => <option key={era} value={era}>\n                {entityMap?.get(era)?.name || era}\n              </option>)}\n          </select>\n\n          {/* Tag filter */}\n          {uniqueTags.length > 0 && <select value={tagFilter} onChange={e => setTagFilter(e.target.value)} className=\"events-panel-filter-select\">\n              <option value=\"\">All tags</option>\n              {uniqueTags.map(tag => <option key={tag} value={tag}>\n                  {tag}\n                </option>)}\n            </select>}\n\n          {/* Clear filters */}\n          {(significanceFilter > 0 || kindFilter !== \"all\" || eraFilter !== \"all\" || tagFilter) && <button onClick={() => {\n          setSignificanceFilter(0);\n          setKindFilter(\"all\");\n          setEraFilter(\"all\");\n          setTagFilter(\"\");\n        }} className=\"events-panel-clear-filters-btn\">\n              Clear filters\n            </button>}\n        </div>\n      </div>\n\n      {/* Events list */}\n      <div className=\"events-panel-list\">\n        {sortedEvents.length === 0 ? <div className=\"events-panel-no-match\">No events match the current filters</div> : <>\n            {displayedEvents.map(event => <EventCard key={event.id} event={event} entityMap={entityMap} expanded={expandedEvents.has(event.id)} onToggle={() => toggleExpanded(event.id)} />)}\n\n            {/* Load more button */}\n            {hasMoreEvents && <div className=\"events-panel-load-more-row\">\n                <button onClick={handleLoadMore} className=\"events-panel-load-more-btn\">\n                  Load {Math.min(LOAD_MORE_INCREMENT, sortedEvents.length - displayLimit)} more\n                  <span className=\"events-panel-load-more-remaining\">\n                    ({sortedEvents.length - displayLimit} remaining)\n                  </span>\n                </button>\n              </div>}\n          </>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  narrativeEvents = [],\n  simulationRunId,\n  entityMap\n}", "type": "{ narrativeEvents?: any[]; simulationRunId: any; entityMap: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/FinalEditTab.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/FinalEditTab.tsx", "sourceCode": "export default function FinalEditTab() {\n  return (\n    <div>\n      <div className=\"fet-section\">\n        <h3 className=\"fet-heading\">Corpus Find & Replace</h3>\n        <p className=\"fet-subtitle\">\n          Search and replace across chronicle content, chronicle annotations, and entity annotations\n        </p>\n      </div>\n      <CorpusFindReplace />\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianConfigEditor.jsx", "sourceCode": "// ============================================================================\n// Main Editor\n// ============================================================================\n\nexport default function HistorianConfigEditor({ config, onChange }) {\n  const update = useCallback(\n    (field, value) => {\n      onChange({ ...config, [field]: value });\n    },\n    [config, onChange]\n  );\n\n  const [reloadStatus, setReloadStatus] = useState(null); // null | 'confirm' | 'loading' | 'done' | 'error'\n\n  const handleReloadFromDefaults = useCallback(async () => {\n    try {\n      setReloadStatus(\"loading\");\n      const response = await fetch(\"/default-project/historianConfig.json\");\n      if (!response.ok) throw new Error(`HTTP ${response.status}`);\n      const defaultConfig = await response.json();\n      onChange(defaultConfig);\n      setReloadStatus(\"done\");\n      setTimeout(() => setReloadStatus(null), 2000);\n    } catch (err) {\n      setReloadStatus(\"error\");\n      console.error(\"Failed to reload historian config:\", err);\n      setTimeout(() => setReloadStatus(null), 3000);\n    }\n  }, [onChange]);\n\n  const isConfigured = config.name.trim().length > 0 && config.background.trim().length > 0;\n\n  return (\n    <div className=\"hce-root\">\n      {/* Header */}\n      <div className=\"hce-header\">\n        <div className=\"hce-header-top\">\n          <div className=\"hce-header-title\">Historian Persona</div>\n          <button\n            onClick={() => setReloadStatus(\"confirm\")}\n            disabled={reloadStatus === \"loading\"}\n            className=\"illuminator-button illuminator-button-secondary hce-reload-btn\"\n            title=\"Reload historian config from the default project template\"\n          >\n            {(() => {\n              if (reloadStatus === \"loading\") return \"Loading...\";\n              if (reloadStatus === \"done\") return \"Reloaded \\u2713\";\n              if (reloadStatus === \"error\") return \"Failed \\u2717\";\n              return \"Reload Defaults\";\n            })()}\n          </button>\n        </div>\n        <div className=\"hce-header-description\">\n          Define the scholarly voice behind both <strong>annotations</strong> (margin notes \u2014\n          corrections, observations, asides) and <strong>copy edits</strong> (full description\n          rewrites synthesized from the description archive). The same persona drives both\n          operations in a consistent voice across all content.\n        </div>\n        {!isConfigured && (\n          <div className=\"hce-unconfigured-notice\">\n            Configure at least a name and background to enable historian annotations and copy edits.\n          </div>\n        )}\n      </div>\n\n      {/* Fields */}\n      <div className=\"hce-fields\">\n        {/* Name */}\n        <div>\n          <FieldLabel\n            label=\"Name & Title\"\n            description='e.g., \"Aldric Fenworth, Third Archivist of the Pale Library\"'\n          />\n          <input\n            type=\"text\"\n            value={config.name}\n            onChange={(e) => update(\"name\", e.target.value)}\n            placeholder=\"Enter the historian's name and title\"\n            className=\"hce-full-input\"\n          />\n        </div>\n\n        {/* Background */}\n        <div>\n          <FieldLabel\n            label=\"Background\"\n            description=\"Credentials, institutional affiliation, era they're writing from\"\n          />\n          <textarea\n            value={config.background}\n            onChange={(e) => update(\"background\", e.target.value)}\n            placeholder=\"A seasoned archivist who has spent forty years cataloguing the histories of the realm. Has outlived most of the people described in these texts. Still shows up to work.\"\n            className=\"hce-textarea hce-textarea-bg\"\n          />\n        </div>\n\n        {/* Personality Traits */}\n        <div>\n          <FieldLabel\n            label=\"Personality Traits\"\n            description=\"Short phrases that define the historian's character \u2014 think weary, not wacky\"\n          />\n          <TagInput\n            value={config.personalityTraits}\n            onChange={(v) => update(\"personalityTraits\", v)}\n            placeholder='e.g., \"world-weary\", \"quietly compassionate\"'\n          />\n        </div>\n\n        {/* Biases */}\n        <div>\n          <FieldLabel\n            label=\"Biases & Blind Spots\"\n            description=\"What they trust, distrust, or have given up arguing about\"\n          />\n          <TagInput\n            value={config.biases}\n            onChange={(v) => update(\"biases\", v)}\n            placeholder='e.g., \"distrusts oral histories\"'\n          />\n        </div>\n\n        {/* Stance */}\n        <div>\n          <FieldLabel\n            label=\"Stance Toward Source Material\"\n            description=\"Their overall relationship to the texts they're working with\"\n          />\n          <textarea\n            value={config.stance}\n            onChange={(e) => update(\"stance\", e.target.value)}\n            placeholder='e.g., \"Has read too many of these accounts to be surprised, but still occasionally moved by the human cost of events others reduce to dates and outcomes\"'\n            className=\"hce-textarea hce-textarea-stance\"\n          />\n        </div>\n\n        {/* Private Facts */}\n        <div>\n          <FieldLabel\n            label=\"Private Facts\"\n            description=\"Things the historian knows that aren't in the canon facts. May surface in annotations and shape editorial choices in copy edits.\"\n          />\n          <ListEditor\n            value={config.privateFacts}\n            onChange={(v) => update(\"privateFacts\", v)}\n            placeholder=\"Add a fact\"\n            itemPlaceholder='e.g., \"The real cause of the Great Fire was arson, not the dragon\"'\n          />\n        </div>\n\n        {/* Running Gags */}\n        <div>\n          <FieldLabel\n            label=\"Recurring Preoccupations\"\n            description=\"Refrains, motifs, or things the historian keeps circling back to \u2014 not jokes, but patterns they can't stop noticing\"\n          />\n          <ListEditor\n            value={config.runningGags}\n            onChange={(v) => update(\"runningGags\", v)}\n            placeholder=\"Add a preoccupation\"\n            itemPlaceholder='e.g., \"The way institutions always outlive the people who built them\"'\n          />\n        </div>\n      </div>\n\n      {/* Reload confirmation modal */}\n      {reloadStatus === \"confirm\" && (\n        <div\n          className=\"hce-modal-overlay\"\n          onClick={(e) => {\n            if (e.target === e.currentTarget) setReloadStatus(null);\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <div className=\"hce-modal-box\">\n            <div className=\"hce-modal-title\">Reload from Defaults?</div>\n            <div className=\"hce-modal-body\">\n              This will overwrite your current historian configuration with the default project\n              template. Any edits you&apos;ve made will be lost.\n            </div>\n            <div className=\"hce-modal-actions\">\n              <button\n                onClick={() => setReloadStatus(null)}\n                className=\"illuminator-button illuminator-button-secondary hce-modal-btn\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={() => handleReloadFromDefaults()}\n                className=\"illuminator-button hce-modal-btn\"\n              >\n                Reload\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ config, onChange }", "type": "{ config: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianEditionComparison.tsx", "sourceCode": "export default function HistorianEditionComparison({\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}: Readonly<HistorianEditionComparisonProps>) {\n  const [expanded, setExpanded] = useState(false);\n\n  const versions = useMemo(() => {\n    // Find all historian-edition and legacy-copy-edit entries with their original indices\n    const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n    const historianEntries = descriptionHistory\n      .map((entry, index) => ({ ...entry, historyIndex: index }))\n      .filter((entry) => editionSources.has(entry.source || \"\"));\n\n    if (historianEntries.length === 0) return [];\n\n    const editionVersions: EditionVersion[] = [];\n\n    // First entry = pre-historian baseline\n    const baseline = historianEntries[0];\n    editionVersions.push({\n      label: \"Pre-Historian\",\n      description: baseline.description,\n      historyIndex: baseline.historyIndex,\n      isCurrent: false,\n      wordCount: baseline.description.split(/\\s+/).length,\n      date: baseline.replacedAt ? new Date(baseline.replacedAt).toLocaleDateString() : undefined,\n    });\n\n    // Subsequent entries = prior historian/legacy outputs pushed to history when replaced\n    for (let i = 1; i < historianEntries.length; i++) {\n      const entry = historianEntries[i];\n      const isLegacy = entry.source === \"legacy-copy-edit\";\n      editionVersions.push({\n        label: `Edition ${i}${isLegacy ? \" (legacy)\" : \"\"}`,\n        description: entry.description,\n        historyIndex: entry.historyIndex,\n        isCurrent: false,\n        wordCount: entry.description.split(/\\s+/).length,\n        date: entry.replacedAt ? new Date(entry.replacedAt).toLocaleDateString() : undefined,\n      });\n    }\n\n    // Current description = latest edition\n    editionVersions.push({\n      label: `Edition ${historianEntries.length} (active)`,\n      description: currentDescription,\n      historyIndex: -1,\n      isCurrent: true,\n      wordCount: currentDescription.split(/\\s+/).length,\n    });\n\n    return editionVersions;\n  }, [descriptionHistory, currentDescription]);\n\n  // Exportable when we have 3+ versions: pre-historian baseline, at least one prior edition, and active.\n  // versions[0] = pre-historian, versions[last] = active, everything in between = prior editions.\n  const exportData = useMemo(() => {\n    if (versions.length < 3) return null;\n    const active = versions[versions.length - 1];\n    if (!active?.isCurrent) return null;\n    const data: Record<string, unknown> = {\n      preHistorian: versions[0].description,\n      legacyCopyEdit: versions[versions.length - 2].description,\n      active: active.description,\n    };\n    // Include non-disabled annotations when present\n    const activeNotes = historianNotes?.filter((n) => n.display !== \"disabled\");\n    if (activeNotes && activeNotes.length > 0) {\n      data.annotations = activeNotes.map((n) => ({\n        type: n.type,\n        display: n.display || \"full\",\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      }));\n    }\n    return data;\n  }, [versions, historianNotes]);\n\n  const [selectedIdx, setSelectedIdx] = useState(() => versions.length - 1);\n  const [compareIdx, setCompareIdx] = useState(() =>\n    versions.length > 1 ? versions.length - 2 : -1\n  );\n\n  if (versions.length < 2) return null;\n\n  const selected = versions[selectedIdx] || versions[versions.length - 1];\n  const compare = compareIdx >= 0 ? versions[compareIdx] : null;\n\n  const wordDelta = compare ? selected.wordCount - compare.wordCount : 0;\n  const deltaSign = wordDelta >= 0 ? \"+\" : \"\";\n\n  return (\n    <div className=\"hec-wrapper\">\n      <div\n        onClick={() => setExpanded(!expanded)}\n        className=\"hec-toggle\"\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <span>{expanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n        <span className=\"hec-toggle-label\">\n          Edition Comparison\n        </span>\n        <span\n          title={`${versions.length - 1} historian edition${versions.length - 1 !== 1 ? \"s\" : \"\"} + pre-historian baseline`}\n        >\n          {\"\\u25C7\"} {versions.length} versions\n        </span>\n      </div>\n\n      {expanded && (\n        <div className=\"hec-expanded\">\n          {/* Version selectors */}\n          <div className=\"hec-selector-row\">\n            <select\n              value={selectedIdx}\n              onChange={(e) => setSelectedIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-select\"\n            >\n              {versions.map((v, i) => (\n                <option key={i} value={i}>\n                  {v.label} ({v.wordCount}w){v.date ? ` \u2014 ${v.date}` : \"\"}\n                </option>\n              ))}\n            </select>\n            <select\n              value={compareIdx}\n              onChange={(e) => setCompareIdx(Number(e.target.value))}\n              className=\"illuminator-select hec-compare-select\"\n              title=\"Select a version to diff against\"\n            >\n              <option value={-1}>Compare to...</option>\n              {versions\n                .filter((_, i) => i !== selectedIdx)\n                .map((v) => {\n                  const realIdx = versions.indexOf(v);\n                  return (\n                    <option key={realIdx} value={realIdx}>\n                      {v.label} ({v.wordCount}w)\n                    </option>\n                  );\n                })}\n            </select>\n            {selected.isCurrent ? (\n              <span className=\"hec-active-badge\">\n                Active\n              </span>\n            ) : (\n              <button\n                onClick={() => onRestoreVersion(entityId, selected.historyIndex)}\n                className=\"hec-make-active-btn\"\n              >\n                Make Active\n              </button>\n            )}\n            {exportData && (\n              <button\n                onClick={() => {\n                  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                    type: \"application/json\",\n                  });\n                  const url = URL.createObjectURL(blob);\n                  const ts = new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, 19);\n                  const a = document.createElement(\"a\");\n                  a.href = url;\n                  a.download = `edition-comparison-${entityId}-${ts}.json`;\n                  a.click();\n                  URL.revokeObjectURL(url);\n                }}\n                className=\"hec-export-btn\"\n                title=\"Export pre-historian, legacy, and active versions as JSON\"\n              >\n                Export\n              </button>\n            )}\n          </div>\n\n          {/* Word count summary */}\n          {compare && (\n            <div className=\"hec-word-summary\">\n\n              <span>\n                {\"\\u25C6\"} {selected.label}: {selected.wordCount.toLocaleString()}w\n              </span>\n              <span>\n                {\"\\u25C6\"} {compare.label}: {compare.wordCount.toLocaleString()}w\n              </span>\n              <span\n                className=\"hec-word-delta\"\n                style={{\n                  \"--hec-delta-color\":\n                    wordDelta < 0 ? \"#22c55e\" : wordDelta > 0 ? \"#f59e0b\" : \"var(--text-muted)\",\n                } as React.CSSProperties}\n              >\n                {deltaSign}\n                {wordDelta.toLocaleString()}w ({deltaSign}\n                {compare.wordCount > 0 ? Math.round((wordDelta / compare.wordCount) * 100) : 0}%)\n              </span>\n            </div>\n          )}\n\n          {/* Diff view */}\n          {compare ? (\n            <DiffView older={compare.description} newer={selected.description} />\n          ) : (\n            <div className=\"hec-text-view\">\n\n              {selected.description}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entityId,\n  currentDescription,\n  descriptionHistory,\n  historianNotes,\n  onRestoreVersion,\n}", "type": "Readonly<HistorianEditionComparisonProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianMarginNotes.jsx", "sourceCode": "// ============================================================================\n// Main Component\n// ============================================================================\n\nexport default function HistorianMarginNotes({\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}) {\n  const counts = useMemo(() => {\n    if (!notes || notes.length === 0) return {\n      full: 0,\n      popout: 0,\n      disabled: 0\n    };\n    let full = 0,\n      popout = 0,\n      disabled = 0;\n    for (const n of notes) {\n      const d = noteDisplayMode(n);\n      if (d === \"full\") full++;else if (d === \"popout\") popout++;else disabled++;\n    }\n    return {\n      full,\n      popout,\n      disabled\n    };\n  }, [notes]);\n  if (!notes || notes.length === 0) return null;\n  const summaryParts = [];\n  if (counts.full > 0) summaryParts.push(`${counts.full} full`);\n  if (counts.popout > 0) summaryParts.push(`${counts.popout} popout`);\n  if (counts.disabled > 0) summaryParts.push(`${counts.disabled} disabled`);\n  return (\n    <div className={className || undefined}>\n      <div className=\"hmn-header\">\n        <span className=\"hmn-title\">Historian Notes</span>\n        <span className=\"hmn-summary\">{summaryParts.join(\", \")}</span>\n      </div>\n\n      {/* All notes in original order \u2014 no regrouping */}\n      {notes.map(note => <NoteItem key={note.noteId} note={note} sourceText={sourceText} onUpdateNote={onUpdateNote} />)}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  notes,\n  sourceText,\n  className,\n  onUpdateNote\n}", "type": "{ notes: any; sourceText: any; className: any; onUpdateNote: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianReviewModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function HistorianReviewModal({\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}) {\n  if (!isActive || !run) return null;\n  const isGenerating = run.status === \"pending\" || run.status === \"generating\";\n  const isReviewing = run.status === \"reviewing\";\n  const isFailed = run.status === \"failed\";\n  const notes = run.notes || [];\n  const acceptedCount = notes.filter(n => run.noteDecisions[n.noteId] !== false).length;\n  return <div className=\"hrm-overlay\">\n      <div className=\"hrm-modal\">\n        {/* Header */}\n        <div className=\"hrm-modal-header\">\n          <div>\n            <div className=\"hrm-modal-title\">Historian Review &mdash; {run.targetName}</div>\n            <div className=\"hrm-modal-subtitle\">\n              {run.targetType === \"entity\" ? \"Entity Description\" : \"Chronicle Narrative\"}\n              {run.tone && TONE_META[run.tone] && <span className=\"hrm-modal-tone\">\n                  {TONE_META[run.tone].symbol} {TONE_META[run.tone].label}\n                </span>}\n              {isReviewing && ` \\u00b7 ${acceptedCount}/${notes.length} notes accepted`}\n            </div>\n          </div>\n          <button onClick={onCancel} className=\"hrm-modal-cancel-btn\">\n            Cancel\n          </button>\n        </div>\n\n        {/* Content */}\n        <div className=\"hrm-modal-content\">\n          {isGenerating && <div className=\"hrm-generating-message\">The historian is reviewing the text\\u2026</div>}\n\n          {isFailed && <div className=\"hrm-failed-message\">Review failed: {run.error || \"Unknown error\"}</div>}\n\n          {isReviewing && <div className=\"hrm-review-layout\">\n              {/* Annotated source text */}\n              <div>\n                <div className=\"hrm-section-label\">Source Text (annotations highlighted)</div>\n                <AnnotatedText sourceText={run.sourceText} notes={notes} noteDecisions={run.noteDecisions} />\n              </div>\n\n              {/* Notes list */}\n              <div>\n                <div className=\"hrm-section-label\">Historian Notes ({notes.length})</div>\n                {notes.map(note => <NoteCard key={note.noteId} note={note} accepted={run.noteDecisions[note.noteId]} onToggle={onToggleNote} onEditText={onEditNoteText} />)}\n              </div>\n            </div>}\n        </div>\n\n        {/* Footer */}\n        {isReviewing && <div className=\"hrm-modal-footer\">\n            <button onClick={onCancel} className=\"hrm-discard-btn\">\n              Discard All\n            </button>\n            <button onClick={onAccept} disabled={acceptedCount === 0} className={`hrm-apply-btn ${acceptedCount > 0 ? \"hrm-apply-btn-active\" : \"hrm-apply-btn-disabled\"}`}>\n              Apply {acceptedCount} Note{acceptedCount !== 1 ? \"s\" : \"\"}\n            </button>\n          </div>}\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onToggleNote,\n  onEditNoteText,\n  onAccept,\n  onCancel\n}", "type": "{ run: any; isActive: any; onToggleNote: any; onEditNoteText: any; onAccept: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistorianToneSelector.jsx", "sourceCode": "// ============================================================================\n// Component\n// ============================================================================\n\nexport default function HistorianToneSelector({\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const containerRef = useRef(null);\n\n  // Close on outside click\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleClickOutside = e => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [isOpen]);\n  const handleSelect = tone => {\n    setIsOpen(false);\n    onSelect(tone);\n  };\n  return <div ref={containerRef} className={`htsel-container${className ? ` ${className}` : \"\"}`}>\n      <button onClick={() => setIsOpen(!isOpen)} disabled={disabled} title=\"Select historian tone and generate annotations\" className={`htsel-trigger ${disabled ? \"htsel-trigger-disabled\" : \"\"}`}>\n        {label || (hasNotes ? \"Re-annotate\" : \"Historian\")} \u25be\n      </button>\n\n      {isOpen && <div className=\"htsel-dropdown\">\n          <div className=\"htsel-dropdown-header\">Historian Tone</div>\n          {TONE_OPTIONS.map(option => <button key={option.value} onClick={() => handleSelect(option.value)} className=\"htsel-option\">\n              <span className=\"htsel-option-symbol\">{option.symbol}</span>\n              <div className=\"htsel-option-content\">\n                <div className=\"htsel-option-label\">{option.label}</div>\n                <div className=\"htsel-option-description\">{option.description}</div>\n              </div>\n            </button>)}\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  onSelect,\n  disabled,\n  hasNotes,\n  className,\n  label\n}", "type": "{ onSelect: any; disabled: any; hasNotes: any; className: any; label: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/HistoryCompressionPreviewModal.jsx", "sourceCode": "export default function HistoryCompressionPreviewModal({\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}) {\n  if (!compressed || compressed.length === 0) return null;\n\n  const removedCount = originalCount - compressed.length;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary hcpm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={onProceed}\n        className=\"illuminator-button illuminator-button-primary hcpm-footer-btn\"\n      >\n        Proceed with Copy Edit\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Description Archive\" className=\"hcpm-dialog\" footer={footer}>\n      <div className=\"hcpm-meta\">\n        <span className=\"hcpm-entity-name\">{entityName}</span>\n        <p className=\"hcpm-subtitle\">\n          {removedCount > 0\n            ? `${originalCount} versions \u2192 ${compressed.length} milestones (${removedCount} near-duplicate passes consolidated)`\n            : `${originalCount} versions \u2014 no compression needed`}\n        </p>\n      </div>\n\n      {/* Scrollable content */}\n      <div className=\"hcpm-content\">\n        {compressed.map((entry, i) => {\n          const date = new Date(entry.replacedAt).toISOString().split(\"T\")[0];\n          const isConsolidated = entry.consolidatedCount > 1;\n          const earliestDate = entry.earliestDate\n            ? new Date(entry.earliestDate).toISOString().split(\"T\")[0]\n            : null;\n\n          return (\n            <div\n              key={i}\n              className={`hcpm-entry ${isConsolidated ? \"hcpm-entry-consolidated\" : \"hcpm-entry-normal\"}`}\n            >\n              {/* Header */}\n              <div className=\"hcpm-entry-header\">\n                <div className=\"hcpm-entry-header-left\">\n                  <span className=\"hcpm-entry-index\">[{i + 1}]</span>\n                  <span className=\"hcpm-entry-source\">{entry.source}</span>\n                  {isConsolidated && (\n                    <span className=\"hcpm-entry-consolidated-label\">\n                      {entry.consolidatedCount} passes consolidated\n                    </span>\n                  )}\n                </div>\n                <span className=\"hcpm-entry-date\">\n                  {isConsolidated && earliestDate ? `${earliestDate} \u2192 ${date}` : date}\n                </span>\n              </div>\n\n              {/* Preview */}\n              <div className=\"hcpm-entry-preview\">{entry.description.slice(0, 300)}</div>\n            </div>\n          );\n        })}\n      </div>\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  entityName,\n  originalCount,\n  compressed,\n  onProceed,\n  onCancel,\n}", "type": "{ entityName: any; originalCount: any; compressed: any; onProceed: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorModals.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorModals.jsx", "sourceCode": "/**\n * Orchestrator component for all Illuminator modal dialogs.\n *\n * Flow objects (revisionFlow, backportFlow, etc.) are passed as grouped props\n * rather than flat-spreading ~100 properties.\n */\nexport default function IlluminatorModals({\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}) {\n  return (\n    <>\n      <ImageSettingsSection\n        imageGenSettings={props.imageGenSettings}\n        updateImageGenSettings={props.updateImageGenSettings}\n        styleLibrary={props.styleLibrary}\n        worldSchema={props.worldSchema}\n        config={props.config}\n      />\n      <DynamicsSection dynamicsFlow={dynamicsFlow} />\n      <RevisionSection revisionFlow={revisionFlow} />\n      <BackportSection backportFlow={backportFlow} revisionFlow={revisionFlow} />\n      <HistorianSection historianFlow={historianFlow} revisionFlow={revisionFlow} />\n      <EntityModals\n        worldSchema={props.worldSchema}\n        handleRenameApplied={props.handleRenameApplied}\n        handleCreateEntity={props.handleCreateEntity}\n        handleEditEntity={props.handleEditEntity}\n      />\n      <ToneAndAnnotationModals />\n      <ThinkingViewer />\n      <FloatingPills onNavigate={props.setActiveTab} />\n    </>\n  );\n}", "parameters": [{"name": "{\n  revisionFlow,\n  backportFlow,\n  historianFlow,\n  dynamicsFlow,\n  ...props\n}", "type": "{ [x: string]: any; revisionFlow: any; backportFlow: any; historianFlow: any; dynamicsFlow: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorSidebar.jsx", "sourceCode": "export default function IlluminatorSidebar({\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}) {\n  return (\n    <div className=\"illuminator-sidebar\">\n      <nav className=\"illuminator-nav\">\n        {TABS.map((tab) => (\n          <NavButton\n            key={tab.id}\n            tab={tab}\n            activeTab={activeTab}\n            setActiveTab={setActiveTab}\n            stats={stats}\n          />\n        ))}\n      </nav>\n\n      <div className=\"isb-spacer\" />\n\n      {/* Image Settings trigger */}\n      <div className=\"isb-image-settings\">\n        <ImageSettingsTrigger\n          settings={imageGenSettings}\n          styleLibrary={styleLibrary}\n          onClick={() => useIlluminatorModals.getState().openImageSettings()}\n        />\n      </div>\n\n      {/* API Key section */}\n      <ApiKeySection\n        showApiKeyInput={showApiKeyInput}\n        setShowApiKeyInput={setShowApiKeyInput}\n        hasRequiredKeys={hasRequiredKeys}\n        anthropicApiKey={anthropicApiKey}\n        setAnthropicApiKey={setAnthropicApiKey}\n        openaiApiKey={openaiApiKey}\n        setOpenaiApiKey={setOpenaiApiKey}\n        persistApiKeys={persistApiKeys}\n        setPersistApiKeys={setPersistApiKeys}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  activeTab,\n  setActiveTab,\n  stats,\n  imageGenSettings,\n  styleLibrary,\n  showApiKeyInput,\n  setShowApiKeyInput,\n  hasRequiredKeys,\n  anthropicApiKey,\n  setAnthropicApiKey,\n  openaiApiKey,\n  setOpenaiApiKey,\n  persistApiKeys,\n  setPersistApiKeys,\n}", "type": "{ activeTab: any; setActiveTab: any; stats: any; imageGenSettings: any; styleLibrary: any; showApiKeyInput: any; setShowApiKeyInput: any; hasRequiredKeys: any; anthropicApiKey: any; setAnthropicApiKey: any; openaiApiKey: any; setOpenaiApiKey: any; persistApiKeys: any; setPersistApiKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/IlluminatorTabContent.jsx", "sourceCode": "export default function IlluminatorTabContent({ activeTab, ...props }) {\n  const TabComponent = TAB_COMPONENTS[activeTab];\n  return TabComponent ? <TabComponent {...props} /> : null;\n}", "parameters": [{"name": "{ activeTab, ...props }", "type": "{ [x: string]: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageModal.jsx", "sourceCode": "export default function ImageModal({ isOpen, imageId, title, onClose }) {\n  const { url: imageUrl, loading, error, metadata } = useImageUrl(isOpen ? imageId : null);\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  // Close on escape key\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener(\"keydown\", handleKeyDown);\n      // Prevent body scroll when modal is open\n      document.body.style.overflow = \"hidden\";\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen) return null;\n\n  const hasSidebar = sidebarOpen && metadata;\n\n  return (\n    <div className=\"imod-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      {/* Header with title and close button */}\n      <div\n        className={`imod-header ${hasSidebar ? \"imod-header-sidebar-open\" : \"imod-header-sidebar-closed\"}`}\n        onClick={(e) => e.stopPropagation()}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n      >\n        <h3 className=\"imod-title\">{title}</h3>\n        <button onClick={onClose} className=\"imod-close-btn\">\n          Close (Esc)\n        </button>\n      </div>\n\n      {/* Image container - adjusted for sidebar */}\n      <div\n        className={`imod-image-container ${hasSidebar ? \"imod-image-container-sidebar-open\" : \"imod-image-container-sidebar-closed\"}`}\n      >\n        {loading && (\n          <div className=\"imod-loading\">Loading image...</div>\n        )}\n        {!loading && (error || !imageUrl) && (\n          <div className=\"imod-error\">\n            <div className=\"imod-error-title\">Image not available</div>\n            <div className=\"imod-error-detail\">{error || \"Image not found in storage\"}</div>\n          </div>\n        )}\n        {!loading && !error && imageUrl && (\n          <img\n            src={imageUrl}\n            alt={title}\n            className=\"imod-full-image\"\n            onClick={(e) => e.stopPropagation()}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          />\n        )}\n      </div>\n\n      {/* Metadata sidebar */}\n      <MetadataSidebar\n        metadata={metadata}\n        isOpen={sidebarOpen}\n        onToggle={() => setSidebarOpen(!sidebarOpen)}\n      />\n\n      {/* Hint at bottom */}\n      <div\n        className={`imod-hint ${hasSidebar ? \"imod-hint-sidebar-open\" : \"imod-hint-sidebar-closed\"}`}\n      >\n        Click anywhere or press Escape to close\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, imageId, title, onClose }", "type": "{ isOpen: any; imageId: any; title: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImagePickerModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImagePickerModal.jsx", "sourceCode": "export default function ImagePickerModal({\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}) {\n  const [images, setImages] = useState([]);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n  const [loading, setLoading] = useState(true);\n  const [selectedImageId, setSelectedImageId] = useState(null);\n  const [filterKind, setFilterKind] = useState(\"all\");\n  const [filterCulture, setFilterCulture] = useState(\"all\");\n  const [filterModel, setFilterModel] = useState(\"all\");\n  const [searchText, setSearchText] = useState(\"\");\n  const [expandedPrompt, setExpandedPrompt] = useState(null);\n  const [filterOptions, setFilterOptions] = useState({ kinds: [], cultures: [], models: [] });\n\n  // Load filter options when modal opens\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadFilterOptions() {\n      try {\n        const [kinds, cultures, models] = await Promise.all([\n          getImageFilterOptions(\"entity-kind\"),\n          getImageFilterOptions(\"entityCulture\"),\n          getImageFilterOptions(\"model\"),\n        ]);\n        setFilterOptions({ kinds, cultures, models });\n      } catch (err) {\n        console.error(\"Failed to load filter options:\", err);\n      }\n    }\n\n    loadFilterOptions();\n    // Reset filters on open\n    setFilterKind(\"all\");\n    setFilterCulture(\"all\");\n    setFilterModel(\"all\");\n    setSearchText(\"\");\n  }, [isOpen]);\n\n  // Load images when filters change\n  useEffect(() => {\n    if (!isOpen) return;\n\n    async function loadData() {\n      setLoading(true);\n      try {\n        const filters = {};\n        if (filterKind !== \"all\") filters.entityKind = filterKind;\n        if (filterCulture !== \"all\") filters.entityCulture = filterCulture;\n        if (filterModel !== \"all\") filters.model = filterModel;\n        if (searchText.trim()) filters.searchText = searchText.trim();\n\n        const results = await searchImages(filters);\n        setImages(results);\n      } catch (err) {\n        console.error(\"Failed to load images:\", err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [isOpen, filterKind, filterCulture, filterModel, searchText]);\n\n  // Handle selection\n  const handleSelect = useCallback(() => {\n    if (selectedImageId && onSelect) {\n      // Find the selected image to get its metadata\n      const selectedImage = images.find((img) => img.imageId === selectedImageId);\n      onSelect(selectedImageId, selectedImage);\n    }\n    onClose();\n  }, [selectedImageId, images, onSelect, onClose]);\n\n  // Handle close\n  const handleClose = useCallback(() => {\n    setSelectedImageId(null);\n    setExpandedPrompt(null);\n    onClose();\n  }, [onClose]);\n\n  // Close on escape key\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleKeyDown = (e) => {\n      if (e.key === \"Escape\") {\n        handleClose();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    document.body.style.overflow = \"hidden\";\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = \"\";\n    };\n  }, [isOpen, handleClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div\n      className=\"illuminator-modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"illuminator-modal ipm-modal\">\n        <div className=\"illuminator-modal-header\">\n          <h3>Select Image from Library</h3>\n          <button onClick={handleClose} className=\"illuminator-modal-close\">\n            &times;\n          </button>\n        </div>\n\n        <div className=\"illuminator-modal-body ipm-body\">\n          {/* Filters */}\n          <div className=\"ipm-filters\">\n            <div>\n              <label htmlFor=\"search\" className=\"ipm-filter-label\">Search</label>\n              <input id=\"search\"\n                type=\"text\"\n                value={searchText}\n                onChange={(e) => setSearchText(e.target.value)}\n                placeholder=\"Name or prompt...\"\n                className=\"illuminator-input ipm-search-input\"\n              />\n            </div>\n\n            <div>\n              <label htmlFor=\"entity-kind\" className=\"ipm-filter-label\">Entity Kind</label>\n              <select id=\"entity-kind\"\n                value={filterKind}\n                onChange={(e) => setFilterKind(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Kinds</option>\n                {filterOptions.kinds.map((kind) => (\n                  <option key={kind} value={kind}>\n                    {kind}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"culture\" className=\"ipm-filter-label\">Culture</label>\n              <select id=\"culture\"\n                value={filterCulture}\n                onChange={(e) => setFilterCulture(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Cultures</option>\n                {filterOptions.cultures.map((culture) => (\n                  <option key={culture} value={culture}>\n                    {culture}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label htmlFor=\"model\" className=\"ipm-filter-label\">Model</label>\n              <select id=\"model\"\n                value={filterModel}\n                onChange={(e) => setFilterModel(e.target.value)}\n                className=\"illuminator-select ipm-filter-select\"\n              >\n                <option value=\"all\">All Models</option>\n                {filterOptions.models.map((model) => (\n                  <option key={model} value={model}>\n                    {model}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"ipm-filter-count-wrapper\">\n              <span className=\"ipm-filter-count\">{images.length} images</span>\n            </div>\n          </div>\n\n          {/* Image grid */}\n          <div className=\"ipm-grid-container\">\n            {loading && (\n              <div className=\"ipm-loading\">Loading images...</div>\n            )}\n            {!loading && images.length === 0 && (\n              <div className=\"ipm-empty\">\n                No images found. Try adjusting the filters or generate some images first.\n              </div>\n            )}\n            {!loading && images.length > 0 && (\n              <div className=\"ipm-grid\">\n                {images.map((img) => {\n                  const isSelected = selectedImageId === img.imageId;\n                  const isCurrent = currentImageId === img.imageId;\n\n                  return (\n                    <div\n                      key={img.imageId}\n                      onClick={() => setSelectedImageId(img.imageId)}\n                      className={`ipm-card ${isSelected ? \"ipm-card-selected\" : \"\"} ${isCurrent ? \"ipm-card-current\" : \"\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {/* Current badge */}\n                      {isCurrent && <div className=\"ipm-current-badge\">CURRENT</div>}\n\n                      {/* Thumbnail \u2014 lazy-loaded via IntersectionObserver */}\n                      <LazyThumbnail\n                        imageId={img.imageId}\n                        alt={img.entityName || img.imageId}\n                        className=\"ipm-thumbnail-wrapper\"\n                      />\n\n                      {/* Info */}\n                      <div className=\"ipm-card-info\">\n                        <div className=\"ipm-card-name\" title={img.entityName}>\n                          {img.entityName || \"Unknown\"}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {img.entityKind}\n                          {img.entityCulture && ` \u00b7 ${img.entityCulture}`}\n                        </div>\n                        <div className=\"ipm-card-meta\">\n                          {formatDate(img.generatedAt)} \u00b7 {formatBytes(img.size || 0)}\n                        </div>\n\n                        {/* Prompt preview */}\n                        {(img.finalPrompt || img.originalPrompt) && (\n                          <div\n                            className={`ipm-card-prompt ${expandedPrompt === img.imageId ? \"ipm-card-prompt-expanded\" : \"ipm-card-prompt-collapsed\"}`}\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              setExpandedPrompt(\n                                expandedPrompt === img.imageId ? null : img.imageId\n                              );\n                            }}\n                            title=\"Click to expand/collapse prompt\"\n                            role=\"button\"\n                            tabIndex={0}\n                            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                          >\n                            {img.finalPrompt || img.originalPrompt}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"illuminator-modal-footer ipm-footer\">\n          <button onClick={handleClose} className=\"illuminator-btn\">\n            Cancel\n          </button>\n          <button\n            onClick={handleSelect}\n            disabled={!selectedImageId || selectedImageId === currentImageId}\n            className=\"illuminator-btn illuminator-btn-primary\"\n          >\n            {selectedImageId === currentImageId ? \"Already Assigned\" : \"Assign Image\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  onSelect,\n  entityKind: _entityKind,\n  entityCulture: _entityCulture,\n  currentImageId,\n}", "type": "{ isOpen: any; onClose: any; onSelect: any; entityKind: any; entityCulture: any; currentImageId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageRefPicker.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageRefPicker.jsx", "sourceCode": "export default function ImageRefPicker({ projectId, onSelect, onClose }) {\n  const [images, setImages] = useState([]);\n  const [imageUrls, setImageUrls] = useState({}); // imageId -> dataUrl cache\n  const [loading, setLoading] = useState(false);\n  const [search, setSearch] = useState(\"\");\n  const [debouncedSearch, setDebouncedSearch] = useState(\"\");\n  const [caption, setCaption] = useState(\"\");\n  const [selectedImage, setSelectedImage] = useState(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [total, setTotal] = useState(0);\n  const searchTimeoutRef = useRef(null);\n\n  // Debounce search input\n  useEffect(() => {\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n    searchTimeoutRef.current = setTimeout(() => {\n      setDebouncedSearch(search);\n    }, 300);\n\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, [search]);\n\n  // Load images when search changes\n  useEffect(() => {\n    let cancelled = false;\n\n    async function loadImages() {\n      setLoading(true);\n      try {\n        const result = await searchImages({\n          projectId,\n          search: debouncedSearch || undefined,\n          limit: PAGE_SIZE,\n          offset: 0,\n        });\n\n        if (cancelled) return;\n\n        setImages(result.items);\n        setHasMore(result.hasMore);\n        setTotal(result.total);\n        setSelectedImage(null);\n        setCaption(\"\");\n      } catch (err) {\n        console.error(\"Failed to search images:\", err);\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    }\n\n    loadImages();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, debouncedSearch]);\n\n  // Load more images (pagination)\n  const handleLoadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const result = await searchImages({\n        projectId,\n        search: debouncedSearch || undefined,\n        limit: PAGE_SIZE,\n        offset: images.length,\n      });\n\n      setImages((prev) => [...prev, ...result.items]);\n      setHasMore(result.hasMore);\n    } catch (err) {\n      console.error(\"Failed to load more images:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, [projectId, debouncedSearch, images.length, loading, hasMore]);\n\n  // Lazy load image thumbnail when it comes into view\n  const loadImageUrl = useCallback(\n    async (imageId) => {\n      if (imageUrls[imageId]) return; // Already loaded\n\n      try {\n        const dataUrl = await getImageDataUrl(imageId);\n        if (dataUrl) {\n          setImageUrls((prev) => ({ ...prev, [imageId]: dataUrl }));\n        }\n      } catch (err) {\n        console.warn(`Failed to load image ${imageId}:`, err);\n      }\n    },\n    [imageUrls]\n  );\n\n  const handleInsert = () => {\n    if (!selectedImage) return;\n    const imageRef = caption\n      ? `![${caption}](image:${selectedImage.imageId})`\n      : `![](image:${selectedImage.imageId})`;\n    onSelect(imageRef);\n    onClose();\n  };\n\n  return (\n    <ModalShell onClose={onClose} title=\"Insert Image\" className=\"image-picker-modal\">\n      <div className=\"image-picker-toolbar\">\n        <input\n          type=\"text\"\n          value={search}\n          onChange={(e) => setSearch(e.target.value)}\n          placeholder=\"Search by entity name...\"\n          className=\"static-page-search-input\"\n          // eslint-disable-next-line jsx-a11y/no-autofocus\n          autoFocus\n        />\n        {total > 0 && <span className=\"image-picker-count\">{total} images</span>}\n      </div>\n\n      {loading && images.length === 0 && (\n        <div className=\"image-picker-loading\">Searching images...</div>\n      )}\n      {!(loading && images.length === 0) && images.length === 0 && (\n        <div className=\"image-picker-empty\">\n          {search ? \"No images match your search\" : \"No images available\"}\n        </div>\n      )}\n      {images.length > 0 && (\n        <>\n          <div className=\"image-picker-grid\">\n            {images.map((img) => (\n              <ImageThumbnail\n                key={img.imageId}\n                image={img}\n                dataUrl={imageUrls[img.imageId]}\n                isSelected={selectedImage?.imageId === img.imageId}\n                onSelect={() => setSelectedImage(img)}\n                onVisible={() => loadImageUrl(img.imageId)}\n              />\n            ))}\n          </div>\n\n          {hasMore && (\n            <button\n              className=\"static-page-button image-picker-load-more\"\n              onClick={() => void handleLoadMore()}\n              disabled={loading}\n            >\n              {loading ? \"Loading...\" : `Load more (${images.length} of ${total})`}\n            </button>\n          )}\n        </>\n      )}\n\n      {selectedImage && (\n        <div className=\"image-picker-caption-section\">\n          <label className=\"image-picker-caption-label\">\n            Caption (optional):\n            <input\n              type=\"text\"\n              value={caption}\n              onChange={(e) => setCaption(e.target.value)}\n              placeholder=\"Enter image caption...\"\n              className=\"static-page-search-input\"\n            />\n          </label>\n          <button className=\"static-page-button primary\" onClick={handleInsert}>\n            Insert Image\n          </button>\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{ projectId, onSelect, onClose }", "type": "{ projectId: any; onSelect: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ImageSettingsDrawer.tsx", "sourceCode": "// \u2500\u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ImageSettingsDrawer({\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}: ImageSettingsDrawerProps) {\n  const drawerRef = useRef<HTMLDivElement>(null);\n\n  // Local copy of settings for instant UI feedback.\n  // Changes render immediately here, then propagate to parent via rAF.\n  const [settings, setLocalSettings] = useState(externalSettings);\n  const pendingFlush = useRef<number | null>(null);\n\n  // Sync local state when external settings change (e.g. on mount or external update)\n  useEffect(() => {\n    setLocalSettings(externalSettings);\n  }, [externalSettings]);\n\n  // Debounced push to parent \u2014 renders locally first, then flushes\n  const onSettingsChange = useCallback((partial: Partial<ImageGenSettings>) => {\n    setLocalSettings(prev => ({\n      ...prev,\n      ...partial\n    }));\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n    pendingFlush.current = requestAnimationFrame(() => {\n      pendingFlush.current = null;\n      externalOnChange(partial);\n    });\n  }, [externalOnChange]);\n\n  // Cleanup on unmount\n  useEffect(() => () => {\n    if (pendingFlush.current !== null) cancelAnimationFrame(pendingFlush.current);\n  }, []);\n\n  // Close on Escape\n  useEffect(() => {\n    if (!isOpen) return;\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") onClose();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [isOpen, onClose]);\n\n  // Section collapse state\n  const collapsedSet = useMemo(() => new Set(settings.collapsedSections), [settings.collapsedSections]);\n  const toggleSection = useCallback((key: string) => {\n    const next = new Set(collapsedSet);\n    if (next.has(key)) next.delete(key);else next.add(key);\n    onSettingsChange({\n      collapsedSections: Array.from(next)\n    });\n  }, [collapsedSet, onSettingsChange]);\n\n  // Group compositions by category\n  const groupedCompositions = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.compositionStyles>();\n    const map = new Map<string, typeof styleLibrary.compositionStyles>();\n    for (const style of styleLibrary.compositionStyles) {\n      const cat = style.targetCategory || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Group artistic styles by category\n  const groupedArtisticStyles = useMemo(() => {\n    if (!styleLibrary) return new Map<string, typeof styleLibrary.artisticStyles>();\n    const map = new Map<string, typeof styleLibrary.artisticStyles>();\n    for (const style of styleLibrary.artisticStyles) {\n      const cat = style.category || \"other\";\n      if (!map.has(cat)) map.set(cat, []);\n      map.get(cat).push(style);\n    }\n    return map;\n  }, [styleLibrary]);\n\n  // Derive initial category tab from current selection\n  const selectedCompositionCategory = useMemo(() => {\n    if (!styleLibrary) return COMPOSITION_CATEGORY_ORDER[0];\n    const selected = styleLibrary.compositionStyles.find(s => s.id === settings.compositionStyleId);\n    return selected?.targetCategory || COMPOSITION_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.compositionStyleId]);\n  const selectedArtisticCategory = useMemo(() => {\n    if (!styleLibrary) return ARTISTIC_CATEGORY_ORDER[0];\n    const selected = styleLibrary.artisticStyles.find(s => s.id === settings.artisticStyleId);\n    return selected?.category || ARTISTIC_CATEGORY_ORDER[0];\n  }, [styleLibrary, settings.artisticStyleId]);\n\n  // Active category tabs \u2014 initialized from selection, then user-controllable\n  const [activeCompositionCategory, setActiveCompositionCategory] = useState(selectedCompositionCategory);\n  const [activeArtisticCategory, setActiveArtisticCategory] = useState(selectedArtisticCategory);\n\n  // Sync tab when selection changes to a different category (e.g. picking from a different tab)\n  useEffect(() => {\n    setActiveCompositionCategory(selectedCompositionCategory);\n  }, [selectedCompositionCategory]);\n  useEffect(() => {\n    setActiveArtisticCategory(selectedArtisticCategory);\n  }, [selectedArtisticCategory]);\n\n  // Available category tabs (only those with styles)\n  const availableCompositionCategories = useMemo(() => {\n    return COMPOSITION_CATEGORY_ORDER.filter(cat => groupedCompositions.has(cat));\n  }, [groupedCompositions]);\n  const availableArtisticCategories = useMemo(() => {\n    return ARTISTIC_CATEGORY_ORDER.filter(cat => groupedArtisticStyles.has(cat));\n  }, [groupedArtisticStyles]);\n\n  // Resolve display names for badge\n  const artisticName = useMemo(() => {\n    if (settings.artisticStyleId === RANDOM_ID) return \"Random\";\n    if (settings.artisticStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.artisticStyles.find(s => s.id === settings.artisticStyleId)?.name || settings.artisticStyleId;\n  }, [settings.artisticStyleId, styleLibrary]);\n  const compositionName = useMemo(() => {\n    if (settings.compositionStyleId === RANDOM_ID) return \"Random\";\n    if (settings.compositionStyleId === NONE_ID) return \"None\";\n    return styleLibrary?.compositionStyles.find(s => s.id === settings.compositionStyleId)?.name || settings.compositionStyleId;\n  }, [settings.compositionStyleId, styleLibrary]);\n  const paletteName = useMemo(() => {\n    if (settings.colorPaletteId === RANDOM_ID) return \"Random\";\n    if (settings.colorPaletteId === NONE_ID) return \"None\";\n    return styleLibrary?.colorPalettes.find(s => s.id === settings.colorPaletteId)?.name || settings.colorPaletteId;\n  }, [settings.colorPaletteId, styleLibrary]);\n\n  // Group palettes by pre-defined groups\n  const palettesByGroup = useMemo(() => {\n    if (!styleLibrary) return [];\n    const paletteMap = new Map(styleLibrary.colorPalettes.map(p => [p.id, p]));\n    return PALETTE_GROUPS.map(group => ({\n      label: group.label,\n      palettes: group.ids.map(id => paletteMap.get(id)).filter(Boolean)\n    })).filter(g => g.palettes.length > 0);\n  }, [styleLibrary]);\n\n  // Size/quality options for current model\n  const sizeOptions = useMemo(() => getSizeOptions(imageModel), [imageModel]);\n  const qualityOptions = useMemo(() => getQualityOptions(imageModel), [imageModel]);\n\n  // Is the current selection a special value?\n  const isSpecialArtistic = settings.artisticStyleId === RANDOM_ID || settings.artisticStyleId === NONE_ID;\n  const isSpecialComposition = settings.compositionStyleId === RANDOM_ID || settings.compositionStyleId === NONE_ID;\n  const isSpecialPalette = settings.colorPaletteId === RANDOM_ID || settings.colorPaletteId === NONE_ID;\n\n  // Pool count info for random selection with exclusion filtering\n  const artisticPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialComposition) return undefined;\n    const total = styleLibrary.artisticStyles.length;\n    const filtered = filterStylesForComposition(styleLibrary.artisticStyles as any, settings.compositionStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.compositionStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.compositionStyleId, isSpecialComposition]);\n  const compositionPoolInfo = useMemo(() => {\n    if (!styleLibrary || isSpecialArtistic) return undefined;\n    const total = styleLibrary.compositionStyles.length;\n    const filtered = filterCompositionsForStyle(styleLibrary.compositionStyles as any, settings.artisticStyleId, DEFAULT_RANDOM_EXCLUSIONS, styleLibrary.artisticStyles as any);\n    return filtered.length < total ? `(${filtered.length}/${total})` : undefined;\n  }, [styleLibrary, settings.artisticStyleId, isSpecialArtistic]);\n  if (!isOpen) return null;\n  return createPortal(<>\n      {/* Backdrop */}\n      <div onClick={onClose} className=\"isd-backdrop\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") onClose(e);\n    }} />\n\n      {/* Drawer */}\n      <div ref={drawerRef} onClick={e => e.stopPropagation()} className=\"isd-drawer\" role=\"button\" tabIndex={0} onKeyDown={e => {\n      if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n    }}>\n        {/* Header */}\n        <div className=\"isd-header\">\n          <span className=\"isd-header-title\">Image Settings</span>\n          <button onClick={onClose} className=\"isd-close-btn\">\n            &#10005;\n          </button>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"isd-scroll\">\n          {!styleLibrary ? <div className=\"isd-loading\">Loading styles...</div> : <>\n              {/* \u2500\u2500\u2500 Visual Style \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Visual Style\" sectionKey=\"artistic\" collapsed={collapsedSet.has(\"artistic\")} onToggle={toggleSection} badge={artisticName}>\n                <SpecialToggle value={isSpecialArtistic ? settings.artisticStyleId : \"\"} onChange={id => onSettingsChange({\n              artisticStyleId: id\n            })} poolInfo={artisticPoolInfo} />\n\n                {/* Artistic category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableArtisticCategories.map(cat => <button key={cat} onClick={() => setActiveArtisticCategory(cat)} className=\"isd-category-tab\" data-active={activeArtisticCategory === cat}>\n                      {ARTISTIC_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Artistic style list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedArtisticStyles.get(activeArtisticCategory) || []).map(style => {\n                const isSelected = settings.artisticStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  artisticStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Composition \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Composition\" sectionKey=\"composition\" collapsed={collapsedSet.has(\"composition\")} onToggle={toggleSection} badge={compositionName}>\n                <SpecialToggle value={isSpecialComposition ? settings.compositionStyleId : \"\"} onChange={id => onSettingsChange({\n              compositionStyleId: id\n            })} poolInfo={compositionPoolInfo} />\n\n                {/* Category tabs */}\n                <div className=\"isd-category-tabs\">\n                  {availableCompositionCategories.map(cat => <button key={cat} onClick={() => setActiveCompositionCategory(cat)} className=\"isd-category-tab\" data-active={activeCompositionCategory === cat}>\n                      {COMPOSITION_CATEGORY_LABELS[cat] || cat}\n                    </button>)}\n                </div>\n\n                {/* Composition list for active category */}\n                <div className=\"isd-item-list\">\n                  {(groupedCompositions.get(activeCompositionCategory) || []).map(style => {\n                const isSelected = settings.compositionStyleId === style.id;\n                return <button key={style.id} onClick={() => onSettingsChange({\n                  compositionStyleId: style.id\n                })} title={style.promptFragment} className=\"isd-item-btn\" data-selected={isSelected}>\n                        <span className=\"isd-item-name-composition\">{style.name}</span>\n                        {style.description && <span className=\"isd-item-desc\">{style.description}</span>}\n                      </button>;\n              })}\n                </div>\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Color Palette \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Color Palette\" sectionKey=\"palette\" collapsed={collapsedSet.has(\"palette\")} onToggle={toggleSection} badge={paletteName}>\n                <SpecialToggle value={isSpecialPalette ? settings.colorPaletteId : \"\"} onChange={id => onSettingsChange({\n              colorPaletteId: id\n            })} />\n\n                {palettesByGroup.map(group => <div key={group.label} className=\"isd-palette-group\">\n                    <div className=\"isd-palette-group-label\">{group.label}</div>\n                    <div className=\"isd-palette-grid\">\n                      {group.palettes.map(palette => {\n                  const isSelected = settings.colorPaletteId === palette.id;\n                  return <button key={palette.id} onClick={() => onSettingsChange({\n                    colorPaletteId: palette.id\n                  })} title={palette.description} className=\"isd-palette-btn\" data-selected={isSelected}>\n                            {palette.swatchColors && palette.swatchColors.length > 0 && <div className=\"isd-palette-swatch-row\">\n                                <SwatchStrip colors={palette.swatchColors} />\n                              </div>}\n                            <div className=\"isd-palette-name\">{palette.name}</div>\n                          </button>;\n                })}\n                    </div>\n                  </div>)}\n              </CollapsibleSection>\n\n              <div className=\"isd-divider\" />\n\n              {/* \u2500\u2500\u2500 Output Settings \u2500\u2500\u2500 */}\n              <CollapsibleSection title=\"Output\" sectionKey=\"output\" collapsed={collapsedSet.has(\"output\")} onToggle={toggleSection}>\n                {/* Size - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Size</div>\n                  <div className=\"isd-output-btns\">\n                    {sizeOptions.map(opt => {\n                  const isSelected = settings.imageSize === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageSize: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n                })}\n                  </div>\n                </div>\n\n                {/* Quality - segmented buttons */}\n                <div className=\"isd-output-group\">\n                  <div className=\"isd-output-label\">Quality</div>\n                  <div className=\"isd-output-btns\">\n                    {qualityOptions.map(opt => {\n                  const isSelected = settings.imageQuality === opt.value;\n                  return <button key={opt.value} onClick={() => onSettingsChange({\n                    imageQuality: opt.value\n                  })} className=\"isd-output-btn\" data-selected={isSelected}>\n                          {opt.label}\n                        </button>;\n// ... (truncated)", "parameters": [{"name": "{\n  isOpen,\n  onClose,\n  settings: externalSettings,\n  onSettingsChange: externalOnChange,\n  styleLibrary,\n  cultures,\n  imageModel\n}", "type": "ImageSettingsDrawerProps", "optional": false}], "returnType": "React.ReactPortal"}, {"id": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/InterleavedAnnotationModal.jsx", "sourceCode": "export default function InterleavedAnnotationModal({\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}) {\n  const isMinimized = useFloatingPillStore(s => s.isMinimized(PILL_ID));\n  const progressStatus = progress?.status;\n  const processedItems = progress?.processedItems;\n  const totalItems = progress?.totalItems;\n  useEffect(() => {\n    if (!isMinimized || !progress) return;\n    let statusColor;\n    if (progressStatus === \"running\") statusColor = \"#f59e0b\";else if (progressStatus === \"complete\") statusColor = \"#10b981\";else if (progressStatus === \"failed\") statusColor = \"#ef4444\";else statusColor = \"#6b7280\";\n    const statusText = progressStatus === \"running\" ? `${processedItems}/${totalItems}` : progressStatus;\n    useFloatingPillStore.getState().updatePill(PILL_ID, {\n      statusText,\n      statusColor\n    });\n  }, [isMinimized, progress, progressStatus, processedItems, totalItems]);\n  useEffect(() => {\n    if (!progress || progressStatus === \"idle\") {\n      useFloatingPillStore.getState().remove(PILL_ID);\n    }\n  }, [progress, progressStatus]);\n  if (!progress || progress.status === \"idle\") return null;\n  if (isMinimized) return null;\n  const isConfirming = progress.status === \"confirming\";\n  const isTerminal = progress.status === \"complete\" || progress.status === \"cancelled\" || progress.status === \"failed\";\n  const globalPercent = progress.totalItems > 0 ? Math.round(progress.processedItems / progress.totalItems * 100) : 0;\n  return <div className=\"iam-overlay\">\n      <div className=\"iam-dialog\" style={{\n      \"--iam-dialog-width\": isConfirming ? \"560px\" : \"480px\"\n    }}>\n        {/* Header */}\n        <div className=\"iam-header\">\n          <div className=\"iam-header-row\">\n            <h2 className=\"iam-title\">Interleaved Annotation</h2>\n            <div className=\"iam-header-actions\">\n              {!isConfirming && <button onClick={() => useFloatingPillStore.getState().minimize({\n              id: PILL_ID,\n              label: \"Interleaved Annotation\",\n              statusText: progress.status === \"running\" ? `${progress.processedItems}/${progress.totalItems}` : progress.status,\n              statusColor: (() => {\n                if (progress.status === \"running\") return \"#f59e0b\";\n                if (progress.status === \"complete\") return \"#10b981\";\n                return \"#ef4444\";\n              })()\n            })} className=\"illuminator-button iam-minimize-btn\" title=\"Minimize to pill\">\n                  \u2014\n                </button>}\n              <span className=\"iam-status-text\" style={{\n              \"--iam-status-color\": (() => {\n                if (progress.status === \"complete\") return \"#10b981\";\n                if (progress.status === \"failed\") return \"#ef4444\";\n                if (progress.status === \"cancelled\") return \"#f59e0b\";\n                return \"var(--text-muted)\";\n              })()\n            }}>\n                {isConfirming && `${progress.totalItems} items`}\n                {progress.status === \"running\" && `${progress.processedItems}/${progress.totalItems}`}\n                {progress.status === \"complete\" && \"Complete\"}\n                {progress.status === \"cancelled\" && \"Cancelled\"}\n                {progress.status === \"failed\" && \"Failed\"}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Body */}\n        <div className={`iam-body ${isConfirming ? \"iam-body-confirming\" : \"iam-body-processing\"}`}>\n          {/* ---- Confirmation screen ---- */}\n          {isConfirming && <>\n              <div className=\"iam-confirm-info\">\n                Chronicles in chronological order, each followed by its referenced entities. Results\n                auto-applied. Voice digest accumulates across both types.\n                <div className=\"iam-confirm-summary\">\n                  {progress.chronicleCount} chronicles + {progress.entityCount} entities ={\" \"}\n                  {progress.totalItems} total\n                </div>\n              </div>\n\n              {/* Work list \u2014 grouped */}\n              <div className=\"iam-worklist-section\">\n                <div className=\"iam-section-label\">Work List</div>\n\n                <div className=\"iam-worklist\">\n                  {progress.workItems.map(item => {\n                const isChronicle = item.type === \"chronicle\";\n                const toneMeta = TONE_META[item.tone];\n                return <div key={isChronicle ? `c-${item.chronicleId}` : `e-${item.entityId}`} className={`iam-work-item ${isChronicle ? \"iam-work-item-chronicle\" : \"iam-work-item-entity\"}`}>\n                        <div className=\"iam-work-item-left\">\n                          <span className={`iam-work-item-icon ${isChronicle ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                            {isChronicle ? \"\\u25a0\" : \"\\u25cb\"}\n                          </span>\n                          <span className={`iam-work-item-name ${isChronicle ? \"iam-work-item-name-chronicle\" : \"iam-work-item-name-entity\"}`}>\n                            {isChronicle ? item.title : item.entityName}\n                          </span>\n                          {!isChronicle && <span className=\"iam-work-item-kind\">{item.entityKind}</span>}\n                        </div>\n                        <span className=\"iam-work-item-tone\" title={toneMeta?.label || item.tone}>\n                          {toneMeta?.symbol || item.tone}\n                        </span>\n                      </div>;\n              })}\n                </div>\n              </div>\n            </>}\n\n          {/* ---- Processing screen ---- */}\n          {!isConfirming && <>\n              <div className=\"iam-progress-section\">\n                <div className=\"iam-progress-header\">\n                  <span className=\"iam-progress-label\">\n                    Item {Math.min(progress.processedItems + 1, progress.totalItems)} /{\" \"}\n                    {progress.totalItems}\n                  </span>\n                  <span className=\"iam-progress-percent\">{globalPercent}%</span>\n                </div>\n\n                {/* Progress bar */}\n                <div className=\"iam-progress-track\">\n                  <div className=\"iam-progress-fill\" style={{\n                \"--iam-progress-bg\": (() => {\n                  if (progress.status === \"failed\") return \"#ef4444\";\n                  if (progress.status === \"cancelled\") return \"#f59e0b\";\n                  return \"#10b981\";\n                })(),\n                \"--iam-progress-width\": `${globalPercent}%`\n              }} />\n                </div>\n\n                <div className=\"iam-progress-detail\">\n                  <span>\n                    Chronicles: {progress.processedChronicles}/{progress.chronicleCount}\n                    {\" \\u00b7 \"}\n                    Entities: {progress.processedEntities}/{progress.entityCount}\n                  </span>\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-count\">{progress.failedItems.length} failed</span>}\n                </div>\n              </div>\n\n              {/* Current item */}\n              {progress.currentItem && !isTerminal && <div className=\"iam-current-item\">\n                  <div className=\"iam-current-item-header\">\n                    <span className={`iam-current-item-icon ${progress.currentItem.type === \"chronicle\" ? \"iam-work-item-icon-chronicle\" : \"iam-work-item-icon-entity\"}`}>\n                      {progress.currentItem.type === \"chronicle\" ? \"\\u25a0\" : \"\\u25cb\"}\n                    </span>\n                    {progress.currentItem.type === \"chronicle\" ? progress.currentItem.title : progress.currentItem.entityName}\n                    {TONE_META[progress.currentItem.tone] && <span className=\"iam-current-item-tone\">\n                        {TONE_META[progress.currentItem.tone].symbol}\n                      </span>}\n                  </div>\n                  <div className=\"iam-current-item-sub\">\n                    {progress.currentItem.type === \"chronicle\" ? \"Annotating chronicle...\" : \"Annotating entity...\"}\n                  </div>\n                </div>}\n\n              {/* Terminal state messages */}\n              {progress.status === \"complete\" && <div className=\"iam-terminal-complete\">\n                  Annotated {progress.processedChronicles} chronicles and{\" \"}\n                  {progress.processedEntities} entities.\n                  {progress.failedItems.length > 0 && <span className=\"iam-failed-inline\">\n                      {\" \"}\n                      {progress.failedItems.length} failed.\n                    </span>}\n                </div>}\n\n              {progress.status === \"cancelled\" && <div className=\"iam-terminal-cancelled\">\n                  Cancelled after {progress.processedItems} of {progress.totalItems} items (\n                  {progress.processedChronicles} chronicles, {progress.processedEntities} entities).\n                </div>}\n\n              {progress.status === \"failed\" && <div className=\"iam-terminal-failed\">\n                  {progress.error || \"An unexpected error occurred.\"}\n                </div>}\n\n              {/* Failed items list */}\n              {isTerminal && progress.failedItems.length > 0 && <div className=\"iam-failed-section\">\n                  <div className=\"iam-failed-label\">Failed ({progress.failedItems.length})</div>\n                  {progress.failedItems.map((f, i) => <div key={i} className=\"iam-failed-item\">\n                      {f.item.type === \"chronicle\" ? f.item.title : f.item.entityName}: {f.error}\n                    </div>)}\n                </div>}\n\n              {/* Cost */}\n              {progress.totalCost > 0 && <div className=\"iam-cost\">Cost: ${progress.totalCost.toFixed(4)}</div>}\n            </>}\n        </div>\n\n        {/* Footer */}\n        <div className=\"iam-footer\">\n          {isConfirming && <>\n              <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n                Cancel\n              </button>\n              <button onClick={onConfirm} className=\"illuminator-button illuminator-button-primary iam-footer-btn\">\n                Start ({progress.totalItems} items)\n              </button>\n            </>}\n          {!isConfirming && !isTerminal && <button onClick={onCancel} className=\"illuminator-button iam-footer-btn\">\n              Cancel\n            </button>}\n          {isTerminal && <button onClick={onClose} className=\"illuminator-button iam-footer-btn\">\n              Close\n            </button>}\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  progress,\n  onConfirm,\n  onCancel,\n  onClose\n}", "type": "{ progress: any; onConfirm: any; onCancel: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/LLMCallConfigPanel.jsx", "sourceCode": "export default function LLMCallConfigPanel() {\n  const [settings, setSettings] = useState(() => getLLMModelSettings());\n  const [, forceUpdate] = useState(0);\n\n  const overrideCount = getOverrideCount();\n  const callTypesByCategory = getCallTypesByCategory();\n\n  const handleUpdate = useCallback(\n    (callType, config) => {\n      const next = {\n        ...settings,\n        callOverrides: {\n          ...settings.callOverrides,\n        },\n      };\n\n      if (\n        !config.model &&\n        config.thinkingBudget === undefined &&\n        config.maxTokens === undefined &&\n        config.streamTimeout === undefined &&\n        config.disableStreaming === undefined &&\n        config.runInBrowser === undefined\n      ) {\n        delete next.callOverrides[callType];\n      } else {\n        next.callOverrides[callType] = config;\n      }\n\n      setSettings(next);\n      saveLLMModelSettings(next);\n      forceUpdate((n) => n + 1);\n    },\n    [settings]\n  );\n\n  const handleResetAll = useCallback(() => {\n    resetToDefaults();\n    setSettings(getLLMModelSettings());\n    forceUpdate((n) => n + 1);\n  }, []);\n\n  const categories = [\n    \"description\",\n    \"perspective\",\n    \"chronicle\",\n    \"image\",\n    \"palette\",\n    \"dynamics\",\n    \"revision\",\n    \"historian\",\n  ];\n\n  return (\n    <div className=\"illuminator-card llm-config-panel\">\n      <div className=\"llm-config-header\">\n        <div className=\"llm-config-title-row\">\n          <h2 className=\"illuminator-card-title\">LLM Call Configuration</h2>\n          {overrideCount > 0 && (\n            <span className=\"llm-config-override-count\">{overrideCount} modified</span>\n          )}\n        </div>\n        <div className=\"llm-config-actions\">\n          {overrideCount > 0 && (\n            <button onClick={handleResetAll} className=\"llm-config-reset-all\">\n              Reset All\n            </button>\n          )}\n        </div>\n      </div>\n\n      <div className=\"llm-table-container\">\n        <table className=\"llm-table\">\n          <thead>\n            <tr className=\"llm-table-header\">\n              <th className=\"llm-table-th llm-table-th-label\">Call Type</th>\n              <th className=\"llm-table-th llm-table-th-model\">Model</th>\n              <th className=\"llm-table-th llm-table-th-thinking\">Thinking</th>\n              <th className=\"llm-table-th llm-table-th-temp\">Temp</th>\n              <th className=\"llm-table-th llm-table-th-top-p\">Low P</th>\n              <th className=\"llm-table-th llm-table-th-max\">Max Tokens</th>\n              <th className=\"llm-table-th llm-table-th-timeout\">Timeout</th>\n              <th className=\"llm-table-th llm-table-th-sync\">No Stream</th>\n              <th className=\"llm-table-th llm-table-th-browser\">Browser</th>\n              <th className=\"llm-table-th llm-table-th-action\"></th>\n            </tr>\n          </thead>\n          <tbody>\n            {categories.map((category) => {\n              const callTypes = callTypesByCategory[category];\n              return [\n                <CategoryHeader key={`cat-${category}`} category={category} />,\n                ...callTypes.map((callType, idx) => {\n                  const resolved = getCallConfig(callType);\n                  const isDefault = !hasOverrides(callType);\n                  return (\n                    <CallTypeRow\n                      key={callType}\n                      callType={callType}\n                      config={resolved}\n                      isDefault={isDefault}\n                      onUpdate={handleUpdate}\n                      isLast={idx === callTypes.length - 1}\n                    />\n                  );\n                }),\n              ];\n            })}\n          </tbody>\n        </table>\n      </div>\n\n      <div className=\"llm-config-footer\">\n        <span className=\"llm-config-hint\">* = default</span>\n        <span className=\"llm-config-hint\">Hover call type for description</span>\n      </div>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/PrePrintPanel.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/PrePrintPanel.tsx", "sourceCode": "export default function PrePrintPanel({ projectId, simulationRunId }: Readonly<PrePrintPanelProps>) {\n  const navEntities = useEntityNavList();\n  const [activeSubTab, setActiveSubTab] = useState<SubTab>(\"stats\");\n  const [fullEntities, setFullEntities] = useState<PersistedEntity[]>([]);\n  const [chronicles, setChronicles] = useState<ChronicleRecord[]>([]);\n  const [allImages, setAllImages] = useState<ImageMetadataRecord[]>([]);\n  const [staticPages, setStaticPages] = useState<StaticPage[]>([]);\n  const [eraNarratives, setEraNarratives] = useState<EraNarrativeRecord[]>([]);\n  const [treeState, setTreeState] = useState<ContentTreeState | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (!projectId || !simulationRunId) {\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    void Promise.all([\n      getChroniclesForSimulation(simulationRunId),\n      getAllImages(),\n      getStaticPagesForProject(projectId),\n      loadTree(projectId, simulationRunId),\n      getEntitiesForRun(simulationRunId),\n      getEraNarrativesForSimulation(simulationRunId),\n    ]).then(([chrons, allImgs, pages, tree, ents, narrs]) => {\n      if (cancelled) return;\n      setChronicles(chrons);\n      // Keep project-scoped images; further filtering happens in memo below.\n      setAllImages(allImgs.filter((img) => img.projectId === projectId));\n      setStaticPages(pages);\n      setTreeState(tree);\n      setFullEntities(ents);\n      setEraNarratives(narrs);\n      setLoading(false);\n    });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, simulationRunId]);\n\n  const handleTreeChange = useCallback((newTree: ContentTreeState) => {\n    setTreeState(newTree);\n    void saveTree(newTree);\n  }, []);\n\n  // Era order map: eraId \u2192 sort index (by startTick)\n  const eraOrderMap = useMemo(() => {\n    const eraEntities = fullEntities.filter((e) => e.kind === \"era\" && (e as any).temporal);\n    const sorted = [...eraEntities].sort(\n      (a, b) => ((a as any).temporal.startTick || 0) - ((b as any).temporal.startTick || 0)\n    );\n    const map = new Map<string, number>();\n    sorted.forEach((era, index) => {\n      const eraId = (era as any).eraId || era.id;\n      map.set(eraId, index);\n    });\n    return map;\n  }, [fullEntities]);\n\n  const images = useMemo(() => {\n    if (allImages.length === 0) return [];\n\n    const referencedIds = new Set<string>();\n\n    for (const entity of navEntities) {\n      if (entity.imageId) referencedIds.add(entity.imageId);\n    }\n\n    const publishableChronicles = chronicles.filter(\n      (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n    );\n\n    for (const chronicle of publishableChronicles) {\n      const coverId = chronicle.coverImage?.generatedImageId;\n      if (coverId && chronicle.coverImage?.status === \"complete\") {\n        referencedIds.add(coverId);\n      }\n\n      if (chronicle.imageRefs?.refs) {\n        for (const ref of chronicle.imageRefs.refs) {\n          if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    // Era narrative images\n    for (const narr of eraNarratives) {\n      if (narr.coverImage?.status === \"complete\" && narr.coverImage.generatedImageId) {\n        referencedIds.add(narr.coverImage.generatedImageId);\n      }\n      if (narr.imageRefs?.refs) {\n        for (const ref of narr.imageRefs.refs) {\n          if (ref.type === \"chronicle_ref\") {\n            referencedIds.add(ref.imageId);\n          } else if (\n            ref.type === \"prompt_request\" &&\n            ref.status === \"complete\" &&\n            ref.generatedImageId\n          ) {\n            referencedIds.add(ref.generatedImageId);\n          }\n        }\n      }\n    }\n\n    if (referencedIds.size === 0) return [];\n    return allImages.filter((img) => referencedIds.has(img.imageId));\n  }, [allImages, navEntities, chronicles, eraNarratives]);\n\n  if (loading) {\n    return (\n      <div className=\"ppp-empty-state\">\n        Loading pre-print data...\n      </div>\n    );\n  }\n\n  if (!projectId || !simulationRunId) {\n    return (\n      <div className=\"ppp-empty-state\">\n        No active project. Load a simulation run to use pre-print features.\n      </div>\n    );\n  }\n\n  const subTabs: { id: SubTab; label: string }[] = [\n    { id: \"stats\", label: \"Stats\" },\n    { id: \"tree\", label: \"Content Tree\" },\n    { id: \"export\", label: \"Export\" },\n  ];\n\n  return (\n    <div className=\"preprint-panel\">\n      <div className=\"preprint-subtabs\">\n        {subTabs.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => setActiveSubTab(tab.id)}\n            className={`preprint-subtab ${activeSubTab === tab.id ? \"active\" : \"\"}`}\n          >\n            {tab.label}\n          </button>\n        ))}\n      </div>\n\n      <div className=\"preprint-content\">\n        {activeSubTab === \"stats\" && (\n          <StatsView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n          />\n        )}\n\n        {activeSubTab === \"tree\" && (\n          <ContentTreeView\n            entities={fullEntities}\n            chronicles={chronicles}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            eraOrderMap={eraOrderMap}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n            onTreeChange={handleTreeChange}\n          />\n        )}\n\n        {activeSubTab === \"export\" && (\n          <ExportView\n            entities={fullEntities}\n            chronicles={chronicles}\n            images={images}\n            staticPages={staticPages}\n            eraNarratives={eraNarratives}\n            treeState={treeState}\n            projectId={projectId}\n            simulationRunId={simulationRunId}\n          />\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, simulationRunId }", "type": "Readonly<PrePrintPanelProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ProgressPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ProgressPanel.jsx", "sourceCode": "export default function ProgressPanel({\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}) {\n  const isRunning = status === \"running\";\n  const isPaused = status === \"paused\";\n  const isIdle = status === \"idle\";\n  const isComplete = status === \"complete\";\n  const completedTasks = useMemo(() => tasks.filter(t => t.status === \"complete\"), [tasks]);\n  const errorTasks = useMemo(() => tasks.filter(t => t.status === \"error\"), [tasks]);\n  const runningTasks = useMemo(() => tasks.filter(t => t.status === \"running\"), [tasks]);\n  const pendingTasks = useMemo(() => tasks.filter(t => t.status === \"pending\"), [tasks]);\n  const progressPercent = progress.total > 0 ? Math.round(progress.completed / progress.total * 100) : 0;\n  return <div>\n      {/* Status card */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Progress</h2>\n          <div className=\"pp-button-group\">\n            {isIdle && <button onClick={onRunAll} className=\"illuminator-button\" disabled={!hasRequiredKeys || pendingTasks.length === 0}>\n                Start Enrichment\n              </button>}\n            {isRunning && <button onClick={onPause} className=\"illuminator-button illuminator-button-secondary\">\n                Pause\n              </button>}\n            {isPaused && <button onClick={onResume} className=\"illuminator-button\">\n                Resume\n              </button>}\n            {(isRunning || isPaused) && <button onClick={onAbort} className=\"pp-abort-btn\">\n                Abort\n              </button>}\n          </div>\n        </div>\n\n        {!hasRequiredKeys && isIdle && <div className=\"pp-key-warning\">Set API keys in the sidebar to start enrichment</div>}\n\n        {/* Progress bar */}\n        <div className=\"pp-progress-section\">\n          <div className=\"pp-progress-header\">\n            <span className=\"pp-progress-completed\">\n              {progress.completed} / {progress.total} tasks\n            </span>\n            <span className=\"pp-progress-percent\">{progressPercent}%</span>\n          </div>\n          <div className=\"illuminator-progress\">\n            <div className=\"illuminator-progress-bar\" style={{\n            \"--pp-bar-width\": `${progressPercent}%`\n          }} />\n          </div>\n        </div>\n\n        {/* Current task */}\n        {runningTasks.length > 0 && <div className=\"pp-current-task\">\n            <div className=\"pp-current-task-label\">Currently processing:</div>\n            {runningTasks.map(task => <div key={task.id} className=\"pp-current-task-item\">\n                {task.entityName} - {task.type}\n              </div>)}\n          </div>}\n\n        {/* Stats */}\n        <div className=\"pp-stats-grid\">\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{completedTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-completed\">Completed</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{runningTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-running\">Running</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className=\"pp-stat-value\">{pendingTasks.length}</div>\n            <div className=\"pp-stat-label pp-stat-label-pending\">Pending</div>\n          </div>\n          <div className=\"pp-stat-card\">\n            <div className={`pp-stat-value${errorTasks.length > 0 ? \" pp-stat-value-danger\" : \"\"}`}>\n              {errorTasks.length}\n            </div>\n            <div className=\"pp-stat-label pp-stat-label-errors\">Errors</div>\n          </div>\n        </div>\n      </div>\n\n      {/* Error log */}\n      {errorTasks.length > 0 && <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title pp-error-title\">Errors ({errorTasks.length})</h2>\n          </div>\n          <div className=\"pp-error-list\">\n            {errorTasks.map(task => <div key={task.id} className=\"pp-error-item\">\n                <div className=\"pp-error-item-name\">\n                  {task.entityName} - {task.type}\n                </div>\n                <div className=\"pp-error-item-message\">{task.error || \"Unknown error\"}</div>\n              </div>)}\n          </div>\n        </div>}\n\n      {/* Completion message */}\n      {isComplete && <div className=\"illuminator-card\">\n          <div className=\"pp-complete-section\">\n            <div className=\"pp-complete-icon\">&#x2728;</div>\n            <div className=\"pp-complete-title\">Enrichment Complete!</div>\n            <div className=\"pp-complete-summary\">\n              {completedTasks.length} tasks completed\n              {errorTasks.length > 0 && `, ${errorTasks.length} errors`}\n            </div>\n          </div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  status,\n  progress,\n  tasks,\n  onPause,\n  onResume,\n  onAbort,\n  onRunAll,\n  hasRequiredKeys\n}", "type": "{ status: any; progress: any; tasks: any; onPause: any; onResume: any; onAbort: any; onRunAll: any; hasRequiredKeys: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/QuickCheckModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/QuickCheckModal.jsx", "sourceCode": "// ---------------------------------------------------------------------------\n// QuickCheckModal\n// ---------------------------------------------------------------------------\n\nexport default function QuickCheckModal({\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}) {\n  if (!report) return null;\n  const {\n    suspects,\n    assessment,\n    summary\n  } = report;\n  return <div className=\"qcm-overlay\" onClick={e => {\n    if (e.target === e.currentTarget) onClose();\n  }} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }}>\n      <div className=\"qcm-dialog\">\n        {/* Header */}\n        <div className=\"qcm-header\">\n          <div>\n            <div className=\"qcm-header-title\">Quick Check \u2014 Unanchored References</div>\n            <div className=\"qcm-header-subtitle\">\n              <span className=\"qcm-assessment-label\"\n            style={{\n              \"--qcm-assessment-color\": ASSESSMENT_COLORS[assessment] || \"var(--text-muted)\"\n            }}>\n                {ASSESSMENT_LABELS[assessment] || assessment}\n              </span>{\" \"}\n              &bull; {suspects.length} suspect{suspects.length !== 1 ? \"s\" : \"\"}\n            </div>\n          </div>\n          <button onClick={onClose} className=\"qcm-close-btn\">\n            {\"\\u2715\"}\n          </button>\n        </div>\n\n        {/* Summary */}\n        <div className=\"qcm-summary\">{summary}</div>\n\n        {/* Suspects list */}\n        <div className=\"qcm-suspects-list\">\n          {suspects.length === 0 ? <div className=\"qcm-empty-message\">No unanchored references detected.</div> : suspects.map((suspect, i) => <SuspectCard key={i} suspect={suspect} entities={entities} onCreateEntity={onCreateEntity} />)}\n        </div>\n\n        {/* Footer */}\n        <div className=\"qcm-footer\">\n          <button onClick={onClose} className=\"illuminator-button qcm-footer-btn\">\n            Dismiss\n          </button>\n        </div>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  report,\n  entities,\n  onCreateEntity,\n  onClose\n}", "type": "{ report: any; entities: any; onCreateEntity: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ResultsPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ResultsPanel.jsx", "sourceCode": "export default function ResultsPanel({ tasks, entities = [], onRegenerateTask }) {\n  const [selectedEntities, setSelectedEntities] = useState(new Set());\n  const [previewImage, setPreviewImage] = useState(null);\n  const [filterType, setFilterType] = useState(\"all\");\n  const effectiveProminenceScale = useMemo(() => {\n    const values = (entities || [])\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [entities]);\n\n  // Get entities with completed tasks\n  const enrichedEntities = useMemo(() => {\n    const entityMap = new Map();\n\n    // Build entity map from world data\n    for (const entity of entities || []) {\n      entityMap.set(entity.id, { ...entity, tasks: [] });\n    }\n\n    // Add tasks to entities\n    for (const task of tasks) {\n      if (task.status === \"complete\" && entityMap.has(task.entityId)) {\n        entityMap.get(task.entityId).tasks.push(task);\n      }\n    }\n\n    // Filter to only entities with completed tasks\n    return Array.from(entityMap.values()).filter((e) => e.tasks.length > 0);\n  }, [entities, tasks]);\n\n  // Apply filter\n  const filteredEntities = useMemo(() => {\n    if (filterType === \"all\") return enrichedEntities;\n    return enrichedEntities.filter((e) => e.tasks.some((t) => t.type === filterType));\n  }, [enrichedEntities, filterType]);\n\n  const toggleSelect = (entityId) => {\n    setSelectedEntities((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) {\n        next.delete(entityId);\n      } else {\n        next.add(entityId);\n      }\n      return next;\n    });\n  };\n\n  const regenerateSelected = () => {\n    const taskIds = [];\n    for (const entityId of selectedEntities) {\n      const entity = enrichedEntities.find((e) => e.id === entityId);\n      if (entity) {\n        for (const task of entity.tasks) {\n          taskIds.push(task.id);\n        }\n      }\n    }\n    if (taskIds.length > 0) {\n      onRegenerateTask(taskIds);\n    }\n  };\n\n  const totalImages = tasks.filter((t) => t.type === \"image\" && t.status === \"complete\").length;\n  const totalDescriptions = tasks.filter(\n    (t) => t.type === \"description\" && t.status === \"complete\"\n  ).length;\n\n  return (\n    <div>\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Enrichment Results</h2>\n          <span className=\"rp-autosave-note\">Changes auto-save to current slot</span>\n        </div>\n\n        {enrichedEntities.length === 0 ? (\n          <div className=\"rp-empty-state\">\n            No enrichment results yet. Run some tasks to see results here.\n          </div>\n        ) : (\n          <>\n            {/* Stats */}\n            <div className=\"rp-stats-bar\">\n              <div>\n                <span className=\"rp-stat-value\">{enrichedEntities.length}</span>\n                <span className=\"rp-stat-label\">entities</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalDescriptions}</span>\n                <span className=\"rp-stat-label\">descriptions</span>\n              </div>\n              <div>\n                <span className=\"rp-stat-value\">{totalImages}</span>\n                <span className=\"rp-stat-label\">images</span>\n              </div>\n\n              <div className=\"rp-filter-wrapper\">\n                <select\n                  value={filterType}\n                  onChange={(e) => setFilterType(e.target.value)}\n                  className=\"illuminator-select rp-filter-select\"\n                >\n                  <option value=\"all\">All Types</option>\n                  <option value=\"description\">Descriptions</option>\n                  <option value=\"image\">Images</option>\n                </select>\n              </div>\n            </div>\n\n            {/* Entity cards */}\n            <div>\n              {filteredEntities.map((entity) => (\n                <EntityResultCard\n                  key={entity.id}\n                  entity={entity}\n                  tasks={entity.tasks}\n                  selected={selectedEntities.has(entity.id)}\n                  onToggleSelect={() => toggleSelect(entity.id)}\n                  onRegenerate={onRegenerateTask}\n                  onPreviewImage={setPreviewImage}\n                  prominenceScale={effectiveProminenceScale}\n                />\n              ))}\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Selection actions */}\n      {selectedEntities.size > 0 && (\n        <div className=\"rp-selection-bar\">\n          <span className=\"rp-selection-count\">\n            {selectedEntities.size} entit{selectedEntities.size !== 1 ? \"ies\" : \"y\"} selected\n          </span>\n          <div className=\"rp-selection-actions\">\n            <button\n              onClick={() => setSelectedEntities(new Set())}\n              className=\"illuminator-button illuminator-button-secondary\"\n            >\n              Clear\n            </button>\n            <button onClick={regenerateSelected} className=\"illuminator-button\">\n              Regenerate Selected\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Image preview modal */}\n      <ImagePreviewModal imageUrl={previewImage} onClose={() => setPreviewImage(null)} />\n    </div>\n  );\n}", "parameters": [{"name": "{ tasks, entities = [], onRegenerateTask }", "type": "{ tasks: any; entities?: any[]; onRegenerateTask: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/RevisionFilterModal.jsx", "sourceCode": "export default function RevisionFilterModal({\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}) {\n  const [excludeChronicle, setExcludeChronicle] = useState(true);\n\n  if (!isOpen) return null;\n\n  const available = excludeChronicle ? totalEligible - usedInChronicles : totalEligible;\n\n  const footer = (\n    <>\n      <button\n        onClick={onCancel}\n        className=\"illuminator-button illuminator-button-secondary rfm-footer-btn\"\n      >\n        Cancel\n      </button>\n      <button\n        onClick={() => onStart(excludeChronicle)}\n        disabled={available === 0}\n        className=\"illuminator-button illuminator-button-primary rfm-footer-btn\"\n      >\n        Start Revision ({available} entities)\n      </button>\n    </>\n  );\n\n  return (\n    <ModalShell onClose={onCancel} title=\"Revise Entity Summaries\" className=\"rfm-dialog\" footer={footer}>\n      <p className=\"rfm-subtitle\">\n        Rewrite summaries and descriptions with full world context.\n      </p>\n\n      {/* Counts */}\n      <div className=\"rfm-counts-grid\">\n        <span className=\"rfm-count-label\">Total eligible entities</span>\n        <span className=\"rfm-count-value\">{totalEligible}</span>\n\n        <span className=\"rfm-count-label\">Used in chronicles</span>\n        <span\n          className={`rfm-count-value ${usedInChronicles > 0 ? \"rfm-count-value-warning\" : \"rfm-count-value-muted\"}`}\n        >\n          {usedInChronicles}\n        </span>\n\n        <span className=\"rfm-count-label rfm-count-label-total\">Available for revision</span>\n        <span className=\"rfm-count-value\">{available}</span>\n      </div>\n\n      {/* Chronicle filter toggle */}\n      {usedInChronicles > 0 && (\n        // eslint-disable-next-line jsx-a11y/label-has-associated-control\n        <label className=\"rfm-filter-toggle\">\n          <input\n            type=\"checkbox\"\n            checked={excludeChronicle}\n            onChange={(e) => setExcludeChronicle(e.target.checked)}\n            className=\"rfm-filter-checkbox\"\n          />\n          <div>\n            <div className=\"rfm-filter-title\">Exclude entities used in chronicles</div>\n            <div className=\"rfm-filter-description\">\n              Recommended. Prevents inconsistency between rewritten descriptions and existing\n              chronicle text.\n            </div>\n          </div>\n        </label>\n      )}\n\n      {available === 0 && (\n        <div className=\"rfm-warning\">\n          No entities available for revision with current filters.\n        </div>\n      )}\n    </ModalShell>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  totalEligible,\n  usedInChronicles,\n  onStart,\n  onCancel,\n}", "type": "{ isOpen: any; totalEligible: any; usedInChronicles: any; onStart: any; onCancel: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StaticPageEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPageEditor.jsx", "sourceCode": "export default function StaticPageEditor({ page, projectId, onSave, onDelete, onPublishToggle }) {\n  const [title, setTitle] = useState(page?.title || \"\");\n  const [content, setContent] = useState(page?.content || \"\");\n  const [summary, setSummary] = useState(page?.summary || \"\");\n  const [showEntityPicker, setShowEntityPicker] = useState(false);\n  const [showImagePicker, setShowImagePicker] = useState(false);\n  const [isDirty, setIsDirty] = useState(false);\n  const saveTimeoutRef = useRef(null);\n\n  // Reset state when page changes\n  useEffect(() => {\n    setTitle(page?.title || \"\");\n    setContent(page?.content || \"\");\n    setSummary(page?.summary || \"\");\n    setIsDirty(false);\n  }, [page?.pageId]);\n\n  // Auto-save on changes (debounced)\n  useEffect(() => {\n    if (!isDirty || !page) return;\n\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n\n    saveTimeoutRef.current = setTimeout(() => {\n      onSave({\n        title,\n        content,\n        summary: summary || undefined,\n      });\n      setIsDirty(false);\n    }, 1000);\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, [isDirty, title, content, summary, page, onSave]);\n\n  const handleTitleChange = (e) => {\n    setTitle(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleContentChange = (value) => {\n    setContent(value || \"\");\n    setIsDirty(true);\n  };\n\n  const handleSummaryChange = (e) => {\n    setSummary(e.target.value);\n    setIsDirty(true);\n  };\n\n  const handleEntityLinkSelect = useCallback((linkText) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + linkText);\n    setIsDirty(true);\n  }, []);\n\n  const handleImageSelect = useCallback((imageRef) => {\n    // Insert at cursor or append to content\n    setContent((prev) => prev + \"\\n\\n\" + imageRef + \"\\n\\n\");\n    setIsDirty(true);\n  }, []);\n\n  const handleSaveNow = () => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current);\n    }\n    onSave({\n      title,\n      content,\n      summary: summary || undefined,\n    });\n    setIsDirty(false);\n  };\n\n  if (!page) {\n    return (\n      <div className=\"static-page-editor-empty\">\n        <div className=\"static-page-editor-empty-icon\">&#x1F4DD;</div>\n        <div className=\"static-page-editor-empty-title\">Select a page to edit</div>\n        <div className=\"static-page-editor-empty-desc\">\n          Choose a page from the list or create a new one\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-page-editor\">\n      {/* Header with title and actions */}\n      <div className=\"static-page-editor-header\">\n        <input\n          type=\"text\"\n          value={title}\n          onChange={handleTitleChange}\n          placeholder=\"Page title...\"\n          className=\"static-page-title-input\"\n        />\n        <div className=\"static-page-editor-actions\">\n          <span\n            className={`static-page-status-badge ${page.status}`}\n            title={page.status === \"published\" ? \"Visible in Chronicler\" : \"Draft only\"}\n          >\n            {page.status}\n          </span>\n          {isDirty && <span className=\"static-page-dirty-indicator\">Unsaved</span>}\n          <button className=\"static-page-button\" onClick={handleSaveNow} disabled={!isDirty}>\n            Save\n          </button>\n          <button\n            className=\"static-page-button\"\n            onClick={() => onPublishToggle(page.status === \"published\" ? \"draft\" : \"published\")}\n          >\n            {page.status === \"published\" ? \"Unpublish\" : \"Publish\"}\n          </button>\n          <button className=\"static-page-button danger\" onClick={onDelete}>\n            Delete\n          </button>\n        </div>\n      </div>\n\n      {/* Summary input */}\n      <div className=\"static-page-summary-section\">\n        <label className=\"static-page-summary-label\">\n          Summary (shown in page lists):\n          <input\n            type=\"text\"\n            value={summary}\n            onChange={handleSummaryChange}\n            placeholder=\"Brief description of this page...\"\n            className=\"static-page-summary-input\"\n          />\n        </label>\n      </div>\n\n      {/* Custom toolbar */}\n      <div className=\"static-page-toolbar\">\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowEntityPicker(true)}\n          title=\"Insert entity link [[Entity Name]]\"\n        >\n          &#x1F517; Entity Link\n        </button>\n        <button\n          className=\"static-page-toolbar-button\"\n          onClick={() => setShowImagePicker(true)}\n          title=\"Insert image reference\"\n        >\n          &#x1F5BC; Image\n        </button>\n        <span className=\"static-page-toolbar-hint\">\n          Use <code>[[Entity Name]]</code> to link to entities\n        </span>\n      </div>\n\n      {/* Markdown editor */}\n      <div className=\"static-page-editor-container\" data-color-mode=\"dark\">\n        <MDEditor\n          value={content}\n          onChange={handleContentChange}\n          preview=\"live\"\n          height={500}\n          visibleDragbar={false}\n        />\n      </div>\n\n      {/* Word count */}\n      <div className=\"static-page-editor-footer\">\n        <span className=\"static-page-word-count\">\n          {page.wordCount || 0} words \u2022 {page.linkedEntityIds?.length || 0} entity links\n        </span>\n        <span className=\"static-page-updated\">\n          Last updated: {new Date(page.updatedAt).toLocaleString()}\n        </span>\n      </div>\n\n      {/* Modals */}\n      {showEntityPicker && (\n        <EntityLinkPicker\n          onSelect={handleEntityLinkSelect}\n          onClose={() => setShowEntityPicker(false)}\n        />\n      )}\n      {showImagePicker && (\n        <ImageRefPicker\n          projectId={projectId}\n          onSelect={handleImageSelect}\n          onClose={() => setShowImagePicker(false)}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ page, projectId, onSave, onDelete, onPublishToggle }", "type": "{ page: any; projectId: any; onSave: any; onDelete: any; onPublishToggle: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StaticPagesPanel.jsx", "sourceCode": "export default function StaticPagesPanel({ projectId }) {\n  const [pages, setPages] = useState([]);\n  const [selectedPageId, setSelectedPageId] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // Load pages on mount and when projectId changes\n  useEffect(() => {\n    if (!projectId) {\n      setPages([]);\n      setLoading(false);\n      return;\n    }\n\n    let cancelled = false;\n\n    setLoading(true);\n    getStaticPagesForProject(projectId)\n      .then((loadedPages) => {\n        if (cancelled) return;\n        setPages(loadedPages);\n        setLoading(false);\n      })\n      .catch((err) => {\n        console.error(\"Failed to load static pages:\", err);\n        if (!cancelled) setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId]);\n\n  const selectedPage = pages.find((p) => p.pageId === selectedPageId);\n\n  const handleCreatePage = useCallback(async () => {\n    if (!projectId) return;\n\n    try {\n      const newPage = await createStaticPage({\n        projectId,\n        title: \"Untitled Page\",\n        content: \"# Untitled Page\\n\\nStart writing here...\",\n      });\n      setPages((prev) => [newPage, ...prev]);\n      setSelectedPageId(newPage.pageId);\n    } catch (err) {\n      console.error(\"Failed to create page:\", err);\n    }\n  }, [projectId]);\n\n  const handleSavePage = useCallback(\n    async (updates) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, updates);\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to save page:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  const handleDeletePage = useCallback(async () => {\n    if (!selectedPageId) return;\n    if (!confirm(\"Are you sure you want to delete this page?\")) return;\n\n    try {\n      await deleteStaticPage(selectedPageId);\n      setPages((prev) => prev.filter((p) => p.pageId !== selectedPageId));\n      setSelectedPageId(null);\n    } catch (err) {\n      console.error(\"Failed to delete page:\", err);\n    }\n  }, [selectedPageId]);\n\n  const handlePublishToggle = useCallback(\n    async (newStatus) => {\n      if (!selectedPageId) return;\n\n      try {\n        const updated = await updateStaticPage(selectedPageId, { status: newStatus });\n        setPages((prev) => prev.map((p) => (p.pageId === selectedPageId ? updated : p)));\n      } catch (err) {\n        console.error(\"Failed to update page status:\", err);\n      }\n    },\n    [selectedPageId]\n  );\n\n  if (loading) {\n    return (\n      <div className=\"static-pages-panel\">\n        <div className=\"static-pages-loading\">Loading pages...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"static-pages-panel\">\n      {/* Left sidebar: page list */}\n      <div className=\"static-pages-sidebar\">\n        <div className=\"static-pages-sidebar-header\">\n          <h3>Static Pages</h3>\n          <button className=\"static-page-button primary\" onClick={() => void handleCreatePage()}>\n            + New Page\n          </button>\n        </div>\n\n        <div className=\"static-pages-list\">\n          {pages.length === 0 ? (\n            <div className=\"static-pages-empty\">\n              <p>No pages yet.</p>\n              <p>Create a page to add custom content like culture overviews or lore articles.</p>\n            </div>\n          ) : (\n            pages.map((page) => (\n              <button\n                key={page.pageId}\n                className={`static-pages-list-item ${selectedPageId === page.pageId ? \"selected\" : \"\"}`}\n                onClick={() => setSelectedPageId(page.pageId)}\n              >\n                <span className=\"static-pages-list-title\">{page.title}</span>\n                <span className=\"static-pages-list-meta\">\n                  <span className={`static-pages-status-dot ${page.status}`} />\n                  {page.wordCount} words\n                </span>\n              </button>\n            ))\n          )}\n        </div>\n      </div>\n\n      {/* Right area: editor */}\n      <div className=\"static-pages-editor-area\">\n        <StaticPageEditor\n          page={selectedPage}\n          projectId={projectId}\n          onSave={handleSavePage}\n          onDelete={() => void handleDeletePage()}\n          onPublishToggle={handlePublishToggle}\n        />\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StoragePanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StoragePanel.jsx", "sourceCode": "export default function StoragePanel({ projectId: _projectId }) {\n  const [images, setImages] = useState([]);\n  const [stats, setStats] = useState({ totalCount: 0, totalSize: 0, byProject: {} });\n  const [loading, setLoading] = useState(true);\n  const [selectedIds, setSelectedIds] = useState(new Set());\n  const [filterProject, setFilterProject] = useState(\"all\");\n  const [imageModal, setImageModal] = useState({ open: false, imageId: \"\", title: \"\" });\n  const [thumbnailUrls, setThumbnailUrls] = useState({});\n  const [downloadingIds, setDownloadingIds] = useState(new Set());\n  const [exportingPrompts, setExportingPrompts] = useState(false);\n  const [pageSize, setPageSize] = useState(DEFAULT_PAGE_SIZE);\n  const [pageIndex, setPageIndex] = useState(0);\n  const thumbnailUrlsRef = useRef({});\n\n  // Load images and stats\n  const loadData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const [allImages, storageStats] = await Promise.all([getAllImages(), getStorageStats()]);\n      setImages(allImages);\n      setStats(storageStats);\n    } catch (err) {\n      console.error(\"Failed to load storage data:\", err);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadData();\n  }, [loadData]);\n\n  useEffect(() => {\n    thumbnailUrlsRef.current = thumbnailUrls;\n  }, [thumbnailUrls]);\n\n  useEffect(() => {\n    return () => {\n      for (const url of Object.values(thumbnailUrlsRef.current)) {\n        URL.revokeObjectURL(url);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    setPageIndex(0);\n  }, [filterProject]);\n\n  // Filter images by project\n  const filteredImages = useMemo(() => {\n    if (filterProject === \"all\") return images;\n    return images.filter((img) => img.projectId === filterProject);\n  }, [images, filterProject]);\n\n  // Get unique project IDs\n  const projectIds = useMemo(() => {\n    const ids = new Set();\n    for (const img of images) {\n      if (img.projectId) ids.add(img.projectId);\n    }\n    return Array.from(ids).sort();\n  }, [images]);\n\n  const totalPages = Math.max(1, Math.ceil(filteredImages.length / pageSize));\n  const currentPage = Math.min(pageIndex, totalPages - 1);\n  const pageStart = currentPage * pageSize;\n  const pageEnd = pageStart + pageSize;\n  const visibleImages = useMemo(\n    () => filteredImages.slice(pageStart, pageEnd),\n    [filteredImages, pageStart, pageEnd]\n  );\n\n  useEffect(() => {\n    setPageIndex((prev) => Math.min(prev, Math.max(0, totalPages - 1)));\n  }, [totalPages]);\n\n  useEffect(() => {\n    const visibleIds = new Set(visibleImages.map((img) => img.imageId));\n    setThumbnailUrls((prev) => {\n      let changed = false;\n      const next = {};\n      for (const [imageId, url] of Object.entries(prev)) {\n        if (visibleIds.has(imageId)) {\n          next[imageId] = url;\n        } else {\n          URL.revokeObjectURL(url);\n          changed = true;\n        }\n      }\n      return changed ? next : prev;\n    });\n  }, [visibleImages]);\n\n  // Load thumbnail URLs for visible images only\n  useEffect(() => {\n    let active = true;\n    const loadThumbnails = async () => {\n      const newUrls = {};\n      for (const img of visibleImages) {\n        if (!thumbnailUrls[img.imageId]) {\n          try {\n            const result = await loadImage(img.imageId);\n            if (result?.url) {\n              newUrls[img.imageId] = result.url;\n            }\n          } catch {\n            // Ignore errors\n          }\n        }\n      }\n\n      if (active && Object.keys(newUrls).length > 0) {\n        setThumbnailUrls((prev) => ({ ...prev, ...newUrls }));\n      }\n    };\n\n    if (visibleImages.length > 0) {\n      loadThumbnails();\n    }\n\n    return () => {\n      active = false;\n    };\n  }, [visibleImages, thumbnailUrls]);\n\n  // Toggle selection\n  const toggleSelect = useCallback((imageId) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(imageId)) {\n        next.delete(imageId);\n      } else {\n        next.add(imageId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Select all filtered\n  const selectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredImages.map((img) => img.imageId)));\n  }, [filteredImages]);\n\n  // Clear selection\n  const clearSelection = useCallback(() => {\n    setSelectedIds(new Set());\n  }, []);\n\n  const handlePageSizeChange = useCallback((event) => {\n    setPageSize(Number(event.target.value));\n    setPageIndex(0);\n  }, []);\n\n  const handlePrevPage = useCallback(() => {\n    setPageIndex((prev) => Math.max(prev - 1, 0));\n  }, []);\n\n  const handleNextPage = useCallback(() => {\n    setPageIndex((prev) => Math.min(prev + 1, totalPages - 1));\n  }, [totalPages]);\n\n  // Delete single image\n  const handleDelete = useCallback(\n    async (imageId) => {\n      if (!window.confirm(\"Delete this image? This cannot be undone.\")) return;\n\n      try {\n        // Revoke thumbnail URL\n        if (thumbnailUrls[imageId]) {\n          URL.revokeObjectURL(thumbnailUrls[imageId]);\n          setThumbnailUrls((prev) => {\n            const next = { ...prev };\n            delete next[imageId];\n            return next;\n          });\n        }\n\n        await deleteImage(imageId);\n        setSelectedIds((prev) => {\n          const next = new Set(prev);\n          next.delete(imageId);\n          return next;\n        });\n        await loadData();\n      } catch (err) {\n        console.error(\"Failed to delete image:\", err);\n        alert(\"Failed to delete image\");\n      }\n    },\n    [loadData, thumbnailUrls]\n  );\n\n  // Delete selected images\n  const handleDeleteSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n    if (!window.confirm(`Delete ${selectedIds.size} selected images? This cannot be undone.`))\n      return;\n\n    try {\n      // Revoke thumbnail URLs\n      for (const id of selectedIds) {\n        if (thumbnailUrls[id]) {\n          URL.revokeObjectURL(thumbnailUrls[id]);\n        }\n      }\n      setThumbnailUrls((prev) => {\n        const next = { ...prev };\n        for (const id of selectedIds) {\n          delete next[id];\n        }\n        return next;\n      });\n\n      await deleteImages(Array.from(selectedIds));\n      setSelectedIds(new Set());\n      await loadData();\n    } catch (err) {\n      console.error(\"Failed to delete images:\", err);\n      alert(\"Failed to delete images\");\n    }\n  }, [selectedIds, loadData, thumbnailUrls]);\n\n  // Download single image\n  const handleDownload = useCallback(async (imageId, entityName) => {\n    setDownloadingIds((prev) => new Set(prev).add(imageId));\n    try {\n      const blob = await getImageBlob(imageId);\n      if (!blob) {\n        alert(\"Image not found\");\n        return;\n      }\n\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${entityName || imageId}.png`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download image:\", err);\n      alert(\"Failed to download image\");\n    } finally {\n      setDownloadingIds((prev) => {\n        const next = new Set(prev);\n        next.delete(imageId);\n        return next;\n      });\n    }\n  }, []);\n\n  // Download selected images as zip\n  const handleDownloadSelected = useCallback(async () => {\n    if (selectedIds.size === 0) return;\n\n    // Check if JSZip is available\n    let JSZip;\n    try {\n      JSZip = (await import(\"jszip\")).default;\n    } catch {\n      alert(\"Bulk download requires JSZip library. Please install it: npm install jszip\");\n      return;\n    }\n\n    setDownloadingIds(new Set(selectedIds));\n    try {\n      const zip = new JSZip();\n\n      for (const imageId of selectedIds) {\n        const blob = await getImageBlob(imageId);\n        if (blob) {\n          const img = images.find((i) => i.imageId === imageId);\n          const filename = img?.entityName\n            ? `${img.entityName.replace(/[^a-z0-9]/gi, \"_\")}.png`\n            : `${imageId}.png`;\n          zip.file(filename, blob);\n        }\n      }\n\n      const content = await zip.generateAsync({ type: \"blob\" });\n      const url = URL.createObjectURL(content);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = \"images.zip\";\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to download images:\", err);\n      alert(\"Failed to download images\");\n    } finally {\n      setDownloadingIds(new Set());\n    }\n  }, [selectedIds, images]);\n\n  // Export prompt data for analysis\n  const handleExportPrompts = useCallback(async () => {\n    setExportingPrompts(true);\n// ... (truncated)", "parameters": [{"name": "{ projectId: _projectId }", "type": "{ projectId: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleLibraryEditor.jsx", "sourceCode": "/**\n * Main StyleLibraryEditor component\n */\nexport default function StyleLibraryEditor({\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}) {\n  const [editingStyle, setEditingStyle] = useState(null);\n  const [editingType, setEditingType] = useState(null); // 'artistic' | 'composition' | 'narrative'\n  const [confirmReset, setConfirmReset] = useState(false);\n  const handleEditArtistic = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"artistic\");\n  }, []);\n  const handleEditComposition = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"composition\");\n  }, []);\n  const handleAddArtistic = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"artistic\");\n  }, []);\n  const handleAddComposition = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"composition\");\n  }, []);\n  const handleEditNarrative = useCallback(style => {\n    setEditingStyle(style);\n    setEditingType(\"narrative\");\n  }, []);\n  const handleAddNarrative = useCallback(() => {\n    setEditingStyle({});\n    setEditingType(\"narrative\");\n  }, []);\n  const handleSaveStyle = useCallback(async (styleData, isNew) => {\n    if (editingType === \"artistic\") {\n      if (isNew) {\n        await onAddArtisticStyle(styleData);\n      } else {\n        await onUpdateArtisticStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"composition\") {\n      if (isNew) {\n        await onAddCompositionStyle(styleData);\n      } else {\n        await onUpdateCompositionStyle(styleData.id, styleData);\n      }\n    } else if (editingType === \"narrative\") {\n      if (isNew) {\n        await onAddNarrativeStyle(styleData);\n      } else {\n        await onUpdateNarrativeStyle(styleData.id, styleData);\n      }\n    }\n    setEditingStyle(null);\n    setEditingType(null);\n  }, [editingType, onAddArtisticStyle, onUpdateArtisticStyle, onAddCompositionStyle, onUpdateCompositionStyle, onAddNarrativeStyle, onUpdateNarrativeStyle]);\n  const handleDeleteArtistic = useCallback(async id => {\n    if (window.confirm(\"Delete this artistic style?\")) {\n      await onDeleteArtisticStyle(id);\n    }\n  }, [onDeleteArtisticStyle]);\n  const handleDeleteComposition = useCallback(async id => {\n    if (window.confirm(\"Delete this composition style?\")) {\n      await onDeleteCompositionStyle(id);\n    }\n  }, [onDeleteCompositionStyle]);\n  const handleDeleteNarrative = useCallback(async id => {\n    if (window.confirm(\"Delete this narrative style?\")) {\n      await onDeleteNarrativeStyle(id);\n    }\n  }, [onDeleteNarrativeStyle]);\n  const handleReset = useCallback(async () => {\n    await onReset();\n    setConfirmReset(false);\n  }, [onReset]);\n  const handleCloseModal = useCallback(() => {\n    setEditingStyle(null);\n    setEditingType(null);\n  }, []);\n  if (loading) {\n    return <div className=\"illuminator-card\">\n        <p className=\"style-editor-loading\">Loading style library...</p>\n      </div>;\n  }\n  return <div>\n      {/* Status bar */}\n      <div className=\"illuminator-card\">\n        <div className=\"style-editor-status-row\">\n          <div>\n            <span className=\"style-editor-status-label\">Style Library</span>\n            <span className=\"style-editor-status-sublabel\">\n              {isCustom ? \"(customized)\" : \"(defaults)\"}\n            </span>\n          </div>\n          <div>\n            {!confirmReset && <button onClick={() => setConfirmReset(true)} className=\"illuminator-btn style-editor-btn-sm\" title={isCustom ? \"Reload defaults and discard custom styles\" : \"Reload default styles\"}>\n                Reload Default Styles\n              </button>}\n            {confirmReset && <span className=\"style-editor-confirm-row\">\n                <span className=\"style-editor-confirm-text\">\n                  {isCustom ? \"Reload defaults and discard custom styles?\" : \"Reload default styles?\"}\n                </span>\n                <button onClick={handleReset} className=\"illuminator-btn illuminator-btn-danger style-editor-btn-sm\">\n                  Yes, Reload\n                </button>\n                <button onClick={() => setConfirmReset(false)} className=\"illuminator-btn style-editor-btn-sm\">\n                  Cancel\n                </button>\n              </span>}\n          </div>\n        </div>\n      </div>\n\n      {/* Artistic Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Artistic Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.artisticStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddArtistic} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Artistic styles define the visual rendering approach (e.g., oil painting, watercolor,\n          digital art).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.artisticStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"artistic\" onEdit={handleEditArtistic} onDelete={handleDeleteArtistic} style={style} />)}\n        </div>\n\n        {styleLibrary.artisticStyles.length === 0 && <p className=\"style-editor-empty\">No artistic styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Composition Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Composition Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.compositionStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddComposition} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Composition styles define framing and visual arrangement (e.g., portrait, establishing\n          shot, action scene).\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.compositionStyles.map(style => <StyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        type=\"composition\" onEdit={handleEditComposition} onDelete={handleDeleteComposition} style={style} />)}\n        </div>\n\n        {styleLibrary.compositionStyles.length === 0 && <p className=\"style-editor-empty\">\n            No composition styles defined. Add one to get started.\n          </p>}\n      </div>\n\n      {/* Narrative Styles */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Narrative Styles\n            <span className=\"style-editor-section-count\">\n              ({styleLibrary.narrativeStyles.length})\n            </span>\n          </h2>\n          <button onClick={handleAddNarrative} className=\"illuminator-btn illuminator-btn-primary style-editor-btn-sm\">\n            + Add Style\n          </button>\n        </div>\n        <p className=\"style-editor-description\">\n          Narrative styles define story structure, character selection, and prose tone for chronicle\n          generation.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {styleLibrary.narrativeStyles.map(style => <NarrativeStyleCard key={style.id}\n        // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n        compositionStyles={styleLibrary.compositionStyles} onEdit={handleEditNarrative} onDelete={handleDeleteNarrative} style={style} />)}\n        </div>\n\n        {styleLibrary.narrativeStyles.length === 0 && <p className=\"style-editor-empty\">No narrative styles defined. Add one to get started.</p>}\n      </div>\n\n      {/* Scene Prompt Templates */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">\n            Cover Image Scene Prompts\n            <span className=\"style-editor-section-count\">({SCENE_PROMPT_TEMPLATES.length})</span>\n          </h2>\n        </div>\n        <p className=\"style-editor-description\">\n          Scene prompt templates direct the LLM on what kind of cover image scene to describe. Each\n          narrative style maps to one of these templates.\n        </p>\n\n        <div className=\"illuminator-style-grid\">\n          {SCENE_PROMPT_TEMPLATES.map(template => <div key={template.id} className=\"illuminator-style-card\">\n              <div className=\"illuminator-style-card-header\">\n                <div className=\"illuminator-style-card-title\">{template.name}</div>\n              </div>\n              <div className=\"illuminator-style-card-prompt\">\n                <strong>Framing:</strong> {template.framing}\n              </div>\n              <div className=\"illuminator-style-card-prompt style-editor-scene-prompt-instructions\">\n                <strong>Instructions:</strong> {template.instructions}\n              </div>\n            </div>)}\n        </div>\n      </div>\n\n      {/* Edit Modal for Artistic/Composition */}\n      {editingStyle && (editingType === \"artistic\" || editingType === \"composition\") && <StyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    type={editingType} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n\n      {/* Edit Modal for Narrative */}\n      {editingStyle && editingType === \"narrative\" && <NarrativeStyleEditModal\n    // eslint-disable-next-line local/no-inline-styles -- not CSS: data prop\n    compositionStyles={styleLibrary.compositionStyles} onSave={handleSaveStyle} onCancel={handleCloseModal} style={editingStyle} />}\n    </div>;\n}", "parameters": [{"name": "{\n  styleLibrary,\n  loading,\n  isCustom,\n  onAddArtisticStyle,\n  onUpdateArtisticStyle,\n  onDeleteArtisticStyle,\n  onAddCompositionStyle,\n  onUpdateCompositionStyle,\n  onDeleteCompositionStyle,\n  onAddNarrativeStyle,\n  onUpdateNarrativeStyle,\n  onDeleteNarrativeStyle,\n  onReset\n}", "type": "{ styleLibrary: any; loading: any; isCustom: any; onAddArtisticStyle: any; onUpdateArtisticStyle: any; onDeleteArtisticStyle: any; onAddCompositionStyle: any; onUpdateCompositionStyle: any; onDeleteCompositionStyle: any; onAddNarrativeStyle: any; onUpdateNarrativeStyle: any; onDeleteNarrativeStyle: any; onReset: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "export default function StyleSelector({\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}) {\n  const compositionId = useId();\n  const artisticStyles = styleLibrary?.artisticStyles || [];\n  const compositionStyles = styleLibrary?.compositionStyles || [];\n  const colorPalettes = styleLibrary?.colorPalettes || [];\n\n  // Filter composition styles based on entity kind (legacy suitableForKinds)\n  const filteredCompositionStyles = useMemo(() => {\n    if (!entityKind) {\n      return compositionStyles;\n    }\n    return compositionStyles.filter(\n      (s) =>\n        !s.suitableForKinds ||\n        s.suitableForKinds.length === 0 ||\n        s.suitableForKinds.includes(entityKind)\n    );\n  }, [compositionStyles, entityKind]);\n\n  // Group compositions by targetCategory for organized display\n  const groupedCompositions = useMemo(() => {\n    return groupCompositionsByCategory(filteredCompositionStyles);\n  }, [filteredCompositionStyles]);\n\n  const selectedArtistic = artisticStyles.find((s) => s.id === selectedArtisticStyleId);\n  const selectedComposition = compositionStyles.find((s) => s.id === selectedCompositionStyleId);\n  const selectedColorPalette = colorPalettes.find((s) => s.id === selectedColorPaletteId);\n\n  if (compact) {\n    return (\n      <div className=\"stsel-compact\">\n        <span className=\"stsel-compact-label\">Style:</span>\n        <select\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedArtistic?.description || \"Select artistic style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n\n        <select\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedComposition?.description || \"Select composition style\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n\n        <select\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select stsel-compact-select\"\n          title={selectedColorPalette?.description || \"Select color palette\"}\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"stsel-grid\">\n      {/* Artistic Style */}\n      <div>\n        <label htmlFor=\"artistic-style\" className=\"stsel-label\">Artistic Style</label>\n        <select id=\"artistic-style\"\n          value={selectedArtisticStyleId || RANDOM_ID}\n          onChange={(e) => onArtisticStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {artisticStyles.map((style) => (\n            <option key={style.id} value={style.id}>\n              {style.name}\n            </option>\n          ))}\n        </select>\n        {selectedArtistic && (\n          <div className=\"stsel-description\">{selectedArtistic.description}</div>\n        )}\n      </div>\n\n      {/* Composition Style */}\n      <div>\n        <label htmlFor={compositionId} className=\"stsel-label\">\n          Composition Style{entityKind && ` (for ${entityKind})`}\n        </label>\n        <select id={compositionId}\n          value={selectedCompositionStyleId || RANDOM_ID}\n          onChange={(e) => onCompositionStyleChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {groupedCompositions.map((group) => (\n            <optgroup key={group.category} label={group.label}>\n              {group.styles.map((style) => (\n                <option key={style.id} value={style.id}>\n                  {style.name}\n                </option>\n              ))}\n            </optgroup>\n          ))}\n        </select>\n        {selectedComposition && (\n          <div className=\"stsel-description\">{selectedComposition.description}</div>\n        )}\n      </div>\n\n      {/* Color Palette */}\n      <div>\n        <label htmlFor=\"color-palette\" className=\"stsel-label\">Color Palette</label>\n        <select id=\"color-palette\"\n          value={selectedColorPaletteId || RANDOM_ID}\n          onChange={(e) => onColorPaletteChange(e.target.value || RANDOM_ID)}\n          className=\"illuminator-select\"\n        >\n          <option value={RANDOM_ID}>Random</option>\n          <option value={NONE_ID}>None</option>\n          {colorPalettes.map((palette) => (\n            <option key={palette.id} value={palette.id}>\n              {palette.name}\n            </option>\n          ))}\n        </select>\n        {selectedColorPalette && (\n          <div className=\"stsel-description\">{selectedColorPalette.description}</div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  styleLibrary,\n  selectedArtisticStyleId,\n  selectedCompositionStyleId,\n  selectedColorPaletteId,\n  onArtisticStyleChange,\n  onCompositionStyleChange,\n  onColorPaletteChange,\n  entityKind,\n  compact = false,\n}", "type": "{ styleLibrary: any; selectedArtisticStyleId: any; selectedCompositionStyleId: any; selectedColorPaletteId: any; onArtisticStyleChange: any; onCompositionStyleChange: any; onColorPaletteChange: any; entityKind: any; compact?: boolean; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/StyleSelector.jsx::resolveStyleSelection", "name": "resolveStyleSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/components/StyleSelector.jsx", "sourceCode": "/**\n * Resolve style selection to actual style definitions\n * Handles culture defaults, random selection, exclusion filtering, and fallbacks\n */\nexport function resolveStyleSelection({\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}) {\n  const result = {\n    artisticStyle: null,\n    compositionStyle: null,\n    colorPalette: null,\n    cultureKeywords: [],\n  };\n\n  if (!styleLibrary) return result;\n\n  const artisticStyles = styleLibrary.artisticStyles || [];\n  const compositionStyles = styleLibrary.compositionStyles || [];\n  const colorPalettes = styleLibrary.colorPalettes || [];\n  const rules = exclusionRules || [];\n\n  // Filter composition styles by entity kind\n  const filteredCompositionStyles = entityKind\n    ? compositionStyles.filter(\n        (s) =>\n          !s.suitableForKinds ||\n          s.suitableForKinds.length === 0 ||\n          s.suitableForKinds.includes(entityKind)\n      )\n    : compositionStyles;\n\n  const styleIsRandom = selection.artisticStyleId === RANDOM_ID || !selection.artisticStyleId;\n  const compIsRandom = selection.compositionStyleId === RANDOM_ID || !selection.compositionStyleId;\n\n  if (\n    styleIsRandom &&\n    compIsRandom &&\n    selection.artisticStyleId !== NONE_ID &&\n    selection.compositionStyleId !== NONE_ID\n  ) {\n    // Both random: pick composition first, then filter styles for that composition\n    result.compositionStyle = pickRandom(filteredCompositionStyles);\n    if (result.compositionStyle && rules.length > 0) {\n      const filteredStyles = filterByExclusion(\n        artisticStyles,\n        result.compositionStyle.id,\n        rules,\n        artisticStyles,\n        compositionStyles,\n        \"style\"\n      );\n      result.artisticStyle = pickRandom(filteredStyles);\n    } else {\n      result.artisticStyle = pickRandom(artisticStyles);\n    }\n  } else {\n    // Resolve artistic style\n    if (selection.artisticStyleId === NONE_ID) {\n      result.artisticStyle = null;\n    } else if (styleIsRandom) {\n      // Style is random, composition is fixed \u2014 filter styles for fixed composition\n      const fixedCompId = selection.compositionStyleId;\n      if (fixedCompId && fixedCompId !== NONE_ID && rules.length > 0) {\n        const filteredStyles = filterByExclusion(\n          artisticStyles,\n          fixedCompId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"style\"\n        );\n        result.artisticStyle = pickRandom(filteredStyles);\n      } else {\n        result.artisticStyle = pickRandom(artisticStyles);\n      }\n    } else {\n      result.artisticStyle = artisticStyles.find((s) => s.id === selection.artisticStyleId);\n    }\n\n    // Resolve composition style\n    if (selection.compositionStyleId === NONE_ID) {\n      result.compositionStyle = null;\n    } else if (compIsRandom) {\n      // Composition is random, style is fixed \u2014 filter compositions for fixed style\n      const fixedStyleId = selection.artisticStyleId;\n      if (fixedStyleId && fixedStyleId !== NONE_ID && rules.length > 0) {\n        const filteredComps = filterByExclusion(\n          filteredCompositionStyles,\n          fixedStyleId,\n          rules,\n          artisticStyles,\n          compositionStyles,\n          \"composition\"\n        );\n        result.compositionStyle = pickRandom(filteredComps);\n      } else {\n        result.compositionStyle = pickRandom(filteredCompositionStyles);\n      }\n    } else {\n      result.compositionStyle = compositionStyles.find(\n        (s) => s.id === selection.compositionStyleId\n      );\n    }\n  }\n\n  // Resolve color palette (no culture default for palettes)\n  if (selection.colorPaletteId === NONE_ID) {\n    result.colorPalette = null;\n  } else if (selection.colorPaletteId === RANDOM_ID || !selection.colorPaletteId) {\n    result.colorPalette = pickRandom(colorPalettes);\n  } else {\n    result.colorPalette = colorPalettes.find((p) => p.id === selection.colorPaletteId);\n  }\n\n  // Get culture style keywords\n  const culture = cultures?.find((c) => c.id === entityCultureId);\n  if (culture?.styleKeywords?.length > 0) {\n    result.cultureKeywords = culture.styleKeywords;\n  }\n\n  return result;\n}", "parameters": [{"name": "{\n  selection,\n  entityCultureId,\n  entityKind,\n  cultures,\n  styleLibrary,\n  exclusionRules = DEFAULT_RANDOM_EXCLUSIONS,\n}", "type": "{ selection: any; entityCultureId: any; entityKind: any; cultures: any; styleLibrary: any; exclusionRules?: import(\"/home/tsonu/src/the-canonry/packages/world-schema/dist/styleExclusions\").RandomExclusionRule[]; }", "optional": false}], "returnType": "{ artisticStyle: any; compositionStyle: any; colorPalette: any; cultureKeywords: any[]; }"}, {"id": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/SummaryRevisionModal.jsx", "sourceCode": "// ============================================================================\n// Main Modal\n// ============================================================================\n\nexport default function SummaryRevisionModal({\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}) {\n  const scrollRef = useRef(null);\n  const [expandedIds, setExpandedIds] = useState(new Set());\n\n  // Auto-scroll on new content\n  useEffect(() => {\n    scrollRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [run?.batches?.length, run?.currentBatchIndex, run?.status]);\n\n  // Reset expanded state when batch changes\n  useEffect(() => {\n    setExpandedIds(new Set());\n  }, [run?.currentBatchIndex, run?.status]);\n\n  // Build entity lookup from entity contexts\n  const [entityLookup, setEntityLookup] = useState(new Map());\n  useEffect(() => {\n    if (!run || !getEntityContexts) {\n      setEntityLookup(new Map());\n      return;\n    }\n    let cancelled = false;\n    const allIds = run.batches.flatMap((b) => b.entityIds);\n    Promise.resolve(getEntityContexts(allIds)).then((contexts) => {\n      if (cancelled) return;\n      const map = new Map();\n      for (const ctx of contexts) {\n        if (ctx) map.set(ctx.id, ctx);\n      }\n      setEntityLookup(map);\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [run, getEntityContexts]);\n\n  if (!isActive || !run) return null;\n\n  const isGenerating = run.status === \"generating\" || run.status === \"pending\";\n  const isBatchReviewing = run.status === \"batch_reviewing\";\n  const isRunReviewing = run.status === \"run_reviewing\";\n  const isFailed = run.status === \"failed\";\n\n  const currentBatch = run.batches[run.currentBatchIndex];\n  const totalBatches = run.batches.length;\n  const completedBatches = run.batches.filter(\n    (b) => b.status === \"complete\" || b.status === \"failed\"\n  ).length;\n\n  // Collect patches for display\n  const allPatches = isRunReviewing\n    ? run.batches.flatMap((b) => b.patches || [])\n    : currentBatch?.patches || [];\n\n  const acceptedCount = allPatches.filter((p) => run.patchDecisions[p.entityId] !== false).length;\n\n  const toggleExpand = (entityId) => {\n    setExpandedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(entityId)) next.delete(entityId);\n      else next.add(entityId);\n      return next;\n    });\n  };\n\n  const expandAll = () => {\n    setExpandedIds(new Set(allPatches.map((p) => p.entityId)));\n  };\n\n  const collapseAll = () => {\n    setExpandedIds(new Set());\n  };\n\n  const handleExport = () => {\n    const text = buildExportText(allPatches, entityLookup, run.patchDecisions, descriptionBaseline);\n    const timestamp = Date.now();\n    downloadText(text, `revision-patches-${timestamp}.txt`);\n  };\n\n  return (\n    <div className=\"srm-overlay\">\n      <div className=\"srm-modal\">\n        {/* Header */}\n        <div className=\"srm-modal-header\">\n          <div>\n            <h2 className=\"srm-modal-title\">\n              Batch Revision\n              {currentBatch && !isRunReviewing && (\n                <span className=\"srm-modal-culture\">{currentBatch.culture}</span>\n              )}\n            </h2>\n            <p className=\"srm-modal-subtitle\">\n              {isRunReviewing\n                ? `All ${totalBatches} batches complete. Review and apply patches.`\n                : `Batch ${run.currentBatchIndex + 1} of ${totalBatches}`}\n              {completedBatches > 0 && !isRunReviewing && ` (${completedBatches} complete)`}\n            </p>\n          </div>\n          <div className=\"srm-modal-header-right\">\n            {run.totalActualCost > 0 && (\n              <span className=\"srm-modal-cost\">${run.totalActualCost.toFixed(4)}</span>\n            )}\n            <button\n              onClick={onCancel}\n              className=\"illuminator-button illuminator-button-secondary srm-cancel-btn\"\n            >\n              Cancel\n            </button>\n          </div>\n        </div>\n\n        {/* Scrollable content */}\n        <div className=\"srm-modal-scroll\">\n          {isGenerating && (\n            <div className=\"srm-generating\">\n              <div className=\"srm-generating-label\">\n                Generating revisions for batch {run.currentBatchIndex + 1}...\n              </div>\n              {currentBatch && (\n                <div className=\"srm-generating-detail\">\n                  {currentBatch.culture} ({currentBatch.entityIds.length} entities)\n                </div>\n              )}\n            </div>\n          )}\n\n          {isFailed && currentBatch?.error && <div className=\"srm-error\">{currentBatch.error}</div>}\n\n          {/* Patches */}\n          {allPatches.length > 0 && (\n            <div>\n              <div className=\"srm-patches-toolbar\">\n                <span className=\"srm-patches-count\">\n                  {allPatches.length} entities revised\n                  <span className=\"srm-patches-accepted\">{acceptedCount} accepted</span>\n                </span>\n                <div className=\"srm-patches-actions\">\n                  <button onClick={handleExport} className=\"srm-toolbar-btn\">\n                    Export\n                  </button>\n                  <button onClick={expandAll} className=\"srm-toolbar-btn\">\n                    Expand all\n                  </button>\n                  <button onClick={collapseAll} className=\"srm-toolbar-btn\">\n                    Collapse all\n                  </button>\n                </div>\n              </div>\n              {allPatches.map((patch) => (\n                <PatchCard\n                  key={patch.entityId}\n                  patch={patch}\n                  currentEntity={entityLookup.get(patch.entityId)}\n                  accepted={run.patchDecisions[patch.entityId]}\n                  onToggle={onTogglePatch}\n                  expanded={expandedIds.has(patch.entityId)}\n                  onToggleExpand={() => toggleExpand(patch.entityId)}\n                  onUpdateAnchorPhrase={onUpdateAnchorPhrase}\n                  descriptionBaseline={descriptionBaseline}\n                />\n              ))}\n            </div>\n          )}\n\n          {(isBatchReviewing || isRunReviewing) && allPatches.length === 0 && (\n            <div className=\"srm-no-patches\">No changes suggested for this batch.</div>\n          )}\n\n          <div ref={scrollRef} />\n        </div>\n\n        {/* Footer */}\n        <div className=\"srm-modal-footer\">\n          {isBatchReviewing && (\n            <>\n              <button\n                onClick={onAutoContine}\n                className=\"illuminator-button illuminator-button-secondary srm-footer-btn\"\n              >\n                Auto-Continue All\n              </button>\n              <button\n                onClick={onContinue}\n                className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n              >\n                {run.currentBatchIndex + 1 < totalBatches\n                  ? `Continue to Batch ${run.currentBatchIndex + 2}`\n                  : \"Finish Review\"}\n              </button>\n            </>\n          )}\n          {isRunReviewing && (\n            <button\n              onClick={onAccept}\n              className=\"illuminator-button illuminator-button-primary srm-footer-btn\"\n            >\n              Apply Accepted ({acceptedCount})\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  run,\n  isActive,\n  onContinue,\n  onAutoContine,\n  onTogglePatch,\n  onAccept,\n  onCancel,\n  getEntityContexts,\n  onUpdateAnchorPhrase,\n  descriptionBaseline,\n}", "type": "{ run: any; isActive: any; onContinue: any; onAutoContine: any; onTogglePatch: any; onAccept: any; onCancel: any; getEntityContexts: any; onUpdateAnchorPhrase: any; descriptionBaseline: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ToneAssignmentPreviewModal.jsx", "sourceCode": "export default function ToneAssignmentPreviewModal({\n  preview,\n  onApply,\n  onClose\n}) {\n  const [entries, setEntries] = useState(preview?.entries ?? []);\n  const distribution = useMemo(() => {\n    const counts = Object.fromEntries(ANNOTATION_TONES.map(t => [t, 0]));\n    for (const e of entries) {\n      if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n    }\n    return counts;\n  }, [entries]);\n  if (!preview) return null;\n  const maxCount = Math.max(1, ...Object.values(distribution));\n  const shiftedCount = entries.filter(e => e.wasShifted).length;\n  const handleToneChange = (chronicleId, newTone) => {\n    setEntries(prev => prev.map(e => e.chronicleId === chronicleId ? {\n      ...e,\n      assignedTone: newTone,\n      wasShifted: newTone !== e.ranking[0]\n    } : e));\n  };\n  const footer = <>\n      <button onClick={onClose} className=\"illuminator-button tapm-footer-btn\">\n        Cancel\n      </button>\n      <button onClick={() => onApply(entries)} className=\"illuminator-button illuminator-button-primary tapm-footer-btn\">\n        Apply ({entries.length} assignments)\n      </button>\n    </>;\n  return <ModalShell onClose={onClose} title=\"Tone Assignment\" className=\"tapm-modal\" footer={footer}>\n      <span className=\"tapm-subtitle\">\n        {entries.length} chronicles\n        {shiftedCount > 0 && ` \u00b7 ${shiftedCount} shifted`}\n      </span>\n\n      {/* Distribution chart */}\n      <div className=\"tapm-distribution\">\n        <div className=\"tapm-section-label\">Distribution</div>\n        <div className=\"tapm-chart\">\n          {ANNOTATION_TONES.map(tone => {\n          const count = distribution[tone] || 0;\n          const meta = TONE_META[tone];\n          const pct = maxCount > 0 ? count / maxCount * 100 : 0;\n          return <div key={tone} className=\"tapm-chart-row\">\n                <span className=\"tapm-chart-symbol\"\n            style={{\n              \"--tapm-symbol-color\": TONE_COLORS[tone]\n            }}>\n                  {meta?.symbol || \"?\"}\n                </span>\n                <span className=\"tapm-chart-label\">{meta?.label || tone}</span>\n                <div className=\"tapm-chart-bar-track\">\n                  <div className=\"tapm-chart-bar-fill\"\n              style={{\n                \"--tapm-bar-color\": TONE_COLORS[tone] || \"#888\",\n                \"--tapm-bar-width\": `${pct}%`\n              }} />\n                </div>\n                <span className=\"tapm-chart-count\">{count}</span>\n              </div>;\n        })}\n        </div>\n      </div>\n\n      {/* Chronicle list */}\n      <div className=\"tapm-section-label tapm-section-label-assignments\">Assignments</div>\n      <div className=\"tapm-list\">\n        {entries.map(entry => <div key={entry.chronicleId} className={`tapm-entry ${entry.wasShifted ? \"tapm-entry-shifted\" : \"\"}`}>\n            {/* Title */}\n            <div className=\"tapm-entry-title\">{entry.title}</div>\n\n            {/* Ranking display */}\n            <div className=\"tapm-ranking\">\n              {entry.ranking.map((tone, rank) => {\n            const meta = TONE_META[tone];\n            const isAssigned = tone === entry.assignedTone;\n            return <span key={rank} title={`#${rank + 1}: ${meta?.label || tone}`} className={`tapm-rank-chip ${isAssigned ? \"tapm-rank-chip-assigned\" : \"tapm-rank-chip-unassigned\"} ${rank === 1 ? \"tapm-rank-chip-rank2\" : \"\"} ${rank >= 2 ? \"tapm-rank-chip-rank3\" : \"\"}`}\n            onClick={() => handleToneChange(entry.chronicleId, tone)} role=\"button\" tabIndex={0} onKeyDown={e => {\n              if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n            }} style={{\n              \"--tapm-chip-bg\": isAssigned ? TONE_COLORS[tone] : \"transparent\"\n            }}>\n                    {meta?.symbol || \"?\"}\n                  </span>;\n          })}\n            </div>\n\n            {/* Shifted indicator */}\n            {entry.wasShifted && <span title=\"Shifted from rank 1 for distribution balance\" className=\"tapm-shifted-label\">\n                shifted\n              </span>}\n          </div>)}\n      </div>\n    </ModalShell>;\n}", "parameters": [{"name": "{\n  preview,\n  onApply,\n  onClose\n}", "type": "{ preview: any; onApply: any; onClose: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/TraitPaletteSection.tsx", "sourceCode": "export default function TraitPaletteSection({\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}: Readonly<TraitPaletteSectionProps>) {\n  // Filter to valid, unique entity kinds\n  const entityKinds = useMemo(\n    () => [...new Set((rawEntityKinds || []).filter((k) => k && typeof k === \"string\"))],\n    // Use joined string as stable key since parent creates new array each render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [(rawEntityKinds || []).join(\",\")]\n  );\n\n  const [palettes, setPalettes] = useState<Record<string, TraitPalette | null>>({});\n  const [loading, setLoading] = useState(true);\n  const [selectedKind, setSelectedKind] = useState<string | null>(null);\n\n  // Stable key for entityKinds to use in dependencies\n  const entityKindsKey = entityKinds.join(\",\");\n\n  // Track which kinds have pending/running tasks\n  const expandingKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const item of queue) {\n      if (\n        item.type === \"paletteExpansion\" &&\n        item.paletteEntityKind &&\n        (item.status === \"queued\" || item.status === \"running\")\n      ) {\n        kinds.add(item.paletteEntityKind);\n      }\n    }\n    return kinds;\n  }, [queue]);\n\n  // Track completed tasks to refresh palettes\n  const completedPaletteTaskIds = useMemo(() => {\n    return queue\n      .filter((item) => item.type === \"paletteExpansion\" && item.status === \"complete\")\n      .map((item) => item.id);\n  }, [queue]);\n\n  // Load all palettes\n  const loadPalettes = useCallback(async () => {\n    setLoading(true);\n    try {\n      const loaded: Record<string, TraitPalette | null> = {};\n      for (const kind of entityKinds) {\n        loaded[kind] = await getPalette(projectId, kind);\n      }\n      setPalettes(loaded);\n    } catch (err) {\n      console.error(\"Failed to load palettes:\", err);\n    } finally {\n      setLoading(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [projectId, entityKindsKey]);\n\n  useEffect(() => {\n    void loadPalettes();\n  }, [loadPalettes]);\n\n  // Refresh palettes when a palette expansion task completes\n  const lastCompletedRef = useMemo(() => ({ ids: new Set<string>() }), []);\n  useEffect(() => {\n    const newCompletions = completedPaletteTaskIds.filter((id) => !lastCompletedRef.ids.has(id));\n    if (newCompletions.length > 0) {\n      for (const id of newCompletions) {\n        lastCompletedRef.ids.add(id);\n      }\n      void loadPalettes();\n    }\n  }, [completedPaletteTaskIds, lastCompletedRef, loadPalettes]);\n\n  // Expand palette for a specific kind via queue\n  const handleExpand = useCallback(\n    (entityKind: string) => {\n      if (!isWorkerReady) {\n        alert(\"Worker not ready. Please wait...\");\n        return;\n      }\n\n      // Create a synthetic entity for the queue (palette expansion is not entity-specific)\n      const syntheticEntity: EnrichedEntity = {\n        id: `palette_${entityKind}`,\n        name: `Palette: ${entityKind}`,\n        kind: entityKind,\n        subtype: \"\",\n        prominence: \"recognized\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      };\n\n      // Filter cultures to those with visual identities (more useful for grounding)\n      const cultureContext = cultures\n        .filter((c) => c.name && (c.visualIdentity || c.description))\n        .map((c) => ({\n          name: c.name,\n          description: c.description,\n          visualIdentity: c.visualIdentity,\n        }));\n\n      // Get subtypes for this kind\n      const subtypes = subtypesByKind[entityKind] || [];\n\n      enqueue([\n        {\n          entity: syntheticEntity,\n          type: \"paletteExpansion\",\n          prompt: \"\", // Not used - worker builds prompt from paletteEntityKind + paletteWorldContext\n          paletteEntityKind: entityKind,\n          paletteWorldContext: worldContext || \"A fantasy world with diverse entities.\",\n          paletteSubtypes: subtypes.length > 0 ? subtypes : undefined,\n          paletteEras: eras.length > 0 ? eras : undefined,\n          paletteCultureContext: cultureContext.length > 0 ? cultureContext : undefined,\n        },\n      ]);\n    },\n    [isWorkerReady, enqueue, worldContext, subtypesByKind, eras, cultures]\n  );\n\n  // Export all palettes\n  const handleExport = useCallback(async () => {\n    try {\n      const allPalettes = await exportPalettes(projectId);\n      const json = JSON.stringify(allPalettes, null, 2);\n      const blob = new Blob([json], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `trait-palettes-${new Date().toISOString().split(\"T\")[0]}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error(\"Failed to export palettes:\", err);\n      alert(\"Failed to export palettes\");\n    }\n  }, [projectId]);\n\n  // Count total categories\n  const totalCategories = Object.values(palettes).reduce(\n    (sum, p) => sum + (p?.items.length || 0),\n    0\n  );\n\n  // Find recent errors for palette expansion\n  const recentErrors = useMemo(() => {\n    return queue\n      .filter(\n        (item) =>\n          item.type === \"paletteExpansion\" && item.status === \"error\" && item.paletteEntityKind\n      )\n      .slice(-3); // Show last 3 errors\n  }, [queue]);\n\n  if (loading) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"tps-loading\">\n          Loading trait palettes...\n        </div>\n      </div>\n    );\n  }\n\n  if (entityKinds.length === 0) {\n    return (\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        </div>\n        <div className=\"tps-empty\">\n          No entity kinds available. Load a world with entity kinds defined to use trait palettes.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"illuminator-card\">\n      <div className=\"illuminator-card-header\">\n        <h2 className=\"illuminator-card-title\">Trait Palettes</h2>\n        <div className=\"tps-header-actions\">\n          <button\n            onClick={() => void handleExport()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n            disabled={totalCategories === 0}\n          >\n            Export\n          </button>\n          <button\n            onClick={() => void loadPalettes()}\n            className=\"illuminator-button illuminator-button-secondary tps-header-btn\"\n          >\n            Refresh\n          </button>\n        </div>\n      </div>\n\n      <p className=\"tps-description\">\n        Trait palettes provide diverse visual directions for entity descriptions. Expand palettes to\n        generate new trait categories and reduce repetition.\n      </p>\n\n      {/* Summary stats */}\n      <div className=\"tps-stats-grid\">\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{entityKinds.length}</div>\n          <div className=\"tps-stat-label\">Entity Kinds</div>\n        </div>\n        <div className=\"tps-stat-card\">\n          <div className=\"tps-stat-value\">{totalCategories}</div>\n          <div className=\"tps-stat-label\">Total Categories</div>\n        </div>\n      </div>\n\n      {/* Per-kind palettes */}\n      <div className=\"tps-kind-list\">\n        {entityKinds.map((kind) => {\n          const palette = palettes[kind];\n          const isExpanding = expandingKinds.has(kind);\n          const isSelected = selectedKind === kind;\n\n          return (\n            <div\n              key={kind}\n              className=\"tps-kind-card\"\n            >\n              {/* Header row */}\n              <div\n                className=\"tps-kind-header\"\n                onClick={() => setSelectedKind(isSelected ? null : kind)}\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                <div className=\"tps-kind-header-left\">\n                  <code className=\"tps-kind-badge\">\n                    {kind || \"(unknown)\"}\n                  </code>\n                  <span className=\"tps-category-count\">\n                    {palette?.items.length || 0} categories\n                  </span>\n                </div>\n                <div className=\"tps-kind-header-right\">\n                  <button\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      if (!kind) {\n                        alert(\"Invalid entity kind\");\n                        return;\n                      }\n                      handleExpand(kind);\n                    }}\n                    className=\"illuminator-button illuminator-button-primary tps-expand-btn\"\n                    disabled={isExpanding || !isWorkerReady || !kind}\n                    title={\n                      !isWorkerReady ? \"Worker not ready\" : `Generate trait categories for ${kind}`\n                    }\n                  >\n                    {isExpanding ? \"Expanding...\" : \"Expand\"}\n                  </button>\n                  <span className={`tps-expand-icon ${isSelected ? \"tps-expand-icon-open\" : \"tps-expand-icon-closed\"}`}>\n                    \u25bc\n                  </span>\n                </div>\n              </div>\n\n              {/* Expanded content */}\n              {isSelected && (\n                <div className=\"tps-kind-body\">\n                  {!palette || palette.items.length === 0 ? (\n                    <div className=\"tps-kind-empty\">\n                      No palette categories yet. Click &quot;Expand Palette&quot; to generate some.\n                    </div>\n                  ) : (\n                    <div className=\"tps-palette-list\">\n                      {palette.items.map((item: PaletteItem) => (\n                        <div\n                          key={item.id}\n                          className=\"tps-palette-item\"\n                        >\n                          <div className=\"tps-palette-header\">\n                            <span className=\"tps-palette-category\">\n                              {item.category}\n                            </span>\n                            <span\n                              className={`tps-usage-badge ${item.timesUsed > 0 ? \"tps-usage-badge-used\" : \"tps-usage-badge-unused\"}`}\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  simulationRunId: _simulationRunId,\n  worldContext,\n  entityKinds: rawEntityKinds = [],\n  subtypesByKind = {},\n  eras = [],\n  cultures = [],\n  enqueue,\n  queue,\n  isWorkerReady,\n}", "type": "Readonly<TraitPaletteSectionProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/VisualIdentityPanel.jsx", "sourceCode": "export default function VisualIdentityPanel({\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}) {\n  // Collect all visual identity keys\n  const visualKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.visual || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.visual]);\n\n  // Collect all descriptive identity keys\n  const descriptiveKeys = useMemo(() => {\n    const keys = new Set();\n    const identities = cultureIdentities.descriptive || {};\n    for (const cultureId of Object.keys(identities)) {\n      for (const key of Object.keys(identities[cultureId])) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys).sort();\n  }, [cultureIdentities.descriptive]);\n\n  // Visual identity handlers\n  const handleVisualIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visual: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleVisualKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      visualKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n\n  // Descriptive identity handlers\n  const handleDescriptiveIdentitiesChange = useCallback(newIdentities => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptive: newIdentities\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  const handleDescriptiveKeysByKindChange = useCallback(newKeysByKind => {\n    onCultureIdentitiesChange({\n      ...cultureIdentities,\n      descriptiveKeysByKind: newKeysByKind\n    });\n  }, [cultureIdentities, onCultureIdentitiesChange]);\n  return <div className=\"illuminator-visual-identity-panel\">\n      {/* Visual Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Visual Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe visual traits for image prompts (clothing, species, architecture)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define visual characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.visual} onIdentitiesChange={handleVisualIdentitiesChange} allKeys={visualKeys} keyPlaceholder=\"KEY (e.g., ATTIRE)\" valuePlaceholder=\"e.g., fur parkas with bone jewelry\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which visual traits to include per entity kind\" defaultOpen={visualKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={visualKeys} keysByKind={cultureIdentities.visualKeysByKind} onKeysByKindChange={handleVisualKeysByKindChange} emptyMessage=\"No visual identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n\n      {/* Descriptive Identity Section */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Descriptive Identity</h2>\n          <span className=\"illuminator-card-subtitle\">\n            In-universe traits for text prompts (customs, speech patterns, values)\n          </span>\n        </div>\n\n        <IdentitySection title=\"Culture Traits\" subtitle=\"Define descriptive characteristics for each culture\" defaultOpen={true}>\n          <CultureIdentityEditor cultures={cultures} identities={cultureIdentities.descriptive} onIdentitiesChange={handleDescriptiveIdentitiesChange} allKeys={descriptiveKeys} keyPlaceholder=\"KEY (e.g., CUSTOMS)\" valuePlaceholder=\"e.g., elaborate greeting rituals involving fish exchange\" />\n        </IdentitySection>\n\n        <IdentitySection title=\"Entity Kind Mapping\" subtitle=\"Which descriptive traits to include per entity kind\" defaultOpen={descriptiveKeys.length > 0}>\n          <IdentityKeySelector entityKinds={entityKinds} availableKeys={descriptiveKeys} keysByKind={cultureIdentities.descriptiveKeysByKind} onKeysByKindChange={handleDescriptiveKeysByKindChange} emptyMessage=\"No descriptive identity keys defined yet. Add keys to cultures above.\" />\n        </IdentitySection>\n      </div>\n    </div>;\n}", "parameters": [{"name": "{\n  cultures,\n  entityKinds,\n  cultureIdentities,\n  onCultureIdentitiesChange\n}", "type": "{ cultures: any; entityKinds: any; cultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/WorldContextEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/WorldContextEditor.jsx", "sourceCode": "export default function WorldContextEditor({\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}) {\n  const updateField = useCallback(\n    (field, value) => {\n      onWorldContextChange({ [field]: value });\n    },\n    [onWorldContextChange]\n  );\n\n  const parseDynamicsFile = useCallback((fileContent) => {\n    try {\n      const parsed = JSON.parse(fileContent);\n      if (!Array.isArray(parsed)) {\n        alert(\"Invalid dynamics file: expected a JSON array.\");\n        return;\n      }\n      const valid = parsed.every(\n        (d) => d && typeof d.id === \"string\" && typeof d.text === \"string\"\n      );\n      if (!valid) {\n        alert(\"Invalid dynamics file: each entry must have id and text strings.\");\n        return;\n      }\n      updateField(\"worldDynamics\", parsed);\n    } catch (err) {\n      alert(`Failed to parse dynamics JSON: ${err.message}`);\n    }\n  }, [updateField]);\n\n  const handleImportDynamicsJson = useCallback(() => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json\";\n    input.onchange = (e) => {\n      const file = e.target.files?.[0];\n      if (!file) return;\n      const reader = new FileReader();\n      reader.onload = (ev) => parseDynamicsFile(ev.target.result);\n      reader.readAsText(file);\n    };\n    input.click();\n  }, [parseDynamicsFile]);\n\n  return (\n    <div>\n      {/* Info Banner */}\n      <div className=\"wce-info-banner\">\n        <div className=\"wce-info-banner-title\">Entity context is built automatically</div>\n        <div className=\"wce-info-banner-desc\">\n          Relationships, cultural peers, faction members, and entity age are extracted from the\n          simulation data. This panel only configures world-level context that applies to all\n          entities.\n        </div>\n      </div>\n\n      {/* World Identity */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">World Identity</h2>\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label htmlFor=\"world-name\" className=\"illuminator-label\">World Name</label>\n          <input id=\"world-name\"\n            type=\"text\"\n            value={worldContext.name || \"\"}\n            onChange={(e) => updateField(\"name\", e.target.value)}\n            placeholder=\"e.g., The Frozen Realms of Aurora Berg\"\n            className=\"illuminator-input\"\n          />\n        </div>\n\n        <div className=\"illuminator-form-group\">\n          <label className=\"illuminator-label\">World Description\n          <LocalTextArea\n            value={worldContext.description || \"\"}\n            onChange={(value) => updateField(\"description\", value)}\n            placeholder=\"Brief description of your world's setting, themes, and what makes it unique...\"\n            className=\"illuminator-input wce-textarea-description\"\n          />\n          </label>\n        </div>\n      </div>\n\n      {/* Species Constraint */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Species Constraint</h2>\n        </div>\n        <p className=\"wce-description-text\">\n          Rule for what species can appear in generated images. This is added as a SPECIES\n          REQUIREMENT at the top of image prompts to ensure all depicted figures match your world&apos;s\n          inhabitants.\n        </p>\n        <div className=\"illuminator-form-group\">\n          <LocalTextArea\n            value={worldContext.speciesConstraint || \"\"}\n            onChange={(value) => updateField(\"speciesConstraint\", value)}\n            placeholder=\"e.g., All depicted figures must be penguins or orcas. No humans exist in this world.\"\n            className=\"illuminator-input wce-textarea-tone\"\n          />\n        </div>\n      </div>\n\n      {/* World Context Configuration */}\n      <div className=\"wce-section-divider\">\n        <div className=\"wce-section-header\">\n          <h2 className=\"wce-section-title\">Chronicle Generation</h2>\n          <p className=\"wce-section-subtitle\">\n            Tone and facts for chronicle generation. Chronicles use perspective synthesis to create\n            focused, faceted views based on each chronicle&apos;s entity constellation.\n          </p>\n        </div>\n\n        {/* Canon Facts */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Canon Facts</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            World truths and generation constraints. Required facts must appear in perspective\n            facets. Generation constraints are always included verbatim and never faceted.\n          </p>\n          <div className=\"illuminator-form-group wce-form-group-mb16\">\n            <span className=\"illuminator-label\">Facet Range (optional)</span>\n            <div className=\"wce-facet-range-row\">\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.minCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    minCount: parsed,\n                  });\n                }}\n                placeholder=\"min (4)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n              <span className=\"wce-facet-range-separator\">to</span>\n              <input\n                type=\"number\"\n                min=\"1\"\n                step=\"1\"\n                value={worldContext.factSelection?.maxCount ?? \"\"}\n                onChange={(e) => {\n                  const raw = e.target.value;\n                  const num = Number(raw);\n                  let parsed;\n                  if (raw === \"\") {\n                    parsed = undefined;\n                  } else if (Number.isFinite(num)) {\n                    parsed = Math.max(1, Math.floor(num));\n                  } else {\n                    parsed = undefined;\n                  }\n                  updateField(\"factSelection\", {\n                    ...(worldContext.factSelection || {}),\n                    maxCount: parsed,\n                  });\n                }}\n                placeholder=\"max (6)\"\n                className=\"illuminator-input wce-facet-range-input\"\n              />\n            </div>\n            <div className=\"wce-facet-range-hint\">\n              Range of world-truth facts to facet. Required facts count toward this; min is raised\n              to match required count if needed.\n            </div>\n          </div>\n          <FactsEditor\n            facts={worldContext.canonFactsWithMetadata || []}\n            onChange={(facts) => updateField(\"canonFactsWithMetadata\", facts)}\n          />\n        </div>\n\n        {/* World Dynamics */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header wce-dynamics-header\">\n            <h2 className=\"illuminator-card-title\">World Dynamics</h2>\n            <div className=\"wce-dynamics-actions\">\n              <button\n                onClick={handleImportDynamicsJson}\n                className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n              >\n                Import JSON\n              </button>\n              {worldContext.worldDynamics?.length > 0 && (\n                <button\n                  onClick={() => {\n                    const json = JSON.stringify(worldContext.worldDynamics, null, 2);\n                    const blob = new Blob([json], { type: \"application/json\" });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = `dynamics-${new Date().toISOString().slice(0, 10)}.json`;\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(url);\n                  }}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  Export JSON\n                </button>\n              )}\n              {onGenerateDynamics && (\n                <button\n                  onClick={onGenerateDynamics}\n                  disabled={isGeneratingDynamics}\n                  className=\"illuminator-button illuminator-button-secondary wce-dynamics-btn\"\n                >\n                  {isGeneratingDynamics ? \"Generating...\" : \"Generate from Lore\"}\n                </button>\n              )}\n            </div>\n          </div>\n          <p className=\"wce-description-text\">\n            Higher-level narrative context about inter-group forces and behaviors. These statements\n            describe macro-level dynamics that individual relationships are expressions of.\n            Optionally filter by culture or entity kind so they only appear in relevant chronicles.\n          </p>\n          <WorldDynamicsEditor\n            dynamics={worldContext.worldDynamics || []}\n            onChange={(dynamics) => updateField(\"worldDynamics\", dynamics)}\n            eras={eras}\n          />\n        </div>\n\n\n        {/* Tone Fragments */}\n        <div className=\"illuminator-card\">\n          <div className=\"illuminator-card-header\">\n            <h2 className=\"illuminator-card-title\">Tone Fragments</h2>\n          </div>\n          <p className=\"wce-description-text\">\n            Composable tone guidance. Core is always included; culture and kind overlays are added\n            based on the chronicle&apos;s entity constellation.\n          </p>\n          <ToneFragmentsEditor\n            fragments={worldContext.toneFragments || {}}\n            onChange={(fragments) => updateField(\"toneFragments\", fragments)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  worldContext,\n  onWorldContextChange,\n  eras,\n  onGenerateDynamics,\n  isGeneratingDynamics,\n}", "type": "{ worldContext: any; onWorldContextChange: any; eras: any; onGenerateDynamics: any; isGeneratingDynamics: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/hooks/useApiKeys.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useApiKeys.js", "sourceCode": "export default function useApiKeys() {\n  const [persistApiKeys, setPersistApiKeys] = useState(() =>\n    readPersistedFlag(\"illuminator:persistApiKeys\")\n  );\n  const [anthropicApiKey, setAnthropicApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:anthropicApiKey\")\n  );\n  const [openaiApiKey, setOpenaiApiKey] = useState(() =>\n    readPersistedApiKey(\"illuminator:openaiApiKey\")\n  );\n  const [showApiKeyInput, setShowApiKeyInput] = useState(false);\n\n  // Persist API keys when enabled\n  useEffect(() => {\n    try {\n      localStorage.setItem(\"illuminator:persistApiKeys\", persistApiKeys ? \"true\" : \"false\");\n      if (persistApiKeys) {\n        localStorage.setItem(\"illuminator:anthropicApiKey\", anthropicApiKey);\n        localStorage.setItem(\"illuminator:openaiApiKey\", openaiApiKey);\n      } else {\n        localStorage.removeItem(\"illuminator:anthropicApiKey\");\n        localStorage.removeItem(\"illuminator:openaiApiKey\");\n      }\n    } catch {\n      /* ignored */\n    }\n  }, [persistApiKeys, anthropicApiKey, openaiApiKey]);\n\n  const hasAnthropicKey = anthropicApiKey.length > 0;\n  const hasRequiredKeys = hasAnthropicKey;\n\n  return {\n    persistApiKeys,\n    setPersistApiKeys,\n    anthropicApiKey,\n    setAnthropicApiKey,\n    openaiApiKey,\n    setOpenaiApiKey,\n    showApiKeyInput,\n    setShowApiKeyInput,\n    hasAnthropicKey,\n    hasRequiredKeys,\n  };\n}", "parameters": [], "returnType": "{ persistApiKeys: boolean; setPersistApiKeys: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; anthropicApiKey: string; setAnthropicApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; openaiApiKey: string; setOpenaiApiKey: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<string>>; showApiKeyInput: boolean; setShowApiKeyInput: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").SetStateAction<boolean>>; hasAnthropicKey: boolean; hasRequiredKeys: boolean; }"}, {"id": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts::deriveStatus", "name": "deriveStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useChronicleGeneration.ts", "sourceCode": "/**\n * Derive status from what's present in the record.\n * This eliminates status synchronization issues.\n */\nexport function deriveStatus(record: ChronicleRecord | undefined): string {\n  if (!record) return \"not_started\";\n\n  if (record.status === \"failed\") return \"failed\";\n\n  // Check for in-progress states (worker is running)\n  if (record.status === \"generating\") {\n    return record.status;\n  }\n\n  // Derive from data presence (completed states)\n  if (record.finalContent || record.status === \"complete\") return \"complete\";\n  if (record.assembledContent) return \"assembly_ready\";\n\n  return \"not_started\";\n}", "parameters": [{"name": "record", "type": "ChronicleRecord | undefined", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/hooks/useConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useConfigSync.js", "sourceCode": "export default function useConfigSync({ externalEnrichmentConfig, onEnrichmentConfigChange }) {\n  const [localConfig, setLocalConfig] = useState(() =>\n    initializeEnrichmentConfig(externalEnrichmentConfig)\n  );\n  const pendingConfigSyncRef = useRef(null);\n  const skipConfigSyncRef = useRef(false);\n\n  // Detect external config changes during render (no ref access)\n  const [prevExternalConfig, setPrevExternalConfig] = useState(externalEnrichmentConfig);\n  if (externalEnrichmentConfig !== prevExternalConfig) {\n    setPrevExternalConfig(externalEnrichmentConfig);\n    if (externalEnrichmentConfig) {\n      setLocalConfig(normalizeEnrichmentConfig(externalEnrichmentConfig) || DEFAULT_CONFIG);\n    }\n  }\n\n  // Mark skip flag in effect (runs before sync effect due to declaration order)\n  useEffect(() => {\n    if (externalEnrichmentConfig) {\n      skipConfigSyncRef.current = true;\n      pendingConfigSyncRef.current = null;\n    }\n  }, [externalEnrichmentConfig]);\n\n  const config = localConfig;\n\n  const setConfig = useCallback((updater) => {\n    setLocalConfig((prev) => {\n      const next = typeof updater === \"function\" ? updater(prev) : updater;\n      pendingConfigSyncRef.current = next;\n      return next;\n    });\n  }, []);\n\n  // Sync local changes to parent (or localStorage)\n  useEffect(() => {\n    if (skipConfigSyncRef.current) {\n      skipConfigSyncRef.current = false;\n      pendingConfigSyncRef.current = null;\n      return;\n    }\n    const pending = pendingConfigSyncRef.current;\n    if (!pending) return;\n    pendingConfigSyncRef.current = null;\n    if (onEnrichmentConfigChange) {\n      onEnrichmentConfigChange(pending);\n    } else {\n      try {\n        localStorage.setItem(\"illuminator:config\", JSON.stringify(pending));\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [localConfig, onEnrichmentConfigChange]);\n\n  const updateConfig = useCallback(\n    (updates) => {\n      setConfig((prev) => ({ ...prev, ...updates }));\n    },\n    [setConfig]\n  );\n\n  return { config, setConfig, updateConfig };\n}", "parameters": [{"name": "{ externalEnrichmentConfig, onEnrichmentConfigChange }", "type": "{ externalEnrichmentConfig: any; onEnrichmentConfigChange: any; }", "optional": false}], "returnType": "{ config: { imageModel: string; minProminenceForImage: string; numWorkers: number; requireDescription: boolean; useClaudeForImagePrompt: boolean; claudeImagePromptTemplate: string; globalImageRules: string; minEventSignificance: number; }; setConfig: (updater: any) => void; updateConfig: (updates: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useEntityCrud.ts::reloadEntities", "name": "reloadEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityCrud.ts", "sourceCode": "// ============================================================================\n// Module-level helper \u2014 reusable by other hooks without prop threading\n// ============================================================================\n\n/**\n * Refresh entity store and notify the host shell.\n * Reads simulationRunId imperatively from the entity store.\n */\nexport async function reloadEntities(invalidateIds?: string[]): Promise<void> {\n  const store = useEntityStore.getState();\n  const { simulationRunId } = store;\n  if (!simulationRunId) return;\n\n  if (invalidateIds?.length) {\n    await store.refreshEntities(invalidateIds);\n  } else {\n    await store.refreshAll();\n  }\n\n  window.dispatchEvent(\n    new CustomEvent(\"illuminator:worlddata-changed\", {\n      detail: { simulationRunId, scope: \"entities\" },\n    })\n  );\n}", "parameters": [{"name": "invalidateIds", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useEntityGuidanceSync.js", "sourceCode": "export default function useEntityGuidanceSync({\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}) {\n  const [localEntityGuidance, setLocalEntityGuidance] = useState(createDefaultEntityGuidance);\n  const [localCultureIdentities, setLocalCultureIdentities] = useState(\n    createDefaultCultureIdentities\n  );\n  const pendingEntityGuidanceRef = useRef(localEntityGuidance);\n  const pendingCultureIdentitiesRef = useRef(localCultureIdentities);\n\n  // Detect external changes during render (no ref access)\n  const [prevGuidance, setPrevGuidance] = useState(externalEntityGuidance);\n  if (externalEntityGuidance !== prevGuidance) {\n    setPrevGuidance(externalEntityGuidance);\n    if (externalEntityGuidance !== undefined) {\n      setLocalEntityGuidance(externalEntityGuidance || createDefaultEntityGuidance());\n    }\n  }\n  const [prevIdentities, setPrevIdentities] = useState(externalCultureIdentities);\n  if (externalCultureIdentities !== prevIdentities) {\n    setPrevIdentities(externalCultureIdentities);\n    if (externalCultureIdentities !== undefined) {\n      setLocalCultureIdentities(externalCultureIdentities || createDefaultCultureIdentities());\n    }\n  }\n\n  // Sync refs in effects\n  useEffect(() => {\n    if (externalEntityGuidance !== undefined) {\n      pendingEntityGuidanceRef.current = externalEntityGuidance || createDefaultEntityGuidance();\n    }\n  }, [externalEntityGuidance]);\n  useEffect(() => {\n    if (externalCultureIdentities !== undefined) {\n      pendingCultureIdentitiesRef.current =\n        externalCultureIdentities || createDefaultCultureIdentities();\n    }\n  }, [externalCultureIdentities]);\n\n  const entityGuidanceSyncTimeoutRef = useRef(null);\n  const updateEntityGuidance = useCallback(\n    (nextGuidance) => {\n      setLocalEntityGuidance(nextGuidance);\n      pendingEntityGuidanceRef.current = nextGuidance;\n      if (!onEntityGuidanceChange) return;\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      entityGuidanceSyncTimeoutRef.current = setTimeout(() => {\n        onEntityGuidanceChange(pendingEntityGuidanceRef.current);\n        entityGuidanceSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onEntityGuidanceChange]\n  );\n\n  const cultureIdentitiesSyncTimeoutRef = useRef(null);\n  const updateCultureIdentities = useCallback(\n    (nextIdentities) => {\n      setLocalCultureIdentities(nextIdentities);\n      pendingCultureIdentitiesRef.current = nextIdentities;\n      if (!onCultureIdentitiesChange) return;\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n      cultureIdentitiesSyncTimeoutRef.current = setTimeout(() => {\n        onCultureIdentitiesChange(pendingCultureIdentitiesRef.current);\n        cultureIdentitiesSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onCultureIdentitiesChange]\n  );\n\n  useEffect(\n    () => () => {\n      if (entityGuidanceSyncTimeoutRef.current) clearTimeout(entityGuidanceSyncTimeoutRef.current);\n      if (cultureIdentitiesSyncTimeoutRef.current)\n        clearTimeout(cultureIdentitiesSyncTimeoutRef.current);\n    },\n    []\n  );\n\n  return {\n    entityGuidance: localEntityGuidance,\n    updateEntityGuidance,\n    cultureIdentities: localCultureIdentities,\n    updateCultureIdentities,\n  };\n}", "parameters": [{"name": "{\n  externalEntityGuidance,\n  onEntityGuidanceChange,\n  externalCultureIdentities,\n  onCultureIdentitiesChange,\n}", "type": "{ externalEntityGuidance: any; onEntityGuidanceChange: any; externalCultureIdentities: any; onCultureIdentitiesChange: any; }", "optional": false}], "returnType": "{ entityGuidance: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").EntityGuidance; updateEntityGuidance: (nextGuidance: any) => void; cultureIdentities: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/promptBuilders\").CultureIdentities; updateCultureIdentities: (nextIdentities: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useHistorianActions.ts::registerHistorianStarters", "name": "registerHistorianStarters", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianActions.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the primitive hook start functions.\n * The isActive flags are synced to useIlluminatorConfigStore instead.\n */\nexport function registerHistorianStarters(starters: HistorianStarters): void {\n  _starters = starters;\n}", "parameters": [{"name": "starters", "type": "HistorianStarters", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useHistorianConfigSync.js", "sourceCode": "export default function useHistorianConfigSync({\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}) {\n  const [localHistorianConfig, setLocalHistorianConfig] = useState(() =>\n    resolveInitialHistorianConfig(externalHistorianConfig)\n  );\n  const [hasMigrated, setHasMigrated] = useState(false);\n  const pendingHistorianConfigRef = useRef(localHistorianConfig);\n\n  // Detect external changes during render (no ref access)\n  const [prevExternal, setPrevExternal] = useState(externalHistorianConfig);\n  if (externalHistorianConfig !== prevExternal) {\n    setPrevExternal(externalHistorianConfig);\n    if (externalHistorianConfig !== undefined) {\n      const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n      setLocalHistorianConfig(resolved.config);\n      if (resolved.migrated !== hasMigrated) setHasMigrated(resolved.migrated);\n    }\n  }\n\n  // Ref + side effects in effect (legacy migration, cleanup)\n  useEffect(() => {\n    if (externalHistorianConfig === undefined) return;\n    const resolved = resolveExternalChange(externalHistorianConfig, hasMigrated);\n    pendingHistorianConfigRef.current = resolved.config;\n    if (resolved.migrated && !externalHistorianConfig) {\n      if (onHistorianConfigChange) onHistorianConfigChange(resolved.config);\n      try {\n        localStorage.removeItem(LEGACY_HISTORIAN_CONFIG_KEY);\n      } catch {\n        /* ignored */\n      }\n    }\n  }, [externalHistorianConfig, onHistorianConfigChange, hasMigrated]);\n\n  const historianConfigSyncTimeoutRef = useRef(null);\n  const updateHistorianConfig = useCallback(\n    (next) => {\n      setLocalHistorianConfig(next);\n      pendingHistorianConfigRef.current = next;\n      if (!onHistorianConfigChange) return;\n      if (historianConfigSyncTimeoutRef.current)\n        clearTimeout(historianConfigSyncTimeoutRef.current);\n      historianConfigSyncTimeoutRef.current = setTimeout(() => {\n        onHistorianConfigChange(pendingHistorianConfigRef.current);\n        historianConfigSyncTimeoutRef.current = null;\n      }, 300);\n    },\n    [onHistorianConfigChange]\n  );\n\n  return { historianConfig: localHistorianConfig, updateHistorianConfig };\n}", "parameters": [{"name": "{\n  externalHistorianConfig,\n  onHistorianConfigChange,\n}", "type": "{ externalHistorianConfig: any; onHistorianConfigChange: any; }", "optional": false}], "returnType": "{ historianConfig: any; updateHistorianConfig: (next: any) => void; }"}, {"id": "apps/illuminator/webui/src/hooks/useSlotManagement.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useSlotManagement.js", "sourceCode": "export default function useSlotManagement({ projectId, activeSlotIndex, navEntities }) {\n  const [slotRecord, setSlotRecord] = useState(null);\n\n  // Adjust state during render when projectId changes (avoids setState-in-effect)\n  const [prevProjectSlot, setPrevProjectSlot] = useState({ projectId, activeSlotIndex });\n  const projectSlotChange = resolveProjectSlotChange(projectId, prevProjectSlot, activeSlotIndex);\n  if (projectSlotChange.changed) {\n    setPrevProjectSlot({ projectId, activeSlotIndex });\n    if (projectSlotChange.clearSlot) setSlotRecord(null);\n  }\n\n  // Load slot metadata from Dexie (async work stays in effect)\n  useEffect(() => {\n    if (!projectId) return;\n    let cancelled = false;\n\n    (async () => {\n      const slot = await slotRepo.getSlot(projectId, activeSlotIndex);\n      if (cancelled) return;\n      setSlotRecord(slot || null);\n      useEntityStore.getState().reset();\n      useIndexStore.getState().reset();\n      useNarrativeEventStore.getState().reset();\n      useRelationshipStore.getState().reset();\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [projectId, activeSlotIndex]);\n\n  const [currentEra, setCurrentEra] = useState(null);\n\n  // Adjust current era during render for synchronous cases\n  const [prevEraKey, setPrevEraKey] = useState(slotRecord?.finalEraId);\n  const currentEraId = slotRecord?.finalEraId;\n  if (currentEraId !== prevEraKey) {\n    setPrevEraKey(currentEraId);\n    const result = resolveEraRenderAdjustment(slotRecord, navEntities);\n    if (result.changed) setCurrentEra(result.era);\n  }\n\n  // Async full-entity load for era (when we have a nav match but need description)\n  useEffect(() => {\n    const resolved = resolveCurrentEra(slotRecord, navEntities);\n    if (!resolved.needsFullLoad) return;\n    useEntityStore\n      .getState()\n      .loadEntity(resolved.needsFullLoad)\n      .then((full) => {\n        setCurrentEra(buildEraFromLoadedEntity(full, resolved.needsFullLoad));\n      });\n  }, [slotRecord, navEntities]);\n\n  const eraTemporalInfo = useEraTemporalInfo();\n  const eraTemporalInfoByKey = useEraTemporalInfoByKey();\n  const prominentByCulture = useProminentByCulture();\n\n  // Extract simulationRunId from slot metadata for content association\n  const simulationRunId = slotRecord?.simulationRunId;\n\n  return {\n    slotRecord,\n    setSlotRecord,\n    simulationRunId,\n    currentEra,\n    eraTemporalInfo,\n    eraTemporalInfoByKey,\n    prominentByCulture,\n  };\n}", "parameters": [{"name": "{ projectId, activeSlotIndex, navEntities }", "type": "{ projectId: any; activeSlotIndex: any; navEntities: any; }", "optional": false}], "returnType": "{ slotRecord: any; setSlotRecord: import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/index\").Dispatch<any>; simulationRunId: any; currentEra: any; eraTemporalInfo: import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry[]; eraTemporalInfoByKey: Map<string, import(\"/home/tsonu/src/the-canonry/apps/illuminator/webui/src/lib/db/indexTypes\").EraTemporalEntry>; prominentByCulture: Record<string, { id: string; name: string; }[]>; }"}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::assignCorpusTones", "name": "assignCorpusTones", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "/**\n * Assign tones to chronicles with strong rank-1 preference but distribution balancing.\n * Chronicles only shift from rank-1 if their preferred tone is heavily overrepresented\n * AND they have a good alternative that fills an underrepresented slot.\n */\nexport function assignCorpusTones(\n  chronicles: Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>\n): ToneAssignmentEntry[] {\n  const entries: ToneAssignmentEntry[] = chronicles.map((c) => ({\n    chronicleId: c.chronicleId,\n    title: c.title,\n    ranking: c.ranking,\n    assignedTone: c.ranking[0],\n    wasShifted: false,\n  }));\n\n  const target = entries.length / ANNOTATION_TONES.length;\n  const ceiling = Math.ceil(target * 1.2);\n\n  for (let round = 0; round < 50; round++) {\n    const counts = countDistribution(entries);\n\n    let overTone: HistorianTone | null = null;\n    let overCount = ceiling;\n    for (const t of ANNOTATION_TONES) {\n      if (counts[t] > overCount) {\n        overTone = t;\n        overCount = counts[t];\n      }\n    }\n    if (!overTone) break;\n\n    let shifted = false;\n    const candidates = entries\n      .filter((e) => e.assignedTone === overTone)\n      .map((e) => {\n        for (const altRank of [1, 2] as const) {\n          const alt = e.ranking[altRank];\n          if (alt && counts[alt] < counts[overTone]) {\n            return { entry: e, alt, priority: altRank * 100 + counts[alt] };\n          }\n        }\n        return null;\n      })\n      .filter(\n        (c): c is { entry: ToneAssignmentEntry; alt: HistorianTone; priority: number } => c !== null\n      )\n      .sort((a, b) => a.priority - b.priority);\n\n    if (candidates.length > 0) {\n      const best = candidates[0];\n      best.entry.assignedTone = best.alt;\n      best.entry.wasShifted = true;\n      shifted = true;\n    }\n\n    if (!shifted) break;\n  }\n\n  return entries;\n}", "parameters": [{"name": "chronicles", "type": "Array<{\n    chronicleId: string;\n    title: string;\n    ranking: [HistorianTone, HistorianTone, HistorianTone];\n  }>", "optional": false}], "returnType": "ToneAssignmentEntry[]"}, {"id": "apps/illuminator/webui/src/hooks/useToneRanking.ts::countDistribution", "name": "countDistribution", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useToneRanking.ts", "sourceCode": "export function countDistribution(entries: ToneAssignmentEntry[]): Record<HistorianTone, number> {\n  const counts = Object.fromEntries(ANNOTATION_TONES.map((t) => [t, 0])) as Record<\n    HistorianTone,\n    number\n  >;\n  for (const e of entries) {\n    if (counts[e.assignedTone] !== undefined) counts[e.assignedTone]++;\n  }\n  return counts;\n}", "parameters": [{"name": "entries", "type": "ToneAssignmentEntry[]", "optional": false}], "returnType": "Record<HistorianTone, number>"}, {"id": "apps/illuminator/webui/src/hooks/useWorldContextSync.js::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/hooks/useWorldContextSync.js", "sourceCode": "export default function useWorldContextSync({ externalWorldContext, onWorldContextChange }) {\n  const [localWorldContext, setLocalWorldContext] = useState(DEFAULT_WORLD_CONTEXT);\n  const worldContext = localWorldContext;\n  const worldContextSyncTimeoutRef = useRef(null);\n  const worldContextDirtyRef = useRef(false);\n  const pendingWorldContextRef = useRef(localWorldContext);\n\n  // Detect external context changes during render (no ref access)\n  const [prevExternalContext, setPrevExternalContext] = useState(externalWorldContext);\n  if (externalWorldContext !== prevExternalContext) {\n    setPrevExternalContext(externalWorldContext);\n    if (externalWorldContext !== undefined) {\n      const nextContext = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n      setLocalWorldContext(nextContext);\n    }\n  }\n\n  // Ref side effects when external changes (clear timeout, update refs)\n  useEffect(() => {\n    if (externalWorldContext === undefined) return;\n    if (worldContextSyncTimeoutRef.current) {\n      clearTimeout(worldContextSyncTimeoutRef.current);\n      worldContextSyncTimeoutRef.current = null;\n    }\n    worldContextDirtyRef.current = false;\n    pendingWorldContextRef.current = externalWorldContext || DEFAULT_WORLD_CONTEXT;\n  }, [externalWorldContext]);\n\n  const updateWorldContext = useCallback(\n    (updates) => {\n      setLocalWorldContext((prev) => {\n        const merged = { ...prev, ...updates };\n        pendingWorldContextRef.current = merged;\n        if (onWorldContextChange) {\n          worldContextDirtyRef.current = true;\n          if (worldContextSyncTimeoutRef.current) {\n            clearTimeout(worldContextSyncTimeoutRef.current);\n          }\n          worldContextSyncTimeoutRef.current = setTimeout(() => {\n            if (!worldContextDirtyRef.current) return;\n            worldContextDirtyRef.current = false;\n            onWorldContextChange(pendingWorldContextRef.current);\n            worldContextSyncTimeoutRef.current = null;\n          }, 300);\n        }\n        return merged;\n      });\n    },\n    [onWorldContextChange]\n  );\n\n  useEffect(() => {\n    return () => {\n      if (worldContextSyncTimeoutRef.current) {\n        clearTimeout(worldContextSyncTimeoutRef.current);\n        worldContextSyncTimeoutRef.current = null;\n      }\n      if (worldContextDirtyRef.current && onWorldContextChange) {\n        onWorldContextChange(pendingWorldContextRef.current);\n      }\n    };\n  }, [onWorldContextChange]);\n\n  return { worldContext, updateWorldContext };\n}", "parameters": [{"name": "{ externalWorldContext, onWorldContextChange }", "type": "{ externalWorldContext: any; onWorldContextChange: any; }", "optional": false}], "returnType": "{ worldContext: { name: string; description: string; toneFragments: { core: string; }; canonFactsWithMetadata: any[]; factSelection: {}; worldDynamics: any[]; }; updateWorldContext: (updates: any) => void; }"}, {"id": "apps/illuminator/webui/src/lib/annotateEntityNames.ts::annotateEntityNames", "name": "annotateEntityNames", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/annotateEntityNames.ts", "sourceCode": "export function annotateEntityNames(text: string, navItems: Map<string, EntityNavItem>): string {\n  const candidates = buildCandidates(navItems);\n\n  // Track annotated regions in the mutated string's coordinates.\n  // After each replacement the ranges shift -- we adjust all existing ranges\n  // so overlap checks always work against current positions.\n  const annotatedRanges: Array<[number, number]> = [];\n  const overlaps = (start: number, end: number): boolean =>\n    annotatedRanges.some(([rs, re]) => start < re && end > rs);\n\n  let result = text;\n\n  for (const { name, annotation } of candidates) {\n    const idx = result.indexOf(name);\n    if (idx === -1) continue;\n\n    const afterName = idx + name.length;\n    if (isAlreadyAnnotated(result, afterName)) continue;\n    if (overlaps(idx, afterName)) continue;\n\n    result = result.slice(0, idx) + annotation + result.slice(afterName);\n    const delta = annotation.length - name.length;\n    shiftRanges(annotatedRanges, afterName, delta);\n    annotatedRanges.push([idx, idx + annotation.length]);\n  }\n\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "navItems", "type": "Map<string, EntityNavItem>", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts::executeBrowserTask", "name": "executeBrowserTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/browserTaskExecutor.ts", "sourceCode": "/**\n * Execute an enrichment task in the main browser thread.\n *\n * Returns the same TaskResult shape as the service worker path.\n */\nexport async function executeBrowserTask(\n  task: WorkerTask,\n  config: WorkerConfig,\n  callbacks?: BrowserTaskCallbacks\n): Promise<TaskResult> {\n  // Merge task-level llmCallSettings with global config\n  const taskConfig = task.llmCallSettings\n    ? { ...config, llmCallSettings: task.llmCallSettings }\n    : config;\n\n  const { llmClient, imageClient } = createClients(taskConfig);\n\n  console.log(\"[BrowserTask] Started\", { taskId: task.id, type: task.type });\n\n  try {\n    const result = await executeTask(task, {\n      config: taskConfig,\n      llmClient,\n      imageClient,\n      isAborted: () => false,\n      onThinkingDelta: callbacks?.onThinkingDelta\n        ? (delta) => callbacks.onThinkingDelta(task.id, delta)\n        : undefined,\n      onTextDelta: callbacks?.onTextDelta\n        ? (delta) => callbacks.onTextDelta(task.id, delta)\n        : undefined,\n    });\n\n    if (result.success) {\n      await persistResult(task, result.result);\n      console.log(\"[BrowserTask] Complete\", { taskId: task.id, type: task.type });\n    } else {\n      console.warn(\"[BrowserTask] Failed\", { taskId: task.id, error: result.error });\n    }\n\n    return result;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    console.error(\"[BrowserTask] Threw\", { taskId: task.id, error: message });\n    return { success: false, error: message };\n  }\n}", "parameters": [{"name": "task", "type": "WorkerTask", "optional": false}, {"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callbacks", "type": "BrowserTaskCallbacks", "optional": true}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildEventHeadline", "name": "buildEventHeadline", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build a stable event headline from subject + action, including description.\n */\nexport function buildEventHeadline(event: {\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}): string {\n  const subjectName = event.subject?.name || event.subject?.id || \"\";\n  const action = event.action || \"\";\n  const base = [subjectName, action].filter(Boolean).join(\" \").trim();\n  if (event.description) {\n    return base ? `${base} - ${event.description}` : event.description;\n  }\n  return base || \"(event)\";\n}", "parameters": [{"name": "event", "type": "{\n  subject?: { id?: string; name?: string };\n  action?: string;\n  description?: string;\n}", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::buildChronicleContext", "name": "buildChronicleContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Build generation context from chronicle selections (chronicle-first architecture)\n *\n * This is the primary entry point for building generation context.\n * Role assignments define the chronicle's identity, not a single entity.\n *\n * @param selections - Chronicle selections from wizard\n * @param worldData - World simulation data\n * @param worldContext - World context (name, description, etc.)\n * @param narrativeStyle - Narrative style selected for this chronicle\n * @param nameBank - Optional pre-generated names by culture for invented characters\n * @param proseHints - Optional per-kind prose hints for narrative guidance\n * @param culturalIdentities - Optional cultural identity data (VALUES, SPEECH, FEARS, TABOOS etc.)\n * @param temporalContext - Optional temporal context computed from selected events and eras\n * @param narrativeDirection - Optional free-text narrative direction from wizard\n */\nexport function buildChronicleContext(\n  selections: ChronicleSelections,\n  worldData: WorldData,\n  worldContext: WorldContext,\n  narrativeStyle: NarrativeStyle,\n  nameBank?: Record<string, string[]>,\n  proseHints?: Record<string, string>,\n  culturalIdentities?: Record<string, Record<string, string>>,\n  temporalContext?: ChronicleTemporalContext | null,\n  narrativeDirection?: string\n): ChronicleGenerationContext {\n  const entityMap = new Map(worldData.entities.map((e) => [e.id, e]));\n\n  // Build focus from role assignments\n  const focus = buildFocus(\n    selections.roleAssignments,\n    selections.selectedEventIds,\n    selections.selectedRelationshipIds,\n    selections.lens\n  );\n\n  // Get entities from role assignments\n  const entities = worldData.entities\n    .filter((e) => focus.selectedEntityIds.includes(e.id))\n    .map(buildEntityContext);\n\n  // Parse relationship IDs (format: src:dst:kind) and get selected relationships\n  const relationships = selections.selectedRelationshipIds\n    .map((id) => {\n      const [src, dst, kind] = id.split(\":\");\n      return worldData.relationships.find((r) => r.src === src && r.dst === dst && r.kind === kind);\n    })\n    .filter((r): r is NonNullable<typeof r> => r !== undefined)\n    .map((r) => buildRelationshipContext(r, entityMap));\n\n  // Get selected events\n  const eventIdSet = new Set(selections.selectedEventIds);\n  const events = (worldData.narrativeHistory || [])\n    .filter((e) => eventIdSet.has(e.id))\n    .sort((a, b) => b.significance - a.significance)\n    .map(buildEventContext);\n\n  // Resolve lens entity from world data\n  const lensRaw = selections.lens ? entityMap.get(selections.lens.entityId) : undefined;\n  const lensEntity = lensRaw ? buildEntityContext(lensRaw) : undefined;\n\n  // Resolve era: prefer temporalContext.focalEra (user-selected), fall back to primary entity's era\n  let eraContext: EraContext | undefined;\n  if (temporalContext?.focalEra) {\n    // Use the user-selected focal era from temporal context\n    eraContext = {\n      id: temporalContext.focalEra.id,\n      name: temporalContext.focalEra.name,\n      description: temporalContext.focalEra.summary,\n    };\n  } else {\n    // Fall back to deriving from primary entity's eraId\n    const eraLookup = buildEraLookup(worldData.entities);\n    const primaryEntityId = focus.primaryEntityIds[0];\n    const primaryEntity = primaryEntityId ? entityMap.get(primaryEntityId) : undefined;\n    const primaryEraId = resolveEntityEraId(primaryEntity);\n    const era = primaryEraId ? eraLookup.get(primaryEraId) : undefined;\n    eraContext = era ? buildEraContext(era) : undefined;\n  }\n\n  return {\n    worldName: worldContext.name || \"The World\",\n    worldDescription: worldContext.description || \"\",\n    // These will be populated by perspective synthesis\n    canonFacts: [],\n    tone: \"\",\n    narrativeStyle,\n\n    // Input for perspective synthesis (required)\n    toneFragments: worldContext.toneFragments,\n    canonFactsWithMetadata: worldContext.canonFactsWithMetadata,\n    factSelection: worldContext.factSelection,\n\n    // Chronicle focus (primary)\n    focus,\n\n    // Narrative lens entity (contextual frame)\n    lensEntity,\n\n    era: eraContext,\n    // Full temporal context with all eras and chronicle timeline\n    temporalContext: temporalContext || undefined,\n    entities,\n    relationships,\n    events,\n\n    // Name bank for invented characters\n    nameBank,\n\n    // Prose hints for entity kinds (e.g., how to write about NPCs vs locations)\n    proseHints,\n\n    // Cultural identities for cultures (VALUES, SPEECH, FEARS, TABOOS, etc.)\n    culturalIdentities,\n\n    // World dynamics (narrative context statements)\n    worldDynamics: worldContext.worldDynamics,\n\n    // Narrative direction (optional, from wizard)\n    narrativeDirection: narrativeDirection || undefined,\n  };\n}", "parameters": [{"name": "selections", "type": "ChronicleSelections", "optional": false}, {"name": "worldData", "type": "WorldData", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "narrativeStyle", "type": "NarrativeStyle", "optional": false}, {"name": "nameBank", "type": "Record<string, string[]>", "optional": true}, {"name": "proseHints", "type": "Record<string, string>", "optional": true}, {"name": "culturalIdentities", "type": "Record<string, Record<string, string>>", "optional": true}, {"name": "temporalContext", "type": "ChronicleTemporalContext | null", "optional": true}, {"name": "narrativeDirection", "type": "string", "optional": true}], "returnType": "ChronicleGenerationContext"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::checkPrerequisites", "name": "checkPrerequisites", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "export function checkPrerequisites(context: ChronicleGenerationContext): PrerequisiteCheck {\n  const missing: PrerequisiteCheck[\"missing\"] = [];\n\n  if (!context.focus?.roleAssignments) {\n    return { ready: false, missing };\n  }\n\n  // Check that primary entities have descriptions\n  for (const role of context.focus.roleAssignments.filter((r) => r.isPrimary)) {\n    const entity = context.entities.find((e) => e.id === role.entityId);\n    if (entity && !(entity.summary && entity.description)) {\n      missing.push({\n        type: \"entityDescription\",\n        id: entity.id,\n        name: entity.name,\n      });\n    }\n  }\n\n  return {\n    ready: missing.length === 0,\n    missing,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "PrerequisiteCheck"}, {"id": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts::summarizeContext", "name": "summarizeContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleContextBuilder.ts", "sourceCode": "/**\n * Get a summary of context for display\n */\nexport function summarizeContext(context: ChronicleGenerationContext): {\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n} {\n  const prominenceScale = buildProminenceScale(\n    context.entities\n      .map((entity) => Number(entity.prominence))\n      .filter((value) => Number.isFinite(value)),\n    { distribution: DEFAULT_PROMINENCE_DISTRIBUTION }\n  );\n  const prominentThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  const prominentEntities = context.entities\n    .filter((e) => Number(e.prominence) >= prominentThreshold)\n    .map((e) => e.name)\n    .slice(0, 10);\n\n  const highSignificanceEvents = context.events\n    .filter((e) => e.significance >= 0.7)\n    .map((e) => e.headline)\n    .slice(0, 5);\n\n  return {\n    entityCount: context.entities.length,\n    relationshipCount: context.relationships.length,\n    eventCount: context.events.length,\n    prominentEntities,\n    highSignificanceEvents,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "{\n  entityCount: number;\n  relationshipCount: number;\n  eventCount: number;\n  prominentEntities: string[];\n  highSignificanceEvents: string[];\n}"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildChronicleExport", "name": "buildChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Build the full chronicle export from STORED data only.\n *\n * This function uses only what is stored in the ChronicleRecord.\n * No reconstruction, no parameter passing of generation context.\n */\nexport function buildChronicleExport(chronicle: ChronicleRecord): ChronicleExport {\n  const versions = [...(chronicle.generationHistory || [])].sort(\n    (a, b) => a.generatedAt - b.generatedAt\n  );\n  const latestVersion = versions.reduce(\n    (acc, v) => (acc && acc.generatedAt > v.generatedAt ? acc : v),\n    versions[0]\n  );\n  const activeVersionId = chronicle.activeVersionId || latestVersion?.versionId;\n  const isAccepted = Boolean(chronicle.acceptedAt && chronicle.finalContent);\n  const acceptedVersionId =\n    chronicle.acceptedVersionId || (isAccepted ? activeVersionId : undefined);\n  const effectiveVersionId = isAccepted ? acceptedVersionId || activeVersionId : activeVersionId;\n\n  const currentContent = chronicle.assembledContent || chronicle.finalContent || \"\";\n  const historyMatch = versions.find((version) => version.versionId === effectiveVersionId);\n  const effectiveVersion = historyMatch\n    ? {\n        id: historyMatch.versionId,\n        content: historyMatch.content,\n        wordCount: historyMatch.wordCount,\n        systemPrompt: historyMatch.systemPrompt,\n        userPrompt: historyMatch.userPrompt,\n        model: historyMatch.model,\n      }\n    : {\n        id: effectiveVersionId || \"unknown\",\n        content: currentContent,\n        wordCount: currentContent.split(/\\s+/).filter(Boolean).length,\n        systemPrompt:\n          chronicle.generationSystemPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        userPrompt:\n          chronicle.generationUserPrompt ||\n          \"(prompt not stored - chronicle generated before prompt storage was implemented)\",\n        model: chronicle.model,\n      };\n\n  const content =\n    isAccepted && chronicle.finalContent ? chronicle.finalContent : effectiveVersion.content;\n  const wordCount =\n    isAccepted && chronicle.finalContent\n      ? chronicle.finalContent.split(/\\s+/).filter(Boolean).length\n      : effectiveVersion.wordCount;\n  const systemPrompt = effectiveVersion.systemPrompt;\n  const userPrompt = effectiveVersion.userPrompt;\n  const exportData: ChronicleExport = {\n    exportVersion: \"1.3\",\n    exportedAt: new Date().toISOString(),\n    activeVersionId,\n    acceptedVersionId,\n\n    chronicle: {\n      id: chronicle.chronicleId,\n      title: chronicle.title,\n      format: chronicle.format,\n      focusType: chronicle.focusType,\n      narrativeStyleId: chronicle.narrativeStyleId,\n      narrativeStyleName: chronicle.narrativeStyle?.name,\n      craftPosture: chronicle.narrativeStyle?.craftPosture,\n      lens: chronicle.lens\n        ? {\n            entityId: chronicle.lens.entityId,\n            entityName: chronicle.lens.entityName,\n            entityKind: chronicle.lens.entityKind,\n          }\n        : undefined,\n      narrativeDirection: chronicle.narrativeDirection,\n      createdAt: new Date(chronicle.createdAt).toISOString(),\n      acceptedAt: chronicle.acceptedAt ? new Date(chronicle.acceptedAt).toISOString() : undefined,\n      model: chronicle.model,\n    },\n\n    content,\n    wordCount,\n\n    generationLLMCall: {\n      systemPrompt,\n      userPrompt,\n      model: effectiveVersion.model,\n    },\n  };\n\n  exportData.versions = versions.map((version) => ({\n    versionId: version.versionId,\n    generatedAt: new Date(version.generatedAt).toISOString(),\n    sampling: version.sampling,\n    step: version.step,\n    model: version.model,\n    wordCount: version.wordCount,\n    content: version.content,\n    systemPrompt: version.systemPrompt,\n    userPrompt: version.userPrompt,\n    cost: version.cost,\n  }));\n\n  attachOptionalExportFields(exportData, chronicle);\n\n  return exportData;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleExport"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadChronicleExport", "name": "downloadChronicleExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "/**\n * Export chronicle to JSON file download.\n *\n * Uses ONLY data stored in the chronicle record - no external parameters.\n */\nexport function downloadChronicleExport(chronicle: ChronicleRecord): void {\n  const exportData = buildChronicleExport(chronicle);\n\n  // Create filename from chronicle title\n  const safeTitle = chronicle.title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `chronicle-export-${safeTitle}-${Date.now()}.json`;\n\n  // Create blob and download\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkAnnotationReviewExport", "name": "downloadBulkAnnotationReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Annotation Review Export\n// =============================================================================\n\nexport async function downloadBulkAnnotationReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n\n  const annotated = chronicles\n    .filter((c) => c.historianNotes && c.historianNotes.filter(isNoteActive).length > 0)\n    .sort((a, b) => (a.title || \"\").localeCompare(b.title || \"\"));\n\n  const rows = annotated.map((c) => {\n    const notes = (c.historianNotes || []).filter(isNoteActive);\n    return {\n      title: c.title || \"Untitled\",\n      format: c.format || \"story\",\n      narrativeStyleName: c.narrativeStyle?.name || c.narrativeStyleId || null,\n      assignedTone: c.assignedTone || null,\n      noteCount: notes.length,\n      annotations: notes.map((n) => ({\n        type: n.type,\n        display: n.display,\n        anchorPhrase: n.anchorPhrase,\n        text: n.text,\n      })),\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    totalAnnotations: rows.reduce((sum, r) => sum + r.noteCount, 0),\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-annotation-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadBulkToneReviewExport", "name": "downloadBulkToneReviewExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "// =============================================================================\n// Bulk Tone Review Export\n// =============================================================================\n\nexport async function downloadBulkToneReviewExport(simulationRunId: string): Promise<void> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const corpusStrength = await computeCorpusFactStrength(simulationRunId);\n\n  const complete = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n\n  const rows = complete.map((c) => {\n    const wordCount = c.finalContent?.split(/\\s+/).length || c.wordCount || 0;\n    const noteRange = computeNoteRange(\"chronicle\", wordCount);\n\n    // Compute fact coverage guidance using the same logic as the annotation prompt\n    const guidance = c.factCoverageReport\n      ? buildFactCoverageGuidance(c.factCoverageReport, corpusStrength)\n      : null;\n\n    const maxRequired = noteRange.max <= 4 ? 1 : (guidance?.length ?? 0);\n    const required = guidance?.slice(0, maxRequired) ?? [];\n    const optional = guidance?.slice(maxRequired) ?? [];\n\n    return {\n      title: c.title || \"Untitled\",\n      summary: c.summary || null,\n      brief: c.perspectiveSynthesis?.brief || null,\n      wordCount,\n      noteRange,\n      assignedTone: c.assignedTone || null,\n      toneRanking: c.toneRanking\n        ? {\n            ranking: c.toneRanking.ranking,\n            rationales: c.toneRanking.rationales || { _legacy: c.toneRanking.rationale },\n          }\n        : null,\n      factCoverage:\n        c.factCoverageReport?.entries?.map((e) => ({\n          factId: e.factId,\n          rating: e.rating,\n          wasFaceted: e.wasFaceted,\n        })) || null,\n      annotationGuidance: {\n        required: required.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n        optional: optional.map((t) => ({\n          factId: t.factId,\n          action: t.action,\n          evidence: t.evidence,\n          corpusStrength: t.corpusStrength,\n        })),\n      },\n    };\n  });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    totalChronicles: rows.length,\n    chronicles: rows,\n  };\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `chronicle-tone-review-${Date.now()}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::buildEraNarrativeExport", "name": "buildEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function buildEraNarrativeExport(record: EraNarrativeRecord): EraNarrativeExport {\n  const exportData: EraNarrativeExport = {\n    exportVersion: \"1.0\",\n    exportedAt: new Date().toISOString(),\n\n    narrative: {\n      narrativeId: record.narrativeId,\n      eraId: record.eraId,\n      eraName: record.eraName,\n      tone: record.tone,\n      ...(record.arcDirection ? { arcDirection: record.arcDirection } : {}),\n      status: record.status,\n      createdAt: new Date(record.createdAt).toISOString(),\n    },\n\n    sourceBriefs: record.prepBriefs.map((b) => ({\n      chronicleId: b.chronicleId,\n      chronicleTitle: b.chronicleTitle,\n      eraYear: b.eraYear,\n      ...(b.weight ? { weight: b.weight } : {}),\n      prep: b.prep,\n    })),\n\n    cost: {\n      totalInputTokens: record.totalInputTokens,\n      totalOutputTokens: record.totalOutputTokens,\n      totalActualCost: record.totalActualCost,\n    },\n  };\n\n  if (record.threadSynthesis) {\n    exportData.threadSynthesis = exportThreadSynthesis(record.threadSynthesis);\n  }\n\n  exportNarrativeContent(exportData, record);\n\n  return exportData;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "EraNarrativeExport"}, {"id": "apps/illuminator/webui/src/lib/chronicleExport.ts::downloadEraNarrativeExport", "name": "downloadEraNarrativeExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleExport.ts", "sourceCode": "export function downloadEraNarrativeExport(record: EraNarrativeRecord): void {\n  const exportData = buildEraNarrativeExport(record);\n\n  const safeTitle = (record.eraName || \"era-narrative\")\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .slice(0, 50);\n  const filename = `era-narrative-export-${safeTitle}-${Date.now()}.json`;\n\n  const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n    type: \"application/json\",\n  });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/chronicleTypes.ts::computeBackportProgress", "name": "computeBackportProgress", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicleTypes.ts", "sourceCode": "/**\n * Compute backport progress for a chronicle.\n * Total = roleAssignments + lens + accepted tertiary.\n * Done = entities present in entityBackportStatus.\n */\nexport function computeBackportProgress(record: {\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}): { done: number; total: number } {\n  const eligibleIds = new Set<string>();\n  for (const r of record.roleAssignments || []) {\n    eligibleIds.add(r.entityId);\n  }\n  if (record.lens) {\n    eligibleIds.add(record.lens.entityId);\n  }\n  for (const t of record.tertiaryCast || []) {\n    if (t.accepted) {\n      eligibleIds.add(t.entityId);\n    }\n  }\n  const statusMap = record.entityBackportStatus || {};\n  let done = 0;\n  for (const id of eligibleIds) {\n    if (statusMap[id]) done++;\n  }\n  return { done, total: eligibleIds.size };\n}", "parameters": [{"name": "record", "type": "{\n  roleAssignments?: ChronicleRoleAssignment[];\n  lens?: NarrativeLens;\n  tertiaryCast?: TertiaryCastEntry[];\n  entityBackportStatus?: Record<string, EntityBackportEntry>;\n}", "optional": false}], "returnType": "{ done: number; total: number }"}, {"id": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts::analyzeConstellation", "name": "analyzeConstellation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/constellationAnalyzer.ts", "sourceCode": "export function analyzeConstellation(input: ConstellationInput): EntityConstellation {\n  const { entities, relationships, events, focalEra } = input;\n\n  const { cultures, topCulture, cultureBalance } = analyzeCultures(entities);\n  const { kinds, topKind, kindFocus } = analyzeKinds(entities);\n  const { tagFrequency, prominentTags } = aggregateTags(entities);\n  const relationshipKinds = countRelationshipKinds(relationships);\n\n  const focalEraId = focalEra?.id || null;\n  const eraIds = new Set(events.map((e) => e.era).filter(Boolean));\n  const eraSpan: EraSpan = eraIds.size > 1 ? \"multiple\" : \"single\";\n\n  // ==========================================================================\n  // Spatial Analysis\n  // ==========================================================================\n\n  const coordinateCentroid = computeCentroid(entities);\n  const spatialSpread = computeSpatialSpread(entities);\n\n  // ==========================================================================\n  // Focus Summary\n  // ==========================================================================\n\n  const focusSummary = buildFocusSummary(\n    cultureBalance,\n    topCulture,\n    kindFocus,\n    prominentTags,\n    relationshipKinds\n  );\n\n  // ==========================================================================\n  // Return\n  // ==========================================================================\n\n  return {\n    cultures,\n    dominantCulture: cultureBalance !== \"mixed\" ? topCulture : null,\n    cultureBalance,\n    kinds,\n    dominantKind: topKind || null,\n    kindFocus,\n    tagFrequency,\n    prominentTags,\n    relationshipKinds,\n    focalEraId,\n    eraSpan,\n    coordinateCentroid,\n    spatialSpread,\n    focusSummary,\n  };\n}", "parameters": [{"name": "input", "type": "ConstellationInput", "optional": false}], "returnType": "EntityConstellation"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTokens", "name": "estimateTokens", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate tokens from text (word count based)\n */\nexport function estimateTokens(text: string): number {\n  const words = text.trim().split(/\\s+/).filter(Boolean).length;\n  return Math.ceil(words * TOKENS_PER_WORD);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCost", "name": "estimateTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for a text enrichment task\n */\nexport function estimateTextCost(\n  prompt: string,\n  type: \"description\",\n  model: string\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = EXPECTED_OUTPUT_TOKENS[type] || 300;\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "type", "type": "\"description\"", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateTextCostForCall", "name": "estimateTextCostForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "export function estimateTextCostForCall(\n  prompt: string,\n  callType: LLMCallType,\n  model: string,\n  outputTokensOverride?: number\n): { inputTokens: number; outputTokens: number; estimatedCost: number } {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputTokens = estimateTokens(prompt);\n  const outputTokens = resolveOutputTokensForCall(callType, outputTokensOverride);\n\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n\n  return {\n    inputTokens,\n    outputTokens,\n    estimatedCost: inputCost + outputCost,\n  };\n}", "parameters": [{"name": "prompt", "type": "string", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "outputTokensOverride", "type": "number", "optional": true}], "returnType": "{ inputTokens: number; outputTokens: number; estimatedCost: number }"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::estimateImageCost", "name": "estimateImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Estimate cost for an image generation task\n */\nexport function estimateImageCost(model: string, size: string, quality: string): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\") {\n    // GPT Image models use token-based pricing\n    const estimatedInputTokens = 300; // Typical prompt size\n    const estimatedOutputTokens =\n      rates.estimatedOutputTokens[quality] || rates.estimatedOutputTokens[\"auto\"] || 6500;\n\n    const inputCost = (estimatedInputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (estimatedOutputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else {\n    // DALL-E models use per-image pricing\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualTextCost", "name": "calculateActualTextCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost from API response usage\n */\nexport function calculateActualTextCost(\n  inputTokens: number,\n  outputTokens: number,\n  model: string\n): number {\n  const rates = TEXT_MODEL_RATES[model] || TEXT_MODEL_RATES[\"claude-sonnet-4-20250514\"];\n  const inputCost = (inputTokens / 1_000_000) * rates.inputPerMillion;\n  const outputCost = (outputTokens / 1_000_000) * rates.outputPerMillion;\n  return inputCost + outputCost;\n}", "parameters": [{"name": "inputTokens", "type": "number", "optional": false}, {"name": "outputTokens", "type": "number", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::calculateActualImageCost", "name": "calculateActualImageCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Calculate actual cost for image generation from API response usage\n * GPT Image models return token usage; DALL-E models use per-image pricing\n */\nexport function calculateActualImageCost(\n  model: string,\n  size: string,\n  quality: string,\n  usage?: { inputTokens: number; outputTokens: number }\n): number {\n  const rates = IMAGE_MODEL_RATES[model] || IMAGE_MODEL_RATES[\"dall-e-3\"];\n\n  if (rates.type === \"token-based\" && usage) {\n    // GPT Image models: use actual token counts from API response\n    const inputCost = (usage.inputTokens / 1_000_000) * rates.inputPerMillion;\n    const outputCost = (usage.outputTokens / 1_000_000) * rates.outputPerMillion;\n    return inputCost + outputCost;\n  } else if (rates.type === \"token-based\") {\n    // GPT Image models without usage data: fall back to estimate\n    return estimateImageCost(model, size, quality);\n  } else {\n    // DALL-E models: per-image pricing (no token usage)\n    const qualityRates = quality === \"hd\" ? rates.hd : rates.standard;\n    return qualityRates[size] || qualityRates[\"1024x1024\"] || 0.04;\n  }\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}, {"name": "usage", "type": "{ inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::createEmptyCostSummary", "name": "createEmptyCostSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Create empty cost summary\n */\nexport function createEmptyCostSummary(): CostSummary {\n  return {\n    totalEstimated: 0,\n    totalActual: 0,\n    textCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    imageCosts: { estimated: 0, actual: 0, taskCount: 0 },\n    byModel: {},\n  };\n}", "parameters": [], "returnType": "CostSummary"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatCost", "name": "formatCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost for display\n */\nexport function formatCost(cost: number): string {\n  if (cost < 0.001) return \"<$0.001\";\n  if (cost < 0.01) return `$${cost.toFixed(4)}`;\n  if (cost < 1) return `$${cost.toFixed(3)}`;\n  return `$${cost.toFixed(2)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/costEstimation.ts::formatEstimatedCost", "name": "formatEstimatedCost", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/costEstimation.ts", "sourceCode": "/**\n * Format cost with estimate indicator\n */\nexport function formatEstimatedCost(cost: number): string {\n  return `~${formatCost(cost)}`;\n}", "parameters": [{"name": "cost", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getCoverImageConfig", "name": "getCoverImageConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getCoverImageConfig(narrativeStyleId: string): CoverImageConfig {\n  return COVER_IMAGE_CONFIG[narrativeStyleId] || DEFAULT_CONFIG;\n}", "parameters": [{"name": "narrativeStyleId", "type": "string", "optional": false}], "returnType": "CoverImageConfig"}, {"id": "apps/illuminator/webui/src/lib/coverImageStyles.ts::getScenePromptTemplate", "name": "getScenePromptTemplate", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/coverImageStyles.ts", "sourceCode": "export function getScenePromptTemplate(id: string): ScenePromptTemplate {\n  return templateMap.get(id) || templateMap.get(\"montage\");\n}", "parameters": [{"name": "id", "type": "string", "optional": false}], "returnType": "ScenePromptTemplate"}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::wordSimilarity", "name": "wordSimilarity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function wordSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/));\n  let intersection = 0;\n  for (const w of wordsA) if (wordsB.has(w)) intersection++;\n  const union = wordsA.size + wordsB.size - intersection;\n  return union === 0 ? 1 : intersection / union;\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts::compressDescriptionHistory", "name": "compressDescriptionHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/descriptionHistoryCompression.ts", "sourceCode": "export function compressDescriptionHistory(\n  history: DescriptionHistoryEntry[]\n): CompressedHistoryEntry[] {\n  if (history.length <= COMPRESSION_FLOOR) {\n    return history;\n  }\n\n  const result: CompressedHistoryEntry[] = [];\n  let currentGroup: DescriptionHistoryEntry[] = [history[0]];\n\n  for (let i = 1; i < history.length; i++) {\n    const anchor = currentGroup[0]; // compare to group anchor, not last entry\n    const curr = history[i];\n    const sameSource = anchor.source === curr.source;\n    const similar = wordSimilarity(anchor.description, curr.description) > SIMILARITY_THRESHOLD;\n\n    if (sameSource && similar) {\n      currentGroup.push(curr);\n    } else {\n      flushGroup(currentGroup, result);\n      currentGroup = [curr];\n    }\n  }\n  flushGroup(currentGroup, result);\n\n  return result;\n}", "parameters": [{"name": "history", "type": "DescriptionHistoryEntry[]", "optional": false}], "returnType": "CompressedHistoryEntry[]"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::getEnrichmentStatus", "name": "getEnrichmentStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Get enrichment status for an entity and type\n */\nexport function getEnrichmentStatus(\n  entity: { id: string; summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  queueItems: QueueItem[]\n): EnrichmentStatus {\n  // Check queue first\n  const queueItem = queueItems.find((item) => item.entityId === entity.id && item.type === type);\n  if (queueItem) {\n    if (queueItem.status === \"running\") return \"running\";\n    if (queueItem.status === \"queued\") return \"queued\";\n    if (queueItem.status === \"error\") return \"error\";\n  }\n\n  // Check entity fields directly (summary/description are on entity, not nested)\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment is complete when entity has summary and description\n    return entity.summary && entity.description ? \"complete\" : \"missing\";\n  }\n  if (type === \"image\" && enrichment?.image?.imageId) return \"complete\";\n  if (type === \"entityChronicle\" && enrichment?.entityChronicle?.chronicleId) return \"complete\";\n\n  return \"missing\";\n}", "parameters": [{"name": "entity", "type": "{ id: string; summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "queueItems", "type": "QueueItem[]", "optional": false}], "returnType": "EnrichmentStatus"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::needsEnrichment", "name": "needsEnrichment", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Check if entity needs enrichment of a given type\n */\nexport function needsEnrichment(\n  entity: { summary?: string; description?: string; enrichment?: EntityEnrichment },\n  type: EnrichmentType\n): boolean {\n  const enrichment = entity.enrichment;\n\n  if (type === \"description\") {\n    // Text enrichment needed when entity lacks summary or description\n    return !(entity.summary && entity.description);\n  }\n  if (type === \"image\") return !enrichment?.image?.imageId;\n  if (type === \"entityChronicle\") return !enrichment?.entityChronicle?.chronicleId;\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "{ summary?: string; description?: string; enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/enrichmentTypes.ts::applyEnrichmentResult", "name": "applyEnrichmentResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/enrichmentTypes.ts", "sourceCode": "/**\n * Apply enrichment result to entity\n *\n * Returns both the enrichment metadata and entity field updates.\n * Callers should apply both: { ...entity, ...output.entityFields, enrichment: output.enrichment }\n *\n * @param lockedSummary - If true, skip setting the summary field (preserves user-defined summary)\n */\nexport function applyEnrichmentResult(\n  entity: { enrichment?: EntityEnrichment },\n  type: EnrichmentType,\n  result: EnrichmentResult,\n  lockedSummary?: boolean\n): ApplyEnrichmentOutput {\n  const existing = entity.enrichment || {};\n\n  if (type === \"description\" && result.description) {\n    // For lockedSummary entities, skip the summary (user-defined takes precedence)\n    // For normal entities, require both summary and description\n    if (!lockedSummary && !result.summary) {\n      return { enrichment: existing };\n    }\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          aliases: result.aliases || [],\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          debug: result.debug,\n          chainDebug: result.chainDebug,\n        },\n      },\n      // Entity field updates - summary/description go directly on entity\n      summary: lockedSummary ? undefined : result.summary,\n      description: result.description,\n    };\n  }\n\n  if (type === \"visualThesis\" && result.visualThesis) {\n    return {\n      enrichment: {\n        ...existing,\n        text: {\n          ...(existing.text || { aliases: [], visualTraits: [], generatedAt: 0, model: \"\" }),\n          visualThesis: result.visualThesis,\n          visualTraits: result.visualTraits || existing.text?.visualTraits || [],\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          chainDebug: result.chainDebug,\n        },\n      },\n    };\n  }\n\n  if (type === \"image\" && result.imageId) {\n    return {\n      enrichment: {\n        ...existing,\n        image: {\n          imageId: result.imageId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          revisedPrompt: result.revisedPrompt,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n          // Image dimensions for aspect-aware display\n          width: result.width,\n          height: result.height,\n          aspect: result.aspect,\n        },\n      },\n    };\n  }\n\n  if (type === \"entityChronicle\" && result.chronicleId) {\n    return {\n      enrichment: {\n        ...existing,\n        entityChronicle: {\n          chronicleId: result.chronicleId,\n          generatedAt: result.generatedAt,\n          model: result.model,\n          estimatedCost: result.estimatedCost,\n          actualCost: result.actualCost,\n          inputTokens: result.inputTokens,\n          outputTokens: result.outputTokens,\n        },\n      },\n    };\n  }\n\n  return { enrichment: existing };\n}", "parameters": [{"name": "entity", "type": "{ enrichment?: EntityEnrichment }", "optional": false}, {"name": "type", "type": "EnrichmentType", "optional": false}, {"name": "result", "type": "EnrichmentResult", "optional": false}, {"name": "lockedSummary", "type": "boolean", "optional": true}], "returnType": "ApplyEnrichmentOutput"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::scanForReferences", "name": "scanForReferences", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Scan all entities and chronicles for references to the given entity name.\n * Also surfaces all foreign-key references to the entity ID (relationships,\n * chronicle selectedEntityIds, etc.) so the user can verify completeness.\n */\nexport function scanForReferences(\n  entityId: string,\n  oldName: string,\n  entities: ScanEntity[],\n  chronicles: ChronicleRecord[],\n  relationships?: ScanRelationship[],\n  narrativeEvents?: ScanNarrativeEvent[]\n): RenameScanResult {\n  matchIdCounter = 0;\n\n  const ctx: ScanContext = {\n    entityId,\n    fullSlug: normalizeSlug(oldName),\n    partialSlugs: generatePartials(oldName),\n    matches: [],\n    coveredPositions: new Map(),\n    currentTier: \"general\",\n  };\n\n  const fullAndPartial: ScanFn = (st, si, sn, f, t) => scanTextField(ctx, st, si, sn, f, t);\n  const fullOnly: ScanFn = (st, si, sn, f, t) => scanTextFieldFullNameOnly(ctx, st, si, sn, f, t);\n\n  const entityById = new Map(entities.map((e) => [e.id, e]));\n\n  // Build related entity set from relationships\n  const relatedEntityIds = new Set<string>();\n  if (relationships) {\n    for (const rel of relationships) {\n      if (rel.src === entityId) relatedEntityIds.add(rel.dst);\n      if (rel.dst === entityId) relatedEntityIds.add(rel.src);\n    }\n  }\n\n  // Build cast chronicle set\n  const castChronicleIds = new Set<string>();\n  for (const chronicle of chronicles) {\n    if (chronicle.selectedEntityIds?.includes(entityId)) {\n      castChronicleIds.add(chronicle.chronicleId);\n    }\n  }\n\n  // 1. SELF\n  ctx.currentTier = \"self\";\n  const selfEntity = entityById.get(entityId);\n  if (selfEntity) scanEntityTextFields(selfEntity, ctx, fullAndPartial);\n\n  // 2. RELATED\n  ctx.currentTier = \"related\";\n  for (const relEntityId of relatedEntityIds) {\n    const relEntity = entityById.get(relEntityId);\n    if (relEntity) scanEntityTextFields(relEntity, ctx, fullAndPartial);\n  }\n\n  // 3. CAST CHRONICLES\n  ctx.currentTier = \"cast\";\n  for (const chronicle of chronicles) {\n    if (!castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullAndPartial);\n  }\n\n  // 4. GENERAL SWEEP\n  ctx.currentTier = \"general\";\n  const scannedEntityIds = new Set([entityId, ...relatedEntityIds]);\n  for (const entity of entities) {\n    if (scannedEntityIds.has(entity.id)) continue;\n    scanEntityTextFields(entity, ctx, fullOnly);\n  }\n\n  for (const chronicle of chronicles) {\n    if (castChronicleIds.has(chronicle.chronicleId)) continue;\n    scanChronicleMetadata(chronicle, entityId, ctx);\n    scanChronicleTextFields(chronicle, fullOnly);\n  }\n\n  // 5. NARRATIVE EVENTS\n  if (narrativeEvents) {\n    scanNarrativeEvents(narrativeEvents, entityId, ctx);\n  }\n\n  // FK references\n  scanFkReferences(entityId, entityById, relationships, chronicles, ctx);\n\n  return { entityId, oldName, matches: ctx.matches };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "entities", "type": "ScanEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "relationships", "type": "ScanRelationship[]", "optional": true}, {"name": "narrativeEvents", "type": "ScanNarrativeEvent[]", "optional": true}], "returnType": "RenameScanResult"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::adjustReplacementForGrammar", "name": "adjustReplacementForGrammar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function adjustReplacementForGrammar(\n  contextBefore: string,\n  contextAfter: string,\n  matchPosition: number,\n  matchedText: string,\n  replacement: string\n): AdjustedReplacement {\n  const state: GrammarState = {\n    position: matchPosition,\n    originalLength: matchedText.length,\n    replacement,\n  };\n\n  const rawBefore = rawCtxBefore(contextBefore);\n  const rawAfter = rawCtxAfter(contextAfter);\n  const sentenceStart = isAtSentenceStart(rawBefore);\n  const casePattern = detectCasePattern(matchedText);\n\n  applyCaseEcho(state, casePattern);\n\n  const precedingArticle = findPrecedingArticle(rawBefore);\n  const replacementStartsWithThe = /^the\\s/i.test(state.replacement);\n  const articleAbsorbed = applyArticleDeduplication(state, matchPosition, matchedText.length, precedingArticle);\n\n  if (!sentenceStart && casePattern !== \"allCaps\" && !articleAbsorbed) {\n    applyMidSentenceArticleLowercasing(state);\n  }\n\n  if (\n    precedingArticle &&\n    !replacementStartsWithThe &&\n    !articleAbsorbed &&\n    (precedingArticle.normalized === \"a\" || precedingArticle.normalized === \"an\")\n  ) {\n    applyAAnAgreement(state, matchPosition, matchedText.length, precedingArticle);\n  }\n\n  applyPossessiveTransfer(state, rawAfter);\n\n  return { position: state.position, originalLength: state.originalLength, replacement: state.replacement };\n}", "parameters": [{"name": "contextBefore", "type": "string", "optional": false}, {"name": "contextAfter", "type": "string", "optional": false}, {"name": "matchPosition", "type": "number", "optional": false}, {"name": "matchedText", "type": "string", "optional": false}, {"name": "replacement", "type": "string", "optional": false}], "returnType": "AdjustedReplacement"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyReplacements", "name": "applyReplacements", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply a set of replacements to a text string. Replacements must not overlap\n * and are applied in reverse order to preserve positions.\n */\nexport function applyReplacements(text: string, replacements: FieldReplacement[]): string {\n  // Sort by position descending so earlier positions aren't shifted\n  const sorted = [...replacements].sort((a, b) => b.position - a.position);\n  let result = text;\n  for (const r of sorted) {\n    result =\n      result.slice(0, r.position) + r.replacement + result.slice(r.position + r.originalLength);\n  }\n  return result;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "replacements", "type": "FieldReplacement[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::buildRenamePatches", "name": "buildRenamePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "export function buildRenamePatches(\n  scanResult: RenameScanResult,\n  newName: string,\n  decisions: MatchDecision[]\n): RenamePatches {\n  const decisionMap = new Map(decisions.map((d) => [d.matchId, d]));\n\n  const entityPatchMap = new Map<string, Record<string, any>>();\n  const chroniclePatchMap = new Map<string, Record<string, any>>();\n  const eventPatchMap = new Map<string, Record<string, any>>();\n  const chronicleMetaUpdates = new Map<string, Partial<ChronicleRecord>>();\n  const eventMetaUpdates = new Map<string, Record<string, string>>();\n\n  for (const match of scanResult.matches) {\n    const decision = decisionMap.get(match.id);\n    if (!decision || decision.action === \"reject\") continue;\n\n    const replacementText = decision.action === \"edit\" ? (decision.editText ?? newName) : newName;\n\n    if (match.matchType === \"metadata\") {\n      if (match.sourceType === \"event\") {\n        const meta = eventMetaUpdates.get(match.sourceId) || {};\n        meta[match.field] = replacementText;\n        eventMetaUpdates.set(match.sourceId, meta);\n      } else {\n        const meta = chronicleMetaUpdates.get(match.sourceId) || {};\n        processChronicleMetadataMatch(meta, match.field, replacementText);\n        chronicleMetaUpdates.set(match.sourceId, meta);\n      }\n    } else {\n      const replacement = computeReplacement(match, decision, newName);\n\n      if (match.sourceType === \"entity\") {\n        appendReplacementToMap(entityPatchMap, match.sourceId, match.field, replacement, true);\n      } else if (match.sourceType === \"chronicle\") {\n        appendReplacementToMap(chroniclePatchMap, match.sourceId, match.field, replacement, false);\n      } else if (match.sourceType === \"event\") {\n        appendReplacementToMap(eventPatchMap, match.sourceId, match.field, replacement, true);\n      }\n    }\n  }\n\n  // Merge metadata updates into chronicle patches\n  for (const [chronicleId, meta] of chronicleMetaUpdates) {\n    const existing = chroniclePatchMap.get(chronicleId) || {};\n    Object.assign(existing, meta);\n    chroniclePatchMap.set(chronicleId, existing);\n  }\n\n  for (const [eventId, meta] of eventMetaUpdates) {\n    const existing = eventPatchMap.get(eventId) || {};\n    Object.assign(existing, meta);\n    eventPatchMap.set(eventId, existing);\n  }\n\n  return {\n    entityPatches: [...entityPatchMap].map(([entityId, changes]) => ({ entityId, changes })),\n    chroniclePatches: [...chroniclePatchMap].map(([chronicleId, fieldUpdates]) => ({\n      chronicleId,\n      fieldUpdates,\n    })),\n    eventPatches: [...eventPatchMap].map(([eventId, changes]) => ({ eventId, changes })),\n  };\n}", "parameters": [{"name": "scanResult", "type": "RenameScanResult", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "decisions", "type": "MatchDecision[]", "optional": false}], "returnType": "RenamePatches"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyEntityPatches", "name": "applyEntityPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Apply helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Apply entity patches to an entity array. Returns a new array with patches applied.\n * Handles summary, description, and enrichment.descriptionHistory text replacements.\n */\nexport function applyEntityPatches<T extends ScanEntity>(\n  entities: T[],\n  patches: EntityPatch[],\n  targetEntityId: string | null,\n  newName: string\n): T[] {\n  const patchMap = new Map(patches.map((p) => [p.entityId, p]));\n\n  return entities.map((entity) => {\n    // The target entity always gets its name updated, even without a text patch\n    const isTarget = entity.id === targetEntityId;\n    const patch = patchMap.get(entity.id);\n    if (!patch && !isTarget) return entity;\n\n    const updated = { ...entity };\n\n    if (isTarget) {\n      updated.name = newName;\n      // Store the entity ID as a slug alias so deep links using the old\n      // ID-based slug still resolve after the name changes. The chronicler's\n      // bySlug map indexes these for URL resolution.\n      const existingAliases = (entity as any).enrichment?.slugAliases || [];\n      if (!existingAliases.includes(entity.id)) {\n        if (!updated.enrichment) updated.enrichment = { ...(entity as any).enrichment };\n        (updated as any).enrichment.slugAliases = [...existingAliases, entity.id];\n      }\n    }\n\n    if (!patch) return updated;\n\n    // Apply text replacements\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (!key.startsWith(\"__replacements_\")) continue;\n      const field = key.replace(\"__replacements_\", \"\");\n      const replacements: FieldReplacement[] = JSON.parse(value);\n\n      if (field === \"summary\" || field === \"description\" || field === \"narrativeHint\") {\n        const originalText = (entity as any)[field];\n        if (typeof originalText === \"string\") {\n          (updated as any)[field] = applyReplacements(originalText, replacements);\n        }\n      } else if (field.startsWith(\"enrichment.descriptionHistory[\")) {\n        // Parse index from: enrichment.descriptionHistory[N].description\n        const idxMatch = field.match(/\\[(\\d+)\\]/);\n        if (idxMatch && entity.enrichment?.descriptionHistory) {\n          const idx = parseInt(idxMatch[1], 10);\n          // Shallow-copy enrichment chain on first write\n          if (!updated.enrichment || updated.enrichment === entity.enrichment) {\n            updated.enrichment = { ...entity.enrichment };\n          }\n          if (\n            !updated.enrichment.descriptionHistory ||\n            updated.enrichment.descriptionHistory === entity.enrichment.descriptionHistory\n          ) {\n            updated.enrichment.descriptionHistory = [...entity.enrichment.descriptionHistory];\n          }\n          const entry = updated.enrichment.descriptionHistory[idx];\n          if (entry) {\n            updated.enrichment.descriptionHistory[idx] = {\n              ...entry,\n              description: applyReplacements(entry.description, replacements),\n            };\n          }\n        }\n      }\n    }\n\n    return updated;\n  });\n}", "parameters": [{"name": "entities", "type": "T[]", "optional": false}, {"name": "patches", "type": "EntityPatch[]", "optional": false}, {"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "T[]"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyChroniclePatches", "name": "applyChroniclePatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply chronicle patches. Reads each chronicle from IDB, applies changes, writes back.\n * Returns the number of successfully updated chronicles.\n */\nexport async function applyChroniclePatches(\n  patches: ChroniclePatch[],\n  getChronicle: (id: string) => Promise<ChronicleRecord | undefined>,\n  putChronicle: (record: ChronicleRecord) => Promise<void>\n): Promise<number> {\n  let successCount = 0;\n\n  for (const patch of patches) {\n    try {\n      const chronicle = await getChronicle(patch.chronicleId);\n      if (!chronicle) {\n        console.warn(`[EntityRename] Chronicle not found: ${patch.chronicleId}`);\n        continue;\n      }\n\n      const updated = { ...chronicle };\n\n      // Apply metadata updates\n      if ((patch.fieldUpdates as any)._roleAssignmentUpdates) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._roleAssignmentUpdates;\n        updated.roleAssignments = [...chronicle.roleAssignments];\n        for (const u of updates) {\n          if (updated.roleAssignments[u.index]) {\n            updated.roleAssignments[u.index] = {\n              ...updated.roleAssignments[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      if ((patch.fieldUpdates as any)._lensNameUpdate && chronicle.lens) {\n        updated.lens = {\n          ...chronicle.lens,\n          entityName: (patch.fieldUpdates as any)._lensNameUpdate,\n        };\n      }\n\n      if (\n        (patch.fieldUpdates as any)._directiveUpdates &&\n        chronicle.generationContext?.entityDirectives\n      ) {\n        const updates: Array<{ index: number; entityName: string }> = (patch.fieldUpdates as any)\n          ._directiveUpdates;\n        updated.generationContext = {\n          ...chronicle.generationContext,\n          entityDirectives: [...chronicle.generationContext.entityDirectives],\n        };\n        for (const u of updates) {\n          if (updated.generationContext.entityDirectives[u.index]) {\n            updated.generationContext.entityDirectives[u.index] = {\n              ...updated.generationContext.entityDirectives[u.index],\n              entityName: u.entityName,\n            };\n          }\n        }\n      }\n\n      // Apply text field replacements\n      for (const [key, value] of Object.entries(patch.fieldUpdates)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements = value as FieldReplacement[];\n\n        if (field.startsWith(\"generationHistory.\")) {\n          // Handle generation history versions\n          const versionId = field.replace(\"generationHistory.\", \"\");\n          if (updated.generationHistory) {\n            updated.generationHistory = updated.generationHistory.map((v) => {\n              if (v.versionId === versionId) {\n                return { ...v, content: applyReplacements(v.content, replacements) };\n              }\n              return v;\n            });\n          }\n        } else if (field === \"assembledContent\" && typeof updated.assembledContent === \"string\") {\n          updated.assembledContent = applyReplacements(updated.assembledContent, replacements);\n        } else if (field === \"finalContent\" && typeof updated.finalContent === \"string\") {\n          updated.finalContent = applyReplacements(updated.finalContent, replacements);\n        } else if (field === \"summary\" && typeof updated.summary === \"string\") {\n          updated.summary = applyReplacements(updated.summary, replacements);\n        }\n      }\n\n      updated.updatedAt = Date.now();\n      await putChronicle(updated);\n      successCount++;\n    } catch (err) {\n      console.error(`[EntityRename] Failed to update chronicle ${patch.chronicleId}:`, err);\n    }\n  }\n\n  return successCount;\n}", "parameters": [{"name": "patches", "type": "ChroniclePatch[]", "optional": false}, {"name": "getChronicle", "type": "(id: string) => Promise<ChronicleRecord | undefined>", "optional": false}, {"name": "putChronicle", "type": "(record: ChronicleRecord) => Promise<void>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::applyNarrativeEventPatches", "name": "applyNarrativeEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Apply narrative event patches to an event array. Returns a new array with patches applied.\n * Handles both structured name fields (metadata) and text replacements.\n */\nexport function applyNarrativeEventPatches<T extends ScanNarrativeEvent>(\n  events: T[],\n  patches: EventPatch[]\n): T[] {\n  if (patches.length === 0) return events;\n\n  const patchMap = new Map(patches.map((p) => [p.eventId, p]));\n\n  return events.map((event) => {\n    const patch = patchMap.get(event.id);\n    if (!patch) return event;\n\n    const updated: any = { ...event };\n\n    for (const [key, value] of Object.entries(patch.changes)) {\n      if (key.startsWith(\"__replacements_\")) {\n        // Text field replacements\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n\n        if (field === \"description\" && typeof updated.description === \"string\") {\n          updated.description = applyReplacements(updated.description, replacements);\n        } else if (field === \"action\" && typeof updated.action === \"string\") {\n          updated.action = applyReplacements(updated.action, replacements);\n        } else if (field.startsWith(\"participantEffects[\")) {\n          // Parse: participantEffects[N].effects[M].description\n          const idxMatch = field.match(\n            /participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.description/\n          );\n          if (idxMatch) {\n            const pi = parseInt(idxMatch[1], 10);\n            const ei = parseInt(idxMatch[2], 10);\n            if (\n              !updated.participantEffects ||\n              updated.participantEffects === event.participantEffects\n            ) {\n              updated.participantEffects = [...event.participantEffects];\n            }\n            if (updated.participantEffects[pi]) {\n              const pe = { ...updated.participantEffects[pi] };\n              if (pe.effects === event.participantEffects[pi].effects) {\n                pe.effects = [...event.participantEffects[pi].effects];\n              }\n              if (pe.effects[ei]) {\n                pe.effects[ei] = {\n                  ...pe.effects[ei],\n                  description: applyReplacements(pe.effects[ei].description, replacements),\n                };\n              }\n              updated.participantEffects[pi] = pe;\n            }\n          }\n        }\n      } else if (key === \"subject.name\") {\n        // Structured name field: subject.name\n        updated.subject = { ...event.subject, name: value };\n      } else if (key.startsWith(\"participantEffects[\")) {\n        // Structured name: participantEffects[N].entity.name or participantEffects[N].effects[M].relatedEntity.name\n        if (\n          !updated.participantEffects ||\n          updated.participantEffects === event.participantEffects\n        ) {\n          updated.participantEffects = [...event.participantEffects];\n        }\n\n        const entityNameMatch = key.match(/^participantEffects\\[(\\d+)\\]\\.entity\\.name$/);\n        if (entityNameMatch) {\n          const pi = parseInt(entityNameMatch[1], 10);\n          if (updated.participantEffects[pi]) {\n            updated.participantEffects[pi] = {\n              ...updated.participantEffects[pi],\n              entity: { ...updated.participantEffects[pi].entity, name: value },\n            };\n          }\n        }\n\n        const relatedMatch = key.match(\n          /^participantEffects\\[(\\d+)\\]\\.effects\\[(\\d+)\\]\\.relatedEntity\\.name$/\n        );\n        if (relatedMatch) {\n          const pi = parseInt(relatedMatch[1], 10);\n          const ei = parseInt(relatedMatch[2], 10);\n          if (updated.participantEffects[pi]) {\n            const pe = { ...updated.participantEffects[pi] };\n            if (pe.effects === event.participantEffects[pi]?.effects) {\n              pe.effects = [...event.participantEffects[pi].effects];\n            }\n            if (pe.effects[ei]?.relatedEntity) {\n              pe.effects[ei] = {\n                ...pe.effects[ei],\n                relatedEntity: { ...pe.effects[ei].relatedEntity!, name: value },\n              };\n            }\n            updated.participantEffects[pi] = pe;\n          }\n        }\n      }\n    }\n\n    return updated as T;\n  });\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "patches", "type": "EventPatch[]", "optional": false}], "returnType": "T[]"}, {"id": "apps/illuminator/webui/src/lib/entityRename.ts::patchNarrativeHistory", "name": "patchNarrativeHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/entityRename.ts", "sourceCode": "/**\n * Brute-force patch of all narrative events for a single entity rename.\n *\n * Unlike the scan-based approach (which uses position-based replacements and\n * per-match decisions), this function does a simple find-and-replace across\n * ALL name fields and text fields in every event where the entity appears.\n *\n * Use this to repair data that was missed by a previous rename, or as a\n * one-shot fix when you don't need per-match granularity.\n *\n * @returns { events: patched array, patchCount: number of events modified }\n */\nexport function patchNarrativeHistory<T extends ScanNarrativeEvent>(\n  events: T[],\n  entityId: string,\n  oldName: string,\n  newName: string\n): { events: T[]; patchCount: number } {\n  let patchCount = 0;\n\n  const patched = events.map((event) => {\n    // Quick check: is this entity involved at all?\n    const isSubject = event.subject.id === entityId;\n    const participantIdx = event.participantEffects.findIndex((pe) => pe.entity.id === entityId);\n    // Also check if old name appears anywhere in the event text\n    const hasTextMatch =\n      event.description.toLowerCase().includes(oldName.toLowerCase()) ||\n      event.action.toLowerCase().includes(oldName.toLowerCase());\n\n    const hasRelatedRef = event.participantEffects.some((pe) =>\n      pe.effects.some((eff) => eff.relatedEntity?.id === entityId)\n    );\n\n    if (!isSubject && participantIdx === -1 && !hasTextMatch && !hasRelatedRef) {\n      return event;\n    }\n\n    let didChange = false;\n    const updated: any = { ...event };\n\n    // Patch subject.name\n    if (isSubject && event.subject.name !== newName) {\n      updated.subject = { ...event.subject, name: newName };\n      didChange = true;\n    }\n\n    // Patch participantEffects\n    const newPE = [...event.participantEffects];\n    for (let pi = 0; pi < newPE.length; pi++) {\n      const pe = newPE[pi];\n      let peChanged = false;\n      let updatedPE: any = pe;\n\n      // Participant entity.name\n      if (pe.entity.id === entityId && pe.entity.name !== newName) {\n        updatedPE = { ...pe, entity: { ...pe.entity, name: newName } };\n        peChanged = true;\n      }\n\n      // Effects\n      const newEffects = [...(updatedPE.effects || pe.effects)];\n      for (let ei = 0; ei < newEffects.length; ei++) {\n        const eff = newEffects[ei];\n        let effChanged = false;\n        let updatedEff: any = eff;\n\n        // relatedEntity.name\n        if (eff.relatedEntity?.id === entityId && eff.relatedEntity.name !== newName) {\n          updatedEff = { ...eff, relatedEntity: { ...eff.relatedEntity, name: newName } };\n          effChanged = true;\n        }\n\n        // effect.description (free text)\n        const patchedDesc = replaceAllCaseInsensitive(updatedEff.description, oldName, newName);\n        if (patchedDesc !== updatedEff.description) {\n          updatedEff = { ...(effChanged ? updatedEff : eff), description: patchedDesc };\n          effChanged = true;\n        }\n\n        if (effChanged) {\n          newEffects[ei] = updatedEff;\n          peChanged = true;\n        }\n      }\n\n      if (peChanged) {\n        updatedPE = { ...(updatedPE === pe ? pe : updatedPE), effects: newEffects };\n        newPE[pi] = updatedPE;\n        didChange = true;\n      }\n    }\n\n    if (didChange) {\n      updated.participantEffects = newPE;\n    }\n\n    // Patch top-level text fields\n    const patchedDesc = replaceAllCaseInsensitive(\n      updated.description || event.description,\n      oldName,\n      newName\n    );\n    if (patchedDesc !== (updated.description || event.description)) {\n      updated.description = patchedDesc;\n      didChange = true;\n    }\n\n    const patchedAction = replaceAllCaseInsensitive(\n      updated.action || event.action,\n      oldName,\n      newName\n    );\n    if (patchedAction !== (updated.action || event.action)) {\n      updated.action = patchedAction;\n      didChange = true;\n    }\n\n    if (didChange) {\n      patchCount++;\n      return updated as T;\n    }\n    return event;\n  });\n\n  return { events: patched, patchCount };\n}", "parameters": [{"name": "events", "type": "T[]", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "oldName", "type": "string", "optional": false}, {"name": "newName", "type": "string", "optional": false}], "returnType": "{ events: T[]; patchCount: number }"}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::resolveAnchorPhrase", "name": "resolveAnchorPhrase", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "export function resolveAnchorPhrase(anchorPhrase: string, text: string): FuzzyAnchorResult | null {\n  if (!anchorPhrase || !text) return null;\n\n  const exact = tryExactMatch(anchorPhrase, text);\n  if (exact) return exact;\n\n  const phraseContentWords = contentWords(anchorPhrase);\n  if (phraseContentWords.length === 0) return null;\n\n  const phraseWordSet = new Set(phraseContentWords);\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  const anchorWordCount = anchorPhrase.split(/\\s+/).length;\n  const halfWindow = Math.floor(Math.max(anchorWordCount, 4) / 2);\n\n  const { bestScore, bestCenter } = findBestCenter(words, phraseWordSet, halfWindow);\n\n  if (bestScore < Math.max(1, Math.ceil(phraseContentWords.length * 0.4))) return null;\n\n  const spanStart = Math.max(0, bestCenter - halfWindow);\n  const spanEnd = Math.min(words.length - 1, bestCenter + halfWindow);\n  const charStart = words[spanStart].start;\n  const charEnd = words[spanEnd].end;\n\n  let candidate = text.slice(charStart, charEnd);\n  const centerCharStart = words[bestCenter].start;\n  const centerCharEnd = words[bestCenter].end;\n\n  candidate = snapToSentence(text, candidate, charStart, charEnd, centerCharStart, centerCharEnd);\n  candidate = ensureUnique(text, candidate, centerCharStart, anchorWordCount);\n\n  if (!candidate || candidate.length < 3) return null;\n\n  const finalIdx = text.indexOf(candidate);\n  if (finalIdx < 0) return null;\n\n  return { phrase: candidate, index: finalIdx, method: \"fuzzy\" };\n}", "parameters": [{"name": "anchorPhrase", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "FuzzyAnchorResult | null"}, {"id": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts::extractWordsAroundIndex", "name": "extractWordsAroundIndex", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "/**\n * Extract ~wordCount words centered around a character index, snapped to word\n * boundaries. Used as a proportional-index fallback when fuzzy anchor matching\n * fails after a copy edit.\n */\nexport function extractWordsAroundIndex(\n  text: string,\n  index: number,\n  wordCount: number\n): string | null {\n  if (!text || index < 0 || index >= text.length) return null;\n\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  // Find the word closest to the target index\n  let centerIdx = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].start <= index && words[i].end >= index) {\n      centerIdx = i;\n      break;\n    }\n    if (words[i].start > index) {\n      centerIdx = Math.max(0, i - 1);\n      break;\n    }\n    centerIdx = i; // last word if index is past end\n  }\n\n  const half = Math.floor(wordCount / 2);\n  const start = Math.max(0, centerIdx - half);\n  const end = Math.min(words.length - 1, start + wordCount - 1);\n  const candidate = text.slice(words[start].start, words[end].end);\n\n  return candidate && candidate.length >= 3 ? candidate : null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::collectPreviousNotes", "name": "collectPreviousNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function collectPreviousNotes(\n  options: {\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  } = {}\n): Promise<PreviousNoteSummary[]> {\n  const { maxPerTarget, relatedRatio } = HISTORIAN_SAMPLING;\n  const maxTotal = options.maxOverride ?? HISTORIAN_SAMPLING.maxTotal;\n  if (maxTotal <= 0) return [];\n  const relatedEntityIds = new Set(options.relatedEntityIds || []);\n  const relatedChronicleIds = new Set(options.relatedChronicleIds || []);\n  const { simulationRunId } = useEntityStore.getState();\n\n  const byTarget = new Map<string, NoteEntry[]>();\n\n  const addNotesForTarget = (\n    targetKey: string,\n    targetMeta: { type: string; id: string; name: string },\n    notes: Array<{ noteId?: string; anchorPhrase: string; text: string; type: string }>\n  ) => {\n    if (!notes.length) return;\n    const mapped: NoteEntry[] = notes.map((note, index) => ({\n      noteKey: note.noteId || `${targetKey}:${index}`,\n      targetKey,\n      targetType: targetMeta.type,\n      targetId: targetMeta.id,\n      targetName: targetMeta.name,\n      anchorPhrase: note.anchorPhrase,\n      text: note.text,\n      type: note.type,\n    }));\n    byTarget.set(targetKey, mapped);\n  };\n\n  // Entity notes\n  if (simulationRunId) {\n    const allEntities = await entityRepo.getEntitiesForRun(simulationRunId);\n    for (const entity of allEntities) {\n      const notes = (entity.enrichment?.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `entity:${entity.id}`,\n        {\n          type: \"entity\",\n          id: entity.id,\n          name: entity.name,\n        },\n        notes\n      );\n    }\n  }\n\n  // Chronicle notes\n  if (simulationRunId) {\n    const chronicleRecords = await getChroniclesForSimulation(simulationRunId);\n    for (const chronicle of chronicleRecords) {\n      const notes = (chronicle.historianNotes || []).filter(isNoteActive);\n      addNotesForTarget(\n        `chronicle:${chronicle.chronicleId}`,\n        {\n          type: \"chronicle\",\n          id: chronicle.chronicleId,\n          name: chronicle.title || chronicle.chronicleId,\n        },\n        notes\n      );\n    }\n  }\n\n  // Cap each target\n  const cappedNotes: NoteEntry[] = [];\n  for (const notes of byTarget.values()) {\n    const selected =\n      notes.length > maxPerTarget ? takeRandomSample(notes, maxPerTarget) : notes.slice();\n    cappedNotes.push(...selected);\n  }\n\n  if (cappedNotes.length === 0) return [];\n\n  const total = Math.min(maxTotal, cappedNotes.length);\n  const relatedNotes = cappedNotes.filter((note) => {\n    if (note.targetType === \"entity\") return relatedEntityIds.has(note.targetId);\n    if (note.targetType === \"chronicle\") return relatedChronicleIds.has(note.targetId);\n    return false;\n  });\n\n  const relatedQuota = Math.min(relatedNotes.length, Math.round(total * relatedRatio));\n  const relatedSample = takeRandomSample(relatedNotes, relatedQuota);\n  const relatedKeys = new Set(relatedSample.map((note) => note.noteKey));\n  const remainingPool = cappedNotes.filter((note) => !relatedKeys.has(note.noteKey));\n  const remainingSample = takeRandomSample(remainingPool, total - relatedSample.length);\n\n  const finalSample = [...relatedSample, ...remainingSample];\n  shuffleInPlace(finalSample);\n\n  return finalSample.map((note) => ({\n    targetName: note.targetName,\n    anchorPhrase: note.anchorPhrase,\n    text: note.text,\n    type: note.type,\n  }));\n}", "parameters": [{"name": "options", "type": "{\n    relatedEntityIds?: string[];\n    relatedChronicleIds?: string[];\n    maxOverride?: number;\n  }", "optional": true}], "returnType": "Promise<PreviousNoteSummary[]>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianEditionContext", "name": "buildHistorianEditionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "// ============================================================================\n// Context builders\n// ============================================================================\n\n/**\n * Build the full context for a historian edition (description rewrite) session.\n * Returns null if preconditions aren't met (missing config, entity, etc.).\n */\nexport async function buildHistorianEditionContext(\n  entityId: string,\n  tone?: string,\n  reEdition?: boolean\n): Promise<HistorianEditionConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  // If prior historian editions exist (active or legacy), use the pre-historian baseline\n  // as the input description instead of entity.description (which may be an inflated historian\n  // output). The first historian-edition or legacy-copy-edit entry is always the pre-historian\n  // text that was replaced by the first edition. Filter edition entries from the archive so\n  // the LLM works from the original source material, not prior historian rewrites.\n  const editionSources = new Set([\"historian-edition\", \"legacy-copy-edit\"]);\n  let description = entity.description;\n  let filteredHistory = entity.enrichment?.descriptionHistory || [];\n  const firstEdition = filteredHistory.find((h: { source?: string }) =>\n    editionSources.has(h.source || \"\")\n  );\n  if (firstEdition) {\n    description = firstEdition.description;\n    filteredHistory = filteredHistory.filter(\n      (h: { source?: string }) => !editionSources.has(h.source || \"\")\n    );\n  } else if (reEdition) {\n    return null; // re-edition requested but no prior edition exists\n  }\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Gather chronicle summaries from backrefs\n  const chronicleSummaries: Array<{\n    chronicleId: string;\n    title: string;\n    format: string;\n    summary: string;\n  }> = [];\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  for (const ref of backrefs) {\n    if (!ref.chronicleId) continue;\n    try {\n      const chronicle = await getChronicle(ref.chronicleId);\n      if (chronicle && chronicle.title) {\n        chronicleSummaries.push({\n          chronicleId: chronicle.chronicleId,\n          title: chronicle.title,\n          format: chronicle.format || \"\",\n          summary: chronicle.summary || chronicle.finalContent?.slice(0, 500) || \"\",\n        });\n      }\n    } catch {\n      // Skip if chronicle not found\n    }\n  }\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    description,\n    summary: entity.summary || \"\",\n    descriptionHistory: filteredHistory,\n    chronicleSummaries,\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    previousNotes,\n    historianConfig,\n    tone: (tone || \"scholarly\") as HistorianEditionConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "reEdition", "type": "boolean", "optional": true}], "returnType": "Promise<HistorianEditionConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildHistorianReviewContext", "name": "buildHistorianReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build the full context for a historian review (annotation) session on an entity.\n * Returns null if preconditions aren't met.\n */\nexport async function buildHistorianReviewContext(\n  entityId: string,\n  tone?: string,\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !entityId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const entity = await useEntityStore.getState().loadEntity(entityId);\n  if (!entity?.description) return null;\n\n  const entityNavMap = useEntityStore.getState().navItems;\n  const prominenceScale = getProminenceScale();\n\n  const { relationships, neighborSummaries } = await buildRelationshipsAndNeighbors(\n    entity.id,\n    entityNavMap\n  );\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    entityId: entity.id,\n    entityName: entity.name,\n    entityKind: entity.kind,\n    entitySubtype: entity.subtype || \"\",\n    entityCulture: entity.culture || \"\",\n    entityProminence: prominenceLabelFromScale(entity.prominence, prominenceScale),\n    summary: entity.summary || \"\",\n    relationships,\n    neighborSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n  });\n\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: getRelatedEntityIds(entity.id),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"entity\",\n    targetId: entity.id,\n    targetName: entity.name,\n    sourceText: entity.description,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildChronicleReviewContext", "name": "buildChronicleReviewContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildChronicleReviewContext(\n  chronicleId: string,\n  tone?: string,\n  corpusStrengthCache?: { runId: string | null; strength: Map<string, number> | null },\n  voiceDigestCache?: CorpusVoiceDigestCache,\n  reinforcementCache?: ReinforcementCache,\n  maxNotesOverride?: number\n): Promise<HistorianReviewConfig | null> {\n  const { projectId, simulationRunId, worldContext, historianConfig } =\n    useIlluminatorConfigStore.getState();\n  if (!projectId || !simulationRunId || !chronicleId) return null;\n  if (!isHistorianConfigured(historianConfig)) return null;\n\n  const chronicle = await getChronicle(chronicleId);\n  if (!chronicle) return null;\n  if (chronicle.status !== \"complete\" || !chronicle.finalContent) return null;\n\n  const content = chronicle.finalContent;\n\n  // Build cast summaries\n  const castEntityIds = (chronicle.roleAssignments || [])\n    .map((ra: { entityId: string }) => ra.entityId)\n    .filter(Boolean);\n  const castFull = await useEntityStore.getState().loadEntities(castEntityIds);\n  const castMap = new Map(castFull.map((e: { id: string }) => [e.id, e]));\n\n  const castSummaries = (chronicle.roleAssignments || [])\n    .slice(0, 10)\n    .map((ra: { entityId: string }) => {\n      const entity = castMap.get(ra.entityId);\n      if (!entity) return null;\n      return {\n        name: entity.name,\n        kind: entity.kind,\n        summary: entity.summary || entity.description?.slice(0, 200) || \"\",\n      };\n    })\n    .filter(Boolean);\n\n  const cast = (chronicle.roleAssignments || []).map((ra: { entityId: string; role: string }) => {\n    const entity = castMap.get(ra.entityId);\n    return {\n      entityName: entity?.name || ra.entityId,\n      role: ra.role,\n      kind: entity?.kind || \"unknown\",\n    };\n  });\n\n  const factCoverageGuidance = chronicle.factCoverageReport?.entries?.length\n    ? await resolveFactCoverageGuidance(\n        chronicle.factCoverageReport, simulationRunId, worldContext,\n        corpusStrengthCache, reinforcementCache\n      )\n    : undefined;\n\n  // Build corpus voice digest (cached across batch runs)\n  const voiceDigest = await buildCorpusVoiceDigest(voiceDigestCache);\n\n  const contextJson = JSON.stringify({\n    chronicleId: chronicle.chronicleId,\n    title: chronicle.title || \"Untitled\",\n    format: chronicle.format,\n    narrativeStyleId: chronicle.narrativeStyleId || \"\",\n    cast,\n    castSummaries,\n    canonFacts: (worldContext.canonFactsWithMetadata || []).map((f: { text: string }) => f.text),\n    worldDynamics: (worldContext.worldDynamics || []).map((d: { text: string }) => d.text),\n    factCoverageGuidance,\n    voiceDigest: voiceDigest.totalNotes > 0 ? voiceDigest : undefined,\n    temporalNarrative: chronicle.perspectiveSynthesis?.temporalNarrative || undefined,\n    focalEra: chronicle.temporalContext?.focalEra\n      ? {\n          name: chronicle.temporalContext.focalEra.name,\n          description: chronicle.temporalContext.focalEra.description,\n        }\n      : undefined,\n    temporalCheckReport: chronicle.temporalCheckReport || undefined,\n  });\n\n  const relatedEntityIds = new Set(\n    (chronicle.roleAssignments || []).map((ra: { entityId: string }) => ra.entityId).filter(Boolean)\n  );\n  const previousNotes = await collectPreviousNotes({\n    relatedEntityIds: Array.from(relatedEntityIds),\n    maxOverride: maxNotesOverride,\n  });\n\n  return {\n    projectId,\n    simulationRunId,\n    targetType: \"chronicle\",\n    targetId: chronicleId,\n    targetName: chronicle.title || \"Untitled Chronicle\",\n    sourceText: content,\n    contextJson,\n    previousNotesJson: JSON.stringify(previousNotes),\n    historianConfig,\n    tone: (tone || chronicle.assignedTone || \"weary\") as HistorianReviewConfig[\"tone\"],\n  };\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": true}, {"name": "corpusStrengthCache", "type": "{ runId: string | null; strength: Map<string, number> | null }", "optional": true}, {"name": "voiceDigestCache", "type": "CorpusVoiceDigestCache", "optional": true}, {"name": "reinforcementCache", "type": "ReinforcementCache", "optional": true}, {"name": "maxNotesOverride", "type": "number", "optional": true}], "returnType": "Promise<HistorianReviewConfig | null>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildCorpusVoiceDigest", "name": "buildCorpusVoiceDigest", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "export async function buildCorpusVoiceDigest(\n  cache?: CorpusVoiceDigestCache\n): Promise<CorpusVoiceDigest> {\n  const { simulationRunId } = useEntityStore.getState();\n\n  if (cache && cache.runId === simulationRunId && cache.digest) {\n    return cache.digest;\n  }\n\n  const allTexts = simulationRunId ? await collectCorpusNotes(simulationRunId) : [];\n\n  const digest: CorpusVoiceDigest = {\n    superlativeClaims: extractSuperlativeClaims(allTexts),\n    overusedOpenings: findOverusedOpenings(allTexts),\n    lengthHistogram: computeLengthHistogram(allTexts),\n    tangentCount: allTexts.filter((n) => n.type === \"tangent\").length,\n    totalNotes: allTexts.length,\n    targetCount: new Set(allTexts.map((n) => n.targetName)).size,\n  };\n\n  if (cache) {\n    cache.runId = simulationRunId || null;\n    cache.digest = digest;\n  }\n\n  return digest;\n}", "parameters": [{"name": "cache", "type": "CorpusVoiceDigestCache", "optional": true}], "returnType": "Promise<CorpusVoiceDigest>"}, {"id": "apps/illuminator/webui/src/lib/historianContextBuilders.ts::buildFactCoverageGuidance", "name": "buildFactCoverageGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianContextBuilders.ts", "sourceCode": "/**\n * Build a prioritized list of facts the historian should pay attention to.\n * Returns null if no guidance is needed (all facts are well-represented).\n *\n * \"surface\" targets: facts rated \"mentioned\" \u2014 material exists, historian should draw attention\n * \"connect\" targets: facts rated \"missing\" \u2014 historian should find natural openings for tangent\n *\n * Dynamic dampening: facts that have already been reinforced more than their fair share\n * (relative to total annotations with guidance and total eligible facts) get their score\n * reduced proportionally, preventing any single fact from dominating annotation guidance.\n */\nexport function buildFactCoverageGuidance(\n  report: FactCoverageReport,\n  corpusStrength: Map<string, number>,\n  excludeFactIds?: Set<string>,\n  reinforcement?: ReinforcementCounts\n): FactGuidanceTarget[] | null {\n  const eligible = report.entries\n    .filter((e) => e.rating !== \"integral\" && e.rating !== \"prevalent\")\n    .filter((e) => !excludeFactIds || !excludeFactIds.has(e.factId));\n\n  // Fair share: if each annotation picks 2 targets from F eligible facts across T annotations,\n  // each fact's expected reinforcement count is 2T / F.\n  const eligibleFactCount = eligible.length;\n  const fairShare =\n    reinforcement && eligibleFactCount > 0 && reinforcement.totalAnnotationsWithGuidance > 0\n      ? (2 * reinforcement.totalAnnotationsWithGuidance) / eligibleFactCount\n      : 0;\n\n  const scored = eligible\n    .map((e) => {\n      let score = 0;\n      if (e.rating === \"mentioned\") score += 3;\n      if (e.rating === \"missing\") score += 1;\n      const strength = corpusStrength.get(e.factId) ?? 50;\n      if (strength < 25) score += 3;\n      else if (strength < 50) score += 1;\n      if (e.wasFaceted) score += 1;\n\n      // Dynamic dampening: penalize facts that have consumed more than their fair share\n      if (reinforcement && fairShare > 0) {\n        const count = reinforcement.counts.get(e.factId) ?? 0;\n        const ratio = count / fairShare;\n        if (ratio > 1) {\n          score -= Math.floor((ratio - 1) * 3);\n        }\n      }\n\n      return { entry: e, score, strength };\n    })\n    .filter((s) => s.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 2);\n\n  if (scored.length === 0) return null;\n\n  return scored.map((s) => ({\n    factId: s.entry.factId,\n    factText: s.entry.factText,\n    action: s.entry.rating === \"mentioned\" ? (\"surface\" as const) : (\"connect\" as const),\n    evidence: s.entry.rating === \"mentioned\" ? s.entry.evidence : undefined,\n    corpusStrength: s.strength,\n  }));\n}", "parameters": [{"name": "report", "type": "FactCoverageReport", "optional": false}, {"name": "corpusStrength", "type": "Map<string, number>", "optional": false}, {"name": "excludeFactIds", "type": "Set<string>", "optional": true}, {"name": "reinforcement", "type": "ReinforcementCounts", "optional": true}], "returnType": "FactGuidanceTarget[] | null"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::noteDisplay", "name": "noteDisplay", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Resolve effective display mode, handling legacy `enabled` field */\nexport function noteDisplay(\n  note: Pick<HistorianNote, \"display\" | \"enabled\">\n): HistorianNoteDisplay {\n  if (note.display) return note.display;\n  if (note.enabled === false) return \"disabled\";\n  return \"full\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "HistorianNoteDisplay"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isNoteActive", "name": "isNoteActive", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Whether a note is functionally active (not disabled) */\nexport function isNoteActive(note: Pick<HistorianNote, \"display\" | \"enabled\">): boolean {\n  return noteDisplay(note) !== \"disabled\";\n}", "parameters": [{"name": "note", "type": "Pick<HistorianNote, \"display\" | \"enabled\">", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::isHistorianConfigured", "name": "isHistorianConfigured", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "/** Check whether a historian config has been meaningfully configured */\nexport function isHistorianConfigured(config: HistorianConfig): boolean {\n  return config.name.trim().length > 0 && config.background.trim().length > 0;\n}", "parameters": [{"name": "config", "type": "HistorianConfig", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/historianTypes.ts::computeNoteRange", "name": "computeNoteRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/historianTypes.ts", "sourceCode": "export function computeNoteRange(\n  targetType: HistorianTargetType,\n  wordCount: number\n): { min: number; max: number } {\n  if (targetType === \"entity\") {\n    if (wordCount < 150) return { min: 1, max: 1 };\n    if (wordCount < 300) return { min: 1, max: 3 };\n    if (wordCount < 600) return { min: 2, max: 4 };\n    if (wordCount < 1200) return { min: 3, max: 6 };\n    return { min: 4, max: 8 };\n  }\n  // chronicle \u2014 calibrated for ~75w/note targeting ~25% annotation ratio\n  if (wordCount < 300) return { min: 1, max: 2 };\n  if (wordCount < 800) return { min: 2, max: 3 };\n  if (wordCount < 1500) return { min: 3, max: 5 };\n  if (wordCount < 3000) return { min: 5, max: 8 };\n  return { min: 8, max: 13 };\n}", "parameters": [{"name": "targetType", "type": "HistorianTargetType", "optional": false}, {"name": "wordCount", "type": "number", "optional": false}], "returnType": "{ min: number; max: number }"}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::analyzeImageRefCompatibility", "name": "analyzeImageRefCompatibility", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Analyze all image refs for compatibility with new content.\n */\nexport function analyzeImageRefCompatibility(\n  imageRefs: ChronicleImageRefs,\n  oldContent: string,\n  newContent: string,\n  sourceVersionId: string,\n  targetVersionId: string\n): ImageRefCompatibilityAnalysis {\n  const refResults = imageRefs.refs.map((ref) => analyzeImageRef(ref, oldContent, newContent));\n\n  const summary = {\n    reusable: refResults.filter((r) => r.recommendation === \"reuse\").length,\n    needsRegeneration: refResults.filter((r) => r.recommendation === \"regenerate\").length,\n    needsReview: refResults.filter((r) => r.recommendation === \"manual_review\").length,\n  };\n\n  return {\n    sourceVersionId,\n    targetVersionId,\n    refs: refResults,\n    summary,\n  };\n}", "parameters": [{"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "oldContent", "type": "string", "optional": false}, {"name": "newContent", "type": "string", "optional": false}, {"name": "sourceVersionId", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": false}], "returnType": "ImageRefCompatibilityAnalysis"}, {"id": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts::createDefaultSelections", "name": "createDefaultSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageRefCompatibility.ts", "sourceCode": "/**\n * Create default selections based on compatibility analysis.\n */\nexport function createDefaultSelections(\n  analysis: ImageRefCompatibilityAnalysis\n): ImageRefSelection[] {\n  return analysis.refs.map((ref) => ({\n    refId: ref.refId,\n    action: ref.recommendation === \"regenerate\" ? \"regenerate\" : \"reuse\",\n  }));\n}", "parameters": [{"name": "analysis", "type": "ImageRefCompatibilityAnalysis", "optional": false}], "returnType": "ImageRefSelection[]"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getSizeOptions", "name": "getSizeOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get size options for a given model\n */\nexport function getSizeOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_SIZES_BY_MODEL[model] || IMAGE_SIZES_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getQualityOptions", "name": "getQualityOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get quality options for a given model\n */\nexport function getQualityOptions(model: string): Array<{ value: string; label: string }> {\n  return IMAGE_QUALITY_BY_MODEL[model] || IMAGE_QUALITY_BY_MODEL[\"dall-e-3\"];\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "Array<{ value: string; label: string }>"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultSize", "name": "getDefaultSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default size for a model\n */\nexport function getDefaultSize(model: string): string {\n  const options = getSizeOptions(model);\n  return options[0]?.value || \"1024x1024\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::getDefaultQuality", "name": "getDefaultQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Get the default quality for a model\n */\nexport function getDefaultQuality(model: string): string {\n  const options = getQualityOptions(model);\n  return options[0]?.value || \"standard\";\n}", "parameters": [{"name": "model", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidSize", "name": "isValidSize", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a size is valid for a model\n */\nexport function isValidSize(model: string, size: string): boolean {\n  const options = getSizeOptions(model);\n  return options.some((opt) => opt.value === size);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "size", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/imageSettings.ts::isValidQuality", "name": "isValidQuality", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/imageSettings.ts", "sourceCode": "/**\n * Check if a quality is valid for a model\n */\nexport function isValidQuality(model: string, quality: string): boolean {\n  const options = getQualityOptions(model);\n  return options.some((opt) => opt.value === quality);\n}", "parameters": [{"name": "model", "type": "string", "optional": false}, {"name": "quality", "type": "string", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/jsonParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/jsonParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/llmBudget.ts::calcTokenBudget", "name": "calcTokenBudget", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmBudget.ts", "sourceCode": "export function calcTokenBudget(\n  callType: LLMCallType,\n  callConfig: ResolvedLLMCallConfig,\n  options: TokenBudgetOptions = {}\n): TokenBudget {\n  const defaultMaxTokens = LLM_CALL_METADATA[callType]?.defaults.maxTokens ?? 0;\n  const fallbackMaxTokens =\n    defaultMaxTokens > 0 ? defaultMaxTokens : (options.autoMaxTokens ?? DEFAULT_AUTO_MAX_TOKENS);\n  const responseBudget = callConfig.maxTokens > 0 ? callConfig.maxTokens : fallbackMaxTokens;\n  const safeResponseBudget = responseBudget > 0 ? responseBudget : DEFAULT_AUTO_MAX_TOKENS;\n  const thinkingBudget = callConfig.thinkingBudget > 0 ? callConfig.thinkingBudget : undefined;\n  const totalMaxTokens = thinkingBudget ? thinkingBudget + safeResponseBudget : safeResponseBudget;\n  return { responseBudget: safeResponseBudget, thinkingBudget, totalMaxTokens };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}, {"name": "options", "type": "TokenBudgetOptions", "optional": true}], "returnType": "TokenBudget"}, {"id": "apps/illuminator/webui/src/lib/llmCallTypes.ts::getCallTypesByCategory", "name": "getCallTypesByCategory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmCallTypes.ts", "sourceCode": "// Group call types by category\nexport function getCallTypesByCategory(): Record<LLMCallCategory, LLMCallType[]> {\n  return {\n    description: [\"description.narrative\", \"description.visualThesis\", \"description.visualTraits\"],\n    image: [\"image.promptFormatting\", \"image.chronicleFormatting\"],\n    perspective: [\"perspective.synthesis\"],\n    chronicle: [\n      \"chronicle.generation\",\n      \"chronicle.compare\",\n      \"chronicle.combine\",\n      \"chronicle.copyEdit\",\n      \"chronicle.quickCheck\",\n      \"chronicle.summary\",\n      \"chronicle.title\",\n      \"chronicle.imageRefs\",\n      \"chronicle.coverImageScene\",\n      \"chronicle.toneRanking\",\n      \"chronicle.bulkToneRanking\",\n    ],\n    palette: [\"palette.expansion\"],\n    dynamics: [\"dynamics.generation\"],\n    revision: [\"revision.summary\", \"revision.loreBackport\"],\n    historian: [\n      \"historian.entityReview\",\n      \"historian.chronicleReview\",\n      \"historian.edition\",\n      \"historian.chronology\",\n      \"historian.prep\",\n      \"historian.eraNarrative.threads\",\n      \"historian.eraNarrative.generate\",\n      \"historian.eraNarrative.edit\",\n      \"historian.eraNarrative.coverImageScene\",\n      \"historian.eraNarrative.imageRefs\",\n      \"historian.motifVariation\",\n    ],\n  };\n}", "parameters": [], "returnType": "Record<LLMCallCategory, LLMCallType[]>"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getLLMModelSettings", "name": "getLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Load settings from localStorage\n */\nexport function getLLMModelSettings(): LLMModelSettings {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (stored) {\n      const parsed = JSON.parse(stored);\n      return migrateSettings(parsed);\n    }\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to load settings:\", err);\n  }\n  return { callOverrides: {}, version: CURRENT_VERSION };\n}", "parameters": [], "returnType": "LLMModelSettings"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::saveLLMModelSettings", "name": "saveLLMModelSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "export function saveLLMModelSettings(settings: LLMModelSettings): void {\n  try {\n    const cleanOverrides: LLMModelSettings[\"callOverrides\"] = {};\n    for (const [callType, config] of Object.entries(settings.callOverrides)) {\n      if (!config) continue;\n      const metadata = LLM_CALL_METADATA[callType as LLMCallType];\n      if (!metadata) continue;\n\n      const overrides = extractNonDefaultOverrides(config, metadata.defaults);\n      if (overrides) {\n        cleanOverrides[callType as LLMCallType] = overrides;\n      }\n    }\n\n    localStorage.setItem(\n      STORAGE_KEY,\n      JSON.stringify({\n        callOverrides: cleanOverrides,\n        version: settings.version,\n      })\n    );\n  } catch (err) {\n    console.warn(\"[LLMModelSettings] Failed to save settings:\", err);\n  }\n}", "parameters": [{"name": "settings", "type": "LLMModelSettings", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getModelForCall", "name": "getModelForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the model for a specific call type\n */\nexport function getModelForCall(callType: LLMCallType): string {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.model ?? LLM_CALL_METADATA[callType].defaults.model;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getThinkingBudgetForCall", "name": "getThinkingBudgetForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the thinking budget for a specific call type\n */\nexport function getThinkingBudgetForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.thinkingBudget ?? LLM_CALL_METADATA[callType].defaults.thinkingBudget;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getMaxTokensForCall", "name": "getMaxTokensForCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get the max tokens (pre-reasoning budget) for a specific call type\n */\nexport function getMaxTokensForCall(callType: LLMCallType): number {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  return override?.maxTokens ?? LLM_CALL_METADATA[callType].defaults.maxTokens;\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get complete resolved config for a call\n */\nexport function getCallConfig(callType: LLMCallType): ResolvedLLMCallConfig {\n  const model = getModelForCall(callType);\n  let thinkingBudget = getThinkingBudgetForCall(callType);\n  const maxTokens = getMaxTokensForCall(callType);\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  const defaults = LLM_CALL_METADATA[callType].defaults;\n  const temperature = override?.temperature ?? defaults.temperature;\n  const topP = override?.topP ?? defaults.topP;\n\n  // Ensure thinking is disabled for models that don't support it\n  if (!THINKING_CAPABLE_MODELS.includes(model)) {\n    thinkingBudget = 0;\n  }\n\n  const streamTimeout = override?.streamTimeout ?? defaults.streamTimeout ?? 0;\n  const disableStreaming = override?.disableStreaming ?? defaults.disableStreaming ?? false;\n  const runInBrowser = override?.runInBrowser ?? defaults.runInBrowser ?? false;\n\n  return {\n    model,\n    thinkingBudget,\n    maxTokens,\n    temperature,\n    topP,\n    streamTimeout,\n    disableStreaming,\n    runInBrowser,\n  };\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getResolvedLLMCallSettings", "name": "getResolvedLLMCallSettings", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get all resolved settings for passing to worker\n */\nexport function getResolvedLLMCallSettings(): ResolvedLLMCallSettings {\n  const result = {} as ResolvedLLMCallSettings;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    result[callType] = getCallConfig(callType);\n  }\n  return result;\n}", "parameters": [], "returnType": "ResolvedLLMCallSettings"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::updateCallConfig", "name": "updateCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Update configuration for a specific call type\n */\nexport function updateCallConfig(callType: LLMCallType, config: LLMCallConfigStored): void {\n  const settings = getLLMModelSettings();\n  settings.callOverrides[callType] = config;\n  saveLLMModelSettings(settings);\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}, {"name": "config", "type": "LLMCallConfigStored", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::resetToDefaults", "name": "resetToDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Reset all settings to defaults\n */\nexport function resetToDefaults(): void {\n  saveLLMModelSettings({ callOverrides: {}, version: CURRENT_VERSION });\n}", "parameters": [], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::hasOverrides", "name": "hasOverrides", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Check if a call type has any overrides from default\n */\nexport function hasOverrides(callType: LLMCallType): boolean {\n  const settings = getLLMModelSettings();\n  const override = settings.callOverrides[callType];\n  if (!override) return false;\n\n  const metadata = LLM_CALL_METADATA[callType];\n  return (\n    (override.model !== undefined && override.model !== metadata.defaults.model) ||\n    (override.thinkingBudget !== undefined &&\n      override.thinkingBudget !== metadata.defaults.thinkingBudget) ||\n    (override.maxTokens !== undefined && override.maxTokens !== metadata.defaults.maxTokens) ||\n    (override.temperature !== undefined &&\n      override.temperature !== metadata.defaults.temperature) ||\n    (override.topP !== undefined && override.topP !== metadata.defaults.topP) ||\n    (override.streamTimeout !== undefined &&\n      override.streamTimeout !== (metadata.defaults.streamTimeout ?? 0)) ||\n    (override.disableStreaming !== undefined &&\n      override.disableStreaming !== (metadata.defaults.disableStreaming ?? false)) ||\n    (override.runInBrowser !== undefined &&\n      override.runInBrowser !== (metadata.defaults.runInBrowser ?? false))\n  );\n}", "parameters": [{"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/llmModelSettings.ts::getOverrideCount", "name": "getOverrideCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmModelSettings.ts", "sourceCode": "/**\n * Get count of call types with overrides\n */\nexport function getOverrideCount(): number {\n  let count = 0;\n  for (const callType of ALL_LLM_CALL_TYPES) {\n    if (hasOverrides(callType)) count++;\n  }\n  return count;\n}", "parameters": [], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/llmTextCall.ts::runTextCall", "name": "runTextCall", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/llmTextCall.ts", "sourceCode": "export async function runTextCall(options: LLMTextCallOptions): Promise<LLMTextCallResult> {\n  const budget = calcTokenBudget(options.callType, options.callConfig, {\n    autoMaxTokens: options.autoMaxTokens,\n  });\n  const estimate = estimateTextCostForCall(\n    options.prompt,\n    options.callType,\n    options.callConfig.model,\n    budget.responseBudget\n  );\n\n  const result = await options.llmClient.complete({\n    systemPrompt: options.systemPrompt,\n    prompt: options.prompt,\n    model: options.callConfig.model,\n    maxTokens: budget.totalMaxTokens,\n    temperature: options.temperature,\n    topP: options.topP,\n    thinkingBudget: budget.thinkingBudget,\n    streamTimeout: options.callConfig.streamTimeout,\n    disableStreaming: options.callConfig.disableStreaming,\n  });\n\n  const usage = result.usage\n    ? {\n        inputTokens: result.usage.inputTokens,\n        outputTokens: result.usage.outputTokens,\n        actualCost: calculateActualTextCost(\n          result.usage.inputTokens,\n          result.usage.outputTokens,\n          options.callConfig.model\n        ),\n      }\n    : {\n        inputTokens: estimate.inputTokens,\n        outputTokens: estimate.outputTokens,\n        actualCost: estimate.estimatedCost,\n      };\n\n  return { result, budget, estimate, usage };\n}", "parameters": [{"name": "options", "type": "LLMTextCallOptions", "optional": false}], "returnType": "Promise<LLMTextCallResult>"}, {"id": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts::synthesizePerspective", "name": "synthesizePerspective", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/perspectiveSynthesizer.ts", "sourceCode": "/**\n * Synthesize perspective using LLM\n */\nexport async function synthesizePerspective(\n  input: PerspectiveSynthesisInput,\n  llmClient: LLMClient,\n  callConfig: ResolvedLLMCallConfig\n): Promise<PerspectiveSynthesisResult> {\n  const { factsWithMetadata, toneFragments } = input;\n\n  // Separate generation constraints (always included verbatim, not sent to LLM)\n  const generationConstraints = (factsWithMetadata || []).filter(\n    (f) => f.type === \"generation_constraint\" && !f.disabled\n  );\n\n  // Build prompt with ALL baseline material - let LLM do the refinement\n  const { prompt: userPrompt, resolvedWorldDynamics } = buildUserPrompt(input);\n\n  // Assembled tone is the core tone fragment\n  const assembledTone = toneFragments.core;\n\n  // Make LLM call\n  const callResult = await runTextCall({\n    llmClient,\n    callType: \"perspective.synthesis\",\n    callConfig,\n    systemPrompt: SYSTEM_PROMPT,\n    prompt: userPrompt,\n    temperature: 0.7, // Allow variation\n  });\n\n  // Parse response\n  const synthesis = parseSynthesisResponse(callResult.result.text);\n\n  // Enforce required facts and finalize\n  const enforcedSynthesis = enforceFacetRequirements(synthesis, input);\n\n  // Build faceted facts for generation\n  const facetedFacts = buildFacetedFacts(enforcedSynthesis, factsWithMetadata, generationConstraints);\n\n  return {\n    synthesis: enforcedSynthesis,\n    assembledTone,\n    facetedFacts,\n    resolvedWorldDynamics,\n    usage: callResult.usage,\n  };\n}", "parameters": [{"name": "input", "type": "PerspectiveSynthesisInput", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}, {"name": "callConfig", "type": "ResolvedLLMCallConfig", "optional": false}], "returnType": "Promise<PerspectiveSynthesisResult>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getTone", "name": "getTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat tone string from structured context\n */\nexport function getTone(ctx: WorldContext): string {\n  return ctx.toneFragments?.core || \"\";\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getCanonFacts", "name": "getCanonFacts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get flat canon facts array from structured context\n */\nexport function getCanonFacts(ctx: WorldContext): string[] {\n  return (ctx.canonFactsWithMetadata || []).map((f) => f.text);\n}", "parameters": [{"name": "ctx", "type": "WorldContext", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getKindGuidance", "name": "getKindGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// NEW: Helper Functions for Entity Guidance\n// =============================================================================\n\n/**\n * Get guidance for a specific entity kind\n * Returns undefined if kind not found (caller should handle gracefully)\n */\nexport function getKindGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): KindGuidance | undefined {\n  return entityGuidance[kind];\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "KindGuidance | undefined"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredVisualIdentity", "name": "getFilteredVisualIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual identity for a culture, filtered by entity kind\n */\nexport function getFilteredVisualIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureVisual = cultureIdentities.visual[culture];\n  if (!cultureVisual) return {};\n\n  const allowedKeys = cultureIdentities.visualKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureVisual;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureVisual[key]) {\n      filtered[key] = cultureVisual[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getFilteredDescriptiveIdentity", "name": "getFilteredDescriptiveIdentity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get descriptive identity for a culture, filtered by entity kind\n */\nexport function getFilteredDescriptiveIdentity(\n  cultureIdentities: CultureIdentities,\n  culture: string,\n  kind: string\n): Record<string, string> {\n  const cultureDescriptive = cultureIdentities.descriptive[culture];\n  if (!cultureDescriptive) return {};\n\n  const allowedKeys = cultureIdentities.descriptiveKeysByKind[kind] || [];\n  if (allowedKeys.length === 0) return cultureDescriptive;\n\n  const filtered: Record<string, string> = {};\n  for (const key of allowedKeys) {\n    if (cultureDescriptive[key]) {\n      filtered[key] = cultureDescriptive[key];\n    }\n  }\n  return filtered;\n}", "parameters": [{"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "culture", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Record<string, string>"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildProseHints", "name": "buildProseHints", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build prose hints for chronicle generation\n * Aggregates proseHint from all involved entity kinds\n */\nexport function buildProseHints(entityGuidance: EntityGuidance, involvedKinds: string[]): string {\n  const uniqueKinds = [...new Set(involvedKinds)];\n  const hints: string[] = [];\n\n  for (const kind of uniqueKinds) {\n    const guidance = entityGuidance[kind];\n    if (guidance?.proseHint) {\n      hints.push(`${kind.toUpperCase()}: ${guidance.proseHint}`);\n    }\n  }\n\n  return hints.length > 0 ? hints.join(\"\\n\") : \"\";\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "involvedKinds", "type": "string[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildDescriptionPromptFromGuidance", "name": "buildDescriptionPromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "// =============================================================================\n// Prompt Builders (using EntityGuidance directly)\n// =============================================================================\n\n/**\n * Build a description prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildDescriptionPromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Get filtered cultural identities\n  const descriptiveIdentity = getFilteredDescriptiveIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n\n  // Format sections\n  const tagsSection =\n    e.tags && Object.keys(e.tags).length > 0\n      ? `TAGS:\\n${Object.entries(e.tags)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const descriptiveSection =\n    Object.keys(descriptiveIdentity).length > 0\n      ? `CULTURAL IDENTITY (${e.culture}):\\n${Object.entries(descriptiveIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const visualSection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  const relationshipsSection =\n    entityContext.relationships.length > 0\n      ? entityContext.relationships\n          .slice(0, 8)\n          .map((r) => {\n            let line = `- ${r.kind}: ${r.targetName} (${r.targetKind}`;\n            if (r.targetSubtype) line += `/${r.targetSubtype}`;\n            line += \")\";\n            const strength = r.strength ?? 0.5;\n            let label: string;\n            if (strength >= 0.7) label = \"strong\";\n            else if (strength >= 0.4) label = \"moderate\";\n            else label = \"weak\";\n            line += ` [${label}]`;\n            return line;\n          })\n          .join(\"\\n\")\n      : \"(No established relationships)\";\n\n  const parts = [\n    `Write a description for ${e.name}, a ${e.subtype} ${kind} in ${worldContext.name}.`,\n    \"\",\n    `WORLD: ${worldContext.description}`,\n    \"\",\n    \"TONE & STYLE:\",\n    getTone(worldContext),\n    \"\",\n    \"CANON FACTS (never contradict):\",\n    getCanonFacts(worldContext)\n      .map((f) => `- ${f}`)\n      .join(\"\\n\"),\n    \"\",\n    \"---\",\n    \"\",\n    \"ENTITY:\",\n    `- Kind: ${kind}`,\n    `- Subtype: ${e.subtype}`,\n    `- Prominence: ${e.prominence}`,\n    `- Status: ${e.status}`,\n    `- Culture: ${e.culture || \"unaffiliated\"}`,\n    `- Age in world: ${entityContext.entityAge}`,\n    \"\",\n    tagsSection,\n    descriptiveSection,\n    visualSection,\n    \"\",\n    \"RELATIONSHIPS:\",\n    relationshipsSection,\n    \"\",\n    entityContext.culturalPeers?.length\n      ? `CULTURAL PEERS: ${entityContext.culturalPeers.join(\", \")}`\n      : \"\",\n    entityContext.factionMembers?.length\n      ? `FACTION MEMBERS: ${entityContext.factionMembers.join(\", \")}`\n      : \"\",\n    \"\",\n    // Add events section if entity has narrative history\n    entityContext.events?.length\n      ? `HISTORY FRAGMENTS (mine for flavor, don't enumerate):\\n${entityContext.events\n          .map((ev) => `- [${ev.era}] ${ev.description}`)\n          .join(\"\\n\")}`\n      : \"\",\n    \"\",\n    `ERA: ${entityContext.era.name}${entityContext.era.description ? \" - \" + entityContext.era.description : \"\"}`,\n    \"\",\n    \"---\",\n    \"\",\n    `FOCUS FOR ${kind.toUpperCase()}:`,\n    guidance.focus,\n    \"\",\n    \"RELATIONSHIP GUIDANCE:\",\n    guidance.relationshipUse,\n    \"\",\n    \"---\",\n    \"\",\n    \"OUTPUT: Return JSON with keys: summary, description, aliases\",\n    \"- description: 2-4 sentences, vivid and specific\",\n    \"- summary: 1-2 sentences, compressed and faithful to description\",\n    \"- aliases: array of alternate names (can be empty)\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildImagePromptFromGuidance", "name": "buildImagePromptFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt using EntityGuidance and CultureIdentities directly.\n * No adapter layer - this is the canonical prompt builder.\n */\nexport function buildImagePromptFromGuidance(\n  entityGuidance: EntityGuidance,\n  cultureIdentities: CultureIdentities,\n  worldContext: WorldContext,\n  entityContext: EntityContext,\n  styleInfo?: StyleInfo\n): string {\n  const e = entityContext.entity;\n  const kind = e.kind;\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n\n  // Use summary for image prompts (concise text for visual generation)\n  const summaryText = e.summary || \"\";\n\n  // Visual thesis - THE primary visual signal\n  const visualThesisSection = e.visualThesis\n    ? `VISUAL THESIS (PRIMARY - this is the dominant visual signal):\\n${e.visualThesis}`\n    : \"\";\n\n  // Supporting traits\n  const traitsBody = e.visualTraits?.length\n    ? e.visualTraits.map((t) => `- ${t}`).join(\"\\n\")\n    : \"\";\n  const supportingTraitsSection = traitsBody\n    ? `SUPPORTING TRAITS (reinforce the thesis):\\n${traitsBody}`\n    : \"\";\n\n  // Cultural visual identity\n  const visualIdentity = getFilteredVisualIdentity(cultureIdentities, e.culture, kind);\n  const visualIdentitySection =\n    Object.keys(visualIdentity).length > 0\n      ? `CULTURAL VISUAL IDENTITY (${e.culture}):\\n${Object.entries(visualIdentity)\n          .map(([k, v]) => `- ${k}: ${v}`)\n          .join(\"\\n\")}`\n      : \"\";\n\n  // Style sections\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : \"\";\n\n  // Species constraint section - placed prominently after IMAGE INSTRUCTIONS\n  const speciesSection = worldContext.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${worldContext.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    `IMAGE INSTRUCTIONS: ${guidance.imageInstructions}`,\n    speciesSection,\n    \"\",\n    `SUBJECT: ${e.name}, a ${e.subtype} ${kind}`,\n    summaryText ? `CONTEXT: ${summaryText}` : \"\",\n    \"\",\n    visualThesisSection,\n    supportingTraitsSection,\n    visualIdentitySection,\n    \"\",\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    \"RENDER: Favor stylized exaggeration over anatomical realism. Push proportions to emphasize the thesis.\",\n    \"\",\n    `SETTING: ${worldContext.name}`,\n    \"\",\n    `AVOID: ${guidance.imageAvoid}`,\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "cultureIdentities", "type": "CultureIdentities", "optional": false}, {"name": "worldContext", "type": "WorldContext", "optional": false}, {"name": "entityContext", "type": "EntityContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::getVisualConfigFromGuidance", "name": "getVisualConfigFromGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Get visual config for an entity from EntityGuidance\n */\nexport function getVisualConfigFromGuidance(\n  entityGuidance: EntityGuidance,\n  kind: string\n): {\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n} {\n  const guidance = entityGuidance[kind] || getDefaultKindGuidance(kind);\n  return {\n    visualAvoid: guidance.imageAvoid,\n    visualThesisInstructions: `${guidance.visualThesis.domain}\\n\\n${guidance.visualThesis.focus}`,\n    visualThesisFraming: guidance.visualThesis.framing,\n    visualTraitsInstructions: `${guidance.visualTraits.domain}\\n\\n${guidance.visualTraits.focus}`,\n    visualTraitsFraming: guidance.visualTraits.framing,\n  };\n}", "parameters": [{"name": "entityGuidance", "type": "EntityGuidance", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "{\n  visualAvoid: string;\n  visualThesisInstructions: string;\n  visualThesisFraming: string;\n  visualTraitsInstructions: string;\n  visualTraitsFraming: string;\n}"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultEntityGuidance", "name": "createDefaultEntityGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default entity guidance (fallback when none provided)\n */\nexport function createDefaultEntityGuidance(): EntityGuidance {\n  return {};\n}", "parameters": [], "returnType": "EntityGuidance"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::createDefaultCultureIdentities", "name": "createDefaultCultureIdentities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Create default culture identities (fallback when none provided)\n */\nexport function createDefaultCultureIdentities(): CultureIdentities {\n  return {\n    visual: {},\n    descriptive: {},\n    visualKeysByKind: {},\n    descriptiveKeysByKind: {},\n  };\n}", "parameters": [], "returnType": "CultureIdentities"}, {"id": "apps/illuminator/webui/src/lib/promptBuilders.ts::buildChronicleScenePrompt", "name": "buildChronicleScenePrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/promptBuilders.ts", "sourceCode": "/**\n * Build an image prompt for chronicle scene/montage images.\n * Rendering directives (STYLE/PALETTE/COMPOSITION) come first as primary authority.\n * No entity lookups \u2014 visual identity is baked into the scene description by the scene LLM.\n */\nexport function buildChronicleScenePrompt(\n  context: ChronicleSceneContext,\n  styleInfo?: StyleInfo\n): string {\n  const { sceneDescription, size, chronicleTitle, world } = context;\n\n  // Rendering directives first \u2014 these are the primary visual authority\n  const styleSection = styleInfo?.artisticPromptFragment\n    ? `STYLE: ${styleInfo.artisticPromptFragment}`\n    : \"\";\n\n  let colorPaletteSection = \"\";\n  if (styleInfo?.colorPalettePromptFragment) {\n    colorPaletteSection = styleInfo.colorPalettePromptFragment.startsWith(\"COLOR PALETTE\")\n      ? styleInfo.colorPalettePromptFragment\n      : `COLOR PALETTE: ${styleInfo.colorPalettePromptFragment}`;\n  }\n\n  const compositionHint = SIZE_COMPOSITION_HINTS[size] || SIZE_COMPOSITION_HINTS.medium;\n  const compositionSection = styleInfo?.compositionPromptFragment\n    ? `COMPOSITION: ${styleInfo.compositionPromptFragment}`\n    : `COMPOSITION: ${compositionHint}`;\n\n  const sizeHint = `SIZE HINT: ${compositionHint}`;\n\n  // Scene content\n  const worldDescSuffix = world?.description ? ` - ${world.description}` : \"\";\n  const worldSection = world\n    ? `WORLD: ${world.name}${worldDescSuffix}`\n    : \"\";\n\n  const speciesSection = world?.speciesConstraint\n    ? `SPECIES REQUIREMENT: ${world.speciesConstraint}`\n    : \"\";\n\n  const parts = [\n    styleSection,\n    colorPaletteSection,\n    compositionSection,\n    sizeHint,\n    \"\",\n    `SCENE: ${sceneDescription}`,\n    chronicleTitle ? `FROM: \"${chronicleTitle}\"` : \"\",\n    \"\",\n    worldSection,\n    speciesSection,\n    \"\",\n    \"AVOID: Human figures, humanoid hands or fingers, human body proportions. Modern elements, anachronistic technology, text overlays, watermarks\",\n  ];\n\n  return parts\n    .filter(Boolean)\n    .join(\"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}", "parameters": [{"name": "context", "type": "ChronicleSceneContext", "optional": false}, {"name": "styleInfo", "type": "StyleInfo", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/traitPalette.ts::expandPalette", "name": "expandPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/traitPalette.ts", "sourceCode": "// ============================================================================\n// Expansion Execution\n// ============================================================================\n\nexport async function expandPalette(\n  request: PaletteExpansionRequest,\n  llmClient: LLMClient\n): Promise<PaletteExpansionResult> {\n  const { projectId, entityKind, worldContext } = request;\n\n  if (!llmClient.isEnabled()) {\n    return { success: false, error: \"LLM client not configured\" };\n  }\n\n  // Get model settings for palette expansion\n  const callConfig = getCallConfig(\"palette.expansion\");\n  const { model } = callConfig;\n\n  // Gather current state\n  const currentPalette = await getPalette(projectId, entityKind);\n  const historicalTraits = await getHistoricalTraits(projectId, entityKind);\n\n  const prompt = buildExpansionPrompt(\n    entityKind,\n    worldContext,\n    currentPalette?.items || [],\n    historicalTraits\n  );\n\n  const expansionCall = await runTextCall({\n    llmClient,\n    callType: \"palette.expansion\",\n    callConfig,\n    systemPrompt: EXPANSION_SYSTEM_PROMPT,\n    prompt,\n    temperature: 0.9,\n  });\n  const result = expansionCall.result;\n\n  if (result.error || !result.text) {\n    return {\n      success: false,\n      error: result.error || \"Empty response from LLM\",\n    };\n  }\n\n  // Parse response\n  let expansion: ExpansionResponse;\n  try {\n    expansion = parseExpansionResponse(result.text);\n  } catch (err) {\n    return {\n      success: false,\n      error: `Failed to parse expansion response: ${err instanceof Error ? err.message : \"Unknown error\"}`,\n    };\n  }\n\n  // Apply updates\n  const updatedPalette = await updatePaletteItems(projectId, entityKind, {\n    removeIds: expansion.removedCategories,\n    merges: expansion.mergedCategories,\n    newItems: expansion.newCategories,\n  });\n\n  // Calculate costs\n  const cost = {\n    estimated: expansionCall.estimate.estimatedCost,\n    actual: expansionCall.usage.actualCost,\n    inputTokens: expansionCall.usage.inputTokens,\n    outputTokens: expansionCall.usage.outputTokens,\n  };\n\n  // Save cost record\n  await saveCostRecordWithDefaults({\n    projectId,\n    simulationRunId: request.simulationRunId,\n    type: \"paletteExpansion\",\n    model,\n    estimatedCost: cost.estimated,\n    actualCost: cost.actual,\n    inputTokens: cost.inputTokens,\n    outputTokens: cost.outputTokens,\n  });\n\n  return {\n    success: true,\n    palette: updatedPalette,\n    stats: {\n      removed: expansion.removedCategories?.length || 0,\n      merged: expansion.mergedCategories?.length || 0,\n      added: expansion.newCategories?.length || 0,\n    },\n    cost,\n  };\n}", "parameters": [{"name": "request", "type": "PaletteExpansionRequest", "optional": false}, {"name": "llmClient", "type": "LLMClient", "optional": false}], "returnType": "Promise<PaletteExpansionResult>"}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::findEntityMentions", "name": "findEntityMentions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "/**\n * Find entity mentions in text using Aho-Corasick matching.\n * Returns one match per entity (first occurrence), no overlap filtering.\n * Use this for detection (e.g. tertiary cast) where we need to know\n * which entities are mentioned regardless of overlapping spans.\n */\nexport function findEntityMentions(content: string, entities: WikiLinkEntity[]): WikiLinkMatch[] {\n  if (!content || entities.length === 0) return [];\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  return Array.from(matchesByEntity.values());\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkMatch[]"}, {"id": "apps/illuminator/webui/src/lib/wikiLinkService.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/wikiLinkService.ts", "sourceCode": "export function applyWikiLinks(content: string, entities: WikiLinkEntity[]): WikiLinkResult {\n  if (!content || entities.length === 0) {\n    return { content, links: [], collisions: [] };\n  }\n\n  const automaton = getAutomaton(entities);\n  const { normalized, indexMap } = normalizeForMatch(content);\n  const matchesByEntity = scanEntityMatches(normalized, indexMap, automaton);\n  const matches = filterOverlaps(Array.from(matchesByEntity.values()));\n\n  if (matches.length === 0) {\n    return { content, links: [], collisions: automaton.collisions };\n  }\n\n  let cursor = 0;\n  const output: string[] = [];\n\n  for (const match of matches) {\n    if (match.start > cursor) {\n      output.push(content.slice(cursor, match.start));\n    }\n    const rawSegment = content.slice(match.start, match.end);\n    output.push(`[[${rawSegment}]]`);\n    cursor = match.end;\n  }\n\n  if (cursor < content.length) {\n    output.push(content.slice(cursor));\n  }\n\n  return {\n    content: output.join(\"\"),\n    links: matches,\n    collisions: automaton.collisions,\n  };\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "WikiLinkEntity[]", "optional": false}], "returnType": "WikiLinkResult"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isSharedWorkerSupported", "name": "isSharedWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Check if SharedWorker is supported\n */\nexport function isSharedWorkerSupported(): boolean {\n  return typeof SharedWorker !== \"undefined\";\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::isServiceWorkerSupported", "name": "isServiceWorkerSupported", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function isServiceWorkerSupported(): boolean {\n  return (\n    typeof navigator !== \"undefined\" &&\n    \"serviceWorker\" in navigator &&\n    typeof window !== \"undefined\" &&\n    window.isSecureContext\n  );\n}", "parameters": [], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorker", "name": "createWorker", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "/**\n * Create a worker handle that abstracts SharedWorker vs regular Worker\n */\nexport function createWorker(config: WorkerConfig): WorkerHandle {\n  if (isServiceWorkerSupported()) {\n    const handle = createServiceWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    return handle;\n  }\n\n  // Try SharedWorker first\n  if (isSharedWorkerSupported()) {\n    try {\n      const handle = createSharedWorkerHandle();\n      handle.postMessage({ type: \"init\", config });\n      return handle;\n    } catch (err) {\n      console.warn(\"[WorkerFactory] SharedWorker failed, falling back to dedicated Worker:\", err);\n    }\n  }\n\n  // Fallback to regular Worker\n  const handle = createDedicatedWorkerHandle();\n  handle.postMessage({ type: \"init\", config });\n  return handle;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "WorkerHandle"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::createWorkerPool", "name": "createWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function createWorkerPool(config: WorkerConfig, count: number): WorkerHandle[] {\n  if (isServiceWorkerSupported()) {\n    const handles = fillFromPool(getServiceWorkerPool(), count, createServiceWorkerHandle, \"ServiceWorker handle\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  if (isSharedWorkerSupported()) {\n    const handles = fillFromPool(getSharedWorkerPool(), count, createSharedWorkerHandle, \"SharedWorker port\");\n    initHandles(handles, config);\n    return handles;\n  }\n\n  const handles: WorkerHandle[] = [];\n  for (let i = 0; i < count; i++) {\n    const handle = createDedicatedWorkerHandle();\n    handle.postMessage({ type: \"init\", config });\n    handles.push(handle);\n  }\n  return handles;\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "WorkerHandle[]"}, {"id": "apps/illuminator/webui/src/lib/workerFactory.ts::resetWorkerPool", "name": "resetWorkerPool", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/workerFactory.ts", "sourceCode": "export function resetWorkerPool(): void {\n  const sharedPool = getSharedWorkerPool();\n  for (const handle of sharedPool) {\n    handle?.terminate();\n  }\n  sharedPool.length = 0;\n\n  const servicePool = getServiceWorkerPool();\n  for (const handle of servicePool) {\n    handle?.terminate();\n  }\n  servicePool.length = 0;\n\n  const globalScope = globalThis as GlobalServiceWorkerState;\n  if (globalScope.__illuminatorServiceWorkerHandleMap) {\n    globalScope.__illuminatorServiceWorkerHandleMap.clear();\n  }\n}", "parameters": [], "returnType": "void"}, {"id": "apps/illuminator/webui/src/workers/clients.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/clients.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}"}, {"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}"}, {"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx", "sourceCode": "export default function ChronicleVersionSelector({\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}) {\n  const isActive = selectedVersionId === activeVersionId;\n  const canDelete = versions.length > 1 && onDeleteVersion;\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const confirmingDelete = confirmingDeleteId === selectedVersionId;\n\n  useEffect(() => {\n    if (!confirmingDeleteId) return;\n    const stillExists = versions.some((v) => v.id === confirmingDeleteId);\n    if (!stillExists || confirmingDeleteId !== selectedVersionId || disabled) {\n      setConfirmingDeleteId(null);\n    }\n  }, [confirmingDeleteId, selectedVersionId, versions, disabled]);\n\n  const handleDeleteClick = () => {\n    if (confirmingDelete) {\n      onDeleteVersion(selectedVersionId);\n      setConfirmingDeleteId(null);\n    } else {\n      setConfirmingDeleteId(selectedVersionId);\n    }\n  };\n\n  return (\n    <div className=\"cvs-container\">\n      <select\n        value={selectedVersionId}\n        onChange={(e) => {\n          onSelectVersion(e.target.value);\n          setConfirmingDeleteId(null);\n        }}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-version\"\n      >\n        {versions.map((version) => (\n          <option key={version.id} value={version.id}>\n            {version.label}\n          </option>\n        ))}\n      </select>\n      <select\n        value={compareToVersionId}\n        onChange={(e) => onSelectCompareVersion(e.target.value)}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-compare\"\n        title=\"Select a version to diff against\"\n      >\n        <option value=\"\">Compare to...</option>\n        {versions\n          .filter((v) => v.id !== selectedVersionId)\n          .map((version) => (\n            <option key={version.id} value={version.id}>\n              {version.shortLabel || version.label}\n            </option>\n          ))}\n      </select>\n      {isActive ? (\n        <span className=\"cvs-active-badge\">Active</span>\n      ) : (\n        <button\n          onClick={() => onSetActiveVersion?.(selectedVersionId)}\n          disabled={disabled || !onSetActiveVersion}\n          className=\"cvs-btn-make-active\"\n        >\n          Make Active\n        </button>\n      )}\n      {canDelete && (\n        <button\n          onClick={handleDeleteClick}\n          onBlur={() => setConfirmingDeleteId(null)}\n          disabled={disabled}\n          title={confirmingDelete ? \"Click again to confirm deletion\" : \"Delete this version\"}\n          className={`cvs-btn-delete${confirmingDelete ? \" cvs-btn-delete-confirming\" : \"\"}`}\n        >\n          {confirmingDelete ? \"Confirm Delete\" : \"Delete\"}\n        </button>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}", "type": "{ versions: any; selectedVersionId: any; activeVersionId: any; compareToVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; disabled: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx", "sourceCode": "export default function ChronicleWorkspace({\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  const isComplete = item.status === \"complete\";\n\n  // ---------------------------------------------------------------------------\n  // Entity map\n  // ---------------------------------------------------------------------------\n  const entityMap = useMemo(() => {\n    if (!entities) return new Map();\n    return new Map(entities.map((e) => [e.id, e]));\n  }, [entities]);\n\n  // ---------------------------------------------------------------------------\n  // Version state & memos\n  // ---------------------------------------------------------------------------\n  const versions = useMemo(() => {\n    const stepLabel = (step) => {\n      if (!step) return null;\n      const labels = {\n        generate: \"initial\",\n        regenerate: \"regenerate\",\n        creative: \"creative\",\n        combine: \"combine\",\n        copy_edit: \"copy-edit\",\n      };\n      return labels[step] || step;\n    };\n\n    const sorted = [...(item.generationHistory || [])].sort(\n      (a, b) => a.generatedAt - b.generatedAt\n    );\n    const seen = new Set();\n    const unique = [];\n    for (const version of sorted) {\n      if (seen.has(version.versionId)) continue;\n      seen.add(version.versionId);\n      unique.push(version);\n    }\n    return unique.map((version, index) => {\n      const samplingLabel = version.sampling ?? \"unspecified\";\n      const step = stepLabel(version.step);\n      const stepDisplay = step || `sampling ${samplingLabel}`;\n      return {\n        id: version.versionId,\n        content: version.content,\n        wordCount: version.wordCount,\n        shortLabel: `V${index + 1}`,\n        label: `Version ${index + 1} \\u2022 ${new Date(version.generatedAt).toLocaleString()} \\u2022 ${stepDisplay}`,\n      };\n    });\n  }, [item.generationHistory]);\n\n  const activeVersionId = item.activeVersionId || versions[versions.length - 1]?.id;\n\n  const [selectedVersionId, setSelectedVersionId] = useState(activeVersionId);\n  const [compareToVersionId, setCompareToVersionId] = useState(\"\");\n\n  useEffect(() => {\n    setSelectedVersionId(activeVersionId);\n    setCompareToVersionId(\"\");\n  }, [activeVersionId, item.chronicleId]);\n\n  useEffect(() => {\n    if (versions.length === 0) return;\n\n    const hasSelected = versions.some((v) => v.id === selectedVersionId);\n    let nextSelected = selectedVersionId;\n    if (!hasSelected) {\n      const hasActive = versions.some((v) => v.id === activeVersionId);\n      nextSelected = hasActive ? activeVersionId : versions[versions.length - 1].id;\n      setSelectedVersionId(nextSelected);\n    }\n\n    if (compareToVersionId) {\n      const hasCompare = versions.some((v) => v.id === compareToVersionId);\n      if (!hasCompare || compareToVersionId === nextSelected) {\n        setCompareToVersionId(\"\");\n      }\n    }\n  }, [versions, selectedVersionId, compareToVersionId, activeVersionId]);\n\n  const selectedVersion = useMemo(\n    () => versions.find((v) => v.id === selectedVersionId) || versions[versions.length - 1],\n    [versions, selectedVersionId]\n  );\n\n  const compareToVersion = useMemo(\n    () => (compareToVersionId ? versions.find((v) => v.id === compareToVersionId) : null),\n    [versions, compareToVersionId]\n  );\n\n  const versionLabelMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.shortLabel);\n    return map;\n  }, [versions]);\n\n  const versionContentMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.content);\n    return map;\n  }, [versions]);\n\n  const getVersionLabel = (versionId) => versionLabelMap.get(versionId) || \"Unknown\";\n\n  const formatTargetIndicator = (targetVersionId) => {\n    if (!targetVersionId) return null;\n    const targetLabel = getVersionLabel(targetVersionId);\n    const activeLabel = getVersionLabel(activeVersionId);\n    if (targetVersionId === activeVersionId) return null;\n    return `Targets ${targetLabel} \\u2022 Active ${activeLabel}`;\n  };\n\n  const summaryIndicator = formatTargetIndicator(item.summaryTargetVersionId);\n  const imageRefsIndicator = formatTargetIndicator(item.imageRefsTargetVersionId);\n  const imageRefsTargetContent =\n    versionContentMap.get(item.imageRefsTargetVersionId || activeVersionId) ||\n    item.assembledContent;\n\n  const compareRunning = refinements?.compare?.running || false;\n  const combineRunning = refinements?.combine?.running || false;\n  const copyEditRunning = refinements?.copyEdit?.running || false;\n  const temporalCheckRunning = refinements?.temporalCheck?.running || false;\n  const quickCheckRunning = refinements?.quickCheck?.running || false;\n\n  // ---------------------------------------------------------------------------\n  // Tertiary cast \u2014 manual detect + persisted on ChronicleRecord\n  // ---------------------------------------------------------------------------\n  const detectTertiaryCast = useCallback(async () => {\n    if (!simulationRunId) return;\n    const content = isComplete\n      ? item.finalContent\n      : selectedVersion?.content || item.assembledContent;\n    if (!content) return;\n\n    // Read fresh entities from Dexie so newly added/edited entities are included\n    const freshEntities = await getEntitiesForRun(simulationRunId);\n    const freshEntityMap = new Map(freshEntities.map((e) => [e.id, e]));\n\n    // Build name/alias dictionary for Aho-Corasick (exclude eras \u2014 too generic)\n    const wikiEntities = [];\n    for (const entity of freshEntities) {\n      if (entity.kind === \"era\") continue;\n      wikiEntities.push({ id: entity.id, name: entity.name });\n      const aliases = entity.enrichment?.text?.aliases;\n      if (Array.isArray(aliases)) {\n        for (const alias of aliases) {\n          if (typeof alias === \"string\" && alias.length >= 3) {\n            wikiEntities.push({ id: entity.id, name: alias });\n          }\n        }\n      }\n    }\n\n    const mentions = findEntityMentions(content, wikiEntities);\n\n    const declaredIds = new Set(item.selectedEntityIds || []);\n\n    // Preserve existing accepted/rejected decisions for entities still detected\n    const prevDecisions = new Map((item.tertiaryCast || []).map((e) => [e.entityId, e.accepted]));\n\n    const seen = new Set();\n    const entries = [];\n    for (const m of mentions) {\n      if (declaredIds.has(m.entityId) || seen.has(m.entityId)) continue;\n      seen.add(m.entityId);\n      const entity = freshEntityMap.get(m.entityId);\n      if (entity) {\n        entries.push({\n          entityId: entity.id,\n          name: entity.name,\n          kind: entity.kind,\n          matchedAs: content.slice(m.start, m.end),\n          matchStart: m.start,\n          matchEnd: m.end,\n          accepted: prevDecisions.get(entity.id) ?? true,\n        });\n      }\n    }\n\n    const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n    await updateChronicleTertiaryCast(item.chronicleId, entries);\n    await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n  }, [\n    simulationRunId,\n    isComplete,\n    item.finalContent,\n    item.assembledContent,\n    item.selectedEntityIds,\n    item.chronicleId,\n    item.tertiaryCast,\n    selectedVersion,\n  ]);\n\n  const toggleTertiaryCast = useCallback(\n    async (entityId) => {\n      const current = item.tertiaryCast || [];\n      const updated = current.map((e) =>\n        e.entityId === entityId ? { ...e, accepted: !e.accepted } : e\n      );\n      const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n      await updateChronicleTertiaryCast(item.chronicleId, updated);\n      await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n    },\n    [item.chronicleId, item.tertiaryCast]\n  );\n\n  // ---------------------------------------------------------------------------\n  // Seed data\n  // ---------------------------------------------------------------------------\n  const seedData = useMemo(\n    () => ({\n      narrativeStyleId: item.narrativeStyleId || \"\",\n      narrativeStyleName:\n        item.narrativeStyle?.name ||\n        styleLibrary?.narrativeStyles?.find((s) => s.id === item.narrativeStyleId)?.name,\n      entrypointId: item.entrypointId,\n      entrypointName: item.entrypointId\n        ? entities?.find((e) => e.id === item.entrypointId)?.name\n// ... (truncated)", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: an...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx", "sourceCode": "// ============================================================================\n// Content Tab\n// ============================================================================\n\nexport default function ContentTab({\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}) {\n  const content = isComplete\n    ? item.finalContent\n    : selectedVersion?.content || item.assembledContent;\n\n  const wc = isComplete\n    ? item.finalContent?.split(/\\s+/).filter(Boolean).length || 0\n    : (selectedVersion?.wordCount ??\n      (item.assembledContent?.split(/\\s+/).filter(Boolean).length || 0));\n\n  const copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\n  const [summaryExpanded, setSummaryExpanded] = useState(false);\n  const [tertiaryCastExpanded, setTertiaryCastExpanded] = useState(false);\n  const [hoveredTertiaryId, setHoveredTertiaryId] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n\n  const handleTertiaryMouseEnter = useCallback((entityId) => {\n    clearTimeout(hoverTimeoutRef.current);\n    setHoveredTertiaryId(entityId);\n  }, []);\n  const handleTertiaryMouseLeave = useCallback(() => {\n    hoverTimeoutRef.current = setTimeout(() => setHoveredTertiaryId(null), 150);\n  }, []);\n\n  const hasTertiaryCast = item.tertiaryCast?.length > 0;\n  const tertiaryExpanded = tertiaryCastExpanded && hasTertiaryCast;\n\n  return (\n    <div>\n      {/* Summary (collapsible) */}\n      {item.summary && (\n        <div className=\"ctab-summary-section\">\n          <div\n            onClick={() => setSummaryExpanded((v) => !v)}\n            className={`ctab-summary-header ${summaryExpanded ? \"ctab-summary-header-expanded\" : \"\"}`}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            <span className=\"ctab-summary-label\">\n              <span className=\"ctab-collapse-icon\">{summaryExpanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n              Summary\n            </span>\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                navigator.clipboard.writeText(item.summary);\n              }}\n              className=\"ctab-copy-btn\"\n            >\n              Copy\n            </button>\n          </div>\n          {summaryExpanded && <div className=\"ctab-summary-body\">{item.summary}</div>}\n        </div>\n      )}\n\n      {/* Tertiary cast -- entities mentioned but not in declared cast (persisted) */}\n      <div className=\"ctab-tertiary-section\">\n        <div\n          onClick={() => hasTertiaryCast && setTertiaryCastExpanded((v) => !v)}\n          className={`ctab-tertiary-header ${hasTertiaryCast ? \"ctab-tertiary-header-expandable\" : \"ctab-tertiary-header-default\"} ${tertiaryExpanded ? \"ctab-tertiary-header-expanded\" : \"ctab-tertiary-header-collapsed\"}`}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"ctab-tertiary-label\">\n            {hasTertiaryCast && (\n              <span className=\"ctab-collapse-icon\">\n                {tertiaryCastExpanded ? \"\\u25BC\" : \"\\u25B6\"}\n              </span>\n            )}\n            Tertiary Cast\n            {hasTertiaryCast && (\n              <span className=\"ctab-tertiary-count\">\n                {item.tertiaryCast.filter((e) => e.accepted).length}/{item.tertiaryCast.length}\n              </span>\n            )}\n          </span>\n          <button\n            onClick={(e) => {\n              e.stopPropagation();\n              onDetectTertiaryCast?.();\n            }}\n            disabled={!content}\n            className={`ctab-detect-btn ${content ? \"ctab-detect-btn-enabled\" : \"ctab-detect-btn-disabled\"}`}\n          >\n            {item.tertiaryCast ? \"Re-detect\" : \"Detect\"}\n          </button>\n        </div>\n        {tertiaryExpanded && (\n          <div className=\"ctab-tertiary-body\">\n            <div className=\"ctab-tertiary-chips\">\n              {item.tertiaryCast.map((entry) => {\n                const isHovered = hoveredTertiaryId === entry.entityId;\n                // Build context snippet from content if we have match positions\n                let contextSnippet = null;\n                if (isHovered && content && entry.matchStart != null && entry.matchEnd != null) {\n                  const radius = 80;\n                  const snippetStart = Math.max(0, entry.matchStart - radius);\n                  const snippetEnd = Math.min(content.length, entry.matchEnd + radius);\n                  const before =\n                    (snippetStart > 0 ? \"\\u2026\" : \"\") +\n                    content.slice(snippetStart, entry.matchStart);\n                  const matched = content.slice(entry.matchStart, entry.matchEnd);\n                  const after =\n                    content.slice(entry.matchEnd, snippetEnd) +\n                    (snippetEnd < content.length ? \"\\u2026\" : \"\");\n                  contextSnippet = { before, matched, after };\n                }\n                return (\n                  <span\n                    key={entry.entityId}\n                    className=\"ctab-tertiary-chip-wrapper\"\n                    onMouseEnter={() => handleTertiaryMouseEnter(entry.entityId)}\n                    onMouseLeave={handleTertiaryMouseLeave}\n                  >\n                    <span\n                      onClick={() => onToggleTertiaryCast?.(entry.entityId)}\n                      className={`ctab-tertiary-chip ${entry.accepted ? \"ctab-tertiary-chip-accepted\" : \"ctab-tertiary-chip-rejected\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {entry.name}\n                      <span className=\"ctab-tertiary-chip-kind\">{entry.kind}</span>\n                    </span>\n                    {isHovered && (\n                      <div className=\"ctab-tertiary-tooltip\">\n                        <div className=\"ctab-tooltip-header\">\n                          <span>{entry.kind}</span>\n                          <span>click to {entry.accepted ? \"reject\" : \"accept\"}</span>\n                        </div>\n                        {contextSnippet && (\n                          <div className=\"ctab-tooltip-context\">\n                            {contextSnippet.before}\n                            <span className=\"ctab-tooltip-match-highlight\">\n                              {contextSnippet.matched}\n                            </span>\n                            {contextSnippet.after}\n                          </div>\n                        )}\n                        {!contextSnippet && entry.matchedAs !== entry.name && (\n                          <div className=\"ctab-tooltip-matched-as\">\n                            matched as &ldquo;\n                            <span className=\"ctab-tooltip-matched-name\">{entry.matchedAs}</span>\n                            &rdquo;\n                          </div>\n                        )}\n                        <div className=\"ctab-tooltip-arrow\" />\n                      </div>\n                    )}\n                  </span>\n                );\n              })}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Version selector for assembly mode */}\n      {!isComplete && versions && versions.length > 1 && (\n        <div className=\"ctab-version-selector\">\n          <ChronicleVersionSelector\n            versions={versions}\n            selectedVersionId={selectedVersionId}\n            activeVersionId={activeVersionId}\n            compareToVersionId={compareToVersionId}\n            onSelectVersion={onSelectVersion}\n            onSelectCompareVersion={onSelectCompareVersion}\n            onSetActiveVersion={onSetActiveVersion}\n            onDeleteVersion={onDeleteVersion}\n            disabled={isGenerating}\n          />\n        </div>\n      )}\n\n      <AssembledContentViewer\n        content={content}\n        wordCount={wc}\n        onCopy={() => copyToClipboard(content)}\n        compareContent={!isComplete ? compareToVersion?.content : undefined}\n        compareLabel={!isComplete ? compareToVersion?.shortLabel : undefined}\n        onQuickCheck={onQuickCheck}\n        quickCheckRunning={quickCheckRunning}\n        quickCheckReport={item.quickCheckReport}\n        onShowQuickCheck={onShowQuickCheck}\n        onFindReplace={onFindReplace}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}", "type": "{ item: any; isComplete: any; versions: any; selectedVersion: any; compareToVersion: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; isGenerating: any; onQuickCheck: any; quickCheckRunning: any; onShowQuickCheck: any; onFindReplace: any; onDetectTertiaryCast: any; onToggleTertiaryCast: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx", "sourceCode": "export default function EnrichmentTab({\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}) {\n  const titleState = refinements?.title || {};\n  const summaryState = refinements?.summary || {};\n  const formatTimestamp = (ts) => new Date(ts).toLocaleString();\n\n  const titleDisabled = isGenerating || titleState.running;\n  const summaryDisabled = isGenerating || summaryState.running;\n\n  return (\n    <div>\n      <div className=\"enrtab-container\">\n        <div className=\"enrtab-heading\">Post-Publish Enrichment</div>\n        <div className=\"enrtab-sections\">\n          {/* Title */}\n          {onGenerateTitle && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Title</div>\n                <div className=\"enrtab-hint\">\n                  Two-phase title generation: extract fragments, then shape candidates.\n                </div>\n                {item.titleGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.titleGeneratedAt)}\n                  </div>\n                )}\n                {item.titleCandidates?.length > 0 && (\n                  <div className=\"enrtab-candidates\">\n                    <span className=\"enrtab-candidate-selected\">&#x25C6; {item.title}</span>\n                    <br />\n                    {item.titleCandidates.map((c, i) => (\n                      <span key={i}>\n                        <span className=\"enrtab-candidate-alt\">&#x25C7;</span> {c}\n                        {i < item.titleCandidates.length - 1 ? <br /> : null}\n                      </span>\n                    ))}\n                  </div>\n                )}\n                {item.titleFragments?.length > 0 && (\n                  <div className=\"enrtab-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateTitle}\n                disabled={titleDisabled}\n                className={`enrtab-button ${titleDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {titleState.running ? \"Generating...\" : \"Regenerate Title\"}\n              </button>\n            </div>\n          )}\n\n          {/* Summary */}\n          {onGenerateSummary && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Summary</div>\n                <div className=\"enrtab-hint\">\n                  Regenerate the short summary for chronicle listings.\n                </div>\n                {item.summaryGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.summaryGeneratedAt)}\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateSummary}\n                disabled={summaryDisabled}\n                className={`enrtab-button ${summaryDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {summaryState.running ? \"Generating...\" : \"Regenerate Summary\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onGenerateTitle: any; onGenerateSummary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx", "sourceCode": "export default function HistorianTab({\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}) {\n  return <div>\n      {/* Tone Assignment */}\n      {onSetAssignedTone && <div className=\"htab-section\">\n          <div className=\"htab-tone-header\">\n            <div className=\"htab-section-title\">Tone</div>\n            {item.toneRanking?.ranking && <div className=\"htab-tone-ranking\">\n                Ranked:{\" \"}\n                {item.toneRanking.ranking.map((tone, i) => {\n            const meta = TONE_META[tone];\n            const perTone = item.toneRanking.rationales?.[tone];\n            return <span key={i}\n            className=\"htab-tone-rank-item\"\n            title={perTone || item.toneRanking.rationale || undefined} style={{\n              // eslint-disable-next-line local/no-inline-styles -- dynamic opacity based on rank index\n              \"--htab-rank-opacity\": i === 0 ? 1 : i === 1 ? 0.6 : 0.4\n            }}>\n                      {i > 0 ? \" > \" : \"\"}\n                      {meta?.label || tone}\n                    </span>;\n          })}\n              </div>}\n            {onDetectTone && <button onClick={onDetectTone} disabled={isGenerating} className=\"htab-tone-detect-btn\" title=\"Run LLM tone detection for this chronicle\">\n                Detect\n              </button>}\n          </div>\n          <div className=\"htab-tone-buttons\">\n            {ANNOTATION_TONES.map(tone => {\n          const meta = TONE_META[tone];\n          const isAssigned = item.assignedTone === tone;\n          const perTone = item.toneRanking?.rationales?.[tone];\n          return <button key={tone} onClick={() => onSetAssignedTone(tone)} className={`htab-tone-btn ${isAssigned ? \"htab-tone-btn-active\" : \"\"}`} title={perTone || meta?.description || tone}>\n                  {meta?.symbol} {meta?.label || tone}\n                </button>;\n        })}\n          </div>\n        </div>}\n\n      {/* Historian Review */}\n      {onHistorianReview && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb12\">Annotate</div>\n          <div className=\"htab-annotate-row\">\n            {item.assignedTone && (() => {\n          const meta = TONE_META[item.assignedTone];\n          return <button onClick={() => onHistorianReview(item.assignedTone)} disabled={isGenerating || isHistorianActive} className=\"htab-annotate-btn\" title={`Run historian review with assigned tone: ${meta?.label || item.assignedTone}`}>\n                    <span className=\"htab-annotate-btn-symbol\">{meta?.symbol || \"?\"}</span>\n                    {item.historianNotes?.length > 0 ? \"Re-annotate\" : \"Annotate\"} (\n                    {meta?.label || item.assignedTone})\n                  </button>;\n        })()}\n            <HistorianToneSelector onSelect={tone => onHistorianReview(tone)} disabled={isGenerating || isHistorianActive} hasNotes={item.historianNotes?.length > 0} label={item.assignedTone ? \"Override\" : undefined} />\n            {!item.assignedTone && <div className=\"htab-annotate-hint\">\n                Select a tone to generate historian margin notes.\n              </div>}\n          </div>\n        </div>}\n\n      {/* Margin Notes */}\n      {item.historianNotes?.length > 0 && <div className=\"htab-margin-notes\">\n          <HistorianMarginNotes notes={item.historianNotes} sourceText={item.finalContent} onUpdateNote={onUpdateHistorianNote ? (noteId, updates) => onUpdateHistorianNote(\"chronicle\", item.chronicleId, noteId, updates) : undefined} />\n        </div>}\n\n      {/* Historian Prep */}\n      {onGeneratePrep && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb8\">Historian Prep</div>\n          <div className=\"htab-prep-description\">\n            Private reading notes in the historian&apos;s voice \u2014 observations and thematic threads for\n            era narrative input.\n          </div>\n          <div className=\"htab-prep-actions\">\n            <button onClick={onGeneratePrep} disabled={isGenerating} className=\"htab-prep-btn\" title={item.historianPrep ? \"Regenerate historian reading notes for this chronicle\" : \"Generate historian reading notes for this chronicle\"}>\n              {item.historianPrep ? \"Regenerate Prep Brief\" : \"Generate Prep Brief\"}\n            </button>\n            {item.historianPrepGeneratedAt && <span className=\"htab-prep-date\" title={`Generated ${new Date(item.historianPrepGeneratedAt).toLocaleString()}`}>\n                Generated {new Date(item.historianPrepGeneratedAt).toLocaleDateString()}\n              </span>}\n          </div>\n          {item.historianPrep && <div className=\"htab-prep-content\">{item.historianPrep}</div>}\n        </div>}\n\n      {/* Lore Backport */}\n      {onBackportLore && <div className=\"htab-section\">\n          <div className=\"htab-lore-title\">Lore Integration</div>\n          <BackportLoreButton item={item} onBackportLore={onBackportLore} isGenerating={isGenerating} />\n        </div>}\n\n      {!onHistorianReview && !onBackportLore && !onGeneratePrep && (item.historianNotes?.length ?? 0) <= 0 && <div className=\"htab-empty\">No historian tools available for this chronicle.</div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}", "type": "{ item: any; isGenerating: any; isHistorianActive: any; onHistorianReview: any; onSetAssignedTone: any; onDetectTone: any; onUpdateHistorianNote: any; onBackportLore: any; onGeneratePrep: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx", "sourceCode": "// ============================================================================\n// Images Tab\n// ============================================================================\n\nexport default function ImagesTab({\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}) {\n  // Compatibility analysis state\n  const [compatibilityAnalysis, setCompatibilityAnalysis] = useState(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [isApplying, setIsApplying] = useState(false);\n  const [imageRefSelections, setImageRefSelections] = useState([]);\n\n  // Cover image picker state\n  const [showCoverImagePicker, setShowCoverImagePicker] = useState(false);\n\n  // Check if image refs are for a different version\n  const hasVersionMismatch = useMemo(() => {\n    if (!item.imageRefs || !item.imageRefsTargetVersionId || !activeVersionId) return false;\n    return item.imageRefsTargetVersionId !== activeVersionId;\n  }, [item.imageRefs, item.imageRefsTargetVersionId, activeVersionId]);\n\n  // Handle analyze compatibility\n  const handleAnalyzeCompatibility = useCallback(() => {\n    if (!item.imageRefs || !versions || !activeVersionId || !item.imageRefsTargetVersionId) return;\n    setIsAnalyzing(true);\n\n    // Find the content for source and target versions\n    const sourceVersion = versions.find(v => v.id === item.imageRefsTargetVersionId);\n    const targetVersion = versions.find(v => v.id === activeVersionId);\n    const sourceContent = sourceVersion?.content || \"\";\n    const targetContent = targetVersion?.content || chronicleText || \"\";\n    if (!sourceContent || !targetContent) {\n      console.warn(\"[ImagesTab] Missing content for compatibility analysis\");\n      setIsAnalyzing(false);\n      return;\n    }\n    try {\n      const analysis = analyzeImageRefCompatibility(item.imageRefs, sourceContent, targetContent, item.imageRefsTargetVersionId, activeVersionId);\n      setCompatibilityAnalysis(analysis);\n      setImageRefSelections(createDefaultSelections(analysis));\n    } catch (err) {\n      console.error(\"[ImagesTab] Compatibility analysis failed:\", err);\n    }\n    setIsAnalyzing(false);\n  }, [item.imageRefs, item.imageRefsTargetVersionId, versions, activeVersionId, chronicleText]);\n\n  // Handle selection change\n  const handleSelectionChange = useCallback((refId, action) => {\n    setImageRefSelections(prev => prev.map(s => s.refId === refId ? {\n      ...s,\n      action\n    } : s));\n  }, []);\n\n  // Handle apply selections\n  const handleApplySelections = useCallback(async () => {\n    if (!onApplyImageRefSelections || !activeVersionId || imageRefSelections.length === 0) return;\n    setIsApplying(true);\n    try {\n      await onApplyImageRefSelections(imageRefSelections, activeVersionId);\n      // Clear analysis state after successful apply\n      setCompatibilityAnalysis(null);\n      setImageRefSelections([]);\n    } catch (err) {\n      console.error(\"[ImagesTab] Failed to apply selections:\", err);\n    }\n    setIsApplying(false);\n  }, [onApplyImageRefSelections, activeVersionId, imageRefSelections]);\n  return <div>\n      {/* Cover Image */}\n      {(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-cover-section\">\n          <div className=\"itab-cover-heading\">Cover Image</div>\n          <div className=\"itab-cover-layout\">\n            <div className=\"itab-cover-info\">\n              <div className=\"itab-cover-desc\">\n                Generate a montage-style cover image for this chronicle.\n              </div>\n              {!item.coverImage && <div className=\"itab-cover-status itab-cover-status-default\">Not run yet</div>}\n              {item.coverImage && item.coverImage.status === \"pending\" && <div className=\"itab-cover-status itab-cover-status-pending\">\n                  Scene ready - click Generate Image to create\n                </div>}\n              {item.coverImage && item.coverImage.status === \"generating\" && <div className=\"itab-cover-status itab-cover-status-generating\">\n                  Generating image...\n                </div>}\n              {item.coverImage && item.coverImage.status === \"complete\" && <div className=\"itab-cover-status itab-cover-status-complete\">Complete</div>}\n              {item.coverImage && item.coverImage.status === \"failed\" && <div className=\"itab-cover-status itab-cover-status-failed\">\n                  Failed{item.coverImage.error ? `: ${item.coverImage.error}` : \"\"}\n                </div>}\n              {item.coverImage?.sceneDescription && <div className=\"itab-scene-desc\">{item.coverImage.sceneDescription}</div>}\n              <CoverImagePreview imageId={item.coverImage?.generatedImageId} onImageClick={onImageClick} />\n            </div>\n            <div className=\"itab-cover-actions\">\n              <div className=\"itab-cover-btn-row\">\n                {onGenerateCoverImageScene && <button onClick={onGenerateCoverImageScene} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                    {item.coverImage ? \"Regen Scene\" : \"Gen Scene\"}\n                  </button>}\n                {onGenerateCoverImage && item.coverImage && (item.coverImage.status === \"pending\" || item.coverImage.status === \"complete\" || item.coverImage.status === \"failed\") && <button onClick={onGenerateCoverImage} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                      {item.coverImage.status === \"complete\" ? \"Regen Image\" : \"Gen Image\"}\n                    </button>}\n                {onSelectExistingCoverImage && item.coverImage && !isGenerating && <button onClick={() => setShowCoverImagePicker(true)} className=\"itab-cover-btn itab-cover-btn-enabled\">\n                    Select Existing\n                  </button>}\n              </div>\n            </div>\n          </div>\n        </div>}\n\n      {/* Cover Image Picker */}\n      {item.projectId && <ChronicleImagePicker isOpen={showCoverImagePicker} onClose={() => setShowCoverImagePicker(false)} onSelect={imageId => {\n      if (onSelectExistingCoverImage) {\n        onSelectExistingCoverImage(imageId);\n      }\n      setShowCoverImagePicker(false);\n    }} projectId={item.projectId} chronicleId={item.chronicleId} currentImageId={item.coverImage?.generatedImageId} />}\n\n      {/* Version Mismatch Warning */}\n      {hasVersionMismatch && item.imageRefs && <ImageRefVersionWarning item={item} versions={versions} activeVersionId={activeVersionId} chronicleText={chronicleText} onAnalyzeCompatibility={handleAnalyzeCompatibility} isAnalyzing={isAnalyzing} />}\n\n      {/* Compatibility Analysis Results */}\n      {compatibilityAnalysis && item.imageRefs && <ImageRefCompatibilityResults analysis={compatibilityAnalysis} imageRefs={item.imageRefs} entityMap={entityMap} onSelectionChange={handleSelectionChange} selections={imageRefSelections} onApply={handleApplySelections} isApplying={isApplying} />}\n\n      {/* Image Anchors */}\n      {item.imageRefs && entityMap && <div>\n          <div className=\"itab-anchors-heading\">\n            Image Anchors\n            <span className=\"itab-anchors-count\">({item.imageRefs.refs?.length || 0} placed)</span>\n          </div>\n          <ChronicleImagePanel imageRefs={item.imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onRegenerateDescription={onRegenerateDescription} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} onSelectExistingImage={onSelectExistingImage} projectId={item.projectId} chronicleId={item.chronicleId} chronicleText={chronicleText} isGenerating={isGenerating} styleLibrary={styleLibrary} styleSelection={styleSelection} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={item.title || item.name} imageSize={imageSize} imageQuality={imageQuality} imageModel={imageModel} imageGenSettings={imageGenSettings} onOpenImageSettings={onOpenImageSettings} />\n        </div>}\n\n      {!item.imageRefs && !(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-empty\">\n          No images generated yet. Use the Pipeline tab to generate image refs and cover images.\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}", "type": "{ item: any; isGenerating: any; entityMap: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: any; onUpdateChronicleImageSize: any; onUpdateChronicleImageJustification: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; imageSize: any; imageQuality: any; imageModel: any; imageGenSettings: any; ...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx", "sourceCode": "// ============================================================================\n// Pipeline Tab\n// ============================================================================\n\nexport default function PipelineTab({\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}) {\n  const summaryState = refinements?.summary || {};\n  const titleState = refinements?.title || {};\n  const imageRefsState = refinements?.imageRefs || {};\n\n  const completedCount = [\n    summaryState.generatedAt,\n    titleState.generatedAt,\n    item.coverImage?.status === \"complete\",\n    imageRefsState.generatedAt,\n    item.cohesionReport,\n  ].filter(Boolean).length;\n\n  return (\n    <div>\n      {/* Refinement Checklist */}\n      <div className=\"pt-checklist\">\n        <div className=\"pt-checklist-header\">\n          <span>Refinements</span>\n          <span className=\"pt-checklist-count\">{completedCount}/5 complete</span>\n        </div>\n        <div className=\"pt-checklist-items\">\n          <RefinementRow\n            label=\"Summary\"\n            description=\"Generate a short summary for chronicle listings.\"\n            state={summaryState}\n            indicator={summaryIndicator}\n            onAction={onGenerateSummary}\n            isGenerating={isGenerating}\n          />\n\n          {/* Title - with candidates display */}\n          <div className=\"pt-refrow\">\n            <div className=\"pt-refrow-content\">\n              <div className=\"pt-refrow-title\">\n                <span\n                  className={`pt-refrow-checkbox ${titleState.generatedAt ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                >\n                  {titleState.generatedAt ? \"\\u2611\" : \"\\u2610\"}\n                </span>\n                Title\n              </div>\n              <div className=\"pt-refrow-description\">\n                Generate an evocative title using single-pass candidate generation.\n              </div>\n              {titleState.generatedAt && (\n                <div className=\"pt-refrow-meta\">\n                  Done - {new Date(titleState.generatedAt).toLocaleString()}\n                  {titleState.model ? ` - ${titleState.model}` : \"\"}\n                </div>\n              )}\n              {item.titleCandidates?.length > 0 && (\n                <div className=\"pt-title-candidates\">\n                  <span className=\"pt-title-selected\">&#x25C6; {item.title}</span>\n                  <br />\n                  {item.titleCandidates.map((c, i) => (\n                    <span key={i}>\n                      <span className=\"pt-title-candidate-icon\">&#x25C7;</span> {c}\n                      {i < item.titleCandidates.length - 1 ? <br /> : null}\n                    </span>\n                  ))}\n                </div>\n              )}\n              {item.titleFragments?.length > 0 && (\n                <div className=\"pt-title-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n              )}\n              {!titleState.generatedAt && !titleState.running && (\n                <div className=\"pt-refrow-meta\">Not run yet</div>\n              )}\n              {titleState.running && <div className=\"pt-refrow-meta\">Running...</div>}\n            </div>\n            {onGenerateTitle && (\n              <button\n                onClick={onGenerateTitle}\n                disabled={isGenerating || titleState.running}\n                className={`pt-refrow-btn ${isGenerating || titleState.running ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {titleState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>\n            )}\n          </div>\n\n          <CoverImageControls\n            item={item}\n            onGenerateCoverImageScene={onGenerateCoverImageScene}\n            onGenerateCoverImage={onGenerateCoverImage}\n            isGenerating={isGenerating}\n            onImageClick={onImageClick}\n          />\n\n          <RefinementRow\n            label=\"Image Refs\"\n            description=\"Generate image placement suggestions for this chronicle.\"\n            state={imageRefsState}\n            indicator={imageRefsIndicator}\n            onAction={onGenerateImageRefs}\n            isGenerating={isGenerating}\n          />\n\n          {onValidate && (\n            <div className=\"pt-refrow\">\n              <div>\n                <div className=\"pt-refrow-title\">\n                  <span\n                    className={`pt-refrow-checkbox ${item.cohesionReport ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                  >\n                    {item.cohesionReport ? \"\\u2611\" : \"\\u2610\"}\n                  </span>\n                  Validate\n                </div>\n                <div className=\"pt-refrow-description\">\n                  Run quality validation to check narrative coherence.\n                </div>\n                {item.cohesionReport && (\n                  <div className=\"pt-refrow-meta\">\n                    Done - Score: {item.cohesionReport.overallScore}/100\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onValidate}\n                disabled={isGenerating}\n                className={`pt-refrow-btn ${isGenerating ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {item.cohesionReport ? \"Revalidate\" : \"Validate\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onGenerateImageRefs: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onRegenerateWithSampling: any; entityMap: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; summaryIndicator: any; imageRefsIndicator: any; imageRefsTargetContent: any; imageSize: any; imageQuality: any; imageModel: any; imageG...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx", "sourceCode": "// ============================================================================\n// Reference Tab\n// ============================================================================\n\nexport default function ReferenceTab({\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}) {\n  return (\n    <div>\n      {item.perspectiveSynthesis && (\n        <PerspectiveSynthesisViewer synthesis={item.perspectiveSynthesis} />\n      )}\n\n      <ExpandableSeedSection seed={seedData} defaultExpanded={false} />\n\n      {item.factCoverageReport && (\n        <>\n          <FactCoverageGrid report={item.factCoverageReport} />\n          <FactCoverageViewer\n            report={item.factCoverageReport}\n            generatedAt={item.factCoverageReportGeneratedAt}\n          />\n        </>\n      )}\n\n      <TemporalContextEditor\n        item={item}\n        eras={eras}\n        events={events}\n        entities={entities}\n        onUpdateTemporalContext={onUpdateTemporalContext}\n        onTemporalCheck={onTemporalCheck}\n        temporalCheckRunning={temporalCheckRunning}\n        isGenerating={isGenerating}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}", "type": "{ item: any; eras: any; events: any; entities: any; isGenerating: any; onUpdateTemporalContext: any; onTemporalCheck: any; temporalCheckRunning: any; seedData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx", "sourceCode": "export default function VersionsTab({\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}) {\n  const [editingCombineInstructions, setEditingCombineInstructions] = useState(false);\n  const [combineInstructionsDraft, setCombineInstructionsDraft] = useState(\"\");\n\n  // Get current LLM settings for display\n  const llmConfigDisplay = useMemo(() => {\n    const perspectiveConfig = getCallConfig(\"perspective.synthesis\");\n    const generationConfig = getCallConfig(\"chronicle.generation\");\n    return {\n      perspective: formatLLMConfig(perspectiveConfig),\n      generation: formatLLMConfig(generationConfig)\n    };\n  }, []);\n  return <div>\n      {/* Version Selector */}\n      <div className=\"vtab-selector-wrap\">\n        <ChronicleVersionSelector versions={versions} selectedVersionId={selectedVersionId} activeVersionId={activeVersionId} compareToVersionId={compareToVersionId} onSelectVersion={onSelectVersion} onSelectCompareVersion={onSelectCompareVersion} onSetActiveVersion={onSetActiveVersion} onDeleteVersion={onDeleteVersion} disabled={isGenerating} />\n      </div>\n\n      {/* Compare & Combine */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">\n          Version Analysis\n          <span className=\"vtab-section-title-count\">\n            ({versions.length} version{versions.length !== 1 ? \"s\" : \"\"} available)\n          </span>\n        </div>\n        <div className=\"vtab-button-row\">\n          <button onClick={onCompareVersions} disabled={isGenerating || compareRunning || combineRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {compareRunning ? \"Comparing...\" : \"Compare Versions\"}\n          </button>\n          <button onClick={onCombineVersions} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {combineRunning ? \"Combining...\" : \"Combine Versions\"}\n          </button>\n          <button onClick={onCopyEdit} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || !item.assembledContent} title=\"Polish pass \u2014 smooths voice, trims to word count target, tightens prose. Produces a new version.\" className=\"vtab-action-btn\">\n            {copyEditRunning ? \"Copy-editing...\" : \"Copy-edit\"}\n          </button>\n          <button onClick={() => {\n          const list = item.generationHistory || [];\n          const byId = new Map();\n          for (const v of list) {\n            const arr = byId.get(v.versionId) || [];\n            arr.push(v);\n            byId.set(v.versionId, arr);\n          }\n          const duplicates = Array.from(byId.entries()).filter(([, arr]) => arr.length > 1).map(([id, arr]) => ({\n            id,\n            count: arr.length\n          }));\n          console.warn(\"[Chronicle][Debug] Version dump\", {\n            chronicleId: item.chronicleId,\n            activeVersionId: item.activeVersionId,\n            acceptedVersionId: item.acceptedVersionId,\n            assembledAt: item.assembledAt,\n            assembledContentLength: item.assembledContent?.length || 0,\n            versionCount: list.length,\n            duplicates,\n            versions: list.map((v, i) => ({\n              index: i,\n              versionId: v.versionId,\n              generatedAt: v.generatedAt,\n              step: v.step,\n              sampling: v.sampling,\n              model: v.model,\n              wordCount: v.wordCount,\n              contentLength: v.content?.length || 0\n            }))\n          });\n        }} disabled={isGenerating} title=\"Dump generationHistory to console\" className=\"vtab-action-btn\">\n            Dump Versions\n          </button>\n        </div>\n        <div className=\"vtab-hint-text\">\n          {versions.length < 2 ? \"Create a new version first to enable comparison and combination.\" : \"Compare produces an analysis report. Combine synthesizes all drafts into a new version. Copy-edit polishes the active version.\"}\n          {item.comparisonReport && !item.combineInstructions && <span className=\"vtab-warning-text\">\n              {\" \"}\n              Combine instructions missing \u2014 combine will use generic criteria.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(\"\");\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Set manually\n                </button>}\n            </span>}\n          {item.combineInstructions && <span className=\"vtab-success-text\">\n              {\" \"}\n              Combine instructions ready.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(item.combineInstructions);\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Edit\n                </button>}\n            </span>}\n        </div>\n\n        {/* Combine Instructions Editor */}\n        {editingCombineInstructions && <div className=\"vtab-instructions-editor\">\n            <textarea value={combineInstructionsDraft} onChange={e => setCombineInstructionsDraft(e.target.value)} placeholder=\"Enter combine instructions \u2014 editorial direction for how to merge versions...\" className=\"vtab-textarea\" />\n            <div className=\"vtab-editor-actions\">\n              <button onClick={() => {\n            onUpdateCombineInstructions(combineInstructionsDraft.trim());\n            setEditingCombineInstructions(false);\n          }} disabled={!combineInstructionsDraft.trim()} className=\"vtab-save-btn\"\n          // eslint-disable-next-line local/no-inline-styles -- dynamic save button appearance from draft state\n          style={{\n            \"--vtab-save-bg\": combineInstructionsDraft.trim() ? \"var(--accent-color, #6366f1)\" : \"var(--bg-tertiary)\",\n            \"--vtab-save-color\": combineInstructionsDraft.trim() ? \"#fff\" : \"var(--text-muted)\",\n            \"--vtab-save-cursor\": combineInstructionsDraft.trim() ? \"pointer\" : \"not-allowed\"\n          }}>\n                Save\n              </button>\n              <button onClick={() => setEditingCombineInstructions(false)} className=\"vtab-cancel-btn\">\n                Cancel\n              </button>\n              {item.combineInstructions && <button onClick={() => {\n            onUpdateCombineInstructions(\"\");\n            setEditingCombineInstructions(false);\n          }} className=\"vtab-clear-btn\">\n                  Clear\n                </button>}\n            </div>\n          </div>}\n      </div>\n\n      {/* Create New Version */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">Create New Version</div>\n\n        <div className=\"vtab-button-row-mb\">\n          {/* Regenerate with existing perspective */}\n          <button onClick={() => onRegenerateWithSampling?.()} disabled={isGenerating || compareRunning || combineRunning || !item.generationSystemPrompt || !item.generationUserPrompt} title=\"Reuse stored prompts with current LLM sampling settings (fast, same perspective)\" className=\"vtab-regen-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with existing perspective\"}\n          </button>\n\n          {/* Regenerate with new perspective */}\n          <button onClick={() => onRegenerateFull?.()} disabled={isGenerating || compareRunning || combineRunning || !onRegenerateFull} title=\"Run fresh perspective synthesis with current world facts & tone (slower, may differ significantly)\" className=\"vtab-regen-primary-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with new perspective\"}\n          </button>\n\n          {/* Regenerate with creative freedom (story format only) */}\n          {onRegenerateCreative && <button onClick={() => onRegenerateCreative?.()} disabled={isGenerating || compareRunning || combineRunning} title=\"Same PS, different generation prompt \u2014 neutral framing, softened structure, no craft posture. Reuses existing perspective synthesis.\" className=\"vtab-regen-creative-btn\">\n              {isGenerating ? \"Generating...\" : \"Creative freedom\"}\n            </button>}\n        </div>\n\n        <div className=\"vtab-llm-config\">\n          <span className=\"vtab-llm-config-label\">LLM Config:</span>{\" \"}\n          <span title=\"perspective.synthesis\">perspective: {llmConfigDisplay.perspective}</span>\n          {\" \u00b7 \"}\n          <span title=\"chronicle.generation\">generation: {llmConfigDisplay.generation}</span>\n          {(!item.generationSystemPrompt || !item.generationUserPrompt) && <span className=\"vtab-warning-inline\">\n              Existing perspective unavailable (legacy chronicle).\n            </span>}\n          {!onRegenerateFull && <span className=\"vtab-warning-inline\">\n              New perspective requires toneFragments and canonFactsWithMetadata.\n            </span>}\n        </div>\n      </div>\n\n      {/* Comparison Report */}\n      {item.comparisonReport && <div className=\"vtab-report-section\">\n          <div className=\"vtab-report-header\">\n            <span className=\"vtab-report-title\">Comparison Report</span>\n            <div className=\"vtab-report-actions\">\n              {item.comparisonReportGeneratedAt && <span className=\"vtab-report-timestamp\">\n                  {new Date(item.comparisonReportGeneratedAt).toLocaleString()}\n                </span>}\n              <button onClick={() => {\n            const blob = new Blob([item.comparisonReport], {\n              type: \"text/markdown\"\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = `comparison-report-${item.chronicleId.slice(0, 20)}-${Date.now()}.md`;\n            a.click();\n            URL.revokeObjectURL(url);\n          }} className=\"vtab-export-btn\">\n                Export\n              </button>\n            </div>\n          </div>\n          <div className=\"vtab-report-body\">{item.comparisonReport}</div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}", "type": "{ item: any; versions: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; isGenerating: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; onCompareVersions: any; onCombineVersions: any; onRegenerateFull: any; onRegenerateCreative: any; onRegenerateWithSampling: any; onUpdateCombineInstructions: any; onCopyEdit: any; compareRunning: any; combineRunning: any; copyEditRunning: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx", "sourceCode": "export default function WorkspaceHeader({\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}) {\n  const [menuOpen, setMenuOpen] = useState(false);\n  const menuRef = useRef(null);\n\n  useEffect(() => {\n    if (!menuOpen) return;\n    const handleClick = (e) => {\n      if (menuRef.current && !menuRef.current.contains(e.target)) setMenuOpen(false);\n    };\n    document.addEventListener(\"mousedown\", handleClick);\n    return () => document.removeEventListener(\"mousedown\", handleClick);\n  }, [menuOpen]);\n\n  return (\n    <div className=\"chronicle-workspace-header\">\n      <div className=\"chronicle-workspace-header-info\">\n        <h3>{item.title || item.name || \"Untitled Chronicle\"}</h3>\n        <div className=\"chronicle-workspace-header-stats\">\n          {wordCount.toLocaleString()} words\n          {item.selectionSummary && (\n            <span>\n              {\" \"}\n              &middot; {item.selectionSummary.entityCount} entities,{\" \"}\n              {item.selectionSummary.eventCount} events\n            </span>\n          )}\n          {item.focusType && (\n            <span> &middot; {item.focusType === \"single\" ? \"Single focus\" : \"Ensemble\"}</span>\n          )}\n          <span> &middot; sampling {item.generationSampling ?? \"unspecified\"}</span>\n        </div>\n      </div>\n      <div className=\"chronicle-workspace-header-actions\">\n        {!isComplete && onAccept && (\n          <button onClick={onAccept} disabled={isGenerating} className=\"wsh-btn-accept\">\n            Accept &#x2713;\n          </button>\n        )}\n        {isComplete && onUnpublish && (\n          <button\n            onClick={onUnpublish}\n            className=\"wsh-btn-unpublish\"\n            title=\"Revert to assembly review without discarding content\"\n          >\n            Unpublish\n          </button>\n        )}\n        <button onClick={onRegenerate} disabled={isGenerating} className=\"wsh-btn-regenerate\">\n          &#x27F3; {isComplete ? \"Restart\" : \"Regenerate\"}\n        </button>\n        <div className=\"workspace-overflow-menu\" ref={menuRef}>\n          <button onClick={() => setMenuOpen(!menuOpen)} className=\"wsh-btn-overflow\">\n            &hellip;\n          </button>\n          {menuOpen && (\n            <div className=\"workspace-overflow-dropdown\">\n              {onExport && (\n                <button\n                  className=\"workspace-overflow-item\"\n                  onClick={() => {\n                    onExport();\n                    setMenuOpen(false);\n                  }}\n                  title=\"Export chronicle with full generation context as JSON\"\n                >\n                  Export\n                </button>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}", "type": "{ item: any; wordCount: any; isGenerating: any; isComplete: any; onAccept: any; onRegenerate: any; onExport: any; onUnpublish: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx", "sourceCode": "export default function WorkspaceTabBar({ tabs, activeTab, onTabChange }) {\n  return (\n    <div className=\"workspace-subtabs\">\n      {tabs.map((tab) => (\n        <button\n          key={tab.id}\n          className={\n            \"workspace-subtab\" +\n            (activeTab === tab.id ? \" active\" : \"\") +\n            (tab.align === \"right\" ? \" right-aligned\" : \"\")\n          }\n          onClick={() => onTabChange(tab.id)}\n        >\n          {tab.label}\n          {tab.indicator ? ` ${tab.indicator}` : \"\"}\n        </button>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ tabs, activeTab, onTabChange }", "type": "{ tabs: any; activeTab: any; onTabChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx", "sourceCode": "// =============================================================================\n// Main Component (wraps with provider)\n// =============================================================================\n\nexport default function ChronicleWizard(props: Readonly<ChronicleWizardProps>) {\n  if (!props.isOpen) return null;\n\n  return (\n    <WizardProvider\n      entityKinds={props.entityKinds}\n      eras={props.eras ?? []}\n      simulationRunId={props.simulationRunId}\n    >\n      <InnerWizard {...props} />\n    </WizardProvider>\n  );\n}", "parameters": [{"name": "props", "type": "Readonly<ChronicleWizardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx", "sourceCode": "export default function ContentPalette({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}: Readonly<ContentPaletteProps>) {\n  const [filter, setFilter] = useState(\"\");\n  const [typeFilter, setTypeFilter] = useState<TypeFilter>(\"all\");\n  const [sortBy, setSortBy] = useState<SortBy>(\"type\");\n\n  const allItems = useMemo<PaletteItem[]>(() => {\n    const items: PaletteItem[] = [];\n\n    for (const e of entities) {\n      if (!e.description || usedIds.has(e.id) || e.kind === \"era\") continue;\n      items.push({\n        type: \"entity\",\n        contentId: e.id,\n        name: e.name,\n        subtitle: `${e.kind}${e.subtype ? \" / \" + e.subtype : \"\"}`,\n        wordCount: countWords(e.description || \"\"),\n      });\n    }\n\n    for (const c of chronicles) {\n      if (c.status !== \"complete\" && c.status !== \"assembly_ready\") continue;\n      if (usedIds.has(c.chronicleId)) continue;\n      const content = c.finalContent || c.assembledContent || \"\";\n      items.push({\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n        name: c.title || \"Untitled Chronicle\",\n        subtitle: `${c.format} \\u2022 ${c.focusType}`,\n        wordCount: countWords(content),\n      });\n    }\n\n    for (const n of eraNarratives) {\n      if (n.status !== \"complete\" && n.status !== \"step_complete\") continue;\n      if (usedIds.has(n.narrativeId)) continue;\n      const { content } = resolveActiveContent(n);\n      items.push({\n        type: \"era_narrative\",\n        contentId: n.narrativeId,\n        name: n.eraName,\n        subtitle: `${n.tone} \\u2022 era narrative`,\n        wordCount: countWords(content || \"\"),\n      });\n    }\n\n    for (const p of staticPages) {\n      if (p.status !== \"published\" || usedIds.has(p.pageId)) continue;\n      items.push({\n        type: \"static_page\",\n        contentId: p.pageId,\n        name: p.title,\n        subtitle: `${p.wordCount.toLocaleString()} words`,\n        wordCount: p.wordCount,\n      });\n    }\n\n    return items;\n  }, [entities, chronicles, eraNarratives, staticPages, usedIds]);\n\n  const filteredItems = useMemo(() => {\n    let items = allItems;\n\n    // Type filter\n    if (typeFilter !== \"all\") {\n      items = items.filter((i) => i.type === typeFilter);\n    }\n\n    // Text filter\n    if (filter) {\n      const lower = filter.toLowerCase();\n      items = items.filter(\n        (i) => i.name.toLowerCase().includes(lower) || i.subtitle.toLowerCase().includes(lower)\n      );\n    }\n\n    // Sort\n    items = [...items].sort((a, b) => {\n      if (sortBy === \"name\") return a.name.localeCompare(b.name);\n      if (sortBy === \"words\") return b.wordCount - a.wordCount;\n      // 'type': group by type, then name\n      if (a.type !== b.type) return a.type.localeCompare(b.type);\n      return a.name.localeCompare(b.name);\n    });\n\n    return items;\n  }, [allItems, typeFilter, filter, sortBy]);\n\n  const handleClick = (item: PaletteItem) => {\n    if (!selectedFolderId) return;\n    onAddContent({ type: item.type, contentId: item.contentId, name: item.name });\n  };\n\n  return (\n    <div className=\"preprint-palette\">\n      <div className=\"preprint-palette-controls\">\n        <input\n          type=\"text\"\n          className=\"preprint-input preprint-palette-search\"\n          placeholder=\"Search content...\"\n          value={filter}\n          onChange={(e) => setFilter(e.target.value)}\n        />\n        <div className=\"preprint-palette-filters\">\n          {TYPE_FILTER_LABELS.map((tf) => (\n            <button\n              key={tf.value}\n              className={`preprint-palette-chip ${typeFilter === tf.value ? \"active\" : \"\"}`}\n              onClick={() => setTypeFilter(tf.value)}\n            >\n              {tf.label}\n            </button>\n          ))}\n          <select\n            className=\"preprint-palette-sort\"\n            value={sortBy}\n            onChange={(e) => setSortBy(e.target.value as SortBy)}\n            title=\"Sort order\"\n          >\n            {SORT_OPTIONS.map((s) => (\n              <option key={s.value} value={s.value}>\n                {s.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n\n      <div className=\"preprint-palette-list\">\n        {filteredItems.length === 0 && (\n          <div className=\"preprint-palette-empty\">\n            {allItems.length === 0\n              ? \"All content has been placed in the tree.\"\n              : \"No items match the current filters.\"}\n          </div>\n        )}\n        {filteredItems.map((item) => (\n          <PaletteItemRow\n            key={`${item.type}-${item.contentId}`}\n            item={item}\n            disabled={!selectedFolderId}\n            onClick={() => handleClick(item)}\n          />\n        ))}\n      </div>\n\n      <div className=\"preprint-palette-footer\">\n        {filteredItems.length} of {allItems.length} items\n        {!selectedFolderId && allItems.length > 0 && (\n          <span className=\"preprint-palette-hint\"> \u2014 select a folder to add</span>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}", "type": "Readonly<ContentPaletteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx", "sourceCode": "// \u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ContentTreeView({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}: Readonly<ContentTreeViewProps>) {\n  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);\n  const [newFolderParent, setNewFolderParent] = useState<string | null>(null);\n  const [newFolderName, setNewFolderName] = useState(\"\");\n  const treeRef = useRef<any>(null);\n\n  // Build set of used content IDs\n  const usedIds = useMemo(\n    () => (treeState ? getAllContentIds(treeState) : new Set<string>()),\n    [treeState]\n  );\n\n  // Enrich tree nodes with metadata for display\n  const enrichedData = useMemo<TreeNodeData[]>(() => {\n    if (!treeState) return [];\n\n    const entityMap = new Map(entities.map((e) => [e.id, e]));\n    const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n    const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n    const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n\n    function enrich(nodes: ContentTreeNode[]): TreeNodeData[] {\n      return nodes.map((node) => {\n        const enriched: TreeNodeData = { ...node };\n\n        if (node.type === \"entity\" && node.contentId) {\n          const ent = entityMap.get(node.contentId);\n          if (ent) {\n            enriched.meta = {\n              wordCount: countWords(ent.description || \"\"),\n              imageCount: ent.enrichment?.image?.imageId ? 1 : 0,\n              hasDescription: !!ent.description,\n              hasImage: !!ent.enrichment?.image?.imageId,\n            };\n          }\n        } else if (node.type === \"chronicle\" && node.contentId) {\n          const chr = chronicleMap.get(node.contentId);\n          if (chr) {\n            const content = chr.finalContent || chr.assembledContent || \"\";\n            const imgCount = countCompletedPromptImages(chr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content),\n              imageCount: imgCount + (chr.coverImage?.generatedImageId ? 1 : 0),\n              hasDescription: !!content,\n              hasImage: imgCount > 0,\n            };\n          }\n        } else if (node.type === \"static_page\" && node.contentId) {\n          const page = pageMap.get(node.contentId);\n          if (page) {\n            enriched.meta = {\n              wordCount: page.wordCount,\n              imageCount: 0,\n              hasDescription: !!page.content,\n              hasImage: true, // Pages don't require images\n            };\n          }\n        } else if (node.type === \"era_narrative\" && node.contentId) {\n          const narr = narrativeMap.get(node.contentId);\n          if (narr) {\n            const { content } = resolveActiveContent(narr);\n            const imgCount =\n              (narr.coverImage?.generatedImageId ? 1 : 0) +\n              countNarrativeImageRefs(narr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content || \"\"),\n              imageCount: imgCount,\n              hasDescription: !!content,\n              hasImage: !!narr.coverImage?.generatedImageId,\n            };\n          }\n        }\n\n        if (node.children) {\n          enriched.children = enrich(node.children);\n        }\n\n        return enriched;\n      });\n    }\n\n    return enrich(toArboristData(treeState.nodes));\n  }, [treeState, entities, chronicles, staticPages, eraNarratives]);\n\n  // Handlers\n  const handleCreateScaffold = useCallback(() => {\n    const scaffold = createScaffold(projectId, simulationRunId);\n    onTreeChange(scaffold);\n  }, [projectId, simulationRunId, onTreeChange]);\n\n  const handleMove: MoveHandler<TreeNodeData> = useCallback(\n    ({ dragIds, parentId, index }) => {\n      if (!treeState || dragIds.length === 0) return;\n      const api = treeRef.current;\n      if (!api) return;\n\n      let newState = treeState;\n      for (const dragId of dragIds) {\n        const node = findNode(newState, dragId);\n        if (!node) continue;\n        const { nodes: withoutNode } = {\n          ...newState,\n          nodes: removeNodeFromTree(newState.nodes, dragId),\n        };\n        if (parentId) {\n          newState = {\n            ...newState,\n            nodes: insertNodeInTree(withoutNode, parentId, { ...node }, index),\n            updatedAt: Date.now(),\n          };\n        } else {\n          const rootNodes = [...withoutNode];\n          rootNodes.splice(index, 0, { ...node });\n          newState = { ...newState, nodes: rootNodes, updatedAt: Date.now() };\n        }\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleRename: RenameHandler<TreeNodeData> = useCallback(\n    ({ id, name }) => {\n      if (!treeState) return;\n      onTreeChange(renameNode(treeState, id, name));\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleDelete: DeleteHandler<TreeNodeData> = useCallback(\n    ({ ids }) => {\n      if (!treeState) return;\n      let newState = treeState;\n      for (const id of ids) {\n        newState = deleteNode(newState, id);\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleAddFolder = useCallback(() => {\n    if (!treeState || !newFolderParent || !newFolderName.trim()) return;\n    onTreeChange(addFolder(treeState, newFolderParent, newFolderName.trim()));\n    setNewFolderName(\"\");\n    setNewFolderParent(null);\n  }, [treeState, newFolderParent, newFolderName, onTreeChange]);\n\n  const handleAddContent = useCallback(\n    (item: { type: ContentNodeType; contentId: string; name: string }) => {\n      if (!treeState || !selectedNodeId) return;\n      const target = findNode(treeState, selectedNodeId);\n      if (!target || target.type !== \"folder\") return;\n      onTreeChange(addContentItem(treeState, selectedNodeId, item));\n    },\n    [treeState, selectedNodeId, onTreeChange]\n  );\n\n  // Auto-populate\n  const handleAutoPopulate = useCallback(() => {\n    if (!treeState) return;\n\n    const bodyNode = treeState.nodes.find((n) => n.name === \"Body\" && n.type === \"folder\");\n    const backMatterNode = treeState.nodes.find(\n      (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n    );\n    const hasExistingContent =\n      (bodyNode?.children?.length ?? 0) > 0 ||\n      (backMatterNode?.children?.some((c) => c.name === \"Encyclopedia\") ?? false);\n\n    if (hasExistingContent) {\n      if (\n        !confirm(\n          \"Body and Back Matter already have content. Replace with auto-populated structure?\"\n        )\n      )\n        return;\n    }\n\n    const chronicleInput = chronicles\n      .filter((c) => c.status === \"complete\" || c.status === \"assembly_ready\")\n      .map((c) => ({\n        chronicleId: c.chronicleId,\n        title: c.title || \"Untitled Chronicle\",\n        status: c.status,\n        focalEraId: c.temporalContext?.focalEra?.id || (c as any).focalEra?.id,\n        focalEraName: c.temporalContext?.focalEra?.name || (c as any).focalEra?.name,\n        eraYear: c.eraYear,\n      }));\n\n    const narrativeInput = eraNarratives.map((n) => ({\n      narrativeId: n.narrativeId,\n      eraId: n.eraId,\n      eraName: n.eraName,\n      status: n.status,\n    }));\n\n    const entityInput = entities.map((e) => ({\n      id: e.id,\n      name: e.name,\n      kind: e.kind,\n      subtype: e.subtype,\n      culture: e.culture,\n      description: e.description,\n    }));\n\n    const pageInput = staticPages.map((p) => ({\n      pageId: p.pageId,\n      title: p.title,\n      status: p.status,\n    }));\n\n    const newTree = autoPopulateBody(treeState, {\n      chronicles: chronicleInput,\n      eraNarratives: narrativeInput,\n      entities: entityInput,\n      staticPages: pageInput,\n      eraOrder: eraOrderMap,\n    });\n\n    onTreeChange(newTree);\n  }, [treeState, chronicles, eraNarratives, entities, staticPages, eraOrderMap, onTreeChange]);\n\n  // No tree yet: show scaffold button\n  if (!treeState) {\n    return (\n      <div className=\"preprint-tree-empty\">\n        <p className=\"ctv-empty-msg\">\n          Create a book structure to organize content for print. The scaffold includes standard\n          Front Matter, Body, and Back Matter sections.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCreateScaffold}>\n          Create Book Scaffold\n        </button>\n      </div>\n    );\n  }\n\n  const selectedNode = selectedNodeId ? findNode(treeState, selectedNodeId) : null;\n  const isSelectedFolder = selectedNode?.type === \"folder\";\n\n  return (\n    <div className=\"preprint-tree-layout\">\n      <div className=\"preprint-tree-toolbar\">\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleAutoPopulate}\n          title=\"Auto-populate Body and Encyclopedia from Chronicler's era ordering\"\n        >\n          Auto-Populate\n        </button>\n        <button\n          className=\"preprint-action-button small\"\n          disabled={!isSelectedFolder}\n          onClick={() => {\n            if (selectedNodeId) setNewFolderParent(selectedNodeId);\n          }}\n          title=\"Add folder to selected folder\"\n        >\n          + Folder\n        </button>\n        <button\n          className=\"preprint-action-button small danger\"\n          disabled={!selectedNodeId}\n          onClick={() => {\n            if (selectedNodeId && confirm(\"Delete this node and all children?\")) {\n              onTreeChange(deleteNode(treeState, selectedNodeId));\n              setSelectedNodeId(null);\n            }\n          }}\n          title=\"Delete selected node\"\n        >\n          Delete\n        </button>\n        <div className=\"ctv-toolbar-spacer\" />\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCreateScaffold}\n          title=\"Reset to default scaffold (replaces current tree)\"\n        >\n          Reset Scaffold\n        </button>\n      </div>\n\n      <DndProvider backend={HTML5Backend}>\n        <div className=\"preprint-tree-split\">\n          <div className=\"preprint-tree-left\">\n            <TreePane\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}", "type": "Readonly<ContentTreeViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ExportView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ExportView.tsx", "sourceCode": "export default function ExportView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}: Readonly<ExportViewProps>) {\n  const [exporting, setExporting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [exportFormat, setExportFormat] = useState<ExportFormat>(\"markdown\");\n  const [idmlLayout, setIdmlLayout] = useState<IdmlLayoutOptions>({ ...DEFAULT_IDML_LAYOUT });\n  const [customFont, setCustomFont] = useState(\"\");\n\n  // Read S3 config from localStorage (set by Canonry AWS panel)\n  const s3Config = useMemo<S3ExportConfig | null>(() => {\n    try {\n      const raw = localStorage.getItem(\"canonry.aws.config\");\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      if (!parsed.imageBucket) return null;\n      return {\n        bucket: parsed.imageBucket,\n        basePrefix: parsed.imagePrefix || \"\",\n        rawPrefix: parsed.rawPrefix || \"raw\",\n        region: parsed.region || \"us-east-1\",\n      };\n    } catch {\n      return null;\n    }\n  }, []);\n\n  const handleExport = useCallback(async () => {\n    if (!treeState) return;\n\n    setExporting(true);\n    setError(null);\n\n    try {\n      const exportOptions = {\n        treeState,\n        entities,\n        chronicles,\n        images,\n        staticPages,\n        eraNarratives,\n        projectId,\n        simulationRunId,\n        s3Config,\n        idmlLayout,\n      };\n\n      const blob =\n        exportFormat === \"indesign\"\n          ? await buildInDesignExportZip(exportOptions)\n          : await buildExportZip(exportOptions);\n\n      const timestamp = new Date().toISOString().slice(0, 10);\n      const filename =\n        exportFormat === \"indesign\"\n          ? `preprint-${timestamp}.idml`\n          : `preprint-markdown-${timestamp}.zip`;\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err: any) {\n      setError(err.message || \"Export failed\");\n    } finally {\n      setExporting(false);\n    }\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n    exportFormat,\n    idmlLayout,\n  ]);\n\n  const handleDownloadScript = useCallback(() => {\n    const script = buildIdmlImageScript({\n      treeState: treeState,\n      entities,\n      chronicles,\n      images,\n      staticPages,\n      eraNarratives,\n      projectId,\n      simulationRunId,\n      s3Config,\n    });\n    if (!script) return;\n\n    const blob = new Blob([script], { type: \"text/x-shellscript\" });\n    const timestamp = new Date().toISOString().slice(0, 10);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = `download-images-${timestamp}.sh`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  ]);\n\n  if (!treeState) {\n    return (\n      <div className=\"ev-empty-msg\">\n        Create a content tree first (Content Tree tab) before exporting.\n      </div>\n    );\n  }\n\n  const s3Contents = s3Config\n    ? [\n        { label: \"s3-config.json\", description: \"S3 bucket and prefix configuration\" },\n        {\n          label: \"download-images.sh\",\n          description: \"Bash script to pull images from S3 (requires aws CLI + jq)\",\n        },\n      ]\n    : [];\n\n  return (\n    <div className=\"preprint-export\">\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Export Format</h2>\n        </div>\n\n        <div className=\"preprint-export-format-selector\">\n          <label\n            className={`preprint-export-format-option${exportFormat === \"markdown\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"markdown\"\n              checked={exportFormat === \"markdown\"}\n              onChange={() => setExportFormat(\"markdown\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>Markdown ZIP</strong>\n              <span>Folder hierarchy of .md files with YAML frontmatter</span>\n            </div>\n          </label>\n          <label\n            className={`preprint-export-format-option${exportFormat === \"indesign\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"indesign\"\n              checked={exportFormat === \"indesign\"}\n              onChange={() => setExportFormat(\"indesign\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>InDesign IDML</strong>\n              <span>Native InDesign document with pages and styles</span>\n            </div>\n          </label>\n        </div>\n\n        <p className=\"ev-format-desc\">\n          {FORMAT_DESCRIPTIONS[exportFormat]}\n        </p>\n\n        {exportFormat === \"indesign\" && (\n          <div className=\"preprint-export-config\">\n            <div className=\"preprint-stats-subsection\">Layout Options</div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Page Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.pagePreset}\n                onChange={(e) => setIdmlLayout((prev) => ({ ...prev, pagePreset: e.target.value }))}\n              >\n                {Object.entries(IDML_PAGE_PRESETS).map(([key, preset]) => (\n                  <option key={key} value={key}>\n                    {preset.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Font</span>\n              <select\n                className=\"preprint-export-select\"\n                value={\n                  IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any)\n                    ? idmlLayout.fontFamily\n                    : \"__custom__\"\n                }\n                onChange={(e) => {\n                  if (e.target.value === \"__custom__\") {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: customFont || \"Junicode\" }));\n                  } else {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                  }\n                }}\n              >\n                {IDML_FONT_PRESETS.map((f) => (\n                  <option key={f} value={f}>\n                    {f}\n                  </option>\n                ))}\n                <option value=\"__custom__\">Custom...</option>\n              </select>\n            </div>\n\n            {!IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any) && (\n              <div className=\"preprint-stats-row\">\n                <span>Custom Font</span>\n                <input\n                  type=\"text\"\n                  className=\"preprint-export-input\"\n                  value={customFont}\n                  placeholder=\"Font family name\"\n                  onChange={(e) => {\n                    setCustomFont(e.target.value);\n                    if (e.target.value) {\n                      setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                    }\n                  }}\n                />\n              </div>\n            )}\n\n            <div className=\"preprint-stats-row\">\n              <span>Body Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodySize}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodySize: Number(e.target.value) }))\n                }\n              >\n                {[9, 10, 11, 12, 13, 14].map((s) => (\n                  <option key={s} value={s}>\n                    {s}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Leading</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodyLeading}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodyLeading: Number(e.target.value) }))\n                }\n              >\n                {[11, 12, 13, 14, 15, 16, 18].map((l) => (\n                  <option key={l} value={l}>\n                    {l}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Columns</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.columnCount}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, columnCount: Number(e.target.value) }))\n                }\n              >\n                <option value={1}>1</option>\n                <option value={2}>2</option>\n              </select>\n            </div>\n\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}", "type": "Readonly<ExportViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx", "sourceCode": "export default function PageLayoutEditor({\n  pageId,\n  pageName,\n  simulationRunId,\n}: Readonly<PageLayoutEditorProps>) {\n  const [override, setOverride] = useState<PageLayoutOverride | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [dirty, setDirty] = useState(false);\n\n  // Load existing override\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getPageLayout(simulationRunId, pageId).then((result) => {\n      if (!cancelled) {\n        setOverride(result);\n        setLoading(false);\n        setDirty(false);\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId, pageId]);\n\n  const update = useCallback(\n    <K extends OverrideField>(field: K, value: PageLayoutOverride[K] | undefined) => {\n      setOverride((prev) => {\n        const base = prev ?? { pageId, simulationRunId, updatedAt: Date.now() };\n        const next = { ...base, [field]: value === \"\" ? undefined : value, updatedAt: Date.now() };\n        return next;\n      });\n      setDirty(true);\n    },\n    [pageId, simulationRunId]\n  );\n\n  const handleSave = useCallback(async () => {\n    if (!override) return;\n    await putPageLayout(override);\n    setDirty(false);\n  }, [override]);\n\n  const handleClear = useCallback(async () => {\n    await deletePageLayout(simulationRunId, pageId);\n    setOverride(null);\n    setDirty(false);\n  }, [simulationRunId, pageId]);\n\n  if (loading) {\n    return (\n      <div className=\"preprint-layout-editor\">\n        <div className=\"preprint-layout-loading\">Loading...</div>\n      </div>\n    );\n  }\n\n  const hasOverride =\n    override &&\n    Object.keys(override).some(\n      (k) =>\n        ![\"pageId\", \"simulationRunId\", \"updatedAt\"].includes(k) &&\n        (override as any)[k] !== undefined\n    );\n\n  return (\n    <div className=\"preprint-layout-editor\">\n      <div className=\"preprint-layout-header\">\n        <span className=\"preprint-layout-title\" title={pageName}>\n          Layout: {pageName}\n        </span>\n        {hasOverride && (\n          <button\n            className=\"preprint-layout-clear\"\n            onClick={() => void handleClear()}\n            title=\"Reset to engine defaults\"\n          >\n            Clear\n          </button>\n        )}\n      </div>\n\n      <div className=\"preprint-layout-fields\">\n        <SelectField\n          label=\"Layout Mode\"\n          value={override?.layoutMode ?? \"\"}\n          options={LAYOUT_MODES}\n          onChange={(v) => update(\"layoutMode\", (v as LayoutMode) || undefined)}\n        />\n\n        <SelectField\n          label=\"Annotations\"\n          value={override?.annotationDisplay ?? \"\"}\n          options={ANNOTATION_DISPLAY}\n          onChange={(v) => update(\"annotationDisplay\", (v as AnnotationDisplay) || undefined)}\n        />\n\n        <SelectField\n          label=\"Note Position\"\n          value={override?.annotationPosition ?? \"\"}\n          options={ANNOTATION_POSITION}\n          onChange={(v) => update(\"annotationPosition\", (v as AnnotationPosition) || undefined)}\n        />\n\n        <SelectField\n          label=\"Image Layout\"\n          value={override?.imageLayout ?? \"\"}\n          options={IMAGE_LAYOUT}\n          onChange={(v) => update(\"imageLayout\", (v as ImageLayout) || undefined)}\n        />\n\n        <SelectField\n          label=\"Content Width\"\n          value={override?.contentWidth ?? \"\"}\n          options={CONTENT_WIDTH}\n          onChange={(v) => update(\"contentWidth\", (v as ContentWidth) || undefined)}\n        />\n\n        <SelectField\n          label=\"Text Align\"\n          value={override?.textAlign ?? \"\"}\n          options={TEXT_ALIGN}\n          onChange={(v) => update(\"textAlign\", (v as TextAlign) || undefined)}\n        />\n\n        <div className=\"preprint-layout-row\">\n          <label className=\"preprint-layout-label\">\n            <input\n              type=\"checkbox\"\n              checked={override?.dropcap ?? false}\n              onChange={(e) => update(\"dropcap\", e.target.checked || undefined)}\n            />\n            Drop cap\n          </label>\n        </div>\n\n        <div className=\"preprint-layout-row\">\n          <label htmlFor=\"custom-css-class\" className=\"preprint-layout-label-block\">Custom CSS class</label>\n          <input id=\"custom-css-class\"\n            type=\"text\"\n            className=\"preprint-input preprint-layout-text\"\n            value={override?.customClass ?? \"\"}\n            onChange={(e) => update(\"customClass\", e.target.value || undefined)}\n            placeholder=\"e.g. my-custom-layout\"\n          />\n        </div>\n      </div>\n\n      {dirty && (\n        <div className=\"preprint-layout-actions\">\n          <button className=\"preprint-layout-save\" onClick={() => void handleSave()}>\n            Save\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  pageId,\n  pageName,\n  simulationRunId,\n}", "type": "Readonly<PageLayoutEditorProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/StatsView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/StatsView.tsx", "sourceCode": "export default function StatsView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}: Readonly<StatsViewProps>) {\n  const [stats, setStats] = useState<PrePrintStats | null>(null);\n  const [calculating, setCalculating] = useState(false);\n\n  const handleCalculate = useCallback(() => {\n    setCalculating(true);\n    // Use setTimeout to allow UI to show spinner before computation blocks\n    setTimeout(() => {\n      const result = computePrePrintStats(entities, chronicles, images, staticPages, eraNarratives);\n      setStats(result);\n      setCalculating(false);\n    }, 50);\n  }, [entities, chronicles, images, staticPages, eraNarratives]);\n\n  if (!stats) {\n    return (\n      <div className=\"preprint-stats-empty\">\n        <p className=\"sv-empty-msg\">\n          Calculate statistics for print preparation. This scans all entities, chronicles, era\n          narratives, images, and static pages to produce word counts, image inventory, and\n          completeness checks.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCalculate} disabled={calculating}>\n          {calculating ? \"Calculating...\" : \"Calculate Stats\"}\n        </button>\n      </div>\n    );\n  }\n\n  const wb = stats.wordBreakdown;\n  const cb = stats.charBreakdown;\n  const img = stats.images;\n  const comp = stats.completeness;\n  const hn = stats.historianNotes;\n\n  return (\n    <div className=\"preprint-stats\">\n      <div className=\"preprint-stats-header\">\n        <span className=\"sv-calc-meta\">\n          Calculated {new Date(stats.calculatedAt).toLocaleString()}\n        </span>\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCalculate}\n          disabled={calculating}\n        >\n          {calculating ? \"Recalculating...\" : \"Recalculate\"}\n        </button>\n      </div>\n\n      {/* Page Estimate */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Page Estimate</h2>\n        </div>\n        <div className=\"preprint-stats-hero\">\n          <div className=\"preprint-stats-hero-number\">{stats.estimatedPages.toLocaleString()}</div>\n          <div className=\"preprint-stats-hero-label\">estimated pages (250 words/page)</div>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total words</span>\n          <span className=\"preprint-stats-value\">{stats.totalWords.toLocaleString()}</span>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total characters</span>\n          <span className=\"preprint-stats-value\">{stats.totalChars.toLocaleString()}</span>\n        </div>\n      </div>\n\n      {/* Word Count Breakdown */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Word & Character Counts</h2>\n        </div>\n        <div className=\"preprint-stats-table\">\n          <div className=\"preprint-stats-table-header\">\n            <span>Content Type</span>\n            <span>Words</span>\n            <span>Chars</span>\n            <span>% of Total</span>\n          </div>\n          <WordRow\n            label=\"Chronicle body text\"\n            words={wb.chronicleBody}\n            chars={cb.chronicleBody}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Chronicle summaries\"\n            words={wb.chronicleSummaries}\n            chars={cb.chronicleSummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Era narrative content\"\n            words={wb.eraNarrativeContent}\n            chars={cb.eraNarrativeContent}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity descriptions\"\n            words={wb.entityDescriptions}\n            chars={cb.entityDescriptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity summaries\"\n            words={wb.entitySummaries}\n            chars={cb.entitySummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Image captions\"\n            words={wb.imageCaptions}\n            chars={cb.imageCaptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (entity)\"\n            words={wb.historianNotesEntity}\n            chars={cb.historianNotesEntity}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (chronicle)\"\n            words={wb.historianNotesChronicle}\n            chars={cb.historianNotesChronicle}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Static page content\"\n            words={wb.staticPageContent}\n            chars={cb.staticPageContent}\n            total={stats.totalWords}\n          />\n        </div>\n      </div>\n\n      {/* Image Inventory */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Inventory</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total images</span>\n          <span className=\"preprint-stats-value\">{img.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Total storage</span>\n          <span className=\"preprint-stats-value\">{formatBytes(img.totalStorageBytes)}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Orientation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Portrait</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.portrait} ({pct(img.byAspect.portrait, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Landscape</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.landscape} ({pct(img.byAspect.landscape, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Square</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.square} ({pct(img.byAspect.square, img.total)})\n          </span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n        <div className=\"preprint-stats-row\">\n          <span>Entity portraits</span>\n          <span className=\"preprint-stats-value\">{img.byType.entity}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Chronicle scenes</span>\n          <span className=\"preprint-stats-value\">{img.byType.chronicle}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Cover images</span>\n          <span className=\"preprint-stats-value\">{img.byType.cover}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Size Designation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Small (inline)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.small}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Medium (half-page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.medium}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Large (3/4 page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.large}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Full-width</span>\n          <span className=\"preprint-stats-value\">{img.bySize[\"full-width\"]}</span>\n        </div>\n\n        {img.dimensionRange && (\n          <>\n            <div className=\"preprint-stats-subsection\">Dimensions (pixels)</div>\n            <div className=\"preprint-stats-row\">\n              <span>Width range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minWidth} \u2013 {img.dimensionRange.maxWidth}px\n              </span>\n            </div>\n            <div className=\"preprint-stats-row\">\n              <span>Height range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minHeight} \u2013 {img.dimensionRange.maxHeight}px\n              </span>\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Completeness */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Completeness</h2>\n        </div>\n        <CompletenessRow\n          label=\"Entities with description\"\n          count={comp.entitiesWithDescription}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with image\"\n          count={comp.entitiesWithImage}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with summary\"\n          count={comp.entitiesWithSummary}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles published\"\n          count={comp.chroniclesPublished}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with historian notes\"\n          count={comp.chroniclesWithHistorianNotes}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with scene images\"\n          count={comp.chroniclesWithSceneImages}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives complete\"\n          count={comp.eraNarrativesComplete}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives with cover image\"\n          count={comp.eraNarrativesWithCoverImage}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Static pages published\"\n          count={comp.staticPagesPublished}\n          total={comp.staticPagesTotal}\n        />\n      </div>\n\n      {/* Historian Notes */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Historian Notes</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total notes</span>\n          <span className=\"preprint-stats-value\">{hn.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On entities</span>\n          <span className=\"preprint-stats-value\">{hn.onEntities}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On chronicles</span>\n          <span className=\"preprint-stats-value\">{hn.onChronicles}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}", "type": "Readonly<StatsViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx", "sourceCode": "export default function TreeNodeRenderer({\n  node,\n  style,\n  dragHandle\n}: Readonly<NodeRendererProps<TreeNodeData>>) {\n  const data = node.data;\n  const meta = data.meta;\n  const isFolder = data.type === \"folder\";\n  return <div className={`preprint-tree-node ${node.isSelected ? \"selected\" : \"\"} ${isFolder ? \"folder\" : \"content\"}`} ref={dragHandle} onClick={() => node.isInternal && node.toggle()} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }} style={style}>\n      <span className=\"preprint-tree-node-icon\" title={TYPE_LABELS[data.type] || data.type}>\n        {(() => {\n        if (isFolder) return node.isOpen ? \"\\u{1F4C2}\" : \"\\u{1F4C1}\";\n        return TYPE_ICONS[data.type] || \"?\";\n      })()}\n      </span>\n\n      {node.isEditing ? <input type=\"text\" className=\"preprint-tree-node-edit\" defaultValue={data.name}\n    // eslint-disable-next-line jsx-a11y/no-autofocus\n    autoFocus onBlur={() => node.reset()} onKeyDown={e => {\n      if (e.key === \"Enter\") node.submit((e.target as HTMLInputElement).value);\n      if (e.key === \"Escape\") node.reset();\n    }} /> : <span className=\"preprint-tree-node-name\" title={data.name}>\n          {data.name}\n        </span>}\n\n      {!isFolder && meta && <span className=\"preprint-tree-node-meta\">\n          {meta.wordCount !== undefined && <span className=\"preprint-tree-node-wc\" title=\"Word count\">\n              {meta.wordCount.toLocaleString()}w\n            </span>}\n          {meta.imageCount !== undefined && meta.imageCount > 0 && <span className=\"preprint-tree-node-ic\" title=\"Images\">\n              \\u25A3 {meta.imageCount}\n            </span>}\n          <span className=\"preprint-tree-node-status\" title={(() => {\n        if (meta.hasDescription && meta.hasImage) return \"Complete\";\n        if (meta.hasDescription) return \"Missing image\";\n        return \"Missing content\";\n      })()} style={{\n        '--tree-status-color': (() => {\n          if (meta.hasDescription && meta.hasImage) return \"#22c55e\";\n          if (meta.hasDescription) return \"#f59e0b\";\n          return \"#ef4444\";\n        })()\n      } as React.CSSProperties}>\n            {(() => {\n          if (meta.hasDescription && meta.hasImage) return \"\\u25CF\";\n          if (meta.hasDescription) return \"\\u25D2\";\n          return \"\\u25CB\";\n        })()}\n          </span>\n        </span>}\n    </div>;\n}", "parameters": [{"name": "{\n  node,\n  style,\n  dragHandle\n}", "type": "Readonly<NodeRendererProps<TreeNodeData>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/lib/chronicle/focus.ts::applyFocusToContext", "name": "applyFocusToContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/focus.ts", "sourceCode": "export function applyFocusToContext(\n  context: ChronicleGenerationContext,\n  focus: NarrativeFocus\n): ChronicleGenerationContext {\n  const entitySet = new Set(focus.selectedEntityIds);\n  const eventSet = new Set(focus.selectedEventIds);\n\n  const filteredEntities = context.entities.filter((e) => entitySet.has(e.id));\n  const filteredEvents = context.events.filter((e) => eventSet.has(e.id));\n  const filteredRelationships = context.relationships.filter(\n    (r) => entitySet.has(r.src) && entitySet.has(r.dst)\n  );\n\n  return {\n    ...context,\n    entities: filteredEntities,\n    events: filteredEvents,\n    relationships: filteredRelationships,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "focus", "type": "NarrativeFocus", "optional": false}], "returnType": "ChronicleGenerationContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::toCulture", "name": "toCulture", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Convert CultureDefinition (Canonry) to Culture (name-forge)\n */\nexport function toCulture(def: CultureDefinition): Culture | null {\n  if (!def.naming) return null;\n\n  return {\n    id: def.id,\n    name: def.name,\n    description: def.description,\n    domains: def.naming.domains || [],\n    lexemeLists: def.naming.lexemeLists || {},\n    grammars: def.naming.grammars || [],\n    profiles: def.naming.profiles || [],\n  };\n}", "parameters": [{"name": "def", "type": "CultureDefinition", "optional": false}], "returnType": "Culture | null"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::generateNameBank", "name": "generateNameBank", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Generate a name bank for the given cultures.\n *\n * @param cultures - All culture definitions from the project\n * @param cultureIds - Culture IDs to generate names for\n * @returns Map of culture ID -> array of generated names\n */\nexport async function generateNameBank(\n  cultures: CultureDefinition[],\n  cultureIds: string[]\n): Promise<Record<string, string[]>> {\n  const nameBank: Record<string, string[]> = {};\n  const uniqueCultureIds = [...new Set(cultureIds)];\n\n  for (const cultureId of uniqueCultureIds) {\n    const cultureDef = cultures.find((c) => c.id === cultureId);\n    if (!cultureDef) continue;\n\n    const culture = toCulture(cultureDef);\n    if (!culture) continue;\n\n    try {\n      const result = await generate(culture, {\n        kind: \"npc\",\n        count: NAMES_PER_CULTURE,\n        seed: `namebank-${cultureId}-${Date.now()}`,\n      });\n      nameBank[cultureId] = result.names;\n    } catch (e) {\n      console.warn(`[NameBank] Failed to generate names for culture ${cultureId}:`, e);\n      // Continue without names for this culture\n    }\n  }\n\n  return nameBank;\n}", "parameters": [{"name": "cultures", "type": "CultureDefinition[]", "optional": false}, {"name": "cultureIds", "type": "string[]", "optional": false}], "returnType": "Promise<Record<string, string[]>>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::extractCultureIds", "name": "extractCultureIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Extract unique culture IDs from a list of entities.\n */\nexport function extractCultureIds(entities: Array<{ culture?: string }>): string[] {\n  const cultureIds = entities\n    .map((e) => e.culture)\n    .filter((c): c is string => c !== undefined && c !== null && c !== \"\");\n  return [...new Set(cultureIds)];\n}", "parameters": [{"name": "entities", "type": "Array<{ culture?: string }>", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildEntityLookup", "name": "buildEntityLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildEntityLookup(\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): Map<string, { name: string; kind?: string }> {\n  const lookup = new Map<string, { name: string; kind?: string }>();\n\n  for (const entity of entities) {\n    lookup.set(entity.id, { name: entity.name, kind: entity.kind });\n  }\n\n  for (const rel of relationships) {\n    if (!lookup.has(rel.src)) {\n      lookup.set(rel.src, { name: rel.sourceName, kind: rel.sourceKind });\n    }\n    if (!lookup.has(rel.dst)) {\n      lookup.set(rel.dst, { name: rel.targetName, kind: rel.targetKind });\n    }\n  }\n\n  return lookup;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "Map<string, { name: string; kind?: string }>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildRelationshipPairSummaries", "name": "buildRelationshipPairSummaries", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildRelationshipPairSummaries(\n  entityIds: string[],\n  relationships: RelationshipContext[]\n): RelationshipPairSummary[] {\n  const uniqueIds = Array.from(new Set(entityIds));\n  const adjacency = buildAdjacency(relationships);\n  const summaries: RelationshipPairSummary[] = [];\n\n  for (let i = 0; i < uniqueIds.length; i += 1) {\n    const entityAId = uniqueIds[i];\n    const neighborsA = collectNeighborLinks(adjacency, entityAId);\n\n    for (let j = i + 1; j < uniqueIds.length; j += 1) {\n      const entityBId = uniqueIds[j];\n      const neighborsB = collectNeighborLinks(adjacency, entityBId);\n\n      const direct = (adjacency.get(entityAId) || []).filter(\n        (rel) => rel.src === entityBId || rel.dst === entityBId\n      );\n\n      const sharedNeighbors: SharedNeighborLink[] = [];\n      for (const [neighborId, linksFromA] of neighborsA.entries()) {\n        const linksFromB = neighborsB.get(neighborId);\n        if (!linksFromB) continue;\n        sharedNeighbors.push({ neighborId, linksFromA, linksFromB });\n      }\n\n      sharedNeighbors.sort((a, b) => a.neighborId.localeCompare(b.neighborId));\n\n      summaries.push({\n        entityAId,\n        entityBId,\n        direct,\n        sharedNeighbors,\n      });\n    }\n  }\n\n  return summaries;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "RelationshipPairSummary[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildKindToCategoryMap", "name": "buildKindToCategoryMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Category Resolution\n// =============================================================================\n\n/**\n * Build a mapping from entity kind to its category.\n * Used to resolve domain-agnostic categories to domain-specific kinds at runtime.\n */\nexport function buildKindToCategoryMap(\n  entityKinds: EntityKindDefinition[]\n): Map<string, EntityCategory> {\n  const map = new Map<string, EntityCategory>();\n  for (const kind of entityKinds) {\n    if (kind.category) {\n      map.set(kind.kind, kind.category);\n    }\n  }\n  return map;\n}", "parameters": [{"name": "entityKinds", "type": "EntityKindDefinition[]", "optional": false}], "returnType": "Map<string, EntityCategory>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildNeighborGraph", "name": "buildNeighborGraph", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build a graph of entities reachable within maxDepth hops from entrypoint.\n */\nexport function buildNeighborGraph(\n  relationships: RelationshipContext[],\n  entrypointId: string,\n  maxDepth: number = 2\n): NeighborGraph {\n  const adjacency = new Map<string, Set<string>>();\n  for (const rel of relationships) {\n    if (!adjacency.has(rel.src)) adjacency.set(rel.src, new Set());\n    if (!adjacency.has(rel.dst)) adjacency.set(rel.dst, new Set());\n    adjacency.get(rel.src).add(rel.dst);\n    adjacency.get(rel.dst).add(rel.src);\n  }\n\n  const distances = new Map<string, number>();\n  const queue: Array<{ id: string; depth: number }> = [{ id: entrypointId, depth: 0 }];\n  distances.set(entrypointId, 0);\n\n  while (queue.length > 0) {\n    const { id, depth } = queue.shift();\n    if (depth >= maxDepth) continue;\n    const neighbors = adjacency.get(id);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (distances.has(neighbor)) continue;\n      distances.set(neighbor, depth + 1);\n      queue.push({ id: neighbor, depth: depth + 1 });\n    }\n  }\n\n  return { ids: new Set(distances.keys()), distances };\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "entrypointId", "type": "string", "optional": false}, {"name": "maxDepth", "type": "number", "optional": true}], "returnType": "NeighborGraph"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEntityMetrics", "name": "computeEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single entity.\n */\nexport function computeEntityMetrics(\n  entity: EntityContext,\n  ctx: MetricsContext\n): EntitySelectionMetrics {\n  const {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  } = ctx;\n\n  // Distance\n  const distance = distances.get(entity.id) ?? 99;\n\n  // Average relationship strength to entry point\n  const relsToEntry = relationships.filter(\n    (r) =>\n      (r.src === entity.id && r.dst === entryPointId) ||\n      (r.dst === entity.id && r.src === entryPointId)\n  );\n  const avgStrength =\n    relsToEntry.length > 0\n      ? relsToEntry.reduce((sum, r) => sum + (r.strength ?? 0.5), 0) / relsToEntry.length\n      : 0;\n\n  // Usage count\n  const usage = usageStats.get(entity.id);\n  const usageCount = usage?.usageCount ?? 0;\n\n  // Era alignment - check if entity shares any era with entry point\n  const entityEraId = resolveEntityEraId(entity);\n  const eraAligned =\n    entryPointEras.size === 0 || (entityEraId !== undefined && entryPointEras.has(entityEraId));\n\n  // Category novelty\n  const entityCategory = kindToCategory.get(entity.kind);\n  const addsNewCategory =\n    entityCategory !== undefined && !currentCastCategories.has(entityCategory);\n\n  // Relationship type diversity\n  const entityRelTypes = new Set(\n    relationships.filter((r) => r.src === entity.id || r.dst === entity.id).map((r) => r.kind)\n  );\n  const newRelTypes = [...entityRelTypes].filter((t) => !currentCastRelTypes.has(t)).length;\n\n  return {\n    entityId: entity.id,\n    distance,\n    avgStrength,\n    usageCount,\n    eraAligned,\n    addsNewCategory,\n    newRelTypes,\n  };\n}", "parameters": [{"name": "entity", "type": "EntityContext", "optional": false}, {"name": "ctx", "type": "MetricsContext", "optional": false}], "returnType": "EntitySelectionMetrics"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEntityMetrics", "name": "computeAllEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate entities.\n */\nexport function computeAllEntityMetrics(\n  candidates: EntityContext[],\n  entryPointId: string,\n  relationships: RelationshipContext[],\n  distances: Map<string, number>,\n  usageStats: Map<string, { usageCount: number }>,\n  currentAssignments: ChronicleRoleAssignment[],\n  kindToCategory: Map<string, EntityCategory>\n): Map<string, EntitySelectionMetrics> {\n  const entryPointEraId = resolveEntityEraId(candidates.find((e) => e.id === entryPointId));\n  const entryPointEras = new Set(entryPointEraId ? [entryPointEraId] : []);\n\n  // Get current cast's categories and relationship types\n  const assignedIds = new Set(currentAssignments.map((a) => a.entityId));\n  const currentCastCategories = new Set<EntityCategory>();\n  const currentCastRelTypes = new Set<string>();\n\n  for (const assignment of currentAssignments) {\n    const entity = candidates.find((e) => e.id === assignment.entityId);\n    if (entity) {\n      const cat = kindToCategory.get(entity.kind);\n      if (cat) currentCastCategories.add(cat);\n    }\n  }\n\n  for (const rel of relationships) {\n    if (assignedIds.has(rel.src) || assignedIds.has(rel.dst)) {\n      currentCastRelTypes.add(rel.kind);\n    }\n  }\n\n  const ctx: MetricsContext = {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  };\n\n  const metricsMap = new Map<string, EntitySelectionMetrics>();\n  for (const entity of candidates) {\n    metricsMap.set(entity.id, computeEntityMetrics(entity, ctx));\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "distances", "type": "Map<string, number>", "optional": false}, {"name": "usageStats", "type": "Map<string, { usageCount: number }>", "optional": false}, {"name": "currentAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}], "returnType": "Map<string, EntitySelectionMetrics>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalScope", "name": "computeTemporalScope", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Temporal Utilities\n// =============================================================================\n\n/**\n * Compute temporal scope from tick range.\n */\nexport function computeTemporalScope(\n  tickRange: [number, number],\n  isMultiEra: boolean\n): TemporalScope {\n  const duration = tickRange[1] - tickRange[0];\n\n  if (isMultiEra) return \"saga\";\n  if (duration >= 50) return \"saga\";\n  if (duration >= 20) return \"arc\";\n  if (duration >= 5) return \"episode\";\n  return \"moment\";\n}", "parameters": [{"name": "tickRange", "type": "[number, number]", "optional": false}, {"name": "isMultiEra", "type": "boolean", "optional": false}], "returnType": "TemporalScope"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::findEraForEvent", "name": "findEraForEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Find era for an event - by direct ID match.\n */\nexport function findEraForEvent(\n  event: { tick: number; era?: string },\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  // Direct ID match (event.era should match era.id)\n  if (event.era) {\n    const byId = eras.find((e) => e.id === event.era);\n    if (byId) return byId;\n  }\n  return undefined;\n}", "parameters": [{"name": "event", "type": "{ tick: number; era?: string }", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeFocalEra", "name": "computeFocalEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the focal era from a set of events.\n * Returns the era that contains the most events.\n */\nexport function computeFocalEra(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  if (events.length === 0 || eras.length === 0) {\n    return eras[0]; // Default to first era\n  }\n\n  // Count events per era\n  const eraCounts = new Map<string, number>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) {\n      eraCounts.set(era.id, (eraCounts.get(era.id) || 0) + 1);\n    }\n  }\n\n  // Find era with most events\n  let maxCount = 0;\n  let focalEraId: string | undefined;\n  for (const [eraId, count] of eraCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      focalEraId = eraId;\n    }\n  }\n\n  return eras.find((e) => e.id === focalEraId) || eras[0];\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalContext", "name": "computeTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the complete temporal context for a chronicle.\n */\nexport function computeTemporalContext(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[],\n  entryPoint?: EntityContext,\n  focalEraOverrideId?: string | null\n): ChronicleTemporalContext {\n  // Compute tick range from events\n  let minTick = Infinity;\n  let maxTick = -Infinity;\n\n  for (const event of events) {\n    minTick = Math.min(minTick, event.tick);\n    maxTick = Math.max(maxTick, event.tick);\n  }\n\n  // Include entry point creation tick if available\n  if (entryPoint) {\n    minTick = Math.min(minTick, entryPoint.createdAt);\n  }\n\n  // Handle edge case of no events\n  if (minTick === Infinity) {\n    minTick = entryPoint?.createdAt ?? 0;\n    maxTick = minTick;\n  }\n\n  const chronicleTickRange: [number, number] = [minTick, maxTick];\n\n  // Find touched eras by event era IDs\n  const touchedEraIds = new Set<string>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) touchedEraIds.add(era.id);\n  }\n\n  const isMultiEra = touchedEraIds.size > 1;\n  const temporalScope = computeTemporalScope(chronicleTickRange, isMultiEra);\n\n  // Compute focal era (use override if provided)\n  const overrideEra = focalEraOverrideId\n    ? eras.find((e) => e.id === focalEraOverrideId)\n    : undefined;\n  const focalEra = overrideEra || computeFocalEra(events, eras) || eras[0];\n\n  // Build temporal description\n  const temporalDescription = buildTemporalDescription(\n    focalEra,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds.size\n  );\n\n  return {\n    focalEra,\n    allEras: eras,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds: Array.from(touchedEraIds),\n    temporalDescription,\n  };\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "entryPoint", "type": "EntityContext", "optional": true}, {"name": "focalEraOverrideId", "type": "string | null", "optional": true}], "returnType": "ChronicleTemporalContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEventMetrics", "name": "computeEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single event.\n */\nexport function computeEventMetrics(\n  event: NarrativeEventContext,\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): EventSelectionMetrics {\n  // Use event era ID and resolve name from eras when possible\n  const eventEra = findEraForEvent(event, eras);\n  const eraId = eventEra?.id || event.era;\n  const eraName = eventEra?.name || event.era;\n\n  // Count how many assigned entities are involved\n  let assignedCount = 0;\n  if (event.subjectId && assignedEntityIds.has(event.subjectId)) assignedCount++;\n  if (event.objectId && assignedEntityIds.has(event.objectId)) assignedCount++;\n\n  // Check if event involves entry point\n  const involvesEntryPoint = event.subjectId === entryPointId || event.objectId === entryPointId;\n\n  return {\n    eventId: event.id,\n    tick: event.tick,\n    eraId,\n    eraName,\n    inFocalEra: eraId === focalEraId,\n    tickDistance: Math.abs(event.tick - entryPointTick),\n    involvesEntryPoint,\n    assignedEntityCount: assignedCount,\n    significance: event.significance,\n  };\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "EventSelectionMetrics"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEventMetrics", "name": "computeAllEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate events.\n */\nexport function computeAllEventMetrics(\n  events: NarrativeEventContext[],\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): Map<string, EventSelectionMetrics> {\n  const metricsMap = new Map<string, EventSelectionMetrics>();\n\n  for (const event of events) {\n    metricsMap.set(\n      event.id,\n      computeEventMetrics(event, entryPointId, entryPointTick, focalEraId, eras, assignedEntityIds)\n    );\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "Map<string, EventSelectionMetrics>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::scoreEventForSelection", "name": "scoreEventForSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Score an event for selection based on temporal alignment and relevance.\n */\nexport function scoreEventForSelection(\n  event: NarrativeEventContext,\n  metrics: EventSelectionMetrics,\n  preferFocalEra: boolean = true\n): number {\n  let score = 0;\n\n  // Base score from significance\n  score += metrics.significance * 30;\n\n  // Bonus for involving entry point\n  if (metrics.involvesEntryPoint) {\n    score += 20;\n  }\n\n  // Bonus for involving multiple assigned entities\n  score += metrics.assignedEntityCount * 10;\n\n  // Era alignment bonus/penalty\n  if (preferFocalEra) {\n    if (metrics.inFocalEra) {\n      score += 15;\n    } else {\n      score -= 10; // Soft penalty for cross-era events\n    }\n  }\n\n  // Temporal proximity bonus (closer to entry point creation = more relevant)\n  // Diminishing returns: 0-10 ticks = 10pts, 10-50 ticks = 5pts, 50+ ticks = 0pts\n  if (metrics.tickDistance <= 10) {\n    score += 10;\n  } else if (metrics.tickDistance <= 50) {\n    score += 5;\n  }\n\n  // Small randomization to break ties\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security tie-breaking jitter\n  score += Math.random() * 3;\n\n  return score;\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "metrics", "type": "EventSelectionMetrics", "optional": false}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestEventSelection", "name": "suggestEventSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Auto-select events based on temporal alignment and relevance.\n * Returns event IDs sorted by score.\n */\nexport function suggestEventSelection(\n  events: NarrativeEventContext[],\n  metricsMap: Map<string, EventSelectionMetrics>,\n  maxEvents: number = 8,\n  preferFocalEra: boolean = true\n): string[] {\n  const scored = events.map((event) => {\n    const metrics = metricsMap.get(event.id);\n    if (!metrics) return { id: event.id, score: 0 };\n    return {\n      id: event.id,\n      score: scoreEventForSelection(event, metrics, preferFocalEra),\n    };\n  });\n\n  scored.sort((a, b) => b.score - a.score);\n\n  return scored.slice(0, maxEvents).map((s) => s.id);\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "metricsMap", "type": "Map<string, EventSelectionMetrics>", "optional": false}, {"name": "maxEvents", "type": "number", "optional": true}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestRoleAssignments", "name": "suggestRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "export function suggestRoleAssignments(\n  candidates: EntityContext[],\n  roles: RoleDefinition[],\n  entryPointId: string,\n  _rules: unknown, // Deprecated - entity selection rules removed\n  relationships: RelationshipContext[],\n  _kindToCategory: Map<string, EntityCategory>,\n  metricsMap?: Map<string, EntitySelectionMetrics>\n): ChronicleRoleAssignment[] {\n  const assignments: ChronicleRoleAssignment[] = [];\n  const usedEntityIds = new Set<string>();\n\n  const entryPoint = candidates.find((e) => e.id === entryPointId);\n  const roleScores = buildRoleScores(candidates, roles, relationships, metricsMap);\n\n  if (entryPoint) {\n    assignEntryPoint(entryPoint, roles, assignments, usedEntityIds);\n  }\n\n  assignRemainingRoles(roles, roleScores, assignments, usedEntityIds);\n\n  return assignments;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "_rules", "type": "unknown", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "_kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}, {"name": "metricsMap", "type": "Map<string, EntitySelectionMetrics>", "optional": true}], "returnType": "ChronicleRoleAssignment[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::validateRoleAssignments", "name": "validateRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Role Assignment Validation\n// =============================================================================\n\n/**\n * Validate role assignments against style constraints.\n */\nexport function validateRoleAssignments(\n  assignments: ChronicleRoleAssignment[],\n  roles: RoleDefinition[],\n  maxCastSize: number\n): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check total cast size\n  if (assignments.length > maxCastSize) {\n    errors.push(`Too many entities assigned (${assignments.length}/${maxCastSize} max)`);\n  }\n\n  // Check each role's min/max constraints\n  for (const roleDef of roles) {\n    const roleCount = assignments.filter((a) => a.role === roleDef.role).length;\n\n    if (roleCount < roleDef.count.min) {\n      if (roleDef.count.min === 1) {\n        errors.push(`Role \"${roleDef.role}\" requires at least 1 entity`);\n      } else {\n        errors.push(\n          `Role \"${roleDef.role}\" requires at least ${roleDef.count.min} entities (has ${roleCount})`\n        );\n      }\n    }\n\n    if (roleCount > roleDef.count.max) {\n      warnings.push(`Role \"${roleDef.role}\" has ${roleCount} entities (max ${roleDef.count.max})`);\n    }\n  }\n\n  // Check for duplicate entity assignments\n  const entityCounts = new Map<string, number>();\n  for (const assignment of assignments) {\n    const count = entityCounts.get(assignment.entityId) || 0;\n    entityCounts.set(assignment.entityId, count + 1);\n  }\n  for (const [entityId, count] of entityCounts) {\n    if (count > 1) {\n      const entity = assignments.find((a) => a.entityId === entityId);\n      warnings.push(`Entity \"${entity?.entityName}\" is assigned to ${count} roles`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "maxCastSize", "type": "number", "optional": false}], "returnType": "ValidationResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantRelationships", "name": "getRelevantRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Relationship & Event Selection\n// =============================================================================\n\n/**\n * Get relationships between assigned entities.\n */\nexport function getRelevantRelationships(\n  assignments: ChronicleRoleAssignment[],\n  allRelationships: RelationshipContext[],\n  extraEntityIds?: Iterable<string>\n): RelationshipContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n  if (extraEntityIds) {\n    for (const id of extraEntityIds) assignedIds.add(id);\n  }\n  return allRelationships.filter((r) => assignedIds.has(r.src) && assignedIds.has(r.dst));\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "extraEntityIds", "type": "Iterable<string>", "optional": true}], "returnType": "RelationshipContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::makeRelationshipId", "name": "makeRelationshipId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Create relationship ID from components.\n */\nexport function makeRelationshipId(src: string, dst: string, kind: string): string {\n  return `${src}:${dst}:${kind}`;\n}", "parameters": [{"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::collapseBidirectionalRelationships", "name": "collapseBidirectionalRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Collapse bidirectional relationships into single entries.\n * A\u2194B shown once instead of A\u2192B and B\u2192A separately.\n */\nexport function collapseBidirectionalRelationships(\n  relationships: RelationshipContext[]\n): CollapsedRelationship[] {\n  const result: CollapsedRelationship[] = [];\n  const processed = new Set<string>();\n\n  // Index relationships by normalized key (sorted src/dst + kind)\n  const byNormalizedKey = new Map<string, RelationshipContext[]>();\n  for (const rel of relationships) {\n    const normalizedKey = [rel.src, rel.dst].sort((a, b) => a.localeCompare(b)).join(\":\") + \":\" + rel.kind;\n    const existing = byNormalizedKey.get(normalizedKey) || [];\n    existing.push(rel);\n    byNormalizedKey.set(normalizedKey, existing);\n  }\n\n  for (const rel of relationships) {\n    const relId = makeRelationshipId(rel.src, rel.dst, rel.kind);\n    if (processed.has(relId)) continue;\n    processed.add(relId);\n\n    // Check for reverse relationship\n    const reverseId = makeRelationshipId(rel.dst, rel.src, rel.kind);\n    const reverseRel = relationships.find(\n      (r) => r.src === rel.dst && r.dst === rel.src && r.kind === rel.kind\n    );\n\n    if (reverseRel && !processed.has(reverseId)) {\n      // Bidirectional - collapse into one entry\n      processed.add(reverseId);\n      const avgStrength = ((rel.strength ?? 0.5) + (reverseRel.strength ?? 0.5)) / 2;\n      result.push({\n        primary: rel,\n        reverse: reverseRel,\n        isBidirectional: true,\n        relationshipIds: [relId, reverseId],\n        strength: avgStrength,\n      });\n    } else {\n      // Unidirectional\n      result.push({\n        primary: rel,\n        reverse: undefined,\n        isBidirectional: false,\n        relationshipIds: [relId],\n        strength: rel.strength ?? 0.5,\n      });\n    }\n  }\n\n  return result;\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "CollapsedRelationship[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantEvents", "name": "getRelevantEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Get events involving assigned entities.\n * Returns ALL matching events - UI is responsible for limiting final selection.\n */\nexport function getRelevantEvents(\n  assignments: ChronicleRoleAssignment[],\n  allEvents: NarrativeEventContext[]\n): NarrativeEventContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n\n  // Return all events involving assigned entities - no artificial limit\n  // Final selection is limited to MAX_CHRONICLE_EVENTS in the UI\n  return allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && assignedIds.has(e.subjectId)) ||\n      (e.objectId && assignedIds.has(e.objectId))\n  );\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "NarrativeEventContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::isProminenceOnlyChronicleEvent", "name": "isProminenceOnlyChronicleEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Check if an event is prominence-only based on its stateChanges.\n * An event is \"prominence-only\" if ALL of its state changes are\n * field === 'prominence' changes. These events are typically noise\n * (gradual prominence shifts) rather than narratively interesting.\n */\nexport function isProminenceOnlyChronicleEvent(\n  event: NarrativeEventContext,\n  assignedEntityIds: Set<string>\n): boolean {\n  // Events with no stateChanges are NOT prominence-only (they might be actions, relationships, etc.)\n  if (!event.stateChanges || event.stateChanges.length === 0) {\n    return false;\n  }\n\n  // Only consider stateChanges for assigned entities\n  const relevantChanges = event.stateChanges.filter((sc) => assignedEntityIds.has(sc.entityId));\n\n  // If no relevant changes, not prominence-only\n  if (relevantChanges.length === 0) {\n    return false;\n  }\n\n  // Check if ALL relevant changes are prominence changes\n  return relevantChanges.every((sc) => sc.field === \"prominence\");\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::filterChronicleEvents", "name": "filterChronicleEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Filter chronicle events by quality criteria.\n * Applies significance threshold and prominence-only exclusion.\n *\n * @param events - Events to filter (typically from getRelevantEvents)\n * @param assignedEntityIds - Set of assigned entity IDs for prominence check\n * @param options - Filter options\n * @returns Filtered events\n */\nexport function filterChronicleEvents(\n  events: NarrativeEventContext[],\n  assignedEntityIds: Set<string>,\n  options: ChronicleEventFilterOptions = {}\n): NarrativeEventContext[] {\n  const { minSignificance = 0, excludeProminenceOnly = true } = options;\n\n  return events.filter((event) => {\n    // Filter by significance threshold\n    if (event.significance < minSignificance) {\n      return false;\n    }\n\n    // Exclude prominence-only events if configured\n    if (excludeProminenceOnly && isProminenceOnlyChronicleEvent(event, assignedEntityIds)) {\n      return false;\n    }\n\n    return true;\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "options", "type": "ChronicleEventFilterOptions", "optional": true}], "returnType": "NarrativeEventContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildWizardSelectionContext", "name": "buildWizardSelectionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build the selection context for the wizard given an entry point.\n * Returns candidates within 2-hop neighborhood.\n */\nexport function buildWizardSelectionContext(\n  entryPoint: EntityContext,\n  allEntities: EntityContext[],\n  allRelationships: RelationshipContext[],\n  allEvents: NarrativeEventContext[],\n  style: NarrativeStyle,\n  options: SelectionContextOptions = {}\n): WizardSelectionContext {\n  const { includeErasInNeighborhood = false } = options;\n\n  // Build set of era entity IDs for filtering\n  const eraEntityIds = new Set(allEntities.filter((e) => e.kind === \"era\").map((e) => e.id));\n\n  // Filter relationships for graph traversal - exclude those involving era nodes\n  const graphRelationships = includeErasInNeighborhood\n    ? allRelationships\n    : allRelationships.filter((r) => !eraEntityIds.has(r.src) && !eraEntityIds.has(r.dst));\n\n  // Build 2-hop neighborhood\n  const neighborGraph = buildNeighborGraph(graphRelationships, entryPoint.id, 2);\n\n  // Filter entities to those in the neighborhood\n  const neighborEntities = allEntities.filter((e) => neighborGraph.ids.has(e.id));\n\n  // Filter out era entities \u2014 they're time periods, not cast members\n  const filteredCandidates = neighborEntities.filter((e) => e.kind !== \"era\");\n\n  // Ensure entry point is included\n  const candidates = filteredCandidates.some((e) => e.id === entryPoint.id)\n    ? filteredCandidates\n    : [entryPoint, ...filteredCandidates];\n\n  // Get relationships between candidates\n  const candidateIds = new Set(candidates.map((e) => e.id));\n  const candidateRelationships = allRelationships.filter(\n    (r) => candidateIds.has(r.src) && candidateIds.has(r.dst)\n  );\n\n  // Get events involving candidates + world-structuring events (always available)\n  const candidateEvents = allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && candidateIds.has(e.subjectId)) ||\n      (e.objectId && candidateIds.has(e.objectId))\n  );\n\n  return {\n    entryPoint,\n    candidates,\n    candidateRelationships,\n    candidateEvents,\n    distances: neighborGraph.distances,\n  };\n}", "parameters": [{"name": "entryPoint", "type": "EntityContext", "optional": false}, {"name": "allEntities", "type": "EntityContext[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "options", "type": "SelectionContextOptions", "optional": true}], "returnType": "WizardSelectionContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeStoryPotential", "name": "computeStoryPotential", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Compute story potential for a single entity\n */\nexport function computeStoryPotential(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[],\n  maxValues: {\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }\n): StoryPotential {\n  const entity = entities.find((e) => e.id === entityId);\n  if (!entity) {\n    return {\n      connections: 0,\n      temporalSpan: 0,\n      roleDiversity: 0,\n      eventInvolvement: 0,\n      prominence: 0,\n      overallScore: 0,\n    };\n  }\n\n  // Count connections\n  const entityRels = relationships.filter((r) => r.src === entityId || r.dst === entityId);\n  const connectionCount = entityRels.length;\n\n  // Get connected entity kinds\n  const connectedIds = new Set<string>();\n  for (const rel of entityRels) {\n    connectedIds.add(rel.src === entityId ? rel.dst : rel.src);\n  }\n  const connectedKinds = new Set<string>();\n  for (const id of connectedIds) {\n    const connected = entities.find((e) => e.id === id);\n    if (connected) connectedKinds.add(connected.kind);\n  }\n\n  // Count events and get eras\n  const entityEvents = events.filter(\n    (e) =>\n      e.subjectId === entityId ||\n      e.objectId === entityId ||\n      e.participants?.some((p) => p.id === entityId)\n  );\n  const eventCount = entityEvents.length;\n  const eraIds = new Set(entityEvents.map((e) => e.era));\n\n  // Normalize values\n  const connections =\n    maxValues.maxConnections > 0 ? Math.min(connectionCount / maxValues.maxConnections, 1) : 0;\n\n  const temporalSpan = maxValues.maxEras > 0 ? Math.min(eraIds.size / maxValues.maxEras, 1) : 0;\n\n  const roleDiversity =\n    maxValues.maxKinds > 0 ? Math.min(connectedKinds.size / maxValues.maxKinds, 1) : 0;\n\n  const eventInvolvement =\n    maxValues.maxEvents > 0 ? Math.min(eventCount / maxValues.maxEvents, 1) : 0;\n\n  const prominence = normalizeProminence(entity.prominence);\n\n  // Compute weighted score\n  const overallScore =\n    WEIGHTS.connections * connections +\n    WEIGHTS.temporalSpan * temporalSpan +\n    WEIGHTS.roleDiversity * roleDiversity +\n    WEIGHTS.eventInvolvement * eventInvolvement +\n    WEIGHTS.prominence * prominence;\n\n  return {\n    connections,\n    temporalSpan,\n    roleDiversity,\n    eventInvolvement,\n    prominence,\n    overallScore,\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "maxValues", "type": "{\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }", "optional": false}], "returnType": "StoryPotential"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeAllStoryPotentials", "name": "computeAllStoryPotentials", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "export function computeAllStoryPotentials(\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[]\n): Map<string, EntityWithPotential> {\n  const rawStats = new Map<string, RawEntityStats>();\n  let maxConnections = 0;\n  let maxEvents = 0;\n  let maxKinds = 0;\n  let maxEras = 0;\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = computeEntityRawStats(entity, entities, relationships, events);\n    rawStats.set(entity.id, stats);\n    maxConnections = Math.max(maxConnections, stats.connectionCount);\n    maxEvents = Math.max(maxEvents, stats.eventCount);\n    maxKinds = Math.max(maxKinds, stats.connectedKinds.length);\n    maxEras = Math.max(maxEras, stats.eraIds.length);\n  }\n\n  const result = new Map<string, EntityWithPotential>();\n  const maxValues = { maxConnections, maxEvents, maxKinds, maxEras };\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = rawStats.get(entity.id);\n    if (!stats) continue;\n\n    const potential = computeStoryPotential(entity.id, entities, relationships, events, maxValues);\n    result.set(entity.id, { ...entity, potential, ...stats });\n  }\n\n  return result;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "Map<string, EntityWithPotential>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getConnectedEntities", "name": "getConnectedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get 1-hop connected entities for mini constellation\n */\nexport function getConnectedEntities(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): ConnectedEntity[] {\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const connected: ConnectedEntity[] = [];\n\n  for (const rel of relationships) {\n    let connectedId: string | null = null;\n\n    if (rel.src === entityId) {\n      connectedId = rel.dst;\n    } else if (rel.dst === entityId) {\n      connectedId = rel.src;\n    }\n\n    if (connectedId) {\n      const entity = entityMap.get(connectedId);\n      if (entity && entity.kind !== \"era\") {\n        // Avoid duplicates but track all relationship kinds\n        const existing = connected.find((c) => c.id === connectedId);\n        if (!existing) {\n          connected.push({\n            id: connectedId,\n            name: entity.name,\n            kind: entity.kind,\n            relationshipKind: rel.kind,\n            strength: rel.strength,\n          });\n        }\n      }\n    }\n  }\n\n  return connected;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "ConnectedEntity[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getUniqueKinds", "name": "getUniqueKinds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get unique entity kinds from a list\n */\nexport function getUniqueKinds(entities: EntityContext[]): string[] {\n  const kinds = new Set<string>();\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") {\n      kinds.add(entity.kind);\n    }\n  }\n  return [...kinds].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::scoreToRating", "name": "scoreToRating", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Convert story score to visual rating (1-5 dots)\n */\nexport function scoreToRating(score: number): number {\n  return Math.max(1, Math.min(5, Math.round(score * 5)));\n}", "parameters": [{"name": "score", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEraRanges", "name": "getEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Convert eras to era ranges for timeline display.\n * Uses the actual era boundaries - no computation.\n */\nexport function getEraRanges(\n  eras: Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n): EraRange[] {\n  return eras.map((era, i) => ({\n    id: era.id,\n    name: era.name,\n    startTick: era.startTick,\n    endTick: era.endTick ?? era.startTick + 100, // fallback for ongoing era\n    color: ERA_COLORS[i % ERA_COLORS.length],\n  }));\n}", "parameters": [{"name": "eras", "type": "Array<{ id: string; name: string; startTick: number; endTick: number | null }>", "optional": false}], "returnType": "EraRange[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareTimelineEvents", "name": "prepareTimelineEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Transform events into timeline format\n */\nexport function prepareTimelineEvents(\n  events: NarrativeEventContext[],\n  entryPointId: string | null,\n  assignedEntityIds: Set<string>,\n  selectedEventIds: Set<string>\n): TimelineEvent[] {\n  return events.map((event) => {\n    const participants = event.participants || [];\n    const participantIds = new Set(participants.map((p) => p.id));\n\n    // Check if entry point or subject/object\n    const involvesEntryPoint =\n      entryPointId !== null &&\n      (event.subjectId === entryPointId ||\n        event.objectId === entryPointId ||\n        participantIds.has(entryPointId));\n\n    // Check if any cast member is involved\n    const involvesCastMember = [...assignedEntityIds].some(\n      (id) => event.subjectId === id || event.objectId === id || participantIds.has(id)\n    );\n\n    return {\n      id: event.id,\n      tick: event.tick,\n      eraId: event.era,\n      headline: event.headline,\n      description: event.description,\n      significance: event.significance,\n      involvesEntryPoint,\n      involvesCastMember,\n      participantCount: participants.length + (event.subjectId ? 1 : 0) + (event.objectId ? 1 : 0),\n      eventKind: event.eventKind,\n      selected: selectedEventIds.has(event.id),\n    };\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string | null", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "selectedEventIds", "type": "Set<string>", "optional": false}], "returnType": "TimelineEvent[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeIntensityCurve", "name": "computeIntensityCurve", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Compute intensity curve for sparkline\n * Uses a rolling window to smooth the data\n */\nexport function computeIntensityCurve(\n  events: NarrativeEventContext[],\n  windowSize: number = 10\n): IntensityPoint[] {\n  if (events.length === 0) return [];\n\n  // Sort by tick\n  const sorted = [...events].sort((a, b) => a.tick - b.tick);\n  const minTick = sorted[0].tick;\n  const maxTick = sorted[sorted.length - 1].tick;\n\n  // Create intensity map\n  const tickSignificance = new Map<number, number>();\n  for (const event of sorted) {\n    const current = tickSignificance.get(event.tick) || 0;\n    tickSignificance.set(event.tick, current + event.significance);\n  }\n\n  // Generate points at regular intervals\n  const numPoints = Math.min(50, maxTick - minTick + 1);\n  const step = Math.max(1, Math.floor((maxTick - minTick) / numPoints));\n  const points: IntensityPoint[] = [];\n\n  for (let tick = minTick; tick <= maxTick; tick += step) {\n    // Sum significance in window around this tick\n    let intensity = 0;\n    const halfWindow = Math.floor(windowSize / 2);\n\n    for (const [t, sig] of tickSignificance) {\n      if (t >= tick - halfWindow && t <= tick + halfWindow) {\n        // Weight by distance from center\n        const distance = Math.abs(t - tick);\n        const weight = 1 - distance / (halfWindow + 1);\n        intensity += sig * weight;\n      }\n    }\n\n    points.push({ tick, intensity });\n  }\n\n  // Normalize to 0-1\n  const maxIntensity = Math.max(...points.map((p) => p.intensity), 0.001);\n  return points.map((p) => ({\n    tick: p.tick,\n    intensity: p.intensity / maxIntensity,\n  }));\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "windowSize", "type": "number", "optional": true}], "returnType": "IntensityPoint[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventsInRange", "name": "getEventsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get events within a tick range\n */\nexport function getEventsInRange(\n  events: TimelineEvent[],\n  startTick: number,\n  endTick: number\n): TimelineEvent[] {\n  return events.filter((e) => e.tick >= startTick && e.tick <= endTick);\n}", "parameters": [{"name": "events", "type": "TimelineEvent[]", "optional": false}, {"name": "startTick", "type": "number", "optional": false}, {"name": "endTick", "type": "number", "optional": false}], "returnType": "TimelineEvent[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getTimelineExtent", "name": "getTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get timeline extent from era boundaries.\n * Returns [0, maxEndTick] - the full simulation range.\n */\nexport function getTimelineExtent(\n  eras: Array<{ startTick: number; endTick: number | null }>\n): [number, number] {\n  if (eras.length === 0) return [0, 100];\n\n  const maxTick = Math.max(...eras.map((e) => e.endTick ?? e.startTick + 100));\n\n  return [0, maxTick];\n}", "parameters": [{"name": "eras", "type": "Array<{ startTick: number; endTick: number | null }>", "optional": false}], "returnType": "[number, number]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::tickToX", "name": "tickToX", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale a tick value to SVG x coordinate\n */\nexport function tickToX(\n  tick: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  return padding + ((tick - minTick) / range) * usableWidth;\n}", "parameters": [{"name": "tick", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::xToTick", "name": "xToTick", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale SVG x coordinate back to tick value\n */\nexport function xToTick(\n  x: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  const normalized = (x - padding) / usableWidth;\n  return Math.round(minTick + normalized * range);\n}", "parameters": [{"name": "x", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventFill", "name": "getEventFill", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get fill pattern based on involvement level\n */\nexport function getEventFill(event: TimelineEvent): string {\n  if (event.involvesEntryPoint) return \"var(--accent-color)\";\n  if (event.involvesCastMember) return \"var(--accent-color-muted, rgba(99, 102, 241, 0.6))\";\n  return \"var(--text-muted)\";\n}", "parameters": [{"name": "event", "type": "TimelineEvent", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventHeight", "name": "getEventHeight", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get event height based on significance (for visual weight)\n */\nexport function getEventHeight(\n  significance: number,\n  maxHeight: number = 40,\n  minHeight: number = 16\n): number {\n  return minHeight + significance * (maxHeight - minHeight);\n}", "parameters": [{"name": "significance", "type": "number", "optional": false}, {"name": "maxHeight", "type": "number", "optional": true}, {"name": "minHeight", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerShape", "name": "getCastMarkerShape", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get SVG path data for a cast marker based on entity kind.\n * Paths are centered at (0,0) \u2014 use transform to position.\n */\nexport function getCastMarkerShape(kind: string): { path: string; size: number } {\n  switch (kind) {\n    case \"person\":\n      // Diamond\n      return { path: \"M 0 -4 L 4 0 L 0 4 L -4 0 Z\", size: 8 };\n    case \"faction\":\n      // Circle\n      return { path: \"M 0 -3.5 A 3.5 3.5 0 1 1 0 3.5 A 3.5 3.5 0 1 1 0 -3.5 Z\", size: 7 };\n    case \"location\":\n      // Square\n      return { path: \"M -3 -3 L 3 -3 L 3 3 L -3 3 Z\", size: 6 };\n    case \"occurrence\":\n      // 6-pointed star (outer=4, inner=2)\n      return {\n        path: \"M 0 -4 L 1 -1.7 L 3.5 -2 L 2 0 L 3.5 2 L 1 1.7 L 0 4 L -1 1.7 L -3.5 2 L -2 0 L -3.5 -2 L -1 -1.7 Z\",\n        size: 8,\n      };\n    default:\n      // Triangle\n      return { path: \"M 0 -3.5 L 3.5 3 L -3.5 3 Z\", size: 7 };\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "{ path: string; size: number }"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerColor", "name": "getCastMarkerColor", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get color for a cast marker based on entity kind.\n * Uses a pastel palette distinct from event card fills.\n */\nexport function getCastMarkerColor(kind: string): string {\n  switch (kind) {\n    case \"person\":\n      return \"#818cf8\";\n    case \"faction\":\n      return \"#a78bfa\";\n    case \"location\":\n      return \"#34d399\";\n    case \"occurrence\":\n      return \"#fbbf24\";\n    case \"ability\":\n      return \"#f472b6\";\n    case \"rule\":\n      return \"#22d3ee\";\n    default:\n      return \"#9ca3af\";\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareCastMarkers", "name": "prepareCastMarkers", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Build cast markers from role assignments, lens, and entity data.\n * Includes the entry point and lens (if provided) and dedupes by entity ID.\n */\nexport function prepareCastMarkers(\n  roleAssignments: ChronicleRoleAssignment[],\n  entityMap: Map<string, EntityContext>,\n  entryPoint?: EntityContext | null,\n  lens?: NarrativeLens | null\n): CastMarker[] {\n  const seen = new Set<string>();\n  const markers: CastMarker[] = [];\n\n  if (entryPoint) {\n    seen.add(entryPoint.id);\n    markers.push({\n      entityId: entryPoint.id,\n      entityName: entryPoint.name,\n      entityKind: entryPoint.kind,\n      subtype: entryPoint.subtype,\n      createdAt: entryPoint.createdAt,\n      isPrimary: true,\n      isEntryPoint: true,\n      isLens: false,\n    });\n  }\n\n  if (lens && !seen.has(lens.entityId)) {\n    seen.add(lens.entityId);\n    const lensEntity = entityMap.get(lens.entityId);\n    if (lensEntity) {\n      markers.push({\n        entityId: lens.entityId,\n        entityName: lens.entityName,\n        entityKind: lens.entityKind,\n        subtype: lensEntity.subtype,\n        createdAt: lensEntity.createdAt,\n        isPrimary: false,\n        isEntryPoint: false,\n        isLens: true,\n      });\n    }\n  }\n\n  for (const assignment of roleAssignments) {\n    if (seen.has(assignment.entityId)) continue;\n    seen.add(assignment.entityId);\n\n    const entity = entityMap.get(assignment.entityId);\n    if (!entity) continue;\n\n    markers.push({\n      entityId: assignment.entityId,\n      entityName: assignment.entityName,\n      entityKind: assignment.entityKind,\n      subtype: entity.subtype,\n      createdAt: entity.createdAt,\n      role: assignment.role,\n      isPrimary: assignment.isPrimary,\n      isEntryPoint: false,\n      isLens: false,\n    });\n  }\n\n  markers.sort((a, b) => a.createdAt - b.createdAt);\n  return markers;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "entityMap", "type": "Map<string, EntityContext>", "optional": false}, {"name": "entryPoint", "type": "EntityContext | null", "optional": true}, {"name": "lens", "type": "NarrativeLens | null", "optional": true}], "returnType": "CastMarker[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeEraRanges", "name": "computeEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeEraRanges = (\n  _events: NarrativeEventContext[],\n  eras: Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>\n) =>\n  getEraRanges(\n    eras as Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n  )", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>", "optional": false}], "returnType": "EraRange[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeTimelineExtent", "name": "computeTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeTimelineExtent = (\n  _events: NarrativeEventContext[],\n  eras?: Array<{ endTick?: number | null; startTick?: number }>\n): [number, number] => {\n  if (!eras || eras.length === 0) return [0, 100];\n  return getTimelineExtent(eras as Array<{ startTick: number; endTick: number | null }>);\n}", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ endTick?: number | null; startTick?: number }>", "optional": true}], "returnType": "[number, number]"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleNav.ts::buildNavItem", "name": "buildNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleNav.ts", "sourceCode": "export function buildNavItem(record: ChronicleRecord): ChronicleNavItem {\n  const primaryCount = record.roleAssignments?.filter((r) => r.isPrimary).length || 0;\n  const supportingCount = (record.roleAssignments?.length || 0) - primaryCount;\n  const historianNoteCount = (record.historianNotes || []).filter(isNoteActive).length;\n  const displayName =\n    record.title ||\n    (record.roleAssignments?.length > 0\n      ? record.roleAssignments\n          .filter((r) => r.isPrimary)\n          .map((r) => r.entityName)\n          .join(\" & \") || record.roleAssignments[0]?.entityName\n      : \"\") ||\n    \"Untitled Chronicle\";\n\n  const backportProgress = computeBackportProgress(record);\n\n  let focalEraOrder: number | undefined;\n  if (typeof record.temporalContext?.focalEra?.order === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.order;\n  } else if (typeof record.temporalContext?.focalEra?.startTick === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.startTick;\n  }\n\n  return {\n    id: record.chronicleId,\n    chronicleId: record.chronicleId,\n    name: displayName,\n    status: deriveStatus(record),\n    title: record.title,\n    format: record.format,\n    focusType: record.focusType,\n    primaryCount,\n    supportingCount,\n    narrativeStyleId: record.narrativeStyleId,\n    narrativeStyleName: record.narrativeStyle?.name,\n    perspectiveSynthesis: !!record.perspectiveSynthesis,\n    combineInstructions: !!record.combineInstructions,\n    coverImageComplete: record.coverImage?.status === \"complete\",\n    backportDone: backportProgress.done,\n    backportTotal: backportProgress.total,\n    historianNoteCount,\n    lens: record.lens ? { entityName: record.lens.entityName } : undefined,\n    imageRefCompleteCount:\n      record.imageRefs?.refs?.filter(\n        (r: { type: string; status?: string }) =>\n          r.type === \"prompt_request\" && r.status === \"complete\"\n      ).length || 0,\n    failureStep: record.failureStep,\n    createdAt: record.createdAt || 0,\n    updatedAt: record.updatedAt || 0,\n    selectedEntityIds: record.selectedEntityIds,\n    roleAssignments: record.roleAssignments,\n    wordCount: (record.finalContent || record.assembledContent || \"\")\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean).length,\n    focalEraName: record.temporalContext?.focalEra?.name,\n    focalEraOrder,\n    focalEraStartTick: record.temporalContext?.focalEra?.startTick,\n    eraYear: record.eraYear,\n    hasTemporalNarrative: !!record.perspectiveSynthesis?.temporalNarrative,\n    hasTemporalCheck: !!record.temporalCheckReport,\n    hasHistorianPrep: !!record.historianPrep,\n    hasSummary: !!record.summary,\n    toneRanking: record.toneRanking?.ranking,\n    assignedTone: record.assignedTone,\n    eraNarrativeWeight: record.narrativeStyle?.eraNarrativeWeight,\n  };\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::generateChronicleId", "name": "generateChronicleId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Pure functions (no DB access)\n// ============================================================================\n\n/**\n * Generate a unique chronicle ID\n */\nexport function generateChronicleId(): string {\n  return `chronicle_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveTitleFromRoles", "name": "deriveTitleFromRoles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Derive a title from role assignments\n */\nexport function deriveTitleFromRoles(roleAssignments: ChronicleRoleAssignment[]): string {\n  const primary = roleAssignments.filter((r) => r.isPrimary);\n  if (primary.length === 0) {\n    const first = roleAssignments[0];\n    return first ? `Chronicle of ${first.entityName}` : \"Untitled Chronicle\";\n  }\n  if (primary.length === 1) {\n    return `Chronicle of ${primary[0].entityName}`;\n  }\n  if (primary.length === 2) {\n    return `${primary[0].entityName} and ${primary[1].entityName}`;\n  }\n  return `${primary[0].entityName} and ${primary.length - 1} others`;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveFocusType", "name": "deriveFocusType", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Determine focus type from role assignments\n */\nexport function deriveFocusType(roleAssignments: ChronicleRoleAssignment[]): ChronicleFocusType {\n  const primaryCount = roleAssignments.filter((r) => r.isPrimary).length;\n  if (primaryCount <= 1) return \"single\";\n  return \"ensemble\";\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "ChronicleFocusType"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicleShell", "name": "createChronicleShell", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Create operations\n// ============================================================================\n\n/**\n * Create a shell chronicle record before generation starts.\n * This provides immediate UI feedback while generation is in progress.\n */\nexport async function createChronicleShell(\n  chronicleId: string,\n  metadata: ChronicleShellMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    generationSampling: metadata.generationSampling,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation state - starts as 'generating'\n    status: \"generating\",\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: 0,\n    totalActualCost: 0,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleShellMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicle", "name": "createChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Create a chronicle record (single-shot generation, goes directly to assembly_ready)\n */\nexport async function createChronicle(\n  chronicleId: string,\n  metadata: ChronicleMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const assembledAt = Date.now();\n  const activeVersionId = createUniqueVersionId(new Set(), assembledAt);\n  const initialVersion: ChronicleGenerationVersion = {\n    versionId: activeVersionId,\n    generatedAt: assembledAt,\n    content: metadata.assembledContent,\n    wordCount: countWords(metadata.assembledContent),\n    model: metadata.model,\n    sampling: metadata.generationSampling,\n    systemPrompt: metadata.generationSystemPrompt,\n    userPrompt: metadata.generationUserPrompt,\n    step: \"generate\",\n  };\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation result\n    selectionSummary: metadata.selectionSummary,\n    perspectiveSynthesis: metadata.perspectiveSynthesis,\n    generationSystemPrompt: metadata.generationSystemPrompt,\n    generationUserPrompt: metadata.generationUserPrompt,\n    generationSampling: metadata.generationSampling,\n    generationStep: \"generate\",\n    generationHistory: [initialVersion],\n    activeVersionId,\n    status: \"assembly_ready\",\n    assembledContent: metadata.assembledContent,\n    assembledAt,\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: metadata.cost.estimated,\n    totalActualCost: metadata.cost.actual,\n    totalInputTokens: metadata.cost.inputTokens,\n    totalOutputTokens: metadata.cost.outputTokens,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssembly", "name": "updateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read-modify-write operations\n// ============================================================================\n\n/**\n * Update chronicle with assembled content (regeneration)\n */\nexport async function updateChronicleAssembly(\n  chronicleId: string,\n  assembledContent: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.updatedAt = Date.now();\n  record.activeVersionId = nextVersion.versionId;\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::regenerateChronicleAssembly", "name": "regenerateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Replace chronicle assembled content via sampling regeneration.\n * Appends a new version to generationHistory and clears refinements.\n */\nexport async function regenerateChronicleAssembly(\n  chronicleId: string,\n  updates: {\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is already accepted`);\n  }\n  if (!updates.sampling) {\n    throw new Error(`Chronicle ${chronicleId} missing sampling for regeneration`);\n  }\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: updates.assembledContent,\n    wordCount: countWords(updates.assembledContent),\n    model: updates.model,\n    sampling: updates.sampling,\n    systemPrompt: updates.systemPrompt,\n    userPrompt: updates.userPrompt,\n    step: updates.step,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = updates.assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.generationSystemPrompt = updates.systemPrompt;\n  record.generationUserPrompt = updates.userPrompt;\n  record.generationSampling = updates.sampling;\n  record.generationStep = updates.step;\n  record.activeVersionId = nextVersion.versionId;\n\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.editVersion = 0;\n  record.editedAt = undefined;\n\n  record.totalEstimatedCost += updates.cost.estimated;\n  record.totalActualCost += updates.cost.actual;\n  record.totalInputTokens += updates.cost.inputTokens;\n  record.totalOutputTokens += updates.cost.outputTokens;\n  record.model = updates.model;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEdit", "name": "updateChronicleEdit", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with revised content (post-validation edits)\n */\nexport async function updateChronicleEdit(\n  chronicleId: string,\n  assembledContent: string,\n  cost?: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.editedAt = generatedAt;\n  record.editVersion = (record.editVersion || 0) + 1;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.status = \"editing\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  if (cost) {\n    record.totalEstimatedCost += cost.estimated;\n    record.totalActualCost += cost.actual;\n    record.totalInputTokens += cost.inputTokens;\n    record.totalOutputTokens += cost.outputTokens;\n  }\n  record.activeVersionId = nextVersion.versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFailure", "name": "updateChronicleFailure", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as failed (worker error)\n */\nexport async function updateChronicleFailure(\n  chronicleId: string,\n  step: ChronicleStep,\n  reason: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"failed\";\n  record.failureStep = step;\n  record.failureReason = reason;\n  record.failedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "step", "type": "ChronicleStep", "optional": false}, {"name": "reason", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCohesion", "name": "updateChronicleCohesion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cohesion report (validation complete)\n */\nexport async function updateChronicleCohesion(\n  chronicleId: string,\n  cohesionReport: CohesionReport,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.cohesionReport = cohesionReport;\n  record.validatedAt = Date.now();\n  record.status = \"validation_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.validationStale = false;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "cohesionReport", "type": "CohesionReport", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleComparisonReport", "name": "updateChronicleComparisonReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Store a version comparison report (text analysis, no new draft).\n */\nexport async function updateChronicleComparisonReport(\n  chronicleId: string,\n  report: string,\n  combineInstructions?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.comparisonReport = report;\n  record.comparisonReportGeneratedAt = Date.now();\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalCheckReport", "name": "updateChronicleTemporalCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleTemporalCheckReport(\n  chronicleId: string,\n  report: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.temporalCheckReport = report;\n  record.temporalCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleQuickCheckReport", "name": "updateChronicleQuickCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleQuickCheckReport(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").QuickCheckReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.quickCheckReport = report;\n  record.quickCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").QuickCheckReport", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFactCoverage", "name": "updateChronicleFactCoverage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle fact coverage analysis report\n */\nexport async function updateChronicleFactCoverage(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").FactCoverageReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.factCoverageReport = report;\n  record.factCoverageReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").FactCoverageReport", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::repairFactCoverageWasFaceted", "name": "repairFactCoverageWasFaceted", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * One-shot fixup: recompute wasFaceted on all stored factCoverageReports\n * using perspectiveSynthesis.facets[].factId instead of fuzzy text matching.\n */\nexport async function repairFactCoverageWasFaceted(): Promise<number> {\n  const all = await db.chronicles.toArray();\n  let patched = 0;\n  for (const record of all) {\n    if (!record.factCoverageReport?.entries?.length) continue;\n    const facetedIds = new Set(\n      (record.perspectiveSynthesis?.facets ?? []).map((f: { factId: string }) => f.factId)\n    );\n    let changed = false;\n    for (const entry of record.factCoverageReport.entries) {\n      const correct = facetedIds.has(entry.factId);\n      if (entry.wasFaceted !== correct) {\n        entry.wasFaceted = correct;\n        changed = true;\n      }\n    }\n    if (changed) {\n      record.updatedAt = Date.now();\n      await db.chronicles.put(record);\n      patched++;\n    }\n  }\n  console.log(`[repairFactCoverageWasFaceted] Patched ${patched} chronicles`);\n  return patched;\n}", "parameters": [], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeCorpusFactStrength", "name": "computeCorpusFactStrength", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute corpus-wide fact strength scores from all chronicles with coverage reports.\n * Returns a Map of factId \u2192 strength percentage (0-100).\n * Weighted: integral=3, prevalent=2, mentioned=1, missing=0, divided by max possible.\n */\nexport async function computeCorpusFactStrength(\n  simulationRunId: string\n): Promise<Map<string, number>> {\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const totals = new Map<string, { weighted: number; count: number }>();\n\n  const ratingWeight: Record<string, number> = {\n    integral: 3,\n    prevalent: 2,\n    mentioned: 1,\n    missing: 0,\n  };\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.factCoverageReport?.entries?.length) continue;\n    for (const entry of chronicle.factCoverageReport.entries) {\n      const agg = totals.get(entry.factId) || { weighted: 0, count: 0 };\n      agg.weighted += ratingWeight[entry.rating] ?? 0;\n      agg.count += 1;\n      totals.set(entry.factId, agg);\n    }\n  }\n\n  const result = new Map<string, number>();\n  for (const [factId, agg] of totals) {\n    result.set(factId, agg.count > 0 ? Math.round((agg.weighted / (agg.count * 3)) * 100) : 0);\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, number>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeAnnotationReinforcementCounts", "name": "computeAnnotationReinforcementCounts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Count how many annotations have reinforced each canon fact.\n * Scans both chronicle.reinforcedFacts and entity.enrichment.reinforcedFacts.\n */\nexport async function computeAnnotationReinforcementCounts(\n  simulationRunId: string\n): Promise<ReinforcementCounts> {\n  const counts = new Map<string, number>();\n  let totalAnnotationsWithGuidance = 0;\n\n  // Chronicle reinforcements\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const c of chronicles) {\n    if (!c.reinforcedFacts?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of c.reinforcedFacts) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  // Entity reinforcements\n  const entities = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const e of entities) {\n    const rf = e.enrichment?.reinforcedFacts;\n    if (!rf?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of rf) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  return { counts, totalAnnotationsWithGuidance };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ReinforcementCounts>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTertiaryCast", "name": "updateChronicleTertiaryCast", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle tertiary cast (detected entity mentions not in declared cast)\n */\nexport async function updateChronicleTertiaryCast(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").TertiaryCastEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.tertiaryCast = entries;\n  record.tertiaryCastDetectedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").TertiaryCastEntry[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianPrep", "name": "updateChronicleHistorianPrep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with historian prep brief\n */\nexport async function updateChronicleHistorianPrep(\n  chronicleId: string,\n  historianPrep: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianPrep = historianPrep;\n  record.historianPrepGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianPrep", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleSummary", "name": "updateChronicleSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with summary and title refinement\n */\nexport async function updateChronicleSummary(\n  chronicleId: string,\n  summary: string,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.summary = summary;\n  record.summaryGeneratedAt = Date.now();\n  record.summaryModel = model;\n  record.summaryTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTitle", "name": "updateChronicleTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with title generation results.\n * Always writes to pending fields \u2014 user must accept via modal.\n */\nexport async function updateChronicleTitle(\n  chronicleId: string,\n  title: string,\n  candidates: string[],\n  fragments: string[],\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = title;\n  record.pendingTitleCandidates = candidates;\n  record.pendingTitleFragments = fragments;\n  record.titleFragments = fragments;\n  record.titleGeneratedAt = Date.now();\n  record.titleModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "title", "type": "string", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "fragments", "type": "string[]", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptPendingTitle", "name": "acceptPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Accept a pending title\n */\nexport async function acceptPendingTitle(chronicleId: string, chosenTitle?: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.pendingTitle) throw new Error(`No pending title for chronicle ${chronicleId}`);\n\n  record.title = chosenTitle || record.pendingTitle;\n  record.titleCandidates = record.pendingTitleCandidates;\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "chosenTitle", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::rejectPendingTitle", "name": "rejectPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reject a pending title on a published chronicle\n */\nexport async function rejectPendingTitle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRefs", "name": "updateChronicleImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with image refs refinement\n */\nexport async function updateChronicleImageRefs(\n  chronicleId: string,\n  imageRefs: ChronicleImageRefs,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.imageRefsGeneratedAt = Date.now();\n  record.imageRefsModel = model;\n  record.imageRefsTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRef", "name": "updateChronicleImageRef", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleImageRef(\n  chronicleId: string,\n  refId: string,\n  updates: {\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const refIndex = record.imageRefs.refs.findIndex((r) => r.refId === refId);\n  if (refIndex === -1) {\n    throw new Error(`Image ref ${refId} not found in chronicle ${chronicleId}`);\n  }\n\n  const ref = record.imageRefs.refs[refIndex];\n  const wantsPromptUpdates =\n    updates.status !== undefined ||\n    updates.generatedImageId !== undefined ||\n    updates.error !== undefined ||\n    updates.sceneDescription !== undefined;\n\n  if (wantsPromptUpdates && ref.type !== \"prompt_request\") {\n    throw new Error(`Image ref ${refId} is not a prompt request`);\n  }\n\n  applyBaseImageRefUpdates(ref, updates);\n  if (ref.type === \"prompt_request\") {\n    applyPromptRequestUpdates(ref, updates);\n  }\n\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::applyImageRefSelections", "name": "applyImageRefSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Apply image ref selections after version change.\n * - 'reuse': Keep the ref as-is\n * - 'regenerate': Reset the ref (clear generated image, set status to pending)\n * - 'skip': Remove the ref entirely\n *\n * Also updates imageRefsTargetVersionId to the new version.\n */\nexport async function applyImageRefSelections(\n  chronicleId: string,\n  selections: Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>,\n  newTargetVersionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const selectionMap = new Map(selections.map((s) => [s.refId, s.action]));\n\n  // Filter and transform refs based on selections\n  const updatedRefs = record.imageRefs.refs\n    .filter((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      return action !== \"skip\";\n    })\n    .map((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      if (action === \"regenerate\" && ref.type === \"prompt_request\") {\n        // Reset prompt request refs for regeneration\n        return {\n          ...ref,\n          status: \"pending\" as const,\n          generatedImageId: undefined,\n          error: undefined,\n        };\n      }\n      return ref;\n    });\n\n  record.imageRefs = {\n    ...record.imageRefs,\n    refs: updatedRefs,\n  };\n  record.imageRefsTargetVersionId = newTargetVersionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "selections", "type": "Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>", "optional": false}, {"name": "newTargetVersionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImage", "name": "updateChronicleCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cover image scene description\n */\nexport async function updateChronicleCoverImage(\n  chronicleId: string,\n  coverImage: ChronicleCoverImage,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.coverImage = coverImage;\n  record.coverImageGeneratedAt = Date.now();\n  record.coverImageModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "coverImage", "type": "ChronicleCoverImage", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImageStatus", "name": "updateChronicleCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update cover image generation status (after image generation completes)\n */\nexport async function updateChronicleCoverImageStatus(\n  chronicleId: string,\n  updates: {\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.coverImage) throw new Error(`Chronicle ${chronicleId} has no cover image`);\n\n  record.coverImage.status = updates.status;\n  if (updates.generatedImageId !== undefined) {\n    record.coverImage.generatedImageId = updates.generatedImageId || undefined;\n  }\n  if (updates.error !== undefined) {\n    record.coverImage.error = updates.error || undefined;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalContext", "name": "updateChronicleTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle temporal context (e.g., post-publish corrections)\n */\nexport async function updateChronicleTemporalContext(\n  chronicleId: string,\n  temporalContext: ChronicleTemporalContext | undefined | null\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (temporalContext) {\n    record.temporalContext = temporalContext;\n  } else {\n    delete record.temporalContext;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "temporalContext", "type": "ChronicleTemporalContext | undefined | null", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::refreshEraSummariesInChronicles", "name": "refreshEraSummariesInChronicles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function refreshEraSummariesInChronicles(\n  simulationRunId: string,\n  currentEras: EraTemporalInfo[]\n): Promise<number> {\n  const summaryMap = new Map(currentEras.map((e) => [e.id, e.summary || \"\"]));\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const record of records) {\n    const changed = patchTemporalContext(record, summaryMap) || patchPerspectiveSynthesisFocalEra(record, summaryMap);\n    if (changed) {\n      record.updatedAt = Date.now();\n      toUpdate.push(record);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "currentEras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptChronicle", "name": "acceptChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as complete (user accepted)\n */\nexport async function acceptChronicle(\n  chronicleId: string,\n  options?: { finalContent?: string; acceptedVersionId?: string }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const fallbackActive = getLatestVersion(versions)?.versionId;\n  const activeVersionId = options?.acceptedVersionId || record.activeVersionId || fallbackActive;\n  const activeVersion = versions.find((v) => v.versionId === activeVersionId);\n  const acceptedVersionId = activeVersionId || record.acceptedVersionId;\n\n  record.finalContent = options?.finalContent ?? activeVersion?.content ?? record.assembledContent;\n  record.acceptedVersionId = acceptedVersionId;\n  record.activeVersionId = acceptedVersionId;\n  record.acceptedAt = Date.now();\n  record.status = \"complete\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "options", "type": "{ finalContent?: string; acceptedVersionId?: string }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::unpublishChronicle", "name": "unpublishChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Unpublish a completed chronicle, reverting it to assembly_ready.\n */\nexport async function unpublishChronicle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  delete record.finalContent;\n  delete record.acceptedAt;\n  delete record.acceptedVersionId;\n  record.status = \"assembly_ready\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleActiveVersion", "name": "updateChronicleActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update which generation version should be published when accepting.\n */\nexport async function updateChronicleActiveVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before changing versions`);\n  }\n\n  ensureChronicleVersions(record);\n  if (!record.generationHistory?.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCombineInstructions", "name": "updateChronicleCombineInstructions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Manually set or update combine instructions for a chronicle.\n */\nexport async function updateChronicleCombineInstructions(\n  chronicleId: string,\n  combineInstructions: string | undefined\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  } else {\n    delete record.combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string | undefined", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicleVersion", "name": "deleteChronicleVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a specific version from a chronicle's generation history.\n * If the deleted version was the current or active version, switches to the most recent remaining version.\n */\nexport async function deleteChronicleVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before deleting versions`);\n  }\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const matchIndex = versions.findIndex((v) => v.versionId === versionId);\n  if (matchIndex === -1) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  if (versions.length <= 1) {\n    throw new Error(`Cannot delete the only version of chronicle ${chronicleId}`);\n  }\n\n  const latest = getLatestVersion(versions);\n  const isCurrentVersion = latest?.versionId === versionId;\n  const remaining = versions.filter((v) => v.versionId !== versionId);\n\n  if (isCurrentVersion) {\n    const nextLatest = getLatestVersion(remaining);\n    if (!nextLatest) {\n      throw new Error(`Cannot delete current version with no history to restore`);\n    }\n    record.assembledContent = nextLatest.content;\n    record.assembledAt = nextLatest.generatedAt;\n    record.model = nextLatest.model || record.model;\n    record.generationSystemPrompt = nextLatest.systemPrompt;\n    record.generationUserPrompt = nextLatest.userPrompt;\n    record.generationSampling = nextLatest.sampling;\n    record.generationStep = nextLatest.step;\n  }\n\n  record.generationHistory = remaining;\n\n  if (record.activeVersionId === versionId) {\n    record.activeVersionId = getLatestVersion(remaining)?.versionId;\n  }\n  if (record.summaryTargetVersionId === versionId) {\n    record.summaryTargetVersionId = record.activeVersionId;\n  }\n  if (record.imageRefsTargetVersionId === versionId) {\n    record.imageRefsTargetVersionId = record.activeVersionId;\n  }\n\n  record.updatedAt = Date.now();\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEntityBackportStatus", "name": "updateChronicleEntityBackportStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Merge per-entity backport status entries into a chronicle's entityBackportStatus map.\n */\nexport async function updateChronicleEntityBackportStatus(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").EntityBackportEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  const existing = record.entityBackportStatus || {};\n  for (const entry of entries) {\n    existing[entry.entityId] = entry;\n  }\n  record.entityBackportStatus = existing;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").EntityBackportEntry[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianNotes", "name": "updateChronicleHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update historian notes on a chronicle.\n */\nexport async function updateChronicleHistorianNotes(\n  chronicleId: string,\n  historianNotes: HistorianNote[],\n  prompts?: { systemPrompt: string; userPrompt: string },\n  reinforcedFacts?: string[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianNotes = historianNotes;\n  if (reinforcedFacts) {\n    record.reinforcedFacts = reinforcedFacts;\n  }\n  if (prompts) {\n    record.historianReviewSystemPrompt = prompts.systemPrompt;\n    record.historianReviewUserPrompt = prompts.userPrompt;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianNotes", "type": "HistorianNote[]", "optional": false}, {"name": "prompts", "type": "{ systemPrompt: string; userPrompt: string }", "optional": true}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::startChronicleValidation", "name": "startChronicleValidation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Start validation step (user approved assembly)\n */\nexport async function startChronicleValidation(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"validating\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::batchUpdateChronicleEraYears", "name": "batchUpdateChronicleEraYears", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read operations\n// ============================================================================\n\n/**\n * Get a chronicle record\n */\n/**\n * Batch update historian-assigned era years for multiple chronicles.\n */\nexport async function batchUpdateChronicleEraYears(\n  assignments: Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>\n): Promise<number> {\n  const ids = assignments.map((a) => a.chronicleId);\n  const records = await db.chronicles.where(\"chronicleId\").anyOf(ids).toArray();\n  const recordMap = new Map(records.map((r) => [r.chronicleId, r]));\n  const now = Date.now();\n\n  const toUpdate: ChronicleRecord[] = [];\n  for (const assignment of assignments) {\n    const record = recordMap.get(assignment.chronicleId);\n    if (!record) continue;\n    record.eraYear = assignment.eraYear;\n    record.eraYearReasoning = assignment.eraYearReasoning;\n    record.updatedAt = now;\n    toUpdate.push(record);\n  }\n\n  if (toUpdate.length > 0) {\n    await db.chronicles.bulkPut(toUpdate);\n  }\n\n  return toUpdate.length;\n}", "parameters": [{"name": "assignments", "type": "Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChronicle", "name": "getChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function getChronicle(chronicleId: string): Promise<ChronicleRecord | undefined> {\n  const record = await db.chronicles.get(chronicleId);\n  if (record && ensureChronicleVersions(record)) {\n    await db.chronicles.put(record);\n  }\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChroniclesForSimulation", "name": "getChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Get all chronicles for a specific simulation run\n */\nexport async function getChroniclesForSimulation(\n  simulationRunId: string\n): Promise<ChronicleRecord[]> {\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const updates: ChronicleRecord[] = [];\n  for (const record of records) {\n    if (ensureChronicleVersions(record)) {\n      updates.push(record);\n    }\n  }\n  if (updates.length > 0) {\n    await db.chronicles.bulkPut(updates);\n  }\n  return records;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicle", "name": "deleteChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a chronicle\n */\nexport async function deleteChronicle(chronicleId: string): Promise<void> {\n  await db.chronicles.delete(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChroniclesForSimulation", "name": "deleteChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete all chronicles for a simulation run\n */\nexport async function deleteChroniclesForSimulation(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  if (chronicles.length === 0) return 0;\n\n  const ids = chronicles.map((c) => c.chronicleId);\n  await db.chronicles.bulkDelete(ids);\n  return chronicles.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::putChronicle", "name": "putChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Entity Rename Support\n// ============================================================================\n\n/**\n * Write a fully-updated chronicle record back to the database.\n * Used by the entity rename flow to persist chronicle patches.\n */\nexport async function putChronicle(record: ChronicleRecord): Promise<void> {\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getEntityUsageStats", "name": "getEntityUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Computed queries\n// ============================================================================\n\n/**\n * Compute entity usage statistics from existing chronicles.\n * Returns a map of entityId -> usage stats.\n */\nexport async function getEntityUsageStats(\n  simulationRunId: string\n): Promise<Map<string, EntityUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, EntityUsageStats>();\n\n  for (const chronicle of chronicles) {\n    // Only count chronicles that have been generated (not just shells)\n    if (chronicle.status === \"generating\") continue;\n\n    for (const entityId of chronicle.selectedEntityIds) {\n      const existing = stats.get(entityId);\n      if (existing) {\n        existing.usageCount += 1;\n        existing.chronicleIds.push(chronicle.chronicleId);\n      } else {\n        stats.set(entityId, {\n          entityId,\n          usageCount: 1,\n          chronicleIds: [chronicle.chronicleId],\n        });\n      }\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, EntityUsageStats>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getNarrativeStyleUsageStats", "name": "getNarrativeStyleUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute narrative style usage statistics from existing chronicles.\n * Returns a map of styleId -> usage stats.\n */\nexport async function getNarrativeStyleUsageStats(\n  simulationRunId: string\n): Promise<Map<string, NarrativeStyleUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, NarrativeStyleUsageStats>();\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.narrativeStyleId) continue;\n\n    const existing = stats.get(chronicle.narrativeStyleId);\n    if (existing) {\n      existing.usageCount += 1;\n      existing.chronicleIds.push(chronicle.chronicleId);\n    } else {\n      stats.set(chronicle.narrativeStyleId, {\n        styleId: chronicle.narrativeStyleId,\n        usageCount: 1,\n        chronicleIds: [chronicle.chronicleId],\n      });\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, NarrativeStyleUsageStats>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::reconcileBackportStatusFromEntities", "name": "reconcileBackportStatusFromEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function reconcileBackportStatusFromEntities(\n  simulationRunId: string,\n  entities: Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>\n): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const entityBackrefs = buildEntityBackrefIndex(entities);\n  const now = Date.now();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const chronicle of chronicles) {\n    const eligibleIds = getEligibleEntityIds(chronicle);\n    const newStatus: Record<string, import(\"../chronicleTypes\").EntityBackportEntry> = {};\n    for (const entityId of eligibleIds) {\n      const backrefSet = entityBackrefs.get(entityId);\n      if (backrefSet && backrefSet.has(chronicle.chronicleId)) {\n        newStatus[entityId] = { entityId, status: \"backported\", updatedAt: now };\n      }\n    }\n\n    if (hasBackportStatusChanged(chronicle.entityBackportStatus || {}, newStatus)) {\n      chronicle.entityBackportStatus = newStatus;\n      chronicle.updatedAt = now;\n      toUpdate.push(chronicle);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::resetAllBackportFlags", "name": "resetAllBackportFlags", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reset entityBackportStatus on all chronicles in a simulation.\n * Returns the count of chronicles that were updated.\n */\nexport async function resetAllBackportFlags(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const toUpdate = chronicles.filter((c) => {\n    const status = c.entityBackportStatus;\n    return status && Object.keys(status).length > 0;\n  });\n\n  if (toUpdate.length === 0) return 0;\n\n  const now = Date.now();\n  await db.chronicles.bulkPut(\n    toUpdate.map((c) => ({\n      ...c,\n      entityBackportStatus: {},\n      updatedAt: now,\n    }))\n  );\n\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleToneRanking", "name": "updateChronicleToneRanking", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Tone Ranking & Assignment\n// ============================================================================\n\nexport async function updateChronicleToneRanking(\n  chronicleId: string,\n  ranking: [string, string, string],\n  rationale: string,\n  cost?: number,\n  rationales?: Record<string, string>\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.toneRanking = {\n    ranking: ranking as [\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n    ],\n    rationale,\n    rationales,\n    generatedAt: Date.now(),\n    actualCost: cost,\n  };\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "ranking", "type": "[string, string, string]", "optional": false}, {"name": "rationale", "type": "string", "optional": false}, {"name": "cost", "type": "number", "optional": true}, {"name": "rationales", "type": "Record<string, string>", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssignedTone", "name": "updateChronicleAssignedTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleAssignedTone(\n  chronicleId: string,\n  tone: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.assignedTone = tone as import(\"../historianTypes\").HistorianTone;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::getChronicleFromStore", "name": "getChronicleFromStore", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Get a chronicle record imperatively (not a subscription).\n * For use in event handlers and callbacks.\n */\nexport function getChronicleFromStore(chronicleId: string): ChronicleRecord | undefined {\n  return useChronicleStore.getState().cache.get(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "ChronicleRecord | undefined"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::loadTree", "name": "loadTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function loadTree(\n  projectId: string,\n  simulationRunId: string\n): Promise<ContentTreeState | null> {\n  const record = await db.contentTrees.get([projectId, simulationRunId]);\n  return record ?? null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ContentTreeState | null>"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::saveTree", "name": "saveTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function saveTree(tree: ContentTreeState): Promise<void> {\n  await db.contentTrees.put(tree);\n}", "parameters": [{"name": "tree", "type": "ContentTreeState", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::deleteTree", "name": "deleteTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function deleteTree(projectId: string, simulationRunId: string): Promise<void> {\n  await db.contentTrees.delete([projectId, simulationRunId]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::getCoordinateState", "name": "getCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function getCoordinateState(\n  simulationRunId: string\n): Promise<CoordinateStateRecord | undefined> {\n  return db.coordinateStates.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CoordinateStateRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::upsertCoordinateState", "name": "upsertCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function upsertCoordinateState(\n  simulationRunId: string,\n  coordinateState: CoordinateState\n): Promise<void> {\n  await db.coordinateStates.put({\n    simulationRunId,\n    coordinateState,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "coordinateState", "type": "CoordinateState", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::generateCostId", "name": "generateCostId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function generateCostId(): string {\n  return `cost_${Date.now()}_${crypto.randomUUID().slice(0, 9)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::createCostRecord", "name": "createCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function createCostRecord(input: CostRecordInput): CostRecord {\n  return {\n    id: input.id ?? generateCostId(),\n    timestamp: input.timestamp ?? Date.now(),\n    projectId: input.projectId,\n    simulationRunId: input.simulationRunId,\n    entityId: input.entityId,\n    entityName: input.entityName,\n    entityKind: input.entityKind,\n    chronicleId: input.chronicleId,\n    type: input.type,\n    model: input.model,\n    estimatedCost: input.estimatedCost,\n    actualCost: input.actualCost,\n    inputTokens: input.inputTokens,\n    outputTokens: input.outputTokens,\n  };\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "CostRecord"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecord", "name": "saveCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecord(record: CostRecord): Promise<void> {\n  console.debug(`${LOG_PREFIX} Save start`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n  await db.costs.put(record);\n  console.debug(`${LOG_PREFIX} Save complete`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n}", "parameters": [{"name": "record", "type": "CostRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecordWithDefaults", "name": "saveCostRecordWithDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecordWithDefaults(input: CostRecordInput): Promise<void> {\n  return saveCostRecord(createCostRecord(input));\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForProject", "name": "getCostsForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForProject(projectId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForSimulation", "name": "getCostsForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForSimulation(simulationRunId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getAllCosts", "name": "getAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getAllCosts(): Promise<CostRecord[]> {\n  return db.costs.toArray();\n}", "parameters": [], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsInRange", "name": "getCostsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsInRange(startTime: number, endTime: number): Promise<CostRecord[]> {\n  return db.costs.where(\"timestamp\").between(startTime, endTime, true, true).toArray();\n}", "parameters": [{"name": "startTime", "type": "number", "optional": false}, {"name": "endTime", "type": "number", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::summarizeCosts", "name": "summarizeCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function summarizeCosts(records: CostRecord[]): CostSummary {\n  const summary: CostSummary = {\n    totalEstimated: 0,\n    totalActual: 0,\n    count: records.length,\n    byType: {} as Record<CostType, { estimated: number; actual: number; count: number }>,\n    byModel: {},\n  };\n\n  for (const record of records) {\n    summary.totalEstimated += record.estimatedCost;\n    summary.totalActual += record.actualCost;\n\n    if (!summary.byType[record.type]) {\n      summary.byType[record.type] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byType[record.type].estimated += record.estimatedCost;\n    summary.byType[record.type].actual += record.actualCost;\n    summary.byType[record.type].count++;\n\n    if (!summary.byModel[record.model]) {\n      summary.byModel[record.model] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byModel[record.model].estimated += record.estimatedCost;\n    summary.byModel[record.model].actual += record.actualCost;\n    summary.byModel[record.model].count++;\n  }\n\n  return summary;\n}", "parameters": [{"name": "records", "type": "CostRecord[]", "optional": false}], "returnType": "CostSummary"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::clearAllCosts", "name": "clearAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function clearAllCosts(): Promise<void> {\n  await db.costs.clear();\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostCount", "name": "getCostCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostCount(): Promise<number> {\n  return db.costs.count();\n}", "parameters": [], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::generateRunId", "name": "generateRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export function generateRunId(): string {\n  return `dynrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::createDynamicsRun", "name": "createDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function createDynamicsRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string\n): Promise<DynamicsRun> {\n  const now = Date.now();\n\n  const run: DynamicsRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    messages: [],\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::getDynamicsRun", "name": "getDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function getDynamicsRun(runId: string): Promise<DynamicsRun | undefined> {\n  return db.dynamicsRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::updateDynamicsRun", "name": "updateDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function updateDynamicsRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<DynamicsRun> {\n  const run = await db.dynamicsRuns.get(runId);\n  if (!run) throw new Error(`Dynamics run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.messages !== undefined) run.messages = updates.messages;\n  if (updates.proposedDynamics !== undefined) run.proposedDynamics = updates.proposedDynamics;\n  if (updates.userFeedback !== undefined) run.userFeedback = updates.userFeedback;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<DynamicsRun>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::deleteDynamicsRun", "name": "deleteDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function deleteDynamicsRun(runId: string): Promise<void> {\n  await db.dynamicsRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::registerQueue", "name": "registerQueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the enrichment queue functions.\n */\nexport function registerQueue(enqueue: EnqueueFn, cancel: CancelFn): void {\n  _enqueue = enqueue;\n  _cancel = cancel;\n}", "parameters": [{"name": "enqueue", "type": "EnqueueFn", "optional": false}, {"name": "cancel", "type": "CancelFn", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getEnqueue", "name": "getEnqueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getEnqueue(): EnqueueFn {\n  if (!_enqueue) {\n    throw new Error(\"registerQueue must be called before getEnqueue\");\n  }\n  return _enqueue;\n}", "parameters": [], "returnType": "EnqueueFn"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getCancel", "name": "getCancel", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getCancel(): CancelFn {\n  if (!_cancel) {\n    throw new Error(\"registerQueue must be called before getCancel\");\n  }\n  return _cancel;\n}", "parameters": [], "returnType": "CancelFn"}, {"id": "apps/illuminator/webui/src/lib/db/entityNav.ts::buildEntityNavItem", "name": "buildEntityNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityNav.ts", "sourceCode": "export function buildEntityNavItem(entity: PersistedEntity): EntityNavItem {\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  return {\n    id: entity.id,\n    name: entity.name,\n    kind: entity.kind,\n    subtype: entity.subtype,\n    prominence: entity.prominence,\n    culture: entity.culture,\n    status: entity.status,\n    summary: entity.summary,\n    eraId: entity.eraId,\n    hasDescription: !!(entity.summary && entity.description),\n    hasVisualThesis: !!entity.enrichment?.text?.visualThesis,\n    imageId: entity.enrichment?.image?.imageId,\n    descriptionCost: entity.enrichment?.text?.actualCost,\n    imageCost: entity.enrichment?.image?.actualCost,\n    aliases: entity.enrichment?.text?.aliases || [],\n    slugAliases: entity.enrichment?.slugAliases || [],\n    backrefCount: backrefs.length,\n    unconfiguredBackrefCount: backrefs.filter(\n      (b: { imageSource?: unknown }) => b.imageSource === undefined\n    ).length,\n    isManual: entity.id.startsWith(\"manual_\"),\n    lockedSummary: !!entity.lockedSummary,\n    hasHistorianNotes: (entity.enrichment?.historianNotes?.length ?? 0) > 0,\n    hasHistorianEdition: (entity.enrichment?.descriptionHistory || []).some(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ),\n    historianEditionCount: (entity.enrichment?.descriptionHistory || []).filter(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ).length,\n    descriptionWordCount: entity.description ? entity.description.split(/\\s+/).length : 0,\n  };\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}], "returnType": "EntityNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::isSeeded", "name": "isSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed (Phase 1 bridge \u2014 replaced by Lore Weave write in future)\n// ---------------------------------------------------------------------------\n\n/**\n * Check whether entities have already been seeded for this simulation run.\n */\nexport async function isSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.entities.where(\"simulationRunId\").equals(simulationRunId).count();\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::seedEntities", "name": "seedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-write entities from worldData.hardState into Dexie.\n * Stamps each record with simulationRunId. Skips if already seeded.\n */\nexport async function seedEntities(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<void> {\n  const records: PersistedEntity[] = entities.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.entities.bulkPut(records);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::createEntity", "name": "createEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Manual Creation\n// ---------------------------------------------------------------------------\n\n/**\n * Create a single entity manually. Generates a collision-safe ID\n * with a `manual_` prefix.\n */\nexport async function createEntity(\n  simulationRunId: string,\n  entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<PersistedEntity> {\n  if (!simulationRunId) {\n    throw new Error(\"simulationRunId is required to create an entity\");\n  }\n  const now = Date.now();\n  const id = `manual_${entity.kind}_${now}_${crypto.randomUUID().slice(0, 8)}`;\n  const record: PersistedEntity = {\n    ...entity,\n    id,\n    createdAt: now,\n    updatedAt: now,\n    simulationRunId,\n  };\n  await db.entities.put(record);\n  return record;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entity", "type": "Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">", "optional": false}], "returnType": "Promise<PersistedEntity>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntity", "name": "deleteEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function deleteEntity(entityId: string): Promise<void> {\n  if (!entityId.startsWith(\"manual_\")) {\n    throw new Error(\"Only manually-created entities can be deleted\");\n  }\n  await db.entities.delete(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::patchEntitiesFromHardState", "name": "patchEntitiesFromHardState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Patch entities from hard state without overwriting existing values.\n * - Inserts missing entities\n * - For existing entities, fills only undefined/null fields (keeps enrichment intact)\n */\nexport async function patchEntitiesFromHardState(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<{ added: number; patched: number }> {\n  if (!entities?.length) return { added: 0, patched: 0 };\n\n  const existing = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const existingById = new Map(existing.map((e) => [e.id, e]));\n  let added = 0;\n  let patched = 0;\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const worldEntity of entities) {\n      const current = existingById.get(worldEntity.id);\n      if (!current) {\n        await db.entities.put({ ...worldEntity, simulationRunId });\n        added += 1;\n        continue;\n      }\n\n      const updates: Partial<PersistedEntity> = {};\n      for (const [key, value] of Object.entries(worldEntity)) {\n        if (key === \"enrichment\") continue;\n        if (value === undefined || value === null) continue;\n        const currentValue = (current as any)[key];\n        if (currentValue === undefined || currentValue === null) {\n          (updates as any)[key] = value;\n        }\n      }\n\n      if (Object.keys(updates).length > 0) {\n        await db.entities.update(current.id, updates);\n        patched += 1;\n      }\n    }\n  });\n\n  return { added, patched };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<{ added: number; patched: number }>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntity", "name": "getEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getEntity(entityId: string): Promise<PersistedEntity | undefined> {\n  return db.entities.get(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByIds", "name": "getEntitiesByIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByIds(entityIds: string[]): Promise<PersistedEntity[]> {\n  const results = await db.entities.bulkGet(entityIds);\n  return results.filter((e): e is PersistedEntity => e !== undefined);\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesForRun", "name": "getEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesForRun(simulationRunId: string): Promise<PersistedEntity[]> {\n  return db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntityIdsForRun", "name": "getEntityIdsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntityIdsForRun(simulationRunId: string): Promise<string[]> {\n  const ids = await db.entities.where(\"simulationRunId\").equals(simulationRunId).primaryKeys();\n  return ids.map((id) => String(id));\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByKind", "name": "getEntitiesByKind", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByKind(\n  simulationRunId: string,\n  kind: string\n): Promise<PersistedEntity[]> {\n  return db.entities.where(\"[simulationRunId+kind]\").equals([simulationRunId, kind]).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityField", "name": "updateEntityField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Single-field updates\n// ---------------------------------------------------------------------------\n\nexport async function updateEntityField(\n  entityId: string,\n  field: string,\n  value: unknown\n): Promise<void> {\n  await db.entities.update(entityId, { [field]: value });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "field", "type": "string", "optional": false}, {"name": "value", "type": "unknown", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityFields", "name": "updateEntityFields", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function updateEntityFields(\n  entityId: string,\n  fields: Partial<PersistedEntity>\n): Promise<void> {\n  await db.entities.update(entityId, fields);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "fields", "type": "Partial<PersistedEntity>", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRename", "name": "applyRename", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function applyRename(\n  targetEntityId: string | null,\n  newName: string,\n  entityPatches: EntityPatch[],\n  simulationRunId: string,\n  addOldNameAsAlias?: boolean\n): Promise<string[]> {\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    if (targetEntityId) {\n      await renameTargetEntity(targetEntityId, newName, addOldNameAsAlias, updatedIds);\n    }\n\n    for (const patch of entityPatches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let changed = false;\n      const updates: Partial<PersistedEntity> = {};\n\n      for (const [key, value] of Object.entries(patch.changes)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n        if (applyFieldReplacement(field, replacements, entity, updates)) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        await db.entities.update(patch.entityId, updates);\n        if (!updatedIds.includes(patch.entityId)) updatedIds.push(patch.entityId);\n      }\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "entityPatches", "type": "EntityPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "addOldNameAsAlias", "type": "boolean", "optional": true}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyDescriptionResult", "name": "applyDescriptionResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Worker enrichment results\n// ---------------------------------------------------------------------------\n\n/**\n * Apply a description enrichment result from the worker.\n * Pushes current description to history if overwriting, merges enrichment.text.\n */\nexport async function applyDescriptionResult(\n  entityId: string,\n  enrichment: Partial<EntityEnrichment>,\n  summary?: string | null,\n  description?: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    // Push description history if overwriting an existing description\n    let baseEnrichment = entity.enrichment || {};\n    if (description !== undefined && entity.description) {\n      const history = [...(baseEnrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"description-task\",\n      });\n      baseEnrichment = { ...baseEnrichment, descriptionHistory: history };\n    }\n\n    const updates: Partial<PersistedEntity> = {\n      enrichment: { ...baseEnrichment, ...enrichment },\n    };\n    if (summary !== undefined) updates.summary = summary ?? undefined;\n    if (description !== undefined) updates.description = description;\n\n    await db.entities.update(entityId, updates);\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "enrichment", "type": "Partial<EntityEnrichment>", "optional": false}, {"name": "summary", "type": "string | null", "optional": true}, {"name": "description", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyVisualThesisResult", "name": "applyVisualThesisResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply a visual thesis result \u2014 updates only visual fields on enrichment.text,\n * preserving existing aliases, description, and summary.\n */\nexport async function applyVisualThesisResult(\n  entityId: string,\n  visualThesis: string,\n  visualTraits: string[],\n  meta: {\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const existingText = entity.enrichment?.text;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        text: {\n          aliases: existingText?.aliases || [],\n          visualThesis,\n          visualTraits,\n          generatedAt: meta.generatedAt,\n          model: meta.model,\n          estimatedCost: meta.estimatedCost,\n          actualCost: meta.actualCost,\n          inputTokens: meta.inputTokens,\n          outputTokens: meta.outputTokens,\n          chainDebug: meta.chainDebug,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "visualThesis", "type": "string", "optional": false}, {"name": "visualTraits", "type": "string[]", "optional": false}, {"name": "meta", "type": "{\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyImageResult", "name": "applyImageResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an image enrichment result from the worker.\n */\nexport async function applyImageResult(\n  entityId: string,\n  imageEnrichment: EntityEnrichment[\"image\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, image: imageEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageEnrichment", "type": "EntityEnrichment[\"image\"]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyEntityChronicleResult", "name": "applyEntityChronicleResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an entity chronicle enrichment result from the worker.\n */\nexport async function applyEntityChronicleResult(\n  entityId: string,\n  chronicleEnrichment: EntityEnrichment[\"entityChronicle\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, entityChronicle: chronicleEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "chronicleEnrichment", "type": "EntityEnrichment[\"entityChronicle\"]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::assignImage", "name": "assignImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// User actions\n// ---------------------------------------------------------------------------\n\n/**\n * Assign an existing library image to an entity.\n */\nexport async function assignImage(\n  entityId: string,\n  imageId: string,\n  imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        image: {\n          imageId,\n          generatedAt: imageMetadata?.generatedAt || Date.now(),\n          model: imageMetadata?.model || \"assigned\",\n          revisedPrompt: imageMetadata?.revisedPrompt,\n          estimatedCost: 0,\n          actualCost: 0,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageId", "type": "string", "optional": false}, {"name": "imageMetadata", "type": "{ generatedAt?: number; model?: string; revisedPrompt?: string }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateDescriptionManual", "name": "updateDescriptionManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's description. Pushes current description to history\n * with source 'manual', bumps text.generatedAt to prevent enrichment overwrites.\n */\nexport async function updateDescriptionManual(\n  entityId: string,\n  description: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    let enrichment = entity.enrichment || {};\n\n    // Push current description to history\n    if (entity.description) {\n      const history = [...(enrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"manual\",\n      });\n      enrichment = { ...enrichment, descriptionHistory: history };\n    }\n\n    // Bump text.generatedAt so enrichment workers won't overwrite\n    if (enrichment.text) {\n      enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n    }\n\n    await db.entities.update(entityId, { description, enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "description", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateSummaryManual", "name": "updateSummaryManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's summary. Sets lockedSummary to prevent enrichment overwrites.\n */\nexport async function updateSummaryManual(entityId: string, summary: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, { summary, lockedSummary: true });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::undoDescription", "name": "undoDescription", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Undo the last description change by popping from descriptionHistory.\n */\nexport async function undoDescription(entityId: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (history.length === 0) return;\n    const previous = history.pop();\n    await db.entities.update(entityId, {\n      description: previous.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::restoreDescriptionFromHistory", "name": "restoreDescriptionFromHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Restore a specific description history entry as the active description.\n * The current description is pushed to history before the swap.\n */\nexport async function restoreDescriptionFromHistory(\n  entityId: string,\n  historyIndex: number\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (historyIndex < 0 || historyIndex >= history.length) return;\n\n    const selected = history[historyIndex];\n\n    // Push current description to history\n    if (entity.description) {\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"version-restore\",\n      });\n    }\n\n    // Remove the selected entry from history\n    history.splice(historyIndex, 1);\n\n    await db.entities.update(entityId, {\n      description: selected.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "historyIndex", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateBackrefs", "name": "updateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Set chronicle backrefs on an entity.\n */\nexport async function updateBackrefs(\n  entityId: string,\n  backrefs: NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "backrefs", "type": "NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateAliases", "name": "updateAliases", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Aliases\n// ---------------------------------------------------------------------------\n\n/**\n * Update the text aliases on an entity.\n */\nexport async function updateAliases(entityId: string, aliases: string[]): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const text = entity.enrichment?.text || {\n      aliases: [],\n      visualTraits: [],\n      generatedAt: 0,\n      model: \"\",\n    };\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, text: { ...text, aliases } },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "aliases", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRevisionPatches", "name": "applyRevisionPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply revision patches from summary revision, lore backport, or copy-edit.\n * Pushes descriptionHistory, bumps text.generatedAt. Returns updated entity IDs.\n */\nexport async function applyRevisionPatches(\n  patches: RevisionPatch[],\n  source: string\n): Promise<string[]> {\n  if (!patches?.length) return [];\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let enrichment = entity.enrichment || {};\n\n      // Push description history if overwriting\n      if (patch.description !== undefined && entity.description) {\n        const history = [...(enrichment.descriptionHistory || [])];\n        history.push({\n          description: entity.description,\n          replacedAt: Date.now(),\n          source,\n        });\n        enrichment = { ...enrichment, descriptionHistory: history };\n      }\n\n      // Bump text.generatedAt so stale persisted data won't overwrite\n      if (patch.description !== undefined && enrichment.text) {\n        enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n      }\n\n      const updates: Partial<PersistedEntity> = { enrichment };\n      if (patch.summary !== undefined) updates.summary = patch.summary;\n      if (patch.description !== undefined) updates.description = patch.description;\n\n      await db.entities.update(patch.entityId, updates);\n      updatedIds.push(patch.entityId);\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "source", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::revalidateBackrefs", "name": "revalidateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function revalidateBackrefs(\n  patches: RevisionPatch[],\n  options?: {\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      if (!patch.description && !options?.chronicleId) continue;\n\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      const desc = patch.description || entity.description || \"\";\n      let backrefs = [...(entity.enrichment?.chronicleBackrefs || [])];\n      if (backrefs.length === 0 && !patch.anchorPhrase) continue;\n\n      if (patch.description && backrefs.length > 0) {\n        backrefs = backrefs.map((br) =>\n          reResolveBackref(br, desc, entity.description, Boolean(options?.fuzzyFallback))\n        );\n      }\n\n      if (options?.chronicleId && patch.anchorPhrase) {\n        upsertBackref(backrefs, options.chronicleId, patch.anchorPhrase, desc, entity.id);\n      }\n\n      await db.entities.update(patch.entityId, {\n        enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n      });\n    }\n  });\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "options", "type": "{\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::setHistorianNotes", "name": "setHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Historian\n// ---------------------------------------------------------------------------\n\n/**\n * Set historian notes on an entity.\n */\nexport async function setHistorianNotes(\n  entityId: string,\n  notes: NonNullable<EntityEnrichment[\"historianNotes\"]>,\n  reinforcedFacts?: string[]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const enrichment = { ...entity.enrichment, historianNotes: notes };\n    if (reinforcedFacts) {\n      enrichment.reinforcedFacts = reinforcedFacts;\n    }\n    await db.entities.update(entityId, { enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "notes", "type": "NonNullable<EntityEnrichment[\"historianNotes\"]>", "optional": false}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::resetEntitiesToPreBackportState", "name": "resetEntitiesToPreBackportState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Backport Reset\n// ---------------------------------------------------------------------------\n\n/**\n * Reset entity descriptions to their pre-backport state.\n * Optionally accepts an entity list to ensure reset covers entities not yet persisted in Dexie.\n * For each entity that has lore-backport entries in descriptionHistory:\n * - Find the first 'lore-backport' entry\n * - Restore the description from that entry (which is the pre-backport state)\n * - Truncate history to remove all entries from that point onward\n * - Clear chronicleBackrefs (these were set by backport operations)\n *\n * Returns count of entities that were reset.\n */\nexport async function resetEntitiesToPreBackportState(\n  simulationRunId: string,\n  entitiesOverride?: PersistedEntity[]\n): Promise<{ resetCount: number; entityIds: string[] }> {\n  const entities = entitiesOverride?.length\n    ? entitiesOverride\n    : await getEntitiesForRun(simulationRunId);\n  const resetEntityIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    const existing = await db.entities.bulkGet(entities.map((entity) => entity.id));\n    const existingIds = new Set(existing.filter(Boolean).map((entity) => entity.id));\n\n    for (const entity of entities) {\n      const history = entity.enrichment?.descriptionHistory || [];\n      if (history.length === 0) continue;\n\n      // Find the first 'lore-backport' entry\n      const firstBackportIndex = history.findIndex((h) => h.source === \"lore-backport\");\n      if (firstBackportIndex === -1) continue; // Never backported\n\n      // The description in that entry is the pre-backport state\n      const preBackportDescription = history[firstBackportIndex].description;\n\n      // Truncate history to remove entries from the first backport onward\n      const newHistory = history.slice(0, firstBackportIndex);\n\n      // Clear chronicleBackrefs since those were set by backport\n      const newEnrichment = {\n        ...entity.enrichment,\n        descriptionHistory: newHistory,\n        chronicleBackrefs: [],\n      };\n\n      const updates = {\n        description: preBackportDescription,\n        enrichment: newEnrichment,\n      };\n\n      if (existingIds.has(entity.id)) {\n        await db.entities.update(entity.id, updates);\n      } else {\n        await db.entities.put({\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n          ...updates,\n        });\n      }\n\n      resetEntityIds.push(entity.id);\n    }\n  });\n\n  return {\n    resetCount: resetEntityIds.length,\n    entityIds: resetEntityIds,\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entitiesOverride", "type": "PersistedEntity[]", "optional": true}], "returnType": "Promise<{ resetCount: number; entityIds: string[] }>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntitiesForRun", "name": "deleteEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEntitiesForRun(simulationRunId: string): Promise<void> {\n  await db.entities.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::convertLongEditionsToLegacy", "name": "convertLongEditionsToLegacy", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-convert all historian-edition history entries to 'legacy-copy-edit' source.\n * Clears the historian-edition slate so entities can go through a fresh edition cycle.\n *\n * Returns the count of entities modified.\n */\nexport async function convertLongEditionsToLegacy(entityIds: string[]): Promise<number> {\n  let modified = 0;\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const entityId of entityIds) {\n      const entity = await db.entities.get(entityId);\n      if (!entity) continue;\n\n      const history = [...(entity.enrichment?.descriptionHistory || [])];\n      let changed = false;\n      for (let i = 0; i < history.length; i++) {\n        if (history[i].source === \"historian-edition\") {\n          history[i] = { ...history[i], source: \"legacy-copy-edit\" };\n          changed = true;\n        }\n      }\n\n      if (!changed) continue;\n\n      await db.entities.update(entityId, {\n        enrichment: { ...entity.enrichment, descriptionHistory: history },\n      });\n      modified++;\n    }\n  });\n  return modified;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts::buildEraNarrativeNavItem", "name": "buildEraNarrativeNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts", "sourceCode": "export function buildEraNarrativeNavItem(\n  record: EraNarrativeRecord,\n  eraOrder?: number\n): EraNarrativeNavItem {\n  const wordCount = record.narrative?.editedWordCount ?? record.narrative?.wordCount ?? 0;\n\n  return {\n    id: `eranarr:${record.narrativeId}`,\n    narrativeId: record.narrativeId,\n    itemType: \"era_narrative\",\n    name: record.eraName,\n    eraName: record.eraName,\n    eraId: record.eraId,\n    status: record.status,\n    tone: record.tone,\n    currentStep: record.currentStep,\n    wordCount,\n    totalActualCost: record.totalActualCost,\n    threadCount: record.threadSynthesis?.threads?.length ?? 0,\n    movementCount: record.threadSynthesis?.movements?.length ?? 0,\n    hasThesis: !!record.threadSynthesis?.thesis,\n    createdAt: record.createdAt,\n    updatedAt: record.updatedAt,\n    focalEraName: record.eraName,\n    focalEraOrder: eraOrder,\n    eraYear: undefined,\n  };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}, {"name": "eraOrder", "type": "number", "optional": true}], "returnType": "EraNarrativeNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateEraNarrativeId", "name": "generateEraNarrativeId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateEraNarrativeId(): string {\n  return `eranarr_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateVersionId", "name": "generateVersionId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateVersionId(): string {\n  return `enver_${Date.now()}_${crypto.randomUUID().slice(0, 6)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::createEraNarrative", "name": "createEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function createEraNarrative(record: EraNarrativeRecord): Promise<EraNarrativeRecord> {\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrative", "name": "getEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrative(\n  narrativeId: string\n): Promise<EraNarrativeRecord | undefined> {\n  return db.eraNarratives.get(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForEra", "name": "getEraNarrativesForEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForEra(\n  simulationRunId: string,\n  eraId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where({ simulationRunId, eraId }).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "eraId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForSimulation", "name": "getEraNarrativesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForSimulation(\n  simulationRunId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrative", "name": "updateEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrative(\n  narrativeId: string,\n  updates: Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  if (updates.status !== undefined) record.status = updates.status;\n  if (updates.error !== undefined) record.error = updates.error;\n  if (updates.currentStep !== undefined) record.currentStep = updates.currentStep;\n  if (updates.threadSynthesis !== undefined) record.threadSynthesis = updates.threadSynthesis;\n  if (updates.narrative !== undefined) record.narrative = updates.narrative;\n  if (updates.contentVersions !== undefined) record.contentVersions = updates.contentVersions;\n  if (updates.activeVersionId !== undefined) record.activeVersionId = updates.activeVersionId;\n  if (updates.coverImage !== undefined) record.coverImage = updates.coverImage;\n  if (updates.imageRefs !== undefined) record.imageRefs = updates.imageRefs;\n  if (updates.totalInputTokens !== undefined) record.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) record.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) record.totalActualCost = updates.totalActualCost;\n  if (updates.editInsertion !== undefined) record.editInsertion = updates.editInsertion;\n  record.updatedAt = Date.now();\n\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrative", "name": "deleteEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrative(narrativeId: string): Promise<void> {\n  await db.eraNarratives.delete(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrativeVersion", "name": "deleteEraNarrativeVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrativeVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  const target = versions.find((v) => v.versionId === versionId);\n  if (!target) throw new Error(`Version ${versionId} not found`);\n  if (target.step === \"generate\") throw new Error(\"Cannot delete the generate version\");\n\n  record.contentVersions = versions.filter((v) => v.versionId !== versionId);\n\n  // If deleted version was active, fall back to latest remaining\n  if (record.activeVersionId === versionId) {\n    const remaining = record.contentVersions;\n    record.activeVersionId =\n      remaining.length > 0 ? remaining[remaining.length - 1].versionId : undefined;\n  }\n\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::setEraNarrativeActiveVersion", "name": "setEraNarrativeActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function setEraNarrativeActiveVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  if (!versions.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found`);\n  }\n\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImage", "name": "updateEraNarrativeCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Cover Image\n// =============================================================================\n\nexport async function updateEraNarrativeCoverImage(\n  narrativeId: string,\n  coverImage: EraNarrativeCoverImage,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.coverImage = coverImage;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "coverImage", "type": "EraNarrativeCoverImage", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImageStatus", "name": "updateEraNarrativeCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeCoverImageStatus(\n  narrativeId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.coverImage) return;\n\n  record.coverImage.status = status;\n  if (imageId) record.coverImage.generatedImageId = imageId;\n  if (error) record.coverImage.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefs", "name": "updateEraNarrativeImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Image Refs\n// =============================================================================\n\nexport async function updateEraNarrativeImageRefs(\n  narrativeId: string,\n  imageRefs: EraNarrativeImageRefs,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "EraNarrativeImageRefs", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefStatus", "name": "updateEraNarrativeImageRefStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeImageRefStatus(\n  narrativeId: string,\n  refId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref || ref.type !== \"prompt_request\") return;\n\n  ref.status = status;\n  if (imageId) ref.generatedImageId = imageId;\n  if (error) ref.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefField", "name": "updateEraNarrativeImageRefField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "/**\n * Update arbitrary fields on an image ref (anchor text, size, justification).\n */\nexport async function updateEraNarrativeImageRefField(\n  narrativeId: string,\n  refId: string,\n  updates: { anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref) return;\n\n  if (updates.anchorText !== undefined) ref.anchorText = updates.anchorText;\n  if (updates.size !== undefined) (ref as any).size = updates.size;\n  if (updates.justification !== undefined) {\n    if (updates.justification === null) {\n      delete (ref as any).justification;\n    } else {\n      ref.justification = updates.justification;\n    }\n  }\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{ anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::resolveActiveContent", "name": "resolveActiveContent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Version Helpers\n// =============================================================================\n\n/**\n * Get the active version's content, falling back to legacy narrative field.\n * Returns the content string and the version list for display.\n */\nexport function resolveActiveContent(record: EraNarrativeRecord): {\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n} {\n  const versions = record.contentVersions || [];\n\n  if (versions.length > 0) {\n    const activeId = record.activeVersionId || versions[versions.length - 1].versionId;\n    const active = versions.find((v) => v.versionId === activeId) || versions[versions.length - 1];\n    return { content: active.content, versions, activeVersionId: active.versionId };\n  }\n\n  // Legacy fallback: migrate from narrative field\n  if (record.narrative) {\n    const legacyVersions: EraNarrativeContentVersion[] = [];\n    legacyVersions.push({\n      versionId: `legacy_gen_${record.narrative.generatedAt}`,\n      content: record.narrative.content,\n      wordCount: record.narrative.wordCount,\n      step: \"generate\",\n      generatedAt: record.narrative.generatedAt,\n      model: record.narrative.model,\n      systemPrompt: record.narrative.systemPrompt,\n      userPrompt: record.narrative.userPrompt,\n      inputTokens: record.narrative.inputTokens,\n      outputTokens: record.narrative.outputTokens,\n      actualCost: record.narrative.actualCost,\n    });\n    if (record.narrative.editedContent) {\n      legacyVersions.push({\n        versionId: `legacy_edit_${record.narrative.editedAt || record.narrative.generatedAt}`,\n        content: record.narrative.editedContent,\n        wordCount:\n          record.narrative.editedWordCount ||\n          record.narrative.editedContent.split(/\\s+/).filter(Boolean).length,\n        step: \"edit\",\n        generatedAt: record.narrative.editedAt || record.narrative.generatedAt,\n        model: record.narrative.model,\n        systemPrompt: record.narrative.editSystemPrompt || \"\",\n        userPrompt: record.narrative.editUserPrompt || \"\",\n        inputTokens: record.narrative.editInputTokens || 0,\n        outputTokens: record.narrative.editOutputTokens || 0,\n        actualCost: record.narrative.editActualCost || 0,\n      });\n    }\n\n    const activeId = legacyVersions[legacyVersions.length - 1].versionId;\n    return {\n      content: legacyVersions[legacyVersions.length - 1].content,\n      versions: legacyVersions,\n      activeVersionId: activeId,\n    };\n  }\n\n  return { content: undefined, versions: [], activeVersionId: undefined };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "{\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n}"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::isNarrativeEventsSeeded", "name": "isNarrativeEventsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isNarrativeEventsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[EventRepo] isNarrativeEventsSeeded\", { simulationRunId, count, seeded: count > 0 });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::seedNarrativeEvents", "name": "seedNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function seedNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<void> {\n  console.log(\"[EventRepo] seedNarrativeEvents\", { simulationRunId, eventCount: events.length });\n  const records: PersistedNarrativeEvent[] = events.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.narrativeEvents.bulkPut(records);\n  console.log(\"[EventRepo] seedNarrativeEvents complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::patchNarrativeEvents", "name": "patchNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "/**\n * Patch narrative events without overwriting existing records.\n * Inserts only missing event IDs.\n */\nexport async function patchNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<number> {\n  if (!events?.length) return 0;\n\n  const existing = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingIds = new Set(existing.map((e) => e.id));\n\n  const toAdd: PersistedNarrativeEvent[] = [];\n  for (const event of events) {\n    if (!existingIds.has(event.id)) {\n      toAdd.push({ ...event, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.narrativeEvents.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEventsForRun", "name": "getNarrativeEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getNarrativeEventsForRun(\n  simulationRunId: string\n): Promise<PersistedNarrativeEvent[]> {\n  const events = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[EventRepo] getNarrativeEventsForRun\", { simulationRunId, count: events.length });\n  return events;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEvent", "name": "getNarrativeEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function getNarrativeEvent(\n  eventId: string\n): Promise<PersistedNarrativeEvent | undefined> {\n  return db.narrativeEvents.get(eventId);\n}", "parameters": [{"name": "eventId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::applyEventPatches", "name": "applyEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Named mutations\n// ---------------------------------------------------------------------------\n\n/**\n * Apply event patches from a rename operation.\n * Reads affected events from Dexie, applies text replacements, writes back.\n * Returns IDs of all updated events.\n */\nexport async function applyEventPatches(\n  eventPatches: EventPatch[],\n  simulationRunId: string\n): Promise<string[]> {\n  console.log(\"[EventRepo] applyEventPatches called\", {\n    patchCount: eventPatches.length,\n    simulationRunId,\n    patchEventIds: eventPatches.map((p) => p.eventId),\n    patchKeys: eventPatches.map((p) => Object.keys(p.changes)),\n  });\n\n  if (eventPatches.length === 0) return [];\n\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.narrativeEvents, async () => {\n    // Load all events for the run (needed for the batch patch function)\n    const allEvents = await db.narrativeEvents\n      .where(\"simulationRunId\")\n      .equals(simulationRunId)\n      .toArray();\n\n    console.log(\"[EventRepo] Loaded events from Dexie\", {\n      totalEvents: allEvents.length,\n      simulationRunId,\n    });\n\n    // Sample a patched event BEFORE applying patches\n    const firstPatchId = eventPatches[0]?.eventId;\n    const sampleBefore = allEvents.find((e) => e.id === firstPatchId);\n    if (sampleBefore) {\n      console.log(\"[EventRepo] Sample event BEFORE patch\", {\n        id: sampleBefore.id,\n        description: sampleBefore.description?.substring(0, 200),\n        action: (sampleBefore as any).action?.substring(0, 200),\n      });\n    } else {\n      console.warn(\"[EventRepo] First patch target NOT FOUND in Dexie events\", {\n        targetId: firstPatchId,\n        availableIds: allEvents.slice(0, 5).map((e) => e.id),\n      });\n    }\n\n    // Apply patches using the existing pure function\n    const patched = applyPatches(allEvents, eventPatches);\n\n    // Sample the same event AFTER applying patches\n    const sampleAfter = patched.find((e) => e.id === firstPatchId);\n    if (sampleAfter) {\n      console.log(\"[EventRepo] Sample event AFTER patch\", {\n        id: sampleAfter.id,\n        description: sampleAfter.description?.substring(0, 200),\n        action: (sampleAfter as any).action?.substring(0, 200),\n      });\n    }\n\n    // Find which events actually changed and write them back\n    const patchedEventIds = new Set(eventPatches.map((p) => p.eventId));\n    let writeCount = 0;\n    for (const event of patched) {\n      if (patchedEventIds.has(event.id)) {\n        await db.narrativeEvents.put(event);\n        updatedIds.push(event.id);\n        writeCount++;\n      }\n    }\n    console.log(\"[EventRepo] Wrote patched events back to Dexie\", {\n      writeCount,\n      updatedIds,\n    });\n  });\n\n  // Verify: re-read one event to confirm persistence\n  if (updatedIds.length > 0) {\n    const verify = await db.narrativeEvents.get(updatedIds[0]);\n    console.log(\"[EventRepo] VERIFY after transaction\", {\n      id: verify?.id,\n      description: verify?.description?.substring(0, 200),\n      action: (verify as any)?.action?.substring(0, 200),\n    });\n  }\n\n  return updatedIds;\n}", "parameters": [{"name": "eventPatches", "type": "EventPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::deleteEventsForRun", "name": "deleteEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEventsForRun(simulationRunId: string): Promise<void> {\n  await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::generateHistorianRunId", "name": "generateHistorianRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export function generateHistorianRunId(): string {\n  return `histrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::createHistorianRun", "name": "createHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function createHistorianRun(run: HistorianRun): Promise<HistorianRun> {\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "run", "type": "HistorianRun", "optional": false}], "returnType": "Promise<HistorianRun>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::getHistorianRun", "name": "getHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function getHistorianRun(runId: string): Promise<HistorianRun | undefined> {\n  return db.historianRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<HistorianRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::updateHistorianRun", "name": "updateHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function updateHistorianRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >\n): Promise<HistorianRun> {\n  const run = await db.historianRuns.get(runId);\n  if (!run) throw new Error(`Historian run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.notes !== undefined) run.notes = updates.notes;\n  if (updates.noteDecisions !== undefined) run.noteDecisions = updates.noteDecisions;\n  if (updates.chronologyAssignments !== undefined)\n    run.chronologyAssignments = updates.chronologyAssignments;\n  if (updates.inputTokens !== undefined) run.inputTokens = updates.inputTokens;\n  if (updates.outputTokens !== undefined) run.outputTokens = updates.outputTokens;\n  if (updates.actualCost !== undefined) run.actualCost = updates.actualCost;\n  if (updates.systemPrompt !== undefined) run.systemPrompt = updates.systemPrompt;\n  if (updates.userPrompt !== undefined) run.userPrompt = updates.userPrompt;\n  run.updatedAt = Date.now();\n\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >", "optional": false}], "returnType": "Promise<HistorianRun>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::deleteHistorianRun", "name": "deleteHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function deleteHistorianRun(runId: string): Promise<void> {\n  await db.historianRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::extractReinforcedFactIds", "name": "extractReinforcedFactIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Context extraction\n// ============================================================================\n\n/**\n * Extract reinforced fact IDs from a HistorianReviewConfig's contextJson.\n * Returns the factIds from factCoverageGuidance targets, or undefined if none.\n */\nexport function extractReinforcedFactIds(contextJson: string): string[] | undefined {\n  try {\n    const ctx = JSON.parse(contextJson);\n    if (!Array.isArray(ctx.factCoverageGuidance) || ctx.factCoverageGuidance.length === 0)\n      return undefined;\n    return ctx.factCoverageGuidance.map((t: { factId: string }) => t.factId).filter(Boolean);\n  } catch {\n    return undefined;\n  }\n}", "parameters": [{"name": "contextJson", "type": "string", "optional": false}], "returnType": "string[] | undefined"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::sleep", "name": "sleep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Helpers\n// ============================================================================\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}", "parameters": [{"name": "ms", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::dispatchReviewTask", "name": "dispatchReviewTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Enqueue a historian review task to the enrichment worker.\n */\nexport function dispatchReviewTask(runId: string): void {\n  getEnqueue()([\n    {\n      entity: {\n        id: \"__historian_review__\",\n        name: \"Historian Review\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      },\n      type: \"historianReview\" as EnrichmentType,\n      prompt: \"\",\n      chronicleId: runId,\n    },\n  ]);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::pollReviewCompletion", "name": "pollReviewCompletion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Poll a historian run until it reaches 'reviewing' (success) or 'failed'.\n *\n * @param isCancelled \u2014 checked before and after each sleep; return true to abort.\n * @returns ReviewResult on success, null if cancelled or run disappeared.\n * @throws on run failure.\n */\nexport async function pollReviewCompletion(\n  runId: string,\n  isCancelled: () => boolean\n): Promise<ReviewResult | null> {\n  while (true) {\n    if (isCancelled()) return null;\n    await sleep(POLL_INTERVAL_MS);\n    if (isCancelled()) return null;\n\n    const run = await getHistorianRun(runId);\n    if (!run) return null;\n\n    if (run.status === \"reviewing\") {\n      const cost = run.actualCost || 0;\n      const prompts =\n        run.systemPrompt && run.userPrompt\n          ? { systemPrompt: run.systemPrompt, userPrompt: run.userPrompt }\n          : undefined;\n      await deleteHistorianRun(runId);\n      return { notes: run.notes || [], cost, prompts };\n    }\n\n    if (run.status === \"failed\") {\n      const error = run.error || \"Unknown error\";\n      await deleteHistorianRun(runId);\n      throw new Error(error);\n    }\n  }\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "isCancelled", "type": "() => boolean", "optional": false}], "returnType": "Promise<ReviewResult | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::generateImageId", "name": "generateImageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Pure Functions\n// ============================================================================\n\nexport function generateImageId(entityId: string): string {\n  return `img_${entityId}_${Date.now()}`;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::classifyAspect", "name": "classifyAspect", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Classify aspect ratio from width/height.\n */\nexport function classifyAspect(width: number, height: number): ImageAspect {\n  const ratio = width / height;\n  if (ratio < 0.9) return \"portrait\";\n  if (ratio > 1.1) return \"landscape\";\n  return \"square\";\n}", "parameters": [{"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}], "returnType": "ImageAspect"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::extractImageDimensions", "name": "extractImageDimensions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Extract dimensions from an image blob using createImageBitmap (works in workers).\n */\nexport async function extractImageDimensions(\n  blob: Blob\n): Promise<{ width: number; height: number; aspect: ImageAspect }> {\n  const bitmap = await createImageBitmap(blob);\n  const { width, height } = bitmap;\n  bitmap.close();\n  return { width, height, aspect: classifyAspect(width, height) };\n}", "parameters": [{"name": "blob", "type": "Blob", "optional": false}], "returnType": "Promise<{ width: number; height: number; aspect: ImageAspect }>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::saveImage", "name": "saveImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// CRUD\n// ============================================================================\n\nexport async function saveImage(\n  imageId: string,\n  blob: Blob,\n  metadata: ImageMetadata\n): Promise<string> {\n  const { size: sizeOverride, ...rest } = metadata as ImageMetadata & { size?: unknown };\n  const requestedSize =\n    typeof sizeOverride === \"string\" && sizeOverride.trim() ? sizeOverride : rest.requestedSize;\n  const metadataRecord = {\n    imageId,\n    mimeType: blob.type || \"image/png\",\n    size: blob.size,\n    ...rest,\n    requestedSize,\n    savedAt: Date.now(),\n  };\n\n  console.log(`${LOG_PREFIX} Image save start`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.put(metadataRecord as any);\n    await db.imageBlobs.put({ imageId, blob });\n  });\n\n  console.log(`${LOG_PREFIX} Image save complete`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  return imageId;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}, {"name": "blob", "type": "Blob", "optional": false}, {"name": "metadata", "type": "ImageMetadata", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImage", "name": "deleteImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "export async function deleteImage(imageId: string): Promise<void> {\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.delete(imageId);\n    await db.imageBlobs.delete(imageId);\n  });\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImages", "name": "searchImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Queries\n// ============================================================================\n\n/**\n * Search images with pagination \u2014 returns metadata only (no blobs).\n */\nexport async function searchImages(options: ImageSearchOptions = {}): Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, search, limit = 20, offset = 0 } = options;\n  const searchLower = search?.toLowerCase() || \"\";\n\n  // Fetch candidates \u2014 use index when filtering by projectId\n  const allRecords = projectId\n    ? await db.images.where(\"projectId\").equals(projectId).toArray()\n    : await db.images.toArray();\n\n  // Apply search filter (on entityName \u2014 lightweight)\n  const filtered = searchLower\n    ? allRecords.filter((r) => r.entityName && r.entityName.toLowerCase().includes(searchLower))\n    : allRecords;\n\n  const total = filtered.length;\n\n  // Paginate and project to lightweight list items (no blob)\n  const items: ImageListItem[] = filtered.slice(offset, offset + limit).map((r) => ({\n    imageId: r.imageId,\n    entityId: r.entityId,\n    projectId: r.projectId,\n    entityName: r.entityName,\n    entityKind: r.entityKind,\n    generatedAt: r.generatedAt,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "options", "type": "ImageSearchOptions", "optional": true}], "returnType": "Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageDataUrl", "name": "getImageDataUrl", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Load a single image's dataUrl by ID (on-demand loading).\n */\nexport async function getImageDataUrl(imageId: string): Promise<string | null> {\n  const blobRecord = await db.imageBlobs.get(imageId);\n  if (!blobRecord?.blob) return null;\n\n  try {\n    return await blobToDataUrl(blobRecord.blob);\n  } catch (err) {\n    console.warn(`Failed to convert image ${imageId} to dataUrl:`, err);\n    return null;\n  }\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<string | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::loadImage", "name": "loadImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Load / Browse (used by UI components that previously used Canonry imageStore)\n// ============================================================================\n\n/**\n * Load an image by ID and create an object URL.\n * Returns { url, ...metadata } or null if not found.\n * Caller is responsible for revoking the object URL.\n */\nexport async function loadImage(imageId: string): Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null> {\n  if (!imageId) return null;\n  const [metadata, blobRecord] = await Promise.all([\n    db.images.get(imageId),\n    db.imageBlobs.get(imageId),\n  ]);\n  if (!metadata || !blobRecord?.blob) return null;\n\n  const url = URL.createObjectURL(blobRecord.blob);\n  return {\n    url,\n    imageId: metadata.imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    mimeType: metadata.mimeType,\n    size: metadata.size,\n    generatedAt: metadata.generatedAt,\n    model: metadata.model,\n    originalPrompt: metadata.originalPrompt,\n    finalPrompt: metadata.finalPrompt,\n    revisedPrompt: metadata.revisedPrompt,\n    entityName: metadata.entityName,\n    entityKind: metadata.entityKind,\n    entityCulture: metadata.entityCulture,\n    imageType: metadata.imageType,\n    chronicleId: metadata.chronicleId,\n    imageRefId: metadata.imageRefId,\n    sceneDescription: metadata.sceneDescription,\n  };\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get raw image blob by ID.\n */\nexport async function getImageBlob(imageId: string): Promise<Blob | null> {\n  if (!imageId) return null;\n  const record = await db.imageBlobs.get(imageId);\n  return record?.blob || null;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<Blob | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getAllImages", "name": "getAllImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get all images (metadata only, no blobs) sorted newest first.\n */\nexport async function getAllImages(): Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n> {\n  const records = await db.images.toArray();\n  const images = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    projectId: record.projectId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    revisedPrompt: record.revisedPrompt,\n    estimatedCost: record.estimatedCost,\n    actualCost: record.actualCost,\n    inputTokens: record.inputTokens,\n    outputTokens: record.outputTokens,\n    width: record.width,\n    height: record.height,\n    aspect: record.aspect,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    imageRefId: record.imageRefId,\n    sceneDescription: record.sceneDescription,\n    mimeType: record.mimeType,\n    size: typeof record.size === \"number\" && Number.isFinite(record.size) ? record.size : 0,\n    savedAt: record.savedAt,\n    hasBlob: true,\n  }));\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n  return images;\n}", "parameters": [], "returnType": "Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImages", "name": "deleteImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Delete multiple images by ID.\n */\nexport async function deleteImages(imageIds: string[]): Promise<void> {\n  if (!imageIds?.length) return;\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.bulkDelete(imageIds);\n    await db.imageBlobs.bulkDelete(imageIds);\n  });\n}", "parameters": [{"name": "imageIds", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getStorageStats", "name": "getStorageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get storage statistics (count, total size, breakdown by project).\n */\nexport async function getStorageStats(): Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}> {\n  const records = await db.images.toArray();\n\n  let totalSize = 0;\n  const byProject: Record<string, { count: number; size: number }> = {};\n\n  for (const img of records) {\n    const size = typeof img.size === \"number\" && Number.isFinite(img.size) ? img.size : 0;\n    totalSize += size;\n\n    const pid = img.projectId || \"unknown\";\n    if (!byProject[pid]) {\n      byProject[pid] = { count: 0, size: 0 };\n    }\n    byProject[pid].count++;\n    byProject[pid].size += size;\n  }\n\n  return { totalCount: records.length, totalSize, byProject };\n}", "parameters": [], "returnType": "Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageFilterOptions", "name": "getImageFilterOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get unique values for a metadata field (for filter dropdowns).\n */\nexport async function getImageFilterOptions(\n  field: \"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"\n): Promise<string[]> {\n  const records = await db.images.toArray();\n  const values = new Set<string>();\n  for (const record of records) {\n    const val = (record as any)[field];\n    if (val) values.add(val);\n  }\n  return [...values].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "field", "type": "\"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImagesWithFilters", "name": "searchImagesWithFilters", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search images with rich filters (entity kind, culture, model, text search).\n * Returns metadata without blobs.\n */\nexport async function searchImagesWithFilters(\n  filters: {\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  } = {}\n): Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>> {\n  const records = await db.images.toArray();\n\n  let images: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }> = records.map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  if (filters.projectId) images = images.filter((img) => img.projectId === filters.projectId);\n  if (filters.entityKind) images = images.filter((img) => img.entityKind === filters.entityKind);\n  if (filters.entityCulture)\n    images = images.filter((img) => img.entityCulture === filters.entityCulture);\n  if (filters.model) images = images.filter((img) => img.model === filters.model);\n  if (filters.imageType) images = images.filter((img) => img.imageType === filters.imageType);\n  if (filters.chronicleId) images = images.filter((img) => img.chronicleId === filters.chronicleId);\n  if (filters.imageRefId) images = images.filter((img) => img.imageRefId === filters.imageRefId);\n\n  if (filters.searchText) {\n    const search = filters.searchText.toLowerCase();\n    images = images.filter(\n      (img) =>\n        img.entityName?.toLowerCase().includes(search) ||\n        img.originalPrompt?.toLowerCase().includes(search) ||\n        img.finalPrompt?.toLowerCase().includes(search) ||\n        img.revisedPrompt?.toLowerCase().includes(search)\n    );\n  }\n\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  if (filters.limit && filters.limit > 0) {\n    images = images.slice(0, filters.limit);\n  }\n\n  return images;\n}", "parameters": [{"name": "filters", "type": "{\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  }", "optional": true}], "returnType": "Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchChronicleImages", "name": "searchChronicleImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search chronicle images with pagination.\n * Uses indexed queries when possible for better performance on large libraries.\n */\nexport async function searchChronicleImages(filters: {\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, chronicleId, imageRefId, limit = 20, offset = 0 } = filters;\n\n  // Start with indexed query on chronicleId if provided, else projectId\n  const query = chronicleId\n    ? db.images.where(\"chronicleId\").equals(chronicleId)\n    : db.images.where(\"projectId\").equals(projectId);\n\n  let records = await query.toArray();\n\n  // Apply additional filters\n  if (chronicleId && !imageRefId) {\n    // Already filtered by chronicleId via index\n  } else if (imageRefId) {\n    records = records.filter((r) => r.imageRefId === imageRefId);\n  }\n\n  // Only include chronicle images\n  records = records.filter((r) => r.imageType === \"chronicle\");\n\n  // Sort by generatedAt descending\n  records.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  const total = records.length;\n\n  // Paginate\n  const items = records.slice(offset, offset + limit).map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "filters", "type": "{\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}", "optional": false}], "returnType": "Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::formatBytes", "name": "formatBytes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (!bytes || !Number.isFinite(bytes) || bytes <= 0) return \"0 B\";\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n}", "parameters": [{"name": "bytes", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::exportImagePrompts", "name": "exportImagePrompts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Bulk Export for Prompt Analysis\n// ============================================================================\n\n/**\n * Export all image prompt data for analysis.\n * Excludes image blobs to keep export size manageable.\n */\nexport async function exportImagePrompts(): Promise<ImagePromptExport[]> {\n  const records = await db.images.toArray();\n\n  const exports: ImagePromptExport[] = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    revisedPrompt: record.revisedPrompt,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    sceneDescription: record.sceneDescription,\n  }));\n\n  // Sort by generatedAt descending (newest first)\n  exports.sort((a, b) => b.generatedAt - a.generatedAt);\n  return exports;\n}", "parameters": [], "returnType": "Promise<ImagePromptExport[]>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::downloadImagePromptExport", "name": "downloadImagePromptExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Export image prompts and download as JSON file.\n */\nexport async function downloadImagePromptExport(): Promise<void> {\n  const exports = await exportImagePrompts();\n  const json = JSON.stringify(exports, null, 2);\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `image-prompts-${new Date().toISOString().split(\"T\")[0]}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n\n  console.log(`Exported ${exports.length} image prompt records`);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/indexComputation.ts::computeRunIndexes", "name": "computeRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexComputation.ts", "sourceCode": "export function computeRunIndexes(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): RunIndexRecord {\n  // --- Prominence scale (exclude manual_ entities) ---\n  const prominenceValues = entities\n    .filter((e) => !e.id.startsWith(\"manual_\"))\n    .map((e) => e.prominence)\n    .filter((v): v is number => typeof v === \"number\" && Number.isFinite(v));\n\n  const prominenceScale = buildProminenceScale(prominenceValues, {\n    distribution: DEFAULT_PROMINENCE_DISTRIBUTION,\n  });\n\n  const renownedThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  // --- Era temporal info ---\n  const eraEntities = entities.filter(\n    (e) => e.kind === \"era\" && (e as any).temporal?.startTick != null\n  );\n  const sortedEras = [...eraEntities].sort(\n    (a, b) => (a as any).temporal.startTick - (b as any).temporal.startTick\n  );\n\n  const eraTemporalInfo: EraTemporalEntry[] = sortedEras.map((era, index) => {\n    const startTick: number = (era as any).temporal.startTick;\n    const endTick: number = (era as any).temporal.endTick ?? startTick;\n    const eraId = resolveEntityEraId(era) || era.id;\n    return {\n      id: eraId,\n      name: era.name,\n      summary: (era as any).summary || \"\",\n      order: index,\n      startTick,\n      endTick,\n      duration: endTick - startTick,\n    };\n  });\n\n  // --- Era ID aliases (entityId -> eraId for eraTemporalInfoByKey) ---\n  const eraIdAliases: Record<string, string> = {};\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") continue;\n    const eraId = resolveEntityEraId(entity);\n    if (eraId) {\n      eraIdAliases[entity.id] = eraId;\n    }\n  }\n\n  // --- Prominent by culture (all entities, threshold from scale) ---\n  const prominentByCulture: Record<string, Array<{ id: string; name: string }>> = {};\n  for (const entity of entities) {\n    if (!entity.culture) continue;\n    if (typeof entity.prominence !== \"number\" || entity.prominence < renownedThreshold) continue;\n    if (!prominentByCulture[entity.culture]) {\n      prominentByCulture[entity.culture] = [];\n    }\n    prominentByCulture[entity.culture].push({ id: entity.id, name: entity.name });\n  }\n\n  return {\n    simulationRunId,\n    prominenceScale,\n    renownedThreshold,\n    eraTemporalInfo,\n    eraIdAliases,\n    prominentByCulture,\n    computedAt: Date.now(),\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "RunIndexRecord"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::getRunIndexes", "name": "getRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function getRunIndexes(simulationRunId: string): Promise<RunIndexRecord | undefined> {\n  return db.runIndexes.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<RunIndexRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::upsertRunIndexes", "name": "upsertRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function upsertRunIndexes(record: RunIndexRecord): Promise<void> {\n  await db.runIndexes.put(record);\n}", "parameters": [{"name": "record", "type": "RunIndexRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::deleteRunIndexes", "name": "deleteRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function deleteRunIndexes(simulationRunId: string): Promise<void> {\n  await db.runIndexes.delete(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts::migrateFromLegacyDbs", "name": "migrateFromLegacyDbs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Run all legacy migrations. Safe to call multiple times \u2014 already-migrated\n * databases are skipped via localStorage tracking.\n */\nexport async function migrateFromLegacyDbs(): Promise<void> {\n  const state = getState();\n  const allDbs = [\n    \"canonry-chronicles\",\n    \"canonry-images\",\n    \"canonry-costs\",\n    \"canonry-traits\",\n    \"canonry-historian\",\n    \"canonry-summary-revision\",\n    \"canonry-dynamics-generation\",\n    \"canonry-static-pages\",\n    \"illuminator-styles\",\n  ];\n\n  const pending = allDbs.filter((name) => !(name in state));\n  if (pending.length === 0) return;\n\n  console.log(`${LOG_PREFIX} Starting migration for ${pending.length} legacy databases:`, pending);\n\n  // Run all migrations in parallel \u2014 they're independent\n  await Promise.allSettled([\n    migrateChronicles(),\n    migrateImages(),\n    migrateCosts(),\n    migrateTraits(),\n    migrateHistorianRuns(),\n    migrateSummaryRevisionRuns(),\n    migrateDynamicsRuns(),\n    migrateStaticPages(),\n    migrateStyleLibrary(),\n  ]);\n\n  console.log(`${LOG_PREFIX} Migration complete`);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayout", "name": "getPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayout(\n  simulationRunId: string,\n  pageId: string\n): Promise<PageLayoutOverride | null> {\n  const record = await db.pageLayouts.get([simulationRunId, pageId]);\n  return record ?? null;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride | null>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::putPageLayout", "name": "putPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function putPageLayout(override: PageLayoutOverride): Promise<void> {\n  await db.pageLayouts.put(override);\n}", "parameters": [{"name": "override", "type": "PageLayoutOverride", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::deletePageLayout", "name": "deletePageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function deletePageLayout(simulationRunId: string, pageId: string): Promise<void> {\n  await db.pageLayouts.delete([simulationRunId, pageId]);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getAllPageLayouts", "name": "getAllPageLayouts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getAllPageLayouts(simulationRunId: string): Promise<PageLayoutOverride[]> {\n  return db.pageLayouts.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride[]>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayoutMap", "name": "getPageLayoutMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayoutMap(\n  simulationRunId: string\n): Promise<Map<string, PageLayoutOverride>> {\n  const all = await getAllPageLayouts(simulationRunId);\n  const map = new Map<string, PageLayoutOverride>();\n  for (const o of all) {\n    map.set(o.pageId, o);\n  }\n  return map;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, PageLayoutOverride>>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::isRelationshipsSeeded", "name": "isRelationshipsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isRelationshipsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.relationships.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[RelationshipRepo] isRelationshipsSeeded\", {\n    simulationRunId,\n    count,\n    seeded: count > 0,\n  });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::seedRelationships", "name": "seedRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "export async function seedRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<void> {\n  console.log(\"[RelationshipRepo] seedRelationships\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  const records: PersistedRelationship[] = relationships.map((rel) => ({\n    ...rel,\n    simulationRunId,\n  }));\n  await db.relationships.bulkPut(records);\n  console.log(\"[RelationshipRepo] seedRelationships complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::patchRelationships", "name": "patchRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Patch relationships without overwriting existing records.\n * Inserts only missing relationship keys (src/dst/kind).\n */\nexport async function patchRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<number> {\n  if (!relationships?.length) return 0;\n\n  const existing = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingKeys = new Set(existing.map((rel) => `${rel.src}:${rel.dst}:${rel.kind}`));\n\n  const toAdd: PersistedRelationship[] = [];\n  for (const rel of relationships) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!existingKeys.has(key)) {\n      toAdd.push({ ...rel, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.relationships.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForRun", "name": "getRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getRelationshipsForRun(\n  simulationRunId: string\n): Promise<PersistedRelationship[]> {\n  const relationships = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[RelationshipRepo] getRelationshipsForRun\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  return relationships;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForEntity", "name": "getRelationshipsForEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Get all relationships involving a specific entity (as src or dst).\n * Uses the existing 'src' and 'dst' indexes for efficient per-entity queries.\n */\nexport async function getRelationshipsForEntity(\n  simulationRunId: string,\n  entityId: string\n): Promise<PersistedRelationship[]> {\n  const [asSrc, asDst] = await Promise.all([\n    db.relationships\n      .where(\"src\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n    db.relationships\n      .where(\"dst\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n  ]);\n  const seen = new Set<string>();\n  const result: PersistedRelationship[] = [];\n  for (const rel of [...asSrc, ...asDst]) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(rel);\n    }\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::deleteRelationshipsForRun", "name": "deleteRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteRelationshipsForRun(simulationRunId: string): Promise<void> {\n  await db.relationships.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::getSchema", "name": "getSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function getSchema(projectId: string): Promise<WorldSchemaRecord | undefined> {\n  return db.worldSchemas.get(projectId);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<WorldSchemaRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::upsertSchema", "name": "upsertSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function upsertSchema(projectId: string, schema: CanonrySchemaSlice): Promise<void> {\n  await db.worldSchemas.put({\n    projectId,\n    schema,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function getSlot(\n  projectId: string,\n  slotIndex: number\n): Promise<SimulationSlotRecord | undefined> {\n  return db.simulationSlots.get([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<SimulationSlotRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::upsertSlot", "name": "upsertSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function upsertSlot(record: SimulationSlotRecord): Promise<void> {\n  await db.simulationSlots.put(record);\n}", "parameters": [{"name": "record", "type": "SimulationSlotRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::deleteSlot", "name": "deleteSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function deleteSlot(projectId: string, slotIndex: number): Promise<void> {\n  await db.simulationSlots.delete([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generatePageId", "name": "generatePageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generatePageId(): string {\n  return `static_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generateSlug", "name": "generateSlug", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, \"\")\n    .replace(/\\s+/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .substring(0, 100);\n}", "parameters": [{"name": "title", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::extractEntityLinks", "name": "extractEntityLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function extractEntityLinks(content: string): string[] {\n  const regex = /\\[\\[([^\\]]+)\\]\\]/g; // eslint-disable-line sonarjs/slow-regex -- character-class bounded, no backtracking\n  const matches: string[] = [];\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const entityName = match[1].trim();\n    if (entityName && !matches.includes(entityName)) {\n      matches.push(entityName);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::countWords", "name": "countWords", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function countWords(content: string): number {\n  /* eslint-disable sonarjs/slow-regex -- character-class bounded markdown patterns, no backtracking */\n  const plainText = content\n    .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, \"$1\")\n    .replace(/\\[\\[([^\\]]+)\\]\\]/g, \"$1\")\n    .replace(/!\\[[^\\]]*\\]\\([^)]+\\)/g, \"\")\n    /* eslint-enable sonarjs/slow-regex */\n    .replace(/[#*_~`>]/g, \"\")\n    .replace(/\\n+/g, \" \")\n    .trim();\n\n  if (!plainText) return 0;\n  return plainText.split(/\\s+/).length;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::createStaticPage", "name": "createStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function createStaticPage(input: CreateStaticPageInput): Promise<StaticPage> {\n  const now = Date.now();\n  const content = input.content ?? \"\";\n\n  const page: StaticPage = {\n    pageId: generatePageId(),\n    projectId: input.projectId,\n    title: input.title,\n    slug: generateSlug(input.title),\n    content,\n    summary: input.summary,\n    status: input.status ?? \"draft\",\n    createdAt: now,\n    updatedAt: now,\n    linkedEntityIds: extractEntityLinks(content),\n    wordCount: countWords(content),\n  };\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "input", "type": "CreateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::updateStaticPage", "name": "updateStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function updateStaticPage(\n  pageId: string,\n  updates: UpdateStaticPageInput\n): Promise<StaticPage> {\n  const page = await db.staticPages.get(pageId);\n  if (!page) throw new Error(`Static page ${pageId} not found`);\n\n  if (updates.title !== undefined) {\n    page.title = updates.title;\n    page.slug = generateSlug(updates.title);\n  }\n  if (updates.content !== undefined) {\n    page.content = updates.content;\n    page.linkedEntityIds = extractEntityLinks(updates.content);\n    page.wordCount = countWords(updates.content);\n  }\n  if (updates.summary !== undefined) {\n    page.summary = updates.summary;\n  }\n  if (updates.status !== undefined) {\n    page.status = updates.status;\n  }\n  page.updatedAt = Date.now();\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}, {"name": "updates", "type": "UpdateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPage", "name": "getStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPage(pageId: string): Promise<StaticPage | undefined> {\n  return db.staticPages.get(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await db.staticPages.where(\"projectId\").equals(projectId).toArray();\n  pages.sort((a, b) => b.updatedAt - a.updatedAt);\n  return pages;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getPublishedStaticPagesForProject", "name": "getPublishedStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getPublishedStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await getStaticPagesForProject(projectId);\n  return pages.filter((page) => page.status === \"published\");\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPage", "name": "deleteStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPage(pageId: string): Promise<void> {\n  await db.staticPages.delete(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPagesForProject(projectId: string): Promise<number> {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n  await db.staticPages.bulkDelete(pages.map((p) => p.pageId));\n  return pages.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::loadStyleLibrary", "name": "loadStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function loadStyleLibrary(): Promise<StyleLibrary | null> {\n  const result = await db.styleLibrary.get(LIBRARY_KEY);\n  return result?.library ?? null;\n}", "parameters": [], "returnType": "Promise<StyleLibrary | null>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::saveStyleLibrary", "name": "saveStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function saveStyleLibrary(library: StyleLibrary): Promise<void> {\n  const record: StyleLibraryRecord = {\n    id: LIBRARY_KEY,\n    library,\n    savedAt: Date.now(),\n  };\n  await db.styleLibrary.put(record);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::resetStyleLibrary", "name": "resetStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function resetStyleLibrary(): Promise<void> {\n  await db.styleLibrary.delete(LIBRARY_KEY);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::getStyleLibrary", "name": "getStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function getStyleLibrary(): Promise<StyleLibrary> {\n  const stored = await loadStyleLibrary();\n  if (stored) return stored;\n  return createDefaultStyleLibrary();\n}", "parameters": [], "returnType": "Promise<StyleLibrary>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::hasCustomStyleLibrary", "name": "hasCustomStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function hasCustomStyleLibrary(): Promise<boolean> {\n  const stored = await loadStyleLibrary();\n  return stored !== null;\n}", "parameters": [], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::generateRevisionRunId", "name": "generateRevisionRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export function generateRevisionRunId(): string {\n  return `revrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::createRevisionRun", "name": "createRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function createRevisionRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string,\n  batches: SummaryRevisionBatch[],\n  context: {\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }\n): Promise<SummaryRevisionRun> {\n  const now = Date.now();\n\n  const run: SummaryRevisionRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    batches,\n    currentBatchIndex: 0,\n    patchDecisions: {},\n    worldDynamicsContext: context.worldDynamicsContext,\n    staticPagesContext: context.staticPagesContext,\n    schemaContext: context.schemaContext,\n    revisionGuidance: context.revisionGuidance,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "batches", "type": "SummaryRevisionBatch[]", "optional": false}, {"name": "context", "type": "{\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }", "optional": false}], "returnType": "Promise<SummaryRevisionRun>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::getRevisionRun", "name": "getRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function getRevisionRun(runId: string): Promise<SummaryRevisionRun | undefined> {\n  return db.summaryRevisionRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<SummaryRevisionRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::updateRevisionRun", "name": "updateRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function updateRevisionRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<SummaryRevisionRun> {\n  const run = await db.summaryRevisionRuns.get(runId);\n  if (!run) throw new Error(`Revision run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.batches !== undefined) run.batches = updates.batches;\n  if (updates.currentBatchIndex !== undefined) run.currentBatchIndex = updates.currentBatchIndex;\n  if (updates.patchDecisions !== undefined) run.patchDecisions = updates.patchDecisions;\n  if (updates.error !== undefined) (run as any).error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<SummaryRevisionRun>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::deleteRevisionRun", "name": "deleteRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function deleteRevisionRun(runId: string): Promise<void> {\n  await db.summaryRevisionRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getPalette", "name": "getPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getPalette(\n  projectId: string,\n  entityKind: string\n): Promise<TraitPalette | null> {\n  const id = paletteId(projectId, entityKind);\n  const result = await db.traitPalettes.get(id);\n  return result || null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette | null>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::savePalette", "name": "savePalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function savePalette(palette: TraitPalette): Promise<void> {\n  await db.traitPalettes.put({\n    ...palette,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "palette", "type": "TraitPalette", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::updatePaletteItems", "name": "updatePaletteItems", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function updatePaletteItems(\n  projectId: string,\n  entityKind: string,\n  updates: {\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }\n): Promise<TraitPalette> {\n  const existing = await getPalette(projectId, entityKind);\n  const items = existing?.items || [];\n  const now = Date.now();\n\n  let filtered = items.filter((item) => !updates.removeIds?.includes(item.id));\n\n  for (const merge of updates.merges || []) {\n    const keepItem = filtered.find((i) => i.id === merge.keepId);\n    if (keepItem) {\n      keepItem.description = merge.newDescription;\n      const mergedItems = items.filter((i) => merge.mergeFromIds.includes(i.id));\n      keepItem.timesUsed += mergedItems.reduce((sum, i) => sum + i.timesUsed, 0);\n    }\n    filtered = filtered.filter((i) => !merge.mergeFromIds.includes(i.id));\n  }\n\n  for (const newItem of updates.newItems || []) {\n    filtered.push({\n      id: `palette_${now}_${crypto.randomUUID().slice(0, 8)}`,\n      category: newItem.category,\n      description: newItem.description,\n      examples: newItem.examples,\n      subtypes: newItem.subtypes,\n      era: newItem.era,\n      timesUsed: 0,\n      addedAt: now,\n    });\n  }\n\n  const palette: TraitPalette = {\n    id: paletteId(projectId, entityKind),\n    projectId,\n    entityKind,\n    items: filtered,\n    updatedAt: now,\n  };\n\n  await savePalette(palette);\n  return palette;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }", "optional": false}], "returnType": "Promise<TraitPalette>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::incrementPaletteUsage", "name": "incrementPaletteUsage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function incrementPaletteUsage(\n  projectId: string,\n  entityKind: string,\n  traits: string[]\n): Promise<void> {\n  const palette = await getPalette(projectId, entityKind);\n  if (!palette || palette.items.length === 0) return;\n\n  const traitLower = traits.map((t) => t.toLowerCase()).join(\" \");\n  let updated = false;\n\n  for (const item of palette.items) {\n    const categoryWords = item.category.toLowerCase().split(/\\s+/);\n    const exampleWords = item.examples.flatMap((e) => e.toLowerCase().split(/\\s+/));\n    const allWords = [...categoryWords, ...exampleWords];\n\n    const matches = allWords.filter((w) => w.length > 4 && traitLower.includes(w));\n    if (matches.length >= 2) {\n      item.timesUsed += 1;\n      updated = true;\n    }\n  }\n\n  if (updated) {\n    await savePalette(palette);\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::registerUsedTraits", "name": "registerUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function registerUsedTraits(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  entityId: string,\n  entityName: string,\n  traits: string[]\n): Promise<void> {\n  if (traits.length === 0) return;\n\n  const id = usedTraitId(projectId, simulationRunId, entityKind, entityId);\n\n  const record: UsedTraitRecord = {\n    id,\n    projectId,\n    simulationRunId,\n    entityKind,\n    entityId,\n    entityName,\n    traits,\n    registeredAt: Date.now(),\n  };\n\n  await db.usedTraits.put(record);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "entityName", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getUsedTraitsForRun", "name": "getUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string\n): Promise<UsedTraitRecord[]> {\n  if (!projectId || !simulationRunId || !entityKind) return [];\n\n  // Filter in memory \u2014 Dexie compound index not declared, use simple index\n  const records = await db.usedTraits.where(\"simulationRunId\").equals(simulationRunId).toArray();\n\n  return records.filter((r) => r.projectId === projectId && r.entityKind === entityKind);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<UsedTraitRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getHistoricalTraits", "name": "getHistoricalTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getHistoricalTraits(\n  projectId: string,\n  entityKind: string\n): Promise<string[]> {\n  if (!projectId || !entityKind) return [];\n\n  const records = await db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  return records.flatMap((r) => r.traits);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::countUsedTraits", "name": "countUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function countUsedTraits(projectId: string, entityKind: string): Promise<number> {\n  if (!projectId || !entityKind) return 0;\n\n  return db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .count();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getTraitGuidance", "name": "getTraitGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getTraitGuidance(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  subtype?: string,\n  eraId?: string\n): Promise<TraitGuidance> {\n  const palette = await getPalette(projectId, entityKind);\n  const allItems = palette?.items || [];\n\n  const categoryUsage: Record<string, number> = {};\n  for (const item of allItems) {\n    categoryUsage[item.category] = item.timesUsed;\n  }\n\n  if (!subtype) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  const subtypePool: PaletteItem[] = [];\n  const eraPool: PaletteItem[] = [];\n\n  for (const item of allItems) {\n    if (item.era) {\n      if (eraId && item.era.toLowerCase() === eraId.toLowerCase()) {\n        eraPool.push(item);\n      }\n    } else {\n      if (categoryMatchesSubtype(item, subtype)) {\n        subtypePool.push(item);\n      }\n    }\n  }\n\n  const numSubtypeCategories = Math.min(2, subtypePool.length);\n  const subtypeAssigned = selectCategoriesWeighted(subtypePool, numSubtypeCategories);\n  const eraAssigned = selectCategoriesWeighted(eraPool, 1);\n  const assigned = [...subtypeAssigned, ...eraAssigned];\n\n  if (assigned.length === 0) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  return {\n    assignedCategories: assigned,\n    categoryUsage,\n    selectionMethod: \"weighted-random\",\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "subtype", "type": "string", "optional": true}, {"name": "eraId", "type": "string", "optional": true}], "returnType": "Promise<TraitGuidance>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::deleteUsedTraitsForRun", "name": "deleteUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup / Export\n// ---------------------------------------------------------------------------\n\nexport async function deleteUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string\n): Promise<number> {\n  const records = await db.usedTraits\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  if (records.length === 0) return 0;\n  await db.usedTraits.bulkDelete(records.map((r) => r.id));\n  return records.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::exportPalettes", "name": "exportPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function exportPalettes(projectId: string): Promise<TraitPalette[]> {\n  return db.traitPalettes.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::importPalettes", "name": "importPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function importPalettes(palettes: TraitPalette[]): Promise<void> {\n  await db.traitPalettes.bulkPut(palettes);\n}", "parameters": [{"name": "palettes", "type": "TraitPalette[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::createScaffold", "name": "createScaffold", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Scaffold\n// =============================================================================\n\nexport function createScaffold(projectId: string, simulationRunId: string): ContentTreeState {\n  return {\n    projectId,\n    simulationRunId,\n    nodes: [\n      {\n        id: generateId(),\n        name: \"Front Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Title Page\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Copyright\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Table of Contents\", type: \"folder\", children: [] },\n        ],\n      },\n      {\n        id: generateId(),\n        name: \"Body\",\n        type: \"folder\",\n        children: [],\n      },\n      {\n        id: generateId(),\n        name: \"Back Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Appendix\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Glossary\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Index\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Colophon\", type: \"folder\", children: [] },\n        ],\n      },\n    ],\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::findNode", "name": "findNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function findNode(state: ContentTreeState, nodeId: string): ContentTreeNode | null {\n  return findInNodes(state.nodes, nodeId);\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeNode | null"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addFolder", "name": "addFolder", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Mutations\n// =============================================================================\n\nexport function addFolder(\n  state: ContentTreeState,\n  parentId: string,\n  name: string\n): ContentTreeState {\n  const newFolder: ContentTreeNode = {\n    id: generateId(),\n    name,\n    type: \"folder\",\n    children: [],\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newFolder, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::renameNode", "name": "renameNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function renameNode(\n  state: ContentTreeState,\n  nodeId: string,\n  name: string\n): ContentTreeState {\n  return {\n    ...state,\n    nodes: mapNodes(state.nodes, (node) => (node.id === nodeId ? { ...node, name } : { ...node })),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::deleteNode", "name": "deleteNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function deleteNode(state: ContentTreeState, nodeId: string): ContentTreeState {\n  return {\n    ...state,\n    nodes: removeNode(state.nodes, nodeId),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::moveNode", "name": "moveNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function moveNode(\n  state: ContentTreeState,\n  nodeId: string,\n  targetParentId: string,\n  index: number\n): ContentTreeState {\n  const node = findInNodes(state.nodes, nodeId);\n  if (!node) return state;\n\n  const withRemoved = removeNode(state.nodes, nodeId);\n  const withInserted = insertIntoParent(withRemoved, targetParentId, { ...node }, index);\n\n  return {\n    ...state,\n    nodes: withInserted,\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "targetParentId", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addContentItem", "name": "addContentItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function addContentItem(\n  state: ContentTreeState,\n  parentId: string,\n  item: { type: ContentNodeType; contentId: string; name: string }\n): ContentTreeState {\n  const newNode: ContentTreeNode = {\n    id: generateId(),\n    name: item.name,\n    type: item.type,\n    contentId: item.contentId,\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newNode, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "item", "type": "{ type: ContentNodeType; contentId: string; name: string }", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::flattenForExport", "name": "flattenForExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function flattenForExport(state: ContentTreeState): FlattenedNode[] {\n  const result: FlattenedNode[] = [];\n\n  function walk(nodes: ContentTreeNode[], parentPath: string, depth: number) {\n    nodes.forEach((node, index) => {\n      const prefix = String(index + 1).padStart(2, \"0\");\n      const segment = `${prefix}-${slugify(node.name)}`;\n      const path = parentPath ? `${parentPath}/${segment}` : segment;\n      result.push({ path, node, depth, index });\n      if (node.children) {\n        walk(node.children, path, depth + 1);\n      }\n    });\n  }\n\n  walk(state.nodes, \"\", 0);\n  return result;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "FlattenedNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::getAllContentIds", "name": "getAllContentIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Content ID Lookup\n// =============================================================================\n\nexport function getAllContentIds(state: ContentTreeState): Set<string> {\n  const ids = new Set<string>();\n  function walk(nodes: ContentTreeNode[]) {\n    for (const node of nodes) {\n      if (node.contentId) ids.add(node.contentId);\n      if (node.children) walk(node.children);\n    }\n  }\n  walk(state.nodes);\n  return ids;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "Set<string>"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::toArboristData", "name": "toArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Convert tree data to react-arborist format.\n * react-arborist expects { id, name, children } with children as arrays.\n */\nexport function toArboristData(nodes: ContentTreeNode[]): ContentTreeNode[] {\n  return nodes.map((node) => ({\n    ...node,\n    children: node.type === \"folder\" ? toArboristData(node.children || []) : undefined,\n  }));\n}", "parameters": [{"name": "nodes", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::fromArboristData", "name": "fromArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Rebuild ContentTreeNode[] from react-arborist's output after a move/reorder.\n */\nexport function fromArboristData(data: ContentTreeNode[]): ContentTreeNode[] {\n  return data.map((node) => ({\n    ...node,\n    children: node.children ? fromArboristData(node.children) : undefined,\n  }));\n}", "parameters": [{"name": "data", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::autoPopulateBody", "name": "autoPopulateBody", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Auto-populate the tree with content in Chronicler's natural book order.\n *\n * Body: eras in chronological order, each containing its narrative + chronicles.\n * Back Matter \u2192 Encyclopedia: entities grouped by culture then kind,\n *   each culture preceded by its static page.\n * Back Matter: remaining non-culture static pages.\n */\nexport function autoPopulateBody(\n  state: ContentTreeState,\n  input: AutoPopulateInput\n): ContentTreeState {\n  const bodyIndex = state.nodes.findIndex((n) => n.name === \"Body\" && n.type === \"folder\");\n  if (bodyIndex < 0) return state;\n\n  const backMatterIndex = state.nodes.findIndex(\n    (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n  );\n\n  // Collect existing content IDs to avoid duplicates\n  const existingIds = getAllContentIds(state);\n\n  // =========================================================================\n  // Body: Era folders with narratives + chronicles\n  // =========================================================================\n\n  const publishedChronicles = input.chronicles.filter(\n    (c) =>\n      (c.status === \"complete\" || c.status === \"assembly_ready\") && !existingIds.has(c.chronicleId)\n  );\n\n  const completedNarratives = input.eraNarratives.filter(\n    (n) =>\n      (n.status === \"complete\" || n.status === \"step_complete\") && !existingIds.has(n.narrativeId)\n  );\n\n  // Collect all era IDs from chronicles and narratives\n  const allEraIds = new Set<string>();\n  for (const c of publishedChronicles) {\n    if (c.focalEraId) allEraIds.add(c.focalEraId);\n  }\n  for (const n of completedNarratives) {\n    allEraIds.add(n.eraId);\n  }\n\n  const sortedEraIds = [...allEraIds].sort((a, b) => {\n    const orderA = input.eraOrder.get(a) ?? Infinity;\n    const orderB = input.eraOrder.get(b) ?? Infinity;\n    return orderA - orderB;\n  });\n\n  const bodyChildren: ContentTreeNode[] = [];\n\n  for (const eraId of sortedEraIds) {\n    const eraName =\n      completedNarratives.find((n) => n.eraId === eraId)?.eraName ||\n      publishedChronicles.find((c) => c.focalEraId === eraId)?.focalEraName ||\n      eraId;\n\n    const eraFolder: ContentTreeNode = {\n      id: generateId(),\n      name: eraName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Era narrative at top of folder (pick most recent if multiple)\n    const narrative = completedNarratives\n      .filter((n) => n.eraId === eraId)\n      .sort((a, b) => (b as any).updatedAt - (a as any).updatedAt)[0];\n    if (narrative) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: `${eraName} \u2014 Era Narrative`,\n        type: \"era_narrative\",\n        contentId: narrative.narrativeId,\n      });\n    }\n\n    // Chronicles sorted by eraYear then name\n    const eraChronicles = publishedChronicles\n      .filter((c) => c.focalEraId === eraId)\n      .sort((a, b) => {\n        const yearA = a.eraYear ?? Infinity;\n        const yearB = b.eraYear ?? Infinity;\n        if (yearA !== yearB) return yearA - yearB;\n        return a.title.localeCompare(b.title);\n      });\n\n    for (const c of eraChronicles) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n      });\n    }\n\n    if (eraFolder.children.length > 0) {\n      bodyChildren.push(eraFolder);\n    }\n  }\n\n  // Unassigned chronicles (no focalEra)\n  const unassigned = publishedChronicles\n    .filter((c) => !c.focalEraId)\n    .sort((a, b) => a.title.localeCompare(b.title));\n  if (unassigned.length > 0) {\n    const unassignedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Unassigned Era\",\n      type: \"folder\",\n      children: unassigned.map((c) => ({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\" as const,\n        contentId: c.chronicleId,\n      })),\n    };\n    bodyChildren.push(unassignedFolder);\n  }\n\n  // =========================================================================\n  // Back Matter \u2192 Encyclopedia: entities by culture then kind\n  // =========================================================================\n\n  const eligibleEntities = input.entities.filter(\n    (e) => e.description && e.kind !== \"era\" && !existingIds.has(e.id)\n  );\n\n  // Build culture \u2192 entity grouping\n  const byCulture = new Map<string, typeof eligibleEntities>();\n  const uncultured: typeof eligibleEntities = [];\n  for (const e of eligibleEntities) {\n    if (e.culture) {\n      const list = byCulture.get(e.culture) || [];\n      list.push(e);\n      byCulture.set(e.culture, list);\n    } else {\n      uncultured.push(e);\n    }\n  }\n\n  // Build culture name \u2192 static page mapping\n  const publishedPages = input.staticPages.filter(\n    (p) => p.status === \"published\" && !existingIds.has(p.pageId)\n  );\n  const culturePageMap = new Map<string, (typeof publishedPages)[number]>();\n  const nonCulturePages: typeof publishedPages = [];\n  for (const p of publishedPages) {\n    const { namespace, baseName } = parseNamespace(p.title);\n    if (namespace === \"Cultures\") {\n      culturePageMap.set(baseName.toLowerCase(), p);\n    } else {\n      nonCulturePages.push(p);\n    }\n  }\n\n  const encyclopediaChildren: ContentTreeNode[] = [];\n  const usedPageIds = new Set<string>();\n\n  const sortedCultures = [...byCulture.keys()].sort((a, b) => a.localeCompare(b));\n  for (const cultureName of sortedCultures) {\n    const cultureFolder: ContentTreeNode = {\n      id: generateId(),\n      name: cultureName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Culture static page at top\n    const culturePage = culturePageMap.get(cultureName.toLowerCase());\n    if (culturePage) {\n      cultureFolder.children.push({\n        id: generateId(),\n        name: culturePage.title,\n        type: \"static_page\",\n        contentId: culturePage.pageId,\n      });\n      usedPageIds.add(culturePage.pageId);\n    }\n\n    // Group entities by kind\n    const cultureEntities = byCulture.get(cultureName);\n    const byKind = new Map<string, typeof cultureEntities>();\n    for (const e of cultureEntities) {\n      const kind = e.kind;\n      const list = byKind.get(kind) || [];\n      list.push(e);\n      byKind.set(kind, list);\n    }\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      cultureFolder.children.push(kindFolder);\n    }\n\n    if (cultureFolder.children.length > 0) {\n      encyclopediaChildren.push(cultureFolder);\n    }\n  }\n\n  // Uncultured entities\n  if (uncultured.length > 0) {\n    const byKind = new Map<string, typeof uncultured>();\n    for (const e of uncultured) {\n      const list = byKind.get(e.kind) || [];\n      list.push(e);\n      byKind.set(e.kind, list);\n    }\n\n    const unculturedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Uncategorized\",\n      type: \"folder\",\n      children: [],\n    };\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      unculturedFolder.children.push(kindFolder);\n    }\n\n    if (unculturedFolder.children.length > 0) {\n      encyclopediaChildren.push(unculturedFolder);\n    }\n  }\n\n  // =========================================================================\n  // Assemble final tree\n  // =========================================================================\n\n  const newNodes = [...state.nodes];\n\n  // Replace Body children\n  newNodes[bodyIndex] = {\n    ...newNodes[bodyIndex],\n    children: bodyChildren,\n  };\n\n  // Add Encyclopedia + remaining static pages to Back Matter\n  if (backMatterIndex >= 0) {\n    const existingBackMatterChildren = [...(newNodes[backMatterIndex].children || [])];\n\n    // Insert Encyclopedia folder before existing back matter items\n    if (encyclopediaChildren.length > 0) {\n      const encyclopediaFolder: ContentTreeNode = {\n        id: generateId(),\n        name: \"Encyclopedia\",\n        type: \"folder\",\n        children: encyclopediaChildren,\n      };\n      existingBackMatterChildren.unshift(encyclopediaFolder);\n    }\n\n    // Add remaining non-culture static pages\n    const remainingPages = nonCulturePages.filter((p) => !usedPageIds.has(p.pageId));\n    for (const p of remainingPages) {\n      existingBackMatterChildren.push({\n        id: generateId(),\n        name: p.title,\n        type: \"static_page\",\n        contentId: p.pageId,\n      });\n    }\n\n    newNodes[backMatterIndex] = {\n      ...newNodes[backMatterIndex],\n      children: existingBackMatterChildren,\n    };\n  }\n\n  return {\n    ...state,\n    nodes: newNodes,\n    updatedAt: Date.now(),\n// ... (truncated)", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "input", "type": "AutoPopulateInput", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::escapeXml", "name": "escapeXml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// XML Helpers\n// =============================================================================\n\nexport function escapeXml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::renderParagraphs", "name": "renderParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "export function renderParagraphs(paras: IcmlParagraph[]): string {\n  if (paras.length === 0) return \"\";\n  return paras.map(renderParagraph).join(\"\\n    <Br/>\\n\");\n}", "parameters": [{"name": "paras", "type": "IcmlParagraph[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::parseInlineRuns", "name": "parseInlineRuns", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Inline Markdown Parsing \u2192 IcmlRun[]\n// =============================================================================\n\n/**\n * Parse inline markdown formatting into character style runs.\n * Handles: ***bold italic***, **bold**, *italic*, `code`\n */\nexport function parseInlineRuns(text: string): IcmlRun[] {\n  const runs: IcmlRun[] = [];\n  // Order matters: bold-italic before bold before italic\n  const pattern = /(\\*\\*\\*(.+?)\\*\\*\\*|\\*\\*(.+?)\\*\\*|\\*(.+?)\\*|`(.+?)`)/g;\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(text)) !== null) {\n    // Text before this match\n    if (match.index > lastIndex) {\n      runs.push({ charStyle: \"\", text: text.slice(lastIndex, match.index) });\n    }\n\n    if (match[2]) {\n      // ***bold italic***\n      runs.push({ charStyle: CS_BOLD_ITALIC, text: match[2] });\n    } else if (match[3]) {\n      // **bold**\n      runs.push({ charStyle: CS_BOLD, text: match[3] });\n    } else if (match[4]) {\n      // *italic*\n      runs.push({ charStyle: CS_ITALIC, text: match[4] });\n    } else if (match[5]) {\n      // `code`\n      runs.push({ charStyle: CS_CODE, text: match[5] });\n    }\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Remaining text\n  if (lastIndex < text.length) {\n    runs.push({ charStyle: \"\", text: text.slice(lastIndex) });\n  }\n\n  // If no runs were generated, add the full text as a default run\n  if (runs.length === 0 && text.length > 0) {\n    runs.push({ charStyle: \"\", text });\n  }\n\n  // Split runs containing \u263d (U+263D) so the crescent gets the Symbol char style\n  // which maps to Segoe UI Symbol \u2014 Junicode doesn't have this glyph.\n  return splitSymbolRuns(runs);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "IcmlRun[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::plainPara", "name": "plainPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a simple paragraph with a single default-style run */\nexport function plainPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: [{ charStyle: \"\", text }] };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::styledPara", "name": "styledPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a paragraph with inline markdown parsed into runs */\nexport function styledPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: parseInlineRuns(text) };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::markdownToIcmlParagraphs", "name": "markdownToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Convert markdown text to ICML paragraphs. Handles:\n * - Headings (# ## ###)\n * - Blockquotes (>)\n * - Horizontal rules (--- or ***)\n * - Image markers (<!-- IMAGE: ... -->)\n * - Inline formatting (**bold**, *italic*, ***both***, `code`)\n */\nexport function markdownToIcmlParagraphs(markdown: string): IcmlParagraph[] {\n  if (!markdown || !markdown.trim()) return [];\n\n  const paras: IcmlParagraph[] = [];\n  const lines = markdown.split(\"\\n\");\n  let blockLines: string[] = [];\n  let afterHeading = false;\n\n  function flushBlock() {\n    const text = blockLines.join(\" \").trim();\n    if (text) {\n      const style = afterHeading ? PS_BODY_FIRST : PS_BODY;\n      paras.push(styledPara(style, text));\n      afterHeading = false;\n    }\n    blockLines = [];\n  }\n\n  for (const rawLine of lines) {\n    const line = rawLine;\n    const trimmed = line.trim();\n\n    // Empty line = flush paragraph\n    if (!trimmed) {\n      flushBlock();\n      continue;\n    }\n\n    // Image marker\n    const img = parseImageMarker(trimmed);\n    if (img) {\n      flushBlock();\n      paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: ${img.path}]`));\n      if (img.caption) {\n        paras.push(plainPara(PS_CAPTION, img.caption));\n      }\n      afterHeading = false;\n      continue;\n    }\n\n    // Heading\n    const headingMatch = /^(#{1,3})\\s+(.+)$/.exec(trimmed); // eslint-disable-line sonarjs/slow-regex -- single markdown line\n    if (headingMatch) {\n      flushBlock();\n      const level = headingMatch[1].length;\n      let headingStyle: string;\n      if (level === 1) headingStyle = PS_HEADING1;\n      else if (level === 2) headingStyle = PS_HEADING2;\n      else headingStyle = PS_HEADING3;\n      paras.push(styledPara(headingStyle, headingMatch[2]));\n      afterHeading = true;\n      continue;\n    }\n\n    // Horizontal rule \u2192 separator\n    if (/^[-*_]{3,}\\s*$/.test(trimmed)) {\n      flushBlock();\n      paras.push(plainPara(PS_SEPARATOR, \"* * *\"));\n      afterHeading = false;\n      continue;\n    }\n\n    // Blockquote\n    if (trimmed.startsWith(\">\")) {\n      flushBlock();\n      const quoteText = trimmed.replace(/^>\\s*/, \"\");\n      paras.push(styledPara(PS_BLOCKQUOTE, quoteText));\n      afterHeading = false;\n      continue;\n    }\n\n    // Regular text \u2014 accumulate into block\n    blockLines.push(trimmed);\n  }\n\n  flushBlock();\n  return paras;\n}", "parameters": [{"name": "markdown", "type": "string", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::getImageExt", "name": "getImageExt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Content Formatters\n// =============================================================================\n\nexport function getImageExt(image?: ImageMetadataRecord): string {\n  if (!image?.mimeType) return \"\";\n  if (image.mimeType.includes(\"png\")) return \".png\";\n  if (image.mimeType.includes(\"jpeg\") || image.mimeType.includes(\"jpg\")) return \".jpg\";\n  if (image.mimeType.includes(\"webp\")) return \".webp\";\n  return \"\";\n}", "parameters": [{"name": "image", "type": "ImageMetadataRecord", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::annotateContentWithImages", "name": "annotateContentWithImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Insert image markers into content text and return annotated markdown.\n * Mirrors the logic from markdownExport.ts.\n */\nexport function annotateContentWithImages(\n  content: string,\n  imageRefs?: { refs?: any[] },\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): string {\n  if (!imageRefs?.refs || !content) return content;\n\n  let annotated = content;\n\n  // Prompt-request images\n  const promptRefs = imageRefs.refs.filter(\n    (r: any) => r.type === \"prompt_request\" && r.status === \"complete\" && r.generatedImageId\n  );\n  const promptInsertions = promptRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of promptInsertions) {\n    const imgId = ref.generatedImageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Entity-ref images\n  const entityRefs = imageRefs.refs.filter((r: any) => r.type === \"entity_ref\");\n  const entityInsertions = entityRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of entityInsertions) {\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: entity-portrait-${ref.entityId} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Chronicle-ref images (for era narratives)\n  const chronicleRefs = imageRefs.refs.filter((r: any) => r.type === \"chronicle_ref\");\n  const chronicleInsertions = chronicleRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of chronicleInsertions) {\n    const imgId = ref.imageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  return annotated;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "imageRefs", "type": "{ refs?: any[] }", "optional": true}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::entityToIcmlParagraphs", "name": "entityToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an entity to ICML paragraphs */\nexport function entityToIcmlParagraphs(\n  entity: PersistedEntity,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, entity.name));\n\n  // Subtitle: kind / subtype\n  const subtitleParts = [entity.kind];\n  if (entity.subtype) subtitleParts.push(entity.subtype);\n  if (entity.culture) subtitleParts.push(entity.culture);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Metadata\n  paras.push(plainPara(PS_METADATA, `Prominence: ${entity.prominence} | Status: ${entity.status}`));\n\n  const aliases = entity.enrichment?.text?.aliases;\n  if (aliases?.length) {\n    paras.push(plainPara(PS_METADATA, `Also known as: ${aliases.join(\", \")}`));\n  }\n\n  if (entity.tags && Object.keys(entity.tags).length > 0) {\n    const tagStr = Object.entries(entity.tags)\n      .map(([k, v]) => `${k}: ${v}`)\n      .join(\" | \");\n    paras.push(plainPara(PS_METADATA, tagStr));\n  }\n\n  // Entity image\n  const imageId = entity.enrichment?.image?.imageId;\n  if (imageId) {\n    registerFn(imageId, \"entity\", entity.id, entity.name);\n    const ext = getImageExt(imageMap.get(imageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${imageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, `${entity.name} portrait`));\n  }\n\n  // Summary\n  if (entity.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, entity.summary));\n  }\n\n  // Description body\n  if (entity.description) {\n    const bodyParas = markdownToIcmlParagraphs(entity.description);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = entity.enrichment?.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::chronicleToIcmlParagraphs", "name": "chronicleToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a chronicle to ICML paragraphs */\nexport function chronicleToIcmlParagraphs(\n  chronicle: ChronicleRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const content = chronicle.finalContent || chronicle.assembledContent || \"\";\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, chronicle.title || \"Untitled Chronicle\"));\n\n  // Subtitle\n  const subtitleParts = [chronicle.format, chronicle.focusType];\n  if (chronicle.narrativeStyle?.name) subtitleParts.push(chronicle.narrativeStyle.name);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Summary\n  if (chronicle.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, chronicle.summary));\n  }\n\n  // Cover image\n  const coverImageId = chronicle.coverImage?.generatedImageId;\n  if (coverImageId && chronicle.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\", undefined, undefined, chronicle.chronicleId);\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, chronicle.title || \"Cover\"));\n  }\n\n  // Cast\n  if (chronicle.roleAssignments?.length) {\n    paras.push(plainPara(PS_HEADING2, \"Cast\"));\n    for (const ra of chronicle.roleAssignments) {\n      const emphasis = ra.isPrimary ? \"Primary\" : \"Supporting\";\n      paras.push({\n        paraStyle: PS_CAST_ENTRY,\n        runs: [\n          { charStyle: CS_BOLD, text: ra.role },\n          { charStyle: \"\", text: ` \\u2014 ${ra.entityName} (${ra.entityKind}, ${emphasis})` },\n        ],\n      });\n    }\n  }\n\n  // Narrative content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      chronicle.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = chronicle.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::eraNarrativeToIcmlParagraphs", "name": "eraNarrativeToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an era narrative to ICML paragraphs */\nexport function eraNarrativeToIcmlParagraphs(\n  narrative: EraNarrativeRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const { content } = resolveActiveContent(narrative);\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, narrative.eraName));\n\n  // Subtitle\n  paras.push(plainPara(PS_ITEM_SUBTITLE, `${narrative.tone} \\u2022 era narrative`));\n\n  // Thesis\n  if (narrative.threadSynthesis?.thesis) {\n    paras.push(styledPara(PS_BLOCKQUOTE, narrative.threadSynthesis.thesis));\n  }\n\n  // Threads\n  if (narrative.threadSynthesis?.threads?.length) {\n    const threadNames = narrative.threadSynthesis.threads.map((t: any) => t.name).join(\", \");\n    paras.push(plainPara(PS_METADATA, `Threads: ${threadNames}`));\n  }\n\n  // Cover image\n  const coverImageId = narrative.coverImage?.generatedImageId;\n  if (coverImageId && narrative.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\");\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, narrative.eraName));\n  }\n\n  // Content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      narrative.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "narrative", "type": "EraNarrativeRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::staticPageToIcmlParagraphs", "name": "staticPageToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a static page to ICML paragraphs */\nexport function staticPageToIcmlParagraphs(page: StaticPage): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, page.title));\n\n  // Content (already markdown with headings, etc.)\n  if (page.content) {\n    const bodyParas = markdownToIcmlParagraphs(page.content);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "page", "type": "StaticPage", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::createImageRegistrar", "name": "createImageRegistrar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Image Registration (mirrors markdownExport.ts pattern)\n// =============================================================================\n\nexport function createImageRegistrar(\n  referencedImages: Map<string, ExportImageEntry>,\n  imageMap: Map<string, ImageMetadataRecord>\n) {\n  return function registerImage(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ): void {\n    if (referencedImages.has(imgId)) return;\n    const img = imageMap.get(imgId);\n    const ext = getImageExt(img);\n    referencedImages.set(imgId, {\n      imageId: imgId,\n      filename: `${imgId}${ext}`,\n      width: img?.width,\n      height: img?.height,\n      aspect: img?.aspect,\n      imageType: type,\n      entityId: entityId || img?.entityId,\n      entityName: entityName || img?.entityName,\n      chronicleId: chronicleId || img?.chronicleId,\n      mimeType: img?.mimeType,\n    });\n  };\n}", "parameters": [{"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}], "returnType": "(imgId: string, type: any, entityId?: string, entityName?: string, chronicleId?: string) => void"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookParagraphs", "name": "buildBookParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Walk the content tree and produce an array of styled paragraphs.\n * Used by both ICML and IDML generators.\n */\nexport function buildBookParagraphs(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): IcmlParagraph[] {\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allParagraphs: IcmlParagraph[] = [];\n  const flattened = flattenForExport(treeState);\n  let prevWasContent = false;\n\n  for (const { node, depth } of flattened) {\n    if (node.type === \"folder\") {\n      if (prevWasContent) {\n        allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n        prevWasContent = false;\n      }\n\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      allParagraphs.push(plainPara(headingStyle, node.name));\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    if (prevWasContent) {\n      allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n    }\n\n    let contentParas: IcmlParagraph[] = [];\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n      }\n    }\n\n    if (contentParas.length > 0) {\n      allParagraphs.push(...contentParas);\n      prevWasContent = true;\n    }\n  }\n\n  return allParagraphs;\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookIcml", "name": "buildBookIcml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Build a complete ICML document from the content tree.\n * Wraps the shared paragraph output in ICML document structure.\n */\nexport function buildBookIcml(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): string {\n  const allParagraphs = buildBookParagraphs(treeState, contentMaps, imageMap, referencedImages);\n\n  const parts: string[] = [];\n  parts.push(ICML_HEADER);\n  parts.push(buildStyleDefinitions());\n  parts.push(buildStoryOpen());\n  parts.push(renderParagraphs(allParagraphs));\n  parts.push(ICML_FOOTER);\n  return parts.join(\"\\n\");\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts::buildIdmlPackage", "name": "buildIdmlPackage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build a complete IDML package as a Blob.\n *\n * The .idml file is a ZIP containing all the XML files that define\n * an InDesign document. Each content entry gets its own story and spread(s).\n */\nexport async function buildIdmlPackage(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  layoutOptions?: IdmlLayoutOptions\n): Promise<Blob> {\n  const layout = resolveLayout(layoutOptions);\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allStories: StoryFile[] = [];\n  const allSpreads: SpreadFile[] = [];\n  let currentPageNum = 1;\n  let entryCounter = 0;\n\n  const flattened = flattenForExport(treeState);\n\n  for (const { node, depth } of flattened) {\n    const entryId = `e${entryCounter++}`;\n\n    if (node.type === \"folder\") {\n      // Folder heading: simple story + 2-page spread\n      const storyId = `story_${entryId}`;\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      const paras = [plainPara(headingStyle, node.name)];\n\n      const storyXml = buildEntryStoryXml(storyId, paras, []);\n      allStories.push({\n        filename: `Stories/Story_${storyId}.xml`,\n        xml: storyXml,\n        storyId,\n      });\n\n      const masterId = MASTERS.D.spreadId; // folders use D-Encyclopedia master\n      const { spreads, pagesUsed } = buildEntrySpreads(\n        entryId,\n        storyId,\n        masterId,\n        2,\n        currentPageNum,\n        [],\n        [],\n        layout\n      );\n      allSpreads.push(...spreads);\n      currentPageNum += pagesUsed;\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    // Content entry: build paragraphs, classify notes, collect images\n    let contentParas: IcmlParagraph[] = [];\n    let footnotes: FootnoteInsert[] = [];\n    let callouts: { anchorPhrase: string; noteText: string; noteType: string }[] = [];\n    let images: ImagePlacement[] = [];\n    const masterKey = selectMaster(node.type, contentMaps, node.contentId);\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(entity.enrichment?.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(entity, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(chronicle.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(chronicle, imageMap);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n        // Era narratives don't have historian notes\n        images = collectEntryImages(narrative, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n        // Static pages have no images or notes\n      }\n    }\n\n    if (contentParas.length === 0) continue;\n\n    // Strip historian note paragraphs from the main content \u2014 in IDML,\n    // popout notes become inline footnotes and full notes become callout stories\n    if (footnotes.length > 0 || callouts.length > 0) {\n      contentParas = stripHistorianNotes(contentParas);\n    }\n\n    // Build main story (with inline footnotes)\n    const storyId = `story_${entryId}`;\n    const storyXml = buildEntryStoryXml(storyId, contentParas, footnotes);\n    allStories.push({\n      filename: `Stories/Story_${storyId}.xml`,\n      xml: storyXml,\n      storyId,\n    });\n\n    // Build callout stories\n    const calloutStoryRefs: { storyId: string }[] = [];\n    for (let ci = 0; ci < callouts.length; ci++) {\n      const callout = callouts[ci];\n      const calloutStoryId = `story_${entryId}_co${ci}`;\n      const calloutXml = buildCalloutStoryXml(\n        calloutStoryId,\n        callout.noteType,\n        callout.noteText,\n        callout.anchorPhrase\n      );\n      allStories.push({\n        filename: `Stories/Story_${calloutStoryId}.xml`,\n        xml: calloutXml,\n        storyId: calloutStoryId,\n      });\n      calloutStoryRefs.push({ storyId: calloutStoryId });\n    }\n\n    // Estimate pages and build spreads\n    const pageCount = estimateEntryPages(contentParas, images.length, layout.linesPerPage);\n    const masterId = MASTERS[masterKey].spreadId;\n\n    const { spreads, pagesUsed } = buildEntrySpreads(\n      entryId,\n      storyId,\n      masterId,\n      pageCount,\n      currentPageNum,\n      images,\n      calloutStoryRefs,\n      layout\n    );\n    allSpreads.push(...spreads);\n    currentPageNum += pagesUsed;\n  }\n\n  // Build master spread files\n  const masterKeys: MasterKey[] = [\"A\", \"B\", \"C\", \"D\"];\n  const masterSpreadFiles: { spreadId: string; filename: string }[] = [];\n  const masterStoryIds: string[] = [];\n\n  const zip = new JSZip();\n\n  // mimetype MUST be the first entry (uncompressed)\n  zip.file(\"mimetype\", MIMETYPE);\n\n  for (const key of masterKeys) {\n    const master = MASTERS[key];\n    const filename = `MasterSpreads/MasterSpread_${master.spreadId}.xml`;\n    zip.file(filename, buildMasterSpreadXml(master, layout));\n    masterSpreadFiles.push({ spreadId: master.spreadId, filename });\n\n    // Master story\n    const masterStoryFilename = `Stories/Story_${master.storyId}.xml`;\n    zip.file(masterStoryFilename, buildMasterStoryXml(master.storyId));\n    masterStoryIds.push(master.storyId);\n  }\n\n  // Structural files\n  zip.file(\"META-INF/container.xml\", buildContainerXml());\n\n  // Resources\n  zip.file(\"Resources/Graphic.xml\", buildGraphicXml());\n  zip.file(\"Resources/Fonts.xml\", buildFontsXml(layout.fontFamily));\n  zip.file(\"Resources/Styles.xml\", buildStylesXml(layout));\n  zip.file(\"Resources/Preferences.xml\", buildPreferencesXml(layout));\n\n  // Entry spreads\n  for (const spread of allSpreads) {\n    zip.file(spread.filename, spread.xml);\n  }\n\n  // Entry stories\n  for (const story of allStories) {\n    zip.file(story.filename, story.xml);\n  }\n\n  // XML structure\n  zip.file(\"XML/BackingStory.xml\", buildBackingStoryXml());\n  zip.file(\"XML/Tags.xml\", buildTagsXml());\n\n  // Designmap (must reference everything)\n  const totalPages = currentPageNum - 1;\n  zip.file(\n    \"designmap.xml\",\n    buildDesignmap(masterSpreadFiles, allSpreads, allStories, masterStoryIds, totalPages)\n  );\n\n  // Generate with STORE compression (standard for IDML)\n  return zip.generateAsync({ type: \"blob\", compression: \"STORE\" });\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "layoutOptions", "type": "IdmlLayoutOptions", "optional": true}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildExportZip", "name": "buildExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildExportZip(options: ExportOptions): Promise<Blob> {\n  const {\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  } = options;\n\n  const zip = new JSZip();\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n\n  // Collect all referenced image IDs for the manifest\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Flatten tree and generate files\n  const flattened = flattenForExport(treeState);\n\n  for (const { path, node } of flattened) {\n    if (node.type === \"folder\") {\n      // Create empty directory entry\n      zip.folder(path);\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    let markdown: string | null = null;\n\n    if (node.type === \"entity\") {\n      const entity = entityMap.get(node.contentId);\n      if (entity) {\n        markdown = formatEntityMarkdown(entity, referencedImages, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = chronicleMap.get(node.contentId);\n      if (chronicle) {\n        markdown = formatChronicleMarkdown(chronicle, referencedImages, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = pageMap.get(node.contentId);\n      if (page) {\n        markdown = formatStaticPageMarkdown(page, entities);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = narrativeMap.get(node.contentId);\n      if (narrative) {\n        markdown = formatEraNarrativeMarkdown(narrative, referencedImages, imageMap);\n      }\n    }\n\n    if (markdown) {\n      const filename = slugify(node.name) + \".md\";\n      zip.file(`${path}/${filename}`, markdown);\n    }\n  }\n\n  // Build manifest\n  const manifest = buildManifest(\n    treeState,\n    entities,\n    chronicles,\n    staticPages,\n    eraNarratives,\n    images,\n    referencedImages,\n    projectId,\n    simulationRunId,\n    s3Config\n  );\n  zip.file(\"manifest.json\", JSON.stringify(manifest, null, 2));\n\n  // S3 download script\n  if (s3Config) {\n    zip.file(\n      \"s3-config.json\",\n      JSON.stringify(\n        {\n          bucket: s3Config.bucket,\n          basePrefix: s3Config.basePrefix,\n          rawPrefix: s3Config.rawPrefix,\n          projectId,\n          region: s3Config.region,\n        },\n        null,\n        2\n      )\n    );\n\n    zip.file(\"download-images.sh\", buildDownloadScript());\n  }\n\n  return zip.generateAsync({ type: \"blob\" });\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildInDesignExportZip", "name": "buildInDesignExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildInDesignExportZip(options: ExportOptions): Promise<Blob> {\n  const { treeState, entities, chronicles, images, staticPages, eraNarratives, idmlLayout } =\n    options;\n\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Build a complete IDML package \u2014 opens directly in InDesign.\n  // IDML is already a ZIP internally, so we return the blob directly\n  // rather than wrapping it in another ZIP.\n  return buildIdmlPackage(\n    treeState,\n    { entityMap, chronicleMap, pageMap, narrativeMap },\n    imageMap,\n    referencedImages,\n    idmlLayout\n  );\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildIdmlImageScript", "name": "buildIdmlImageScript", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "// =============================================================================\n// IDML Image Download Script\n// =============================================================================\n\n/**\n * Generates a self-contained bash script that downloads all images referenced\n * by the IDML export from S3. The script embeds the S3 config and image list\n * directly \u2014 no manifest.json or s3-config.json needed.\n *\n * Place the script next to the .idml file and run it. It creates images/\n * alongside the IDML so InDesign resolves the `file:images/...` links.\n */\nexport function buildIdmlImageScript(options: ExportOptions): string {\n  const { entities, chronicles, eraNarratives, images, projectId, s3Config } = options;\n  if (!s3Config) return \"\";\n\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const seen = new Set<string>();\n  const imageEntries: { id: string; filename: string }[] = [];\n\n  // Match the extension logic used by idmlExport's collectEntryImages\n  // (defaults to .png when mimeType is unknown)\n  function idmlExt(img?: ImageMetadataRecord): string {\n    if (!img?.mimeType) return \".png\";\n    if (img.mimeType.includes(\"png\")) return \".png\";\n    if (img.mimeType.includes(\"jpeg\") || img.mimeType.includes(\"jpg\")) return \".jpg\";\n    if (img.mimeType.includes(\"webp\")) return \".webp\";\n    return \".png\";\n  }\n\n  function addImage(imageId: string) {\n    if (!imageId || seen.has(imageId)) return;\n    // Skip image IDs not present in metadata \u2014 they are likely malformed\n    // composite keys (e.g. chronicleId:imageRefId) that won't exist in S3\n    if (!imageMap.has(imageId)) return;\n    seen.add(imageId);\n    const ext = idmlExt(imageMap.get(imageId));\n    imageEntries.push({ id: imageId, filename: `${imageId}${ext}` });\n  }\n\n  // Entity portraits\n  for (const entity of entities) {\n    const imageId = entity.enrichment?.image?.imageId;\n    if (imageId) addImage(imageId);\n  }\n\n  // Chronicle covers and scene images\n  for (const chronicle of chronicles) {\n    if (chronicle.coverImage?.generatedImageId && chronicle.coverImage.status === \"complete\") {\n      addImage(chronicle.coverImage.generatedImageId);\n    }\n    if (chronicle.imageRefs?.refs) {\n      for (const ref of chronicle.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n      }\n    }\n  }\n\n  // Era narrative covers and inline refs\n  for (const narrative of eraNarratives) {\n    if (narrative.coverImage?.generatedImageId && narrative.coverImage?.status === \"complete\") {\n      addImage(narrative.coverImage.generatedImageId);\n    }\n    if (narrative.imageRefs?.refs) {\n      for (const ref of narrative.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n        if (ref.type === \"chronicle_ref\" && ref.imageId) {\n          addImage(ref.imageId);\n        }\n      }\n    }\n  }\n\n  if (imageEntries.length === 0) {\n    return `#!/usr/bin/env bash\n# No images referenced in this export.\necho \"No images to download.\"\n`;\n  }\n\n  const downloads = imageEntries.map((e) => `download_image \"${e.id}\" \"${e.filename}\"`).join(\"\\n\");\n\n  return `#!/usr/bin/env bash\n# Download images from S3 for InDesign IDML import\n# Generated by Illuminator Pre-Print Export\n#\n# Place this script next to your .idml file, then run it.\n# It creates an images/ directory alongside the IDML file\n# so InDesign resolves the linked image paths automatically.\n\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"\\${BASH_SOURCE[0]}\")\" && pwd)\"\nIMAGE_DIR=\"\\${SCRIPT_DIR}/images\"\n\n# --- Embedded S3 Configuration ---\nBUCKET=\"${s3Config.bucket}\"\nBASE_PREFIX=\"${s3Config.basePrefix}\"\nRAW_PREFIX=\"${s3Config.rawPrefix}\"\nPROJECT_ID=\"${projectId}\"\nREGION=\"${s3Config.region}\"\n\n# Build S3 key prefix, filtering out empty segments\nS3_PREFIX=$(echo \"\\${BASE_PREFIX}/\\${RAW_PREFIX}/\\${PROJECT_ID}\" | sed 's|/\\\\+|/|g; s|^/||; s|/$||')\n\n# --- Pre-flight checks ---\nif ! command -v aws &>/dev/null; then\n  echo \"ERROR: aws CLI is required but not installed.\"\n  echo \"  Install: https://aws.amazon.com/cli/\"\n  exit 1\nfi\n\nmkdir -p \"\\${IMAGE_DIR}\"\n\necho \"Downloading ${imageEntries.length} images from s3://\\${BUCKET}/\\${S3_PREFIX}/\"\necho \"Region: \\${REGION}\"\necho \"Target: \\${IMAGE_DIR}/\"\necho \"\"\n\nDOWNLOADED=0\nSKIPPED=0\nFAILED=0\n\ndownload_image() {\n  local IMAGE_ID=\"\\$1\"\n  local FILENAME=\"\\$2\"\n  local DEST=\"\\${IMAGE_DIR}/\\${FILENAME}\"\n\n  if [ -f \"\\${DEST}\" ]; then\n    SKIPPED=$((SKIPPED + 1))\n    return\n  fi\n\n  local S3_KEY=\"\\${S3_PREFIX}/\\${IMAGE_ID}\"\n  echo \"  GET  \\${FILENAME}\"\n  if aws s3 cp \"s3://\\${BUCKET}/\\${S3_KEY}\" \"\\${DEST}\" --region \"\\${REGION}\" --quiet 2>/dev/null; then\n    DOWNLOADED=$((DOWNLOADED + 1))\n  else\n    echo \"  FAIL \\${FILENAME}\"\n    FAILED=$((FAILED + 1))\n  fi\n}\n\n${downloads}\n\necho \"\"\necho \"Done. Downloaded: \\${DOWNLOADED}  Skipped: \\${SKIPPED}  Failed: \\${FAILED}\"\necho \"Images directory: \\${IMAGE_DIR}\"\n`;\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts::computePrePrintStats", "name": "computePrePrintStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts", "sourceCode": "export function computePrePrintStats(\n  entities: PersistedEntity[],\n  chronicles: ChronicleRecord[],\n  images: ImageMetadataRecord[],\n  staticPages: StaticPage[],\n  eraNarratives: EraNarrativeRecord[]\n): PrePrintStats {\n  // Filter to publishable content\n  const publishedChronicles = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n  const publishedPages = staticPages.filter((p) => p.status === \"published\");\n  const completedNarratives = eraNarratives.filter(\n    (n) => n.status === \"complete\" || n.status === \"step_complete\"\n  );\n\n  // =========================================================================\n  // Word & Character Counts\n  // =========================================================================\n\n  const chronicleBodyTexts = publishedChronicles.map(getPublishedContent);\n  const chronicleSummaryTexts = publishedChronicles.map((c) => c.summary || \"\");\n  const entityDescTexts = entities.map((e) => e.description || \"\");\n  const entitySummaryTexts = entities.map((e) => e.summary || \"\");\n  const captionTexts = collectCaptions(publishedChronicles);\n  const pageTexts = publishedPages.map((p) => p.content || \"\");\n\n  // Era narrative content from active version (with legacy fallback)\n  const narrativeTexts = completedNarratives.map((n) => {\n    const { content } = resolveActiveContent(n);\n    return content || \"\";\n  });\n\n  // Historian notes: collect from both entities and chronicles\n  const entityHistorianNotes: HistorianNote[] = [];\n  for (const e of entities) {\n    if (e.enrichment?.historianNotes?.length) {\n      entityHistorianNotes.push(...e.enrichment.historianNotes);\n    }\n  }\n  const chronicleHistorianNotes: HistorianNote[] = [];\n  for (const c of publishedChronicles) {\n    if (c.historianNotes?.length) {\n      chronicleHistorianNotes.push(...c.historianNotes);\n    }\n  }\n  const allHistorianNotes = [...entityHistorianNotes, ...chronicleHistorianNotes];\n\n  const sumWords = (texts: string[]) => texts.reduce((s, t) => s + countWords(t), 0);\n  const sumChars = (texts: string[]) => texts.reduce((s, t) => s + countChars(t), 0);\n\n  const entityHistorianNoteText = collectHistorianNoteTexts(entityHistorianNotes);\n  const chronicleHistorianNoteText = collectHistorianNoteTexts(chronicleHistorianNotes);\n\n  const wordBreakdown: WordCountBreakdown = {\n    chronicleBody: sumWords(chronicleBodyTexts),\n    chronicleSummaries: sumWords(chronicleSummaryTexts),\n    entityDescriptions: sumWords(entityDescTexts),\n    entitySummaries: sumWords(entitySummaryTexts),\n    eraNarrativeContent: sumWords(narrativeTexts),\n    imageCaptions: sumWords(captionTexts),\n    historianNotesEntity: countWords(entityHistorianNoteText),\n    historianNotesChronicle: countWords(chronicleHistorianNoteText),\n    staticPageContent: sumWords(pageTexts),\n  };\n\n  const charBreakdown: CharCountBreakdown = {\n    chronicleBody: sumChars(chronicleBodyTexts),\n    chronicleSummaries: sumChars(chronicleSummaryTexts),\n    entityDescriptions: sumChars(entityDescTexts),\n    entitySummaries: sumChars(entitySummaryTexts),\n    eraNarrativeContent: sumChars(narrativeTexts),\n    imageCaptions: sumChars(captionTexts),\n    historianNotesEntity: countChars(entityHistorianNoteText),\n    historianNotesChronicle: countChars(chronicleHistorianNoteText),\n    staticPageContent: sumChars(pageTexts),\n  };\n\n  const totalWords = Object.values(wordBreakdown).reduce((s, v) => s + v, 0);\n  const totalChars = Object.values(charBreakdown).reduce((s, v) => s + v, 0);\n\n  // =========================================================================\n  // Image Stats\n  // =========================================================================\n\n  const byAspect: Record<ImageAspect, number> = { portrait: 0, landscape: 0, square: 0 };\n  const byType: Record<ImageType | \"cover\", number> = { entity: 0, chronicle: 0, cover: 0 };\n  const bySize: Record<ChronicleImageSize, number> = {\n    small: 0,\n    medium: 0,\n    large: 0,\n    \"full-width\": 0,\n  };\n\n  let minW = Infinity,\n    maxW = 0,\n    minH = Infinity,\n    maxH = 0;\n  let hasDimensions = false;\n\n  for (const img of images) {\n    const aspect = img.aspect || \"square\";\n    byAspect[aspect]++;\n\n    const isCover = img.imageRefId === \"__cover_image__\";\n    const type = isCover ? \"cover\" : img.imageType || \"entity\";\n    byType[type]++;\n\n    if (img.width && img.height) {\n      hasDimensions = true;\n      if (img.width < minW) minW = img.width;\n      if (img.width > maxW) maxW = img.width;\n      if (img.height < minH) minH = img.height;\n      if (img.height > maxH) maxH = img.height;\n    }\n  }\n\n  // Count image size designations from chronicle image refs\n  for (const c of publishedChronicles) {\n    if (!c.imageRefs?.refs) continue;\n    for (const ref of c.imageRefs.refs) {\n      bySize[ref.size]++;\n    }\n  }\n\n  const totalStorageBytes = images.reduce((s, img) => s + (img.size || 0), 0);\n\n  const imageStats: ImageStats = {\n    total: images.length,\n    totalStorageBytes,\n    byAspect,\n    byType,\n    bySize,\n    dimensionRange: hasDimensions\n      ? { minWidth: minW, maxWidth: maxW, minHeight: minH, maxHeight: maxH }\n      : null,\n  };\n\n  // =========================================================================\n  // Completeness\n  // =========================================================================\n\n  const entitiesWithImage = entities.filter((e) => e.enrichment?.image?.imageId).length;\n  const totalEras = entities.filter((e) => e.kind === \"era\").length;\n\n  const completeness: CompletenessStats = {\n    entitiesTotal: entities.length,\n    entitiesWithDescription: entities.filter((e) => e.description).length,\n    entitiesWithImage,\n    entitiesWithSummary: entities.filter((e) => e.summary).length,\n    chroniclesTotal: publishedChronicles.length,\n    chroniclesPublished: publishedChronicles.filter((c) => c.status === \"complete\").length,\n    chroniclesWithHistorianNotes: publishedChronicles.filter((c) => c.historianNotes?.length)\n      .length,\n    chroniclesWithSceneImages: publishedChronicles.filter((c) =>\n      c.imageRefs?.refs?.some((r) => r.type === \"prompt_request\" && r.status === \"complete\")\n    ).length,\n    staticPagesTotal: staticPages.length,\n    staticPagesPublished: publishedPages.length,\n    eraNarrativesTotal: totalEras,\n    eraNarrativesComplete: eraNarratives.filter((n) => n.status === \"complete\").length,\n    eraNarrativesWithCoverImage: eraNarratives.filter((n) => n.coverImage?.status === \"complete\")\n      .length,\n  };\n\n  // =========================================================================\n  // Historian Notes\n  // =========================================================================\n\n  const byNoteType: Record<HistorianNoteType, number> = {\n    commentary: 0,\n    correction: 0,\n    tangent: 0,\n    skepticism: 0,\n    pedantic: 0,\n  };\n  for (const note of allHistorianNotes) {\n    if (byNoteType[note.type] !== undefined) {\n      byNoteType[note.type]++;\n    }\n  }\n\n  const historianNoteStats: HistorianNoteStats = {\n    total: allHistorianNotes.length,\n    byType: byNoteType,\n    onEntities: entityHistorianNotes.length,\n    onChronicles: chronicleHistorianNotes.length,\n  };\n\n  return {\n    totalWords,\n    totalChars,\n    estimatedPages: Math.ceil(totalWords / 250),\n    wordBreakdown,\n    charBreakdown,\n    images: imageStats,\n    completeness,\n    historianNotes: historianNoteStats,\n    calculatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "entities", "type": "PersistedEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "images", "type": "ImageMetadataRecord[]", "optional": false}, {"name": "staticPages", "type": "StaticPage[]", "optional": false}, {"name": "eraNarratives", "type": "EraNarrativeRecord[]", "optional": false}], "returnType": "PrePrintStats"}, {"id": "apps/illuminator/webui/src/workers/tasks/index.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/index.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts", "sourceCode": "export function getCallConfig(config: WorkerConfig, callType: LLMCallType): ResolvedLLMCallConfig {\n  return config.llmCallSettings[callType];\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx", "sourceCode": "export default function EntryPointStep({ entities, relationships, events }: Readonly<EntryPointStepProps>) {\n  const {\n    state,\n    eras,\n    selectEntryPoint,\n    clearEntryPoint,\n    setIncludeErasInNeighborhood,\n    simulationRunId,\n  } = useWizard();\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [sortBy, setSortBy] = useState<SortOption>(\"story-score\");\n  const [hoveredEntityId, setHoveredEntityId] = useState<string | null>(null);\n  const [onlyUnused, setOnlyUnused] = useState(false);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage stats when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageStats(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n        if (isActive) setUsageStats(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Compute story potentials for all entities\n  const entityPotentials = useMemo(() => {\n    return computeAllStoryPotentials(entities, relationships, events);\n  }, [entities, relationships, events]);\n\n  const usageCounts = useMemo(() => {\n    const counts = new Map<string, number>();\n    for (const [id, stats] of usageStats) {\n      counts.set(id, stats.usageCount);\n    }\n    return counts;\n  }, [usageStats]);\n\n  const usageMetrics = useMemo(() => {\n    if (entityPotentials.size === 0) return new Map<string, UsageMetrics>();\n\n    const entityIds = Array.from(entityPotentials.keys());\n    const adjacency = new Map<string, Set<string>>();\n    for (const id of entityIds) adjacency.set(id, new Set());\n\n    for (const rel of relationships) {\n      if (!adjacency.has(rel.src) || !adjacency.has(rel.dst)) continue;\n      adjacency.get(rel.src).add(rel.dst);\n      adjacency.get(rel.dst).add(rel.src);\n    }\n\n    const visitStamp = new Map<string, number>();\n    let stamp = 1;\n    const result = new Map<string, UsageMetrics>();\n\n    for (const id of entityIds) {\n      const usageCount = usageCounts.get(id) ?? 0;\n      const entity = entityPotentials.get(id);\n      const rawProminence = entity ? Number(entity.prominence) : 0;\n      const prominence = Number.isFinite(rawProminence) ? Math.max(0, rawProminence) : 0;\n\n      const firstHop = adjacency.get(id) || new Set<string>();\n      stamp += 1;\n      visitStamp.set(id, stamp);\n\n      let hop1Total = 0;\n      let hop1Unused = 0;\n      for (const neighbor of firstHop) {\n        if (visitStamp.get(neighbor) === stamp) continue;\n        visitStamp.set(neighbor, stamp);\n        hop1Total += 1;\n        if ((usageCounts.get(neighbor) ?? 0) === 0) hop1Unused += 1;\n      }\n\n      let hop2Total = 0;\n      let hop2Unused = 0;\n      for (const neighbor of firstHop) {\n        const neighborHops = adjacency.get(neighbor);\n        if (!neighborHops) continue;\n\n        for (const secondHop of neighborHops) {\n          if (visitStamp.get(secondHop) === stamp) continue;\n          visitStamp.set(secondHop, stamp);\n          hop2Total += 1;\n          if ((usageCounts.get(secondHop) ?? 0) === 0) hop2Unused += 1;\n        }\n      }\n\n      result.set(id, {\n        usageCount,\n        unusedSelf: usageCount === 0,\n        hop1Unused,\n        hop1Total,\n        hop2Unused,\n        hop2Total,\n        underusedScore: prominence / (usageCount + 1),\n        prominence,\n      });\n    }\n\n    return result;\n  }, [entityPotentials, relationships, usageCounts]);\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    return getUniqueKinds(entities);\n  }, [entities]);\n\n  // Era lookups: id -> color and id -> name\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  const eraNameMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const era of eras) {\n      map.set(era.id, era.name);\n    }\n    return map;\n  }, [eras]);\n\n  // Filter and sort entities\n  const filteredEntities = useMemo(() => {\n    let result = [...entityPotentials.values()];\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      result = result.filter((e) => selectedKinds.has(e.kind));\n    }\n\n    // Apply unused filter (requires usage stats)\n    if (onlyUnused && !usageLoading) {\n      result = result.filter((e) => (usageMetrics.get(e.id)?.usageCount ?? 0) === 0);\n    }\n\n    // Sort\n    result.sort((a, b) => {\n      switch (sortBy) {\n        case \"name\":\n          return a.name.localeCompare(b.name);\n        case \"connections\":\n          return b.connectionCount - a.connectionCount;\n        case \"underused\": {\n          const aScore = usageMetrics.get(a.id)?.underusedScore ?? 0;\n          const bScore = usageMetrics.get(b.id)?.underusedScore ?? 0;\n          if (bScore !== aScore) return bScore - aScore;\n          return b.potential.overallScore - a.potential.overallScore;\n        }\n        case \"story-score\":\n        default:\n          return b.potential.overallScore - a.potential.overallScore;\n      }\n    });\n\n    return result;\n  }, [entityPotentials, selectedKinds, sortBy, onlyUnused, usageLoading, usageMetrics]);\n\n  // Get entity for detail panel (hover takes priority over selection)\n  const detailEntity = useMemo(() => {\n    const id = hoveredEntityId || state.entryPointId;\n    if (!id) return null;\n    return entityPotentials.get(id) || null;\n  }, [hoveredEntityId, state.entryPointId, entityPotentials]);\n\n  // Get connections for constellation\n  const detailConnections = useMemo(() => {\n    if (!detailEntity) return [];\n    return getConnectedEntities(detailEntity.id, entities, relationships);\n  }, [detailEntity, entities, relationships]);\n  const detailUsage = useMemo(() => {\n    if (!detailEntity) return null;\n    return usageMetrics.get(detailEntity.id) || null;\n  }, [detailEntity, usageMetrics]);\n\n  const handleSelect = (entity: EntityWithPotential) => {\n    // Click again to deselect\n    if (state.entryPointId === entity.id) {\n      clearEntryPoint();\n      return;\n    }\n    // Convert back to EntityContext for the wizard\n    const { potential, connectionCount, eventCount, connectedKinds, eraIds, ...baseEntity } =\n      entity;\n    selectEntryPoint(baseEntity as EntityContext, entities, relationships, events);\n  };\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"eps-header\">\n        <h4 className=\"eps-title\">Select Entry Point</h4>\n        <p className=\"eps-subtitle\">\n          Choose the central entity for your chronicle. Higher story scores indicate richer\n          narrative potential.\n        </p>\n      </div>\n\n      {/* Two column layout - fixed height to prevent jumping */}\n      <div className=\"eps-layout\">\n        {/* Left: Entity list */}\n        <div className=\"eps-left\">\n          {/* Filter chips */}\n          <div className=\"eps-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n\n          {/* Sort control and options */}\n          <div className=\"eps-sort-row\">\n            <select\n              value={sortBy}\n              onChange={(e) => setSortBy(e.target.value as SortOption)}\n              className=\"illuminator-select eps-sort-select\"\n            >\n              <option value=\"story-score\">Sort by Story Score</option>\n              <option value=\"connections\">Sort by Connections</option>\n              <option value=\"underused\">Sort by Underused Score</option>\n              <option value=\"name\">Sort by Name</option>\n            </select>\n            <label className=\"eps-checkbox-label eps-checkbox-label-muted\">\n              <input\n                type=\"checkbox\"\n                checked={state.includeErasInNeighborhood}\n                onChange={(e) => setIncludeErasInNeighborhood(e.target.checked)}\n                className=\"eps-checkbox\"\n              />\n              Include eras in neighborhood\n            </label>\n            <label\n              className=\"eps-checkbox-label\"\n              style={{\n                '--eps-label-color': usageLoading ? \"var(--text-muted)\" : \"var(--text-secondary)\",\n                '--eps-label-cursor': usageLoading ? \"not-allowed\" : \"pointer\",\n              } as React.CSSProperties}\n            >\n              <input\n                type=\"checkbox\"\n                checked={onlyUnused}\n                onChange={(e) => setOnlyUnused(e.target.checked)}\n                className=\"eps-checkbox\"\n                disabled={usageLoading}\n              />\n              Only unused\n            </label>\n          </div>\n\n          {/* Entity list - fills remaining height */}\n          <div className=\"eps-entity-list\">\n            {filteredEntities.length === 0 ? (\n              <div className=\"eps-empty-list\">\n                No entities match the selected filters.\n              </div>\n            ) : (\n              filteredEntities.map((entity) => {\n                const isSelected = state.entryPointId === entity.id;\n                const isHovered = hoveredEntityId === entity.id;\n                const usage = usageMetrics.get(entity.id);\n\n                return (\n                  <div\n                    key={entity.id}\n                    onClick={() => handleSelect(entity)}\n                    onMouseEnter={() => setHoveredEntityId(entity.id)}\n                    onMouseLeave={() => setHoveredEntityId(null)}\n                    className={`eps-entity-row ${isSelected ? \"eps-entity-row-selected\" : \"\"} ${isHovered && !isSelected ? \"eps-entity-row-hovered\" : \"\"}`}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n// ... (truncated)", "parameters": [{"name": "{ entities, relationships, events }", "type": "Readonly<EntryPointStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx", "sourceCode": "export default function EventResolutionStep() {\n  const {\n    state,\n    toggleEvent,\n    toggleRelationship,\n    selectAllEvents,\n    deselectAllEvents,\n    selectAllRelationships,\n    deselectAllRelationships,\n    computeEventMetricsForSelection,\n    temporalContext,\n    detectedFocalEra,\n    eras,\n    setFocalEraOverride,\n    autoFillEvents,\n  } = useWizard();\n\n  const [, setEventMetrics] = useState<Map<string, EventSelectionMetrics>>(new Map());\n  const [brushSelection, setBrushSelection] = useState<[number, number] | null>(null);\n  const [minEventSignificance, setMinEventSignificance] = useState<number>(0);\n\n  // Recompute event metrics when the computation function changes\n  useEffect(() => {\n    const metrics = computeEventMetricsForSelection();\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync derived metrics cache to updated computation source\n    setEventMetrics(metrics);\n  }, [computeEventMetricsForSelection]);\n\n  // Get relevant relationships (between assigned entities + lens)\n  const lensEntityIds = useMemo(() => (state.lens ? [state.lens.entityId] : []), [state.lens]);\n\n  const relevantRelationships = useMemo(() => {\n    return getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensEntityIds\n    );\n  }, [state.roleAssignments, state.candidateRelationships, lensEntityIds]);\n\n  // Get ALL relevant events (involving assigned entities) - before filtering\n  const allRelevantEvents = useMemo(() => {\n    return getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Filter events by significance and exclude prominence-only events\n  const relevantEvents = useMemo(() => {\n    const entityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n    return filterChronicleEvents(allRelevantEvents, entityIds, {\n      minSignificance: minEventSignificance,\n      excludeProminenceOnly: true,\n    });\n  }, [allRelevantEvents, state.roleAssignments, minEventSignificance]);\n\n  // Get era ranges directly from era definitions\n  const eraRanges = useMemo(() => {\n    return getEraRanges(eras);\n  }, [eras]);\n\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  const timelineEvents = useMemo(() => {\n    return prepareTimelineEvents(\n      relevantEvents,\n      state.entryPointId,\n      assignedEntityIds,\n      state.selectedEventIds\n    );\n  }, [relevantEvents, state.entryPointId, assignedEntityIds, state.selectedEventIds]);\n\n  const intensityCurve = useMemo(() => {\n    return computeIntensityCurve(relevantEvents);\n  }, [relevantEvents]);\n\n  // Get timeline extent directly from era definitions\n  const timelineExtent = useMemo(() => {\n    return getTimelineExtent(eras);\n  }, [eras]);\n\n  // Build entity map for cast marker lookup\n  const entityMap = useMemo(() => {\n    const map = new Map<string, EntityContext>();\n    for (const entity of state.candidates) {\n      map.set(entity.id, entity);\n    }\n    return map;\n  }, [state.candidates]);\n\n  // Compute cast markers from role assignments, entry point, and lens\n  const castMarkers = useMemo(() => {\n    return prepareCastMarkers(state.roleAssignments, entityMap, state.entryPoint, state.lens);\n  }, [state.roleAssignments, entityMap, state.entryPoint, state.lens]);\n\n  // Collapse bidirectional relationships for display\n  const collapsedRelationships = useMemo(\n    () => collapseBidirectionalRelationships(relevantRelationships),\n    [relevantRelationships]\n  );\n\n  // Get all relationship IDs (flattened from collapsed)\n  const relevantRelationshipIds = useMemo(\n    () => collapsedRelationships.flatMap((cr) => cr.relationshipIds),\n    [collapsedRelationships]\n  );\n\n  const relevantEventIds = useMemo(() => relevantEvents.map((e) => e.id), [relevantEvents]);\n\n  // Count how many selected events are visible (pass the current filter)\n  const visibleSelectedCount = useMemo(() => {\n    const relevantIdSet = new Set(relevantEventIds);\n    return Array.from(state.selectedEventIds).filter((id) => relevantIdSet.has(id)).length;\n  }, [relevantEventIds, state.selectedEventIds]);\n\n  // Auto-select all on first mount if accepting defaults\n  useEffect(() => {\n    if (\n      state.acceptDefaults &&\n      state.selectedRelationshipIds.size === 0 &&\n      state.selectedEventIds.size === 0\n    ) {\n      selectAllRelationships(relevantRelationshipIds);\n      selectAllEvents(relevantEventIds);\n    }\n  }, [\n    state.acceptDefaults,\n    state.selectedRelationshipIds.size,\n    state.selectedEventIds.size,\n    selectAllRelationships,\n    selectAllEvents,\n    relevantRelationshipIds,\n    relevantEventIds,\n  ]);\n\n  // Handle brush selection change - select events in range\n  const handleBrushChange = useCallback(\n    (range: [number, number] | null) => {\n      setBrushSelection(range);\n      if (range) {\n        const eventsInRange = getEventsInRange(timelineEvents, range[0], range[1]);\n        const idsInRange = eventsInRange.map((e) => e.id);\n        // Select only events in range, deselect others\n        const newSelectedIds = new Set(idsInRange);\n        // Update selection\n        for (const id of relevantEventIds) {\n          const inNew = newSelectedIds.has(id);\n          const inCurrent = state.selectedEventIds.has(id);\n          if (inNew !== inCurrent) {\n            toggleEvent(id);\n          }\n        }\n      }\n    },\n    [timelineEvents, relevantEventIds, state.selectedEventIds, toggleEvent]\n  );\n\n  // Effective focal era\n  const effectiveFocalEraId = state.focalEraOverride || detectedFocalEra?.id || null;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ers-header\">\n        <div className=\"ers-header-row\">\n          <div>\n            <h4 className=\"ers-title\">Compose Narrative Arc</h4>\n            <p className=\"ers-subtitle\">\n              Select events from the timeline to build your narrative. Use the brush to select time\n              ranges.\n            </p>\n          </div>\n          <button\n            onClick={() => autoFillEvents(true)}\n            className=\"illuminator-btn ers-btn-sm\"\n          >\n            Auto-fill Events\n          </button>\n        </div>\n\n        {/* Filters */}\n        <div className=\"ers-filters\">\n          {/* Row 1: Focal Era selector */}\n          {temporalContext && (\n            <div className=\"ers-filter-row\">\n              <span className=\"ers-filter-label\">Focal Era:</span>\n              <select\n                value={state.focalEraOverride || temporalContext.focalEra.id}\n                onChange={(e) => {\n                  const selectedId = e.target.value;\n                  if (detectedFocalEra && selectedId === detectedFocalEra.id) {\n                    setFocalEraOverride(null);\n                  } else {\n                    setFocalEraOverride(selectedId);\n                  }\n                }}\n                className=\"illuminator-select ers-filter-select\"\n              >\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name}\n                    {detectedFocalEra?.id === era.id ? \" (detected)\" : \"\"}\n                  </option>\n                ))}\n              </select>\n              {state.focalEraOverride && (\n                <button\n                  onClick={() => setFocalEraOverride(null)}\n                  className=\"illuminator-btn ers-reset-btn\"\n                >\n                  Reset\n                </button>\n              )}\n            </div>\n          )}\n\n          {/* Row 2: Min Significance selector */}\n          <div className=\"ers-filter-row\">\n            <span className=\"ers-filter-label\">Min Significance:</span>\n            <select\n              value={minEventSignificance}\n              onChange={(e) => setMinEventSignificance(parseFloat(e.target.value))}\n              className=\"illuminator-select ers-filter-select\"\n            >\n              <option value={0}>All (&gt;0%)</option>\n              <option value={0.25}>Low (&gt;25%)</option>\n              <option value={0.5}>Medium (&gt;50%)</option>\n              <option value={0.75}>High (&gt;75%)</option>\n            </select>\n            <span className=\"ers-filter-count\">\n              {relevantEvents.length} events match filter\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Timeline Visualization */}\n      <div className=\"ers-timeline-section\">\n        {/* Intensity Sparkline */}\n        <IntensitySparkline\n          points={intensityCurve}\n          width={700}\n          height={40}\n          extent={timelineExtent}\n          selectedRange={brushSelection}\n        />\n\n        {/* Narrative Timeline with Era Lanes - compact overview */}\n        <div className=\"ers-timeline-gap\">\n          <NarrativeTimeline\n            events={timelineEvents}\n            eraRanges={eraRanges}\n            width={700}\n            height={castMarkers.length > 0 ? 148 : 120}\n            onToggleEvent={toggleEvent}\n            focalEraId={effectiveFocalEraId}\n            extent={timelineExtent}\n            castMarkers={castMarkers}\n          />\n        </div>\n\n        {/* Timeline Brush */}\n        <div className=\"ers-timeline-gap\">\n          <TimelineBrush\n            width={700}\n            height={36}\n            extent={timelineExtent}\n            selection={brushSelection}\n            onSelectionChange={handleBrushChange}\n          />\n        </div>\n\n        {/* Quick actions */}\n        <div className=\"ers-quick-actions\">\n          <button\n            onClick={() => selectAllEvents(relevantEventIds)}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Select All Events\n          </button>\n          <button\n            onClick={() => {\n              deselectAllEvents();\n              setBrushSelection(null);\n            }}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Clear Selection\n          </button>\n          <span\n            className=\"ers-selection-count\"\n            style={{\n              '--ers-count-color': state.selectedEventIds.size > MAX_CHRONICLE_EVENTS\n                ? \"var(--error)\"\n                : \"var(--text-muted)\",\n            } as React.CSSProperties}\n          >\n            {visibleSelectedCount} of {relevantEvents.length} visible selected\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx", "sourceCode": "export default function GenerateStep({ onGenerate: _onGenerate }: Readonly<GenerateStepProps>) {\n  const { state, setNarrativeDirection } = useWizard();\n\n  // Count primary vs supporting roles\n  const primaryCount = state.roleAssignments.filter((a) => a.isPrimary).length;\n  const supportingCount = state.roleAssignments.length - primaryCount;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"gs-header\">\n        <h4 className=\"gs-title\">Generate Chronicle</h4>\n        <p className=\"gs-subtitle\">\n          Review your selections and generate the chronicle.\n        </p>\n      </div>\n\n      {/* Summary */}\n      <div className=\"gs-summary\">\n        <div className=\"gs-summary-grid\">\n          {/* Style */}\n          <div>\n            <div className=\"gs-section-label\">\n              Narrative Style\n            </div>\n            <div className=\"gs-section-value\">\n              {state.narrativeStyle?.name}\n              <span\n                className={`gs-format-badge ${state.narrativeStyle?.format === \"story\" ? \"gs-format-badge-story\" : \"gs-format-badge-document\"}`}\n              >\n                {state.narrativeStyle?.format}\n              </span>\n            </div>\n          </div>\n\n          {/* Entry Point */}\n          <div>\n            <div className=\"gs-section-label\">\n              Entry Point\n            </div>\n            <div className=\"gs-section-value\">\n              {state.entryPoint?.name}\n              <span className=\"gs-section-meta\">\n                ({state.entryPoint?.kind})\n              </span>\n            </div>\n          </div>\n\n          {/* Ensemble */}\n          <div>\n            <div className=\"gs-section-label\">\n              Ensemble\n            </div>\n            <div className=\"gs-section-value\">\n              {state.roleAssignments.length} entities\n              <span className=\"gs-section-meta\">\n                ({primaryCount} primary, {supportingCount} supporting)\n              </span>\n            </div>\n          </div>\n\n          {/* Events & Relationships */}\n          <div>\n            <div className=\"gs-section-label\">\n              Context\n            </div>\n            <div className=\"gs-section-value\">\n              {state.selectedEventIds.size} events, {state.selectedRelationshipIds.size}{\" \"}\n              relationships\n            </div>\n          </div>\n        </div>\n\n        {/* Narrative Lens */}\n        {state.lens && (\n          <div className=\"gs-lens-section\">\n            <div className=\"gs-section-label\">\n              Narrative Lens\n            </div>\n            <div className=\"gs-lens-chip\">\n              <span className=\"gs-lens-icon\">&#x25C8;</span>\n              <span className=\"gs-lens-name\">{state.lens.entityName}</span>\n              <span className=\"gs-lens-kind\">\n                ({state.lens.entityKind})\n              </span>\n            </div>\n          </div>\n        )}\n\n        {/* Role Breakdown */}\n        <div className=\"gs-roles-section\">\n          <div className=\"gs-roles-label\">\n            Role Assignments\n          </div>\n          <div className=\"gs-roles-list\">\n            {state.roleAssignments.map((assignment) => (\n              <span\n                key={`${assignment.role}-${assignment.entityId}`}\n                className={`gs-role-chip ${assignment.isPrimary ? \"gs-role-chip-primary\" : \"gs-role-chip-support\"}`}\n                style={{\n                  '--gs-role-opacity': assignment.isPrimary ? 0.9 : 0.7,\n                } as React.CSSProperties}\n              >\n                <span className=\"gs-role-name\">{assignment.role}</span>\n                <span className=\"gs-role-entity\">\n                  {assignment.entityName}\n                </span>\n              </span>\n            ))}\n          </div>\n        </div>\n      </div>\n\n      {/* Narrative Direction */}\n      <div className=\"gs-direction-section\">\n        <div className=\"gs-section-label\">\n          Narrative Direction\n          <span className=\"gs-direction-optional\">\n            optional\n          </span>\n        </div>\n        <p className=\"gs-direction-desc\">\n          Concrete story purpose that shapes perspective and generation. Leave empty for open-ended\n          chronicles.\n        </p>\n        <textarea\n          value={state.narrativeDirection}\n          onChange={(e) => setNarrativeDirection(e.target.value)}\n          placeholder='e.g. \"This is the treaty document that ended the Faction Wars\" or \"An eyewitness account of the apocalyptic magic that ended the Orca Invasion\"'\n          className=\"gs-direction-textarea\"\n        />\n      </div>\n\n      {/* Info Box */}\n      <div className=\"gs-info-box\">\n        <span className=\"gs-info-icon\">\ud83d\udca1</span>\n        <span>\n          Click &quot;Generate Chronicle&quot; to start generation. The complete chronicle will be ready in\n          about 30-60 seconds.\n        </span>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onGenerate: _onGenerate }", "type": "Readonly<GenerateStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx", "sourceCode": "export default function RoleAssignmentStep() {\n  const {\n    state,\n    eras,\n    autoFillRoles,\n    addRoleAssignment,\n    removeRoleAssignment,\n    togglePrimary,\n    setLens,\n    clearLens,\n    computeMetrics,\n    simulationRunId,\n  } = useWizard();\n\n  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [metricsMap, setMetricsMap] = useState<Map<string, EntitySelectionMetrics>>(new Map());\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [selectedEras, setSelectedEras] = useState<Set<string>>(new Set());\n  const [connectionFilter, setConnectionFilter] = useState<string | null>(null);\n\n  const style = state.narrativeStyle;\n  const roles = getRoles(style);\n  const maxCastSize = 10;\n\n  // Load usage stats on mount\n  useEffect(() => {\n    if (!simulationRunId) {\n      throw new Error(\"[Chronicle Wizard] simulationRunId is required to load entity usage stats.\");\n    }\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n      });\n  }, [simulationRunId]);\n\n  const metricsKey = `${state.candidates.length}|${state.entryPointId}|${usageStats.size}|${state.roleAssignments.length}`;\n  useEffect(() => {\n    if (state.candidates.length === 0 || !state.entryPointId) return;\n    const metrics = computeMetrics(usageStats);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- recompute local metrics cache when candidate inputs change\n    setMetricsMap(metrics);\n  }, [metricsKey, state.candidates.length, state.entryPointId, usageStats]);\n\n  // Get assigned entity IDs\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  // Validation\n  const validation = useMemo(() => {\n    if (!roles.length) return { valid: true, errors: [], warnings: [] };\n    return validateRoleAssignments(state.roleAssignments, roles, maxCastSize);\n  }, [state.roleAssignments, roles, maxCastSize]);\n\n  // Get selected entity details\n  const selectedEntity = useMemo(() => {\n    if (!selectedEntityId) return null;\n    return state.candidates.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, state.candidates]);\n\n  const selectedMetrics = useMemo(() => {\n    if (!selectedEntityId) return undefined;\n    return metricsMap.get(selectedEntityId);\n  }, [selectedEntityId, metricsMap]);\n\n  // Era color map: eraId -> hex color (same palette as timeline)\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  // Get era name and color for selected entity\n  const selectedEntityEra = useMemo(() => {\n    if (!selectedEntity || eras.length === 0) return undefined;\n    const entityEraId = resolveEntityEraId(selectedEntity);\n    const era = entityEraId ? eras.find((e) => e.id === entityEraId) : undefined;\n    if (!era) return undefined;\n    return { name: era.name, color: eraColorMap.get(era.id) };\n  }, [selectedEntity, eras, eraColorMap]);\n\n  // Handle role assignment\n  const handleAssignToRole = useCallback(\n    (roleId: string) => {\n      if (!selectedEntityId) return;\n\n      const entity = state.candidates.find((e) => e.id === selectedEntityId);\n      if (!entity) return;\n\n      addRoleAssignment({\n        role: roleId,\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n        isPrimary: false,\n      });\n\n      setSelectedEntityId(null);\n    },\n    [selectedEntityId, state.candidates, addRoleAssignment]\n  );\n\n  // Handle remove from role\n  const handleRemoveFromRole = useCallback(\n    (entityId: string, roleId: string) => {\n      removeRoleAssignment(entityId, roleId);\n    },\n    [removeRoleAssignment]\n  );\n\n  // Build kind-to-category map\n  const kindToCategory = useMemo(() => {\n    const map = new Map<string, string>();\n    // Simple mapping - could be domain-specific\n    for (const candidate of state.candidates) {\n      map.set(candidate.kind, candidate.kind);\n    }\n    return map;\n  }, [state.candidates]);\n\n  const handleSetLens = useCallback(\n    (entity: { id: string; name: string; kind: string }) => {\n      const lens: NarrativeLens = {\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n      };\n      setLens(lens);\n    },\n    [setLens]\n  );\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const candidate of state.candidates) {\n      kinds.add(candidate.kind);\n    }\n    return Array.from(kinds).sort((a, b) => a.localeCompare(b));\n  }, [state.candidates]);\n\n  // Available eras from candidates (in era order, only eras with entities)\n  const availableEras = useMemo(() => {\n    const eraIds = new Set<string>();\n    for (const c of state.candidates) {\n      const eraId = resolveEntityEraId(c);\n      if (eraId) eraIds.add(eraId);\n    }\n    return eras.filter((e) => eraIds.has(e.id)).map((e) => e.id);\n  }, [state.candidates, eras]);\n\n  // Build connection maps for filtering\n  const connectionMaps = useMemo(() => {\n    // Map entity ID -> set of assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of state.candidateRelationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    return { connectedToAssigned };\n  }, [state.candidateRelationships, assignedEntityIds]);\n\n  // Filter candidates by selected kinds and connection filter (always include assigned entities)\n  const filteredCandidates = useMemo(() => {\n    let candidates = state.candidates;\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      candidates = candidates.filter(\n        (c) => selectedKinds.has(c.kind) || assignedEntityIds.has(c.id)\n      );\n    }\n\n    // Apply era filter\n    if (selectedEras.size > 0) {\n      candidates = candidates.filter((c) => {\n        const eraId = resolveEntityEraId(c);\n        return (eraId !== undefined && selectedEras.has(eraId)) || assignedEntityIds.has(c.id);\n      });\n    }\n\n    // Apply connection filter\n    if (connectionFilter && assignedEntityIds.size > 0) {\n      candidates = candidates.filter((c) => {\n        // Always include assigned entities\n        if (assignedEntityIds.has(c.id)) return true;\n\n        const connectedTo = connectionMaps.connectedToAssigned.get(c.id);\n        const connectionCount = connectedTo?.size ?? 0;\n\n        switch (connectionFilter) {\n          case \"linked\":\n            // Connected to at least one assigned entity\n            return connectionCount > 0;\n          case \"bridges\":\n            // Connected to 2+ assigned entities (bridges/connectors)\n            return connectionCount >= 2;\n          default:\n            return true;\n        }\n      });\n    }\n\n    return candidates;\n  }, [\n    state.candidates,\n    selectedKinds,\n    selectedEras,\n    assignedEntityIds,\n    connectionFilter,\n    connectionMaps,\n  ]);\n\n  // Filter relationships to only include those between filtered candidates\n  const filteredRelationships = useMemo(() => {\n    const filteredIds = new Set(filteredCandidates.map((c) => c.id));\n    return state.candidateRelationships.filter(\n      (r) => filteredIds.has(r.src) && filteredIds.has(r.dst)\n    );\n  }, [state.candidateRelationships, filteredCandidates]);\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ras-header\">\n        <div>\n          <h4 className=\"ras-title\">Build Your Ensemble</h4>\n          <p className=\"ras-subtitle\">\n            Click entities in the constellation to select, then click a role to assign.\n          </p>\n        </div>\n        <button\n          onClick={() => autoFillRoles(metricsMap)}\n          className=\"illuminator-btn ras-autofill-btn\"\n        >\n          Auto-fill Roles\n        </button>\n      </div>\n\n      {/* Validation Messages */}\n      {validation.errors.length > 0 && (\n        <div className=\"ras-errors\">\n          {validation.errors.map((error, i) => (\n            <div key={i} className=\"ras-error\">\n              {error}\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Main layout: Left (constellation + health) | Right (roles + detail) */}\n      <div className=\"ras-layout\">\n        {/* Left: Constellation + Ensemble Health */}\n        <div className=\"ras-left\">\n          {/* Kind filter chips */}\n          <div className=\"ras-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n          {/* Era filter chips */}\n          {availableEras.length > 1 && (\n            <div className=\"ras-filter-gap\">\n              <FilterChips\n                options={availableEras}\n                selected={selectedEras}\n                onSelectionChange={setSelectedEras}\n                label=\"Filter by Era\"\n                formatLabel={(eraId) => eras.find((e) => e.id === eraId)?.name ?? eraId}\n                getColor={(eraId) => eraColorMap.get(eraId) ?? \"var(--text-muted)\"}\n              />\n            </div>\n          )}\n          {/* Connection filter */}\n          <div className=\"ras-conn-filter\">\n            <span className=\"ras-conn-label\">Show:</span>\n            {[\n              { id: null, label: \"All\" },\n              { id: \"linked\", label: \"Linked to ensemble\" },\n              { id: \"bridges\", label: \"Bridges (2+ links)\" },\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx", "sourceCode": "export default function StyleStep({ styles }: Readonly<StyleStepProps>) {\n  const { state, selectStyle, setAcceptDefaults, simulationRunId } = useWizard();\n  const [searchText, setSearchText] = useState(\"\");\n  const [formatFilter, setFormatFilter] = useState<\"all\" | \"story\" | \"document\">(\"all\");\n  const [styleUsage, setStyleUsage] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setStyleUsage(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getNarrativeStyleUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setStyleUsage(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load narrative style usage stats:\", err);\n        if (isActive) setStyleUsage(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Filter styles\n  const filteredStyles = useMemo(() => {\n    return styles.filter((style) => {\n      // Format filter\n      if (formatFilter !== \"all\" && style.format !== formatFilter) {\n        return false;\n      }\n      // Search filter\n      if (searchText.trim()) {\n        const search = searchText.toLowerCase();\n        return (\n          style.name.toLowerCase().includes(search) ||\n          style.description.toLowerCase().includes(search) ||\n          style.tags?.some((tag) => tag.toLowerCase().includes(search))\n        );\n      }\n      return true;\n    });\n  }, [styles, formatFilter, searchText]);\n\n  // Group by format\n  const storyStyles = filteredStyles.filter((s) => s.format === \"story\");\n  const documentStyles = filteredStyles.filter((s) => s.format === \"document\");\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"sstep-header\">\n        <h4 className=\"sstep-title\">Select Narrative Style</h4>\n        <p className=\"sstep-subtitle\">\n          Choose a style that defines the structure and roles for your chronicle.\n        </p>\n      </div>\n\n      {/* Filters */}\n      <div className=\"sstep-filters\">\n        <input\n          type=\"text\"\n          value={searchText}\n          onChange={(e) => setSearchText(e.target.value)}\n          placeholder=\"Search styles...\"\n          className=\"illuminator-input sstep-search\"\n        />\n        <select\n          value={formatFilter}\n          onChange={(e) => setFormatFilter(e.target.value as \"all\" | \"story\" | \"document\")}\n          className=\"illuminator-select\"\n        >\n          <option value=\"all\">All Formats</option>\n          <option value=\"story\">Stories</option>\n          <option value=\"document\">Documents</option>\n        </select>\n\n        {/* Accept Defaults Checkbox */}\n        <label className=\"sstep-defaults-label\">\n          <input\n            type=\"checkbox\"\n            checked={state.acceptDefaults}\n            onChange={(e) => setAcceptDefaults(e.target.checked)}\n          />\n          Accept defaults for quick generation\n        </label>\n      </div>\n\n      {/* Styles Grid */}\n      <div className=\"sstep-scroll\">\n        {formatFilter === \"all\" || formatFilter === \"story\" ? (\n          <>\n            {storyStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Story Styles ({storyStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid sstep-grid-mb\">\n              {storyStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {formatFilter === \"all\" || formatFilter === \"document\" ? (\n          <>\n            {documentStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Document Styles ({documentStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid\">\n              {documentStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {filteredStyles.length === 0 && (\n          <div className=\"sstep-empty\">\n            No styles match your search.\n          </div>\n        )}\n      </div>\n\n      {/* Selected Style Details */}\n      {state.narrativeStyle && (\n        <div className=\"sstep-selected-detail\">\n          <h5 className=\"sstep-selected-name\">\n            {state.narrativeStyle.name}\n            <span\n              className={`sstep-format-badge ${state.narrativeStyle.format === \"story\" ? \"sstep-format-badge-story\" : \"sstep-format-badge-document\"}`}\n            >\n              {state.narrativeStyle.format}\n            </span>\n          </h5>\n          <p className=\"sstep-selected-desc\">\n            {state.narrativeStyle.description}\n          </p>\n          <div className=\"sstep-usage-info\">\n            {usageLoading\n              ? \"Usage in this run: \u2026\"\n              : `Usage in this run: ${styleUsage.get(state.narrativeStyle.id)?.usageCount ?? 0}x`}\n          </div>\n\n          {/* Role Requirements */}\n          <div>\n            <span className=\"sstep-roles-label\">\n              Required Roles:\n            </span>\n            <div className=\"sstep-roles-list\">\n              {getRoles(state.narrativeStyle).map((role) => (\n                <span\n                  key={role.role}\n                  className=\"sstep-role-chip\"\n                  title={role.description}\n                >\n                  {role.role}\n                  <span className=\"sstep-role-count\">\n                    ({role.count.min}-{role.count.max})\n                  </span>\n                </span>\n              ))}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ styles }", "type": "Readonly<StyleStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx", "sourceCode": "export default function EnsembleConstellation({\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}: Readonly<EnsembleConstellationProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);\n\n  // Compute layout\n  const nodes = useMemo(() => {\n    const layout = computeLayout(entryPointId, candidates, metricsMap, width, height);\n    const candidateMap = new Map(candidates.map((c) => [c.id, c]));\n    return layout.map((node) => {\n      const candidate = candidateMap.get(node.id);\n      const eraId = candidate?.eraId && candidate.eraId.length > 0 ? candidate.eraId : undefined;\n      return {\n        ...node,\n        isAssigned: assignedEntityIds.has(node.id),\n        eraColor: eraId ? (eraColorMap?.get(eraId) ?? \"#6b7280\") : \"#6b7280\",\n      };\n    });\n  }, [entryPointId, candidates, metricsMap, width, height, assignedEntityIds, eraColorMap]);\n\n  const nodeMap = useMemo(() => {\n    return new Map(nodes.map((n) => [n.id, n]));\n  }, [nodes]);\n\n  // Compute edges\n  const edges = useMemo(() => {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n    return computeEdges(relationships, nodeIds);\n  }, [relationships, nodes]);\n\n  // Compute bridge nodes (unassigned nodes connected to 2+ unique assigned entities)\n  const bridgeNodeIds = useMemo(() => {\n    // Map entity ID -> set of unique assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of relationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    const bridges = new Set<string>();\n    for (const [id, assignedConnections] of connectedToAssigned) {\n      if (assignedConnections.size >= 2) bridges.add(id);\n    }\n    return bridges;\n  }, [relationships, assignedEntityIds]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  const handleNodeClick = useCallback(\n    (nodeId: string) => {\n      if (selectedEntityId === nodeId) {\n        onSelectEntity(null);\n      } else {\n        onSelectEntity(nodeId);\n      }\n    },\n    [selectedEntityId, onSelectEntity]\n  );\n\n  // Determine node visual properties\n  const getNodeStyle = (node: ConstellationNode) => {\n    const isSelected = selectedEntityId === node.id;\n    const isHovered = hoveredNodeId === node.id;\n    const metrics = node.metrics;\n\n    // Base size\n    let radius = node.isEntryPoint ? 18 : 12;\n    if (isSelected || isHovered) radius += 2;\n\n    // Overused indicator\n    const isOverused = metrics && metrics.usageCount >= 5;\n\n    return { radius, isOverused, isSelected, isHovered };\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"ec-svg\"\n    >\n      {/* Orbit guides */}\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.25}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.5}\n      />\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.42}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.3}\n      />\n\n      {/* Edges */}\n      {edges.map((edge, i) => {\n        const source = nodeMap.get(edge.source);\n        const target = nodeMap.get(edge.target);\n        if (!source || !target) return null;\n\n        const sourceAssigned = assignedEntityIds.has(edge.source);\n        const targetAssigned = assignedEntityIds.has(edge.target);\n        const sourceSelected = selectedEntityId === edge.source || hoveredNodeId === edge.source;\n        const targetSelected = selectedEntityId === edge.target || hoveredNodeId === edge.target;\n\n        // Determine edge color and style based on node states\n        let strokeColor = \"var(--border-color)\";\n        let strokeOpacity = 0.2;\n        let strokeWidth = 1 + edge.strength * 1.5;\n\n        if (sourceAssigned && targetAssigned) {\n          // Both assigned - green, prominent\n          strokeColor = \"var(--success)\";\n          strokeOpacity = 0.7;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if ((sourceAssigned && targetSelected) || (targetAssigned && sourceSelected)) {\n          // One assigned, one selected - orange/gold\n          strokeColor = \"var(--warning)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceSelected || targetSelected) {\n          // One selected, neither assigned - purple\n          strokeColor = \"var(--accent-color)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceAssigned || targetAssigned) {\n          // One assigned, not selected - cyan to show potential ensemble connections\n          strokeColor = \"#06b6d4\"; // cyan\n          strokeOpacity = 0.5;\n          strokeWidth = 1.5 + edge.strength * 1.5;\n        }\n\n        return (\n          <line\n            key={i}\n            x1={source.x}\n            y1={source.y}\n            x2={target.x}\n            y2={target.y}\n            stroke={strokeColor}\n            strokeWidth={strokeWidth}\n            strokeOpacity={strokeOpacity}\n          />\n        );\n      })}\n\n      {/* Nodes */}\n      {nodes.map((node) => {\n        const style = getNodeStyle(node);\n        const color = getKindColor(node.kind);\n\n        return (\n          <g\n            key={node.id}\n            className=\"ec-cursor-pointer\"\n            onClick={() => handleNodeClick(node.id)}\n            onMouseEnter={() => setHoveredNodeId(node.id)}\n            onMouseLeave={() => setHoveredNodeId(null)}\n          >\n            {/* Overused glow */}\n            {style.isOverused && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 4}\n                fill=\"none\"\n                stroke=\"var(--error)\"\n                strokeWidth={2}\n                opacity={0.6}\n              />\n            )}\n\n            {/* Selection ring */}\n            {style.isSelected && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 3}\n                fill=\"none\"\n                stroke=\"var(--accent-color)\"\n                strokeWidth={2}\n              />\n            )}\n\n            {/* Bridge indicator (unassigned node connected to 2+ assigned) */}\n            {!node.isAssigned && !node.isEntryPoint && bridgeNodeIds.has(node.id) && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"#f59e0b\"\n                strokeWidth={2}\n                strokeDasharray=\"2,2\"\n              />\n            )}\n\n            {/* Assigned indicator */}\n            {node.isAssigned && !node.isEntryPoint && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"var(--success)\"\n                strokeWidth={2}\n                strokeDasharray=\"3,2\"\n              />\n            )}\n\n            {/* Node circle with era-colored ring */}\n            <circle\n              cx={node.x}\n              cy={node.y}\n              r={style.radius}\n              fill={node.isEntryPoint ? \"var(--accent-color)\" : color}\n              stroke={style.isHovered ? \"white\" : node.eraColor}\n              strokeWidth={2}\n            />\n\n            {/* Entry point star */}\n            {node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={5}\n                fontSize=\"14\"\n                fill=\"white\"\n                fontWeight=\"bold\"\n                className=\"ec-no-pointer\"\n              >\n                \u2605\n              </text>\n            )}\n\n            {/* Kind initial for non-entry-point nodes */}\n            {!node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={4}\n                fontSize=\"9\"\n                fill=\"white\"\n                fontWeight=\"500\"\n                className=\"ec-no-pointer\"\n              >\n                {node.kind.charAt(0).toUpperCase()}\n              </text>\n            )}\n          </g>\n        );\n      })}\n\n      {/* Tooltip layer - rendered on top of all nodes */}\n      {(() => {\n        const tooltipNodeId = hoveredNodeId || selectedEntityId;\n        const tooltipNode = tooltipNodeId ? nodeMap.get(tooltipNodeId) : null;\n        if (!tooltipNode) return null;\n\n        const style = getNodeStyle(tooltipNode);\n        const metrics = tooltipNode.metrics;\n        const usageCount = metrics?.usageCount ?? 0;\n        const linksToEnsemble = (() => {\n          if (tooltipNode.isAssigned) return null; // Don't show for assigned\n          let count = 0;\n          for (const rel of relationships) {\n// ... (truncated)", "parameters": [{"name": "{\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}", "type": "Readonly<EnsembleConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx", "sourceCode": "export default function EnsembleHealthBar({\n  assignments,\n  candidates,\n  kindToCategory,\n}: Readonly<EnsembleHealthBarProps>) {\n  // Compute category stats\n  const stats = useMemo(() => {\n    // Get all unique categories from candidates\n    const allCategories = new Set<string>();\n    const kindMap = kindToCategory || new Map<string, string>();\n\n    for (const candidate of candidates) {\n      const category = kindMap.get(candidate.kind) || candidate.kind;\n      allCategories.add(category);\n    }\n\n    // Count assigned categories\n    const assignedCategories = new Map<string, number>();\n    for (const assignment of assignments) {\n      const category = kindMap.get(assignment.entityKind) || assignment.entityKind;\n      assignedCategories.set(category, (assignedCategories.get(category) || 0) + 1);\n    }\n\n    // Find missing categories\n    const missingCategories: string[] = [];\n    for (const category of allCategories) {\n      if (!assignedCategories.has(category)) {\n        missingCategories.push(category);\n      }\n    }\n\n    // Calculate coverage percentage\n    const coveredCount = assignedCategories.size;\n    const totalCount = allCategories.size;\n    const coveragePercent = totalCount > 0 ? (coveredCount / totalCount) * 100 : 0;\n\n    return {\n      categories: [...allCategories],\n      assignedCategories,\n      missingCategories,\n      coveragePercent,\n      coveredCount,\n      totalCount,\n    };\n  }, [assignments, candidates, kindToCategory]);\n\n  const getColor = (category: string): string => {\n    return CATEGORY_COLORS[category.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (stats.totalCount === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"ehb-wrap\">\n      {/* Header */}\n      <div className=\"ehb-header\">\n        <span className=\"ehb-title\">\n          Ensemble Diversity\n        </span>\n        <span\n          className=\"ehb-count\"\n          style={{\n            '--ehb-count-color': stats.coveragePercent === 100 ? \"var(--success)\" : \"var(--text-muted)\",\n          } as React.CSSProperties}\n        >\n          {stats.coveredCount}/{stats.totalCount} categories\n        </span>\n      </div>\n\n      {/* Segmented bar */}\n      <div className=\"ehb-bar\">\n        {stats.categories.map((category, i) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const width = `${100 / stats.totalCount}%`;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              title={`${category}: ${count} assigned`}\n              className=\"ehb-bar-segment\"\n              style={{\n                '--ehb-seg-width': width,\n                '--ehb-seg-bg': isCovered ? color : \"transparent\",\n                '--ehb-seg-opacity': isCovered ? 1 : 0.3,\n                '--ehb-seg-border': i < stats.categories.length - 1 ? \"1px solid var(--bg-tertiary)\" : \"none\",\n              } as React.CSSProperties}\n            />\n          );\n        })}\n      </div>\n\n      {/* Category legend */}\n      <div\n        className=\"ehb-legend\"\n        style={{\n          '--ehb-legend-mb': stats.missingCategories.length > 0 ? \"8px\" : \"0\",\n        } as React.CSSProperties}\n      >\n        {stats.categories.map((category) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              className=\"ehb-legend-item\"\n              style={{\n                '--ehb-item-color': isCovered ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                '--ehb-item-opacity': isCovered ? 1 : 0.6,\n              } as React.CSSProperties}\n            >\n              <span\n                className=\"ehb-legend-dot\"\n                style={{\n                  '--ehb-dot-bg': isCovered ? color : \"var(--bg-secondary)\",\n                  '--ehb-dot-border': isCovered ? \"none\" : `1px solid ${color}`,\n                } as React.CSSProperties}\n              />\n              <span className=\"ehb-legend-label\">\n                {category}\n                {count > 1 && ` (${count})`}\n              </span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Missing categories warning */}\n      {stats.missingCategories.length > 0 && (\n        <div className=\"ehb-warning\">\n          <span className=\"ehb-warning-icon\">\ud83d\udca1</span>\n          <span>\n            Consider adding:{\" \"}\n            {stats.missingCategories.map((cat, i) => (\n              <span key={cat}>\n                <span className=\"ehb-missing-cat\">{cat}</span>\n                {i < stats.missingCategories.length - 1 && \", \"}\n              </span>\n            ))}\n          </span>\n        </div>\n      )}\n\n      {/* All covered celebration */}\n      {stats.missingCategories.length === 0 && stats.totalCount > 1 && (\n        <div className=\"ehb-success\">\n          <span>\u2713</span>\n          <span>All categories represented - diverse ensemble!</span>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  assignments,\n  candidates,\n  kindToCategory,\n}", "type": "Readonly<EnsembleHealthBarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx", "sourceCode": "export default function EntityDetailCard({\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}: Readonly<EntityDetailCardProps>) {\n  // Empty state\n  if (!entity) {\n    return (\n      <div className=\"edc-empty\">\n        <div className=\"edc-empty-sub\">No entity selected</div>\n        <div className=\"edc-empty-hint\">Click a node to see details</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edc-card\">\n      {/* Header - compact */}\n      <div className=\"edc-header\">\n        <div className=\"edc-name-row\">\n          {entity.name}\n          {isEntryPoint && (\n            <span className=\"edc-entry-badge\">\n              Entry\n            </span>\n          )}\n          {isAssigned && !isEntryPoint && (\n            <span className=\"edc-assigned-badge\">\n              Assigned\n            </span>\n          )}\n        </div>\n        <div className=\"edc-kind-line\">\n          {entity.kind}\n          {entity.subtype && ` \u00b7 ${entity.subtype}`}\n        </div>\n      </div>\n\n      {/* Metrics - two rows: stats on top, story effects below */}\n      {(metrics || eraName) && (\n        <div className=\"edc-metrics\">\n          {/* Row 1: Basic stats */}\n          <div className=\"edc-metric-row\">\n            {metrics && (\n              <>\n                <MetricChip\n                  label={(() => {\n                    if (metrics.distance === 0) return \"Entry\";\n                    if (metrics.distance === 1) return \"Direct\";\n                    if (metrics.distance >= 99) return \"Distant\";\n                    return `${metrics.distance}-hop`;\n                  })()}\n                />\n                <MetricChip\n                  label={`${metrics.usageCount}x used`}\n                  variant={(() => {\n                    if (metrics.usageCount >= 5) return \"error\" as const;\n                    if (metrics.usageCount >= 2) return \"warning\" as const;\n                    return \"default\" as const;\n                  })()}\n                />\n                <MetricChip label={`${(metrics.avgStrength * 100).toFixed(0)}% link`} />\n              </>\n            )}\n            {eraName && <MetricChip label={eraName} customColor={eraColor} />}\n          </div>\n          {/* Row 2: Story effects (always separate line) */}\n          {(metrics?.addsNewCategory || (metrics && metrics.newRelTypes > 0)) && (\n            <div className=\"edc-metric-row\">\n              {metrics?.addsNewCategory && <MetricChip label=\"+category\" variant=\"accent\" />}\n              {metrics && metrics.newRelTypes > 0 && (\n                <MetricChip label={`+${metrics.newRelTypes} rel`} variant=\"accent\" />\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}", "type": "Readonly<EntityDetailCardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx", "sourceCode": "export default function FilterChips<T extends string>({\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}: Readonly<FilterChipsProps<T>>) {\n  const handleChipClick = (option: T) => {\n    const newSelected = new Set(selected);\n\n    if (newSelected.has(option)) {\n      newSelected.delete(option);\n    } else {\n      if (!multiSelect) {\n        newSelected.clear();\n      }\n      newSelected.add(option);\n    }\n\n    onSelectionChange(newSelected);\n  };\n\n  const handleClearAll = () => {\n    onSelectionChange(new Set());\n  };\n\n  const getChipColor = (option: T): string => {\n    if (getColor) return getColor(option);\n    return KIND_COLORS[option.toLowerCase()] || \"var(--accent-color)\";\n  };\n\n  const getDisplayLabel = (option: T): string => {\n    if (formatLabel) return formatLabel(option);\n    // Capitalize first letter\n    return option.charAt(0).toUpperCase() + option.slice(1);\n  };\n\n  return (\n    <div className=\"fc-wrap\">\n      {label && (\n        <div className=\"fc-header\">\n          <span className=\"fc-label\">\n            {label}\n          </span>\n          {selected.size > 0 && (\n            <button\n              onClick={handleClearAll}\n              className=\"fc-clear-btn\"\n            >\n              Clear\n            </button>\n          )}\n        </div>\n      )}\n\n      <div className=\"fc-chips\">\n        {options.map((option) => {\n          const isSelected = selected.has(option);\n          const color = getChipColor(option);\n\n          return (\n            <button\n              key={option}\n              onClick={() => handleChipClick(option)}\n              className=\"fc-chip\"\n              style={{\n                '--fc-chip-border': isSelected ? `1px solid ${color}` : \"1px solid var(--border-color)\",\n                '--fc-chip-bg': isSelected ? color : \"transparent\",\n                '--fc-chip-color': isSelected ? \"white\" : \"var(--text-secondary)\",\n                '--fc-chip-weight': isSelected ? 500 : 400,\n              } as React.CSSProperties}\n            >\n              {/* Color dot when not selected */}\n              {!isSelected && (\n                <span\n                  className=\"fc-chip-dot\"\n                  style={{\n                    '--fc-dot-bg': color,\n                  } as React.CSSProperties}\n                />\n              )}\n              {getDisplayLabel(option)}\n            </button>\n          );\n        })}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}", "type": "Readonly<FilterChipsProps<T>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx", "sourceCode": "export default function IntensitySparkline({\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}: Readonly<IntensitySparklineProps>) {\n  // Match padding with NarrativeTimeline for visual alignment\n  const padding = { left: 40, right: 40, top: 4, bottom: 4 };\n  const innerWidth = width - padding.left - padding.right;\n  const innerHeight = height - padding.top - padding.bottom;\n\n  // Build the SVG path\n  const { areaPath, linePath } = useMemo(() => {\n    if (points.length < 2) {\n      return { areaPath: \"\", linePath: \"\" };\n    }\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const scaleY = (intensity: number) => padding.top + (1 - intensity) * innerHeight;\n\n    // Build line path\n    const lineParts: string[] = [];\n    const areaParts: string[] = [];\n\n    points.forEach((point, i) => {\n      const x = scaleX(point.tick);\n      const y = scaleY(point.intensity);\n\n      if (i === 0) {\n        lineParts.push(`M ${x} ${y}`);\n        areaParts.push(`M ${x} ${height - padding.bottom}`);\n        areaParts.push(`L ${x} ${y}`);\n      } else {\n        lineParts.push(`L ${x} ${y}`);\n        areaParts.push(`L ${x} ${y}`);\n      }\n    });\n\n    // Close the area path\n    const lastX = scaleX(points[points.length - 1].tick);\n    areaParts.push(`L ${lastX} ${height - padding.bottom}`);\n    areaParts.push(\"Z\");\n\n    return {\n      areaPath: areaParts.join(\" \"),\n      linePath: lineParts.join(\" \"),\n    };\n  }, [points, extent, innerWidth, innerHeight, height, padding]);\n\n  // Build highlight rect for selected range\n  const highlightRect = useMemo(() => {\n    if (!selectedRange) return null;\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const x1 = scaleX(selectedRange[0]);\n    const x2 = scaleX(selectedRange[1]);\n\n    return {\n      x: Math.min(x1, x2),\n      width: Math.abs(x2 - x1),\n    };\n  }, [selectedRange, extent, innerWidth, padding]);\n\n  if (points.length < 2) {\n    return (\n      <svg width={width} height={height}>\n        <text\n          x={width / 2}\n          y={height / 2}\n          textAnchor=\"middle\"\n          fontSize=\"10\"\n          fill=\"var(--text-muted)\"\n        >\n          Not enough data\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={width} height={height} className=\"is-svg\">\n      {/* Selected range highlight */}\n      {highlightRect && (\n        <rect\n          x={highlightRect.x}\n          y={0}\n          width={highlightRect.width}\n          height={height}\n          fill=\"rgba(99, 102, 241, 0.15)\"\n        />\n      )}\n\n      {/* Area fill */}\n      <path d={areaPath} fill={fillColor} />\n\n      {/* Line stroke */}\n      <path d={linePath} fill=\"none\" stroke={strokeColor} strokeWidth={1.5} />\n\n      {/* Label */}\n      <text x={4} y={12} fontSize=\"9\" fill=\"var(--text-muted)\" fontFamily=\"inherit\">\n        Narrative Intensity\n      </text>\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}", "type": "Readonly<IntensitySparklineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx", "sourceCode": "export default function MiniConstellation({\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}: Readonly<MiniConstellationProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const centerRadius = 16;\n  const nodeRadius = 10;\n  const orbitRadius = size / 2 - nodeRadius - 12;\n\n  // Limit and arrange connections\n  const visibleConnections = useMemo(() => {\n    // Group by kind and take most diverse sample\n    const byKind = new Map<string, ConnectedEntity[]>();\n    for (const conn of connections) {\n      const list = byKind.get(conn.kind) || [];\n      list.push(conn);\n      byKind.set(conn.kind, list);\n    }\n\n    // Take one from each kind first, then fill remaining\n    const result: ConnectedEntity[] = [];\n    const kindIterators = [...byKind.values()].map((list) => list[Symbol.iterator]());\n\n    while (result.length < maxConnections && kindIterators.length > 0) {\n      for (let i = kindIterators.length - 1; i >= 0; i--) {\n        if (result.length >= maxConnections) break;\n        const next = kindIterators[i].next();\n        if (next.done) {\n          kindIterators.splice(i, 1);\n        } else {\n          result.push(next.value);\n        }\n      }\n    }\n\n    return result;\n  }, [connections, maxConnections]);\n\n  const hiddenCount = connections.length - visibleConnections.length;\n\n  // Position nodes in a circle\n  const nodePositions = useMemo(() => {\n    const count = visibleConnections.length;\n    if (count === 0) return [];\n\n    const angleStep = (2 * Math.PI) / count;\n    const startAngle = -Math.PI / 2; // Start from top\n\n    return visibleConnections.map((conn, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        ...conn,\n        x: cx + orbitRadius * Math.cos(angle),\n        y: cy + orbitRadius * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [visibleConnections, cx, cy, orbitRadius]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (connections.length === 0) {\n    return (\n      <svg width={size} height={size} className=\"mc-svg\">\n        {/* Center node */}\n        <circle cx={cx} cy={cy} r={centerRadius} fill=\"var(--accent-color)\" />\n        <text x={cx} y={cy} textAnchor=\"middle\" dy={3} fontSize=\"10\" fill=\"white\" fontWeight=\"500\">\n          \u2605\n        </text>\n        <text\n          x={cx}\n          y={cy + centerRadius + 14}\n          textAnchor=\"middle\"\n          fontSize=\"9\"\n          fill=\"var(--text-muted)\"\n        >\n          No connections\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={size} height={size} className=\"mc-svg\">\n      {/* Connection lines */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n        const strength = node.strength ?? 0.5;\n\n        return (\n          <line\n            key={i}\n            x1={cx}\n            y1={cy}\n            x2={node.x}\n            y2={node.y}\n            stroke={color}\n            strokeWidth={1 + strength * 2}\n            strokeOpacity={0.4 + strength * 0.4}\n          />\n        );\n      })}\n\n      {/* Outer nodes */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n\n        return (\n          <g key={i}>\n            {/* Node circle */}\n            <circle cx={node.x} cy={node.y} r={nodeRadius} fill={color} opacity={0.9} />\n            {/* Kind initial */}\n            <text\n              x={node.x}\n              y={node.y}\n              textAnchor=\"middle\"\n              dy={3}\n              fontSize=\"8\"\n              fill=\"white\"\n              fontWeight=\"500\"\n            >\n              {node.kind.charAt(0).toUpperCase()}\n            </text>\n            {/* Name label */}\n            <title>{`${node.name} (${node.kind})\\n${node.relationshipKind}`}</title>\n          </g>\n        );\n      })}\n\n      {/* Center node (entry point) */}\n      <circle\n        cx={cx}\n        cy={cy}\n        r={centerRadius}\n        fill=\"var(--accent-color)\"\n        stroke=\"white\"\n        strokeWidth={2}\n      />\n      <text x={cx} y={cy} textAnchor=\"middle\" dy={4} fontSize=\"12\" fill=\"white\" fontWeight=\"600\">\n        \u2605\n      </text>\n\n      {/* Center label */}\n      <text x={cx} y={size - 6} textAnchor=\"middle\" fontSize=\"9\" fill=\"var(--text-muted)\">\n        {visibleConnections.length} connections\n        {hiddenCount > 0 && ` (+${hiddenCount})`}\n      </text>\n\n      {/* Legend - show unique kinds */}\n      {(() => {\n        const uniqueKinds = [...new Set(visibleConnections.map((c) => c.kind))];\n        if (uniqueKinds.length <= 4) {\n          return (\n            <g>\n              {uniqueKinds.map((kind, i) => (\n                <g key={kind} transform={`translate(${4 + i * 40}, 4)`}>\n                  <circle cx={4} cy={6} r={4} fill={getKindColor(kind)} />\n                  <text x={12} y={9} fontSize=\"8\" fill=\"var(--text-muted)\">\n                    {kind.slice(0, 4)}\n                  </text>\n                </g>\n              ))}\n            </g>\n          );\n        }\n        return null;\n      })()}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}", "type": "Readonly<MiniConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx", "sourceCode": "export default function NarrativeTimeline({\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}: Readonly<NarrativeTimelineProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredEvent, setHoveredEvent] = useState<TooltipData | null>(null);\n  const [hoveredCastMarker, setHoveredCastMarker] = useState<CastTooltipData | null>(null);\n\n  const padding = { left: 40, right: 40, top: 24, bottom: 32 };\n  const hasCastMarkers = castMarkers && castMarkers.length > 0;\n  const castTrackHeight = hasCastMarkers ? 28 : 0;\n  const laneHeight = height - padding.top - padding.bottom;\n  const eventAreaTop = padding.top + 20; // Leave room for era labels\n  const eventAreaHeight = laneHeight - 20 - castTrackHeight;\n  const castBaselineY = eventAreaTop + eventAreaHeight + 4;\n  const castMarkerCenterY = castBaselineY + 12;\n\n  // Use provided extent or compute from events as fallback\n  const extent = useMemo(() => {\n    if (extentProp) return extentProp;\n    return computeTimelineExtent(events.map((e) => ({ tick: e.tick }) as any));\n  }, [extentProp, events]);\n\n  // Scale functions\n  const scaleX = useCallback(\n    (tick: number) => tickToX(tick, extent, width, padding.left),\n    [extent, width, padding.left]\n  );\n\n  // Position events to avoid overlap using simple row allocation\n  const eventPositions = useMemo(() => {\n    const positions = new Map<string, { x: number; y: number; height: number; row: number }>();\n    const rows: Array<{ endX: number }> = [];\n    const eventWidth = 24;\n    const eventGap = 4;\n\n    // Sort by tick\n    const sorted = [...events].sort((a, b) => a.tick - b.tick);\n\n    for (const event of sorted) {\n      const x = scaleX(event.tick);\n      const eventHeight = getEventHeight(event.significance, 50, 20);\n\n      // Find first available row\n      let row = 0;\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].endX + eventGap < x) {\n          row = i;\n          break;\n        }\n        row = i + 1;\n      }\n\n      // Ensure row exists\n      while (rows.length <= row) {\n        rows.push({ endX: 0 });\n      }\n      rows[row].endX = x + eventWidth;\n\n      // Calculate y position (stack from bottom)\n      const y = eventAreaTop + eventAreaHeight - eventHeight - row * 12;\n\n      positions.set(event.id, { x, y, height: eventHeight, row });\n    }\n\n    return positions;\n  }, [events, scaleX, eventAreaTop, eventAreaHeight]);\n\n  // Generate tick marks\n  const tickMarks = useMemo(() => {\n    const [minTick, maxTick] = extent;\n    const range = maxTick - minTick;\n    const step = Math.ceil(range / 8);\n    const marks: number[] = [];\n\n    for (let tick = Math.ceil(minTick / step) * step; tick <= maxTick; tick += step) {\n      marks.push(tick);\n    }\n\n    return marks;\n  }, [extent]);\n\n  const handleEventClick = useCallback(\n    (e: React.MouseEvent, eventId: string) => {\n      e.stopPropagation();\n      onToggleEvent(eventId);\n    },\n    [onToggleEvent]\n  );\n\n  const handleEventHover = useCallback((event: TimelineEvent | null, e?: React.MouseEvent) => {\n    if (event && e && svgRef.current) {\n      const rect = svgRef.current.getBoundingClientRect();\n      setHoveredEvent({\n        event,\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    } else {\n      setHoveredEvent(null);\n    }\n  }, []);\n\n  return (\n    <div className=\"nt-wrap\">\n      <svg\n        ref={svgRef}\n        width={width}\n        height={height}\n        className=\"nt-svg\"\n      >\n        {/* Era bands */}\n        {eraRanges.map((era) => {\n          // Clamp era boundaries to the usable timeline area\n          const x1 = Math.max(scaleX(era.startTick), padding.left);\n          const x2 = Math.min(scaleX(era.endTick), width - padding.right);\n          const isFocal = focalEraId === era.id;\n          const bandWidth = x2 - x1;\n\n          // Skip eras that fall entirely outside the visible range\n          if (bandWidth <= 0) return null;\n\n          return (\n            <g key={era.id}>\n              {/* Era background band */}\n              <rect\n                x={x1}\n                y={padding.top}\n                width={bandWidth}\n                height={laneHeight}\n                fill={era.color}\n                opacity={isFocal ? 0.15 : 0.08}\n              />\n              {/* Era divider line */}\n              <line\n                x1={x1}\n                y1={padding.top}\n                x2={x1}\n                y2={height - padding.bottom}\n                stroke={era.color}\n                strokeWidth={isFocal ? 2 : 1}\n                strokeDasharray={isFocal ? \"none\" : \"4,4\"}\n              />\n              {/* Era label */}\n              <text\n                x={x1 + 6}\n                y={padding.top + 14}\n                fontSize=\"10\"\n                fontWeight={isFocal ? 600 : 400}\n                fill={era.color}\n              >\n                {era.name}\n                {isFocal && \" \u2605\"}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Timeline axis */}\n        <line\n          x1={padding.left}\n          y1={height - padding.bottom}\n          x2={width - padding.right}\n          y2={height - padding.bottom}\n          stroke=\"var(--border-color)\"\n          strokeWidth={1}\n        />\n\n        {/* Tick marks */}\n        {tickMarks.map((tick) => {\n          const x = scaleX(tick);\n          return (\n            <g key={tick}>\n              <line\n                x1={x}\n                y1={height - padding.bottom}\n                x2={x}\n                y2={height - padding.bottom + 4}\n                stroke=\"var(--text-muted)\"\n                strokeWidth={1}\n              />\n              <text\n                x={x}\n                y={height - padding.bottom + 16}\n                textAnchor=\"middle\"\n                fontSize=\"9\"\n                fill=\"var(--text-muted)\"\n              >\n                {tick}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Event cards */}\n        {events.map((event) => {\n          const pos = eventPositions.get(event.id);\n          if (!pos) return null;\n\n          const fill = getEventFill(event);\n          const cardWidth = 20;\n\n          return (\n            <g\n              key={event.id}\n              className=\"nt-cursor-pointer\"\n              onClick={(e) => handleEventClick(e, event.id)}\n              onMouseEnter={(e) => handleEventHover(event, e)}\n              onMouseLeave={() => handleEventHover(null)}\n            >\n              {/* Event card */}\n              <rect\n                x={pos.x - cardWidth / 2}\n                y={pos.y}\n                width={cardWidth}\n                height={pos.height}\n                rx={3}\n                fill={fill}\n                opacity={event.selected ? 1 : 0.4}\n                stroke={event.selected ? \"white\" : \"transparent\"}\n                strokeWidth={event.selected ? 2 : 0}\n              />\n              {/* Selection checkmark */}\n              {event.selected && (\n                <text\n                  x={pos.x}\n                  y={pos.y + pos.height / 2 + 4}\n                  textAnchor=\"middle\"\n                  fontSize=\"12\"\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  className=\"nt-no-pointer\"\n                >\n                  \u2713\n                </text>\n              )}\n            </g>\n          );\n        })}\n\n        {/* Cast creation markers */}\n        {hasCastMarkers && (\n          <g>\n            {/* Dashed baseline */}\n            <line\n              x1={padding.left}\n              y1={castBaselineY}\n              x2={width - padding.right}\n              y2={castBaselineY}\n              stroke=\"var(--border-color)\"\n              strokeWidth={1}\n              strokeDasharray=\"4,3\"\n            />\n            {/* \"Cast\" label */}\n            <text\n              x={padding.left - 4}\n              y={castMarkerCenterY + 3}\n              textAnchor=\"end\"\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n            >\n              Cast\n            </text>\n            {/* Markers */}\n            {castMarkers.map((marker) => {\n              if (typeof marker.createdAt !== \"number\" || Number.isNaN(marker.createdAt))\n                return null;\n              const x = scaleX(marker.createdAt);\n              const shape = getCastMarkerShape(marker.entityKind);\n              const color = getCastMarkerColor(marker.entityKind);\n              const isHovered = hoveredCastMarker?.marker.entityId === marker.entityId;\n\n              return (\n                <g\n                  key={marker.entityId}\n                  className=\"nt-cursor-pointer\"\n                  onMouseEnter={(e) => {\n                    if (svgRef.current) {\n                      const rect = svgRef.current.getBoundingClientRect();\n                      setHoveredCastMarker({\n                        marker,\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                      });\n                    }\n                  }}\n                  onMouseLeave={() => setHoveredCastMarker(null)}\n                >\n                  {/* Vertical tick from baseline to marker */}\n                  <line\n                    x1={x}\n                    y1={castBaselineY}\n                    x2={x}\n                    y2={castMarkerCenterY - shape.size / 2}\n// ... (truncated)", "parameters": [{"name": "{\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}", "type": "Readonly<NarrativeTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx", "sourceCode": "export default function RoleSlot({\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}: Readonly<RoleSlotProps>) {\n  const canAccept = hasSelection && !isAtMax;\n  const count = assignments.length;\n\n  const wrapClass = `rs-wrap ${canAccept ? \"rs-wrap-accept\" : isUnderMin ? \"rs-wrap-undermin\" : \"rs-wrap-default\"}`;\n\n  return (\n    <div\n      onClick={canAccept ? onAssign : undefined}\n      className={wrapClass}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      {/* Role header - single line */}\n      <div className={`rs-header ${assignments.length > 0 || canAccept ? \"rs-header-mb\" : \"\"}`}>\n        <div className=\"rs-name-row\">\n          <span className={`rs-role-name ${isUnderMin ? \"rs-role-name-error\" : \"rs-role-name-default\"}`}>\n            {role.role}\n          </span>\n          <span className={`rs-role-count ${isUnderMin ? \"rs-role-count-error\" : \"rs-role-count-default\"}`}>\n            {count}/{role.count.max}\n          </span>\n        </div>\n\n        {canAccept && (\n          <span className=\"rs-add-label\">\n            + Add\n          </span>\n        )}\n      </div>\n\n      {/* Assigned entities - visually distinct from header */}\n      {assignments.length > 0 && (\n        <div className=\"rs-assignments\">\n          {assignments.map((assignment) => (\n            <div\n              key={assignment.entityId}\n              className=\"rs-assignment-row\"\n              onClick={(e) => e.stopPropagation()}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              {/* Entity name */}\n              <span className=\"rs-entity-name\">\n                {assignment.entityName}\n                <span className=\"rs-entity-kind\">\n                  {assignment.entityKind}\n                </span>\n              </span>\n\n              {/* Primary/Support toggle - full text, more button-like */}\n              <button\n                onClick={() => onTogglePrimary(assignment.entityId)}\n                className={`rs-toggle-btn ${assignment.isPrimary ? \"rs-toggle-btn-primary\" : \"rs-toggle-btn-support\"}`}\n                title=\"Click to toggle primary/support\"\n              >\n                {assignment.isPrimary ? \"Primary\" : \"Support\"}\n              </button>\n\n              {/* Remove button */}\n              <button\n                onClick={() => onRemove(assignment.entityId)}\n                className=\"rs-remove-btn\"\n                title=\"Remove from role\"\n              >\n                \u00d7\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}", "type": "Readonly<RoleSlotProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "export default function StoryPotentialRadar({\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}: Readonly<StoryPotentialRadarProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const maxRadius = size / 2 - (showLabels ? 28 : 8);\n  const numAxes = AXES.length;\n  const angleStep = (2 * Math.PI) / numAxes;\n  // Start from top (-90 degrees)\n  const startAngle = -Math.PI / 2;\n\n  // Compute axis endpoints\n  const axisPoints = useMemo(() => {\n    return AXES.map((_, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + maxRadius * Math.cos(angle),\n        y: cy + maxRadius * Math.sin(angle),\n        labelX: cx + (maxRadius + 14) * Math.cos(angle),\n        labelY: cy + (maxRadius + 14) * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Compute polygon points for the data\n  const dataPoints = useMemo(() => {\n    return AXES.map((axis, i) => {\n      const value = potential[axis.key as keyof StoryPotential];\n      const radius = value * maxRadius;\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n        value,\n        label: axis.label,\n      };\n    });\n  }, [potential, cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Build polygon path\n  const polygonPath =\n    dataPoints.map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x} ${p.y}`).join(\" \") + \" Z\";\n\n  // Grid rings (25%, 50%, 75%, 100%)\n  const gridRings = [0.25, 0.5, 0.75, 1];\n\n  return (\n    <svg width={size} height={size} className=\"spr-svg\">\n      {/* Background */}\n      <circle cx={cx} cy={cy} r={maxRadius} fill=\"var(--bg-tertiary)\" />\n\n      {/* Grid rings */}\n      {gridRings.map((ring) => (\n        <circle\n          key={ring}\n          cx={cx}\n          cy={cy}\n          r={maxRadius * ring}\n          fill=\"none\"\n          stroke=\"var(--border-color)\"\n          strokeWidth={ring === 1 ? 1 : 0.5}\n          strokeDasharray={ring === 1 ? \"none\" : \"2,2\"}\n        />\n      ))}\n\n      {/* Axis lines */}\n      {axisPoints.map((point, i) => (\n        <line\n          key={i}\n          x1={cx}\n          y1={cy}\n          x2={point.x}\n          y2={point.y}\n          stroke=\"var(--border-color)\"\n          strokeWidth={0.5}\n        />\n      ))}\n\n      {/* Data polygon */}\n      <path\n        d={polygonPath}\n        fill=\"rgba(99, 102, 241, 0.3)\"\n        stroke=\"var(--accent-color)\"\n        strokeWidth={2}\n      />\n\n      {/* Data points */}\n      {dataPoints.map((point, i) => (\n        <g key={i}>\n          <circle\n            cx={point.x}\n            cy={point.y}\n            r={4}\n            fill=\"var(--accent-color)\"\n            stroke=\"white\"\n            strokeWidth={1.5}\n          />\n          {interactive && <title>{`${point.label}: ${(point.value * 100).toFixed(0)}%`}</title>}\n        </g>\n      ))}\n\n      {/* Axis labels */}\n      {showLabels &&\n        axisPoints.map((point, i) => {\n          const axis = AXES[i];\n\n          // Adjust text anchor based on position\n          let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n          if (point.labelX < cx - 10) textAnchor = \"end\";\n          else if (point.labelX > cx + 10) textAnchor = \"start\";\n\n          // Adjust vertical position\n          let dy = 4;\n          if (point.labelY < cy - maxRadius * 0.5) dy = 12;\n          else if (point.labelY > cy + maxRadius * 0.5) dy = -2;\n\n          return (\n            <text\n              key={i}\n              x={point.labelX}\n              y={point.labelY}\n              dy={dy}\n              textAnchor={textAnchor}\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n              fontFamily=\"inherit\"\n            >\n              {axis.shortLabel}\n            </text>\n          );\n        })}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}", "type": "Readonly<StoryPotentialRadarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx", "sourceCode": "export default function TimelineBrush({\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}: Readonly<TimelineBrushProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [dragMode, setDragMode] = useState<DragMode>(\"none\");\n  const [dragStart, setDragStart] = useState<{ x: number; selection: [number, number] | null }>({\n    x: 0,\n    selection: null,\n  });\n\n  const handleSize = 8;\n\n  // Convert selection to pixel positions\n  const selectionPx = selection\n    ? {\n        left: tickToX(selection[0], extent, width, padding),\n        right: tickToX(selection[1], extent, width, padding),\n      }\n    : null;\n\n  const getMouseX = useCallback((e: React.MouseEvent | MouseEvent) => {\n    if (!svgRef.current) return 0;\n    const rect = svgRef.current.getBoundingClientRect();\n    return e.clientX - rect.left;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, mode: DragMode) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragMode(mode);\n      setDragStart({ x: getMouseX(e), selection });\n    },\n    [selection, getMouseX]\n  );\n\n  const handleBackgroundMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      const x = getMouseX(e);\n      // If clicking outside selection, start creating new selection\n      if (!selectionPx || x < selectionPx.left - handleSize || x > selectionPx.right + handleSize) {\n        setDragMode(\"create\");\n        const tick = xToTick(x, extent, width, padding);\n        setDragStart({ x, selection: [tick, tick] });\n        onSelectionChange([tick, tick]);\n      }\n    },\n    [selectionPx, extent, width, padding, getMouseX, onSelectionChange, handleSize]\n  );\n\n  useEffect(() => {\n    if (dragMode === \"none\") return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const x = getMouseX(e);\n      const dx = x - dragStart.x;\n\n      if (dragMode === \"create\") {\n        const startTick = dragStart.selection[0];\n        const currentTick = xToTick(x, extent, width, padding);\n        const newSelection: [number, number] =\n          currentTick >= startTick ? [startTick, currentTick] : [currentTick, startTick];\n        onSelectionChange(newSelection);\n        return;\n      }\n\n      if (!dragStart.selection) return;\n\n      const [startTick, endTick] = dragStart.selection;\n\n      if (dragMode === \"left\") {\n        const newLeft = xToTick(\n          tickToX(startTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.min(newLeft, endTick - 1);\n        onSelectionChange([Math.max(extent[0], clamped), endTick]);\n      } else if (dragMode === \"right\") {\n        const newRight = xToTick(\n          tickToX(endTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.max(newRight, startTick + 1);\n        onSelectionChange([startTick, Math.min(extent[1], clamped)]);\n      } else if (dragMode === \"move\") {\n        const tickDelta =\n          xToTick(dragStart.x + dx, extent, width, padding) -\n          xToTick(dragStart.x, extent, width, padding);\n        let newStart = startTick + tickDelta;\n        let newEnd = endTick + tickDelta;\n\n        // Clamp to extent\n        if (newStart < extent[0]) {\n          const shift = extent[0] - newStart;\n          newStart = extent[0];\n          newEnd += shift;\n        }\n        if (newEnd > extent[1]) {\n          const shift = newEnd - extent[1];\n          newEnd = extent[1];\n          newStart -= shift;\n        }\n\n        onSelectionChange([Math.max(extent[0], newStart), Math.min(extent[1], newEnd)]);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setDragMode(\"none\");\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [dragMode, dragStart, extent, width, padding, getMouseX, onSelectionChange]);\n\n  const getCursor = (mode: DragMode) => {\n    switch (mode) {\n      case \"left\":\n      case \"right\":\n        return \"ew-resize\";\n      case \"move\":\n        return \"grab\";\n      case \"create\":\n        return \"crosshair\";\n      default:\n        return \"crosshair\";\n    }\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"tb-svg\"\n      style={{\n        '--tb-cursor': getCursor(dragMode === \"none\" ? \"create\" : dragMode),\n      } as React.CSSProperties}\n      onMouseDown={handleBackgroundMouseDown}\n    >\n      {/* Background track */}\n      <rect\n        x={padding}\n        y={4}\n        width={width - 2 * padding}\n        height={height - 8}\n        rx={4}\n        fill=\"var(--bg-tertiary)\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n      />\n\n      {/* Selection */}\n      {selectionPx && selectionPx.right - selectionPx.left >= minSelectionWidth && (\n        <g>\n          {/* Selection rect */}\n          <rect\n            x={selectionPx.left}\n            y={4}\n            width={selectionPx.right - selectionPx.left}\n            height={height - 8}\n            rx={4}\n            fill=\"rgba(99, 102, 241, 0.3)\"\n            stroke=\"var(--accent-color)\"\n            strokeWidth={1}\n            className=\"tb-grab\"\n            onMouseDown={(e) => handleMouseDown(e, \"move\")}\n          />\n\n          {/* Left handle */}\n          <rect\n            x={selectionPx.left - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"left\")}\n          />\n\n          {/* Right handle */}\n          <rect\n            x={selectionPx.right - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"right\")}\n          />\n\n          {/* Selection label */}\n          {selection && (\n            <text\n              x={(selectionPx.left + selectionPx.right) / 2}\n              y={height / 2 + 4}\n              textAnchor=\"middle\"\n              fontSize=\"10\"\n              fontWeight=\"500\"\n              fill=\"var(--accent-color)\"\n              className=\"tb-no-pointer\"\n            >\n              {selection[0]} \u2013 {selection[1]}\n            </text>\n          )}\n        </g>\n      )}\n\n      {/* Instructions when no selection */}\n      {!selectionPx && (\n        <text\n          x={width / 2}\n          y={height / 2 + 4}\n          textAnchor=\"middle\"\n          fontSize=\"11\"\n          fill=\"var(--text-muted)\"\n          className=\"tb-no-pointer\"\n        >\n          Drag to select time range\n        </text>\n      )}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}", "type": "Readonly<TimelineBrushProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts::assembleSections", "name": "assembleSections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts", "sourceCode": "export function assembleSections(\n  plan: ChroniclePlan,\n  _context: ChronicleGenerationContext,\n  options: {\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  } = {}\n): AssemblyResult {\n  const { includeTitle = true, includeSectionTitles = false } = options;\n\n  try {\n    const missingSections = plan.sections.filter((s) => !s.generatedContent);\n    if (missingSections.length > 0) {\n      return {\n        success: false,\n        error: `Missing content for ${missingSections.length} section(s): ${missingSections.map((s) => s.name).join(\", \")}`,\n      };\n    }\n\n    const parts: string[] = [];\n\n    if (includeTitle) {\n      parts.push(`# ${plan.title}\\n\\n`);\n    }\n\n    for (let i = 0; i < plan.sections.length; i += 1) {\n      const section = plan.sections[i];\n\n      if (i > 0) {\n        parts.push(\"\\n\\n---\\n\\n\");\n      }\n\n      if (includeSectionTitles && section.name) {\n        parts.push(`## ${section.name}\\n\\n`);\n      }\n\n      parts.push(section.generatedContent || \"\");\n    }\n\n    const content = parts.join(\"\");\n\n    return {\n      success: true,\n      content,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error during assembly\",\n    };\n  }\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "_context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "options", "type": "{\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  }", "optional": true}], "returnType": "AssemblyResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatFocusSummary", "name": "formatFocusSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatFocusSummary(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n  const nameForId = (id: string) => entityMap.get(id)?.name || id;\n\n  const lines = [\n    `Focus Mode: ${plan.focus.mode}`,\n    `Entrypoint: ${nameForId(plan.focus.entrypointId)}`,\n    plan.focus.primaryEntityIds?.length\n      ? `Primary: ${plan.focus.primaryEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n    plan.focus.supportingEntityIds?.length\n      ? `Supporting: ${plan.focus.supportingEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n  ].filter(Boolean);\n\n  return lines.join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatEntityRoster", "name": "formatEntityRoster", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatEntityRoster(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n\n  if (!plan.entityRoles || plan.entityRoles.length === 0) {\n    return \"(none)\";\n  }\n\n  return plan.entityRoles\n    .map((role) => {\n      const entity = entityMap.get(role.entityId);\n      const name = entity?.name || role.entityId;\n      const kind = entity?.kind || \"unknown\";\n      const subtype = entity?.subtype ? `/${entity.subtype}` : \"\";\n      const culture = entity?.culture || \"(none)\";\n      const tags = formatTags(entity?.tags);\n\n      return `- ${name} (${kind}${subtype})\n  Role: ${role.role}\n  Contribution: ${role.contribution}\n  Culture: ${culture}\n  Tags: ${tags}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatIssueList", "name": "formatIssueList", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatIssueList(report: CohesionReport, plan?: ChroniclePlan): string {\n  if (!report.issues || report.issues.length === 0) {\n    return \"(no issues listed)\";\n  }\n\n  const sectionMap = new Map(plan?.sections?.map((s) => [s.id, s.name]) || []);\n\n  return report.issues\n    .map((issue, index) => {\n      const sectionName = issue.sectionId\n        ? sectionMap.get(issue.sectionId) || issue.sectionId\n        : \"General\";\n      const suggestion = issue.suggestion\n        ? `Suggestion: ${issue.suggestion}`\n        : \"Suggestion: (none provided)\";\n      return `${index + 1}. [${issue.severity}] ${issue.checkType} (Section: ${sectionName})\n   ${issue.description}\n   ${suggestion}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "report", "type": "CohesionReport", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts::parseJsonResponse", "name": "parseJsonResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts", "sourceCode": "export function parseJsonResponse<T>(response: string): T {\n  const extracted = extractJsonBlock(response);\n  let fixed = applyJsonFixes(extracted);\n\n  try {\n    return JSON.parse(fixed) as T;\n  } catch (firstError) {\n    fixed = applyAggressiveFixes(fixed);\n\n    try {\n      return JSON.parse(fixed) as T;\n    } catch (secondError) {\n      const message = (secondError as Error).message;\n      const posMatch = message.match(/position (\\d+)/);\n      if (posMatch) {\n        const errorPos = parseInt(posMatch[1], 10);\n        const before = fixed.substring(0, errorPos);\n        const after = fixed.substring(errorPos);\n        const lastChar = before.trim().slice(-1);\n        const firstChar = after.trim()[0];\n\n        if (\n          (lastChar === '\"' || lastChar === \"}\" || lastChar === \"]\") &&\n          (firstChar === '\"' || firstChar === \"{\" || firstChar === \"[\")\n        ) {\n          const patched = before + \",\" + after;\n          return JSON.parse(patched) as T;\n        }\n      }\n\n      throw firstError;\n    }\n  }\n}", "parameters": [{"name": "response", "type": "string", "optional": false}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::buildReferenceLookup", "name": "buildReferenceLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function buildReferenceLookup<T>(\n  items: T[],\n  getId: (item: T) => string,\n  getName: (item: T) => string | undefined\n): ReferenceLookup {\n  const ids = new Map<string, string>();\n  const names = new Map<string, string | null>();\n\n  for (const item of items) {\n    const id = getId(item);\n    if (id) {\n      ids.set(normalizeId(id), id);\n    }\n    const name = getName(item);\n    if (!name) continue;\n    const normalized = normalizeName(name);\n    if (!names.has(normalized)) {\n      names.set(normalized, id);\n    } else if (names.get(normalized) !== id) {\n      names.set(normalized, null);\n    }\n  }\n\n  return { ids, names };\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "getId", "type": "(item: T) => string", "optional": false}, {"name": "getName", "type": "(item: T) => string | undefined", "optional": false}], "returnType": "ReferenceLookup"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::resolveReference", "name": "resolveReference", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function resolveReference(value: string, lookup: ReferenceLookup): string {\n  const rawValue = String(value);\n  const directMatch = lookup.ids.get(normalizeId(rawValue));\n  if (directMatch) {\n    return directMatch;\n  }\n  const nameMatch = lookup.names.get(normalizeName(rawValue));\n  return nameMatch || rawValue;\n}", "parameters": [{"name": "value", "type": "string", "optional": false}, {"name": "lookup", "type": "ReferenceLookup", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts::parseValidationResponse", "name": "parseValidationResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts", "sourceCode": "export function parseValidationResponse(response: string, plan: ChroniclePlan): CohesionReport {\n  let jsonStr = response;\n  // eslint-disable-next-line sonarjs/slow-regex -- bounded LLM response text\n  const jsonMatch = response.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1];\n  }\n\n  const parsed = JSON.parse(jsonStr.trim());\n\n  const report: CohesionReport = {\n    overallScore: typeof parsed.overallScore === \"number\" ? parsed.overallScore : 50,\n    checks: {\n      plotStructure: normalizeCheck(parsed.checks?.plotStructure),\n      entityConsistency: normalizeCheck(parsed.checks?.entityConsistency),\n      sectionGoals: normalizeSectionGoals(parsed.checks?.sectionGoals, plan.sections),\n      resolution: normalizeCheck(parsed.checks?.resolution),\n      factualAccuracy: normalizeCheck(parsed.checks?.factualAccuracy),\n      themeExpression: normalizeCheck(parsed.checks?.themeExpression),\n    },\n    issues: (parsed.issues || []).map(normalizeIssue),\n    generatedAt: Date.now(),\n  };\n\n  return report;\n}", "parameters": [{"name": "response", "type": "string", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": false}], "returnType": "CohesionReport"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditSystemPrompt", "name": "buildCopyEditSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// System prompt\n// =============================================================================\n\nexport function buildCopyEditSystemPrompt(format: \"story\" | \"document\"): string {\n  if (format === \"document\") {\n    return `You are a senior editor doing a final polish on an in-universe document that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, tighter, more convincing as an artifact \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every piece of information the document conveys. If the same information appears in two sections that serve different purposes (e.g. a summary and a detailed account), both belong. If two sections serve the same purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Nothing the document *says* changes, but it shouldn't say the same thing twice for the same reason.\n- The document's voice and register. A bureaucratic report should stay bureaucratic. A folk collection should stay collected. Do not normalize register across sections that are intentionally different (e.g. quoted material vs. editorial framing).\n- World details. Names, places, customs, terminology, formatting conventions \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the register, density, or level of formality shifts abruptly between sections, ease the transition. The document should read as a single coherent artifact.\n\nTighten. Every word should earn its place. Look for redundant framing (\"it should be noted that\"), bureaucratic padding that doesn't serve the document's voice, repeated information that appears in multiple sections for the same purpose, and explanations that duplicate what the document already establishes.\n\nCut what doesn't work. If a section catalogs information without purpose, repeats the same content in template form, or pads the document without adding substance, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as document text \u2014 should be broken or cut.\n\nRead for consistency. Formatting conventions (headers, dates, citations, marginalia) should be uniform throughout. Where a convention appears in one section but not another, extend it.\n\nWhat you must not do:\n- Do not add new content, information, sections, or world details.\n- Do not impose a different voice on the document. Burnish the voice that is already there.\n- Do not restructure sections unless they are genuinely confusing.\n- Do not modernize or standardize language that is intentionally archaic or formal.\n\nYour changes should be invisible. A reader should not be able to tell the document was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n  }\n\n  return `You are a senior fiction editor doing a final polish on a piece that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, clearer, more efficient \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every plot point and beat. If two scenes serve the same narrative purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Scenes that cover the same event from different perspectives or for different reasons each belong; scenes that do the same dramatic work twice do not. Nothing that *happens* in the story changes, but the reader shouldn't experience the same purpose served twice.\n- Character voices. Where characters speak in distinct registers \u2014 dialect, formality, cultural cadence \u2014 that is intentional. Do not standardize dialogue or testimony into a uniform voice.\n- World details. Names, places, customs, terminology \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the prose rhythm changes abruptly \u2014 a shift in sentence length, descriptive density, or level of ornateness \u2014 ease the transition. The reader should never feel a bump between sections.\n\nTighten. Every word should earn its place. Look for filter words that create distance (\"she noticed,\" \"he felt\"), redundant modifiers, stage directions that reveal nothing about character, and emotional explanations that duplicate what the prose already shows. Where the same detail appears twice because it was imported from two different drafts, keep whichever instance lands harder and cut the other.\n\nCut what doesn't work. If a passage catalogs names or events in sequence, repeats the same dramatic beat in parallel structure (e.g., three characters experiencing the same effect in the same paragraph shape), or reads as a report of what happened rather than lived experience, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as narrative \u2014 should be broken or cut.\n\nRead for rhythm. Where a sentence fights you or the prose stumbles, recast it \u2014 but preserve its content and intent. If a passage is deliberately languid or dense, that may be the style working as intended. Only intervene where the prose works against the effect it is trying to achieve.\n\nWhat you must not do:\n- Do not add new content, ideas, scenes, details, or metaphors.\n- Do not impose a different voice on the narration. Burnish the voice that is already there.\n- Do not restructure paragraphs unless they are genuinely confusing.\n- Do not flatten distinctive character speech into standard grammar.\n\nYour changes should be invisible. A reader should not be able to tell the text was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n}", "parameters": [{"name": "format", "type": "\"story\" | \"document\"", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditUserPrompt", "name": "buildCopyEditUserPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// User prompt\n// =============================================================================\n\nexport function buildCopyEditUserPrompt(\n  text: string,\n  style: NarrativeStyle,\n  voiceContext?: {\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }\n): string {\n  const target = getWordCountRange(style);\n  const currentWords = countWords(text);\n  const styleName = style.name;\n  const craftPosture =\n    \"craftPosture\" in style ? (style.craftPosture) : undefined;\n\n  const parts: string[] = [];\n\n  parts.push(`## Format\\n${styleName}`);\n\n  parts.push(\n    `## Length\\nThe piece is ${currentWords} words. The natural range for this format is ${target.min}\u2013${target.max}. Use this as context for what length feels natural, but your job is to improve the prose, not to hit a number. If the piece needs to be shorter, cut what doesn't work. If it needs room, let it breathe.`\n  );\n\n  if (craftPosture) {\n    parts.push(`## Craft Posture\\n${craftPosture}`);\n  }\n\n  // Voice textures help the editor recognize intentional prose choices\n  const nv = voiceContext?.narrativeVoice;\n  if (nv && Object.keys(nv).length > 0) {\n    const voiceLines = Object.entries(nv)\n      .map(([key, value]) => `**${key}**: ${value}`)\n      .join(\"\\n\");\n    parts.push(`## Voice Textures (preserve these \u2014 they are intentional)\\n${voiceLines}`);\n  }\n\n  // Motifs help the editor recognize structural repetition vs draft artifacts\n  const motifs = voiceContext?.motifs;\n  if (motifs && motifs.length > 0) {\n    const motifLines = motifs.map((m) => `- \"${m}\"`).join(\"\\n\");\n    parts.push(\n      `## Recurring Motifs (these are structural \u2014 do not cut or collapse)\\n${motifLines}`\n    );\n  }\n\n  parts.push(`## Text\\n\\n${text}`);\n\n  return parts.join(\"\\n\\n\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "voiceContext", "type": "{\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::applyWikilinks", "name": "applyWikilinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Apply wikilinks to content deterministically.\n * Replaces entity name mentions with [[entity]] syntax.\n *\n * Process: Replaces all mentions in a single pass using a combined regex\n * to avoid offset issues from multiple sequential replacements.\n */\nexport function applyWikilinks(content: string, entities: EntityContext[]): string {\n  // Filter and sort entities by name length descending\n  // (match longer names first to avoid partial matches)\n  const validEntities = entities\n    .filter((e) => e.name.length >= 3)\n    .sort((a, b) => b.name.length - a.name.length);\n\n  if (validEntities.length === 0) return content;\n\n  // Build a single regex that matches any entity name\n  const patterns = validEntities.map((e) => `\\\\b${escapeRegex(e.name)}\\\\b`);\n  const combinedPattern = new RegExp(`(${patterns.join(\"|\")})`, \"gi\");\n\n  // Single pass replacement - check each match to see if already linked\n  return content.replace(combinedPattern, (match, _group, offset) => {\n    // Check if this position is already inside a wikilink\n    if (isInsideWikilink(content, offset)) {\n      return match;\n    }\n    return `[[${match}]]`;\n  });\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult"}]