[{"id": "apps/canonry/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/App.jsx", "sourceCode": "// normalizeUiState moved to stores/useCanonryUiStore.js\n\nexport default function App() {\n  const activeTab = useCanonryUiStore(s => s.activeTab);\n  const activeSectionByTab = useCanonryUiStore(s => s.activeSectionByTab);\n  const showHome = useCanonryUiStore(s => s.showHome);\n  const helpModalOpen = useCanonryUiStore(s => s.helpModalOpen);\n  const chroniclerRequestedPage = useCanonryUiStore(s => s.chroniclerRequestedPage);\n  const [archivistData, setArchivistData] = useState(null);\n  const [worldContext, setWorldContext] = useState(null);\n  const [entityGuidance, setEntityGuidance] = useState(null);\n  const [cultureIdentities, setCultureIdentities] = useState(null);\n  const [enrichmentConfig, setEnrichmentConfig] = useState(null);\n  const [styleSelection, setStyleSelection] = useState(null);\n  const [historianConfig, setHistorianConfig] = useState(null);\n  const [simulationResults, setSimulationResults] = useState(null);\n  const [simulationState, setSimulationState] = useState(null);\n  const [slots, setSlots] = useState({});\n  const [activeSlotIndex, setActiveSlotIndex] = useState(0);\n  const [exportModalSlotIndex, setExportModalSlotIndex] = useState(null);\n  const [exportBundleStatus, setExportBundleStatus] = useState({\n    state: \"idle\",\n    detail: \"\"\n  });\n  // AWS state from zustand store\n  const awsModalOpen = useCanonryAwsStore(s => s.modalOpen);\n  const awsConfig = useCanonryAwsStore(s => s.config);\n  const awsTokens = useCanonryAwsStore(s => s.tokens);\n  const awsStatus = useCanonryAwsStore(s => s.status);\n  const awsBrowseState = useCanonryAwsStore(s => s.browseState);\n  const awsUsername = useCanonryAwsStore(s => s.username);\n  const awsPassword = useCanonryAwsStore(s => s.password);\n  const awsUserLabel = useCanonryAwsStore(s => s.userLabel);\n  const awsSyncProgress = useCanonryAwsStore(s => s.syncProgress);\n  const awsUploadPlan = useCanonryAwsStore(s => s.uploadPlan);\n  const snapshotStatus = useCanonryAwsStore(s => s.snapshotStatus);\n  // AWS actions from zustand store (stable references, no useCallback needed)\n  const updateAwsConfig = useCanonryAwsStore(s => s.updateConfig);\n  const setAwsTokens = useCanonryAwsStore(s => s.setTokens);\n  const setAwsStatus = useCanonryAwsStore(s => s.setStatus);\n  const setAwsBrowseState = useCanonryAwsStore(s => s.setBrowseState);\n  const setAwsUsername = useCanonryAwsStore(s => s.setUsername);\n  const setAwsPassword = useCanonryAwsStore(s => s.setPassword);\n  const setAwsUserLabel = useCanonryAwsStore(s => s.setUserLabel);\n  const setAwsSyncProgress = useCanonryAwsStore(s => s.setSyncProgress);\n  const setAwsUploadPlan = useCanonryAwsStore(s => s.setUploadPlan);\n  const setSnapshotStatus = useCanonryAwsStore(s => s.setSnapshotStatus);\n  const openAwsModal = useCanonryAwsStore(s => s.openModal);\n  const closeAwsModal = useCanonryAwsStore(s => s.closeModal);\n  const exportCancelRef = useRef(false);\n  const exportModalMouseDown = useRef(false);\n  const awsModalMouseDown = useRef(false);\n  const simulationOwnerRef = useRef(null);\n  const currentProjectRef = useRef(null);\n  // Track whether we're loading from a saved slot (to skip auto-save to scratch)\n  const isLoadingSlotRef = useRef(false);\n  // Track the last saved simulation results object to detect new simulations\n  const lastSavedResultsRef = useRef(null);\n  const bestRunScoreRef = useRef(-Infinity);\n  const bestRunSaveQueueRef = useRef(Promise.resolve());\n  const activeSection = useCanonryUiStore(selectActiveSection);\n  const s3Client = useMemo(() => createS3Client(awsConfig, awsTokens), [awsConfig, awsTokens]);\n  useEffect(() => {\n    const tokens = extractCognitoTokensFromUrl();\n    if (tokens) {\n      setAwsTokens(tokens);\n      clearCognitoHash();\n    }\n  }, [setAwsTokens]);\n  useEffect(() => {\n    let canceled = false;\n    const userPoolConfigured = Boolean(awsConfig?.cognitoUserPoolId && awsConfig?.cognitoClientId);\n    if (!userPoolConfigured || isTokenValid(awsTokens)) return;\n    getUserPoolSession(awsConfig).then(session => {\n      if (canceled || !session) return;\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      const username = session.getIdToken().payload?.[\"cognito:username\"] || \"\";\n      if (username) setAwsUserLabel(username);\n    }).catch(() => {});\n    return () => {\n      canceled = true;\n    };\n  }, [awsConfig, awsTokens, setAwsTokens, setAwsUserLabel]);\n  // UI actions from zustand store (stable references, no useCallback needed)\n  const setActiveSection = useCanonryUiStore(s => s.setActiveSection);\n  const setActiveSectionForTab = useCanonryUiStore(s => s.setActiveSectionForTab);\n  const handleTabChange = useCanonryUiStore(s => s.setActiveTab);\n  const handleGoHome = useCanonryUiStore(s => s.goHome);\n  const handleLandingNavigate = useCanonryUiStore(s => s.setActiveTab);\n  const clearChroniclerRequestedPage = useCanonryUiStore(s => s.clearChroniclerRequestedPage);\n  const openHelpModal = useCanonryUiStore(s => s.openHelpModal);\n  const closeHelpModal = useCanonryUiStore(s => s.closeHelpModal);\n  // Listen for cross-MFE navigation events (e.g., Archivist -> Chronicler)\n  useEffect(() => {\n    const navigateTo = useCanonryUiStore.getState().navigateTo;\n    const handleCrossNavigation = e => {\n      const {\n        tab,\n        pageId\n      } = e.detail || {};\n      if (tab) navigateTo(tab, pageId);\n    };\n    window.addEventListener(\"canonry:navigate\", handleCrossNavigation);\n    return () => window.removeEventListener(\"canonry:navigate\", handleCrossNavigation);\n  }, []);\n\n  // Listen for Illuminator world data mutations (rename, patch, enrichment)\n  // The Illuminator writes to its own Dexie store, then dispatches this event.\n  // We read from Dexie and merge into archivistData so other tabs see the changes.\n  useEffect(() => {\n    const handler = async e => {\n      const {\n        simulationRunId\n      } = e.detail || {};\n      if (!simulationRunId) return;\n      try {\n        const [{\n          getEntitiesForRun\n        }, {\n          getNarrativeEventsForRun\n        }] = await Promise.all([import(\"illuminator/entityRepository\"), import(\"illuminator/eventRepository\")]);\n        await Promise.all([getEntitiesForRun(simulationRunId), getNarrativeEventsForRun(simulationRunId)]);\n\n        // DISABLED: Automatic hardState updates removed due to data loss bug.\n        // The enrichment data lives in Dexie and is loaded by IlluminatorRemote.\n        // Do NOT modify worldData.hardState from this event handler.\n      } catch (err) {\n        console.warn(\"[Canonry] Failed to load Illuminator world data from Dexie:\", err);\n      }\n    };\n    window.addEventListener(\"illuminator:worlddata-changed\", handler);\n    return () => window.removeEventListener(\"illuminator:worlddata-changed\", handler);\n  }, []);\n\n  // Listen for hash changes to switch tabs (enables back button across MFEs)\n  // Hash formats: Archivist uses #/entity/{id}, Chronicler uses #/page/{id|slug}\n  useEffect(() => {\n    const handleHashChange = () => {\n      const hash = window.location.hash;\n      if (hash.startsWith(\"#/entity/\") || hash === \"#/entity\") {\n        if (activeTab !== \"archivist\") handleTabChange(\"archivist\");\n      } else if (hash.startsWith(\"#/page/\") || hash === \"#/page\") {\n        if (activeTab !== \"chronicler\") handleTabChange(\"chronicler\");\n      }\n    };\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [activeTab, handleTabChange]);\n  const openExportModal = useCallback(slotIndex => {\n    exportCancelRef.current = false;\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n    setExportModalSlotIndex(slotIndex);\n  }, []);\n  const closeExportModal = useCallback(() => {\n    setExportModalSlotIndex(null);\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n  }, []);\n  const handleExportModalMouseDown = useCallback(e => {\n    exportModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleExportModalClick = useCallback(e => {\n    if (exportBundleStatus.state === \"working\") return;\n    if (exportModalMouseDown.current && e.target === e.currentTarget) {\n      closeExportModal();\n    }\n  }, [closeExportModal, exportBundleStatus.state]);\n  const handleAwsModalMouseDown = useCallback(e => {\n    awsModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleAwsModalClick = useCallback(e => {\n    if (awsModalMouseDown.current && e.target === e.currentTarget) {\n      closeAwsModal();\n    }\n  }, [closeAwsModal]);\n  const handleAwsLogin = useCallback(async () => {\n    if (!awsUsername || !awsPassword) {\n      alert(\"Enter username and password.\");\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Signing in...\"\n      });\n      const session = await signInWithUserPool({\n        username: awsUsername,\n        password: awsPassword,\n        config: awsConfig\n      });\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      setAwsUserLabel(awsUsername);\n      setAwsPassword(\"\");\n      setAwsStatus({\n        state: \"idle\",\n        detail: \"Signed in.\"\n      });\n    } catch (err) {\n      console.error(\"Failed to sign in:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"Sign in failed.\"\n      });\n    }\n  }, [awsUsername, awsPassword, awsConfig, setAwsStatus, setAwsTokens, setAwsUserLabel, setAwsPassword]);\n  const handleAwsLogout = useCallback(() => {\n    signOutUserPool(awsConfig);\n    setAwsTokens(null);\n    setAwsUserLabel(\"\");\n    setAwsStatus({\n      state: \"idle\",\n      detail: \"Signed out.\"\n    });\n  }, [awsConfig, setAwsTokens, setAwsUserLabel, setAwsStatus]);\n  const handleAwsBrowsePrefixes = useCallback(async () => {\n    if (!s3Client || !awsConfig?.imageBucket) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: \"Missing S3 client or bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsBrowseState({\n        loading: true,\n        prefixes: [],\n        error: null\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      setAwsBrowseState({\n        loading: false,\n        prefixes,\n        error: null\n      });\n    } catch (err) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: err.message || \"Failed to list prefixes.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsBrowseState]);\n  const handleAwsTestSetup = useCallback(async () => {\n    if (!s3Client) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing AWS credentials.\"\n      });\n      return;\n    }\n    if (!awsConfig?.imageBucket) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing image bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Testing S3 access...\"\n      });\n      setAwsSyncProgress({\n        phase: \"test\",\n        processed: 0,\n        total: 0,\n        uploaded: 0\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      const prefixLabel = prefixes.length ? `Found ${prefixes.length} prefixes.` : \"Access OK.\";\n      setAwsStatus({\n        state: \"idle\",\n        detail: `Test passed. ${prefixLabel}`\n      });\n    } catch (err) {\n      console.error(\"Failed to test S3 setup:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"S3 test failed.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsStatus, setAwsSyncProgress]);\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/theme.js::getAccentColor", "name": "getAccentColor", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get accent color for current app\nexport function getAccentColor(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return colors.accentEnumerist;\n    case \"names\":\n      return colors.accentNameForge;\n    case \"cosmography\":\n      return colors.accentCosmographer;\n    case \"coherence\":\n      return colors.accentCoherence;\n    case \"simulation\":\n      return colors.accentSimulation;\n    case \"illuminator\":\n      return colors.accentIlluminator;\n    case \"archivist\":\n      return colors.accentArchivist;\n    case \"chronicler\":\n      return colors.accentChronicler;\n    default:\n      return colors.accent;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/theme.js::getAccentGradient", "name": "getAccentGradient", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get gradient for active nav buttons\nexport function getAccentGradient(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return `linear-gradient(135deg, ${colors.accentEnumerist} 0%, ${colors.accentEnumeristLight} 100%)`;\n    case \"names\":\n      return `linear-gradient(135deg, ${colors.accentNameForge} 0%, ${colors.accentNameForgeLight} 100%)`;\n    case \"cosmography\":\n      return `linear-gradient(135deg, ${colors.accentCosmographer} 0%, ${colors.accentCosmographerLight} 100%)`;\n    case \"coherence\":\n      return `linear-gradient(135deg, ${colors.accentCoherence} 0%, ${colors.accentCoherenceLight} 100%)`;\n    case \"simulation\":\n      return `linear-gradient(135deg, ${colors.accentSimulation} 0%, ${colors.accentSimulationLight} 100%)`;\n    case \"illuminator\":\n      return `linear-gradient(135deg, ${colors.accentIlluminator} 0%, ${colors.accentIlluminatorLight} 100%)`;\n    case \"archivist\":\n      return `linear-gradient(135deg, ${colors.accentArchivist} 0%, ${colors.accentArchivistLight} 100%)`;\n    case \"chronicler\":\n      return `linear-gradient(135deg, ${colors.accentChronicler} 0%, ${colors.accentChroniclerLight} 100%)`;\n    default:\n      return `linear-gradient(135deg, ${colors.accent} 0%, ${colors.accentLight} 100%)`;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/theme.js::getHoverBg", "name": "getHoverBg", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get hover background for current app\nexport function getHoverBg(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"names\":\n      return \"rgba(251, 191, 36, 0.15)\";\n    case \"cosmography\":\n      return \"rgba(96, 165, 250, 0.15)\";\n    case \"coherence\":\n      return \"rgba(245, 158, 11, 0.15)\";\n    case \"simulation\":\n      return \"rgba(167, 139, 250, 0.15)\";\n    case \"illuminator\":\n      return \"rgba(168, 85, 247, 0.15)\";\n    case \"archivist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"chronicler\":\n      return \"rgba(16, 185, 129, 0.15)\";\n    default:\n      return colors.hoverBg;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsConfig", "name": "loadAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsConfig() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(CONFIG_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsConfig", "name": "saveAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsConfig(config) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!config) {\n    localStorage.removeItem(CONFIG_KEY);\n    return;\n  }\n  localStorage.setItem(CONFIG_KEY, JSON.stringify(config));\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsTokens", "name": "loadAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsTokens() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(TOKEN_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsTokens", "name": "saveAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsTokens(tokens) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!tokens) {\n    localStorage.removeItem(TOKEN_KEY);\n    return;\n  }\n  localStorage.setItem(TOKEN_KEY, JSON.stringify(tokens));\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::clearAwsTokens", "name": "clearAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function clearAwsTokens() {\n  if (typeof localStorage === \"undefined\") return;\n  localStorage.removeItem(TOKEN_KEY);\n}", "parameters": [], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::isTokenValid", "name": "isTokenValid", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function isTokenValid(tokens) {\n  if (!tokens?.idToken) return false;\n  if (!tokens.expiresAt) return true;\n  return Date.now() < tokens.expiresAt - 30_000;\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "boolean"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildImageStorageConfig", "name": "buildImageStorageConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildImageStorageConfig(config, projectId) {\n  if (!config?.imageBucket) return null;\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  return {\n    provider: \"s3\",\n    bucket: config.imageBucket.trim(),\n    region: config.region?.trim() || \"us-east-1\",\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    projectId,\n  };\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "projectId", "type": "any", "optional": false}], "returnType": "{ provider: string; bucket: any; region: any; basePrefix: any; rawPrefix: string; webpPrefix: string; thumbPrefix: string; projectId: any; }"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::createS3Client", "name": "createS3Client", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function createS3Client(config, tokens) {\n  if (!config?.identityPoolId || !config?.region) return null;\n  const region = config.region.trim();\n  const identityPoolId = config.identityPoolId.trim();\n  const logins = {};\n  const userPoolId = config.cognitoUserPoolId?.trim();\n  if (tokens?.idToken && userPoolId) {\n    const loginKey = `cognito-idp.${region}.amazonaws.com/${userPoolId}`;\n    logins[loginKey] = tokens.idToken;\n  }\n\n  return new S3Client({\n    region,\n    credentials: fromCognitoIdentityPool({\n      clientConfig: { region },\n      identityPoolId,\n      logins: Object.keys(logins).length ? logins : undefined,\n    }),\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "tokens", "type": "any", "optional": false}], "returnType": "S3Client"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::loadImageManifest", "name": "loadImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function loadImageManifest(s3, { bucket, basePrefix }) {\n  if (!s3 || !bucket) return null;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  try {\n    const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n    const text = await readBodyAsText(response.Body);\n    if (!text) return null;\n    return JSON.parse(text);\n  } catch (err) {\n    if (err?.name === \"NoSuchKey\" || err?.$metadata?.httpStatusCode === 404) {\n      return null;\n    }\n    console.warn(\"Failed to load image manifest:\", err);\n    return null;\n  }\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::saveImageManifest", "name": "saveImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function saveImageManifest(s3, { bucket, basePrefix }, manifest) {\n  if (!s3 || !bucket) return;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  const body = JSON.stringify(manifest, null, 2);\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}, {"name": "manifest", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::listS3Prefixes", "name": "listS3Prefixes", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function listS3Prefixes(s3, { bucket, prefix }) {\n  if (!s3 || !bucket) return [];\n  const response = await s3.send(\n    new ListObjectsV2Command({\n      Bucket: bucket,\n      Prefix: prefix || undefined,\n      Delimiter: \"/\",\n      MaxKeys: 200,\n    })\n  );\n  return (response.CommonPrefixes || []).map((item) => item.Prefix).filter(Boolean);\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, prefix }", "type": "{ bucket: any; prefix: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::getS3ImageUploadPlan", "name": "getS3ImageUploadPlan", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function getS3ImageUploadPlan({ projectId, s3, config, repairSizes = false }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const manifestFromS3 = await loadImageManifest(s3, { bucket, basePrefix });\n  const manifest = manifestFromS3 || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  const candidates = [];\n  const repairs = { attempted: 0, updated: 0, skipped: 0, failed: 0 };\n  const manifestRepairs = { updated: 0, skipped: 0, failed: 0 };\n  const canRepairManifest = Boolean(repairSizes && manifestFromS3);\n  let manifestChanged = false;\n  let db = null;\n\n  try {\n    if (repairSizes) {\n      db = await openIlluminatorDb();\n    }\n\n    for (const image of images) {\n      if (!image?.imageId) continue;\n      const updatedAt = image.savedAt || image.generatedAt || 0;\n      const entry = existing[image.imageId];\n      const rawSize = image.size;\n      const normalizedSize = normalizeImageSize(rawSize);\n\n      let { effectiveSize, sizeSource, needsBlob } = resolveEffectiveSize(\n        image, entry, updatedAt, normalizedSize, repairSizes\n      );\n      let blob = null;\n\n      if (needsBlob) {\n        blob = await getImageBlob(image.imageId);\n        ({ effectiveSize, sizeSource } = applyBlobSize(blob, effectiveSize, sizeSource));\n      }\n\n      if (canRepairManifest && entry && entry.updatedAt >= updatedAt) {\n        if (repairManifestEntry(entry, updatedAt, effectiveSize, manifestRepairs)) {\n          manifestChanged = true;\n        }\n      }\n\n      if (repairSizes && blob && effectiveSize != null && effectiveSize !== normalizedSize) {\n        await repairImageSize(db, image.imageId, effectiveSize, repairs);\n      }\n\n      const reasons = collectUploadReasons(entry, updatedAt, effectiveSize);\n      if (!reasons.length) continue;\n\n      candidates.push({\n        imageId: image.imageId,\n        entityId: image.entityId || null,\n        entityName: image.entityName || null,\n        imageType: image.imageType || \"entity\",\n        updatedAt,\n        size: rawSize ?? null,\n        effectiveSize,\n        sizeSource,\n        manifestUpdatedAt: entry?.updatedAt ?? null,\n        manifestSize: entry?.size ?? null,\n        reason: reasons.join(\"+\"),\n      });\n    }\n  } finally {\n    if (db) {\n      db.close();\n    }\n  }\n\n  if (canRepairManifest && manifestChanged) {\n    manifest.generatedAt = new Date().toISOString();\n    manifest.count = Object.keys(existing).length;\n    await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n  }\n\n  return {\n    total: images.length,\n    candidates,\n    manifestFound: Boolean(manifestFromS3),\n    basePrefix,\n    repairs: repairSizes ? repairs : null,\n    manifestRepairs: canRepairManifest ? manifestRepairs : null,\n  };\n}", "parameters": [{"name": "{ projectId, s3, config, repairSizes = false }", "type": "{ projectId: any; s3: any; config: any; repairSizes?: boolean; }", "optional": false}], "returnType": "Promise<{ total: any; candidates: { imageId: any; entityId: any; entityName: any; imageType: any; updatedAt: any; size: any; effectiveSize: any; sizeSource: string; manifestUpdatedAt: any; manifestSize: any; reason: string; }[]; manifestFound: boolean; basePrefix: any; repairs: { attempted: number; updated: number; skipped: number; failed: number; }; manifestRepairs: { updated: number; skipped: number; failed: number; }; }>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::syncProjectImagesToS3", "name": "syncProjectImagesToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function syncProjectImagesToS3({ projectId, s3, config, onProgress }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const rawPrefix = DEFAULT_RAW_PREFIX;\n  const manifest = (await loadImageManifest(s3, { bucket, basePrefix })) || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  let processed = 0;\n  let uploaded = 0;\n  const total = images.length;\n\n  for (const image of images) {\n    if (!image?.imageId) continue;\n    processed += 1;\n    if (onProgress) {\n      onProgress({ phase: \"scan\", processed, total, uploaded });\n    }\n\n    const updatedAt = image.savedAt || image.generatedAt || 0;\n    const entry = existing[image.imageId];\n    const normalizedSize = normalizeImageSize(image.size);\n\n    let blob = null;\n    if (entry && entry.updatedAt >= updatedAt && normalizedSize == null) {\n      blob = await getImageBlob(image.imageId);\n    }\n\n    if (shouldSkipSyncImage(entry, updatedAt, normalizedSize, blob)) continue;\n\n    if (!blob) {\n      blob = await getImageBlob(image.imageId);\n      if (!blob) continue;\n    }\n\n    const buffer = await blob.arrayBuffer();\n    const body = new Uint8Array(buffer);\n    const contentLength = body.byteLength;\n\n    const rawKey = toS3Key(basePrefix, rawPrefix, projectId, image.imageId);\n    const tagging = buildTagging({ ...image, projectId, savedAt: updatedAt });\n\n    await s3.send(\n      new PutObjectCommand({\n        Bucket: bucket,\n        Key: rawKey,\n        Body: body,\n        ContentType: image.mimeType || blob.type || \"application/octet-stream\",\n        ContentLength: contentLength,\n        Tagging: tagging,\n        CacheControl: \"public, max-age=31536000, immutable\",\n      })\n    );\n\n    existing[image.imageId] = buildManifestEntry(\n      image, projectId, rawKey, blob, normalizedSize, contentLength, updatedAt\n    );\n\n    uploaded += 1;\n    if (onProgress) {\n      onProgress({ phase: \"upload\", processed, total, uploaded });\n    }\n  }\n\n  manifest.images = existing;\n  manifest.generatedAt = new Date().toISOString();\n  manifest.count = Object.keys(existing).length;\n  await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n\n  return { total, uploaded, manifest };\n}", "parameters": [{"name": "{ projectId, s3, config, onProgress }", "type": "{ projectId: any; s3: any; config: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: any; uploaded: number; manifest: any; }>"}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildStorageImageUrl", "name": "buildStorageImageUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildStorageImageUrl(storage, variant, imageId) {\n  if (!storage || !imageId) return null;\n  const basePrefix = storage.basePrefix || \"\";\n  const projectId = storage.projectId || \"\";\n  let prefix;\n  if (variant === \"raw\") {\n    prefix = storage.rawPrefix;\n  } else if (variant === \"thumb\") {\n    prefix = storage.thumbPrefix;\n  } else {\n    prefix = storage.webpPrefix;\n  }\n  const filename = variant === \"raw\" ? imageId : `${imageId}.webp`;\n  const path = toS3Key(basePrefix, prefix, projectId, filename);\n  return `/${path}`;\n}", "parameters": [{"name": "storage", "type": "any", "optional": false}, {"name": "variant", "type": "any", "optional": false}, {"name": "imageId", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::extractCognitoTokensFromUrl", "name": "extractCognitoTokensFromUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function extractCognitoTokensFromUrl() {\n  if (typeof window === \"undefined\") return null;\n  const params = parseHashParams(window.location.hash || \"\");\n  if (!params.id_token) return null;\n  const expiresIn = Number(params.expires_in || 0);\n  const expiresAt = expiresIn ? Date.now() + expiresIn * 1000 : null;\n  return {\n    idToken: params.id_token,\n    accessToken: params.access_token || null,\n    tokenType: params.token_type || null,\n    expiresAt,\n  };\n}", "parameters": [], "returnType": "{ idToken: any; accessToken: any; tokenType: any; expiresAt: number; }"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::clearCognitoHash", "name": "clearCognitoHash", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function clearCognitoHash() {\n  if (typeof window === \"undefined\") return;\n  if (window.location.hash) {\n    history.replaceState(null, document.title, window.location.pathname + window.location.search);\n  }\n}", "parameters": [], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLoginUrl", "name": "buildHostedUiLoginUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLoginUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const scope = config?.cognitoScope?.trim() || \"openid email profile\";\n  const params = new URLSearchParams({\n    client_id: clientId,\n    response_type: \"token\",\n    scope,\n    redirect_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/login?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLogoutUrl", "name": "buildHostedUiLogoutUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLogoutUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const params = new URLSearchParams({\n    client_id: clientId,\n    logout_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/logout?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signInWithUserPool", "name": "signInWithUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function signInWithUserPool({ username, password, config }) {\n  const authenticationDetails = new AuthenticationDetails({\n    Username: username,\n    Password: password,\n  });\n\n  const user = new CognitoUser({\n    Username: username,\n    Pool: getUserPool(config),\n  });\n\n  return new Promise((resolve, reject) => {\n    user.authenticateUser(authenticationDetails, {\n      onSuccess: (session) => resolve(session),\n      onFailure: (error) => reject(error),\n    });\n  });\n}", "parameters": [{"name": "{ username, password, config }", "type": "{ username: any; password: any; config: any; }", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::getUserPoolSession", "name": "getUserPoolSession", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function getUserPoolSession(config) {\n  const user = getCurrentUser(config);\n  if (!user) return null;\n  return new Promise((resolve) => {\n    user.getSession((error, session) => {\n      if (error || !session) {\n        resolve(null);\n        return;\n      }\n      resolve(session);\n    });\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signOutUserPool", "name": "signOutUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function signOutUserPool(config) {\n  const user = getCurrentUser(config);\n  user?.signOut();\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::sessionToTokens", "name": "sessionToTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function sessionToTokens(session) {\n  if (!session) return null;\n  const idToken = session.getIdToken().getJwtToken();\n  const accessToken = session.getAccessToken().getJwtToken();\n  const expiresAt = session.getIdToken().getExpiration() * 1000;\n  return {\n    idToken,\n    accessToken,\n    tokenType: \"Bearer\",\n    expiresAt,\n  };\n}", "parameters": [{"name": "session", "type": "any", "optional": false}], "returnType": "{ idToken: any; accessToken: any; tokenType: string; expiresAt: number; }"}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::exportIndexedDbToS3", "name": "exportIndexedDbToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function exportIndexedDbToS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/export] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Enumerating databases...\");\n  const dbList = await indexedDB.databases();\n  if (!dbList || dbList.length === 0) {\n    throw new Error(\"No IndexedDB databases found\");\n  }\n\n  const snapshot = {\n    format: \"canonry-indexeddb-snapshot\",\n    version: 1,\n    exportedAt: new Date().toISOString(),\n    databases: {},\n  };\n\n  for (let i = 0; i < dbList.length; i++) {\n    const { name, version } = dbList[i];\n    if (!name) continue;\n    report(`Exporting ${name} v${version} (${i + 1}/${dbList.length})...`);\n\n    const dbSnapshot = await exportSingleDatabase(name, version);\n    if (dbSnapshot) {\n      snapshot.databases[name] = dbSnapshot;\n    }\n  }\n\n  report(\"Uploading to S3...\");\n  const body = JSON.stringify(snapshot);\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n\n  const sizeMb = (body.length / (1024 * 1024)).toFixed(1);\n  const dbCount = Object.keys(snapshot.databases).length;\n  const storeCount = Object.values(snapshot.databases).reduce(\n    (sum, db) => sum + Object.keys(db.stores).length,\n    0\n  );\n\n  console.log(`[snapshot/export] Done: ${dbCount} databases, ${storeCount} stores, ${sizeMb} MB`);\n\n  return {\n    size: body.length,\n    sizeMb,\n    dbCount,\n    storeCount,\n    key,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ size: number; sizeMb: string; dbCount: number; storeCount: any; key: string; }>"}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::importIndexedDbFromS3", "name": "importIndexedDbFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function importIndexedDbFromS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/import] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Downloading snapshot from S3...\");\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n  const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n  const text = await readS3BodyAsText(response.Body);\n  if (!text) throw new Error(\"Empty snapshot file\");\n\n  report(`Parsing snapshot (${(text.length / (1024 * 1024)).toFixed(1)} MB)...`);\n  const snapshot = JSON.parse(text);\n  if (snapshot.format !== \"canonry-indexeddb-snapshot\") {\n    throw new Error(`Unknown snapshot format: ${snapshot.format}`);\n  }\n\n  const existingDbs = await getExistingDatabases();\n  const dbNames = Object.keys(snapshot.databases);\n  console.log(\n    `[snapshot/import] Snapshot from ${snapshot.exportedAt}, ${dbNames.length} databases: [${dbNames.join(\", \")}]. Local: [${Array.from(existingDbs.keys()).join(\", \")}]`\n  );\n\n  const warnings = [];\n  let totalStoresRestored = 0;\n  let totalRecordsWritten = 0;\n\n  for (let i = 0; i < dbNames.length; i++) {\n    const name = dbNames[i];\n    const dbSnapshot = snapshot.databases[name];\n    const snapshotStoreNames = Object.keys(dbSnapshot.stores);\n\n    report(\n      `Restoring ${name} v${dbSnapshot.version} (${i + 1}/${dbNames.length}) \u2014 ${snapshotStoreNames.length} stores [${snapshotStoreNames.join(\", \")}]`\n    );\n\n    let db;\n    try {\n      db = await openDatabaseForImport(name, dbSnapshot, existingDbs);\n    } catch (err) {\n      const msg = `Failed to open \"${name}\" for import: ${err.message}`;\n      console.error(`[snapshot/import] ${msg}`);\n      warnings.push(msg);\n      continue;\n    }\n\n    const { storesRestored, recordsWritten } = await restoreStoresFromSnapshot(\n      db, name, dbSnapshot, warnings\n    );\n    totalStoresRestored += storesRestored;\n    totalRecordsWritten += recordsWritten;\n\n    db.close();\n    console.log(`[snapshot/import] \"${name}\" done`);\n  }\n\n  console.log(\n    `[snapshot/import] Import complete: ${totalStoresRestored} stores, ${totalRecordsWritten} records`\n  );\n  if (warnings.length) {\n    console.warn(`[snapshot/import] Warnings (${warnings.length}):`, warnings);\n  }\n\n  return {\n    exportedAt: snapshot.exportedAt,\n    dbCount: dbNames.length,\n    storeCount: totalStoresRestored,\n    recordCount: totalRecordsWritten,\n    warnings,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ exportedAt: any; dbCount: number; storeCount: number; recordCount: number; warnings: string[]; }>"}, {"id": "apps/canonry/webui/src/aws/s3ImagePull.js::pullImagesFromS3", "name": "pullImagesFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/s3ImagePull.js", "sourceCode": "export async function pullImagesFromS3({ s3, config, projectId, onProgress }) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[s3-pull] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  // 1. Load manifest (read-only \u2014 never written back)\n  report(\"Loading image manifest from S3...\");\n  const manifest = await loadImageManifest(s3, { bucket, basePrefix });\n  if (!manifest || !manifest.images) {\n    throw new Error('No image manifest found in S3. Push images first with \"Sync Images to S3\".');\n  }\n\n  const allEntries = Object.values(manifest.images);\n  // Filter to requested project if provided\n  const entries = projectId ? allEntries.filter((e) => e.projectId === projectId) : allEntries;\n\n  const projectScope = projectId ? ` for project ${projectId}` : \" (all projects)\";\n  report(\n    `Manifest has ${entries.length} images${projectScope}. Checking local state...`\n  );\n\n  // 2. Check what exists locally\n  const db = await openIlluminatorDb();\n  let localBlobIds;\n  let localImageIds;\n  try {\n    localBlobIds = await getLocalBlobIds(db);\n    localImageIds = await getLocalImageIds(db);\n  } catch (err) {\n    db.close();\n    throw err;\n  }\n\n  // 3. Compute what needs downloading\n  const missing = entries.filter((e) => !localBlobIds.has(e.imageId));\n  const total = entries.length;\n  const skippedCount = total - missing.length;\n\n  report(`${missing.length} to download, ${skippedCount} already local`);\n\n  if (missing.length === 0) {\n    db.close();\n    return { total, downloaded: 0, skipped: skippedCount, errors: 0 };\n  }\n\n  // 4. Download incrementally\n  let downloaded = 0;\n  let errors = 0;\n  const logInterval = Math.max(1, Math.floor(missing.length / 5));\n\n  for (let i = 0; i < missing.length; i++) {\n    const entry = missing[i];\n\n    if (i % logInterval === 0) {\n      report(`Downloading ${i + 1}/${missing.length}...`);\n    }\n\n    try {\n      const response = await s3.send(\n        new GetObjectCommand({\n          Bucket: bucket,\n          Key: entry.rawKey,\n        })\n      );\n\n      const blob = await readBodyAsBlob(response.Body, entry.mimeType);\n\n      // Write blob, and metadata if missing locally\n      const needsMetadata = !localImageIds.has(entry.imageId);\n      const metadata = needsMetadata ? manifestEntryToMetadata(entry) : null;\n\n      await writeImageToDb(db, entry.imageId, blob, metadata);\n      downloaded++;\n    } catch (err) {\n      errors++;\n      console.error(\n        `[s3-pull] Failed to download \"${entry.imageId}\" (key=${entry.rawKey}):`,\n        err.message\n      );\n    }\n  }\n\n  db.close();\n\n  const summary = `Done: ${downloaded} downloaded, ${skippedCount} already local, ${errors} errors`;\n  report(summary);\n\n  return { total, downloaded, skipped: skippedCount, errors };\n}", "parameters": [{"name": "{ s3, config, projectId, onProgress }", "type": "{ s3: any; config: any; projectId: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: number; downloaded: number; skipped: number; errors: number; }>"}, {"id": "apps/canonry/webui/src/components/HelpModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/HelpModal.jsx", "sourceCode": "export default function HelpModal({ isOpen, onClose, activeTab }) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const content = HELP_CONTENT[activeTab] || HELP_CONTENT.enumerist;\n\n  return (\n    <div\n      className=\"modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"modal help-modal\">\n        <div className=\"modal-header\">\n          <div className=\"modal-title hm-title-colored\" style={{ '--hm-title-color': content.color }}>\n            {content.title}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n        <div className=\"modal-body modal-body-single\">\n          {/* Description */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">What is this?</h3>\n            <p className=\"help-text\">{content.description}</p>\n          </div>\n\n          {/* Workflow */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">Workflow</h3>\n            {content.workflow.map((step, index) => (\n              <div key={index} className=\"workflow-step\">\n                <div className=\"workflow-step-header\">\n                  <div className=\"workflow-step-number hm-step-number-colored\" style={{ '--hm-step-bg': content.color }}>\n                    {index + 1}\n                  </div>\n                  <div className=\"workflow-step-title\">{step.title}</div>\n                </div>\n                <p className=\"workflow-step-desc\">{step.desc}</p>\n                <ul className=\"workflow-step-list\">\n                  {step.items.map((item, i) => (\n                    <li key={i}>{item}</li>\n                  ))}\n                </ul>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, activeTab }", "type": "{ isOpen: any; onClose: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/LandingPage.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/LandingPage.jsx", "sourceCode": "export default function LandingPage({ onNavigate, hasProject }) {\n  return (\n    <div className=\"lp-container\">\n      {/* Hero Section */}\n      <div className=\"lp-hero\">\n        <h1 className=\"lp-title\">Welcome to The Canonry</h1>\n        <p className=\"lp-subtitle\">\n          A unified suite for procedural world-building. Define your schema, configure naming\n          systems, place entities on semantic planes, and generate interconnected histories.\n        </p>\n        <p className=\"lp-tagline\">Yes, this is probably overkill. No, we&apos;re not sorry.</p>\n      </div>\n\n      {/* App Cards */}\n      <div className=\"lp-cards-grid\">\n        {APP_CARDS.map((app) => (\n          <AppCard key={app.id} app={app} onNavigate={onNavigate} hasProject={hasProject} />\n        ))}\n      </div>\n\n      {/* Footer */}\n      <div className=\"lp-footer\">\n        <h2 className=\"lp-footer-title\">Get Started</h2>\n        <p className=\"lp-footer-text\">\n          {hasProject\n            ? \"Click on any card above to start working with your project.\"\n            : \"Create a new project or open an existing one using the project selector above.\"}\n        </p>\n        <p className=\"lp-footer-hint\">\n          Projects are stored locally in your browser. Use Export to create backups.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onNavigate, hasProject }", "type": "{ onNavigate: any; hasProject: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/Navigation.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/Navigation.jsx", "sourceCode": "export default function Navigation({ activeTab, onTabChange, onHelpClick, onAwsClick }) {\n  const getTabClassName = (tab) => {\n    if (!tab.enabled) {\n      return \"nav-tab nav-tab-disabled\";\n    }\n    if (tab.id === activeTab) {\n      return \"nav-tab nav-tab-active\";\n    }\n    return \"nav-tab nav-tab-inactive\";\n  };\n\n  const getTabDynamicStyle = (tab) => {\n    if (tab.id === activeTab && tab.enabled) {\n      return {\n        '--nav-tab-bg': getAccentGradient(tab.id),\n        '--nav-tab-color': colors.bgSidebar,\n      };\n    }\n    return undefined;\n  };\n\n  return (\n    <nav className=\"nav-bar\">\n      <div className=\"nav-tabs-container\">\n        {TABS.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => tab.enabled && onTabChange(tab.id)}\n            className={getTabClassName(tab)}\n            style={getTabDynamicStyle(tab)}\n            disabled={!tab.enabled}\n            onMouseEnter={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = getHoverBg(tab.id);\n                e.target.style.color = getAccentColor(tab.id);\n              }\n            }}\n            onMouseLeave={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = \"transparent\";\n                e.target.style.color = colors.textSecondary;\n              }\n            }}\n          >\n            {tab.label}\n            {tab.badge && <span className=\"nav-badge\">{tab.badge}</span>}\n          </button>\n        ))}\n      </div>\n      <button\n        className=\"nav-help-button\"\n        onClick={onAwsClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"AWS & S3 Sync\"\n      >\n        AWS\n      </button>\n      <button\n        className=\"nav-help-button\"\n        onClick={onHelpClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"Help & Workflow Guide\"\n      >\n        ? Help\n      </button>\n    </nav>\n  );\n}", "parameters": [{"name": "{ activeTab, onTabChange, onHelpClick, onAwsClick }", "type": "{ activeTab: any; onTabChange: any; onHelpClick: any; onAwsClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/ProjectManager.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ProjectManager.jsx", "sourceCode": "export default function ProjectManager({\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [showNewModal, setShowNewModal] = useState(false);\n  const [newProjectName, setNewProjectName] = useState(\"\");\n  const dropdownRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowNewModal(false);\n    }\n  }, []);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  const handleCreate = () => {\n    if (newProjectName.trim()) {\n      onCreateProject(newProjectName.trim());\n      setNewProjectName(\"\");\n      setShowNewModal(false);\n      setShowDropdown(false);\n    }\n  };\n\n  const handleImport = async (e) => {\n    const file = e.target.files?.[0];\n    if (!file) return;\n\n    try {\n      // Require zip file imports\n      if (!file.name.endsWith(\".zip\") && file.type !== \"application/zip\") {\n        throw new Error(\"Unsupported file type. Import requires a .zip project export.\");\n      }\n      await onImportProject(file);\n      setShowDropdown(false);\n    } catch (err) {\n      alert(\"Failed to import: \" + err.message);\n    }\n    e.target.value = \"\";\n  };\n\n  const handleExport = async () => {\n    try {\n      const zipBlob = await onExportProject();\n      if (!zipBlob) return;\n\n      const url = URL.createObjectURL(zipBlob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${currentProject?.name || \"world\"}.canonry.zip`;\n      a.click();\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      alert(\"Failed to export: \" + err.message);\n    }\n  };\n\n  const formatDate = (dateString) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <header className=\"app-header\">\n      <div className=\"app-header-left\">\n        <div className=\"app-logo\" onClick={onGoHome} title=\"Go to home\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onGoHome(e); }} >\n          The Canonry\n        </div>\n\n        <div className=\"project-selector\" ref={dropdownRef}>\n          <button\n            className=\"project-selector-trigger\"\n            onClick={() => setShowDropdown(!showDropdown)}\n          >\n            <span className=\"project-selector-name\">\n              {currentProject?.name || \"Select Project\"}\n            </span>\n            <span className=\"project-selector-chevron\">{showDropdown ? \"\u25b2\" : \"\u25bc\"}</span>\n          </button>\n\n          {showDropdown && (\n            <div className=\"project-dropdown\">\n              <div className=\"project-dropdown-header\">\n                <span className=\"project-dropdown-title\">Projects</span>\n                <div className=\"project-dropdown-actions\">\n                  <button\n                    className=\"btn-sm btn-sm-primary\"\n                    onClick={() => {\n                      setShowDropdown(false);\n                      setShowNewModal(true);\n                    }}\n                  >\n                    + New\n                  </button>\n                  <button className=\"btn-sm\" onClick={() => fileInputRef.current?.click()}>\n                    Import\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"project-list\">\n                {projects.length === 0 ? (\n                  <div className=\"empty-state-compact\">\n                    No projects yet. Create one to get started!\n                  </div>\n                ) : (\n                  projects.map((project) => (\n                    <div\n                      key={project.id}\n                      className={[\"project-item\", currentProject?.id === project.id ? \"project-item-active\" : \"\"].join(\" \").trim()}\n                      onClick={() => {\n                        onOpenProject(project.id);\n                        setShowDropdown(false);\n                      }}\n                      onMouseEnter={() => setHoveredProject(project.id)}\n                      onMouseLeave={() => setHoveredProject(null)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <div className=\"project-item-name\">{project.name}</div>\n                      <div className=\"project-item-meta\">\n                        <span>{project.entityCount} entities</span>\n                        <span>{project.cultureCount} cultures</span>\n                        <span>{formatDate(project.updatedAt)}</span>\n                      </div>\n                      <div className=\"project-item-actions\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                        {project.id === defaultProjectId && onReloadFromDefaults && (\n                          <button\n                            className=\"btn-xs\"\n                            onClick={async () => {\n                              if (\n                                confirm(\n                                  \"Reload project from defaults? This will overwrite your configuration changes but preserve world data.\"\n                                )\n                              ) {\n                                try {\n                                  await onReloadFromDefaults();\n                                  setShowDropdown(false);\n                                } catch (err) {\n                                  alert(\"Failed to reload: \" + err.message);\n                                }\n                              }\n                            }}\n                          >\n                            Reload Defaults\n                          </button>\n                        )}\n                        <button className=\"btn-xs\" onClick={() => onDuplicateProject(project.id)}>\n                          Duplicate\n                        </button>\n                        <button\n                          className=\"btn-xs btn-xs-danger\"\n                          onClick={() => {\n                            if (confirm(`Delete \"${project.name}\"?`)) {\n                              onDeleteProject(project.id);\n                            }\n                          }}\n                        >\n                          Delete\n                        </button>\n                      </div>\n                    </div>\n                  ))\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        {currentProject && onLoadSlot && (\n          <SlotSelector\n            slots={slots}\n            activeSlotIndex={activeSlotIndex}\n            onLoadSlot={onLoadSlot}\n            onSaveToSlot={onSaveToSlot}\n            onClearSlot={onClearSlot}\n            onUpdateTitle={onUpdateSlotTitle}\n            onExportSlot={onExportSlot}\n            onImportSlot={onImportSlot}\n            onLoadExampleOutput={onLoadExampleOutput}\n            hasDataInScratch={hasDataInScratch}\n          />\n        )}\n      </div>\n\n      <div className=\"app-header-right\">\n        {currentProject && <TracePopover simulationState={simulationState} systems={systems} />}\n        {currentProject && (\n          <ValidationPopover\n            validationResult={validationResult}\n            onNavigateToValidation={onNavigateToValidation}\n            onRemoveProperty={onRemoveProperty}\n          />\n        )}\n        <button className=\"btn btn-secondary\" onClick={handleExport} disabled={!currentProject}>\n          Export\n        </button>\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\".zip\"\n          className=\"pm-hidden-input\"\n          onChange={handleImport}\n        />\n      </div>\n\n      {showNewModal && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal modal-simple\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Create New Project</div>\n              <button className=\"btn-close\" onClick={() => setShowNewModal(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"modal-body\">\n              {/* eslint-disable-next-line jsx-a11y/no-autofocus -- intentional UX: modal input should auto-focus */}\n              <input\n                className=\"input\"\n                type=\"text\"\n                placeholder=\"Project name...\"\n                value={newProjectName}\n                onChange={(e) => setNewProjectName(e.target.value)}\n                onKeyDown={(e) => e.key === \"Enter\" && handleCreate()}\n                autoFocus\n              />\n              <div className=\"modal-actions\">\n                <button className=\"btn btn-secondary\" onClick={() => setShowNewModal(false)}>\n                  Cancel\n                </button>\n                <button className=\"btn btn-primary\" onClick={handleCreate}>\n                  Create\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </header>\n  );\n}", "parameters": [{"name": "{\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}", "type": "{ projects: any; currentProject: any; onCreateProject: any; onOpenProject: any; onDeleteProject: any; onDuplicateProject: any; onExportProject: any; onImportProject: any; onReloadFromDefaults: any; defaultProjectId: any; onGoHome: any; validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; simulationState: any; systems?: any[]; slots?: Readonly<{}>; activeSlotIndex?: number; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateSlotTitle: any; onExportSlot: any; on...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SlotSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SlotSelector.jsx", "sourceCode": "export default function SlotSelector({\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [editingSlot, setEditingSlot] = useState(null);\n  const [editValue, setEditValue] = useState(\"\");\n  const [importTargetSlot, setImportTargetSlot] = useState(null);\n  const dropdownRef = useRef(null);\n  const inputRef = useRef(null);\n  const fileInputRef = useRef(null);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n        setEditingSlot(null);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  // Focus input when editing starts\n  useEffect(() => {\n    if (editingSlot !== null && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [editingSlot]);\n\n  const handleStartEdit = useCallback((slotIndex, currentTitle, e) => {\n    e.stopPropagation();\n    setEditingSlot(slotIndex);\n    setEditValue(currentTitle || \"\");\n  }, []);\n\n  const handleSaveEdit = useCallback(() => {\n    if (editingSlot !== null && editValue.trim()) {\n      onUpdateTitle(editingSlot, editValue.trim());\n    }\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, [editingSlot, editValue, onUpdateTitle]);\n\n  const handleCancelEdit = useCallback(() => {\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Enter\") {\n        handleSaveEdit();\n      } else if (e.key === \"Escape\") {\n        handleCancelEdit();\n      }\n    },\n    [handleSaveEdit, handleCancelEdit]\n  );\n\n  const handleImportRequest = useCallback(\n    (slotIndex) => {\n      if (!onImportSlot) return;\n      const slot = slots[slotIndex];\n      const slotTitle = slot?.title || (slotIndex === 0 ? \"Scratch\" : `Slot ${slotIndex}`);\n      if (slot && !window.confirm(`Overwrite \"${slotTitle}\" with imported data?`)) {\n        return;\n      }\n      setImportTargetSlot(slotIndex);\n      fileInputRef.current?.click();\n    },\n    [onImportSlot, slots]\n  );\n\n  const handleImportFile = useCallback(\n    (e) => {\n      const file = e.target.files?.[0];\n      if (!file || importTargetSlot === null || !onImportSlot) {\n        e.target.value = \"\";\n        return;\n      }\n      onImportSlot(importTargetSlot, file);\n      setImportTargetSlot(null);\n      setShowDropdown(false);\n      e.target.value = \"\";\n    },\n    [importTargetSlot, onImportSlot]\n  );\n\n  // Get active slot data for display\n  const activeSlot = slots[activeSlotIndex];\n  const activeTitle =\n    activeSlotIndex === 0\n      ? activeSlot?.title || \"Scratch\"\n      : activeSlot?.title || `Slot ${activeSlotIndex}`;\n\n  // Determine which slots to show:\n  // - Always show slot 0 (scratch)\n  // - Show filled save slots\n  // - Show next empty slot if scratch has data\n  const visibleSlots = [0]; // Always show scratch\n  let nextEmptySlot = null;\n\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (slots[i]) {\n      visibleSlots.push(i);\n    } else if (nextEmptySlot === null) {\n      nextEmptySlot = i;\n    }\n  }\n\n  // Add next empty slot if scratch has data\n  if (hasDataInScratch && nextEmptySlot !== null) {\n    visibleSlots.push(nextEmptySlot);\n  }\n\n  return (\n    <div className=\"slot-selector\" ref={dropdownRef}>\n      <button className=\"slot-selector-trigger\" onClick={() => setShowDropdown(!showDropdown)}>\n        <span className=\"slot-selector-name\">{activeTitle}</span>\n        <span className=\"slot-selector-chevron\">{showDropdown ? \"\\u25B2\" : \"\\u25BC\"}</span>\n      </button>\n\n      {showDropdown && (\n        <div className=\"slot-dropdown\">\n          <div className=\"slot-dropdown-header\">\n            <span className=\"slot-dropdown-title\">Run Slots</span>\n          </div>\n\n          <div className=\"slot-list\">\n            {visibleSlots.map((slotIndex) => (\n              <SlotItem\n                key={slotIndex}\n                slotIndex={slotIndex}\n                slot={slots[slotIndex]}\n                isActive={slotIndex === activeSlotIndex}\n                editingSlot={editingSlot}\n                editValue={editValue}\n                setEditValue={setEditValue}\n                inputRef={inputRef}\n                handleKeyDown={handleKeyDown}\n                handleSaveEdit={handleSaveEdit}\n                handleStartEdit={handleStartEdit}\n                canExport={Boolean(onExportSlot && slots[slotIndex])}\n                canImport={Boolean(onImportSlot)}\n                hasDataInScratch={hasDataInScratch}\n                activeSlotIndex={activeSlotIndex}\n                onLoadSlot={onLoadSlot}\n                onSaveToSlot={onSaveToSlot}\n                onClearSlot={onClearSlot}\n                onExportSlot={onExportSlot}\n                handleImportRequest={handleImportRequest}\n                setShowDropdown={setShowDropdown}\n              />\n            ))}\n\n            {visibleSlots.length === 1 && !hasDataInScratch && (\n              <div className=\"slot-empty-hint\">\n                Run a simulation to create data, then save to a slot.\n              </div>\n            )}\n\n            {onLoadExampleOutput && (\n              <div className=\"slot-item slot-item-empty\">\n                <div className=\"slot-item-content\">\n                  <div className=\"slot-item-name\">Example Output</div>\n                  <div className=\"slot-item-meta\">Load a sample Lore Weave run.</div>\n                </div>\n                <div className=\"slot-item-actions\">\n                  <button\n                    className=\"btn-xs\"\n                    onClick={() => {\n                      if (\n                        hasDataInScratch &&\n                        !window.confirm(\"Overwrite scratch with the example output?\")\n                      ) {\n                        return;\n                      }\n                      onLoadExampleOutput();\n                      setShowDropdown(false);\n                    }}\n                  >\n                    Load\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\".json,.zip,application/json,application/zip\"\n        className=\"ss-hidden-input\"\n        onChange={handleImportFile}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}", "type": "{ slots: any; activeSlotIndex: any; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateTitle: any; onExportSlot: any; onImportSlot: any; onLoadExampleOutput: any; hasDataInScratch: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/TracePopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/TracePopover.jsx", "sourceCode": "export default function TracePopover({ simulationState }) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // Extract data from simulation state\n  const hasData = simulationState?.pressureUpdates?.length > 0;\n  const tickCount = simulationState?.pressureUpdates?.length || 0;\n  const templateCount = simulationState?.templateApplications?.length || 0;\n  const actionCount = simulationState?.actionApplications?.length || 0;\n  const eraTransitions = (simulationState?.systemActions || []).filter(\n    (a) => a.details?.eraTransition\n  ).length;\n\n  // Button label\n  const buttonLabel = useMemo(() => {\n    if (!hasData) return \"No trace\";\n    return `${tickCount} ticks`;\n  }, [hasData, tickCount]);\n\n  // Button class\n  const buttonClassName = useMemo(() => {\n    if (!hasData) {\n      return \"tp-button tp-button-disabled\";\n    }\n    return \"tp-button tp-button-active\";\n  }, [hasData]);\n\n  const loadingFallback = useMemo(\n    () => <div className=\"tp-loading-overlay\">Loading trace visualization...</div>,\n    []\n  );\n\n  const handleOpen = () => {\n    if (hasData) {\n      setIsOpen(true);\n    }\n  };\n  const handleClose = useCallback(() => setIsOpen(false), []);\n\n  return (\n    <>\n      <button\n        className={buttonClassName}\n        onClick={handleOpen}\n        disabled={!hasData}\n        title={\n          hasData\n            ? `View simulation trace: ${tickCount} ticks, ${templateCount} templates, ${actionCount} actions, ${eraTransitions} era transitions`\n            : \"Run a simulation to see trace data\"\n        }\n      >\n        <span className=\"tp-tilde\">~</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && hasData && (\n        <Suspense fallback={loadingFallback}>\n          <SimulationTraceVisx\n            pressureUpdates={simulationState.pressureUpdates}\n            epochStats={simulationState.epochStats}\n            templateApplications={simulationState.templateApplications}\n            actionApplications={simulationState.actionApplications}\n            systemActions={simulationState.systemActions}\n            onClose={handleClose}\n          />\n        </Suspense>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ simulationState }", "type": "{ simulationState: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/ValidationPopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ValidationPopover.jsx", "sourceCode": "export default function ValidationPopover({\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const popoverRef = useRef(null);\n\n  const { valid, errors, warnings } = validationResult || { valid: true, errors: [], warnings: [] };\n  const totalIssues = errors.length + warnings.length;\n\n  // Determine button class\n  const buttonClassName = useMemo(() => {\n    if (errors.length > 0) return \"vp-button vp-button-error\";\n    if (warnings.length > 0) return \"vp-button vp-button-warning\";\n    return \"vp-button vp-button-valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get button label\n  const buttonLabel = useMemo(() => {\n    if (errors.length > 0) return `${errors.length} error${errors.length !== 1 ? \"s\" : \"\"}`;\n    if (warnings.length > 0) return `${warnings.length} warning${warnings.length !== 1 ? \"s\" : \"\"}`;\n    return \"Valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get icon\n  const icon = useMemo(() => {\n    if (errors.length > 0) return \"\u2717\";\n    if (warnings.length > 0) return \"\u26a0\";\n    return \"\u2713\";\n  }, [errors.length, warnings.length]);\n\n  // Combined and limited list\n  const displayItems = useMemo(() => {\n    const items = [\n      ...errors.map((e) => ({ ...e, isWarning: false })),\n      ...warnings.map((w) => ({ ...w, isWarning: true })),\n    ];\n    return items.slice(0, MAX_ERRORS_SHOWN);\n  }, [errors, warnings]);\n\n  const remainingCount = totalIssues - displayItems.length;\n\n  const handleNavigate = () => {\n    setIsOpen(false);\n    onNavigateToValidation?.();\n  };\n\n  return (\n    <div className=\"vp-container\">\n      <button\n        className={buttonClassName}\n        onClick={() => setIsOpen(!isOpen)}\n        title={valid ? \"Configuration is valid\" : \"Click to see validation issues\"}\n      >\n        <span>{icon}</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && (\n        <div className=\"vp-popover\" ref={popoverRef}>\n          <div className=\"vp-popover-header\">\n            <span className=\"vp-popover-title\">Structure Validation</span>\n            <button className=\"vp-close-button\" onClick={() => setIsOpen(false)}>\n              \u00d7\n            </button>\n          </div>\n\n          <div className=\"vp-popover-body\">\n            {valid && warnings.length === 0 ? (\n              <div className=\"vp-valid-message\">\n                <span>\u2713</span>\n                <span>All configuration files are valid</span>\n              </div>\n            ) : (\n              <div className=\"vp-error-list\">\n                {displayItems.map((item, i) => (\n                  <ErrorCard\n                    key={i}\n                    error={item}\n                    isWarning={item.isWarning}\n                    onRemoveProperty={onRemoveProperty}\n                  />\n                ))}\n              </div>\n            )}\n          </div>\n\n          {remainingCount > 0 && (\n            <div className=\"vp-more-count\">\n              +{remainingCount} more issue{remainingCount !== 1 ? \"s\" : \"\"}.{\" \"}\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View all in Validation tab\n              </span>\n            </div>\n          )}\n\n          {totalIssues > 0 && remainingCount === 0 && onNavigateToValidation && (\n            <div className=\"vp-more-count\">\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View full details in Validation tab\n              </span>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}", "type": "{ validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/lib/illuminatorDbReader.js::openIlluminatorDb", "name": "openIlluminatorDb", "kind": "function", "filePath": "apps/canonry/webui/src/lib/illuminatorDbReader.js", "sourceCode": "export function openIlluminatorDb() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME);\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // If another connection triggers a version upgrade while we're\n      // still open, close immediately so we don't block it.\n      db.onversionchange = () => {\n        db.close();\n      };\n\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(request.error || new Error('Failed to open illuminator DB'));\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImagesByProject", "name": "getImagesByProject", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get all image metadata records for a project (no blobs).\n */\nexport async function getImagesByProject(projectId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const store = tx.objectStore('images');\n      const index = store.index('projectId');\n      const request = index.getAll(projectId);\n      request.onsuccess = () => resolve(request.result || []);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageMetadata", "name": "getImageMetadata", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get a single image metadata record by imageId (no blob).\n */\nexport async function getImageMetadata(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const request = tx.objectStore('images').get(imageId);\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get the raw blob for an image by imageId.\n */\nexport async function getImageBlob(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('imageBlobs', 'readonly');\n      const request = tx.objectStore('imageBlobs').get(imageId);\n      request.onsuccess = () => resolve(request.result?.blob || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/remotes/ArchivistHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ArchivistHost.jsx", "sourceCode": "export default function ArchivistHost({\n  projectId,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Archivist encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ArchivistRemote projectId={projectId} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex\n}", "type": "{ projectId: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx", "sourceCode": "export default function ChroniclerHost({\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Chronicler encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ChroniclerRemote projectId={projectId} activeSlotIndex={activeSlotIndex} requestedPageId={requestedPageId} onRequestedPageConsumed={onRequestedPageConsumed} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}", "type": "{ projectId: any; activeSlotIndex: any; requestedPageId: any; onRequestedPageConsumed: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx", "sourceCode": "export default function CoherenceEngineHost({\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Coherence Engine encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CoherenceEngineRemote projectId={projectId} schema={schema} eras={eras} onErasChange={onErasChange} pressures={pressures} onPressuresChange={onPressuresChange} generators={generators} onGeneratorsChange={onGeneratorsChange} actions={actions} onActionsChange={onActionsChange} systems={systems} onSystemsChange={onSystemsChange} activeSection={activeSection} onSectionChange={onSectionChange} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}", "type": "{ projectId: any; schema: any; eras: any; onErasChange: any; pressures: any; onPressuresChange: any; generators: any; onGeneratorsChange: any; actions: any; onActionsChange: any; systems: any; onSystemsChange: any; activeSection: any; onSectionChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/CosmographerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CosmographerHost.jsx", "sourceCode": "export default function CosmographerHost({\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Cosmographer encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CosmographerRemote schema={schema} axisDefinitions={axisDefinitions} seedEntities={seedEntities} seedRelationships={seedRelationships} onEntityKindsChange={onEntityKindsChange} onCulturesChange={onCulturesChange} onAxisDefinitionsChange={onAxisDefinitionsChange} onTagRegistryChange={onTagRegistryChange} onSeedEntitiesChange={onSeedEntitiesChange} onSeedRelationshipsChange={onSeedRelationshipsChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} schemaUsage={schemaUsage} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}", "type": "{ schema: any; axisDefinitions: any; seedEntities: any; seedRelationships: any; onEntityKindsChange: any; onCulturesChange: any; onAxisDefinitionsChange: any; onTagRegistryChange: any; onSeedEntitiesChange: any; onSeedRelationshipsChange: any; onAddTag: any; activeSection: any; onSectionChange: any; schemaUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx", "sourceCode": "export default function IlluminatorHost({\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Illuminator encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <IlluminatorRemote projectId={projectId} schema={schema} worldData={worldData} worldContext={worldContext} onWorldContextChange={onWorldContextChange} entityGuidance={entityGuidance} onEntityGuidanceChange={onEntityGuidanceChange} cultureIdentities={cultureIdentities} onCultureIdentitiesChange={onCultureIdentitiesChange} enrichmentConfig={enrichmentConfig} onEnrichmentConfigChange={onEnrichmentConfigChange} styleSelection={styleSelection} onStyleSelectionChange={onStyleSelectionChange} historianConfig={historianConfig} onHistorianConfigChange={onHistorianConfigChange} activeSection={activeSection} onSectionChange={onSectionChange} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; styleSelection: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx", "sourceCode": "export default function LoreWeaveHost({\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Lore Weave encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <LoreWeaveRemote projectId={projectId} schema={schema} eras={eras} pressures={pressures} generators={generators} systems={systems} actions={actions} seedEntities={seedEntities} seedRelationships={seedRelationships} distributionTargets={distributionTargets} onDistributionTargetsChange={onDistributionTargetsChange} activeSection={activeSection} onSectionChange={onSectionChange} simulationResults={simulationResults} onSimulationResultsChange={onSimulationResultsChange} simulationState={simulationState} onSimulationStateChange={onSimulationStateChange} onSearchRunScored={onSearchRunScored} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}", "type": "{ projectId: any; schema: any; eras: any; pressures: any; generators: any; systems: any; actions: any; seedEntities: any; seedRelationships: any; distributionTargets: any; onDistributionTargetsChange: any; activeSection: any; onSectionChange: any; simulationResults: any; onSimulationResultsChange: any; simulationState: any; onSimulationStateChange: any; onSearchRunScored: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/NameForgeHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/NameForgeHost.jsx", "sourceCode": "export default function NameForgeHost({\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Name Forge encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <NameForgeRemote projectId={projectId} schema={schema} onNamingDataChange={onNamingDataChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} generators={generators} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}", "type": "{ projectId: any; schema: any; onNamingDataChange: any; onAddTag: any; activeSection: any; onSectionChange: any; generators: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/RemotePlaceholder.jsx", "sourceCode": "export default function RemotePlaceholder({ name, instructions }) {\n  return (\n    <div className=\"rph-container\">\n      <div className=\"rph-icon\">\ud83d\udd0c</div>\n      <div className=\"rph-title\">{name} Not Connected</div>\n      <div className=\"rph-message\">\n        The {name} module is not currently running. Start it to enable this feature.\n      </div>\n      {instructions && <div className=\"rph-instructions\">{instructions}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{ name, instructions }", "type": "{ name: any; instructions: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForSimulation", "name": "getCompletedChroniclesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getCompletedChroniclesForProject", "name": "getCompletedChroniclesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getCompletedChroniclesForProject(projectId) {\n  if (!projectId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"projectId\");\n        const request = index.getAll(IDBKeyRange.only(projectId));\n\n        request.onsuccess = () => resolve(filterCompleted(request.result || []));\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::importChronicles", "name": "importChronicles", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "/**\n * Import chronicles into a project (overwrite-merge by chronicleId).\n *\n * @param {string} projectId\n * @param {Array} chronicles\n * @param {Object} options\n * @param {string} options.simulationRunId - Optional run ID to apply when missing\n */\nexport async function importChronicles(projectId, chronicles, options = {}) {\n  if (!projectId || !Array.isArray(chronicles) || chronicles.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  const { simulationRunId } = options;\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n\n      for (const chronicle of chronicles) {\n        if (!chronicle?.chronicleId) {\n          skipped += 1;\n          continue;\n        }\n        const record = {\n          ...chronicle,\n          projectId,\n          simulationRunId: chronicle.simulationRunId || simulationRunId || null,\n        };\n        const req = store.get(record.chronicleId);\n        req.onsuccess = () => {\n          if (req.result) overwritten += 1;\n          store.put(record);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "chronicles", "type": "any[]", "optional": false}, {"name": "options", "type": "{ simulationRunId: string; }", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/chronicleStorage.js::getChronicleCountForProject", "name": "getChronicleCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/chronicleStorage.js", "sourceCode": "export async function getChronicleCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(CHRONICLE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count chronicles\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::openDatabase", "name": "openDatabase", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Open (or reuse) the IndexedDB database.\n */\nexport async function openDatabase() {\n  if (dbInstance) return dbInstance;\n\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n\n    request.onsuccess = () => {\n      dbInstance = request.result;\n      resolve(dbInstance);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n        store.createIndex(\"name\", \"name\", { unique: false });\n        store.createIndex(\"updatedAt\", \"updatedAt\", { unique: false });\n      }\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::saveProject", "name": "saveProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Save a project to the database.\n */\nexport async function saveProject(project) {\n  const db = await openDatabase();\n  const timestamp = new Date().toISOString();\n\n  const projectToSave = {\n    ...project,\n    updatedAt: timestamp,\n    createdAt: project.createdAt || timestamp,\n  };\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put(projectToSave);\n\n    request.onsuccess = () => resolve(projectToSave);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "project", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::loadProject", "name": "loadProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Load a project by ID.\n */\nexport async function loadProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.get(id);\n\n    request.onsuccess = () => resolve(request.result || null);\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::deleteProject", "name": "deleteProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Delete a project by ID.\n */\nexport async function deleteProject(id) {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.delete(id);\n\n    request.onsuccess = () => resolve();\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [{"name": "id", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/db.js::listProjects", "name": "listProjects", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * List all projects (metadata only, sorted by recency).\n */\nexport async function listProjects() {\n  const db = await openDatabase();\n\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_NAME, \"readonly\");\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.getAll();\n\n    request.onsuccess = () => {\n      const projects = request.result.map((p) => ({\n        id: p.id,\n        name: p.name,\n        updatedAt: p.updatedAt,\n        entityCount: p.seedEntities?.length || 0,\n        cultureCount: p.cultures?.length || 0,\n      }));\n\n      // Sort by most recently updated\n      projects.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));\n      resolve(projects);\n    };\n\n    request.onerror = () => reject(request.error);\n  });\n}", "parameters": [], "returnType": "Promise<any>"}]