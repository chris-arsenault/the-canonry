[{"id": "apps/name-forge/lib/validation/index.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Estimate syllable count based on vowel groups\r\n */\r\nexport function estimateSyllableCount(name: string): number {\r\n  const vowelGroups = name.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(name: string): number {\r\n  if (name.length === 0) return 0;\r\n  const vowelCount = (name.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / name.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::countApostrophes", "name": "countApostrophes", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Count apostrophes in a name\r\n */\r\nexport function countApostrophes(name: string): number {\r\n  return (name.match(/'/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::countHyphens", "name": "countHyphens", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Count hyphens in a name\r\n */\r\nexport function countHyphens(name: string): number {\r\n  return (name.match(/-/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::extractBigrams", "name": "extractBigrams", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Extract character bigrams (2-character sequences)\r\n */\r\nexport function extractBigrams(name: string): Map<string, number> {\r\n  const bigrams = new Map<string, number>();\r\n  const normalized = name.toLowerCase();\r\n\r\n  for (let i = 0; i < normalized.length - 1; i++) {\r\n    const bigram = normalized.substring(i, i + 2);\r\n    bigrams.set(bigram, (bigrams.get(bigram) ?? 0) + 1);\r\n  }\r\n\r\n  return bigrams;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "Map<string, number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::getEnding", "name": "getEnding", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Get the ending (last 2 chars) of a name\r\n */\r\nexport function getEnding(name: string): string {\r\n  return name.length >= 2\r\n    ? name.substring(name.length - 2).toLowerCase()\r\n    : name.toLowerCase();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::featureVectorToArray", "name": "featureVectorToArray", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Convert a feature vector to a numeric array for ML\r\n * This flattens the structured features into a single vector\r\n */\r\nexport function featureVectorToArray(\r\n  fv: FeatureVector,\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  const features: number[] = [];\r\n\r\n  // Basic numeric features\r\n  features.push(fv.features.length);\r\n  features.push(fv.features.syllableCount);\r\n  features.push(fv.features.vowelRatio);\r\n  features.push(fv.features.apostropheCount);\r\n  features.push(fv.features.hyphenCount);\r\n\r\n  // Bigram features (one-hot-ish encoding)\r\n  for (const bigram of allBigrams) {\r\n    features.push(fv.features.bigrams[bigram] ?? 0);\r\n  }\r\n\r\n  // Ending feature (one-hot encoding)\r\n  const endingIndex = allEndings.indexOf(fv.features.ending);\r\n  for (let i = 0; i < allEndings.length; i++) {\r\n    features.push(i === endingIndex ? 1 : 0);\r\n  }\r\n\r\n  return features;\r\n}", "parameters": [{"name": "fv", "type": "FeatureVector", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::buildVocabulary", "name": "buildVocabulary", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Build vocabulary of all bigrams and endings from a set of feature vectors\r\n */\r\nexport function buildVocabulary(featureVectors: FeatureVector[]): {\r\n  bigrams: string[];\r\n  endings: string[];\r\n} {\r\n  const bigramSet = new Set<string>();\r\n  const endingSet = new Set<string>();\r\n\r\n  for (const fv of featureVectors) {\r\n    for (const bigram of Object.keys(fv.features.bigrams)) {\r\n      bigramSet.add(bigram);\r\n    }\r\n    endingSet.add(fv.features.ending);\r\n  }\r\n\r\n  return {\r\n    bigrams: Array.from(bigramSet).sort((a, b) => a.localeCompare(b)),\r\n    endings: Array.from(endingSet).sort((a, b) => a.localeCompare(b)),\r\n  };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}], "returnType": "{\r\n  bigrams: string[];\r\n  endings: string[];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate centroid (mean) of feature vectors\r\n */\r\nexport function calculateCentroid(\r\n  featureVectors: FeatureVector[],\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  if (featureVectors.length === 0) {\r\n    // Return zero vector\r\n    return new Array<number>(5 + allBigrams.length + allEndings.length).fill(0);\r\n  }\r\n\r\n  // Convert all to arrays\r\n  const arrays = featureVectors.map((fv) =>\r\n    featureVectorToArray(fv, allBigrams, allEndings)\r\n  );\r\n\r\n  // Calculate mean for each dimension\r\n  const dimensions = arrays[0].length;\r\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\r\n\r\n  for (const arr of arrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      centroid[i] += arr[i];\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < dimensions; i++) {\r\n    centroid[i] /= arrays.length;\r\n  }\r\n\r\n  return centroid;\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::normalizeFeatures", "name": "normalizeFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Normalize feature vectors to [0, 1] range\r\n * Helps with distance calculations and classification\r\n */\r\nexport function normalizeFeatures(\r\n  featureArrays: number[][]\r\n): {\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n} {\r\n  if (featureArrays.length === 0) {\r\n    return { normalized: [], min: [], max: [] };\r\n  }\r\n\r\n  const dimensions = featureArrays[0].length;\r\n  const min: number[] = new Array<number>(dimensions).fill(Infinity);\r\n  const max: number[] = new Array<number>(dimensions).fill(-Infinity);\r\n\r\n  // Find min/max for each dimension\r\n  for (const arr of featureArrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      min[i] = Math.min(min[i], arr[i]);\r\n      max[i] = Math.max(max[i], arr[i]);\r\n    }\r\n  }\r\n\r\n  // Normalize\r\n  const normalized = featureArrays.map((arr) => {\r\n    return arr.map((val, i) => {\r\n      const range = max[i] - min[i];\r\n      if (range === 0) return 0;\r\n      return (val - min[i]) / range;\r\n    });\r\n  });\r\n\r\n  return { normalized, min, max };\r\n}", "parameters": [{"name": "featureArrays", "type": "number[][]", "optional": false}], "returnType": "{\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::toShapeKey", "name": "toShapeKey", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Convert a name to a shape key for phonetic similarity detection\r\n * Collapses vowels to V, consonants to C, and removes repeated patterns\r\n *\r\n * Example: \"Aeltharion\" -> \"VCCCVCVC\"\r\n */\r\nexport function toShapeKey(name: string): string {\r\n  // Lowercase and remove non-alphabetic characters\r\n  let s = name.toLowerCase().replace(/[^a-z]/g, \"\");\r\n\r\n  // Replace vowels with V\r\n  s = s.replace(/[aeiou]+/g, \"V\");\r\n\r\n  // Replace consonants with C\r\n  s = s.replace(/[^V]+/g, \"C\");\r\n\r\n  // Collapse repeated patterns (optional - can make distance less sensitive)\r\n  // s = s.replace(/(.)\\1+/g, \"$1\");\r\n\r\n  return s;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::shapeDistance", "name": "shapeDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate shape distance between two names\r\n * Uses Levenshtein on shape keys\r\n */\r\nexport function shapeDistance(a: string, b: string): number {\r\n  const shapeA = toShapeKey(a);\r\n  const shapeB = toShapeKey(b);\r\n\r\n  return normalizedLevenshtein(shapeA, shapeB);\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::pairwiseDistances", "name": "pairwiseDistances", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate distance between all pairs in a list of names\r\n * Returns a matrix where matrix[i][j] is the distance from names[i] to names[j]\r\n */\r\nexport function pairwiseDistances(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): number[][] {\r\n  const n = names.length;\r\n  const matrix: number[][] = new Array<number[]>(n)\r\n    .fill([])\r\n    .map(() => new Array<number>(n).fill(0));\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = i + 1; j < n; j++) {\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      matrix[i][j] = dist;\r\n      matrix[j][i] = dist; // Symmetric\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "number[][]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::findNearestNeighbors", "name": "findNearestNeighbors", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Find the nearest neighbor for each name in a list\r\n * Returns array of {name, nearestName, distance}\r\n */\r\nexport function findNearestNeighbors(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): Array<{ name: string; nearestName: string; distance: number }> {\r\n  const results: Array<{ name: string; nearestName: string; distance: number }> =\r\n    [];\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    let minDistance = Infinity;\r\n    let nearestIndex = -1;\r\n\r\n    for (let j = 0; j < names.length; j++) {\r\n      if (i === j) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist < minDistance) {\r\n        minDistance = dist;\r\n        nearestIndex = j;\r\n      }\r\n    }\r\n\r\n    if (nearestIndex !== -1) {\r\n      results.push({\r\n        name: names[i],\r\n        nearestName: names[nearestIndex],\r\n        distance: minDistance,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "Array<{ name: string; nearestName: string; distance: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::calculatePercentiles", "name": "calculatePercentiles", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate percentile statistics from a list of distances\r\n */\r\nexport function calculatePercentiles(\r\n  values: number[]\r\n): {\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n} {\r\n  if (values.length === 0) {\r\n    return { min: 0, p1: 0, p5: 0, median: 0, p95: 0, p99: 0, max: 0, mean: 0 };\r\n  }\r\n\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const n = sorted.length;\r\n\r\n  const percentile = (p: number) => {\r\n    const index = Math.ceil((p / 100) * n) - 1;\r\n    return sorted[Math.max(0, Math.min(index, n - 1))];\r\n  };\r\n\r\n  const mean = values.reduce((sum, v) => sum + v, 0) / n;\r\n\r\n  return {\r\n    min: sorted[0],\r\n    p1: percentile(1),\r\n    p5: percentile(5),\r\n    median: percentile(50),\r\n    p95: percentile(95),\r\n    p99: percentile(99),\r\n    max: sorted[n - 1],\r\n    mean,\r\n  };\r\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}], "returnType": "{\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/index.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/validation/index.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/classifier.ts::crossValidate", "name": "crossValidate", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/classifier.ts", "sourceCode": "/**\r\n * Perform k-fold cross-validation on a classifier\r\n */\r\nexport function crossValidate(\r\n  featureVectors: FeatureVector[],\r\n  k: number = 5\r\n): {\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n} {\r\n  const n = featureVectors.length;\r\n  const foldSize = Math.floor(n / k);\r\n  const results: ClassificationResult[] = [];\r\n\r\n  // Initialize confusion matrix\r\n  const domains = new Set(featureVectors.map((fv) => fv.domainId));\r\n  const confusionMatrix = new Map<string, Map<string, number>>();\r\n  for (const domain of domains) {\r\n    confusionMatrix.set(domain, new Map());\r\n    for (const otherDomain of domains) {\r\n      confusionMatrix.get(domain)!.set(otherDomain, 0);\r\n    }\r\n  }\r\n\r\n  // Shuffle data\r\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security shuffle for k-fold cross-validation\r\n  const shuffled = [...featureVectors].sort(() => Math.random() - 0.5);\r\n\r\n  // Perform k-fold CV\r\n  for (let i = 0; i < k; i++) {\r\n    const testStart = i * foldSize;\r\n    const testEnd = i === k - 1 ? n : testStart + foldSize;\r\n\r\n    const testSet = shuffled.slice(testStart, testEnd);\r\n    const trainSet = [\r\n      ...shuffled.slice(0, testStart),\r\n      ...shuffled.slice(testEnd),\r\n    ];\r\n\r\n    // Train classifier\r\n    const classifier = new NearestCentroidClassifier();\r\n    classifier.train(trainSet);\r\n\r\n    // Test on test set\r\n    for (const fv of testSet) {\r\n      const predicted = classifier.predict(fv);\r\n      const actual = fv.domainId;\r\n      const correct = predicted === actual;\r\n\r\n      results.push({ predicted, actual, correct });\r\n\r\n      // Update confusion matrix\r\n      const actualCount = confusionMatrix.get(actual)!.get(predicted) ?? 0;\r\n      confusionMatrix.get(actual)!.set(predicted, actualCount + 1);\r\n    }\r\n  }\r\n\r\n  // Calculate accuracy\r\n  const correctCount = results.filter((r) => r.correct).length;\r\n  const accuracy = correctCount / results.length;\r\n\r\n  return { accuracy, results, confusionMatrix };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "k", "type": "number", "optional": true}], "returnType": "{\r\n  accuracy: number;\r\n  results: ClassificationResult[];\r\n  confusionMatrix: Map<string, Map<string, number>>;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector", "Centroid", "ClassificationResult"], "category": "internal"}, {"source": "./features.js", "specifiers": ["featureVectorToArray", "buildVocabulary", "normalizeFeatures"], "category": "internal"}, {"source": "./distance.js", "specifiers": ["euclideanDistance"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::levenshtein", "name": "levenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * String distance metrics for name similarity analysis\r\n */\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * Returns the minimum number of single-character edits (insertions, deletions, substitutions)\r\n */\r\nexport function levenshtein(a: string, b: string): number {\r\n  if (a.length === 0) return b.length;\r\n  if (b.length === 0) return a.length;\r\n\r\n  // Create matrix\r\n  const matrix: number[][] = [];\r\n\r\n  // Initialize first column\r\n  for (let i = 0; i <= b.length; i++) {\r\n    matrix[i] = [i];\r\n  }\r\n\r\n  // Initialize first row\r\n  for (let j = 0; j <= a.length; j++) {\r\n    matrix[0][j] = j;\r\n  }\r\n\r\n  // Fill matrix\r\n  for (let i = 1; i <= b.length; i++) {\r\n    for (let j = 1; j <= a.length; j++) {\r\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n        matrix[i][j] = matrix[i - 1][j - 1];\r\n      } else {\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j - 1] + 1, // substitution\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j] + 1 // deletion\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix[b.length][a.length];\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::normalizedLevenshtein", "name": "normalizedLevenshtein", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate normalized Levenshtein distance (0 = identical, 1 = completely different)\r\n */\r\nexport function normalizedLevenshtein(a: string, b: string): number {\r\n  const distance = levenshtein(a, b);\r\n  const maxLength = Math.max(a.length, b.length);\r\n\r\n  if (maxLength === 0) return 0;\r\n\r\n  return distance / maxLength;\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::toShapeKey", "name": "toShapeKey", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Convert a name to a shape key for phonetic similarity detection\r\n * Collapses vowels to V, consonants to C, and removes repeated patterns\r\n *\r\n * Example: \"Aeltharion\" -> \"VCCCVCVC\"\r\n */\r\nexport function toShapeKey(name: string): string {\r\n  // Lowercase and remove non-alphabetic characters\r\n  let s = name.toLowerCase().replace(/[^a-z]/g, \"\");\r\n\r\n  // Replace vowels with V\r\n  s = s.replace(/[aeiou]+/g, \"V\");\r\n\r\n  // Replace consonants with C\r\n  s = s.replace(/[^V]+/g, \"C\");\r\n\r\n  // Collapse repeated patterns (optional - can make distance less sensitive)\r\n  // s = s.replace(/(.)\\1+/g, \"$1\");\r\n\r\n  return s;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::shapeDistance", "name": "shapeDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate shape distance between two names\r\n * Uses Levenshtein on shape keys\r\n */\r\nexport function shapeDistance(a: string, b: string): number {\r\n  const shapeA = toShapeKey(a);\r\n  const shapeB = toShapeKey(b);\r\n\r\n  return normalizedLevenshtein(shapeA, shapeB);\r\n}", "parameters": [{"name": "a", "type": "string", "optional": false}, {"name": "b", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::pairwiseDistances", "name": "pairwiseDistances", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate distance between all pairs in a list of names\r\n * Returns a matrix where matrix[i][j] is the distance from names[i] to names[j]\r\n */\r\nexport function pairwiseDistances(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): number[][] {\r\n  const n = names.length;\r\n  const matrix: number[][] = new Array<number[]>(n)\r\n    .fill([])\r\n    .map(() => new Array<number>(n).fill(0));\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = i + 1; j < n; j++) {\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      matrix[i][j] = dist;\r\n      matrix[j][i] = dist; // Symmetric\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "number[][]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::findNearestNeighbors", "name": "findNearestNeighbors", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Find the nearest neighbor for each name in a list\r\n * Returns array of {name, nearestName, distance}\r\n */\r\nexport function findNearestNeighbors(\r\n  names: string[],\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): Array<{ name: string; nearestName: string; distance: number }> {\r\n  const results: Array<{ name: string; nearestName: string; distance: number }> =\r\n    [];\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    let minDistance = Infinity;\r\n    let nearestIndex = -1;\r\n\r\n    for (let j = 0; j < names.length; j++) {\r\n      if (i === j) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist < minDistance) {\r\n        minDistance = dist;\r\n        nearestIndex = j;\r\n      }\r\n    }\r\n\r\n    if (nearestIndex !== -1) {\r\n      results.push({\r\n        name: names[i],\r\n        nearestName: names[nearestIndex],\r\n        distance: minDistance,\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "Array<{ name: string; nearestName: string; distance: number }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::calculatePercentiles", "name": "calculatePercentiles", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate percentile statistics from a list of distances\r\n */\r\nexport function calculatePercentiles(\r\n  values: number[]\r\n): {\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n} {\r\n  if (values.length === 0) {\r\n    return { min: 0, p1: 0, p5: 0, median: 0, p95: 0, p99: 0, max: 0, mean: 0 };\r\n  }\r\n\r\n  const sorted = [...values].sort((a, b) => a - b);\r\n  const n = sorted.length;\r\n\r\n  const percentile = (p: number) => {\r\n    const index = Math.ceil((p / 100) * n) - 1;\r\n    return sorted[Math.max(0, Math.min(index, n - 1))];\r\n  };\r\n\r\n  const mean = values.reduce((sum, v) => sum + v, 0) / n;\r\n\r\n  return {\r\n    min: sorted[0],\r\n    p1: percentile(1),\r\n    p5: percentile(5),\r\n    median: percentile(50),\r\n    p95: percentile(95),\r\n    p99: percentile(99),\r\n    max: sorted[n - 1],\r\n    mean,\r\n  };\r\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}], "returnType": "{\r\n  min: number;\r\n  p1: number;\r\n  p5: number;\r\n  median: number;\r\n  p95: number;\r\n  p99: number;\r\n  max: number;\r\n  mean: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::euclideanDistance", "name": "euclideanDistance", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate Euclidean distance between two feature vectors\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    const diff = a[i] - b[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/distance.ts::cosineSimilarity", "name": "cosineSimilarity", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/distance.ts", "sourceCode": "/**\r\n * Calculate cosine similarity between two feature vectors\r\n * Returns value in [0, 1] where 1 = identical direction\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    throw new Error(\"Feature vectors must have same length\");\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  normA = Math.sqrt(normA);\r\n  normB = Math.sqrt(normB);\r\n\r\n  if (normA === 0 || normB === 0) return 0;\r\n\r\n  return dotProduct / (normA * normB);\r\n}", "parameters": [{"name": "a", "type": "number[]", "optional": false}, {"name": "b", "type": "number[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::estimateSyllableCount", "name": "estimateSyllableCount", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Estimate syllable count based on vowel groups\r\n */\r\nexport function estimateSyllableCount(name: string): number {\r\n  const vowelGroups = name.toLowerCase().match(/[aeiou]+/g);\r\n  return vowelGroups ? vowelGroups.length : 1;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::calculateVowelRatio", "name": "calculateVowelRatio", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Calculate vowel ratio (vowels / total length)\r\n */\r\nexport function calculateVowelRatio(name: string): number {\r\n  if (name.length === 0) return 0;\r\n  const vowelCount = (name.toLowerCase().match(/[aeiou]/g) || []).length;\r\n  return vowelCount / name.length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::countApostrophes", "name": "countApostrophes", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Count apostrophes in a name\r\n */\r\nexport function countApostrophes(name: string): number {\r\n  return (name.match(/'/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::countHyphens", "name": "countHyphens", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Count hyphens in a name\r\n */\r\nexport function countHyphens(name: string): number {\r\n  return (name.match(/-/g) || []).length;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::extractBigrams", "name": "extractBigrams", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Extract character bigrams (2-character sequences)\r\n */\r\nexport function extractBigrams(name: string): Map<string, number> {\r\n  const bigrams = new Map<string, number>();\r\n  const normalized = name.toLowerCase();\r\n\r\n  for (let i = 0; i < normalized.length - 1; i++) {\r\n    const bigram = normalized.substring(i, i + 2);\r\n    bigrams.set(bigram, (bigrams.get(bigram) ?? 0) + 1);\r\n  }\r\n\r\n  return bigrams;\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "Map<string, number>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::getEnding", "name": "getEnding", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Get the ending (last 2 chars) of a name\r\n */\r\nexport function getEnding(name: string): string {\r\n  return name.length >= 2\r\n    ? name.substring(name.length - 2).toLowerCase()\r\n    : name.toLowerCase();\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::extractFeatures", "name": "extractFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Extract feature vector from a name\r\n */\r\nexport function extractFeatures(\r\n  name: string,\r\n  domainId: string\r\n): FeatureVector {\r\n  const bigrams = extractBigrams(name);\r\n\r\n  // Convert bigrams to frequency counts (top 10 most common)\r\n  const bigramFreqs: Record<string, number> = {};\r\n  const sortedBigrams = Array.from(bigrams.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, 10);\r\n\r\n  for (const [bigram, count] of sortedBigrams) {\r\n    bigramFreqs[bigram] = count;\r\n  }\r\n\r\n  return {\r\n    name,\r\n    domainId,\r\n    features: {\r\n      length: name.length,\r\n      syllableCount: estimateSyllableCount(name),\r\n      vowelRatio: calculateVowelRatio(name),\r\n      apostropheCount: countApostrophes(name),\r\n      hyphenCount: countHyphens(name),\r\n      bigrams: bigramFreqs,\r\n      ending: getEnding(name),\r\n    },\r\n  };\r\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "domainId", "type": "string", "optional": false}], "returnType": "FeatureVector", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::featureVectorToArray", "name": "featureVectorToArray", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Convert a feature vector to a numeric array for ML\r\n * This flattens the structured features into a single vector\r\n */\r\nexport function featureVectorToArray(\r\n  fv: FeatureVector,\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  const features: number[] = [];\r\n\r\n  // Basic numeric features\r\n  features.push(fv.features.length);\r\n  features.push(fv.features.syllableCount);\r\n  features.push(fv.features.vowelRatio);\r\n  features.push(fv.features.apostropheCount);\r\n  features.push(fv.features.hyphenCount);\r\n\r\n  // Bigram features (one-hot-ish encoding)\r\n  for (const bigram of allBigrams) {\r\n    features.push(fv.features.bigrams[bigram] ?? 0);\r\n  }\r\n\r\n  // Ending feature (one-hot encoding)\r\n  const endingIndex = allEndings.indexOf(fv.features.ending);\r\n  for (let i = 0; i < allEndings.length; i++) {\r\n    features.push(i === endingIndex ? 1 : 0);\r\n  }\r\n\r\n  return features;\r\n}", "parameters": [{"name": "fv", "type": "FeatureVector", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::buildVocabulary", "name": "buildVocabulary", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Build vocabulary of all bigrams and endings from a set of feature vectors\r\n */\r\nexport function buildVocabulary(featureVectors: FeatureVector[]): {\r\n  bigrams: string[];\r\n  endings: string[];\r\n} {\r\n  const bigramSet = new Set<string>();\r\n  const endingSet = new Set<string>();\r\n\r\n  for (const fv of featureVectors) {\r\n    for (const bigram of Object.keys(fv.features.bigrams)) {\r\n      bigramSet.add(bigram);\r\n    }\r\n    endingSet.add(fv.features.ending);\r\n  }\r\n\r\n  return {\r\n    bigrams: Array.from(bigramSet).sort((a, b) => a.localeCompare(b)),\r\n    endings: Array.from(endingSet).sort((a, b) => a.localeCompare(b)),\r\n  };\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}], "returnType": "{\r\n  bigrams: string[];\r\n  endings: string[];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::calculateCentroid", "name": "calculateCentroid", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Calculate centroid (mean) of feature vectors\r\n */\r\nexport function calculateCentroid(\r\n  featureVectors: FeatureVector[],\r\n  allBigrams: string[],\r\n  allEndings: string[]\r\n): number[] {\r\n  if (featureVectors.length === 0) {\r\n    // Return zero vector\r\n    return new Array<number>(5 + allBigrams.length + allEndings.length).fill(0);\r\n  }\r\n\r\n  // Convert all to arrays\r\n  const arrays = featureVectors.map((fv) =>\r\n    featureVectorToArray(fv, allBigrams, allEndings)\r\n  );\r\n\r\n  // Calculate mean for each dimension\r\n  const dimensions = arrays[0].length;\r\n  const centroid: number[] = new Array<number>(dimensions).fill(0);\r\n\r\n  for (const arr of arrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      centroid[i] += arr[i];\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < dimensions; i++) {\r\n    centroid[i] /= arrays.length;\r\n  }\r\n\r\n  return centroid;\r\n}", "parameters": [{"name": "featureVectors", "type": "FeatureVector[]", "optional": false}, {"name": "allBigrams", "type": "string[]", "optional": false}, {"name": "allEndings", "type": "string[]", "optional": false}], "returnType": "number[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/analysis/features.ts::normalizeFeatures", "name": "normalizeFeatures", "kind": "function", "filePath": "apps/name-forge/lib/validation/analysis/features.ts", "sourceCode": "/**\r\n * Normalize feature vectors to [0, 1] range\r\n * Helps with distance calculations and classification\r\n */\r\nexport function normalizeFeatures(\r\n  featureArrays: number[][]\r\n): {\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n} {\r\n  if (featureArrays.length === 0) {\r\n    return { normalized: [], min: [], max: [] };\r\n  }\r\n\r\n  const dimensions = featureArrays[0].length;\r\n  const min: number[] = new Array<number>(dimensions).fill(Infinity);\r\n  const max: number[] = new Array<number>(dimensions).fill(-Infinity);\r\n\r\n  // Find min/max for each dimension\r\n  for (const arr of featureArrays) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      min[i] = Math.min(min[i], arr[i]);\r\n      max[i] = Math.max(max[i], arr[i]);\r\n    }\r\n  }\r\n\r\n  // Normalize\r\n  const normalized = featureArrays.map((arr) => {\r\n    return arr.map((val, i) => {\r\n      const range = max[i] - min[i];\r\n      if (range === 0) return 0;\r\n      return (val - min[i]) / range;\r\n    });\r\n  });\r\n\r\n  return { normalized, min, max };\r\n}", "parameters": [{"name": "featureArrays", "type": "number[][]", "optional": false}], "returnType": "{\r\n  normalized: number[][];\r\n  min: number[];\r\n  max: number[];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../validation.js", "specifiers": ["FeatureVector"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::calculateEntropy", "name": "calculateEntropy", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Calculate Shannon entropy for a set of names\r\n * Measures information density - higher entropy = more variety in character usage\r\n *\r\n * H = -\u03a3 p(c) * log2(p(c))\r\n */\r\nexport function calculateEntropy(names: string[]): number {\r\n  if (names.length === 0) return 0;\r\n\r\n  // Count character frequencies\r\n  const freq = new Map<string, number>();\r\n  let total = 0;\r\n\r\n  for (const name of names) {\r\n    for (const char of name.toLowerCase()) {\r\n      total++;\r\n      freq.set(char, (freq.get(char) ?? 0) + 1);\r\n    }\r\n  }\r\n\r\n  if (total === 0) return 0;\r\n\r\n  // Calculate entropy\r\n  let entropy = 0;\r\n  for (const count of freq.values()) {\r\n    const p = count / total;\r\n    entropy -= p * Math.log2(p);\r\n  }\r\n\r\n  return entropy;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["CapacityReport", "ValidationConfig"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::validateCapacity", "name": "validateCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Validate capacity of a domain - can it generate enough unique names?\r\n */\r\nexport function validateCapacity(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): CapacityReport {\r\n  const sampleSize = config.sampleSize ?? 1000;\r\n  const maxCollisionRate = config.maxCollisionRate ?? 0.05;\r\n  const minEntropy = config.minEntropy ?? 3.0;\r\n\r\n  // Generate samples using the name generator's test function\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n  // Calculate metrics\r\n  const uniqueCount = testResult.uniqueCount;\r\n  const collisionRate = 1 - uniqueCount / sampleSize;\r\n  const entropy = calculateEntropy(testResult.samples);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (collisionRate > maxCollisionRate) {\r\n    issues.push(\r\n      `Collision rate ${(collisionRate * 100).toFixed(2)}% exceeds threshold ${(maxCollisionRate * 100).toFixed(2)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (entropy < minEntropy) {\r\n    issues.push(\r\n      `Entropy ${entropy.toFixed(2)} bits/char below threshold ${minEntropy} bits/char`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (uniqueCount < sampleSize * 0.8) {\r\n    issues.push(\r\n      `Only ${uniqueCount} unique names from ${sampleSize} samples (${((uniqueCount / sampleSize) * 100).toFixed(1)}%)`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    uniqueCount,\r\n    collisionRate,\r\n    entropy,\r\n    avgLength: testResult.avgLength,\r\n    minLength: testResult.minLength,\r\n    maxLength: testResult.maxLength,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "CapacityReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["CapacityReport", "ValidationConfig"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::estimateRequiredSamples", "name": "estimateRequiredSamples", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Estimate required sample size for target collision rate\r\n * Uses birthday paradox approximation\r\n */\r\nexport function estimateRequiredSamples(\r\n  domain: NamingDomain,\r\n  targetCollisionRate: number = 0.01,\r\n  probeSampleSize: number = 100\r\n): number {\r\n  // Generate a small probe sample to estimate capacity\r\n  const probe = testDomain(domain, probeSampleSize);\r\n\r\n  // Estimate total capacity from probe collision rate\r\n  const probeCollisionRate = 1 - probe.uniqueCount / probeSampleSize;\r\n\r\n  if (probeCollisionRate === 0) {\r\n    // No collisions in probe - domain is large\r\n    // Use conservative estimate\r\n    return Math.floor(probeSampleSize / targetCollisionRate);\r\n  }\r\n\r\n  // Rough estimate: if probe has X% collision rate with N samples,\r\n  // extrapolate to target collision rate\r\n  const scaleFactor = Math.sqrt(probeCollisionRate / targetCollisionRate);\r\n  return Math.floor(probeSampleSize / scaleFactor);\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "targetCollisionRate", "type": "number", "optional": true}, {"name": "probeSampleSize", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["CapacityReport", "ValidationConfig"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/capacity.ts::theoreticalCapacity", "name": "theoreticalCapacity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/capacity.ts", "sourceCode": "/**\r\n * Calculate theoretical capacity using combinatorics\r\n * This is an upper bound - actual capacity may be lower due to forbidden clusters\r\n */\r\nexport function theoreticalCapacity(domain: NamingDomain): {\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n} {\r\n  const phonology = domain.phonology;\r\n  const [minSyllables, maxSyllables] = phonology.lengthRange;\r\n\r\n  // Count phonemes\r\n  const numConsonants = phonology.consonants.length;\r\n  const numVowels = phonology.vowels.length;\r\n\r\n  // Estimate syllables per template (rough average)\r\n  const avgPhonemes = phonology.syllableTemplates.reduce((sum, template) => {\r\n    return sum + template.replace(/[^CV]/g, \"\").length;\r\n  }, 0) / phonology.syllableTemplates.length;\r\n\r\n  // Calculate capacity for min and max syllable counts\r\n  const capacityPerSyllable = Math.pow(\r\n    (numConsonants + numVowels) / 2,\r\n    avgPhonemes\r\n  );\r\n\r\n  const minCapacity = Math.pow(capacityPerSyllable, minSyllables);\r\n  const maxCapacity = Math.pow(capacityPerSyllable, maxSyllables);\r\n\r\n  return {\r\n    minCapacity: Math.floor(minCapacity),\r\n    maxCapacity: Math.floor(maxCapacity),\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}], "returnType": "{\r\n  minCapacity: number;\r\n  maxCapacity: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["CapacityReport", "ValidationConfig"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::validateDiffuseness", "name": "validateDiffuseness", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Validate diffuseness of a domain - are names within the domain distinct enough?\r\n */\r\nexport function validateDiffuseness(\r\n  domain: NamingDomain,\r\n  config: Partial<ValidationConfig> = {}\r\n): DiffusenessReport {\r\n  const sampleSize = config.sampleSize ?? 500;\r\n  const minNN_p5 = config.minNN_p5 ?? 0.3;\r\n  const minShapeNN_p5 = config.minShapeNN_p5 ?? 0.2;\r\n\r\n  // Generate samples\r\n  const testResult = testDomain(domain, sampleSize, config.seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Find nearest neighbors using raw Levenshtein\r\n  const levenshteinNN = findNearestNeighbors(samples, normalizedLevenshtein);\r\n  const levenshteinDistances = levenshteinNN.map((nn) => nn.distance);\r\n  const levenshteinStats = calculatePercentiles(levenshteinDistances);\r\n\r\n  // Find nearest neighbors using shape distance\r\n  const shapeNN = findNearestNeighbors(samples, shapeDistance);\r\n  const shapeDistances = shapeNN.map((nn) => nn.distance);\r\n  const shapeStats = calculatePercentiles(shapeDistances);\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  if (levenshteinStats.p5 < minNN_p5) {\r\n    issues.push(\r\n      `Levenshtein p5 distance ${levenshteinStats.p5.toFixed(3)} below threshold ${minNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  if (shapeStats.p5 < minShapeNN_p5) {\r\n    issues.push(\r\n      `Shape p5 distance ${shapeStats.p5.toFixed(3)} below threshold ${minShapeNN_p5}`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Additional checks\r\n  if (levenshteinStats.min < 0.1) {\r\n    const veryClose = levenshteinNN.filter((nn) => nn.distance < 0.1);\r\n    const closeExamples = veryClose.slice(0, 3).map((nn) => `\"${nn.name}\" \\u2194 \"${nn.nearestName}\"`).join(\", \");\r\n    issues.push(\r\n      `${veryClose.length} name pairs are very similar (distance < 0.1). Examples: ${closeExamples}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    domainId: domain.id,\r\n    sampleSize,\r\n    levenshteinNN: levenshteinStats,\r\n    shapeNN: shapeStats,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "DiffusenessReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["DiffusenessReport", "ValidationConfig"], "category": "internal"}, {"source": "../analysis/distance.js", "specifiers": ["findNearestNeighbors", "normalizedLevenshtein", "shapeDistance", "calculatePercentiles"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::findSimilarClusters", "name": "findSimilarClusters", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Find clusters of very similar names\r\n * Useful for identifying problematic groups\r\n */\r\nexport function findSimilarClusters(\r\n  names: string[],\r\n  threshold: number = 0.2,\r\n  distanceFunc: (a: string, b: string) => number = normalizedLevenshtein\r\n): string[][] {\r\n  const clusters: string[][] = [];\r\n  const visited = new Set<number>();\r\n\r\n  for (let i = 0; i < names.length; i++) {\r\n    if (visited.has(i)) continue;\r\n\r\n    const cluster = [names[i]];\r\n    visited.add(i);\r\n\r\n    for (let j = i + 1; j < names.length; j++) {\r\n      if (visited.has(j)) continue;\r\n\r\n      const dist = distanceFunc(names[i], names[j]);\r\n      if (dist <= threshold) {\r\n        cluster.push(names[j]);\r\n        visited.add(j);\r\n      }\r\n    }\r\n\r\n    if (cluster.length > 1) {\r\n      clusters.push(cluster);\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "threshold", "type": "number", "optional": true}, {"name": "distanceFunc", "type": "(a: string, b: string) => number", "optional": true}], "returnType": "string[][]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["DiffusenessReport", "ValidationConfig"], "category": "internal"}, {"source": "../analysis/distance.js", "specifiers": ["findNearestNeighbors", "normalizedLevenshtein", "shapeDistance", "calculatePercentiles"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/diffuseness.ts::analyzeDiversity", "name": "analyzeDiversity", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/diffuseness.ts", "sourceCode": "/**\r\n * Analyze name diversity within a domain\r\n * Returns statistics about how varied the names are\r\n */\r\nexport function analyzeDiversity(\r\n  domain: NamingDomain,\r\n  sampleSize: number = 500,\r\n  seed?: string\r\n): {\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n} {\r\n  const testResult = testDomain(domain, sampleSize, seed);\r\n  const samples = testResult.samples;\r\n\r\n  // Count unique starts (first 2 chars)\r\n  const starts = new Set(samples.map((s) => s.substring(0, 2).toLowerCase()));\r\n\r\n  // Count unique endings (last 2 chars)\r\n  const endings = new Set(\r\n    samples.map((s) => s.substring(s.length - 2).toLowerCase())\r\n  );\r\n\r\n  // Calculate average pairwise similarity (sample for efficiency)\r\n  const maxPairs = Math.min(1000, (sampleSize * (sampleSize - 1)) / 2);\r\n  let totalSimilarity = 0;\r\n  let pairCount = 0;\r\n\r\n  for (let i = 0; i < samples.length && pairCount < maxPairs; i++) {\r\n    for (\r\n      let j = i + 1;\r\n      j < samples.length && pairCount < maxPairs;\r\n      j++, pairCount++\r\n    ) {\r\n      const dist = normalizedLevenshtein(samples[i], samples[j]);\r\n      totalSimilarity += 1 - dist; // Convert distance to similarity\r\n    }\r\n  }\r\n\r\n  const avgSimilarity = pairCount > 0 ? totalSimilarity / pairCount : 0;\r\n\r\n  // Find similar clusters\r\n  const clusters = findSimilarClusters(samples, 0.2);\r\n\r\n  return {\r\n    uniqueStarts: starts.size,\r\n    uniqueEndings: endings.size,\r\n    avgSimilarity,\r\n    clusters,\r\n  };\r\n}", "parameters": [{"name": "domain", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  uniqueStarts: number;\r\n  uniqueEndings: number;\r\n  avgSimilarity: number;\r\n  clusters: string[][];\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["DiffusenessReport", "ValidationConfig"], "category": "internal"}, {"source": "../analysis/distance.js", "specifiers": ["findNearestNeighbors", "normalizedLevenshtein", "shapeDistance", "calculatePercentiles"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/separation.ts::validateSeparation", "name": "validateSeparation", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/separation.ts", "sourceCode": "/**\r\n * Validate separation between multiple domains\r\n * Tests if names from different domains are distinguishable by shape\r\n */\r\nexport function validateSeparation(\r\n  domains: NamingDomain[],\r\n  config: Partial<ValidationConfig> = {}\r\n): SeparationReport {\r\n  if (domains.length < 2) {\r\n    throw new Error(\"Need at least 2 domains to test separation\");\r\n  }\r\n\r\n  const sampleSize = config.sampleSize ?? 200;\r\n  const minCentroidDistance = config.minCentroidDistance ?? 0.2;\r\n  const minClassifierAccuracy = config.minClassifierAccuracy ?? 0.7;\r\n\r\n  // Generate samples for each domain\r\n  const allFeatureVectors: FeatureVector[] = [];\r\n\r\n  for (const domain of domains) {\r\n    const testResult = testDomain(domain, sampleSize, config.seed);\r\n\r\n    for (const name of testResult.samples) {\r\n      const fv = extractFeatures(name, domain.id);\r\n      allFeatureVectors.push(fv);\r\n    }\r\n  }\r\n\r\n  // Build vocabulary and calculate centroids\r\n  const vocabulary = buildVocabulary(allFeatureVectors);\r\n  const centroids: Centroid[] = [];\r\n\r\n  const byDomain = new Map<string, FeatureVector[]>();\r\n  for (const fv of allFeatureVectors) {\r\n    if (!byDomain.has(fv.domainId)) {\r\n      byDomain.set(fv.domainId, []);\r\n    }\r\n    byDomain.get(fv.domainId)!.push(fv);\r\n  }\r\n\r\n  for (const [domainId, vectors] of byDomain) {\r\n    const centroidFeatures = calculateCentroid(\r\n      vectors,\r\n      vocabulary.bigrams,\r\n      vocabulary.endings\r\n    );\r\n\r\n    centroids.push({\r\n      domainId,\r\n      features: centroidFeatures,\r\n      sampleCount: vectors.length,\r\n    });\r\n  }\r\n\r\n  // Calculate pairwise centroid distances\r\n  const pairwiseDistances: Record<string, number> = {};\r\n\r\n  for (let i = 0; i < centroids.length; i++) {\r\n    for (let j = i + 1; j < centroids.length; j++) {\r\n      const c1 = centroids[i];\r\n      const c2 = centroids[j];\r\n      const dist = euclideanDistance(c1.features, c2.features);\r\n      const key = `${c1.domainId}-${c2.domainId}`;\r\n      pairwiseDistances[key] = dist;\r\n    }\r\n  }\r\n\r\n  // Train and evaluate classifier with cross-validation\r\n  const cvResult = crossValidate(allFeatureVectors, 5);\r\n\r\n  // Build confusion matrix in the expected format\r\n  const confusionMatrix: Record<string, Record<string, number>> = {};\r\n  for (const [actual, predictions] of cvResult.confusionMatrix) {\r\n    confusionMatrix[actual] = {};\r\n    for (const [predicted, count] of predictions) {\r\n      confusionMatrix[actual][predicted] = count;\r\n    }\r\n  }\r\n\r\n  // Determine pass/fail\r\n  const issues: string[] = [];\r\n  let passed = true;\r\n\r\n  // Check centroid distances\r\n  for (const [pair, dist] of Object.entries(pairwiseDistances)) {\r\n    if (dist < minCentroidDistance) {\r\n      issues.push(\r\n        `Centroid distance for ${pair} is ${dist.toFixed(3)}, below threshold ${minCentroidDistance}`\r\n      );\r\n      passed = false;\r\n    }\r\n  }\r\n\r\n  // Check classifier accuracy\r\n  if (cvResult.accuracy < minClassifierAccuracy) {\r\n    issues.push(\r\n      `Classifier accuracy ${(cvResult.accuracy * 100).toFixed(1)}% below threshold ${(minClassifierAccuracy * 100).toFixed(1)}%`\r\n    );\r\n    passed = false;\r\n  }\r\n\r\n  // Check for specific domain pairs with high confusion\r\n  const confusionIssues = findHighConfusionPairs(cvResult.confusionMatrix);\r\n  issues.push(...confusionIssues);\r\n\r\n  return {\r\n    domains: domains.map((d) => d.id),\r\n    sampleSize,\r\n    centroids,\r\n    pairwiseDistances,\r\n    classifierAccuracy: cvResult.accuracy,\r\n    confusionMatrix,\r\n    passed,\r\n    issues,\r\n  };\r\n}", "parameters": [{"name": "domains", "type": "NamingDomain[]", "optional": false}, {"name": "config", "type": "Partial<ValidationConfig>", "optional": true}], "returnType": "SeparationReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["SeparationReport", "ValidationConfig", "FeatureVector", "Centroid"], "category": "internal"}, {"source": "../analysis/features.js", "specifiers": ["extractFeatures", "calculateCentroid", "buildVocabulary"], "category": "internal"}, {"source": "../analysis/classifier.js", "specifiers": ["crossValidate"], "category": "internal"}, {"source": "../analysis/distance.js", "specifiers": ["euclideanDistance"], "category": "internal"}]}, {"id": "apps/name-forge/lib/validation/metrics/separation.ts::compareDomains", "name": "compareDomains", "kind": "function", "filePath": "apps/name-forge/lib/validation/metrics/separation.ts", "sourceCode": "/**\r\n * Calculate separation score between two specific domains\r\n */\r\nexport function compareDomains(\r\n  domain1: NamingDomain,\r\n  domain2: NamingDomain,\r\n  sampleSize: number = 200,\r\n  seed?: string\r\n): {\r\n  centroidDistance: number;\r\n  classifierAccuracy: number;\r\n  domain1MisclassifiedAs2: number;\r\n  domain2MisclassifiedAs1: number;\r\n} {\r\n  const report = validateSeparation([domain1, domain2], { sampleSize, seed });\r\n\r\n  const key = `${domain1.id}-${domain2.id}`;\r\n  const centroidDistance = report.pairwiseDistances[key] ?? 0;\r\n\r\n  const domain1Total =\r\n    Object.values(report.confusionMatrix[domain1.id] ?? {}).reduce(\r\n      (sum, count) => sum + count,\r\n      0\r\n    );\r\n  const domain1MisclassifiedAs2 =\r\n    (report.confusionMatrix[domain1.id]?.[domain2.id] ?? 0) / domain1Total;\r\n\r\n  const domain2Total =\r\n    Object.values(report.confusionMatrix[domain2.id] ?? {}).reduce(\r\n      (sum, count) => sum + count,\r\n      0\r\n    );\r\n  const domain2MisclassifiedAs1 =\r\n    (report.confusionMatrix[domain2.id]?.[domain1.id] ?? 0) / domain2Total;\r\n\r\n  return {\r\n    centroidDistance,\r\n    classifierAccuracy: report.classifierAccuracy,\r\n    domain1MisclassifiedAs2,\r\n    domain2MisclassifiedAs1,\r\n  };\r\n}", "parameters": [{"name": "domain1", "type": "NamingDomain", "optional": false}, {"name": "domain2", "type": "NamingDomain", "optional": false}, {"name": "sampleSize", "type": "number", "optional": true}, {"name": "seed", "type": "string", "optional": true}], "returnType": "{\r\n  centroidDistance: number;\r\n  classifierAccuracy: number;\r\n  domain1MisclassifiedAs2: number;\r\n  domain2MisclassifiedAs1: number;\r\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../types/domain.js", "specifiers": ["NamingDomain"], "category": "internal"}, {"source": "../../generate.js", "specifiers": ["testDomain"], "category": "internal"}, {"source": "../validation.js", "specifiers": ["SeparationReport", "ValidationConfig", "FeatureVector", "Centroid"], "category": "internal"}, {"source": "../analysis/features.js", "specifiers": ["extractFeatures", "calculateCentroid", "buildVocabulary"], "category": "internal"}, {"source": "../analysis/classifier.js", "specifiers": ["crossValidate"], "category": "internal"}, {"source": "../analysis/distance.js", "specifiers": ["euclideanDistance"], "category": "internal"}]}, {"id": "apps/viewer/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/App.jsx", "sourceCode": "export default function App() {\n  const {\n    bundle,\n    status,\n    error,\n    bundleRequestUrl,\n    loadBundle,\n    dexieSeededAt,\n    preloadedChronicles,\n    preloadedStaticPages,\n    preloadedEraNarratives,\n  } = useBundleLoader();\n  const [chroniclerRequestedPage, setChroniclerRequestedPage] = useState(null);\n  const clearChroniclerRequestedPage = useCallback(() => setChroniclerRequestedPage(null), []);\n\n  if (status !== \"ready\" || !bundle?.worldData) {\n    return (\n      <StatusScreen\n        status={status}\n        error={error}\n        bundleRequestUrl={bundleRequestUrl}\n        onRetry={loadBundle}\n        worldData={bundle?.worldData}\n      />\n    );\n  }\n\n  return (\n    <div className=\"app\">\n      <header className=\"app-header\">\n        <button\n          type=\"button\"\n          className=\"brand\"\n          onClick={() => {\n            setChroniclerRequestedPage(\"home\");\n            window.location.hash = \"#/\";\n          }}\n        >\n          <span className=\"brand-icon\" aria-hidden=\"true\">\n            &#x2756;\n          </span>\n          <span className=\"brand-title\">The Ice Remembers</span>\n        </button>\n        <HeaderSearch\n          projectId={bundle.projectId}\n          slotIndex={bundle.slot?.index ?? 0}\n          dexieSeededAt={dexieSeededAt}\n          onNavigate={setChroniclerRequestedPage}\n        />\n        <div className=\"header-spacer\" />\n      </header>\n      <main className=\"app-main\">\n        <div className=\"panel chronicler-scope\">\n          <ChroniclerRemote\n            projectId={bundle.projectId}\n            activeSlotIndex={bundle.slot?.index ?? 0}\n            requestedPageId={chroniclerRequestedPage}\n            onRequestedPageConsumed={clearChroniclerRequestedPage}\n            dexieSeededAt={dexieSeededAt}\n            preloadedWorldData={bundle.worldData}\n            preloadedChronicles={preloadedChronicles}\n            preloadedStaticPages={preloadedStaticPages}\n            preloadedEraNarratives={preloadedEraNarratives}\n            prebakedParchmentUrl={parchmentTileUrl}\n            precomputedPageIndex={bundle.precomputedPageIndex}\n          />\n        </div>\n      </main>\n      <footer className=\"app-footer\">\n        <span>Copyright \u00a9 2026</span>\n        <a href=\"https://ahara.io\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <img src=\"/tsonu-combined.png\" alt=\"tsonu\" height=\"14\" />\n        </a>\n      </footer>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "@chronicler/ChroniclerRemote.tsx", "specifiers": ["ChroniclerRemote"], "category": "external"}, {"source": "@chronicler/assets/textures/parchment-tile.jpg", "specifiers": ["parchmentTileUrl"], "category": "external"}, {"source": "./HeaderSearch", "specifiers": ["HeaderSearch"], "category": "internal"}, {"source": "./StatusScreen", "specifiers": ["StatusScreen"], "category": "internal"}, {"source": "./useBundleLoader", "specifiers": ["useBundleLoader"], "category": "internal"}]}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleUrl", "name": "resolveBundleUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleUrl() {\n  return new URL(DEFAULT_BUNDLE_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore", "FetchBackend"], "category": "external"}]}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleManifestUrl", "name": "resolveBundleManifestUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleManifestUrl() {\n  return new URL(DEFAULT_BUNDLE_MANIFEST_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore", "FetchBackend"], "category": "external"}]}, {"id": "apps/viewer/webui/src/bundleLoader.js::normalizeBundle", "name": "normalizeBundle", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function normalizeBundle(raw, bundleUrl) {\n  if (!raw || typeof raw !== \"object\") return null;\n\n  const baseUrl = new URL(\".\", bundleUrl).toString();\n  const resolveUrl = (value) => resolveAssetUrl(value, baseUrl);\n\n  return {\n    ...raw,\n    chronicles: Array.isArray(raw.chronicles) ? raw.chronicles : [],\n    staticPages: Array.isArray(raw.staticPages) ? raw.staticPages : [],\n    images: resolveImageMap(raw.images, resolveUrl),\n    imageData: resolveImageData(raw.imageData, resolveUrl),\n  };\n}", "parameters": [{"name": "raw", "type": "any", "optional": false}, {"name": "bundleUrl", "type": "any", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore", "FetchBackend"], "category": "external"}]}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleViaManifest", "name": "loadBundleViaManifest", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleViaManifest(manifestUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(manifestUrl);\n  const manifest = await fetchJson(manifestUrl, { cache: \"no-store\" });\n  if (!manifest || manifest.format !== \"viewer-bundle-manifest\") {\n    throw new Error(\"Bundle manifest missing or invalid.\");\n  }\n\n  const manifestBaseUrl = new URL(\".\", manifestUrl).toString();\n  const corePath = manifest.core;\n  if (typeof corePath !== \"string\") {\n    throw new Error(\"Bundle manifest is missing core path.\");\n  }\n  const coreUrl = resolveAssetUrl(corePath, manifestBaseUrl);\n  setBundleRequestUrl(coreUrl);\n  const data = await fetchJson(coreUrl);\n\n  const normalized = validateAndNormalizeBundle(data, coreUrl);\n  configureNarrativeBackend(\n    manifest,\n    manifestBaseUrl,\n    normalized.worldData?.metadata?.simulationRunId\n  );\n  return normalized;\n}", "parameters": [{"name": "manifestUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore", "FetchBackend"], "category": "external"}]}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleFallback", "name": "loadBundleFallback", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleFallback(fallbackUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(fallbackUrl);\n  const data = await fetchJson(fallbackUrl, { cache: \"no-store\" });\n  const normalized = validateAndNormalizeBundle(data, fallbackUrl);\n  const totalEvents = normalized.worldData.narrativeHistory.length;\n\n  if (totalEvents > 0) {\n    useNarrativeStore.getState().ingestChunk(normalized.worldData.narrativeHistory);\n  }\n  useNarrativeStore.getState().setStatus({\n    loading: false,\n    totalExpected: totalEvents,\n    chunksLoaded: totalEvents ? 1 : 0,\n    chunksTotal: totalEvents ? 1 : 0,\n  });\n\n  return normalized;\n}", "parameters": [{"name": "fallbackUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore", "FetchBackend"], "category": "external"}]}, {"id": "apps/viewer/webui/src/HeaderSearch.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/HeaderSearch.jsx", "sourceCode": "export default function HeaderSearch({ projectId, slotIndex, dexieSeededAt, onNavigate }) {\n  const [query, setQuery] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const containerRef = useRef(null);\n  const { pages, isIndexLoading } = useSearchIndex(projectId, slotIndex, dexieSeededAt);\n\n  const fuse = useMemo(\n    () =>\n      new Fuse(pages, {\n        keys: [\n          { name: \"title\", weight: 2 },\n          { name: \"content.summary\", weight: 1 },\n        ],\n        threshold: 0.3,\n        includeScore: true,\n        minMatchCharLength: 2,\n      }),\n    [pages]\n  );\n\n  const results = useMemo(() => {\n    if (!query || query.length < 2) return [];\n    return fuse.search(query).slice(0, 8);\n  }, [fuse, query]);\n\n  const handleSelect = useCallback(\n    (id) => {\n      if (id) onNavigate(id);\n      setIsOpen(false);\n      setQuery(\"\");\n    },\n    [onNavigate]\n  );\n\n  const handleKeyDown = useKeyboardNavigation(\n    results,\n    selectedIndex,\n    setSelectedIndex,\n    handleSelect\n  );\n\n  useEffect(() => {\n    const onClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) setIsOpen(false);\n    };\n    document.addEventListener(\"mousedown\", onClickOutside);\n    return () => document.removeEventListener(\"mousedown\", onClickOutside);\n  }, []);\n\n  return (\n    <div className=\"header-search\" ref={containerRef}>\n      <input\n        type=\"text\"\n        className=\"header-search-input\"\n        placeholder=\"Search wiki...\"\n        value={query}\n        onChange={(e) => {\n          setQuery(e.target.value);\n          setSelectedIndex(0);\n          setIsOpen(true);\n        }}\n        onFocus={() => setIsOpen(true)}\n        onKeyDown={(e) => {\n          if (isOpen) handleKeyDown(e);\n        }}\n      />\n      {isOpen && query.length >= 2 && (\n        <div className=\"header-search-dropdown\">\n          {results.length > 0 ? (\n            results.map((result, index) => (\n              <button\n                key={result.item.id}\n                type=\"button\"\n                className={`header-search-result ${index === selectedIndex ? \"selected\" : \"\"}`}\n                onClick={() => handleSelect(result.item.id)}\n                onMouseEnter={() => setSelectedIndex(index)}\n              >\n                <span className=\"header-search-result-title\">{result.item.title}</span>\n                <span className=\"header-search-result-type\">{result.item.type}</span>\n              </button>\n            ))\n          ) : (\n            <div className=\"header-search-no-results\">\n              {isIndexLoading ? \"Indexing pages...\" : \"No results found\"}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, slotIndex, dexieSeededAt, onNavigate }", "type": "{ projectId: any; slotIndex: any; dexieSeededAt: any; onNavigate: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useCallback", "useEffect", "useMemo", "useRef", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "fuse.js", "specifiers": ["Fuse"], "category": "external"}, {"source": "@the-canonry/world-store", "specifiers": ["getChronicles", "getEntities", "getSlotRecord", "getStaticPages"], "category": "external"}]}, {"id": "apps/viewer/webui/src/StatusScreen.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/StatusScreen.jsx", "sourceCode": "export default function StatusScreen({ status, error, bundleRequestUrl, onRetry, worldData }) {\n  if (status === \"loading\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Loading viewer bundle...</div>\n            <div className=\"state-detail\">Fetching {bundleRequestUrl}</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (status === \"error\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title state-error\">Bundle unavailable</div>\n            <div className=\"state-detail\">\n              {error?.message || \"Failed to load the viewer bundle.\"}\n            </div>\n            <div className=\"state-detail\">Expected at: {bundleRequestUrl}</div>\n            <div className=\"state-actions\">\n              <button className=\"button\" onClick={onRetry} type=\"button\">\n                Retry\n              </button>\n              <button\n                className=\"button secondary\"\n                onClick={() => window.location.reload()}\n                type=\"button\"\n              >\n                Reload page\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!worldData) {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Bundle is empty</div>\n            <div className=\"state-detail\">No world data found in {bundleRequestUrl}.</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{ status, error, bundleRequestUrl, onRetry, worldData }", "type": "{ status: any; error: any; bundleRequestUrl: any; onRetry: any; worldData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}]}, {"id": "apps/viewer/webui/src/useBundleLoader.js::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/useBundleLoader.js", "sourceCode": "export default function useBundleLoader() {\n  const { bundle, status, error, bundleRequestUrl, loadBundle } = useLoadBundle();\n  const dexieSeededAt = useDexiePersistence(bundle);\n  const preloads = useBundlePreloads(bundle);\n\n  return { bundle, status, error, bundleRequestUrl, loadBundle, dexieSeededAt, ...preloads };\n}", "parameters": [], "returnType": "{ preloadedChronicles: any; preloadedStaticPages: any; preloadedEraNarratives: any; bundle: any; status: string; error: any; bundleRequestUrl: string; loadBundle: () => Promise<void>; dexieSeededAt: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["useCallback", "useEffect", "useMemo", "useRef", "useState"], "category": "framework"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageStore", "CDNBackend"], "category": "external"}, {"source": "@the-canonry/narrative-store", "specifiers": ["useNarrativeStore"], "category": "external"}, {"source": "./lib/illuminatorDbWriter", "specifiers": ["overwriteWorldDataInDexie"], "category": "internal"}, {"source": "./bundleLoader", "specifiers": ["resolveBundleUrl", "resolveBundleManifestUrl", "loadBundleViaManifest", "loadBundleFallback"], "category": "internal"}]}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::overwriteWorldDataInDexie", "name": "overwriteWorldDataInDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "export async function overwriteWorldDataInDexie({\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}: {\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}) {\n  if (!projectId || !worldData) return;\n\n  const simulationRunId = worldData?.metadata?.simulationRunId;\n  if (!simulationRunId) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    // Determine which stores to include in the transaction\n    const storeNames = [\n      \"entities\",\n      \"relationships\",\n      \"narrativeEvents\",\n      \"simulationSlots\",\n      \"worldSchemas\",\n      \"coordinateStates\",\n      \"chronicles\",\n      \"staticPages\",\n    ];\n    const hasEraNarrativesStore = db.objectStoreNames.contains(\"eraNarratives\");\n    if (hasEraNarrativesStore) {\n      storeNames.push(\"eraNarratives\");\n    }\n\n    const tx = db.transaction(storeNames, \"readwrite\");\n\n    const entitiesStore = tx.objectStore(\"entities\");\n    const relationshipsStore = tx.objectStore(\"relationships\");\n    const eventsStore = tx.objectStore(\"narrativeEvents\");\n    const slotsStore = tx.objectStore(\"simulationSlots\");\n    const schemasStore = tx.objectStore(\"worldSchemas\");\n    const coordinateStore = tx.objectStore(\"coordinateStates\");\n    const chroniclesStore = tx.objectStore(\"chronicles\");\n    const staticPagesStore = tx.objectStore(\"staticPages\");\n    const eraNarrativesStore = hasEraNarrativesStore ? tx.objectStore(\"eraNarratives\") : null;\n\n    const deleteOps = [\n      deleteByIndex(entitiesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(relationshipsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(eventsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(chroniclesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(staticPagesStore, \"projectId\", projectId),\n    ];\n    if (eraNarrativesStore) {\n      deleteOps.push(deleteByIndex(eraNarrativesStore, \"simulationRunId\", simulationRunId));\n    }\n    await Promise.all(deleteOps);\n\n    const entities = Array.isArray(worldData.hardState)\n      ? worldData.hardState.map((entity: any) => ({ ...entity, simulationRunId }))\n      : [];\n    const relationships = Array.isArray(worldData.relationships)\n      ? worldData.relationships.map((rel: any) => ({ ...rel, simulationRunId }))\n      : [];\n    const narrativeEvents = Array.isArray(worldData.narrativeHistory)\n      ? worldData.narrativeHistory.map((event: any) => ({ ...event, simulationRunId }))\n      : [];\n\n    const slotRecord = {\n      projectId,\n      slotIndex,\n      simulationRunId,\n      finalTick: Number.isFinite(worldData.metadata?.tick) ? worldData.metadata.tick : null,\n      finalEraId: worldData.metadata?.era ?? null,\n      label: null,\n      isTemporary: slotIndex === 0,\n      updatedAt: Date.now(),\n    };\n\n    await Promise.all([\n      bulkPut(entitiesStore, entities),\n      bulkPut(relationshipsStore, relationships),\n      bulkPut(eventsStore, narrativeEvents),\n      requestToPromise(slotsStore.put(slotRecord)),\n      worldData.schema\n        ? requestToPromise(\n            schemasStore.put({ projectId, schema: worldData.schema, updatedAt: Date.now() })\n          )\n        : Promise.resolve(),\n      worldData.coordinateState\n        ? requestToPromise(\n            coordinateStore.put({\n              simulationRunId,\n              coordinateState: worldData.coordinateState,\n              updatedAt: Date.now(),\n            })\n          )\n        : Promise.resolve(),\n    ]);\n\n    if (Array.isArray(chronicles) && chronicles.length > 0) {\n      const normalizedChronicles = chronicles.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(chroniclesStore, normalizedChronicles);\n    }\n\n    if (Array.isArray(staticPages) && staticPages.length > 0) {\n      const normalizedPages = staticPages.map((page: any) => ({\n        ...page,\n        projectId: page.projectId || projectId,\n      }));\n      await bulkPut(staticPagesStore, normalizedPages);\n    }\n\n    if (eraNarrativesStore && Array.isArray(eraNarratives) && eraNarratives.length > 0) {\n      const normalizedNarratives = eraNarratives.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(eraNarrativesStore, normalizedNarratives);\n    }\n\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}", "type": "{\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::appendNarrativeEventsToDexie", "name": "appendNarrativeEventsToDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function appendNarrativeEventsToDexie(simulationRunId: string, events: any[]) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    const tx = db.transaction([\"narrativeEvents\"], \"readwrite\");\n    const store = tx.objectStore(\"narrativeEvents\");\n    const records = events.map((event) => ({ ...event, simulationRunId }));\n    await bulkPut(store, records);\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "any[]", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/compile.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./parser.js", "specifiers": ["parseCanon"], "category": "internal"}, {"source": "./types.js", "specifiers": ["AstFile", "BlockNode", "Diagnostic", "AttributeNode", "StatementNode", "Value", "ObjectValue", "ArrayValue", "IdentifierValue", "CallValue", "CompileResult", "StaticPagesCompileResult"], "category": "internal"}]}, {"id": "packages/canonry-dsl/src/compile.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/compile.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./parser.js", "specifiers": ["parseCanon"], "category": "internal"}, {"source": "./types.js", "specifiers": ["AstFile", "BlockNode", "Diagnostic", "AttributeNode", "StatementNode", "Value", "ObjectValue", "ArrayValue", "IdentifierValue", "CallValue", "CompileResult", "StaticPagesCompileResult"], "category": "internal"}]}, {"id": "packages/canonry-dsl/src/index.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/index.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/index.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/index.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/parser.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl/src/parser.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "peggy", "specifiers": ["peggy"], "category": "external"}, {"source": "./grammar.js", "specifiers": ["cannonGrammar"], "category": "internal"}, {"source": "./types.js", "specifiers": ["StatementNode"], "category": "internal"}]}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl/src/serialize.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl/src/serialize.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/compile.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/compile.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./parser.js", "specifiers": ["parseCanon"], "category": "internal"}, {"source": "./types.js", "specifiers": ["AstFile", "BlockNode", "Diagnostic", "AttributeNode", "StatementNode", "Value", "ObjectValue", "ArrayValue", "IdentifierValue", "CallValue", "CompileResult", "StaticPagesCompileResult"], "category": "internal"}]}, {"id": "packages/canonry-dsl-v2/src/compile.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/compile.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./parser.js", "specifiers": ["parseCanon"], "category": "internal"}, {"source": "./types.js", "specifiers": ["AstFile", "BlockNode", "Diagnostic", "AttributeNode", "StatementNode", "Value", "ObjectValue", "ArrayValue", "IdentifierValue", "CallValue", "CompileResult", "StaticPagesCompileResult"], "category": "internal"}]}, {"id": "packages/canonry-dsl-v2/src/index.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/index.ts::compileCanonProject", "name": "compileCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function compileCanonProject(files: SourceFile[]): CompileResult<Record<string, unknown>> {\n  const diagnostics: Diagnostic[] = [];\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    try {\n      const statements = parseCanon(file.content, file.path);\n      astFiles.push({ path: file.path, statements });\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n    }\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const allBlocks = collectTopLevelBlocks(expandedFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const { blocks: blocksWithoutSets, sets } = collectSetDefinitions(allBlocks, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const resources = collectResourceRegistry(blocksWithoutSets);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { config: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, resources, sets, diagnostics);\n  return withEvalContext(evalContext, () => {\n    const { blocks: filteredBlocks, resources: namingResources } = collectNamingResources(blocksWithoutSets, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n    const config: Record<string, unknown> = {};\n    const seenSingletons = new Set<string>();\n    const seenIds: Record<string, Map<string, { span: BlockNode['span'] }>> = {};\n\n    for (const block of filteredBlocks) {\n      if (block.name === 'relationships') {\n        const groupItems = buildSeedRelationshipGroup(block, diagnostics);\n        if (groupItems.length > 0) {\n          if (!config.seedRelationships) config.seedRelationships = [];\n          const list = config.seedRelationships as Record<string, unknown>[];\n          list.push(...groupItems);\n        }\n        continue;\n      }\n\n      const mapping = BLOCK_MAPPINGS[block.name];\n      if (!mapping) {\n        if (block.name === 'static_page') {\n          continue;\n        }\n        diagnostics.push({\n          severity: 'error',\n          message: `Unknown block type \"${block.name}\"`,\n          span: block.span\n        });\n        continue;\n      }\n\n      if (mapping.singleton) {\n        if (seenSingletons.has(mapping.target)) {\n          diagnostics.push({\n            severity: 'error',\n            message: `Duplicate singleton block for \"${mapping.target}\"`,\n            span: block.span\n          });\n          continue;\n        }\n        seenSingletons.add(mapping.target);\n        const singletonValue = mapping.buildItem\n          ? mapping.buildItem(block, diagnostics)\n          : buildObjectFromStatements(block.body, diagnostics, block);\n        if (singletonValue) {\n          if (mapping.mergeIntoRoot) {\n            for (const [key, value] of Object.entries(singletonValue)) {\n              if (key in config) {\n                diagnostics.push({\n                  severity: 'error',\n                  message: `Duplicate project field \"${key}\"`,\n                  span: block.span\n                });\n                continue;\n              }\n              config[key] = value;\n            }\n          } else {\n            config[mapping.target] = singletonValue;\n          }\n        }\n        continue;\n      }\n\n      const item = mapping.buildItem\n        ? mapping.buildItem(block, diagnostics)\n        : buildItemFromBlock(block, mapping, diagnostics);\n      if (!item) continue;\n\n      const target = mapping.target;\n      if (!config[target]) config[target] = [];\n      const list = config[target] as Record<string, unknown>[];\n\n      if (mapping.idKey) {\n        const idValue = item[mapping.idKey];\n        if (typeof idValue === 'string') {\n          if (!seenIds[target]) seenIds[target] = new Map();\n          const existing = seenIds[target].get(idValue);\n          if (existing) {\n            diagnostics.push({\n              severity: 'error',\n              message: `Duplicate ${mapping.idKey} \"${idValue}\" in ${target}`,\n              span: block.span\n            });\n            continue;\n          }\n          seenIds[target].set(idValue, { span: block.span });\n        }\n      }\n\n      list.push(item);\n    }\n\n    if (!seenSingletons.has('project')) {\n      diagnostics.push({\n        severity: 'error',\n        message: 'Missing required project block',\n        span: undefined\n      });\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    for (const [, mapping] of Object.entries(BLOCK_MAPPINGS)) {\n      if (mapping.singleton) continue;\n      const target = mapping.target;\n      const list = config[target] as Record<string, unknown>[] | undefined;\n      if (!list || list.length === 0) continue;\n      const sortKey = mapping.sortKey || DEFAULT_SORT(mapping.idKey);\n      list.sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n    }\n\n    validateSeedRelationships(config, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    applyNamingResources(config, namingResources, diagnostics);\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { config: null, diagnostics };\n    }\n\n    return { config, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "SourceFile[]", "optional": false}], "returnType": "CompileResult<Record<string, unknown>>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/index.ts::compileCanonStaticPages", "name": "compileCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function compileCanonStaticPages(\n  files: Array<{ path: string; content: string }>\n): StaticPagesCompileResult {\n  const diagnostics: Diagnostic[] = [];\n  const pages: Record<string, unknown>[] = [];\n  const contentByPath = new Map<string, string>();\n  const astFiles: AstFile[] = [];\n\n  for (const file of files) {\n    contentByPath.set(file.path, file.content);\n  }\n\n  const canonFiles = files.filter(file => file.path.endsWith('.canon'));\n  for (const file of canonFiles) {\n    let statements: StatementNode[];\n    try {\n      statements = parseCanon(file.content, file.path);\n    } catch (error) {\n      const err = error as { message?: string; location?: { start: { line: number; column: number; offset: number }; end: { line: number; column: number; offset: number } } };\n      diagnostics.push({\n        severity: 'error',\n        message: err.message || 'Failed to parse .canon file',\n        span: err.location\n          ? {\n              file: file.path,\n              start: err.location.start,\n              end: err.location.end\n            }\n          : { file: file.path, start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }\n      });\n      continue;\n    }\n    astFiles.push({ path: file.path, statements });\n  }\n\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  validateTextFormatting(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const { files: filteredFiles, variables } = collectVariables(astFiles, diagnostics);\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const expandedFiles = filteredFiles.map((file) => ({\n    ...file,\n    statements: expandStatements(file.statements, diagnostics)\n  }));\n  if (diagnostics.some(d => d.severity === 'error')) {\n    return { pages: null, diagnostics };\n  }\n\n  const evalContext = createEvalContext(variables, new Map(), new Map(), diagnostics);\n  return withEvalContext(evalContext, () => {\n    for (const file of expandedFiles) {\n      for (const stmt of file.statements) {\n        if (stmt.type !== 'block' || stmt.name !== 'static_page') continue;\n        const page = buildStaticPageFromBlock(stmt, contentByPath, diagnostics);\n        if (page) pages.push(page);\n      }\n    }\n\n    if (diagnostics.some(d => d.severity === 'error')) {\n      return { pages: null, diagnostics };\n    }\n\n    return { pages, diagnostics };\n  });\n}", "parameters": [{"name": "files", "type": "Array<{ path: string; content: string }>", "optional": false}], "returnType": "StaticPagesCompileResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/index.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/index.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/index.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/parser.ts::parseCanon", "name": "parseCanon", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/parser.ts", "sourceCode": "export function parseCanon(source: string, file: string): StatementNode[] {\n  return parser.parse(source, { file }) as StatementNode[];\n}", "parameters": [{"name": "source", "type": "string", "optional": false}, {"name": "file", "type": "string", "optional": false}], "returnType": "StatementNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "peggy", "specifiers": ["peggy"], "category": "external"}, {"source": "./grammar.js", "specifiers": ["cannonGrammar"], "category": "internal"}, {"source": "./types.js", "specifiers": ["StatementNode"], "category": "internal"}]}, {"id": "packages/canonry-dsl-v2/src/serialize.ts::serializeCanonProject", "name": "serializeCanonProject", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/serialize.ts", "sourceCode": "export function serializeCanonProject(\n  project: Record<string, unknown>,\n  options: SerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const files: CanonFile[] = [];\n\n  const projectFields: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(project)) {\n    if (ROOT_KEYS.has(key)) continue;\n    if (value === undefined) continue;\n    projectFields[key] = value;\n  }\n\n  files.push({\n    path: PROJECT_FILE,\n    content: formatBlock('project', [], projectFields)\n  });\n\n  for (const def of SINGLETONS) {\n    const value = project[def.key];\n    if (value === undefined || value === null) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n    const body = isRecord(value) ? value : { value };\n    if (def.block === 'distribution_targets') {\n      const content = isRecord(body) ? formatDistributionTargetsBlock(body) : null;\n      files.push({ path: def.file, content: content ?? '' });\n      continue;\n    }\n    files.push({ path: def.file, content: formatBlock(def.block, [], body) });\n  }\n\n  for (const def of COLLECTIONS) {\n    const raw = project[def.key];\n    const items = Array.isArray(raw) ? raw.slice() : [];\n    if (items.length === 0) {\n      if (includeEmpty) {\n        files.push({ path: def.file, content: '' });\n      }\n      continue;\n    }\n\n    if (def.block === 'seed_relationship') {\n      const blocks = formatSeedRelationshipGroups(items.filter(isRecord));\n      files.push({\n        path: def.file,\n        content: blocks.join('\\n\\n')\n      });\n      continue;\n    }\n\n    items.sort((a, b) => {\n      if (!isRecord(a) || !isRecord(b)) return 0;\n      if (def.sortKey) return def.sortKey(a).localeCompare(def.sortKey(b));\n      if (!def.idKey) return 0;\n      const aValue = a[def.idKey];\n      const bValue = b[def.idKey];\n      if (typeof aValue !== 'string' || typeof bValue !== 'string') return 0;\n      return aValue.localeCompare(bValue);\n    });\n\n    const blocks: string[] = [];\n    const namingBlocks =\n      def.block === 'culture'\n        ? formatNamingResourceBlocks(collectNamingResourcesFromCultures(items.filter(isRecord)))\n        : null;\n    for (const item of items) {\n      if (!isRecord(item)) continue;\n      if (def.block === 'system') {\n        const block = formatSystemBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'axis') {\n        const line = formatAxisLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'relationship_kind') {\n        const line = formatRelationshipKindLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'tag') {\n        const line = formatTagLine(item);\n        if (line) blocks.push(line);\n        continue;\n      }\n      if (def.block === 'seed_relationship') {\n        const block = formatSeedRelationshipBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'seed_entity') {\n        const block = formatSeedEntityBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'entity_kind') {\n        const block = formatEntityKindBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'era') {\n        const block = formatEraBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'culture') {\n        const block = formatCultureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'action') {\n        const block = formatActionBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n      if (def.block === 'pressure') {\n        const block = formatPressureBlock(item);\n        if (block) blocks.push(block);\n        continue;\n      }\n\n      const body = { ...item };\n      const labels: string[] = [];\n      if (def.idKey && typeof body[def.idKey] === 'string') {\n        labels.push(body[def.idKey] as string);\n        delete body[def.idKey];\n      }\n      if (def.nameKey && typeof body[def.nameKey] === 'string') {\n        labels.push(body[def.nameKey] as string);\n        delete body[def.nameKey];\n      }\n\n      blocks.push(formatBlock(def.block, labels, body));\n    }\n\n    if (namingBlocks && namingBlocks.length > 0) {\n      blocks.push(...namingBlocks);\n    }\n\n    files.push({\n      path: def.file,\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "project", "type": "Record<string, unknown>", "optional": false}, {"name": "options", "type": "SerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/canonry-dsl-v2/src/serialize.ts::serializeCanonStaticPages", "name": "serializeCanonStaticPages", "kind": "function", "filePath": "packages/canonry-dsl-v2/src/serialize.ts", "sourceCode": "export function serializeCanonStaticPages(\n  pages: StaticPageRecord[],\n  options: StaticPageSerializeOptions = {}\n): CanonFile[] {\n  const includeEmpty = options.includeEmpty ?? true;\n  const pageDir = normalizeStaticPageDir(options.pageDir ?? 'page');\n  const pagePrefix = pageDir ? `${pageDir}/` : '';\n  const files: CanonFile[] = [];\n  const blocks: string[] = [];\n  const usedNames = new Set<string>();\n\n  for (const page of pages || []) {\n    if (!isRecord(page)) continue;\n    const title = typeof page.title === 'string' && page.title.length > 0 ? page.title : 'Untitled';\n    const inferredSlug = generateStaticPageSlug(title);\n    const slug = typeof page.slug === 'string' && page.slug.length > 0 ? page.slug : inferredSlug;\n    const filename = resolveStaticPageFilename(slug, usedNames);\n    const outputPath = `${pagePrefix}${filename}`;\n\n    const blockLines: string[] = [];\n    blockLines.push(`static_page ${formatLabel(title)} do`);\n\n    const remaining: Record<string, unknown> = { ...page };\n    delete remaining.title;\n    delete remaining.slug;\n    delete remaining.content;\n\n    if (page.seedId !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', page.seedId, 1);\n      delete remaining.seedId;\n    } else if ((remaining).seed_id !== undefined) {\n      pushAttributeLine(blockLines, 'seedId', (remaining).seed_id, 1);\n      delete (remaining).seed_id;\n    }\n\n    if (page.summary !== undefined) {\n      pushAttributeLine(blockLines, 'summary', page.summary, 1);\n      delete remaining.summary;\n    }\n\n    if (page.status !== undefined) {\n      pushAttributeLine(blockLines, 'status', page.status, 1);\n      delete remaining.status;\n    }\n\n    if (page.slug !== undefined && page.slug !== inferredSlug) {\n      pushAttributeLine(blockLines, 'slug', page.slug, 1);\n    }\n\n    const extraLines = formatAttributeLines(remaining, 1);\n    if (extraLines.length > 0) {\n      blockLines.push(...extraLines);\n    }\n\n    blockLines.push(`${indent(1)}content read(${quoteString(outputPath)})`);\n    blockLines.push('end');\n    blocks.push(blockLines.join('\\n'));\n\n    files.push({\n      path: outputPath,\n      content: typeof page.content === 'string' ? page.content : ''\n    });\n  }\n\n  if (blocks.length > 0 || includeEmpty) {\n    files.unshift({\n      path: 'static_pages.canon',\n      content: blocks.join('\\n\\n')\n    });\n  }\n\n  return files;\n}", "parameters": [{"name": "pages", "type": "StaticPageRecord[]", "optional": false}, {"name": "options", "type": "StaticPageSerializeOptions", "optional": true}], "returnType": "CanonFile[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/eventFiltering.ts::isProminenceOnlyEvent", "name": "isProminenceOnlyEvent", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Check if an event is prominence-only for a given entity.\r\n * An event is \"prominence-only\" if ALL of its effects on the entity are\r\n * field_changed effects where field === 'prominence'.\r\n *\r\n * These events are typically noise (gradual prominence changes) rather than\r\n * narratively interesting happenings.\r\n */\r\nexport function isProminenceOnlyEvent(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): boolean {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  if (!participant || participant.effects.length === 0) return false;\r\n\r\n  // Check if ALL effects are prominence field changes\r\n  return participant.effects.every(\r\n    effect => effect.type === 'field_changed' && effect.field === 'prominence'\r\n  );\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["NarrativeEvent", "EntityEffect"], "category": "internal"}]}, {"id": "packages/world-schema/src/eventFiltering.ts::getEntityEffects", "name": "getEntityEffects", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Get effects for a specific entity from an event\r\n */\r\nexport function getEntityEffects(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): EntityEffect[] {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  return participant?.effects ?? [];\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "EntityEffect[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["NarrativeEvent", "EntityEffect"], "category": "internal"}]}, {"id": "packages/world-schema/src/eventFiltering.ts::getEntityEvents", "name": "getEntityEvents", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Get filtered events for an entity from narrative history.\r\n *\r\n * Applies filters:\r\n * 1. Entity must appear in participantEffects\r\n * 2. Exclude prominence-only events (if enabled)\r\n * 3. Significance >= minSignificance\r\n *\r\n * Results are sorted chronologically (by tick).\r\n */\r\nexport function getEntityEvents(\r\n  narrativeHistory: NarrativeEvent[],\r\n  options: EventFilterOptions\r\n): NarrativeEvent[] {\r\n  const {\r\n    entityId,\r\n    minSignificance = 0,\r\n    excludeProminenceOnly = true,\r\n    limit,\r\n  } = options;\r\n\r\n  const filtered = narrativeHistory\r\n    .filter(event => {\r\n      // Entity must appear in participantEffects\r\n      if (!event.participantEffects?.some(p => p.entity.id === entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Exclude prominence-only events if configured\r\n      if (excludeProminenceOnly && isProminenceOnlyEvent(event, entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Filter by significance threshold\r\n      if (event.significance < minSignificance) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    })\r\n    .sort((a, b) => a.tick - b.tick); // Chronological order\r\n\r\n  return limit ? filtered.slice(0, limit) : filtered;\r\n}", "parameters": [{"name": "narrativeHistory", "type": "NarrativeEvent[]", "optional": false}, {"name": "options", "type": "EventFilterOptions", "optional": false}], "returnType": "NarrativeEvent[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["NarrativeEvent", "EntityEffect"], "category": "internal"}]}, {"id": "packages/world-schema/src/eventFiltering.ts::formatEventForPrompt", "name": "formatEventForPrompt", "kind": "function", "filePath": "packages/world-schema/src/eventFiltering.ts", "sourceCode": "/**\r\n * Format an event for inclusion in a prompt.\r\n * Produces a concise one-line summary.\r\n */\r\nexport function formatEventForPrompt(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): string {\r\n  const effects = getEntityEffects(event, entityId);\r\n\r\n  // Use the event description, or summarize effects\r\n  if (event.description) {\r\n    return `[Tick ${event.tick}] ${event.description}`;\r\n  }\r\n\r\n  // Fallback: summarize effects\r\n  const effectSummary = effects\r\n    .map(e => e.description)\r\n    .filter(Boolean)\r\n    .join('; ');\r\n\r\n  return `[Tick ${event.tick}] ${effectSummary || event.action}`;\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["NarrativeEvent", "EntityEffect"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkEntityKind", "name": "isFrameworkEntityKind", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "// ===========================\n// TYPE GUARDS\n// ===========================\n\nexport function isFrameworkEntityKind(kind: string): kind is FrameworkEntityKind {\n  return FRAMEWORK_ENTITY_KIND_VALUES.includes(kind as FrameworkEntityKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkEntityKind", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkRelationshipKind", "name": "isFrameworkRelationshipKind", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkRelationshipKind(kind: string): kind is FrameworkRelationshipKind {\n  return FRAMEWORK_RELATIONSHIP_KIND_VALUES.includes(kind as FrameworkRelationshipKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkRelationshipKind", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkStatus", "name": "isFrameworkStatus", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkStatus(status: string): status is FrameworkStatus {\n  return FRAMEWORK_STATUS_VALUES.includes(status as FrameworkStatus);\n}", "parameters": [{"name": "status", "type": "string", "optional": false}], "returnType": "status is FrameworkStatus", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkSubtype", "name": "isFrameworkSubtype", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkSubtype(subtype: string): subtype is FrameworkSubtype {\n  return FRAMEWORK_SUBTYPE_VALUES.includes(subtype as FrameworkSubtype);\n}", "parameters": [{"name": "subtype", "type": "string", "optional": false}], "returnType": "subtype is FrameworkSubtype", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::isFrameworkTag", "name": "isFrameworkTag", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function isFrameworkTag(tag: string): tag is FrameworkTag {\n  return FRAMEWORK_TAG_VALUES.includes(tag as FrameworkTag);\n}", "parameters": [{"name": "tag", "type": "string", "optional": false}], "returnType": "tag is FrameworkTag", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::getFrameworkRelationshipStrength", "name": "getFrameworkRelationshipStrength", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "export function getFrameworkRelationshipStrength(kind: FrameworkRelationshipKind): number {\n  return FRAMEWORK_RELATIONSHIP_PROPERTIES[kind].defaultStrength;\n}", "parameters": [{"name": "kind", "type": "FrameworkRelationshipKind", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/frameworkPrimitives.ts::mergeFrameworkSchemaSlice", "name": "mergeFrameworkSchemaSlice", "kind": "function", "filePath": "packages/world-schema/src/frameworkPrimitives.ts", "sourceCode": "// ===========================\n// SCHEMA MERGE HELPERS\n// ===========================\n\nexport function mergeFrameworkSchemaSlice(schema: CanonrySchemaSlice): CanonrySchemaSlice {\n  const entityOverrides = new Map(\n    (schema.entityKinds || []).map(item => [item.kind, item])\n  );\n  const relationshipOverrides = new Map(\n    (schema.relationshipKinds || []).map(item => [item.kind, item])\n  );\n  const cultureOverrides = new Map(\n    (schema.cultures || []).map(item => [item.id, item])\n  );\n  const tagOverrides = new Map(\n    (schema.tagRegistry || []).map(item => [item.tag, item])\n  );\n\n  const frameworkEntityKindIds = new Set(FRAMEWORK_ENTITY_KIND_VALUES.map(String));\n  const frameworkRelationshipKindIds = new Set(FRAMEWORK_RELATIONSHIP_KIND_VALUES.map(String));\n  const frameworkCultureIds = new Set(Object.values(FRAMEWORK_CULTURES).map(String));\n  const frameworkTagIds = new Set(FRAMEWORK_TAG_VALUES.map(String));\n\n  const mergeSubtypes = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.subtypes.map(s => s.id));\n    const extra = (override?.subtypes || []).filter(s => !seen.has(s.id));\n    return [...base.subtypes, ...extra];\n  };\n\n  const mergeStatuses = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.statuses.map(s => s.id));\n    const extra = (override?.statuses || []).filter(s => !seen.has(s.id));\n    return [...base.statuses, ...extra];\n  };\n\n  const mergeRequiredRelationships = (\n    base: EntityKindDefinition,\n    override?: EntityKindDefinition\n  ) => {\n    const baseRules = base.requiredRelationships || [];\n    const seen = new Set(baseRules.map(r => r.kind));\n    const extra = (override?.requiredRelationships || []).filter(r => !seen.has(r.kind));\n    return baseRules.length > 0 || extra.length > 0 ? [...baseRules, ...extra] : undefined;\n  };\n\n  const mergedEntityKinds = [\n    ...FRAMEWORK_ENTITY_KIND_DEFINITIONS.map((base) => {\n      const override = entityOverrides.get(base.kind);\n      const merged: EntityKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        subtypes: mergeSubtypes(base, override),\n        statuses: mergeStatuses(base, override),\n        requiredRelationships: mergeRequiredRelationships(base, override),\n        style: { ...(base.style || {}), ...(override?.style || {}) },\n        semanticPlane: override?.semanticPlane ?? base.semanticPlane,\n        defaultStatus: override?.defaultStatus ?? base.defaultStatus,\n      };\n      return merged;\n    }),\n    ...(schema.entityKinds || []).filter(item => !frameworkEntityKindIds.has(String(item.kind))),\n  ];\n\n  const mergedRelationshipKinds = [\n    ...FRAMEWORK_RELATIONSHIP_KIND_DEFINITIONS.map((base) => {\n      const override = relationshipOverrides.get(base.kind);\n      const merged: RelationshipKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        srcKinds: (override?.srcKinds && override.srcKinds.length > 0)\n          ? override.srcKinds\n          : base.srcKinds,\n        dstKinds: (override?.dstKinds && override.dstKinds.length > 0)\n          ? override.dstKinds\n          : base.dstKinds,\n        cullable: base.cullable,\n        decayRate: base.decayRate,\n      };\n      return merged;\n    }),\n    ...(schema.relationshipKinds || []).filter(item => !frameworkRelationshipKindIds.has(String(item.kind))),\n  ];\n\n  const mergedCultures = [\n    ...FRAMEWORK_CULTURE_DEFINITIONS.map((base) => {\n      const override = cultureOverrides.get(base.id);\n      const merged: CultureDefinition = {\n        ...base,\n        ...(override || {}),\n        id: base.id,\n        isFramework: true,\n        name: base.name,\n        description: base.description ?? override?.description,\n        color: base.color ?? override?.color,\n        naming: override?.naming ?? base.naming,\n        axisBiases: override?.axisBiases ?? base.axisBiases,\n        homeRegions: override?.homeRegions ?? base.homeRegions,\n      };\n      return merged;\n    }),\n    ...(schema.cultures || []).filter(item => !frameworkCultureIds.has(String(item.id))),\n  ];\n\n  const mergedTags = [\n    ...FRAMEWORK_TAG_DEFINITIONS.map((base) => {\n      const override = tagOverrides.get(base.tag);\n      const merged: TagDefinition = {\n        ...base,\n        ...(override || {}),\n        tag: base.tag,\n        isFramework: true,\n      };\n      return merged;\n    }),\n    ...(schema.tagRegistry || []).filter(item => !frameworkTagIds.has(String(item.tag))),\n  ];\n\n  return {\n    ...schema,\n    entityKinds: mergedEntityKinds,\n    relationshipKinds: mergedRelationshipKinds,\n    cultures: mergedCultures,\n    tagRegistry: mergedTags,\n  };\n}", "parameters": [{"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "CanonrySchemaSlice", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./entityKind.js", "specifiers": ["EntityKindDefinition"], "category": "internal"}, {"source": "./relationship.js", "specifiers": ["RelationshipKindDefinition"], "category": "internal"}, {"source": "./culture.js", "specifiers": ["CultureDefinition"], "category": "internal"}, {"source": "./mfeContracts.js", "specifiers": ["CanonrySchemaSlice", "TagDefinition"], "category": "internal"}]}, {"id": "packages/world-schema/src/index.ts::createDefaultStyleLibrary", "name": "createDefaultStyleLibrary", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Create a default style library\n */\nexport function createDefaultStyleLibrary(): StyleLibrary {\n  return {\n    artisticStyles: [...DEFAULT_ARTISTIC_STYLES],\n    compositionStyles: [...DEFAULT_COMPOSITION_STYLES],\n    colorPalettes: [...DEFAULT_COLOR_PALETTES],\n    narrativeStyles: [...DEFAULT_NARRATIVE_STYLES, ...DEFAULT_DOCUMENT_STYLES],\n  };\n}", "parameters": [], "returnType": "StyleLibrary", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::findArtisticStyle", "name": "findArtisticStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find an artistic style by ID\n */\nexport function findArtisticStyle(library: StyleLibrary, id: string): ArtisticStyle | undefined {\n  return library.artisticStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ArtisticStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::findCompositionStyle", "name": "findCompositionStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a composition style by ID\n */\nexport function findCompositionStyle(library: StyleLibrary, id: string): CompositionStyle | undefined {\n  return library.compositionStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "CompositionStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::findColorPalette", "name": "findColorPalette", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a color palette by ID\n */\nexport function findColorPalette(library: StyleLibrary, id: string): ColorPalette | undefined {\n  return library.colorPalettes.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ColorPalette | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::findNarrativeStyle", "name": "findNarrativeStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Find a narrative style by ID\n */\nexport function findNarrativeStyle(library: StyleLibrary, id: string): NarrativeStyle | undefined {\n  return library.narrativeStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "NarrativeStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isFrameworkEntityKind", "name": "isFrameworkEntityKind", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// ===========================\n// TYPE GUARDS\n// ===========================\n\nexport function isFrameworkEntityKind(kind: string): kind is FrameworkEntityKind {\n  return FRAMEWORK_ENTITY_KIND_VALUES.includes(kind as FrameworkEntityKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkEntityKind", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isFrameworkRelationshipKind", "name": "isFrameworkRelationshipKind", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkRelationshipKind(kind: string): kind is FrameworkRelationshipKind {\n  return FRAMEWORK_RELATIONSHIP_KIND_VALUES.includes(kind as FrameworkRelationshipKind);\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "kind is FrameworkRelationshipKind", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isFrameworkStatus", "name": "isFrameworkStatus", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkStatus(status: string): status is FrameworkStatus {\n  return FRAMEWORK_STATUS_VALUES.includes(status as FrameworkStatus);\n}", "parameters": [{"name": "status", "type": "string", "optional": false}], "returnType": "status is FrameworkStatus", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isFrameworkSubtype", "name": "isFrameworkSubtype", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkSubtype(subtype: string): subtype is FrameworkSubtype {\n  return FRAMEWORK_SUBTYPE_VALUES.includes(subtype as FrameworkSubtype);\n}", "parameters": [{"name": "subtype", "type": "string", "optional": false}], "returnType": "subtype is FrameworkSubtype", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isFrameworkTag", "name": "isFrameworkTag", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function isFrameworkTag(tag: string): tag is FrameworkTag {\n  return FRAMEWORK_TAG_VALUES.includes(tag as FrameworkTag);\n}", "parameters": [{"name": "tag", "type": "string", "optional": false}], "returnType": "tag is FrameworkTag", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::getFrameworkRelationshipStrength", "name": "getFrameworkRelationshipStrength", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function getFrameworkRelationshipStrength(kind: FrameworkRelationshipKind): number {\n  return FRAMEWORK_RELATIONSHIP_PROPERTIES[kind].defaultStrength;\n}", "parameters": [{"name": "kind", "type": "FrameworkRelationshipKind", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::mergeFrameworkSchemaSlice", "name": "mergeFrameworkSchemaSlice", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "// ===========================\n// SCHEMA MERGE HELPERS\n// ===========================\n\nexport function mergeFrameworkSchemaSlice(schema: CanonrySchemaSlice): CanonrySchemaSlice {\n  const entityOverrides = new Map(\n    (schema.entityKinds || []).map(item => [item.kind, item])\n  );\n  const relationshipOverrides = new Map(\n    (schema.relationshipKinds || []).map(item => [item.kind, item])\n  );\n  const cultureOverrides = new Map(\n    (schema.cultures || []).map(item => [item.id, item])\n  );\n  const tagOverrides = new Map(\n    (schema.tagRegistry || []).map(item => [item.tag, item])\n  );\n\n  const frameworkEntityKindIds = new Set(FRAMEWORK_ENTITY_KIND_VALUES.map(String));\n  const frameworkRelationshipKindIds = new Set(FRAMEWORK_RELATIONSHIP_KIND_VALUES.map(String));\n  const frameworkCultureIds = new Set(Object.values(FRAMEWORK_CULTURES).map(String));\n  const frameworkTagIds = new Set(FRAMEWORK_TAG_VALUES.map(String));\n\n  const mergeSubtypes = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.subtypes.map(s => s.id));\n    const extra = (override?.subtypes || []).filter(s => !seen.has(s.id));\n    return [...base.subtypes, ...extra];\n  };\n\n  const mergeStatuses = (base: EntityKindDefinition, override?: EntityKindDefinition) => {\n    const seen = new Set(base.statuses.map(s => s.id));\n    const extra = (override?.statuses || []).filter(s => !seen.has(s.id));\n    return [...base.statuses, ...extra];\n  };\n\n  const mergeRequiredRelationships = (\n    base: EntityKindDefinition,\n    override?: EntityKindDefinition\n  ) => {\n    const baseRules = base.requiredRelationships || [];\n    const seen = new Set(baseRules.map(r => r.kind));\n    const extra = (override?.requiredRelationships || []).filter(r => !seen.has(r.kind));\n    return baseRules.length > 0 || extra.length > 0 ? [...baseRules, ...extra] : undefined;\n  };\n\n  const mergedEntityKinds = [\n    ...FRAMEWORK_ENTITY_KIND_DEFINITIONS.map((base) => {\n      const override = entityOverrides.get(base.kind);\n      const merged: EntityKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        subtypes: mergeSubtypes(base, override),\n        statuses: mergeStatuses(base, override),\n        requiredRelationships: mergeRequiredRelationships(base, override),\n        style: { ...(base.style || {}), ...(override?.style || {}) },\n        semanticPlane: override?.semanticPlane ?? base.semanticPlane,\n        defaultStatus: override?.defaultStatus ?? base.defaultStatus,\n      };\n      return merged;\n    }),\n    ...(schema.entityKinds || []).filter(item => !frameworkEntityKindIds.has(String(item.kind))),\n  ];\n\n  const mergedRelationshipKinds = [\n    ...FRAMEWORK_RELATIONSHIP_KIND_DEFINITIONS.map((base) => {\n      const override = relationshipOverrides.get(base.kind);\n      const merged: RelationshipKindDefinition = {\n        ...base,\n        ...(override || {}),\n        kind: base.kind,\n        isFramework: true,\n        srcKinds: (override?.srcKinds && override.srcKinds.length > 0)\n          ? override.srcKinds\n          : base.srcKinds,\n        dstKinds: (override?.dstKinds && override.dstKinds.length > 0)\n          ? override.dstKinds\n          : base.dstKinds,\n        cullable: base.cullable,\n        decayRate: base.decayRate,\n      };\n      return merged;\n    }),\n    ...(schema.relationshipKinds || []).filter(item => !frameworkRelationshipKindIds.has(String(item.kind))),\n  ];\n\n  const mergedCultures = [\n    ...FRAMEWORK_CULTURE_DEFINITIONS.map((base) => {\n      const override = cultureOverrides.get(base.id);\n      const merged: CultureDefinition = {\n        ...base,\n        ...(override || {}),\n        id: base.id,\n        isFramework: true,\n        name: base.name,\n        description: base.description ?? override?.description,\n        color: base.color ?? override?.color,\n        naming: override?.naming ?? base.naming,\n        axisBiases: override?.axisBiases ?? base.axisBiases,\n        homeRegions: override?.homeRegions ?? base.homeRegions,\n      };\n      return merged;\n    }),\n    ...(schema.cultures || []).filter(item => !frameworkCultureIds.has(String(item.id))),\n  ];\n\n  const mergedTags = [\n    ...FRAMEWORK_TAG_DEFINITIONS.map((base) => {\n      const override = tagOverrides.get(base.tag);\n      const merged: TagDefinition = {\n        ...base,\n        ...(override || {}),\n        tag: base.tag,\n        isFramework: true,\n      };\n      return merged;\n    }),\n    ...(schema.tagRegistry || []).filter(item => !frameworkTagIds.has(String(item.tag))),\n  ];\n\n  return {\n    ...schema,\n    entityKinds: mergedEntityKinds,\n    relationshipKinds: mergedRelationshipKinds,\n    cultures: mergedCultures,\n    tagRegistry: mergedTags,\n  };\n}", "parameters": [{"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "CanonrySchemaSlice", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::buildProminenceScale", "name": "buildProminenceScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function buildProminenceScale(\n  values: number[],\n  options: BuildProminenceScaleOptions = {}\n): ProminenceScale {\n  const labels = options.labels ?? PROMINENCE_LABELS;\n  const min = typeof options.min === 'number' ? options.min : DEFAULT_MIN;\n  const max = typeof options.max === 'number' ? options.max : DEFAULT_MAX;\n  const distribution = normalizeDistribution(\n    options.distribution ?? DEFAULT_PROMINENCE_DISTRIBUTION,\n    labels.length\n  );\n\n  const numericValues = values.filter((value) => Number.isFinite(value)).sort((a, b) => a - b);\n\n  if (numericValues.length === 0) {\n    return {\n      labels,\n      distribution,\n      thresholds: defaultThresholds(min, max, labels.length),\n      min,\n      max,\n    };\n  }\n\n  const thresholds: number[] = [];\n  let cumulative = 0;\n  for (let i = 0; i < labels.length - 1; i += 1) {\n    cumulative += distribution[i];\n    thresholds.push(clamp(quantile(numericValues, cumulative), min, max));\n  }\n\n  return {\n    labels,\n    distribution,\n    thresholds,\n    min,\n    max,\n  };\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}, {"name": "options", "type": "BuildProminenceScaleOptions", "optional": true}], "returnType": "ProminenceScale", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::prominenceLabelFromScale", "name": "prominenceLabelFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceLabelFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): ProminenceLabel {\n  if (typeof value === 'string' && scale.labels.includes(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'number' || !Number.isFinite(value)) {\n    return scale.labels[0];\n  }\n\n  for (let i = 0; i < scale.thresholds.length; i += 1) {\n    if (value < scale.thresholds[i]) {\n      return scale.labels[i];\n    }\n  }\n\n  return scale.labels[scale.labels.length - 1];\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "ProminenceLabel", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::prominenceThresholdFromScale", "name": "prominenceThresholdFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceThresholdFromScale(label: ProminenceLabel, scale: ProminenceScale): number {\n  const index = scale.labels.indexOf(label);\n  if (index <= 0) return scale.min;\n  return scale.thresholds[index - 1] ?? scale.max;\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::prominenceIndexFromScale", "name": "prominenceIndexFromScale", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "export function prominenceIndexFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): number {\n  const label = prominenceLabelFromScale(value, scale);\n  const index = scale.labels.indexOf(label);\n  return index >= 0 ? index : 0;\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::isProminenceOnlyEvent", "name": "isProminenceOnlyEvent", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Check if an event is prominence-only for a given entity.\r\n * An event is \"prominence-only\" if ALL of its effects on the entity are\r\n * field_changed effects where field === 'prominence'.\r\n *\r\n * These events are typically noise (gradual prominence changes) rather than\r\n * narratively interesting happenings.\r\n */\r\nexport function isProminenceOnlyEvent(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): boolean {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  if (!participant || participant.effects.length === 0) return false;\r\n\r\n  // Check if ALL effects are prominence field changes\r\n  return participant.effects.every(\r\n    effect => effect.type === 'field_changed' && effect.field === 'prominence'\r\n  );\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::getEntityEffects", "name": "getEntityEffects", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Get effects for a specific entity from an event\r\n */\r\nexport function getEntityEffects(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): EntityEffect[] {\r\n  const participant = event.participantEffects?.find(p => p.entity.id === entityId);\r\n  return participant?.effects ?? [];\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "EntityEffect[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::getEntityEvents", "name": "getEntityEvents", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Get filtered events for an entity from narrative history.\r\n *\r\n * Applies filters:\r\n * 1. Entity must appear in participantEffects\r\n * 2. Exclude prominence-only events (if enabled)\r\n * 3. Significance >= minSignificance\r\n *\r\n * Results are sorted chronologically (by tick).\r\n */\r\nexport function getEntityEvents(\r\n  narrativeHistory: NarrativeEvent[],\r\n  options: EventFilterOptions\r\n): NarrativeEvent[] {\r\n  const {\r\n    entityId,\r\n    minSignificance = 0,\r\n    excludeProminenceOnly = true,\r\n    limit,\r\n  } = options;\r\n\r\n  const filtered = narrativeHistory\r\n    .filter(event => {\r\n      // Entity must appear in participantEffects\r\n      if (!event.participantEffects?.some(p => p.entity.id === entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Exclude prominence-only events if configured\r\n      if (excludeProminenceOnly && isProminenceOnlyEvent(event, entityId)) {\r\n        return false;\r\n      }\r\n\r\n      // Filter by significance threshold\r\n      if (event.significance < minSignificance) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    })\r\n    .sort((a, b) => a.tick - b.tick); // Chronological order\r\n\r\n  return limit ? filtered.slice(0, limit) : filtered;\r\n}", "parameters": [{"name": "narrativeHistory", "type": "NarrativeEvent[]", "optional": false}, {"name": "options", "type": "EventFilterOptions", "optional": false}], "returnType": "NarrativeEvent[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/index.ts::formatEventForPrompt", "name": "formatEventForPrompt", "kind": "function", "filePath": "packages/world-schema/src/index.ts", "sourceCode": "/**\r\n * Format an event for inclusion in a prompt.\r\n * Produces a concise one-line summary.\r\n */\r\nexport function formatEventForPrompt(\r\n  event: NarrativeEvent,\r\n  entityId: string\r\n): string {\r\n  const effects = getEntityEffects(event, entityId);\r\n\r\n  // Use the event description, or summarize effects\r\n  if (event.description) {\r\n    return `[Tick ${event.tick}] ${event.description}`;\r\n  }\r\n\r\n  // Fallback: summarize effects\r\n  const effectSummary = effects\r\n    .map(e => e.description)\r\n    .filter(Boolean)\r\n    .join('; ');\r\n\r\n  return `[Tick ${event.tick}] ${effectSummary || event.action}`;\r\n}", "parameters": [{"name": "event", "type": "NarrativeEvent", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/world-schema/src/prominenceScale.ts::buildProminenceScale", "name": "buildProminenceScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function buildProminenceScale(\n  values: number[],\n  options: BuildProminenceScaleOptions = {}\n): ProminenceScale {\n  const labels = options.labels ?? PROMINENCE_LABELS;\n  const min = typeof options.min === 'number' ? options.min : DEFAULT_MIN;\n  const max = typeof options.max === 'number' ? options.max : DEFAULT_MAX;\n  const distribution = normalizeDistribution(\n    options.distribution ?? DEFAULT_PROMINENCE_DISTRIBUTION,\n    labels.length\n  );\n\n  const numericValues = values.filter((value) => Number.isFinite(value)).sort((a, b) => a - b);\n\n  if (numericValues.length === 0) {\n    return {\n      labels,\n      distribution,\n      thresholds: defaultThresholds(min, max, labels.length),\n      min,\n      max,\n    };\n  }\n\n  const thresholds: number[] = [];\n  let cumulative = 0;\n  for (let i = 0; i < labels.length - 1; i += 1) {\n    cumulative += distribution[i];\n    thresholds.push(clamp(quantile(numericValues, cumulative), min, max));\n  }\n\n  return {\n    labels,\n    distribution,\n    thresholds,\n    min,\n    max,\n  };\n}", "parameters": [{"name": "values", "type": "number[]", "optional": false}, {"name": "options", "type": "BuildProminenceScaleOptions", "optional": true}], "returnType": "ProminenceScale", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["ProminenceLabel"], "category": "internal"}]}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceLabelFromScale", "name": "prominenceLabelFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceLabelFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): ProminenceLabel {\n  if (typeof value === 'string' && scale.labels.includes(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'number' || !Number.isFinite(value)) {\n    return scale.labels[0];\n  }\n\n  for (let i = 0; i < scale.thresholds.length; i += 1) {\n    if (value < scale.thresholds[i]) {\n      return scale.labels[i];\n    }\n  }\n\n  return scale.labels[scale.labels.length - 1];\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "ProminenceLabel", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["ProminenceLabel"], "category": "internal"}]}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceThresholdFromScale", "name": "prominenceThresholdFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceThresholdFromScale(label: ProminenceLabel, scale: ProminenceScale): number {\n  const index = scale.labels.indexOf(label);\n  if (index <= 0) return scale.min;\n  return scale.thresholds[index - 1] ?? scale.max;\n}", "parameters": [{"name": "label", "type": "ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["ProminenceLabel"], "category": "internal"}]}, {"id": "packages/world-schema/src/prominenceScale.ts::prominenceIndexFromScale", "name": "prominenceIndexFromScale", "kind": "function", "filePath": "packages/world-schema/src/prominenceScale.ts", "sourceCode": "export function prominenceIndexFromScale(\n  value: number | ProminenceLabel,\n  scale: ProminenceScale\n): number {\n  const label = prominenceLabelFromScale(value, scale);\n  const index = scale.labels.indexOf(label);\n  return index >= 0 ? index : 0;\n}", "parameters": [{"name": "value", "type": "number | ProminenceLabel", "optional": false}, {"name": "scale", "type": "ProminenceScale", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./world.js", "specifiers": ["ProminenceLabel"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::createDefaultStyleLibrary", "name": "createDefaultStyleLibrary", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Create a default style library\n */\nexport function createDefaultStyleLibrary(): StyleLibrary {\n  return {\n    artisticStyles: [...DEFAULT_ARTISTIC_STYLES],\n    compositionStyles: [...DEFAULT_COMPOSITION_STYLES],\n    colorPalettes: [...DEFAULT_COLOR_PALETTES],\n    narrativeStyles: [...DEFAULT_NARRATIVE_STYLES, ...DEFAULT_DOCUMENT_STYLES],\n  };\n}", "parameters": [], "returnType": "StyleLibrary", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::findArtisticStyle", "name": "findArtisticStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find an artistic style by ID\n */\nexport function findArtisticStyle(library: StyleLibrary, id: string): ArtisticStyle | undefined {\n  return library.artisticStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ArtisticStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::findColorPalette", "name": "findColorPalette", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a color palette by ID\n */\nexport function findColorPalette(library: StyleLibrary, id: string): ColorPalette | undefined {\n  return library.colorPalettes.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "ColorPalette | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::findCompositionStyle", "name": "findCompositionStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a composition style by ID\n */\nexport function findCompositionStyle(library: StyleLibrary, id: string): CompositionStyle | undefined {\n  return library.compositionStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "CompositionStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::findNarrativeStyle", "name": "findNarrativeStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Find a narrative style by ID\n */\nexport function findNarrativeStyle(library: StyleLibrary, id: string): NarrativeStyle | undefined {\n  return library.narrativeStyles.find(s => s.id === id);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}, {"name": "id", "type": "string", "optional": false}], "returnType": "NarrativeStyle | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/style.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/style.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["ColorPalette"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["StoryNarrativeStyle"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DocumentNarrativeStyle"], "category": "internal"}, {"source": "./artisticStyles.js", "specifiers": ["DEFAULT_ARTISTIC_STYLES"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["DEFAULT_COMPOSITION_STYLES"], "category": "internal"}, {"source": "./colorPalettes.js", "specifiers": ["DEFAULT_COLOR_PALETTES"], "category": "internal"}, {"source": "./narrativeStyles.js", "specifiers": ["DEFAULT_NARRATIVE_STYLES"], "category": "internal"}, {"source": "./documentStyles.js", "specifiers": ["DEFAULT_DOCUMENT_STYLES"], "category": "internal"}]}, {"id": "packages/world-schema/src/styleExclusions.ts::isExcludedPair", "name": "isExcludedPair", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Check if a specific style+composition pair is excluded by the given rules.\n */\nexport function isExcludedPair(\n  styleId: string,\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n  compositionStyles: CompositionStyle[],\n): boolean {\n  for (const rule of rules) {\n    const excludedStyles = expandPatterns(\n      rule.styles,\n      artisticStyles,\n      (s) => s.category,\n    );\n    const excludedCompositions = expandPatterns(\n      rule.compositions,\n      compositionStyles,\n      (c) => c.targetCategory,\n    );\n\n    if (excludedStyles.has(styleId) && excludedCompositions.has(compositionId)) {\n      // Check allow overrides\n      if (rule.allow?.some(([s, c]) => s === styleId && c === compositionId)) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}", "parameters": [{"name": "styleId", "type": "string", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}]}, {"id": "packages/world-schema/src/styleExclusions.ts::filterStylesForComposition", "name": "filterStylesForComposition", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Filter artistic styles to exclude bad pairings with a fixed composition.\n */\nexport function filterStylesForComposition(\n  artisticStyles: ArtisticStyle[],\n  compositionId: string,\n  rules: RandomExclusionRule[],\n  compositionStyles: CompositionStyle[],\n): ArtisticStyle[] {\n  return artisticStyles.filter(\n    (s) => !isExcludedPair(s.id, compositionId, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}, {"name": "compositionId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}], "returnType": "ArtisticStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}]}, {"id": "packages/world-schema/src/styleExclusions.ts::filterCompositionsForStyle", "name": "filterCompositionsForStyle", "kind": "function", "filePath": "packages/world-schema/src/styleExclusions.ts", "sourceCode": "/**\n * Filter composition styles to exclude bad pairings with a fixed artistic style.\n */\nexport function filterCompositionsForStyle(\n  compositionStyles: CompositionStyle[],\n  styleId: string,\n  rules: RandomExclusionRule[],\n  artisticStyles: ArtisticStyle[],\n): CompositionStyle[] {\n  return compositionStyles.filter(\n    (c) => !isExcludedPair(styleId, c.id, rules, artisticStyles, compositionStyles),\n  );\n}", "parameters": [{"name": "compositionStyles", "type": "CompositionStyle[]", "optional": false}, {"name": "styleId", "type": "string", "optional": false}, {"name": "rules", "type": "RandomExclusionRule[]", "optional": false}, {"name": "artisticStyles", "type": "ArtisticStyle[]", "optional": false}], "returnType": "CompositionStyle[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./artisticStyles.js", "specifiers": ["ArtisticStyle"], "category": "internal"}, {"source": "./compositionStyles.js", "specifiers": ["CompositionStyle"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/behaviorMarkers.ts::analyzeBehavior", "name": "analyzeBehavior", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/behaviorMarkers.ts", "sourceCode": "/**\n * Walk the AST subtree rooted at `node` and detect behavioral markers.\n */\nexport function analyzeBehavior(node: Node): BehaviorMarkers {\n  const markers: BehaviorMarkers = {\n    isAsync: false,\n    hasErrorHandling: false,\n    hasLoadingState: false,\n    hasEmptyState: false,\n    hasRetryLogic: false,\n    rendersIteration: false,\n    rendersConditional: false,\n    sideEffects: false,\n  };\n\n  // Check if the function itself is async\n  if (Node.isFunctionDeclaration(node) || Node.isMethodDeclaration(node)) {\n    markers.isAsync = node.isAsync();\n  } else if (Node.isVariableDeclaration(node)) {\n    const init = node.getInitializer();\n    if (init && Node.isArrowFunction(init)) {\n      markers.isAsync = init.isAsync();\n    } else if (init && Node.isFunctionExpression(init)) {\n      markers.isAsync = init.isAsync();\n    }\n  }\n\n  // Walk the full subtree once and check patterns\n  node.forEachDescendant(desc => {\n    const kindNum = desc.getKind();\n\n    // hasErrorHandling: try/catch or .catch()\n    if (kindNum === SyntaxKind.TryStatement) {\n      markers.hasErrorHandling = true;\n    }\n    if (Node.isPropertyAccessExpression(desc) && desc.getName() === 'catch') {\n      markers.hasErrorHandling = true;\n    }\n\n    // hasLoadingState: variable/state named loading/isLoading/pending\n    if (Node.isIdentifier(desc)) {\n      const name = desc.getText();\n      if (/^(loading|isLoading|isPending|pending|isSubmitting)$/.test(name)) {\n        markers.hasLoadingState = true;\n      }\n      // hasRetryLogic: retry/attempt/MAX_RETRIES identifiers\n      if (/^(retry|retryCount|attempt|attempts|MAX_RETRIES|maxRetries|retries)$/i.test(name)) {\n        markers.hasRetryLogic = true;\n      }\n    }\n\n    // hasEmptyState: checks for .length === 0 or !data patterns\n    if (Node.isBinaryExpression(desc)) {\n      const text = desc.getText();\n      if (/\\.length\\s*===?\\s*0/.test(text) || /\\.length\\s*!==?\\s*[^0]/.test(text) === false && /\\.length\\s*<\\s*1/.test(text)) {\n        markers.hasEmptyState = true;\n      }\n    }\n    if (Node.isPrefixUnaryExpression(desc) && desc.getOperatorToken() === SyntaxKind.ExclamationToken) {\n      const operand = desc.getOperand();\n      if (Node.isIdentifier(operand)) {\n        const name = operand.getText();\n        if (/^(data|items|results|entries|records|list|rows)$/i.test(name)) {\n          markers.hasEmptyState = true;\n        }\n      }\n    }\n\n    // rendersIteration: .map() in JSX context\n    if (Node.isCallExpression(desc)) {\n      const expr = desc.getExpression();\n      if (Node.isPropertyAccessExpression(expr) && expr.getName() === 'map') {\n        // Check if ancestor is a JSX expression\n        let ancestor: Node | undefined = desc.getParent();\n        while (ancestor) {\n          if (ancestor.getKind() === SyntaxKind.JsxExpression) {\n            markers.rendersIteration = true;\n            break;\n          }\n          if (ancestor.getKind() === SyntaxKind.ReturnStatement) {\n            markers.rendersIteration = true;\n            break;\n          }\n          ancestor = ancestor.getParent();\n        }\n      }\n\n      // sideEffects: useEffect, addEventListener, setTimeout, setInterval\n      const callText = desc.getExpression().getText();\n      if (/^(useEffect|useLayoutEffect)$/.test(callText)) {\n        markers.sideEffects = true;\n      }\n      if (/addEventListener|setTimeout|setInterval|requestAnimationFrame/.test(callText)) {\n        markers.sideEffects = true;\n      }\n    }\n\n    // rendersConditional: && or ternary in JSX return context\n    if (kindNum === SyntaxKind.JsxExpression) {\n      const exprChild = desc.getChildAtIndex(1); // The expression inside { }\n      if (exprChild) {\n        const exprText = exprChild.getText();\n        // Pattern: condition && <Jsx> or condition ? <A> : <B>\n        if (exprChild.getKind() === SyntaxKind.BinaryExpression) {\n          const opToken = exprChild.getChildAtIndex(1);\n          if (opToken && opToken.getKind() === SyntaxKind.AmpersandAmpersandToken) {\n            markers.rendersConditional = true;\n          }\n        }\n        if (exprChild.getKind() === SyntaxKind.ConditionalExpression) {\n          markers.rendersConditional = true;\n        }\n        // Also handle nested ternaries/&& in the text\n        if (!markers.rendersConditional && (/&&/.test(exprText) || /\\?.*:/.test(exprText))) {\n          markers.rendersConditional = true;\n        }\n      }\n    }\n  });\n\n  return markers;\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "BehaviorMarkers", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["Node", "SyntaxKind"], "category": "external"}, {"source": "./types.js", "specifiers": ["BehaviorMarkers"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts::analyzeCallGraph", "name": "analyzeCallGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/callGraphAnalyzer.ts", "sourceCode": "/**\n * Analyze outbound call graph for a function/component/hook.\n *\n * Walks the function body, finds all CallExpression nodes, resolves targets,\n * classifies call context, and detects method chain patterns.\n */\nexport function analyzeCallGraph(node: Node, _sourceFile: SourceFile): CallGraphInfo {\n  const callees: CalleeEntry[] = [];\n  const calleesByContext = new Map<string, string[]>();\n  const chainPatterns = new Set<string>();\n  let maxChainDepth = 0;\n  const uniqueTargets = new Set<string>();\n\n  // Get the function body to analyze\n  const body = getFunctionBody(node);\n  if (!body) {\n    return {\n      callees: [],\n      calleeSequence: {},\n      callDepth: 0,\n      uniqueCallees: 0,\n      chainPatterns: [],\n    };\n  }\n\n  // Find all call expressions\n  body.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    // Skip if this call is inside a nested function definition (not our scope)\n    // unless it's inside useEffect/useCallback/useMemo callbacks which ARE our scope\n    if (isInsideNestedFunctionDef(desc, body)) return;\n\n    const target = resolveCallTarget(desc);\n    const context = classifyCallContext(desc, body);\n\n    callees.push({ target, context });\n    uniqueTargets.add(target);\n\n    // Add to context-grouped sequence\n    if (!calleesByContext.has(context)) {\n      calleesByContext.set(context, []);\n    }\n    calleesByContext.get(context)!.push(target);\n\n    // Detect method chain patterns\n    const chainDepth = detectChainPattern(desc, chainPatterns);\n    if (chainDepth > maxChainDepth) maxChainDepth = chainDepth;\n  });\n\n  // Build calleeSequence record\n  const calleeSequence: Record<string, string[]> = {};\n  for (const [ctx, targets] of calleesByContext) {\n    calleeSequence[ctx] = targets;\n  }\n\n  return {\n    callees,\n    calleeSequence,\n    callDepth: maxChainDepth,\n    uniqueCallees: uniqueTargets.size,\n    chainPatterns: [...chainPatterns],\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}, {"name": "_sourceFile", "type": "SourceFile", "optional": false}], "returnType": "CallGraphInfo", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["Node", "SyntaxKind", "SourceFile"], "category": "external"}, {"source": "./types.js", "specifiers": ["CallGraphInfo", "CalleeEntry"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts::buildConsumerGraph", "name": "buildConsumerGraph", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/consumerAnalyzer.ts", "sourceCode": "/**\n * Build the consumer graph across all extracted units (second pass).\n *\n * For each unit, looks at its imports. For each internal import that resolves\n * to a file with known exported units, adds this unit as a consumer of those\n * target units. Then computes consumer counts, kinds, directories, and\n * co-occurrence data.\n *\n * Mutates units in place.\n */\nexport function buildConsumerGraph(units: CodeUnit[]): void {\n  // Build lookup maps\n  const unitById = new Map<string, CodeUnit>();\n  const unitsByFile = new Map<string, string[]>(); // filePath \u2192 list of unit IDs\n\n  for (const unit of units) {\n    unitById.set(unit.id, unit);\n\n    if (!unitsByFile.has(unit.filePath)) {\n      unitsByFile.set(unit.filePath, []);\n    }\n    unitsByFile.get(unit.filePath)!.push(unit.id);\n  }\n\n  // First pass: build consumer lists\n  // For each unit, look at its internal imports and link to target units\n  for (const unit of units) {\n    for (const imp of unit.imports) {\n      if (imp.category !== 'internal') continue;\n\n      // Resolve the import source relative to the unit's file\n      const resolvedTargets = resolveImportToFile(unit.filePath, imp.source, unitsByFile);\n\n      for (const targetUnitId of resolvedTargets) {\n        const targetUnit = unitById.get(targetUnitId);\n        if (!targetUnit) continue;\n        if (targetUnit.id === unit.id) continue; // Don't self-reference\n\n        // Check if any of the imported specifiers match the target unit name\n        const targetName = targetUnit.name;\n        const specifierMatch = imp.specifiers.length === 0 || // default import or namespace\n          imp.specifiers.some(spec => {\n            // Handle \"Name as Alias\" patterns\n            const baseName = spec.includes(' as ') ? spec.split(' as ')[0].trim() : spec;\n            return baseName === targetName || baseName === 'default' || spec.startsWith('* as');\n          });\n\n        if (specifierMatch) {\n          if (!targetUnit.consumers.includes(unit.id)) {\n            targetUnit.consumers.push(unit.id);\n          }\n        }\n      }\n    }\n  }\n\n  // Second pass: compute consumer metadata\n  for (const unit of units) {\n    unit.consumerCount = unit.consumers.length;\n\n    // Consumer kinds: set of kinds that consume this unit\n    const kindSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) kindSet.add(consumer.kind);\n    }\n    unit.consumerKinds = [...kindSet].sort();\n\n    // Consumer directories: set of directory prefixes\n    const dirSet = new Set<string>();\n    for (const consumerId of unit.consumers) {\n      const consumer = unitById.get(consumerId);\n      if (consumer) {\n        // Use the first two path segments as directory prefix\n        const parts = consumer.filePath.split('/');\n        if (parts.length >= 2) {\n          dirSet.add(parts.slice(0, 2).join('/'));\n        } else {\n          dirSet.add(parts[0]);\n        }\n      }\n    }\n    unit.consumerDirectories = [...dirSet].sort();\n  }\n\n  // Third pass: build co-occurrence data\n  buildCoOccurrences(units, unitById, unitsByFile);\n}", "parameters": [{"name": "units", "type": "CodeUnit[]", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "node:path", "specifiers": ["* as path"], "category": "external"}, {"source": "./types.js", "specifiers": ["CodeUnit", "CoOccurrence"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/hookAnalyzer.ts::analyzeHooks", "name": "analyzeHooks", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/hookAnalyzer.ts", "sourceCode": "/**\n * Analyze hook usage within a function/component body.\n *\n * Finds all call expressions where the callee name starts with `use` (React convention).\n * Counts occurrences, categorizes built-in vs custom, and counts state variables.\n */\nexport function analyzeHooks(node: Node): HookInfo {\n  const hookCounts = new Map<string, number>();\n  const customHookSet = new Set<string>();\n  let stateVariableCount = 0;\n\n  node.forEachDescendant(desc => {\n    if (!Node.isCallExpression(desc)) return;\n\n    const expr = desc.getExpression();\n    let hookName: string | null = null;\n\n    // Direct call: useFoo()\n    if (Node.isIdentifier(expr)) {\n      const name = expr.getText();\n      if (name.startsWith('use') && name.length > 3 && name[3] === name[3].toUpperCase()) {\n        hookName = name;\n      }\n    }\n\n    // Namespaced call: React.useState()\n    if (Node.isPropertyAccessExpression(expr)) {\n      const propName = expr.getName();\n      if (propName.startsWith('use') && propName.length > 3 && propName[3] === propName[3].toUpperCase()) {\n        hookName = propName;\n      }\n    }\n\n    if (!hookName) return;\n\n    // Count occurrences\n    hookCounts.set(hookName, (hookCounts.get(hookName) ?? 0) + 1);\n\n    // Classify as custom if not a React built-in\n    if (!REACT_BUILT_IN_HOOKS.has(hookName)) {\n      customHookSet.add(hookName);\n    }\n\n    // Count state variables from useState destructuring:\n    // const [value, setValue] = useState(...)\n    if (hookName === 'useState') {\n      const parent = desc.getParent();\n      if (parent && Node.isVariableDeclaration(parent)) {\n        const nameNode = parent.getNameNode();\n        if (Node.isArrayBindingPattern(nameNode)) {\n          // Each element with a \"set\" prefix is a setter\n          const elements = nameNode.getElements();\n          // Count the number of state values (the non-setter elements, typically first)\n          // Standard pattern: [value, setValue] = one state variable\n          stateVariableCount += 1;\n        }\n      }\n    }\n  });\n\n  // Build ordered hookCalls list (ordered by first appearance - Map preserves insertion order)\n  const hookCalls: HookCallEntry[] = [];\n  for (const [name, count] of hookCounts) {\n    hookCalls.push({ name, count });\n  }\n\n  return {\n    hookCalls,\n    customHookCalls: [...customHookSet].sort(),\n    stateVariableCount,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "HookInfo", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["Node", "SyntaxKind"], "category": "external"}, {"source": "./types.js", "specifiers": ["HookInfo", "HookCallEntry"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/importAnalyzer.ts::analyzeImports", "name": "analyzeImports", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/importAnalyzer.ts", "sourceCode": "/**\n * Analyze all imports in a source file.\n * Also detects store access patterns and data source access.\n */\nexport function analyzeImports(sourceFile: SourceFile, _projectRoot: string): ImportInfo {\n  const imports: ImportEntry[] = [];\n  const storeAccess: string[] = [];\n  const dataSourceAccess: string[] = [];\n\n  // Process import declarations\n  for (const decl of sourceFile.getImportDeclarations()) {\n    const source = decl.getModuleSpecifierValue();\n    const specifiers: string[] = [];\n\n    // Default import\n    const defaultImport = decl.getDefaultImport();\n    if (defaultImport) {\n      specifiers.push(defaultImport.getText());\n    }\n\n    // Named imports\n    for (const named of decl.getNamedImports()) {\n      const alias = named.getAliasNode();\n      specifiers.push(alias ? `${named.getName()} as ${alias.getText()}` : named.getName());\n    }\n\n    // Namespace import\n    const nsImport = decl.getNamespaceImport();\n    if (nsImport) {\n      specifiers.push(`* as ${nsImport.getText()}`);\n    }\n\n    imports.push({\n      source,\n      specifiers,\n      category: categorizeImport(source),\n    });\n  }\n\n  // Detect store access patterns in the full file text\n  const fullText = sourceFile.getFullText();\n\n  // useXxxStore() calls\n  const storeCallPattern = /\\buse(\\w+Store)\\s*\\(/g;\n  let match: RegExpExecArray | null;\n  const seenStores = new Set<string>();\n  while ((match = storeCallPattern.exec(fullText)) !== null) {\n    const storeName = `use${match[1]}`;\n    if (!seenStores.has(storeName)) {\n      seenStores.add(storeName);\n      storeAccess.push(storeName);\n    }\n  }\n\n  // store.getState() / store.setState() patterns\n  const storeGetSetPattern = /\\b(\\w+Store)\\.(getState|setState|subscribe)\\s*\\(/g;\n  while ((match = storeGetSetPattern.exec(fullText)) !== null) {\n    const access = `${match[1]}.${match[2]}`;\n    if (!seenStores.has(access)) {\n      seenStores.add(access);\n      storeAccess.push(access);\n    }\n  }\n\n  // Data source access patterns\n  const seenDataSources = new Set<string>();\n\n  // Dexie: db.tableName patterns\n  const dbTablePattern = /\\bdb\\.(\\w+)\\b/g;\n  while ((match = dbTablePattern.exec(fullText)) !== null) {\n    const access = `db.${match[1]}`;\n    if (!seenDataSources.has(access)) {\n      seenDataSources.add(access);\n      dataSourceAccess.push(access);\n    }\n  }\n\n  // useLiveQuery calls\n  if (/\\buseLiveQuery\\s*\\(/.test(fullText)) {\n    if (!seenDataSources.has('useLiveQuery')) {\n      seenDataSources.add('useLiveQuery');\n      dataSourceAccess.push('useLiveQuery');\n    }\n  }\n\n  // fetch() calls\n  sourceFile.forEachDescendant(node => {\n    if (Node.isCallExpression(node)) {\n      const expr = node.getExpression();\n      if (Node.isIdentifier(expr) && expr.getText() === 'fetch') {\n        if (!seenDataSources.has('fetch')) {\n          seenDataSources.add('fetch');\n          dataSourceAccess.push('fetch');\n        }\n      }\n    }\n  });\n\n  return { imports, storeAccess, dataSourceAccess };\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "_projectRoot", "type": "string", "optional": false}], "returnType": "ImportInfo", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["SourceFile", "Node", "SyntaxKind"], "category": "external"}, {"source": "node:path", "specifiers": ["* as path"], "category": "external"}, {"source": "./types.js", "specifiers": ["ImportEntry", "ImportInfo"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts::analyzeJsx", "name": "analyzeJsx", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/jsxAnalyzer.ts", "sourceCode": "/**\n * Analyze JSX structure in a component function.\n *\n * Returns null for non-component functions (no JSX return).\n * Builds a nested tree of JSX elements with map/conditional markers.\n * Strips attributes/props -- we only care about structural nesting.\n */\nexport function analyzeJsx(node: Node): JsxInfo | null {\n  // Find return statements that contain JSX\n  const returnStatements = node.getDescendantsOfKind(SyntaxKind.ReturnStatement);\n\n  let jsxRoot: Node | null = null;\n\n  for (const ret of returnStatements) {\n    const expr = ret.getExpression();\n    if (!expr) continue;\n\n    // Check if the return expression is JSX or a parenthesized JSX\n    if (isJsxNode(expr)) {\n      jsxRoot = expr;\n      break;\n    }\n\n    // Check inside parenthesized expression\n    if (Node.isParenthesizedExpression(expr)) {\n      const inner = expr.getExpression();\n      if (isJsxNode(inner)) {\n        jsxRoot = inner;\n        break;\n      }\n    }\n  }\n\n  // Also handle arrow functions with expression bodies (no explicit return):\n  // const Foo = () => <div>...</div>\n  if (!jsxRoot) {\n    if (Node.isArrowFunction(node)) {\n      const body = node.getBody();\n      if (body && isJsxNode(body)) {\n        jsxRoot = body;\n      } else if (body && Node.isParenthesizedExpression(body)) {\n        const inner = body.getExpression();\n        if (isJsxNode(inner)) {\n          jsxRoot = inner;\n        }\n      }\n    }\n    // For VariableDeclaration wrapping an arrow function\n    if (!jsxRoot && Node.isVariableDeclaration(node)) {\n      const init = node.getInitializer();\n      if (init && Node.isArrowFunction(init)) {\n        const body = init.getBody();\n        if (body && isJsxNode(body)) {\n          jsxRoot = body;\n        } else if (body && Node.isParenthesizedExpression(body)) {\n          const inner = body.getExpression();\n          if (isJsxNode(inner)) {\n            jsxRoot = inner;\n          }\n        }\n      }\n    }\n  }\n\n  if (!jsxRoot) return null;\n\n  const tree = buildJsxTree(jsxRoot, false, false);\n  if (!tree) return null;\n\n  const leafElements: string[] = [];\n  const depth = computeDepthAndLeaves(tree, leafElements);\n\n  return {\n    jsxTree: tree,\n    jsxLeafElements: [...new Set(leafElements)],\n    jsxDepth: depth,\n  };\n}", "parameters": [{"name": "node", "type": "Node", "optional": false}], "returnType": "JsxInfo | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["Node", "SyntaxKind", "JsxChild"], "category": "external"}, {"source": "./types.js", "specifiers": ["JsxInfo", "JsxTreeNode"], "category": "internal"}]}, {"id": "tools/drift-semantic/extractor/src/projectLoader.ts::loadProjects", "name": "loadProjects", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/projectLoader.ts", "sourceCode": "/**\n * Load all TypeScript/JavaScript projects from the monorepo.\n *\n * - Creates a ts-morph Project for each tsconfig.json / tsconfig.app.json\n * - For webui directories not covered by any tsconfig, creates an ad-hoc Project\n *   with allowJs + JSX support\n * - Returns projects and a set of seen absolute file paths for deduplication\n */\nexport function loadProjects(projectRoot: string): LoadedProjects {\n  const tsconfigPaths = findTsconfigFiles(projectRoot);\n  const seenFiles = new Set<string>();\n  const projects: Project[] = [];\n\n  // Prefer tsconfig.app.json over tsconfig.json when both exist in same dir\n  const byDir = new Map<string, string[]>();\n  for (const tc of tsconfigPaths) {\n    const dir = path.dirname(tc);\n    if (!byDir.has(dir)) byDir.set(dir, []);\n    byDir.get(dir)!.push(tc);\n  }\n\n  const selectedTsconfigs: string[] = [];\n  for (const [, configs] of byDir) {\n    const appConfig = configs.find(c => path.basename(c) === 'tsconfig.app.json');\n    // If tsconfig.app.json exists, prefer it (it's the actual source config);\n    // otherwise use tsconfig.json\n    selectedTsconfigs.push(appConfig ?? configs[0]);\n  }\n\n  for (const tsconfigPath of selectedTsconfigs) {\n    try {\n      const project = new Project({ tsConfigFilePath: tsconfigPath });\n      const sourceFiles = project.getSourceFiles();\n\n      // Track which files this project covers\n      for (const sf of sourceFiles) {\n        seenFiles.add(sf.getFilePath());\n      }\n\n      projects.push(project);\n      process.stderr.write(`  tsconfig: ${path.relative(projectRoot, tsconfigPath)} \u2192 ${sourceFiles.length} files\\n`);\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to load ${path.relative(projectRoot, tsconfigPath)}: ${err}\\n`);\n    }\n  }\n\n  // Find and create ad-hoc projects for uncovered webui directories\n  const uncoveredWebuis = findUncoveredWebuis(projectRoot, selectedTsconfigs);\n\n  for (const webuiDir of uncoveredWebuis) {\n    try {\n      const project = new Project({\n        compilerOptions: {\n          target: ts.ScriptTarget.ES2022,\n          module: ts.ModuleKind.ESNext,\n          moduleResolution: ts.ModuleResolutionKind.Bundler,\n          allowJs: true,\n          jsx: ts.JsxEmit.ReactJSX,\n          strict: false,\n          noEmit: true,\n          esModuleInterop: true,\n          skipLibCheck: true,\n        },\n      });\n\n      // Add all .js/.jsx/.ts/.tsx files from the webui/src directory\n      const srcDir = path.join(webuiDir, 'src');\n      if (fs.existsSync(srcDir)) {\n        addSourceFilesRecursively(project, srcDir, seenFiles);\n      }\n\n      const sourceFiles = project.getSourceFiles();\n      if (sourceFiles.length > 0) {\n        projects.push(project);\n        process.stderr.write(`  ad-hoc:   ${path.relative(projectRoot, webuiDir)}/src \u2192 ${sourceFiles.length} files\\n`);\n      }\n    } catch (err) {\n      process.stderr.write(`  WARN: failed to create ad-hoc project for ${path.relative(projectRoot, webuiDir)}: ${err}\\n`);\n    }\n  }\n\n  return { projects, seenFiles };\n}", "parameters": [{"name": "projectRoot", "type": "string", "optional": false}], "returnType": "LoadedProjects", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["Project", "ts"], "category": "external"}, {"source": "node:path", "specifiers": ["* as path"], "category": "external"}, {"source": "node:fs", "specifiers": ["* as fs"], "category": "external"}]}, {"id": "tools/drift-semantic/extractor/src/unitExtractor.ts::extractUnits", "name": "extractUnits", "kind": "function", "filePath": "tools/drift-semantic/extractor/src/unitExtractor.ts", "sourceCode": "/**\n * Extract all exported code units from a source file.\n *\n * Iterates over all exported declarations, determines their kind,\n * runs all analyzers, and returns an array of CodeUnit records.\n */\nexport function extractUnits(sourceFile: SourceFile, projectRoot: string): CodeUnit[] {\n  const units: CodeUnit[] = [];\n  const relativePath = path.relative(projectRoot, sourceFile.getFilePath());\n\n  // Import analysis is per-file (shared across all units in the file)\n  const importInfo = analyzeImports(sourceFile, projectRoot);\n\n  let exportedDeclarations: ReadonlyMap<string, Node[]>;\n  try {\n    exportedDeclarations = sourceFile.getExportedDeclarations();\n  } catch {\n    process.stderr.write(`  WARN: failed to get exports from ${relativePath}\\n`);\n    return units;\n  }\n\n  if (exportedDeclarations.size === 0) return units;\n\n  for (const [exportName, declarations] of exportedDeclarations) {\n    for (const decl of declarations) {\n      try {\n        const unit = extractSingleUnit(decl, exportName, relativePath, sourceFile, projectRoot, importInfo);\n        if (unit) units.push(unit);\n      } catch (err) {\n        process.stderr.write(`  WARN: failed to extract ${exportName} from ${relativePath}: ${err}\\n`);\n      }\n    }\n  }\n\n  return units;\n}", "parameters": [{"name": "sourceFile", "type": "SourceFile", "optional": false}, {"name": "projectRoot", "type": "string", "optional": false}], "returnType": "CodeUnit[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ts-morph", "specifiers": ["SourceFile", "Node", "SyntaxKind", "ts"], "category": "external"}, {"source": "node:path", "specifiers": ["* as path"], "category": "external"}, {"source": "./types.js", "specifiers": ["CodeUnit", "ParameterInfo"], "category": "internal"}, {"source": "./jsxAnalyzer.js", "specifiers": ["analyzeJsx"], "category": "internal"}, {"source": "./hookAnalyzer.js", "specifiers": ["analyzeHooks"], "category": "internal"}, {"source": "./importAnalyzer.js", "specifiers": ["analyzeImports"], "category": "internal"}, {"source": "./callGraphAnalyzer.js", "specifiers": ["analyzeCallGraph"], "category": "internal"}, {"source": "./behaviorMarkers.js", "specifiers": ["analyzeBehavior"], "category": "internal"}]}, {"id": "config/federation.js::federationOnWarn", "name": "federationOnWarn", "kind": "function", "filePath": "config/federation.js", "sourceCode": "/**\r\n * Shared Module Federation configuration utilities.\r\n *\r\n * All MFE vite configs should import from this module to avoid\r\n * duplicating boilerplate (onwarn handlers, shared dep declarations).\r\n */\r\n\r\n/**\r\n * Rollup onwarn handler that silences benign eval warnings from\r\n * @module-federation/sdk. Without this, every MFE build emits\r\n * dozens of EVAL warnings that are not actionable.\r\n */\r\nexport function federationOnWarn(warning, warn) {\r\n  const isModuleFederationEval =\r\n    warning.code === 'EVAL' &&\r\n    (warning.id?.includes('@module-federation/sdk') ||\r\n      warning.message.includes('@module-federation/sdk'));\r\n  if (isModuleFederationEval) return;\r\n  warn(warning);\r\n}", "parameters": [{"name": "warning", "type": "any", "optional": false}, {"name": "warn", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "config/federation.js::sharedDeps", "name": "sharedDeps", "kind": "function", "filePath": "config/federation.js", "sourceCode": "/**\r\n * Build a shared deps object by picking from the extended set.\r\n * Only declare what the app actually uses.\r\n *\r\n * @param {...string} keys - Package names to include beyond base deps\r\n * @returns {Record<string, object>} Shared dependency config\r\n *\r\n * @example\r\n * // Just react/react-dom\r\n * sharedDeps()\r\n *\r\n * @example\r\n * // react/react-dom + zustand + image-store\r\n * sharedDeps('zustand', '@the-canonry/image-store')\r\n */\r\nexport function sharedDeps(...keys) {\r\n  if (keys.length === 0) return { ...sharedDepsBase };\r\n  const result = { ...sharedDepsBase };\r\n  for (const key of keys) {\r\n    if (sharedDepsExtended[key]) {\r\n      result[key] = sharedDepsExtended[key];\r\n    } else {\r\n      result[key] = { singleton: true };\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "keys", "type": "string[]", "optional": false}], "returnType": "Record<string, any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/App.jsx", "sourceCode": "// normalizeUiState moved to stores/useCanonryUiStore.js\n\nexport default function App() {\n  const activeTab = useCanonryUiStore(s => s.activeTab);\n  const activeSectionByTab = useCanonryUiStore(s => s.activeSectionByTab);\n  const showHome = useCanonryUiStore(s => s.showHome);\n  const helpModalOpen = useCanonryUiStore(s => s.helpModalOpen);\n  const chroniclerRequestedPage = useCanonryUiStore(s => s.chroniclerRequestedPage);\n  const [archivistData, setArchivistData] = useState(null);\n  const [worldContext, setWorldContext] = useState(null);\n  const [entityGuidance, setEntityGuidance] = useState(null);\n  const [cultureIdentities, setCultureIdentities] = useState(null);\n  const [enrichmentConfig, setEnrichmentConfig] = useState(null);\n  const [styleSelection, setStyleSelection] = useState(null);\n  const [historianConfig, setHistorianConfig] = useState(null);\n  const [simulationResults, setSimulationResults] = useState(null);\n  const [simulationState, setSimulationState] = useState(null);\n  const [slots, setSlots] = useState({});\n  const [activeSlotIndex, setActiveSlotIndex] = useState(0);\n  const [exportModalSlotIndex, setExportModalSlotIndex] = useState(null);\n  const [exportBundleStatus, setExportBundleStatus] = useState({\n    state: \"idle\",\n    detail: \"\"\n  });\n  // AWS state from zustand store\n  const awsModalOpen = useCanonryAwsStore(s => s.modalOpen);\n  const awsConfig = useCanonryAwsStore(s => s.config);\n  const awsTokens = useCanonryAwsStore(s => s.tokens);\n  const awsStatus = useCanonryAwsStore(s => s.status);\n  const awsBrowseState = useCanonryAwsStore(s => s.browseState);\n  const awsUsername = useCanonryAwsStore(s => s.username);\n  const awsPassword = useCanonryAwsStore(s => s.password);\n  const awsUserLabel = useCanonryAwsStore(s => s.userLabel);\n  const awsSyncProgress = useCanonryAwsStore(s => s.syncProgress);\n  const awsUploadPlan = useCanonryAwsStore(s => s.uploadPlan);\n  const snapshotStatus = useCanonryAwsStore(s => s.snapshotStatus);\n  // AWS actions from zustand store (stable references, no useCallback needed)\n  const updateAwsConfig = useCanonryAwsStore(s => s.updateConfig);\n  const setAwsTokens = useCanonryAwsStore(s => s.setTokens);\n  const setAwsStatus = useCanonryAwsStore(s => s.setStatus);\n  const setAwsBrowseState = useCanonryAwsStore(s => s.setBrowseState);\n  const setAwsUsername = useCanonryAwsStore(s => s.setUsername);\n  const setAwsPassword = useCanonryAwsStore(s => s.setPassword);\n  const setAwsUserLabel = useCanonryAwsStore(s => s.setUserLabel);\n  const setAwsSyncProgress = useCanonryAwsStore(s => s.setSyncProgress);\n  const setAwsUploadPlan = useCanonryAwsStore(s => s.setUploadPlan);\n  const setSnapshotStatus = useCanonryAwsStore(s => s.setSnapshotStatus);\n  const openAwsModal = useCanonryAwsStore(s => s.openModal);\n  const closeAwsModal = useCanonryAwsStore(s => s.closeModal);\n  const exportCancelRef = useRef(false);\n  const exportModalMouseDown = useRef(false);\n  const awsModalMouseDown = useRef(false);\n  const simulationOwnerRef = useRef(null);\n  const currentProjectRef = useRef(null);\n  // Track whether we're loading from a saved slot (to skip auto-save to scratch)\n  const isLoadingSlotRef = useRef(false);\n  // Track the last saved simulation results object to detect new simulations\n  const lastSavedResultsRef = useRef(null);\n  const bestRunScoreRef = useRef(-Infinity);\n  const bestRunSaveQueueRef = useRef(Promise.resolve());\n  const activeSection = useCanonryUiStore(selectActiveSection);\n  const s3Client = useMemo(() => createS3Client(awsConfig, awsTokens), [awsConfig, awsTokens]);\n  useEffect(() => {\n    const tokens = extractCognitoTokensFromUrl();\n    if (tokens) {\n      setAwsTokens(tokens);\n      clearCognitoHash();\n    }\n  }, [setAwsTokens]);\n  useEffect(() => {\n    let canceled = false;\n    const userPoolConfigured = Boolean(awsConfig?.cognitoUserPoolId && awsConfig?.cognitoClientId);\n    if (!userPoolConfigured || isTokenValid(awsTokens)) return;\n    getUserPoolSession(awsConfig).then(session => {\n      if (canceled || !session) return;\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      const username = session.getIdToken().payload?.[\"cognito:username\"] || \"\";\n      if (username) setAwsUserLabel(username);\n    }).catch(() => {});\n    return () => {\n      canceled = true;\n    };\n  }, [awsConfig, awsTokens, setAwsTokens, setAwsUserLabel]);\n  // UI actions from zustand store (stable references, no useCallback needed)\n  const setActiveSection = useCanonryUiStore(s => s.setActiveSection);\n  const setActiveSectionForTab = useCanonryUiStore(s => s.setActiveSectionForTab);\n  const handleTabChange = useCanonryUiStore(s => s.setActiveTab);\n  const handleGoHome = useCanonryUiStore(s => s.goHome);\n  const handleLandingNavigate = useCanonryUiStore(s => s.setActiveTab);\n  const clearChroniclerRequestedPage = useCanonryUiStore(s => s.clearChroniclerRequestedPage);\n  const openHelpModal = useCanonryUiStore(s => s.openHelpModal);\n  const closeHelpModal = useCanonryUiStore(s => s.closeHelpModal);\n  // Listen for cross-MFE navigation events (e.g., Archivist -> Chronicler)\n  useEffect(() => {\n    const navigateTo = useCanonryUiStore.getState().navigateTo;\n    const handleCrossNavigation = e => {\n      const {\n        tab,\n        pageId\n      } = e.detail || {};\n      if (tab) navigateTo(tab, pageId);\n    };\n    window.addEventListener(\"canonry:navigate\", handleCrossNavigation);\n    return () => window.removeEventListener(\"canonry:navigate\", handleCrossNavigation);\n  }, []);\n\n  // Listen for Illuminator world data mutations (rename, patch, enrichment)\n  // The Illuminator writes to its own Dexie store, then dispatches this event.\n  // We read from Dexie and merge into archivistData so other tabs see the changes.\n  useEffect(() => {\n    const handler = async e => {\n      const {\n        simulationRunId\n      } = e.detail || {};\n      if (!simulationRunId) return;\n      try {\n        const [{\n          getEntitiesForRun\n        }, {\n          getNarrativeEventsForRun\n        }] = await Promise.all([import(\"illuminator/entityRepository\"), import(\"illuminator/eventRepository\")]);\n        await Promise.all([getEntitiesForRun(simulationRunId), getNarrativeEventsForRun(simulationRunId)]);\n\n        // DISABLED: Automatic hardState updates removed due to data loss bug.\n        // The enrichment data lives in Dexie and is loaded by IlluminatorRemote.\n        // Do NOT modify worldData.hardState from this event handler.\n      } catch (err) {\n        console.warn(\"[Canonry] Failed to load Illuminator world data from Dexie:\", err);\n      }\n    };\n    window.addEventListener(\"illuminator:worlddata-changed\", handler);\n    return () => window.removeEventListener(\"illuminator:worlddata-changed\", handler);\n  }, []);\n\n  // Listen for hash changes to switch tabs (enables back button across MFEs)\n  // Hash formats: Archivist uses #/entity/{id}, Chronicler uses #/page/{id|slug}\n  useEffect(() => {\n    const handleHashChange = () => {\n      const hash = window.location.hash;\n      if (hash.startsWith(\"#/entity/\") || hash === \"#/entity\") {\n        if (activeTab !== \"archivist\") handleTabChange(\"archivist\");\n      } else if (hash.startsWith(\"#/page/\") || hash === \"#/page\") {\n        if (activeTab !== \"chronicler\") handleTabChange(\"chronicler\");\n      }\n    };\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [activeTab, handleTabChange]);\n  const openExportModal = useCallback(slotIndex => {\n    exportCancelRef.current = false;\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n    setExportModalSlotIndex(slotIndex);\n  }, []);\n  const closeExportModal = useCallback(() => {\n    setExportModalSlotIndex(null);\n    setExportBundleStatus({\n      state: \"idle\",\n      detail: \"\"\n    });\n  }, []);\n  const handleExportModalMouseDown = useCallback(e => {\n    exportModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleExportModalClick = useCallback(e => {\n    if (exportBundleStatus.state === \"working\") return;\n    if (exportModalMouseDown.current && e.target === e.currentTarget) {\n      closeExportModal();\n    }\n  }, [closeExportModal, exportBundleStatus.state]);\n  const handleAwsModalMouseDown = useCallback(e => {\n    awsModalMouseDown.current = e.target === e.currentTarget;\n  }, []);\n  const handleAwsModalClick = useCallback(e => {\n    if (awsModalMouseDown.current && e.target === e.currentTarget) {\n      closeAwsModal();\n    }\n  }, [closeAwsModal]);\n  const handleAwsLogin = useCallback(async () => {\n    if (!awsUsername || !awsPassword) {\n      alert(\"Enter username and password.\");\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Signing in...\"\n      });\n      const session = await signInWithUserPool({\n        username: awsUsername,\n        password: awsPassword,\n        config: awsConfig\n      });\n      const nextTokens = sessionToTokens(session);\n      if (nextTokens) {\n        setAwsTokens(nextTokens);\n      }\n      setAwsUserLabel(awsUsername);\n      setAwsPassword(\"\");\n      setAwsStatus({\n        state: \"idle\",\n        detail: \"Signed in.\"\n      });\n    } catch (err) {\n      console.error(\"Failed to sign in:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"Sign in failed.\"\n      });\n    }\n  }, [awsUsername, awsPassword, awsConfig, setAwsStatus, setAwsTokens, setAwsUserLabel, setAwsPassword]);\n  const handleAwsLogout = useCallback(() => {\n    signOutUserPool(awsConfig);\n    setAwsTokens(null);\n    setAwsUserLabel(\"\");\n    setAwsStatus({\n      state: \"idle\",\n      detail: \"Signed out.\"\n    });\n  }, [awsConfig, setAwsTokens, setAwsUserLabel, setAwsStatus]);\n  const handleAwsBrowsePrefixes = useCallback(async () => {\n    if (!s3Client || !awsConfig?.imageBucket) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: \"Missing S3 client or bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsBrowseState({\n        loading: true,\n        prefixes: [],\n        error: null\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      setAwsBrowseState({\n        loading: false,\n        prefixes,\n        error: null\n      });\n    } catch (err) {\n      setAwsBrowseState({\n        loading: false,\n        prefixes: [],\n        error: err.message || \"Failed to list prefixes.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsBrowseState]);\n  const handleAwsTestSetup = useCallback(async () => {\n    if (!s3Client) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing AWS credentials.\"\n      });\n      return;\n    }\n    if (!awsConfig?.imageBucket) {\n      setAwsStatus({\n        state: \"error\",\n        detail: \"Missing image bucket.\"\n      });\n      return;\n    }\n    try {\n      setAwsStatus({\n        state: \"working\",\n        detail: \"Testing S3 access...\"\n      });\n      setAwsSyncProgress({\n        phase: \"test\",\n        processed: 0,\n        total: 0,\n        uploaded: 0\n      });\n      const prefixes = await listS3Prefixes(s3Client, {\n        bucket: awsConfig.imageBucket,\n        prefix: awsConfig.imagePrefix || \"\"\n      });\n      const prefixLabel = prefixes.length ? `Found ${prefixes.length} prefixes.` : \"Access OK.\";\n      setAwsStatus({\n        state: \"idle\",\n        detail: `Test passed. ${prefixLabel}`\n      });\n    } catch (err) {\n      console.error(\"Failed to test S3 setup:\", err);\n      setAwsStatus({\n        state: \"error\",\n        detail: err.message || \"S3 test failed.\"\n      });\n    }\n  }, [s3Client, awsConfig, setAwsStatus, setAwsSyncProgress]);\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect", "useRef"], "category": "framework"}, {"source": "./storage/useProjectStorage", "specifiers": ["useProjectStorage"], "category": "internal"}, {"source": "./stores/useCanonryUiStore", "specifiers": ["useCanonryUiStore", "selectActiveSection"], "category": "internal"}, {"source": "./storage/worldStore", "specifiers": ["loadWorldStore", "saveWorldData", "saveWorldContext", "saveEntityGuidance", "saveCultureIdentities", "saveEnrichmentConfig", "saveStyleSelection", "saveHistorianConfig", "getSlots", "getSlot", "setActiveSlotIndex as persistActiveSlotIndex", "saveSlot", "saveToSlot", "loadSlot", "clearSlot", "updateSlotTitle", "generateSlotTitle"], "category": "internal"}, {"source": "./components/ProjectManager", "specifiers": ["ProjectManager"], "category": "internal"}, {"source": "./components/Navigation", "specifiers": ["Navigation"], "category": "internal"}, {"source": "./components/SchemaEditor", "specifiers": ["SchemaEditor"], "category": "internal"}, {"source": "./components/LandingPage", "specifiers": ["LandingPage"], "category": "internal"}, {"source": "./components/HelpModal", "specifiers": ["HelpModal"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["computeTagUsage", "computeSchemaUsage"], "category": "external"}, {"source": "../../../lore-weave/lib/engine/configSchemaValidator", "specifiers": ["validateAllConfigs"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["mergeFrameworkSchemaSlice", "FRAMEWORK_ENTITY_KIND_VALUES", "FRAMEWORK_RELATIONSHIP_KIND_VALUES", "FRAMEWORK_CULTURES", "FRAMEWORK_CULTURE_DEFINITIONS", "FRAMEWORK_TAG_VALUES"], "category": "external"}, {"source": "./remotes/NameForgeHost", "specifiers": ["NameForgeHost"], "category": "internal"}, {"source": "./remotes/CosmographerHost", "specifiers": ["CosmographerHost"], "category": "internal"}, {"source": "./remotes/CoherenceEngineHost", "specifiers": ["CoherenceEngineHost"], "category": "internal"}, {"source": "./remotes/LoreWeaveHost", "specifiers": ["LoreWeaveHost"], "category": "internal"}, {"source": "./remotes/IlluminatorHost", "specifiers": ["IlluminatorHost"], "category": "internal"}, {"source": "./remotes/ArchivistHost", "specifiers": ["ArchivistHost"], "category": "internal"}, {"source": "./remotes/ChroniclerHost", "specifiers": ["ChroniclerHost"], "category": "internal"}, {"source": "@the-canonry/image-store", "specifiers": ["useImageStore", "IndexedDBBackend"], "category": "external"}, {"source": "./lib/imageExportHelpers", "specifiers": ["getImagesByProject", "getImageBlob", "getImageMetadata"], "category": "internal"}, {"source": "./storage/staticPageStorage", "specifiers": ["getStaticPagesForProject", "importStaticPages"], "category": "internal"}, {"source": "./storage/chronicleStorage", "specifiers": ["getCompletedChroniclesForSimulation", "getCompletedChroniclesForProject", "importChronicles", "getChronicleCountForProject"], "category": "internal"}, {"source": "./storage/eraNarrativeStorage", "specifiers": ["getCompletedEraNarrativesForSimulation"], "category": "internal"}, {"source": "./storage/imageStorage", "specifiers": ["importBundleImageReferences", "getImageCountForProject"], "category": "internal"}, {"source": "./storage/entityStorage", "specifiers": ["importEntities", "getEntityCountForRun"], "category": "internal"}, {"source": "./storage/eventStorage", "specifiers": ["importNarrativeEvents", "getNarrativeEventCountForRun"], "category": "internal"}, {"source": "./theme", "specifiers": ["colors", "typography", "spacing"], "category": "internal"}, {"source": "./aws/awsConfigStorage", "specifiers": ["isTokenValid"], "category": "internal"}, {"source": "./stores/useCanonryAwsStore", "specifiers": ["useCanonryAwsStore"], "category": "internal"}, {"source": "./aws/cognitoAuth", "specifiers": ["extractCognitoTokensFromUrl", "clearCognitoHash"], "category": "internal"}, {"source": "./aws/cognitoUserAuth", "specifiers": ["signInWithUserPool", "getUserPoolSession", "signOutUserPool", "sessionToTokens"], "category": "internal"}, {"source": "./aws/awsS3", "specifiers": ["createS3Client", "buildImageStorageConfig", "syncProjectImagesToS3", "getS3ImageUploadPlan", "listS3Prefixes", "buildStorageImageUrl"], "category": "internal"}, {"source": "./aws/indexedDbSnapshot", "specifiers": ["exportIndexedDbToS3", "importIndexedDbFromS3"], "category": "internal"}, {"source": "./aws/s3ImagePull", "specifiers": ["pullImagesFromS3"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/theme.js::getAccentColor", "name": "getAccentColor", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get accent color for current app\nexport function getAccentColor(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return colors.accentEnumerist;\n    case \"names\":\n      return colors.accentNameForge;\n    case \"cosmography\":\n      return colors.accentCosmographer;\n    case \"coherence\":\n      return colors.accentCoherence;\n    case \"simulation\":\n      return colors.accentSimulation;\n    case \"illuminator\":\n      return colors.accentIlluminator;\n    case \"archivist\":\n      return colors.accentArchivist;\n    case \"chronicler\":\n      return colors.accentChronicler;\n    default:\n      return colors.accent;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/theme.js::getAccentGradient", "name": "getAccentGradient", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get gradient for active nav buttons\nexport function getAccentGradient(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return `linear-gradient(135deg, ${colors.accentEnumerist} 0%, ${colors.accentEnumeristLight} 100%)`;\n    case \"names\":\n      return `linear-gradient(135deg, ${colors.accentNameForge} 0%, ${colors.accentNameForgeLight} 100%)`;\n    case \"cosmography\":\n      return `linear-gradient(135deg, ${colors.accentCosmographer} 0%, ${colors.accentCosmographerLight} 100%)`;\n    case \"coherence\":\n      return `linear-gradient(135deg, ${colors.accentCoherence} 0%, ${colors.accentCoherenceLight} 100%)`;\n    case \"simulation\":\n      return `linear-gradient(135deg, ${colors.accentSimulation} 0%, ${colors.accentSimulationLight} 100%)`;\n    case \"illuminator\":\n      return `linear-gradient(135deg, ${colors.accentIlluminator} 0%, ${colors.accentIlluminatorLight} 100%)`;\n    case \"archivist\":\n      return `linear-gradient(135deg, ${colors.accentArchivist} 0%, ${colors.accentArchivistLight} 100%)`;\n    case \"chronicler\":\n      return `linear-gradient(135deg, ${colors.accentChronicler} 0%, ${colors.accentChroniclerLight} 100%)`;\n    default:\n      return `linear-gradient(135deg, ${colors.accent} 0%, ${colors.accentLight} 100%)`;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/theme.js::getHoverBg", "name": "getHoverBg", "kind": "function", "filePath": "apps/canonry/webui/src/theme.js", "sourceCode": "// Helper to get hover background for current app\nexport function getHoverBg(appId) {\n  switch (appId) {\n    case \"enumerist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"names\":\n      return \"rgba(251, 191, 36, 0.15)\";\n    case \"cosmography\":\n      return \"rgba(96, 165, 250, 0.15)\";\n    case \"coherence\":\n      return \"rgba(245, 158, 11, 0.15)\";\n    case \"simulation\":\n      return \"rgba(167, 139, 250, 0.15)\";\n    case \"illuminator\":\n      return \"rgba(168, 85, 247, 0.15)\";\n    case \"archivist\":\n      return \"rgba(59, 130, 246, 0.15)\";\n    case \"chronicler\":\n      return \"rgba(16, 185, 129, 0.15)\";\n    default:\n      return colors.hoverBg;\n  }\n}", "parameters": [{"name": "appId", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/coherence-engine/webui/src/CoherenceEngineRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/coherence-engine/webui/src/CoherenceEngineRemote.jsx", "sourceCode": "export default function CoherenceEngineRemote({\n  projectId,\n  schema,\n  eras = [],\n  onErasChange,\n  pressures = [],\n  onPressuresChange,\n  generators = [],\n  onGeneratorsChange,\n  actions = [],\n  onActionsChange,\n  systems = [],\n  onSystemsChange,\n  activeSection,\n  onSectionChange,\n}) {\n  // Use passed-in section or default to 'validation'\n  const activeTab = activeSection || \"validation\";\n  const setActiveTab = onSectionChange || (() => {});\n\n  const currentSection = SECTION_INFO[activeTab] || SECTION_INFO.validation;\n\n  // Compute usage map for cross-reference tracking and validation (must be before validationStatus)\n  const usageMap = useMemo(\n    () => computeUsageMap(schema, pressures, eras, generators, systems, actions),\n    [schema, pressures, eras, generators, systems, actions]\n  );\n\n  // Calculate validation status for the nav indicator (uses usageMap)\n  const validationStatus = useMemo(\n    () => getValidationStatus(usageMap, schema, eras, pressures, generators, systems),\n    [usageMap, schema, eras, pressures, generators, systems]\n  );\n\n  // Navigate to generators tab and optionally select a specific generator\n  const handleNavigateToGenerator = (_generatorId) => {\n    setActiveTab(\"generators\");\n    // NOOP: generator expansion not yet implemented\n  };\n\n  const renderContent = () => {\n    switch (activeTab) {\n      case \"validation\":\n        return (\n          <ValidationEditor\n            schema={schema}\n            eras={eras}\n            pressures={pressures}\n            generators={generators}\n            systems={systems}\n            actions={actions}\n            usageMap={usageMap}\n            onNavigateToGenerator={handleNavigateToGenerator}\n          />\n        );\n      case \"causal\":\n        return (\n          <CausalLoopEditor\n            pressures={pressures}\n            generators={generators}\n            systems={systems}\n            actions={actions}\n            schema={schema}\n            usageMap={usageMap}\n          />\n        );\n      case \"pressures\":\n        return (\n          <PressuresEditor\n            projectId={projectId}\n            pressures={pressures}\n            onChange={onPressuresChange || (() => {})}\n            schema={schema}\n            usageMap={usageMap}\n          />\n        );\n      case \"eras\":\n        return (\n          <ErasEditor\n            eras={eras}\n            onChange={onErasChange || (() => {})}\n            generators={generators}\n            systems={systems}\n            pressures={pressures}\n            schema={schema}\n            usageMap={usageMap}\n          />\n        );\n      case \"matrix\":\n        return (\n          <WeightMatrixEditor\n            generators={generators}\n            systems={systems}\n            eras={eras}\n            onErasChange={onErasChange || (() => {})}\n          />\n        );\n      case \"generators\":\n        return (\n          <GeneratorsEditor\n            projectId={projectId}\n            generators={generators}\n            onChange={onGeneratorsChange || (() => {})}\n            schema={schema}\n            pressures={pressures}\n            eras={eras}\n            usageMap={usageMap}\n          />\n        );\n      case \"actions\":\n        return (\n          <ActionsEditor\n            projectId={projectId}\n            actions={actions}\n            onChange={onActionsChange || (() => {})}\n            schema={schema}\n            pressures={pressures}\n            usageMap={usageMap}\n          />\n        );\n      case \"systems\":\n        return (\n          <SystemsEditor\n            projectId={projectId}\n            systems={systems}\n            onChange={onSystemsChange || (() => {})}\n            schema={schema}\n            pressures={pressures}\n            usageMap={usageMap}\n          />\n        );\n      default:\n        return (\n          <div className=\"cer-placeholder\">\n            <div className=\"cer-placeholder-icon\"></div>\n            <div className=\"cer-placeholder-title\">{currentSection.title}</div>\n            <div className=\"cer-placeholder-desc\">{currentSection.description}</div>\n          </div>\n        );\n    }\n  };\n\n  return (\n    <div className=\"cer-container\">\n      {/* Left sidebar with nav */}\n      <div className=\"cer-sidebar\">\n        <nav className=\"cer-nav\">\n          {TABS.map((tab) => {\n            // Show status indicator for validation tab\n            const showStatus = tab.id === \"validation\";\n            const statusColor = STATUS_COLORS[validationStatus.status];\n\n            return (\n              <button\n                key={tab.id}\n                onClick={() => setActiveTab(tab.id)}\n                className={`cer-nav-button ${activeTab === tab.id ? \"cer-nav-button-active\" : \"cer-nav-button-inactive\"}`}\n              >\n                <span className=\"cer-nav-button-content\">\n                  <span>{tab.label}</span>\n                  {showStatus && (\n                    <span\n                      className=\"cer-status-dot\"\n                      // eslint-disable-next-line local/no-inline-styles -- dynamic color from validation status\n                      style={{ '--cer-status-color': statusColor, backgroundColor: 'var(--cer-status-color)' }}\n                      title={(() => {\n                        if (validationStatus.status === \"clean\") return \"All validations passed\";\n                        const plural = validationStatus.totalIssues === 1 ? \"\" : \"s\";\n                        return `${validationStatus.totalIssues} issue${plural}`;\n                      })()}\n                    />\n                  )}\n                </span>\n              </button>\n            );\n          })}\n        </nav>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"cer-main\">\n        <div className=\"cer-content\">{renderContent()}</div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras = [],\n  onErasChange,\n  pressures = [],\n  onPressuresChange,\n  generators = [],\n  onGeneratorsChange,\n  actions = [],\n  onActionsChange,\n  systems = [],\n  onSystemsChange,\n  activeSection,\n  onSectionChange,\n}", "type": "{ projectId: any; schema: any; eras?: any[]; onErasChange: any; pressures?: any[]; onPressuresChange: any; generators?: any[]; onGeneratorsChange: any; actions?: any[]; onActionsChange: any; systems?: any[]; onSystemsChange: any; activeSection: any; onSectionChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components/styles", "specifiers": [], "category": "external"}, {"source": "./styles/index.css", "specifiers": [], "category": "internal"}, {"source": "./CoherenceEngineRemote.css", "specifiers": [], "category": "internal"}, {"source": "./components/eras", "specifiers": ["ErasEditor"], "category": "internal"}, {"source": "./components/PressuresEditor", "specifiers": ["PressuresEditor"], "category": "internal"}, {"source": "./components/GeneratorsEditor", "specifiers": ["GeneratorsEditor"], "category": "internal"}, {"source": "./components/ActionsEditor", "specifiers": ["ActionsEditor"], "category": "internal"}, {"source": "./components/SystemsEditor", "specifiers": ["SystemsEditor"], "category": "internal"}, {"source": "./components/ValidationEditor", "specifiers": ["ValidationEditor", "getValidationStatus"], "category": "internal"}, {"source": "./components/weight-matrix", "specifiers": ["WeightMatrixEditor"], "category": "internal"}, {"source": "./components/CausalLoopEditor", "specifiers": ["CausalLoopEditor"], "category": "internal"}, {"source": "@the-canonry/shared-components", "specifiers": ["computeUsageMap"], "category": "external"}]}, {"id": "apps/cosmographer/webui/src/CosmographerRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/cosmographer/webui/src/CosmographerRemote.jsx", "sourceCode": "export default function CosmographerRemote({\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage,\n}) {\n  // Use passed-in section or default to 'axes'\n  const activeTab = activeSection || \"axes\";\n  const setActiveTab = onSectionChange || (() => {});\n\n  // Build internal project representation\n  const project = useMemo(\n    () => ({\n      entityKinds: schema?.entityKinds || [],\n      relationshipKinds: schema?.relationshipKinds || [],\n      cultures: schema?.cultures || [],\n      axisDefinitions: axisDefinitions || [],\n      seedEntities: seedEntities || [],\n      seedRelationships: seedRelationships || [],\n      tagRegistry: schema?.tagRegistry || [],\n    }),\n    [schema, axisDefinitions, seedEntities, seedRelationships]\n  );\n\n  // Handle save - route updates to appropriate callbacks\n  const handleSave = useCallback(\n    (updates) => {\n      if (updates.entityKinds && onEntityKindsChange) {\n        onEntityKindsChange(updates.entityKinds);\n      }\n\n      // Handle seed entity changes\n      if (updates.seedEntities && onSeedEntitiesChange) {\n        onSeedEntitiesChange(updates.seedEntities);\n      }\n\n      // Handle seed relationship changes\n      if (updates.seedRelationships && onSeedRelationshipsChange) {\n        onSeedRelationshipsChange(updates.seedRelationships);\n      }\n\n      if (updates.cultures && onCulturesChange) {\n        onCulturesChange(updates.cultures);\n      }\n    },\n    [onEntityKindsChange, onCulturesChange, onSeedEntitiesChange, onSeedRelationshipsChange]\n  );\n\n  const hasSchema = schema?.entityKinds?.length > 0 || schema?.cultures?.length > 0;\n\n  if (!hasSchema) {\n    return (\n      <div className=\"cosmo-container\">\n        <div className=\"cosmo-no-schema\">\n          <div className=\"cosmo-no-schema-title\">No Schema Defined</div>\n          <div>\n            Define entity kinds and cultures in the <strong>Enumerist</strong> tab first, then\n            return here to place entities and manage relationships.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const renderContent = () => {\n    switch (activeTab) {\n      case \"axes\":\n        return (\n          <AxisRegistryEditor\n            axisDefinitions={project.axisDefinitions}\n            entityKinds={project.entityKinds}\n            tagRegistry={project.tagRegistry}\n            onAxisDefinitionsChange={onAxisDefinitionsChange}\n            onTagRegistryChange={onTagRegistryChange}\n          />\n        );\n      case \"planes\":\n        return (\n          <SemanticPlaneEditor\n            project={project}\n            onSave={handleSave}\n            axisDefinitions={project.axisDefinitions}\n          />\n        );\n      case \"cultures\":\n        return <CultureEditor project={project} onSave={handleSave} />;\n      case \"entities\":\n        return (\n          <EntityEditor\n            project={project}\n            onSave={handleSave}\n            onAddTag={onAddTag}\n            schemaUsage={schemaUsage}\n          />\n        );\n      case \"relationships\":\n        return <RelationshipEditor project={project} onSave={handleSave} />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"cosmo-container\">\n      {/* Left sidebar with nav */}\n      <div className=\"cosmo-sidebar\">\n        <nav className=\"cosmo-nav\">\n          {TABS.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`cosmo-nav-button ${activeTab === tab.id ? \"cosmo-nav-button-active\" : \"cosmo-nav-button-inactive\"}`}\n            >\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"cosmo-main\">\n        <div className=\"cosmo-content\">{renderContent()}</div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage,\n}", "type": "{ schema: any; axisDefinitions: any; seedEntities: any; seedRelationships: any; onEntityKindsChange: any; onCulturesChange: any; onAxisDefinitionsChange: any; onTagRegistryChange: any; onSeedEntitiesChange: any; onSeedRelationshipsChange: any; onAddTag: any; activeSection: any; onSectionChange: any; schemaUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./components/SemanticPlane/index.jsx", "specifiers": ["SemanticPlaneEditor"], "category": "internal"}, {"source": "./components/CultureEditor/index.jsx", "specifiers": ["CultureEditor"], "category": "internal"}, {"source": "./components/EntityEditor/index.jsx", "specifiers": ["EntityEditor"], "category": "internal"}, {"source": "./components/RelationshipEditor/index.jsx", "specifiers": ["RelationshipEditor"], "category": "internal"}, {"source": "./components/AxisRegistry/index.jsx", "specifiers": ["AxisRegistryEditor"], "category": "internal"}, {"source": "./CosmographerRemote.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/name-forge/webui/src/NameForgeRemote.jsx::default", "name": "default", "kind": "function", "filePath": "apps/name-forge/webui/src/NameForgeRemote.jsx", "sourceCode": "export default function NameForgeRemote({\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators = [],\n}) {\n  // Use passed-in section or default to 'workshop'\n  const activeTab = activeSection || \"workshop\";\n  const setActiveTab = onSectionChange || (() => {});\n  const storageKey = projectId ? `nameforge:ui:${projectId}` : null;\n  const [selectedCulture, setSelectedCulture] = useState(null);\n  const [workspaceTab, setWorkspaceTab] = useState(\"domain\");\n  const [hydratedKey, setHydratedKey] = useState(null);\n\n  // Session-only API key (not persisted)\n  const [apiKey, setApiKey] = useState(\"\");\n  const [showApiKeyInput, setShowApiKeyInput] = useState(false);\n\n  // GenerateTab form state\n  const [generateFormState, setGenerateFormState] = useState({\n    selectedCulture: \"\",\n    selectedProfile: \"\",\n    selectedKind: \"\",\n    selectedSubKind: \"\",\n    tags: [],\n    prominence: \"\",\n    count: 20,\n    contextPairs: [{ key: \"\", value: \"\" }],\n  });\n\n  const worldSchema = useMemo(\n    () => schema || { entityKinds: [], relationshipKinds: [], cultures: [], tagRegistry: [] },\n    [schema]\n  );\n\n  const cultures = useMemo(() => {\n    const map = {};\n    (schema?.cultures || []).forEach((culture) => {\n      map[culture.id] = culture;\n    });\n    return map;\n  }, [schema?.cultures]);\n\n  // Handle culture updates from the workspace\n  const handleCultureChange = useCallback(\n    (updatedCulture) => {\n      if (!selectedCulture || !onNamingDataChange) return;\n\n      const newNamingData = updatedCulture?.naming || {\n        domains: [],\n        lexemeLists: {},\n        lexemeSpecs: [],\n        grammars: [],\n        profiles: [],\n      };\n      onNamingDataChange(selectedCulture, newNamingData);\n    },\n    [selectedCulture, onNamingDataChange]\n  );\n\n  // Handle cultures change (for optimizer updates)\n  const handleCulturesChange = useCallback(\n    (newCultures) => {\n      if (!onNamingDataChange) return;\n\n      Object.entries(newCultures).forEach(([cultureId, culture]) => {\n        const naming = culture?.naming || {\n          domains: [],\n          lexemeLists: {},\n          lexemeSpecs: [],\n          grammars: [],\n          profiles: [],\n        };\n        onNamingDataChange(cultureId, naming);\n      });\n    },\n    [onNamingDataChange]\n  );\n\n  // Auto-select first culture if none selected\n  const cultureIds = Object.keys(cultures);\n\n  useEffect(() => {\n    if (!storageKey || typeof localStorage === \"undefined\") {\n      setHydratedKey(storageKey);\n      return;\n    }\n    try {\n      const raw = localStorage.getItem(storageKey);\n      if (raw) {\n        const parsed = JSON.parse(raw);\n        setSelectedCulture(parsed?.selectedCulture || null);\n        setWorkspaceTab(parsed?.workspaceTab || \"domain\");\n      } else {\n        setSelectedCulture(null);\n        setWorkspaceTab(\"domain\");\n      }\n    } catch {\n      setSelectedCulture(null);\n      setWorkspaceTab(\"domain\");\n    } finally {\n      setHydratedKey(storageKey);\n    }\n  }, [storageKey]);\n\n  useEffect(() => {\n    if (!storageKey || typeof localStorage === \"undefined\") return;\n    if (hydratedKey !== storageKey) return;\n    try {\n      localStorage.setItem(\n        storageKey,\n        JSON.stringify({\n          selectedCulture,\n          workspaceTab,\n        })\n      );\n    } catch {\n      // Best-effort only.\n    }\n  }, [storageKey, hydratedKey, selectedCulture, workspaceTab]);\n\n  useEffect(() => {\n    if (hydratedKey !== storageKey) return;\n    if (!cultureIds.length) return;\n    if (selectedCulture && cultures[selectedCulture]) return;\n    setSelectedCulture(cultureIds[0]);\n  }, [hydratedKey, storageKey, cultureIds, cultures, selectedCulture]);\n\n  const hasCultures = cultureIds.length > 0;\n\n  if (!hasCultures) {\n    return (\n      <div className=\"nf-empty-state\">\n        <div className=\"nf-empty-state-icon\"></div>\n        <div className=\"nf-empty-state-title\">No Cultures Defined</div>\n        <div className=\"nf-empty-state-desc\">\n          Add cultures in the <strong>Enumerist</strong> tab first, then return here to configure\n          naming domains, grammars, and profiles.\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"nf-container\">\n      {/* Left sidebar with nav and cultures */}\n      <div className=\"nf-sidebar\">\n        <nav className=\"nf-nav\">\n          {TABS.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`nf-nav-button ${activeTab === tab.id ? \"active\" : \"\"}`}\n            >\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n\n        {/* API Key section */}\n        <div className=\"nf-api-section\">\n          <button\n            onClick={() => setShowApiKeyInput(!showApiKeyInput)}\n            className={`nf-api-button ${apiKey ? \"active\" : \"\"}`}\n          >\n            {apiKey ? \"\u2713 API Key Set\" : \"Set API Key\"}\n          </button>\n          {showApiKeyInput && (\n            <div className=\"nf-api-dropdown\">\n              <div className=\"nf-api-dropdown-title\">Anthropic API Key</div>\n              <p className=\"nf-api-dropdown-hint\">Required for LLM lexeme generation.</p>\n              <input\n                type=\"password\"\n                value={apiKey}\n                onChange={(e) => setApiKey(e.target.value)}\n                placeholder=\"sk-ant-...\"\n                className=\"nf-api-input\"\n              />\n              <button onClick={() => setShowApiKeyInput(false)} className=\"nf-api-button active\">\n                Done\n              </button>\n            </div>\n          )}\n        </div>\n\n        {/* Culture sidebar - always visible */}\n        <div className=\"nf-culture-section\">\n          <CultureSidebar\n            cultures={cultures}\n            selectedCulture={selectedCulture}\n            onSelectCulture={setSelectedCulture}\n            onCulturesChange={handleCulturesChange}\n            readOnly={true}\n          />\n        </div>\n      </div>\n\n      {/* Main content area */}\n      <div className=\"nf-main\">\n        {activeTab === \"workshop\" && (\n          <div className=\"nf-content\">\n            <EntityWorkspace\n              worldSchema={worldSchema}\n              cultureId={selectedCulture}\n              cultureConfig={selectedCulture ? cultures[selectedCulture] : null}\n              allCultures={cultures}\n              activeTab={workspaceTab}\n              onTabChange={setWorkspaceTab}\n              onCultureChange={handleCultureChange}\n              onAddTag={onAddTag}\n              apiKey={apiKey}\n              generators={generators}\n            />\n          </div>\n        )}\n\n        {activeTab === \"optimizer\" && (\n          <div className=\"nf-content\">\n            <OptimizerWorkshop cultures={cultures} onCulturesChange={handleCulturesChange} />\n          </div>\n        )}\n\n        {activeTab === \"generate\" && (\n          <div className=\"nf-content\">\n            <GenerateTab\n              worldSchema={worldSchema}\n              cultures={cultures}\n              formState={generateFormState}\n              onFormStateChange={setGenerateFormState}\n            />\n          </div>\n        )}\n\n        {activeTab === \"coverage\" && (\n          <div className=\"nf-content\">\n            <ProfileCoverageMatrix\n              cultures={cultures}\n              worldSchema={worldSchema}\n              onNavigateToProfile={(cultureId, _profileId) => {\n                setSelectedCulture(cultureId);\n                setWorkspaceTab(\"profiles\");\n                setActiveTab(\"workshop\");\n              }}\n            />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators = [],\n}", "type": "{ projectId: any; schema: any; onNamingDataChange: any; onAddTag: any; activeSection: any; onSectionChange: any; generators?: any[]; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useMemo", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./App.css", "specifiers": [], "category": "internal"}, {"source": "./components/sidebar", "specifiers": ["CultureSidebar"], "category": "internal"}, {"source": "./components/workspace", "specifiers": ["EntityWorkspace"], "category": "internal"}, {"source": "./components/optimizer", "specifiers": ["OptimizerWorkshop"], "category": "internal"}, {"source": "./components/generator", "specifiers": ["GenerateTab"], "category": "internal"}, {"source": "./components/coverage/ProfileCoverageMatrix", "specifiers": ["ProfileCoverageMatrix"], "category": "internal"}]}, {"id": "packages/shared-components/src/utils/index.js::computeUsageMap", "name": "computeUsageMap", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Schema Usage Map - Computes bidirectional reference tracking across all config elements\n *\n * This utility analyzes the relationships between:\n * - Schema (entity kinds, relationship kinds, statuses, subtypes, tags)\n * - Pressures (and their feedback factors)\n * - Eras (and their generator/system weights)\n * - Generators (and their entity/relationship references)\n * - Systems (and their entity/relationship/pressure references)\n * - Actions (and their actor/target/outcome references)\n *\n * Returns a comprehensive map showing:\n * 1. Where each element is used (forward references)\n * 2. What each element references (backward references)\n * 3. Validation status for each reference\n */\n\n/**\n * Compute complete usage map for all schema elements\n */\nexport function computeUsageMap(schema, pressures, eras, generators, systems, actions) {\n  const usageMap = {\n    // Schema element usage tracking\n    entityKinds: {},      // { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    subtypes: {},         // { subtype: { generators: [], systems: [], actions: [] } }\n    statuses: {},         // { status: { generators: [], systems: [], actions: [] } }\n    relationshipKinds: {},// { kindId: { generators: [], systems: [], actions: [], pressures: [] } }\n    tags: {},             // { tag: { pressures: [], systems: [], generators: [], actions: [] } }\n\n    // Cross-tab reference tracking\n    pressures: {},        // { pressureId: { generators: [], systems: [], actions: [], eras: [] } }\n    generators: {},       // generatorId -> eras with id and weight\n    systems: {},          // systemId -> eras with id and weight\n\n    // Validation results\n    validation: {\n      invalidRefs: [],    // [{ type, id, field, refType, refId, location }]\n      orphans: [],        // [{ type, id, reason }]\n      compatibility: [],  // [{ type, id, field, issue }]\n    }\n  };\n\n  // Initialize from schema\n  initializeFromSchema(usageMap, schema);\n\n  // Initialize pressure tracking\n  initializePressures(usageMap, pressures);\n\n  // Initialize generator/system tracking\n  initializeGeneratorsAndSystems(usageMap, generators, systems);\n\n  // Scan pressures for schema references\n  scanPressureReferences(usageMap, pressures, schema);\n\n  // Scan eras for generator/system references\n  scanEraReferences(usageMap, eras, generators, systems);\n\n  // Scan generators for all references\n  scanGeneratorReferences(usageMap, generators, schema, pressures);\n\n  // Scan systems for all references\n  scanSystemReferences(usageMap, systems, schema, pressures);\n\n  // Scan actions for all references\n  scanActionReferences(usageMap, actions, schema, pressures);\n\n  // Detect orphans (unused elements)\n  detectOrphans(usageMap, schema, pressures, generators, systems);\n\n  // Check relationship compatibility\n  checkRelationshipCompatibility(usageMap, generators, actions, schema);\n\n  return usageMap;\n}", "parameters": [{"name": "schema", "type": "any", "optional": false}, {"name": "pressures", "type": "any", "optional": false}, {"name": "eras", "type": "any", "optional": false}, {"name": "generators", "type": "any", "optional": false}, {"name": "systems", "type": "any", "optional": false}, {"name": "actions", "type": "any", "optional": false}], "returnType": "{ entityKinds: {}; subtypes: {}; statuses: {}; relationshipKinds: {}; tags: {}; pressures: {}; generators: {}; systems: {}; validation: { invalidRefs: any[]; orphans: any[]; compatibility: any[]; }; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/index.js::getElementValidation", "name": "getElementValidation", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get validation status for a specific element\n */\nexport function getElementValidation(usageMap, type, id) {\n  const invalidRefs = usageMap.validation.invalidRefs.filter(\n    ref => ref.type === type && ref.id === id\n  );\n  const compatibility = usageMap.validation.compatibility.filter(\n    c => c.type === type && c.id === id\n  );\n  const isOrphan = usageMap.validation.orphans.some(\n    o => o.type === type && o.id === id\n  );\n\n  return {\n    isValid: invalidRefs.length === 0 && compatibility.length === 0,\n    invalidRefs,\n    compatibility,\n    isOrphan,\n  };\n}", "parameters": [{"name": "usageMap", "type": "any", "optional": false}, {"name": "type", "type": "any", "optional": false}, {"name": "id", "type": "any", "optional": false}], "returnType": "{ isValid: boolean; invalidRefs: any; compatibility: any; isOrphan: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/index.js::getUsageSummary", "name": "getUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get usage summary for display\n */\nexport function getUsageSummary(usage) {\n  const parts = [];\n  if (usage.generators?.length > 0) {\n    parts.push(`${usage.generators.length} generator${usage.generators.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.systems?.length > 0) {\n    parts.push(`${usage.systems.length} system${usage.systems.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.actions?.length > 0) {\n    parts.push(`${usage.actions.length} action${usage.actions.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.pressures?.length > 0) {\n    parts.push(`${usage.pressures.length} pressure${usage.pressures.length !== 1 ? 's' : ''}`);\n  }\n  if (usage.eras?.length > 0) {\n    parts.push(`${usage.eras.length} era${usage.eras.length !== 1 ? 's' : ''}`);\n  }\n  return parts.length > 0 ? parts.join(', ') : 'Not used';\n}", "parameters": [{"name": "usage", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/index.js::computeTagUsage", "name": "computeTagUsage", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "export function computeTagUsage({ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions } = {}) {\n  const usage = {};\n\n  const ensureTag = (tag) => {\n    if (!usage[tag]) {\n      usage[tag] = {};\n    }\n  };\n\n  const addTagUsage = (tag, section) => {\n    if (!tag) return;\n    ensureTag(tag);\n    usage[tag][section] = (usage[tag][section] || 0) + 1;\n  };\n\n  const collectTagsFromFilters = (filters, section) => {\n    (filters || []).forEach((filter) => {\n      switch (filter.type) {\n        case 'has_tag':\n        case 'lacks_tag':\n          addTagUsage(filter.tag, section);\n          break;\n        case 'has_tags':\n        case 'has_any_tag':\n        case 'lacks_any_tag':\n          (filter.tags || []).forEach((tag) => addTagUsage(tag, section));\n          break;\n        default:\n          break;\n      }\n    });\n  };\n\n  const collectTagsFromCondition = (condition, section) => {\n    if (!condition) return;\n    switch (condition.type) {\n      case 'tag_exists':\n      case 'tag_absent':\n        addTagUsage(condition.tag, section);\n        break;\n      case 'and':\n      case 'or':\n        (condition.conditions || []).forEach((child) => collectTagsFromCondition(child, section));\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectTagsFromMutations = (mutations, section) => {\n    (mutations || []).forEach((mutation) => {\n      if (mutation.type === 'set_tag' || mutation.type === 'remove_tag') {\n        addTagUsage(mutation.tag, section);\n      }\n    });\n  };\n\n  collectCultureTags(cultures, ensureTag, usage);\n  collectSeedEntityTags(seedEntities, ensureTag, usage);\n  collectGeneratorTags(generators, addTagUsage, collectTagsFromCondition, collectTagsFromFilters, collectTagsFromMutations);\n  collectSystemTags(systems, addTagUsage, collectTagsFromFilters, collectTagsFromCondition, collectTagsFromMutations);\n  collectPressureTags(pressures, ensureTag, usage);\n  collectAxisTags(entityKinds, axisDefinitions, ensureTag, usage);\n\n  return usage;\n}", "parameters": [{"name": "{ cultures, seedEntities, generators, systems, pressures, entityKinds, axisDefinitions }", "type": "{}", "optional": true}], "returnType": "{}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/index.js::getEntityKindUsageSummary", "name": "getEntityKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get a summary of usage for an entity kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.entityKinds\n * @param {string} kind - Entity kind ID\n * @returns {Object} - { coherence: number, seed: number } for ToolUsageBadges component\n */\nexport function getEntityKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.entityKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const coherenceTotal =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0) +\n    (usage.pressures?.length || 0);\n\n  const seedTotal = usage.seeds?.length || 0;\n\n  return {\n    coherence: coherenceTotal,\n    ...(seedTotal > 0 && { seed: seedTotal }),\n  };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "packages/shared-components/src/utils/index.js::getRelationshipKindUsageSummary", "name": "getRelationshipKindUsageSummary", "kind": "function", "filePath": "packages/shared-components/src/utils/index.js", "sourceCode": "/**\n * Get a summary of usage for a relationship kind (for cross-tool badges)\n * @param {Object} schemaUsage - Output from computeSchemaUsage or usageMap.relationshipKinds\n * @param {string} kind - Relationship kind ID\n * @returns {Object} - { coherence: number } for ToolUsageBadges component\n */\nexport function getRelationshipKindUsageSummary(schemaUsage, kind) {\n  const usage = schemaUsage?.relationshipKinds?.[kind];\n  if (!usage) return { coherence: 0 };\n\n  const total =\n    (usage.generators?.length || 0) +\n    (usage.systems?.length || 0) +\n    (usage.actions?.length || 0);\n\n  return { coherence: total };\n}", "parameters": [{"name": "schemaUsage", "type": "any", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsConfig", "name": "loadAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsConfig() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(CONFIG_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsConfig", "name": "saveAwsConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsConfig(config) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!config) {\n    localStorage.removeItem(CONFIG_KEY);\n    return;\n  }\n  localStorage.setItem(CONFIG_KEY, JSON.stringify(config));\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::loadAwsTokens", "name": "loadAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function loadAwsTokens() {\n  if (typeof localStorage === \"undefined\") return null;\n  const stored = localStorage.getItem(TOKEN_KEY);\n  return safeParse(stored, null);\n}", "parameters": [], "returnType": "any", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::saveAwsTokens", "name": "saveAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function saveAwsTokens(tokens) {\n  if (typeof localStorage === \"undefined\") return;\n  if (!tokens) {\n    localStorage.removeItem(TOKEN_KEY);\n    return;\n  }\n  localStorage.setItem(TOKEN_KEY, JSON.stringify(tokens));\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::clearAwsTokens", "name": "clearAwsTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function clearAwsTokens() {\n  if (typeof localStorage === \"undefined\") return;\n  localStorage.removeItem(TOKEN_KEY);\n}", "parameters": [], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsConfigStorage.js::isTokenValid", "name": "isTokenValid", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsConfigStorage.js", "sourceCode": "export function isTokenValid(tokens) {\n  if (!tokens?.idToken) return false;\n  if (!tokens.expiresAt) return true;\n  return Date.now() < tokens.expiresAt - 30_000;\n}", "parameters": [{"name": "tokens", "type": "any", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildImageStorageConfig", "name": "buildImageStorageConfig", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildImageStorageConfig(config, projectId) {\n  if (!config?.imageBucket) return null;\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  return {\n    provider: \"s3\",\n    bucket: config.imageBucket.trim(),\n    region: config.region?.trim() || \"us-east-1\",\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    projectId,\n  };\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "projectId", "type": "any", "optional": false}], "returnType": "{ provider: string; bucket: any; region: any; basePrefix: any; rawPrefix: string; webpPrefix: string; thumbPrefix: string; projectId: any; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::createS3Client", "name": "createS3Client", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function createS3Client(config, tokens) {\n  if (!config?.identityPoolId || !config?.region) return null;\n  const region = config.region.trim();\n  const identityPoolId = config.identityPoolId.trim();\n  const logins = {};\n  const userPoolId = config.cognitoUserPoolId?.trim();\n  if (tokens?.idToken && userPoolId) {\n    const loginKey = `cognito-idp.${region}.amazonaws.com/${userPoolId}`;\n    logins[loginKey] = tokens.idToken;\n  }\n\n  return new S3Client({\n    region,\n    credentials: fromCognitoIdentityPool({\n      clientConfig: { region },\n      identityPoolId,\n      logins: Object.keys(logins).length ? logins : undefined,\n    }),\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}, {"name": "tokens", "type": "any", "optional": false}], "returnType": "S3Client", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::loadImageManifest", "name": "loadImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function loadImageManifest(s3, { bucket, basePrefix }) {\n  if (!s3 || !bucket) return null;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  try {\n    const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n    const text = await readBodyAsText(response.Body);\n    if (!text) return null;\n    return JSON.parse(text);\n  } catch (err) {\n    if (err?.name === \"NoSuchKey\" || err?.$metadata?.httpStatusCode === 404) {\n      return null;\n    }\n    console.warn(\"Failed to load image manifest:\", err);\n    return null;\n  }\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::saveImageManifest", "name": "saveImageManifest", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function saveImageManifest(s3, { bucket, basePrefix }, manifest) {\n  if (!s3 || !bucket) return;\n  const key = toS3Key(basePrefix, MANIFEST_NAME);\n  const body = JSON.stringify(manifest, null, 2);\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, basePrefix }", "type": "{ bucket: any; basePrefix: any; }", "optional": false}, {"name": "manifest", "type": "any", "optional": false}], "returnType": "Promise<void>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::listS3Prefixes", "name": "listS3Prefixes", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function listS3Prefixes(s3, { bucket, prefix }) {\n  if (!s3 || !bucket) return [];\n  const response = await s3.send(\n    new ListObjectsV2Command({\n      Bucket: bucket,\n      Prefix: prefix || undefined,\n      Delimiter: \"/\",\n      MaxKeys: 200,\n    })\n  );\n  return (response.CommonPrefixes || []).map((item) => item.Prefix).filter(Boolean);\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "{ bucket, prefix }", "type": "{ bucket: any; prefix: any; }", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::getS3ImageUploadPlan", "name": "getS3ImageUploadPlan", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function getS3ImageUploadPlan({ projectId, s3, config, repairSizes = false }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const manifestFromS3 = await loadImageManifest(s3, { bucket, basePrefix });\n  const manifest = manifestFromS3 || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix: DEFAULT_RAW_PREFIX,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  const candidates = [];\n  const repairs = { attempted: 0, updated: 0, skipped: 0, failed: 0 };\n  const manifestRepairs = { updated: 0, skipped: 0, failed: 0 };\n  const canRepairManifest = Boolean(repairSizes && manifestFromS3);\n  let manifestChanged = false;\n  let db = null;\n\n  try {\n    if (repairSizes) {\n      db = await openIlluminatorDb();\n    }\n\n    for (const image of images) {\n      if (!image?.imageId) continue;\n      const updatedAt = image.savedAt || image.generatedAt || 0;\n      const entry = existing[image.imageId];\n      const rawSize = image.size;\n      const normalizedSize = normalizeImageSize(rawSize);\n\n      let { effectiveSize, sizeSource, needsBlob } = resolveEffectiveSize(\n        image, entry, updatedAt, normalizedSize, repairSizes\n      );\n      let blob = null;\n\n      if (needsBlob) {\n        blob = await getImageBlob(image.imageId);\n        ({ effectiveSize, sizeSource } = applyBlobSize(blob, effectiveSize, sizeSource));\n      }\n\n      if (canRepairManifest && entry && entry.updatedAt >= updatedAt) {\n        if (repairManifestEntry(entry, updatedAt, effectiveSize, manifestRepairs)) {\n          manifestChanged = true;\n        }\n      }\n\n      if (repairSizes && blob && effectiveSize != null && effectiveSize !== normalizedSize) {\n        await repairImageSize(db, image.imageId, effectiveSize, repairs);\n      }\n\n      const reasons = collectUploadReasons(entry, updatedAt, effectiveSize);\n      if (!reasons.length) continue;\n\n      candidates.push({\n        imageId: image.imageId,\n        entityId: image.entityId || null,\n        entityName: image.entityName || null,\n        imageType: image.imageType || \"entity\",\n        updatedAt,\n        size: rawSize ?? null,\n        effectiveSize,\n        sizeSource,\n        manifestUpdatedAt: entry?.updatedAt ?? null,\n        manifestSize: entry?.size ?? null,\n        reason: reasons.join(\"+\"),\n      });\n    }\n  } finally {\n    if (db) {\n      db.close();\n    }\n  }\n\n  if (canRepairManifest && manifestChanged) {\n    manifest.generatedAt = new Date().toISOString();\n    manifest.count = Object.keys(existing).length;\n    await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n  }\n\n  return {\n    total: images.length,\n    candidates,\n    manifestFound: Boolean(manifestFromS3),\n    basePrefix,\n    repairs: repairSizes ? repairs : null,\n    manifestRepairs: canRepairManifest ? manifestRepairs : null,\n  };\n}", "parameters": [{"name": "{ projectId, s3, config, repairSizes = false }", "type": "{ projectId: any; s3: any; config: any; repairSizes?: boolean; }", "optional": false}], "returnType": "Promise<{ total: any; candidates: { imageId: any; entityId: any; entityName: any; imageType: any; updatedAt: any; size: any; effectiveSize: any; sizeSource: string; manifestUpdatedAt: any; manifestSize: any; reason: string; }[]; manifestFound: boolean; basePrefix: any; repairs: { attempted: number; updated: number; skipped: number; failed: number; }; manifestRepairs: { updated: number; skipped: number; failed: number; }; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::syncProjectImagesToS3", "name": "syncProjectImagesToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export async function syncProjectImagesToS3({ projectId, s3, config, onProgress }) {\n  if (!projectId) throw new Error(\"Missing projectId for image sync\");\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n  const rawPrefix = DEFAULT_RAW_PREFIX;\n  const manifest = (await loadImageManifest(s3, { bucket, basePrefix })) || {\n    version: 1,\n    generatedAt: new Date().toISOString(),\n    bucket,\n    basePrefix,\n    rawPrefix,\n    webpPrefix: DEFAULT_WEBP_PREFIX,\n    thumbPrefix: DEFAULT_THUMB_PREFIX,\n    images: {},\n  };\n\n  const existing = manifest.images || {};\n  const images = await getImagesByProject(projectId);\n  let processed = 0;\n  let uploaded = 0;\n  const total = images.length;\n\n  for (const image of images) {\n    if (!image?.imageId) continue;\n    processed += 1;\n    if (onProgress) {\n      onProgress({ phase: \"scan\", processed, total, uploaded });\n    }\n\n    const updatedAt = image.savedAt || image.generatedAt || 0;\n    const entry = existing[image.imageId];\n    const normalizedSize = normalizeImageSize(image.size);\n\n    let blob = null;\n    if (entry && entry.updatedAt >= updatedAt && normalizedSize == null) {\n      blob = await getImageBlob(image.imageId);\n    }\n\n    if (shouldSkipSyncImage(entry, updatedAt, normalizedSize, blob)) continue;\n\n    if (!blob) {\n      blob = await getImageBlob(image.imageId);\n      if (!blob) continue;\n    }\n\n    const buffer = await blob.arrayBuffer();\n    const body = new Uint8Array(buffer);\n    const contentLength = body.byteLength;\n\n    const rawKey = toS3Key(basePrefix, rawPrefix, projectId, image.imageId);\n    const tagging = buildTagging({ ...image, projectId, savedAt: updatedAt });\n\n    await s3.send(\n      new PutObjectCommand({\n        Bucket: bucket,\n        Key: rawKey,\n        Body: body,\n        ContentType: image.mimeType || blob.type || \"application/octet-stream\",\n        ContentLength: contentLength,\n        Tagging: tagging,\n        CacheControl: \"public, max-age=31536000, immutable\",\n      })\n    );\n\n    existing[image.imageId] = buildManifestEntry(\n      image, projectId, rawKey, blob, normalizedSize, contentLength, updatedAt\n    );\n\n    uploaded += 1;\n    if (onProgress) {\n      onProgress({ phase: \"upload\", processed, total, uploaded });\n    }\n  }\n\n  manifest.images = existing;\n  manifest.generatedAt = new Date().toISOString();\n  manifest.count = Object.keys(existing).length;\n  await saveImageManifest(s3, { bucket, basePrefix }, manifest);\n\n  return { total, uploaded, manifest };\n}", "parameters": [{"name": "{ projectId, s3, config, onProgress }", "type": "{ projectId: any; s3: any; config: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: any; uploaded: number; manifest: any; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/awsS3.js::buildStorageImageUrl", "name": "buildStorageImageUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/awsS3.js", "sourceCode": "export function buildStorageImageUrl(storage, variant, imageId) {\n  if (!storage || !imageId) return null;\n  const basePrefix = storage.basePrefix || \"\";\n  const projectId = storage.projectId || \"\";\n  let prefix;\n  if (variant === \"raw\") {\n    prefix = storage.rawPrefix;\n  } else if (variant === \"thumb\") {\n    prefix = storage.thumbPrefix;\n  } else {\n    prefix = storage.webpPrefix;\n  }\n  const filename = variant === \"raw\" ? imageId : `${imageId}.webp`;\n  const path = toS3Key(basePrefix, prefix, projectId, filename);\n  return `/${path}`;\n}", "parameters": [{"name": "storage", "type": "any", "optional": false}, {"name": "variant", "type": "any", "optional": false}, {"name": "imageId", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["S3Client", "GetObjectCommand", "PutObjectCommand", "ListObjectsV2Command"], "category": "external"}, {"source": "@aws-sdk/credential-provider-cognito-identity", "specifiers": ["fromCognitoIdentityPool"], "category": "external"}, {"source": "../lib/imageExportHelpers", "specifiers": ["getImageBlob", "getImagesByProject"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::extractCognitoTokensFromUrl", "name": "extractCognitoTokensFromUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function extractCognitoTokensFromUrl() {\n  if (typeof window === \"undefined\") return null;\n  const params = parseHashParams(window.location.hash || \"\");\n  if (!params.id_token) return null;\n  const expiresIn = Number(params.expires_in || 0);\n  const expiresAt = expiresIn ? Date.now() + expiresIn * 1000 : null;\n  return {\n    idToken: params.id_token,\n    accessToken: params.access_token || null,\n    tokenType: params.token_type || null,\n    expiresAt,\n  };\n}", "parameters": [], "returnType": "{ idToken: any; accessToken: any; tokenType: any; expiresAt: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::clearCognitoHash", "name": "clearCognitoHash", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function clearCognitoHash() {\n  if (typeof window === \"undefined\") return;\n  if (window.location.hash) {\n    history.replaceState(null, document.title, window.location.pathname + window.location.search);\n  }\n}", "parameters": [], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLoginUrl", "name": "buildHostedUiLoginUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLoginUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const scope = config?.cognitoScope?.trim() || \"openid email profile\";\n  const params = new URLSearchParams({\n    client_id: clientId,\n    response_type: \"token\",\n    scope,\n    redirect_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/login?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/cognitoAuth.js::buildHostedUiLogoutUrl", "name": "buildHostedUiLogoutUrl", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoAuth.js", "sourceCode": "export function buildHostedUiLogoutUrl(config) {\n  const domain = config?.cognitoDomain?.trim();\n  const clientId = config?.cognitoClientId?.trim();\n  if (!domain || !clientId) return null;\n  const redirectUri =\n    config?.cognitoRedirectUri?.trim() || `${window.location.origin}${window.location.pathname}`;\n  const params = new URLSearchParams({\n    client_id: clientId,\n    logout_uri: redirectUri,\n  });\n  return `${domain.replace(/\\/$/, \"\")}/logout?${params.toString()}`;\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signInWithUserPool", "name": "signInWithUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function signInWithUserPool({ username, password, config }) {\n  const authenticationDetails = new AuthenticationDetails({\n    Username: username,\n    Password: password,\n  });\n\n  const user = new CognitoUser({\n    Username: username,\n    Pool: getUserPool(config),\n  });\n\n  return new Promise((resolve, reject) => {\n    user.authenticateUser(authenticationDetails, {\n      onSuccess: (session) => resolve(session),\n      onFailure: (error) => reject(error),\n    });\n  });\n}", "parameters": [{"name": "{ username, password, config }", "type": "{ username: any; password: any; config: any; }", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "amazon-cognito-identity-js", "specifiers": ["CognitoUserPool", "CognitoUser", "AuthenticationDetails"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::getUserPoolSession", "name": "getUserPoolSession", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export async function getUserPoolSession(config) {\n  const user = getCurrentUser(config);\n  if (!user) return null;\n  return new Promise((resolve) => {\n    user.getSession((error, session) => {\n      if (error || !session) {\n        resolve(null);\n        return;\n      }\n      resolve(session);\n    });\n  });\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "amazon-cognito-identity-js", "specifiers": ["CognitoUserPool", "CognitoUser", "AuthenticationDetails"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::signOutUserPool", "name": "signOutUserPool", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function signOutUserPool(config) {\n  const user = getCurrentUser(config);\n  user?.signOut();\n}", "parameters": [{"name": "config", "type": "any", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "amazon-cognito-identity-js", "specifiers": ["CognitoUserPool", "CognitoUser", "AuthenticationDetails"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/cognitoUserAuth.js::sessionToTokens", "name": "sessionToTokens", "kind": "function", "filePath": "apps/canonry/webui/src/aws/cognitoUserAuth.js", "sourceCode": "export function sessionToTokens(session) {\n  if (!session) return null;\n  const idToken = session.getIdToken().getJwtToken();\n  const accessToken = session.getAccessToken().getJwtToken();\n  const expiresAt = session.getIdToken().getExpiration() * 1000;\n  return {\n    idToken,\n    accessToken,\n    tokenType: \"Bearer\",\n    expiresAt,\n  };\n}", "parameters": [{"name": "session", "type": "any", "optional": false}], "returnType": "{ idToken: any; accessToken: any; tokenType: string; expiresAt: number; }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "amazon-cognito-identity-js", "specifiers": ["CognitoUserPool", "CognitoUser", "AuthenticationDetails"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::exportIndexedDbToS3", "name": "exportIndexedDbToS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function exportIndexedDbToS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/export] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Enumerating databases...\");\n  const dbList = await indexedDB.databases();\n  if (!dbList || dbList.length === 0) {\n    throw new Error(\"No IndexedDB databases found\");\n  }\n\n  const snapshot = {\n    format: \"canonry-indexeddb-snapshot\",\n    version: 1,\n    exportedAt: new Date().toISOString(),\n    databases: {},\n  };\n\n  for (let i = 0; i < dbList.length; i++) {\n    const { name, version } = dbList[i];\n    if (!name) continue;\n    report(`Exporting ${name} v${version} (${i + 1}/${dbList.length})...`);\n\n    const dbSnapshot = await exportSingleDatabase(name, version);\n    if (dbSnapshot) {\n      snapshot.databases[name] = dbSnapshot;\n    }\n  }\n\n  report(\"Uploading to S3...\");\n  const body = JSON.stringify(snapshot);\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n\n  await s3.send(\n    new PutObjectCommand({\n      Bucket: bucket,\n      Key: key,\n      Body: body,\n      ContentType: \"application/json\",\n      CacheControl: \"no-store, must-revalidate\",\n    })\n  );\n\n  const sizeMb = (body.length / (1024 * 1024)).toFixed(1);\n  const dbCount = Object.keys(snapshot.databases).length;\n  const storeCount = Object.values(snapshot.databases).reduce(\n    (sum, db) => sum + Object.keys(db.stores).length,\n    0\n  );\n\n  console.log(`[snapshot/export] Done: ${dbCount} databases, ${storeCount} stores, ${sizeMb} MB`);\n\n  return {\n    size: body.length,\n    sizeMb,\n    dbCount,\n    storeCount,\n    key,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ size: number; sizeMb: string; dbCount: number; storeCount: any; key: string; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["PutObjectCommand", "GetObjectCommand"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/indexedDbSnapshot.js::importIndexedDbFromS3", "name": "importIndexedDbFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/indexedDbSnapshot.js", "sourceCode": "export async function importIndexedDbFromS3(s3, config, onProgress) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[snapshot/import] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  report(\"Downloading snapshot from S3...\");\n  const key = toS3Key(basePrefix, SNAPSHOT_KEY_SUFFIX);\n  const response = await s3.send(new GetObjectCommand({ Bucket: bucket, Key: key }));\n  const text = await readS3BodyAsText(response.Body);\n  if (!text) throw new Error(\"Empty snapshot file\");\n\n  report(`Parsing snapshot (${(text.length / (1024 * 1024)).toFixed(1)} MB)...`);\n  const snapshot = JSON.parse(text);\n  if (snapshot.format !== \"canonry-indexeddb-snapshot\") {\n    throw new Error(`Unknown snapshot format: ${snapshot.format}`);\n  }\n\n  const existingDbs = await getExistingDatabases();\n  const dbNames = Object.keys(snapshot.databases);\n  console.log(\n    `[snapshot/import] Snapshot from ${snapshot.exportedAt}, ${dbNames.length} databases: [${dbNames.join(\", \")}]. Local: [${Array.from(existingDbs.keys()).join(\", \")}]`\n  );\n\n  const warnings = [];\n  let totalStoresRestored = 0;\n  let totalRecordsWritten = 0;\n\n  for (let i = 0; i < dbNames.length; i++) {\n    const name = dbNames[i];\n    const dbSnapshot = snapshot.databases[name];\n    const snapshotStoreNames = Object.keys(dbSnapshot.stores);\n\n    report(\n      `Restoring ${name} v${dbSnapshot.version} (${i + 1}/${dbNames.length}) \u2014 ${snapshotStoreNames.length} stores [${snapshotStoreNames.join(\", \")}]`\n    );\n\n    let db;\n    try {\n      db = await openDatabaseForImport(name, dbSnapshot, existingDbs);\n    } catch (err) {\n      const msg = `Failed to open \"${name}\" for import: ${err.message}`;\n      console.error(`[snapshot/import] ${msg}`);\n      warnings.push(msg);\n      continue;\n    }\n\n    const { storesRestored, recordsWritten } = await restoreStoresFromSnapshot(\n      db, name, dbSnapshot, warnings\n    );\n    totalStoresRestored += storesRestored;\n    totalRecordsWritten += recordsWritten;\n\n    db.close();\n    console.log(`[snapshot/import] \"${name}\" done`);\n  }\n\n  console.log(\n    `[snapshot/import] Import complete: ${totalStoresRestored} stores, ${totalRecordsWritten} records`\n  );\n  if (warnings.length) {\n    console.warn(`[snapshot/import] Warnings (${warnings.length}):`, warnings);\n  }\n\n  return {\n    exportedAt: snapshot.exportedAt,\n    dbCount: dbNames.length,\n    storeCount: totalStoresRestored,\n    recordCount: totalRecordsWritten,\n    warnings,\n  };\n}", "parameters": [{"name": "s3", "type": "any", "optional": false}, {"name": "config", "type": "any", "optional": false}, {"name": "onProgress", "type": "any", "optional": false}], "returnType": "Promise<{ exportedAt: any; dbCount: number; storeCount: number; recordCount: number; warnings: string[]; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["PutObjectCommand", "GetObjectCommand"], "category": "external"}]}, {"id": "apps/canonry/webui/src/aws/s3ImagePull.js::pullImagesFromS3", "name": "pullImagesFromS3", "kind": "function", "filePath": "apps/canonry/webui/src/aws/s3ImagePull.js", "sourceCode": "export async function pullImagesFromS3({ s3, config, projectId, onProgress }) {\n  if (!s3) throw new Error(\"Missing S3 client\");\n  const bucket = config?.imageBucket?.trim();\n  if (!bucket) throw new Error(\"Missing image bucket\");\n  const basePrefix = config?.imagePrefix?.trim() || \"\";\n\n  const report = (detail) => {\n    console.log(`[s3-pull] ${detail}`);\n    onProgress?.({ detail });\n  };\n\n  // 1. Load manifest (read-only \u2014 never written back)\n  report(\"Loading image manifest from S3...\");\n  const manifest = await loadImageManifest(s3, { bucket, basePrefix });\n  if (!manifest || !manifest.images) {\n    throw new Error('No image manifest found in S3. Push images first with \"Sync Images to S3\".');\n  }\n\n  const allEntries = Object.values(manifest.images);\n  // Filter to requested project if provided\n  const entries = projectId ? allEntries.filter((e) => e.projectId === projectId) : allEntries;\n\n  const projectScope = projectId ? ` for project ${projectId}` : \" (all projects)\";\n  report(\n    `Manifest has ${entries.length} images${projectScope}. Checking local state...`\n  );\n\n  // 2. Check what exists locally\n  const db = await openIlluminatorDb();\n  let localBlobIds;\n  let localImageIds;\n  try {\n    localBlobIds = await getLocalBlobIds(db);\n    localImageIds = await getLocalImageIds(db);\n  } catch (err) {\n    db.close();\n    throw err;\n  }\n\n  // 3. Compute what needs downloading\n  const missing = entries.filter((e) => !localBlobIds.has(e.imageId));\n  const total = entries.length;\n  const skippedCount = total - missing.length;\n\n  report(`${missing.length} to download, ${skippedCount} already local`);\n\n  if (missing.length === 0) {\n    db.close();\n    return { total, downloaded: 0, skipped: skippedCount, errors: 0 };\n  }\n\n  // 4. Download incrementally\n  let downloaded = 0;\n  let errors = 0;\n  const logInterval = Math.max(1, Math.floor(missing.length / 5));\n\n  for (let i = 0; i < missing.length; i++) {\n    const entry = missing[i];\n\n    if (i % logInterval === 0) {\n      report(`Downloading ${i + 1}/${missing.length}...`);\n    }\n\n    try {\n      const response = await s3.send(\n        new GetObjectCommand({\n          Bucket: bucket,\n          Key: entry.rawKey,\n        })\n      );\n\n      const blob = await readBodyAsBlob(response.Body, entry.mimeType);\n\n      // Write blob, and metadata if missing locally\n      const needsMetadata = !localImageIds.has(entry.imageId);\n      const metadata = needsMetadata ? manifestEntryToMetadata(entry) : null;\n\n      await writeImageToDb(db, entry.imageId, blob, metadata);\n      downloaded++;\n    } catch (err) {\n      errors++;\n      console.error(\n        `[s3-pull] Failed to download \"${entry.imageId}\" (key=${entry.rawKey}):`,\n        err.message\n      );\n    }\n  }\n\n  db.close();\n\n  const summary = `Done: ${downloaded} downloaded, ${skippedCount} already local, ${errors} errors`;\n  report(summary);\n\n  return { total, downloaded, skipped: skippedCount, errors };\n}", "parameters": [{"name": "{ s3, config, projectId, onProgress }", "type": "{ s3: any; config: any; projectId: any; onProgress: any; }", "optional": false}], "returnType": "Promise<{ total: number; downloaded: number; skipped: number; errors: number; }>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@aws-sdk/client-s3", "specifiers": ["GetObjectCommand"], "category": "external"}, {"source": "./awsS3", "specifiers": ["loadImageManifest"], "category": "internal"}, {"source": "../lib/illuminatorDbReader", "specifiers": ["openIlluminatorDb"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/HelpModal.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/HelpModal.jsx", "sourceCode": "export default function HelpModal({ isOpen, onClose, activeTab }) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const content = HELP_CONTENT[activeTab] || HELP_CONTENT.enumerist;\n\n  return (\n    <div\n      className=\"modal-overlay\"\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <div className=\"modal help-modal\">\n        <div className=\"modal-header\">\n          <div className=\"modal-title hm-title-colored\" style={{ '--hm-title-color': content.color }}>\n            {content.title}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\n            \u00d7\n          </button>\n        </div>\n        <div className=\"modal-body modal-body-single\">\n          {/* Description */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">What is this?</h3>\n            <p className=\"help-text\">{content.description}</p>\n          </div>\n\n          {/* Workflow */}\n          <div className=\"help-section\">\n            <h3 className=\"help-section-title\">Workflow</h3>\n            {content.workflow.map((step, index) => (\n              <div key={index} className=\"workflow-step\">\n                <div className=\"workflow-step-header\">\n                  <div className=\"workflow-step-number hm-step-number-colored\" style={{ '--hm-step-bg': content.color }}>\n                    {index + 1}\n                  </div>\n                  <div className=\"workflow-step-title\">{step.title}</div>\n                </div>\n                <p className=\"workflow-step-desc\">{step.desc}</p>\n                <ul className=\"workflow-step-list\">\n                  {step.items.map((item, i) => (\n                    <li key={i}>{item}</li>\n                  ))}\n                </ul>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ isOpen, onClose, activeTab }", "type": "{ isOpen: any; onClose: any; activeTab: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useRef"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./HelpModal.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/LandingPage.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/LandingPage.jsx", "sourceCode": "export default function LandingPage({ onNavigate, hasProject }) {\n  return (\n    <div className=\"lp-container\">\n      {/* Hero Section */}\n      <div className=\"lp-hero\">\n        <h1 className=\"lp-title\">Welcome to The Canonry</h1>\n        <p className=\"lp-subtitle\">\n          A unified suite for procedural world-building. Define your schema, configure naming\n          systems, place entities on semantic planes, and generate interconnected histories.\n        </p>\n        <p className=\"lp-tagline\">Yes, this is probably overkill. No, we&apos;re not sorry.</p>\n      </div>\n\n      {/* App Cards */}\n      <div className=\"lp-cards-grid\">\n        {APP_CARDS.map((app) => (\n          <AppCard key={app.id} app={app} onNavigate={onNavigate} hasProject={hasProject} />\n        ))}\n      </div>\n\n      {/* Footer */}\n      <div className=\"lp-footer\">\n        <h2 className=\"lp-footer-title\">Get Started</h2>\n        <p className=\"lp-footer-text\">\n          {hasProject\n            ? \"Click on any card above to start working with your project.\"\n            : \"Create a new project or open an existing one using the project selector above.\"}\n        </p>\n        <p className=\"lp-footer-hint\">\n          Projects are stored locally in your browser. Use Export to create backups.\n        </p>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onNavigate, hasProject }", "type": "{ onNavigate: any; hasProject: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../theme", "specifiers": ["colors"], "category": "internal"}, {"source": "./LandingPage.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/Navigation.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/Navigation.jsx", "sourceCode": "export default function Navigation({ activeTab, onTabChange, onHelpClick, onAwsClick }) {\n  const getTabClassName = (tab) => {\n    if (!tab.enabled) {\n      return \"nav-tab nav-tab-disabled\";\n    }\n    if (tab.id === activeTab) {\n      return \"nav-tab nav-tab-active\";\n    }\n    return \"nav-tab nav-tab-inactive\";\n  };\n\n  const getTabDynamicStyle = (tab) => {\n    if (tab.id === activeTab && tab.enabled) {\n      return {\n        '--nav-tab-bg': getAccentGradient(tab.id),\n        '--nav-tab-color': colors.bgSidebar,\n      };\n    }\n    return undefined;\n  };\n\n  return (\n    <nav className=\"nav-bar\">\n      <div className=\"nav-tabs-container\">\n        {TABS.map((tab) => (\n          <button\n            key={tab.id}\n            onClick={() => tab.enabled && onTabChange(tab.id)}\n            className={getTabClassName(tab)}\n            style={getTabDynamicStyle(tab)}\n            disabled={!tab.enabled}\n            onMouseEnter={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = getHoverBg(tab.id);\n                e.target.style.color = getAccentColor(tab.id);\n              }\n            }}\n            onMouseLeave={(e) => {\n              if (tab.enabled && tab.id !== activeTab) {\n                e.target.style.backgroundColor = \"transparent\";\n                e.target.style.color = colors.textSecondary;\n              }\n            }}\n          >\n            {tab.label}\n            {tab.badge && <span className=\"nav-badge\">{tab.badge}</span>}\n          </button>\n        ))}\n      </div>\n      <button\n        className=\"nav-help-button\"\n        onClick={onAwsClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"AWS & S3 Sync\"\n      >\n        AWS\n      </button>\n      <button\n        className=\"nav-help-button\"\n        onClick={onHelpClick}\n        onMouseEnter={(e) => {\n          e.target.style.backgroundColor = colors.bgTertiary;\n          e.target.style.color = colors.textPrimary;\n          e.target.style.borderColor = colors.borderLight;\n        }}\n        onMouseLeave={(e) => {\n          e.target.style.backgroundColor = \"transparent\";\n          e.target.style.color = colors.textSecondary;\n          e.target.style.borderColor = colors.border;\n        }}\n        title=\"Help & Workflow Guide\"\n      >\n        ? Help\n      </button>\n    </nav>\n  );\n}", "parameters": [{"name": "{ activeTab, onTabChange, onHelpClick, onAwsClick }", "type": "{ activeTab: any; onTabChange: any; onHelpClick: any; onAwsClick: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "../theme", "specifiers": ["colors", "getAccentColor", "getAccentGradient", "getHoverBg"], "category": "internal"}, {"source": "./Navigation.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/ProjectManager.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ProjectManager.jsx", "sourceCode": "export default function ProjectManager({\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [showNewModal, setShowNewModal] = useState(false);\n  const [newProjectName, setNewProjectName] = useState(\"\");\n  const dropdownRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = useCallback((e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  }, []);\n\n  const handleOverlayClick = useCallback((e) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      setShowNewModal(false);\n    }\n  }, []);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  const handleCreate = () => {\n    if (newProjectName.trim()) {\n      onCreateProject(newProjectName.trim());\n      setNewProjectName(\"\");\n      setShowNewModal(false);\n      setShowDropdown(false);\n    }\n  };\n\n  const handleImport = async (e) => {\n    const file = e.target.files?.[0];\n    if (!file) return;\n\n    try {\n      // Require zip file imports\n      if (!file.name.endsWith(\".zip\") && file.type !== \"application/zip\") {\n        throw new Error(\"Unsupported file type. Import requires a .zip project export.\");\n      }\n      await onImportProject(file);\n      setShowDropdown(false);\n    } catch (err) {\n      alert(\"Failed to import: \" + err.message);\n    }\n    e.target.value = \"\";\n  };\n\n  const handleExport = async () => {\n    try {\n      const zipBlob = await onExportProject();\n      if (!zipBlob) return;\n\n      const url = URL.createObjectURL(zipBlob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `${currentProject?.name || \"world\"}.canonry.zip`;\n      a.click();\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      alert(\"Failed to export: \" + err.message);\n    }\n  };\n\n  const formatDate = (dateString) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <header className=\"app-header\">\n      <div className=\"app-header-left\">\n        <div className=\"app-logo\" onClick={onGoHome} title=\"Go to home\" role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onGoHome(e); }} >\n          The Canonry\n        </div>\n\n        <div className=\"project-selector\" ref={dropdownRef}>\n          <button\n            className=\"project-selector-trigger\"\n            onClick={() => setShowDropdown(!showDropdown)}\n          >\n            <span className=\"project-selector-name\">\n              {currentProject?.name || \"Select Project\"}\n            </span>\n            <span className=\"project-selector-chevron\">{showDropdown ? \"\u25b2\" : \"\u25bc\"}</span>\n          </button>\n\n          {showDropdown && (\n            <div className=\"project-dropdown\">\n              <div className=\"project-dropdown-header\">\n                <span className=\"project-dropdown-title\">Projects</span>\n                <div className=\"project-dropdown-actions\">\n                  <button\n                    className=\"btn-sm btn-sm-primary\"\n                    onClick={() => {\n                      setShowDropdown(false);\n                      setShowNewModal(true);\n                    }}\n                  >\n                    + New\n                  </button>\n                  <button className=\"btn-sm\" onClick={() => fileInputRef.current?.click()}>\n                    Import\n                  </button>\n                </div>\n              </div>\n\n              <div className=\"project-list\">\n                {projects.length === 0 ? (\n                  <div className=\"empty-state-compact\">\n                    No projects yet. Create one to get started!\n                  </div>\n                ) : (\n                  projects.map((project) => (\n                    <div\n                      key={project.id}\n                      className={[\"project-item\", currentProject?.id === project.id ? \"project-item-active\" : \"\"].join(\" \").trim()}\n                      onClick={() => {\n                        onOpenProject(project.id);\n                        setShowDropdown(false);\n                      }}\n                      onMouseEnter={() => setHoveredProject(project.id)}\n                      onMouseLeave={() => setHoveredProject(null)}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      <div className=\"project-item-name\">{project.name}</div>\n                      <div className=\"project-item-meta\">\n                        <span>{project.entityCount} entities</span>\n                        <span>{project.cultureCount} cultures</span>\n                        <span>{formatDate(project.updatedAt)}</span>\n                      </div>\n                      <div className=\"project-item-actions\" onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n                        {project.id === defaultProjectId && onReloadFromDefaults && (\n                          <button\n                            className=\"btn-xs\"\n                            onClick={async () => {\n                              if (\n                                confirm(\n                                  \"Reload project from defaults? This will overwrite your configuration changes but preserve world data.\"\n                                )\n                              ) {\n                                try {\n                                  await onReloadFromDefaults();\n                                  setShowDropdown(false);\n                                } catch (err) {\n                                  alert(\"Failed to reload: \" + err.message);\n                                }\n                              }\n                            }}\n                          >\n                            Reload Defaults\n                          </button>\n                        )}\n                        <button className=\"btn-xs\" onClick={() => onDuplicateProject(project.id)}>\n                          Duplicate\n                        </button>\n                        <button\n                          className=\"btn-xs btn-xs-danger\"\n                          onClick={() => {\n                            if (confirm(`Delete \"${project.name}\"?`)) {\n                              onDeleteProject(project.id);\n                            }\n                          }}\n                        >\n                          Delete\n                        </button>\n                      </div>\n                    </div>\n                  ))\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        {currentProject && onLoadSlot && (\n          <SlotSelector\n            slots={slots}\n            activeSlotIndex={activeSlotIndex}\n            onLoadSlot={onLoadSlot}\n            onSaveToSlot={onSaveToSlot}\n            onClearSlot={onClearSlot}\n            onUpdateTitle={onUpdateSlotTitle}\n            onExportSlot={onExportSlot}\n            onImportSlot={onImportSlot}\n            onLoadExampleOutput={onLoadExampleOutput}\n            hasDataInScratch={hasDataInScratch}\n          />\n        )}\n      </div>\n\n      <div className=\"app-header-right\">\n        {currentProject && <TracePopover simulationState={simulationState} systems={systems} />}\n        {currentProject && (\n          <ValidationPopover\n            validationResult={validationResult}\n            onNavigateToValidation={onNavigateToValidation}\n            onRemoveProperty={onRemoveProperty}\n          />\n        )}\n        <button className=\"btn btn-secondary\" onClick={handleExport} disabled={!currentProject}>\n          Export\n        </button>\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\".zip\"\n          className=\"pm-hidden-input\"\n          onChange={handleImport}\n        />\n      </div>\n\n      {showNewModal && (\n        <div\n          className=\"modal-overlay\"\n          onMouseDown={handleOverlayMouseDown}\n          onClick={handleOverlayClick}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n        >\n          <div className=\"modal modal-simple\">\n            <div className=\"modal-header\">\n              <div className=\"modal-title\">Create New Project</div>\n              <button className=\"btn-close\" onClick={() => setShowNewModal(false)}>\n                \u00d7\n              </button>\n            </div>\n            <div className=\"modal-body\">\n              {/* eslint-disable-next-line jsx-a11y/no-autofocus -- intentional UX: modal input should auto-focus */}\n              <input\n                className=\"input\"\n                type=\"text\"\n                placeholder=\"Project name...\"\n                value={newProjectName}\n                onChange={(e) => setNewProjectName(e.target.value)}\n                onKeyDown={(e) => e.key === \"Enter\" && handleCreate()}\n                autoFocus\n              />\n              <div className=\"modal-actions\">\n                <button className=\"btn btn-secondary\" onClick={() => setShowNewModal(false)}>\n                  Cancel\n                </button>\n                <button className=\"btn btn-primary\" onClick={handleCreate}>\n                  Create\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </header>\n  );\n}", "parameters": [{"name": "{\n  projects,\n  currentProject,\n  onCreateProject,\n  onOpenProject,\n  onDeleteProject,\n  onDuplicateProject,\n  onExportProject,\n  onImportProject,\n  onReloadFromDefaults,\n  defaultProjectId,\n  onGoHome,\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n  simulationState,\n  systems = EMPTY_SYSTEMS,\n  // Slot management props\n  slots = EMPTY_SLOTS,\n  activeSlotIndex = 0,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateSlotTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch = false,\n}", "type": "{ projects: any; currentProject: any; onCreateProject: any; onOpenProject: any; onDeleteProject: any; onDuplicateProject: any; onExportProject: any; onImportProject: any; onReloadFromDefaults: any; defaultProjectId: any; onGoHome: any; validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; simulationState: any; systems?: any[]; slots?: Readonly<{}>; activeSlotIndex?: number; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateSlotTitle: any; onExportSlot: any; on...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect", "useCallback"], "category": "framework"}, {"source": "./ValidationPopover", "specifiers": ["ValidationPopover"], "category": "internal"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./TracePopover", "specifiers": ["TracePopover"], "category": "internal"}, {"source": "./SlotSelector", "specifiers": ["SlotSelector"], "category": "internal"}, {"source": "./ProjectManager.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/SlotSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SlotSelector.jsx", "sourceCode": "export default function SlotSelector({\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}) {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const [editingSlot, setEditingSlot] = useState(null);\n  const [editValue, setEditValue] = useState(\"\");\n  const [importTargetSlot, setImportTargetSlot] = useState(null);\n  const dropdownRef = useRef(null);\n  const inputRef = useRef(null);\n  const fileInputRef = useRef(null);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {\n        setShowDropdown(false);\n        setEditingSlot(null);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  // Focus input when editing starts\n  useEffect(() => {\n    if (editingSlot !== null && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [editingSlot]);\n\n  const handleStartEdit = useCallback((slotIndex, currentTitle, e) => {\n    e.stopPropagation();\n    setEditingSlot(slotIndex);\n    setEditValue(currentTitle || \"\");\n  }, []);\n\n  const handleSaveEdit = useCallback(() => {\n    if (editingSlot !== null && editValue.trim()) {\n      onUpdateTitle(editingSlot, editValue.trim());\n    }\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, [editingSlot, editValue, onUpdateTitle]);\n\n  const handleCancelEdit = useCallback(() => {\n    setEditingSlot(null);\n    setEditValue(\"\");\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e) => {\n      if (e.key === \"Enter\") {\n        handleSaveEdit();\n      } else if (e.key === \"Escape\") {\n        handleCancelEdit();\n      }\n    },\n    [handleSaveEdit, handleCancelEdit]\n  );\n\n  const handleImportRequest = useCallback(\n    (slotIndex) => {\n      if (!onImportSlot) return;\n      const slot = slots[slotIndex];\n      const slotTitle = slot?.title || (slotIndex === 0 ? \"Scratch\" : `Slot ${slotIndex}`);\n      if (slot && !window.confirm(`Overwrite \"${slotTitle}\" with imported data?`)) {\n        return;\n      }\n      setImportTargetSlot(slotIndex);\n      fileInputRef.current?.click();\n    },\n    [onImportSlot, slots]\n  );\n\n  const handleImportFile = useCallback(\n    (e) => {\n      const file = e.target.files?.[0];\n      if (!file || importTargetSlot === null || !onImportSlot) {\n        e.target.value = \"\";\n        return;\n      }\n      onImportSlot(importTargetSlot, file);\n      setImportTargetSlot(null);\n      setShowDropdown(false);\n      e.target.value = \"\";\n    },\n    [importTargetSlot, onImportSlot]\n  );\n\n  // Get active slot data for display\n  const activeSlot = slots[activeSlotIndex];\n  const activeTitle =\n    activeSlotIndex === 0\n      ? activeSlot?.title || \"Scratch\"\n      : activeSlot?.title || `Slot ${activeSlotIndex}`;\n\n  // Determine which slots to show:\n  // - Always show slot 0 (scratch)\n  // - Show filled save slots\n  // - Show next empty slot if scratch has data\n  const visibleSlots = [0]; // Always show scratch\n  let nextEmptySlot = null;\n\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (slots[i]) {\n      visibleSlots.push(i);\n    } else if (nextEmptySlot === null) {\n      nextEmptySlot = i;\n    }\n  }\n\n  // Add next empty slot if scratch has data\n  if (hasDataInScratch && nextEmptySlot !== null) {\n    visibleSlots.push(nextEmptySlot);\n  }\n\n  return (\n    <div className=\"slot-selector\" ref={dropdownRef}>\n      <button className=\"slot-selector-trigger\" onClick={() => setShowDropdown(!showDropdown)}>\n        <span className=\"slot-selector-name\">{activeTitle}</span>\n        <span className=\"slot-selector-chevron\">{showDropdown ? \"\\u25B2\" : \"\\u25BC\"}</span>\n      </button>\n\n      {showDropdown && (\n        <div className=\"slot-dropdown\">\n          <div className=\"slot-dropdown-header\">\n            <span className=\"slot-dropdown-title\">Run Slots</span>\n          </div>\n\n          <div className=\"slot-list\">\n            {visibleSlots.map((slotIndex) => (\n              <SlotItem\n                key={slotIndex}\n                slotIndex={slotIndex}\n                slot={slots[slotIndex]}\n                isActive={slotIndex === activeSlotIndex}\n                editingSlot={editingSlot}\n                editValue={editValue}\n                setEditValue={setEditValue}\n                inputRef={inputRef}\n                handleKeyDown={handleKeyDown}\n                handleSaveEdit={handleSaveEdit}\n                handleStartEdit={handleStartEdit}\n                canExport={Boolean(onExportSlot && slots[slotIndex])}\n                canImport={Boolean(onImportSlot)}\n                hasDataInScratch={hasDataInScratch}\n                activeSlotIndex={activeSlotIndex}\n                onLoadSlot={onLoadSlot}\n                onSaveToSlot={onSaveToSlot}\n                onClearSlot={onClearSlot}\n                onExportSlot={onExportSlot}\n                handleImportRequest={handleImportRequest}\n                setShowDropdown={setShowDropdown}\n              />\n            ))}\n\n            {visibleSlots.length === 1 && !hasDataInScratch && (\n              <div className=\"slot-empty-hint\">\n                Run a simulation to create data, then save to a slot.\n              </div>\n            )}\n\n            {onLoadExampleOutput && (\n              <div className=\"slot-item slot-item-empty\">\n                <div className=\"slot-item-content\">\n                  <div className=\"slot-item-name\">Example Output</div>\n                  <div className=\"slot-item-meta\">Load a sample Lore Weave run.</div>\n                </div>\n                <div className=\"slot-item-actions\">\n                  <button\n                    className=\"btn-xs\"\n                    onClick={() => {\n                      if (\n                        hasDataInScratch &&\n                        !window.confirm(\"Overwrite scratch with the example output?\")\n                      ) {\n                        return;\n                      }\n                      onLoadExampleOutput();\n                      setShowDropdown(false);\n                    }}\n                  >\n                    Load\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\".json,.zip,application/json,application/zip\"\n        className=\"ss-hidden-input\"\n        onChange={handleImportFile}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  slots,\n  activeSlotIndex,\n  onLoadSlot,\n  onSaveToSlot,\n  onClearSlot,\n  onUpdateTitle,\n  onExportSlot,\n  onImportSlot,\n  onLoadExampleOutput,\n  hasDataInScratch,\n}", "type": "{ slots: any; activeSlotIndex: any; onLoadSlot: any; onSaveToSlot: any; onClearSlot: any; onUpdateTitle: any; onExportSlot: any; onImportSlot: any; onLoadExampleOutput: any; hasDataInScratch: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useEffect", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./SlotSelector.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/TracePopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/TracePopover.jsx", "sourceCode": "export default function TracePopover({ simulationState }) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // Extract data from simulation state\n  const hasData = simulationState?.pressureUpdates?.length > 0;\n  const tickCount = simulationState?.pressureUpdates?.length || 0;\n  const templateCount = simulationState?.templateApplications?.length || 0;\n  const actionCount = simulationState?.actionApplications?.length || 0;\n  const eraTransitions = (simulationState?.systemActions || []).filter(\n    (a) => a.details?.eraTransition\n  ).length;\n\n  // Button label\n  const buttonLabel = useMemo(() => {\n    if (!hasData) return \"No trace\";\n    return `${tickCount} ticks`;\n  }, [hasData, tickCount]);\n\n  // Button class\n  const buttonClassName = useMemo(() => {\n    if (!hasData) {\n      return \"tp-button tp-button-disabled\";\n    }\n    return \"tp-button tp-button-active\";\n  }, [hasData]);\n\n  const loadingFallback = useMemo(\n    () => <div className=\"tp-loading-overlay\">Loading trace visualization...</div>,\n    []\n  );\n\n  const handleOpen = () => {\n    if (hasData) {\n      setIsOpen(true);\n    }\n  };\n  const handleClose = useCallback(() => setIsOpen(false), []);\n\n  return (\n    <>\n      <button\n        className={buttonClassName}\n        onClick={handleOpen}\n        disabled={!hasData}\n        title={\n          hasData\n            ? `View simulation trace: ${tickCount} ticks, ${templateCount} templates, ${actionCount} actions, ${eraTransitions} era transitions`\n            : \"Run a simulation to see trace data\"\n        }\n      >\n        <span className=\"tp-tilde\">~</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && hasData && (\n        <Suspense fallback={loadingFallback}>\n          <SimulationTraceVisx\n            pressureUpdates={simulationState.pressureUpdates}\n            epochStats={simulationState.epochStats}\n            templateApplications={simulationState.templateApplications}\n            actionApplications={simulationState.actionApplications}\n            systemActions={simulationState.systemActions}\n            onClose={handleClose}\n          />\n        </Suspense>\n      )}\n    </>\n  );\n}", "parameters": [{"name": "{ simulationState }", "type": "{ simulationState: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "lazy", "Suspense"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./TracePopover.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/components/ValidationPopover.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/ValidationPopover.jsx", "sourceCode": "export default function ValidationPopover({\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const popoverRef = useRef(null);\n\n  const { valid, errors, warnings } = validationResult || { valid: true, errors: [], warnings: [] };\n  const totalIssues = errors.length + warnings.length;\n\n  // Determine button class\n  const buttonClassName = useMemo(() => {\n    if (errors.length > 0) return \"vp-button vp-button-error\";\n    if (warnings.length > 0) return \"vp-button vp-button-warning\";\n    return \"vp-button vp-button-valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get button label\n  const buttonLabel = useMemo(() => {\n    if (errors.length > 0) return `${errors.length} error${errors.length !== 1 ? \"s\" : \"\"}`;\n    if (warnings.length > 0) return `${warnings.length} warning${warnings.length !== 1 ? \"s\" : \"\"}`;\n    return \"Valid\";\n  }, [errors.length, warnings.length]);\n\n  // Get icon\n  const icon = useMemo(() => {\n    if (errors.length > 0) return \"\u2717\";\n    if (warnings.length > 0) return \"\u26a0\";\n    return \"\u2713\";\n  }, [errors.length, warnings.length]);\n\n  // Combined and limited list\n  const displayItems = useMemo(() => {\n    const items = [\n      ...errors.map((e) => ({ ...e, isWarning: false })),\n      ...warnings.map((w) => ({ ...w, isWarning: true })),\n    ];\n    return items.slice(0, MAX_ERRORS_SHOWN);\n  }, [errors, warnings]);\n\n  const remainingCount = totalIssues - displayItems.length;\n\n  const handleNavigate = () => {\n    setIsOpen(false);\n    onNavigateToValidation?.();\n  };\n\n  return (\n    <div className=\"vp-container\">\n      <button\n        className={buttonClassName}\n        onClick={() => setIsOpen(!isOpen)}\n        title={valid ? \"Configuration is valid\" : \"Click to see validation issues\"}\n      >\n        <span>{icon}</span>\n        <span>{buttonLabel}</span>\n      </button>\n\n      {isOpen && (\n        <div className=\"vp-popover\" ref={popoverRef}>\n          <div className=\"vp-popover-header\">\n            <span className=\"vp-popover-title\">Structure Validation</span>\n            <button className=\"vp-close-button\" onClick={() => setIsOpen(false)}>\n              \u00d7\n            </button>\n          </div>\n\n          <div className=\"vp-popover-body\">\n            {valid && warnings.length === 0 ? (\n              <div className=\"vp-valid-message\">\n                <span>\u2713</span>\n                <span>All configuration files are valid</span>\n              </div>\n            ) : (\n              <div className=\"vp-error-list\">\n                {displayItems.map((item, i) => (\n                  <ErrorCard\n                    key={i}\n                    error={item}\n                    isWarning={item.isWarning}\n                    onRemoveProperty={onRemoveProperty}\n                  />\n                ))}\n              </div>\n            )}\n          </div>\n\n          {remainingCount > 0 && (\n            <div className=\"vp-more-count\">\n              +{remainingCount} more issue{remainingCount !== 1 ? \"s\" : \"\"}.{\" \"}\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View all in Validation tab\n              </span>\n            </div>\n          )}\n\n          {totalIssues > 0 && remainingCount === 0 && onNavigateToValidation && (\n            <div className=\"vp-more-count\">\n              <span className=\"vp-nav-link\" onClick={handleNavigate} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleNavigate(); }} >\n                View full details in Validation tab\n              </span>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  validationResult,\n  onNavigateToValidation,\n  onRemoveProperty,\n}", "type": "{ validationResult: any; onNavigateToValidation: any; onRemoveProperty: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useRef", "useMemo"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ValidationPopover.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/canonry/webui/src/lib/illuminatorDbReader.js::openIlluminatorDb", "name": "openIlluminatorDb", "kind": "function", "filePath": "apps/canonry/webui/src/lib/illuminatorDbReader.js", "sourceCode": "export function openIlluminatorDb() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME);\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // If another connection triggers a version upgrade while we're\n      // still open, close immediately so we don't block it.\n      db.onversionchange = () => {\n        db.close();\n      };\n\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(request.error || new Error('Failed to open illuminator DB'));\n    };\n  });\n}", "parameters": [], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImagesByProject", "name": "getImagesByProject", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get all image metadata records for a project (no blobs).\n */\nexport async function getImagesByProject(projectId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const store = tx.objectStore('images');\n      const index = store.index('projectId');\n      const request = index.getAll(projectId);\n      request.onsuccess = () => resolve(request.result || []);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageMetadata", "name": "getImageMetadata", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get a single image metadata record by imageId (no blob).\n */\nexport async function getImageMetadata(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('images', 'readonly');\n      const request = tx.objectStore('images').get(imageId);\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/lib/imageExportHelpers.js::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/canonry/webui/src/lib/imageExportHelpers.js", "sourceCode": "/**\n * Get the raw blob for an image by imageId.\n */\nexport async function getImageBlob(imageId) {\n  const db = await openDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction('imageBlobs', 'readonly');\n      const request = tx.objectStore('imageBlobs').get(imageId);\n      request.onsuccess = () => resolve(request.result?.blob || null);\n      request.onerror = () => reject(request.error);\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "imageId", "type": "any", "optional": false}], "returnType": "Promise<any>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/canonry/webui/src/remotes/ArchivistHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ArchivistHost.jsx", "sourceCode": "export default function ArchivistHost({\n  projectId,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Archivist encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ArchivistRemote projectId={projectId} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex\n}", "type": "{ projectId: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/ChroniclerHost.jsx", "sourceCode": "export default function ChroniclerHost({\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Chronicler encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <ChroniclerRemote projectId={projectId} activeSlotIndex={activeSlotIndex} requestedPageId={requestedPageId} onRequestedPageConsumed={onRequestedPageConsumed} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  requestedPageId,\n  onRequestedPageConsumed\n}", "type": "{ projectId: any; activeSlotIndex: any; requestedPageId: any; onRequestedPageConsumed: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CoherenceEngineHost.jsx", "sourceCode": "export default function CoherenceEngineHost({\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Coherence Engine encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CoherenceEngineRemote projectId={projectId} schema={schema} eras={eras} onErasChange={onErasChange} pressures={pressures} onPressuresChange={onPressuresChange} generators={generators} onGeneratorsChange={onGeneratorsChange} actions={actions} onActionsChange={onActionsChange} systems={systems} onSystemsChange={onSystemsChange} activeSection={activeSection} onSectionChange={onSectionChange} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  onErasChange,\n  pressures,\n  onPressuresChange,\n  generators,\n  onGeneratorsChange,\n  actions,\n  onActionsChange,\n  systems,\n  onSystemsChange,\n  activeSection,\n  onSectionChange\n}", "type": "{ projectId: any; schema: any; eras: any; onErasChange: any; pressures: any; onPressuresChange: any; generators: any; onGeneratorsChange: any; actions: any; onActionsChange: any; systems: any; onSystemsChange: any; activeSection: any; onSectionChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/CosmographerHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/CosmographerHost.jsx", "sourceCode": "export default function CosmographerHost({\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Cosmographer encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <CosmographerRemote schema={schema} axisDefinitions={axisDefinitions} seedEntities={seedEntities} seedRelationships={seedRelationships} onEntityKindsChange={onEntityKindsChange} onCulturesChange={onCulturesChange} onAxisDefinitionsChange={onAxisDefinitionsChange} onTagRegistryChange={onTagRegistryChange} onSeedEntitiesChange={onSeedEntitiesChange} onSeedRelationshipsChange={onSeedRelationshipsChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} schemaUsage={schemaUsage} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  schema,\n  axisDefinitions,\n  seedEntities,\n  seedRelationships,\n  onEntityKindsChange,\n  onCulturesChange,\n  onAxisDefinitionsChange,\n  onTagRegistryChange,\n  onSeedEntitiesChange,\n  onSeedRelationshipsChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  schemaUsage\n}", "type": "{ schema: any; axisDefinitions: any; seedEntities: any; seedRelationships: any; onEntityKindsChange: any; onCulturesChange: any; onAxisDefinitionsChange: any; onTagRegistryChange: any; onSeedEntitiesChange: any; onSeedRelationshipsChange: any; onAddTag: any; activeSection: any; onSectionChange: any; schemaUsage: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/IlluminatorHost.jsx", "sourceCode": "export default function IlluminatorHost({\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Illuminator encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <IlluminatorRemote projectId={projectId} schema={schema} worldData={worldData} worldContext={worldContext} onWorldContextChange={onWorldContextChange} entityGuidance={entityGuidance} onEntityGuidanceChange={onEntityGuidanceChange} cultureIdentities={cultureIdentities} onCultureIdentitiesChange={onCultureIdentitiesChange} enrichmentConfig={enrichmentConfig} onEnrichmentConfigChange={onEnrichmentConfigChange} styleSelection={styleSelection} onStyleSelectionChange={onStyleSelectionChange} historianConfig={historianConfig} onHistorianConfigChange={onHistorianConfigChange} activeSection={activeSection} onSectionChange={onSectionChange} activeSlotIndex={activeSlotIndex} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  worldData,\n  worldContext,\n  onWorldContextChange,\n  entityGuidance,\n  onEntityGuidanceChange,\n  cultureIdentities,\n  onCultureIdentitiesChange,\n  enrichmentConfig,\n  onEnrichmentConfigChange,\n  styleSelection,\n  onStyleSelectionChange,\n  historianConfig,\n  onHistorianConfigChange,\n  activeSection,\n  onSectionChange,\n  activeSlotIndex\n}", "type": "{ projectId: any; schema: any; worldData: any; worldContext: any; onWorldContextChange: any; entityGuidance: any; onEntityGuidanceChange: any; cultureIdentities: any; onCultureIdentitiesChange: any; enrichmentConfig: any; onEnrichmentConfigChange: any; styleSelection: any; onStyleSelectionChange: any; historianConfig: any; onHistorianConfigChange: any; activeSection: any; onSectionChange: any; activeSlotIndex: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/LoreWeaveHost.jsx", "sourceCode": "export default function LoreWeaveHost({\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Lore Weave encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <LoreWeaveRemote projectId={projectId} schema={schema} eras={eras} pressures={pressures} generators={generators} systems={systems} actions={actions} seedEntities={seedEntities} seedRelationships={seedRelationships} distributionTargets={distributionTargets} onDistributionTargetsChange={onDistributionTargetsChange} activeSection={activeSection} onSectionChange={onSectionChange} simulationResults={simulationResults} onSimulationResultsChange={onSimulationResultsChange} simulationState={simulationState} onSimulationStateChange={onSimulationStateChange} onSearchRunScored={onSearchRunScored} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  eras,\n  pressures,\n  generators,\n  systems,\n  actions,\n  seedEntities,\n  seedRelationships,\n  distributionTargets,\n  onDistributionTargetsChange,\n  activeSection,\n  onSectionChange,\n  simulationResults,\n  onSimulationResultsChange,\n  simulationState,\n  onSimulationStateChange,\n  onSearchRunScored\n}", "type": "{ projectId: any; schema: any; eras: any; pressures: any; generators: any; systems: any; actions: any; seedEntities: any; seedRelationships: any; distributionTargets: any; onDistributionTargetsChange: any; activeSection: any; onSectionChange: any; simulationResults: any; onSimulationResultsChange: any; simulationState: any; onSimulationStateChange: any; onSearchRunScored: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}, {"id": "apps/canonry/webui/src/remotes/NameForgeHost.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/remotes/NameForgeHost.jsx", "sourceCode": "export default function NameForgeHost({\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}) {\n  return <div className=\"inline-extracted-1\">\n      <ErrorBoundary title=\"Name Forge encountered an error\">\n      <Suspense fallback={loadingFallback}>\n        <NameForgeRemote projectId={projectId} schema={schema} onNamingDataChange={onNamingDataChange} onAddTag={onAddTag} activeSection={activeSection} onSectionChange={onSectionChange} generators={generators} />\n      </Suspense>\n      </ErrorBoundary>\n    </div>;\n}", "parameters": [{"name": "{\n  projectId,\n  schema,\n  onNamingDataChange,\n  onAddTag,\n  activeSection,\n  onSectionChange,\n  generators\n}", "type": "{ projectId: any; schema: any; onNamingDataChange: any; onAddTag: any; activeSection: any; onSectionChange: any; generators: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "Suspense", "lazy"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "@the-canonry/shared-components", "specifiers": ["ErrorBoundary"], "category": "external"}, {"source": "./RemotePlaceholder", "specifiers": ["RemotePlaceholder"], "category": "internal"}, {"source": "../theme", "specifiers": ["colors", "typography"], "category": "internal"}]}]