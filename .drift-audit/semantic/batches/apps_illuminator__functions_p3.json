[{"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::createEraNarrative", "name": "createEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function createEraNarrative(record: EraNarrativeRecord): Promise<EraNarrativeRecord> {\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrative", "name": "getEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrative(\n  narrativeId: string\n): Promise<EraNarrativeRecord | undefined> {\n  return db.eraNarratives.get(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForEra", "name": "getEraNarrativesForEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForEra(\n  simulationRunId: string,\n  eraId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where({ simulationRunId, eraId }).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "eraId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::getEraNarrativesForSimulation", "name": "getEraNarrativesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function getEraNarrativesForSimulation(\n  simulationRunId: string\n): Promise<EraNarrativeRecord[]> {\n  return db.eraNarratives.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrative", "name": "updateEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrative(\n  narrativeId: string,\n  updates: Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  if (updates.status !== undefined) record.status = updates.status;\n  if (updates.error !== undefined) record.error = updates.error;\n  if (updates.currentStep !== undefined) record.currentStep = updates.currentStep;\n  if (updates.threadSynthesis !== undefined) record.threadSynthesis = updates.threadSynthesis;\n  if (updates.narrative !== undefined) record.narrative = updates.narrative;\n  if (updates.contentVersions !== undefined) record.contentVersions = updates.contentVersions;\n  if (updates.activeVersionId !== undefined) record.activeVersionId = updates.activeVersionId;\n  if (updates.coverImage !== undefined) record.coverImage = updates.coverImage;\n  if (updates.imageRefs !== undefined) record.imageRefs = updates.imageRefs;\n  if (updates.totalInputTokens !== undefined) record.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) record.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) record.totalActualCost = updates.totalActualCost;\n  if (updates.editInsertion !== undefined) record.editInsertion = updates.editInsertion;\n  record.updatedAt = Date.now();\n\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      EraNarrativeRecord,\n      | \"status\"\n      | \"error\"\n      | \"currentStep\"\n      | \"threadSynthesis\"\n      | \"narrative\"\n      | \"contentVersions\"\n      | \"activeVersionId\"\n      | \"coverImage\"\n      | \"imageRefs\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n      | \"editInsertion\"\n    >\n  >", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrative", "name": "deleteEraNarrative", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrative(narrativeId: string): Promise<void> {\n  await db.eraNarratives.delete(narrativeId);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::deleteEraNarrativeVersion", "name": "deleteEraNarrativeVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function deleteEraNarrativeVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  const target = versions.find((v) => v.versionId === versionId);\n  if (!target) throw new Error(`Version ${versionId} not found`);\n  if (target.step === \"generate\") throw new Error(\"Cannot delete the generate version\");\n\n  record.contentVersions = versions.filter((v) => v.versionId !== versionId);\n\n  // If deleted version was active, fall back to latest remaining\n  if (record.activeVersionId === versionId) {\n    const remaining = record.contentVersions;\n    record.activeVersionId =\n      remaining.length > 0 ? remaining[remaining.length - 1].versionId : undefined;\n  }\n\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::setEraNarrativeActiveVersion", "name": "setEraNarrativeActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function setEraNarrativeActiveVersion(\n  narrativeId: string,\n  versionId: string\n): Promise<EraNarrativeRecord> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  materializeLegacyVersions(record);\n\n  const versions = record.contentVersions || [];\n  if (!versions.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found`);\n  }\n\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n  return record;\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImage", "name": "updateEraNarrativeCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Cover Image\n// =============================================================================\n\nexport async function updateEraNarrativeCoverImage(\n  narrativeId: string,\n  coverImage: EraNarrativeCoverImage,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.coverImage = coverImage;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "coverImage", "type": "EraNarrativeCoverImage", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeCoverImageStatus", "name": "updateEraNarrativeCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeCoverImageStatus(\n  narrativeId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.coverImage) return;\n\n  record.coverImage.status = status;\n  if (imageId) record.coverImage.generatedImageId = imageId;\n  if (error) record.coverImage.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefs", "name": "updateEraNarrativeImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Image Refs\n// =============================================================================\n\nexport async function updateEraNarrativeImageRefs(\n  narrativeId: string,\n  imageRefs: EraNarrativeImageRefs,\n  costs: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record) throw new Error(`Era narrative ${narrativeId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.totalInputTokens += costs.inputTokens;\n  record.totalOutputTokens += costs.outputTokens;\n  record.totalActualCost += costs.actual;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "EraNarrativeImageRefs", "optional": false}, {"name": "costs", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefStatus", "name": "updateEraNarrativeImageRefStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export async function updateEraNarrativeImageRefStatus(\n  narrativeId: string,\n  refId: string,\n  status: \"pending\" | \"generating\" | \"complete\" | \"failed\",\n  imageId?: string,\n  error?: string\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref || ref.type !== \"prompt_request\") return;\n\n  ref.status = status;\n  if (imageId) ref.generatedImageId = imageId;\n  if (error) ref.error = error;\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "status", "type": "\"pending\" | \"generating\" | \"complete\" | \"failed\"", "optional": false}, {"name": "imageId", "type": "string", "optional": true}, {"name": "error", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::updateEraNarrativeImageRefField", "name": "updateEraNarrativeImageRefField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "/**\n * Update arbitrary fields on an image ref (anchor text, size, justification).\n */\nexport async function updateEraNarrativeImageRefField(\n  narrativeId: string,\n  refId: string,\n  updates: { anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }\n): Promise<void> {\n  const record = await db.eraNarratives.get(narrativeId);\n  if (!record || !record.imageRefs) return;\n\n  const ref = record.imageRefs.refs.find((r) => r.refId === refId);\n  if (!ref) return;\n\n  if (updates.anchorText !== undefined) ref.anchorText = updates.anchorText;\n  if (updates.size !== undefined) (ref as any).size = updates.size;\n  if (updates.justification !== undefined) {\n    if (updates.justification === null) {\n      delete (ref as any).justification;\n    } else {\n      ref.justification = updates.justification;\n    }\n  }\n  record.updatedAt = Date.now();\n  await db.eraNarratives.put(record);\n}", "parameters": [{"name": "narrativeId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{ anchorText?: string; size?: string; justification?: \"left\" | \"right\" | null }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::resolveActiveContent", "name": "resolveActiveContent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "// =============================================================================\n// Version Helpers\n// =============================================================================\n\n/**\n * Get the active version's content, falling back to legacy narrative field.\n * Returns the content string and the version list for display.\n */\nexport function resolveActiveContent(record: EraNarrativeRecord): {\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n} {\n  const versions = record.contentVersions || [];\n\n  if (versions.length > 0) {\n    const activeId = record.activeVersionId || versions[versions.length - 1].versionId;\n    const active = versions.find((v) => v.versionId === activeId) || versions[versions.length - 1];\n    return { content: active.content, versions, activeVersionId: active.versionId };\n  }\n\n  // Legacy fallback: migrate from narrative field\n  if (record.narrative) {\n    const legacyVersions: EraNarrativeContentVersion[] = [];\n    legacyVersions.push({\n      versionId: `legacy_gen_${record.narrative.generatedAt}`,\n      content: record.narrative.content,\n      wordCount: record.narrative.wordCount,\n      step: \"generate\",\n      generatedAt: record.narrative.generatedAt,\n      model: record.narrative.model,\n      systemPrompt: record.narrative.systemPrompt,\n      userPrompt: record.narrative.userPrompt,\n      inputTokens: record.narrative.inputTokens,\n      outputTokens: record.narrative.outputTokens,\n      actualCost: record.narrative.actualCost,\n    });\n    if (record.narrative.editedContent) {\n      legacyVersions.push({\n        versionId: `legacy_edit_${record.narrative.editedAt || record.narrative.generatedAt}`,\n        content: record.narrative.editedContent,\n        wordCount:\n          record.narrative.editedWordCount ||\n          record.narrative.editedContent.split(/\\s+/).filter(Boolean).length,\n        step: \"edit\",\n        generatedAt: record.narrative.editedAt || record.narrative.generatedAt,\n        model: record.narrative.model,\n        systemPrompt: record.narrative.editSystemPrompt || \"\",\n        userPrompt: record.narrative.editUserPrompt || \"\",\n        inputTokens: record.narrative.editInputTokens || 0,\n        outputTokens: record.narrative.editOutputTokens || 0,\n        actualCost: record.narrative.editActualCost || 0,\n      });\n    }\n\n    const activeId = legacyVersions[legacyVersions.length - 1].versionId;\n    return {\n      content: legacyVersions[legacyVersions.length - 1].content,\n      versions: legacyVersions,\n      activeVersionId: activeId,\n    };\n  }\n\n  return { content: undefined, versions: [], activeVersionId: undefined };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}], "returnType": "{\n  content: string | undefined;\n  versions: EraNarrativeContentVersion[];\n  activeVersionId: string | undefined;\n}"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::isNarrativeEventsSeeded", "name": "isNarrativeEventsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isNarrativeEventsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[EventRepo] isNarrativeEventsSeeded\", { simulationRunId, count, seeded: count > 0 });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::seedNarrativeEvents", "name": "seedNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function seedNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<void> {\n  console.log(\"[EventRepo] seedNarrativeEvents\", { simulationRunId, eventCount: events.length });\n  const records: PersistedNarrativeEvent[] = events.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.narrativeEvents.bulkPut(records);\n  console.log(\"[EventRepo] seedNarrativeEvents complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::patchNarrativeEvents", "name": "patchNarrativeEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "/**\n * Patch narrative events without overwriting existing records.\n * Inserts only missing event IDs.\n */\nexport async function patchNarrativeEvents(\n  simulationRunId: string,\n  events: NarrativeEvent[]\n): Promise<number> {\n  if (!events?.length) return 0;\n\n  const existing = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingIds = new Set(existing.map((e) => e.id));\n\n  const toAdd: PersistedNarrativeEvent[] = [];\n  for (const event of events) {\n    if (!existingIds.has(event.id)) {\n      toAdd.push({ ...event, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.narrativeEvents.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "NarrativeEvent[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEventsForRun", "name": "getNarrativeEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getNarrativeEventsForRun(\n  simulationRunId: string\n): Promise<PersistedNarrativeEvent[]> {\n  const events = await db.narrativeEvents\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[EventRepo] getNarrativeEventsForRun\", { simulationRunId, count: events.length });\n  return events;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::getNarrativeEvent", "name": "getNarrativeEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "export async function getNarrativeEvent(\n  eventId: string\n): Promise<PersistedNarrativeEvent | undefined> {\n  return db.narrativeEvents.get(eventId);\n}", "parameters": [{"name": "eventId", "type": "string", "optional": false}], "returnType": "Promise<PersistedNarrativeEvent | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::applyEventPatches", "name": "applyEventPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Named mutations\n// ---------------------------------------------------------------------------\n\n/**\n * Apply event patches from a rename operation.\n * Reads affected events from Dexie, applies text replacements, writes back.\n * Returns IDs of all updated events.\n */\nexport async function applyEventPatches(\n  eventPatches: EventPatch[],\n  simulationRunId: string\n): Promise<string[]> {\n  console.log(\"[EventRepo] applyEventPatches called\", {\n    patchCount: eventPatches.length,\n    simulationRunId,\n    patchEventIds: eventPatches.map((p) => p.eventId),\n    patchKeys: eventPatches.map((p) => Object.keys(p.changes)),\n  });\n\n  if (eventPatches.length === 0) return [];\n\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.narrativeEvents, async () => {\n    // Load all events for the run (needed for the batch patch function)\n    const allEvents = await db.narrativeEvents\n      .where(\"simulationRunId\")\n      .equals(simulationRunId)\n      .toArray();\n\n    console.log(\"[EventRepo] Loaded events from Dexie\", {\n      totalEvents: allEvents.length,\n      simulationRunId,\n    });\n\n    // Sample a patched event BEFORE applying patches\n    const firstPatchId = eventPatches[0]?.eventId;\n    const sampleBefore = allEvents.find((e) => e.id === firstPatchId);\n    if (sampleBefore) {\n      console.log(\"[EventRepo] Sample event BEFORE patch\", {\n        id: sampleBefore.id,\n        description: sampleBefore.description?.substring(0, 200),\n        action: (sampleBefore as any).action?.substring(0, 200),\n      });\n    } else {\n      console.warn(\"[EventRepo] First patch target NOT FOUND in Dexie events\", {\n        targetId: firstPatchId,\n        availableIds: allEvents.slice(0, 5).map((e) => e.id),\n      });\n    }\n\n    // Apply patches using the existing pure function\n    const patched = applyPatches(allEvents, eventPatches);\n\n    // Sample the same event AFTER applying patches\n    const sampleAfter = patched.find((e) => e.id === firstPatchId);\n    if (sampleAfter) {\n      console.log(\"[EventRepo] Sample event AFTER patch\", {\n        id: sampleAfter.id,\n        description: sampleAfter.description?.substring(0, 200),\n        action: (sampleAfter as any).action?.substring(0, 200),\n      });\n    }\n\n    // Find which events actually changed and write them back\n    const patchedEventIds = new Set(eventPatches.map((p) => p.eventId));\n    let writeCount = 0;\n    for (const event of patched) {\n      if (patchedEventIds.has(event.id)) {\n        await db.narrativeEvents.put(event);\n        updatedIds.push(event.id);\n        writeCount++;\n      }\n    }\n    console.log(\"[EventRepo] Wrote patched events back to Dexie\", {\n      writeCount,\n      updatedIds,\n    });\n  });\n\n  // Verify: re-read one event to confirm persistence\n  if (updatedIds.length > 0) {\n    const verify = await db.narrativeEvents.get(updatedIds[0]);\n    console.log(\"[EventRepo] VERIFY after transaction\", {\n      id: verify?.id,\n      description: verify?.description?.substring(0, 200),\n      action: (verify as any)?.action?.substring(0, 200),\n    });\n  }\n\n  return updatedIds;\n}", "parameters": [{"name": "eventPatches", "type": "EventPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/eventRepository.ts::deleteEventsForRun", "name": "deleteEventsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eventRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEventsForRun(simulationRunId: string): Promise<void> {\n  await db.narrativeEvents.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::generateHistorianRunId", "name": "generateHistorianRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export function generateHistorianRunId(): string {\n  return `histrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::createHistorianRun", "name": "createHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function createHistorianRun(run: HistorianRun): Promise<HistorianRun> {\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "run", "type": "HistorianRun", "optional": false}], "returnType": "Promise<HistorianRun>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::getHistorianRun", "name": "getHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function getHistorianRun(runId: string): Promise<HistorianRun | undefined> {\n  return db.historianRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<HistorianRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::updateHistorianRun", "name": "updateHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function updateHistorianRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >\n): Promise<HistorianRun> {\n  const run = await db.historianRuns.get(runId);\n  if (!run) throw new Error(`Historian run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.notes !== undefined) run.notes = updates.notes;\n  if (updates.noteDecisions !== undefined) run.noteDecisions = updates.noteDecisions;\n  if (updates.chronologyAssignments !== undefined)\n    run.chronologyAssignments = updates.chronologyAssignments;\n  if (updates.inputTokens !== undefined) run.inputTokens = updates.inputTokens;\n  if (updates.outputTokens !== undefined) run.outputTokens = updates.outputTokens;\n  if (updates.actualCost !== undefined) run.actualCost = updates.actualCost;\n  if (updates.systemPrompt !== undefined) run.systemPrompt = updates.systemPrompt;\n  if (updates.userPrompt !== undefined) run.userPrompt = updates.userPrompt;\n  run.updatedAt = Date.now();\n\n  await db.historianRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      HistorianRun,\n      | \"status\"\n      | \"error\"\n      | \"notes\"\n      | \"noteDecisions\"\n      | \"chronologyAssignments\"\n      | \"inputTokens\"\n      | \"outputTokens\"\n      | \"actualCost\"\n      | \"systemPrompt\"\n      | \"userPrompt\"\n    >\n  >", "optional": false}], "returnType": "Promise<HistorianRun>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRepository.ts::deleteHistorianRun", "name": "deleteHistorianRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRepository.ts", "sourceCode": "export async function deleteHistorianRun(runId: string): Promise<void> {\n  await db.historianRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::extractReinforcedFactIds", "name": "extractReinforcedFactIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Context extraction\n// ============================================================================\n\n/**\n * Extract reinforced fact IDs from a HistorianReviewConfig's contextJson.\n * Returns the factIds from factCoverageGuidance targets, or undefined if none.\n */\nexport function extractReinforcedFactIds(contextJson: string): string[] | undefined {\n  try {\n    const ctx = JSON.parse(contextJson);\n    if (!Array.isArray(ctx.factCoverageGuidance) || ctx.factCoverageGuidance.length === 0)\n      return undefined;\n    return ctx.factCoverageGuidance.map((t: { factId: string }) => t.factId).filter(Boolean);\n  } catch {\n    return undefined;\n  }\n}", "parameters": [{"name": "contextJson", "type": "string", "optional": false}], "returnType": "string[] | undefined"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::sleep", "name": "sleep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "// ============================================================================\n// Helpers\n// ============================================================================\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}", "parameters": [{"name": "ms", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::dispatchReviewTask", "name": "dispatchReviewTask", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Enqueue a historian review task to the enrichment worker.\n */\nexport function dispatchReviewTask(runId: string): void {\n  getEnqueue()([\n    {\n      entity: {\n        id: \"__historian_review__\",\n        name: \"Historian Review\",\n        kind: \"system\",\n        subtype: \"\",\n        prominence: \"\",\n        culture: \"\",\n        status: \"active\",\n        description: \"\",\n        tags: {},\n      },\n      type: \"historianReview\" as EnrichmentType,\n      prompt: \"\",\n      chronicleId: runId,\n    },\n  ]);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts::pollReviewCompletion", "name": "pollReviewCompletion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/historianRunHelpers.ts", "sourceCode": "/**\n * Poll a historian run until it reaches 'reviewing' (success) or 'failed'.\n *\n * @param isCancelled \u2014 checked before and after each sleep; return true to abort.\n * @returns ReviewResult on success, null if cancelled or run disappeared.\n * @throws on run failure.\n */\nexport async function pollReviewCompletion(\n  runId: string,\n  isCancelled: () => boolean\n): Promise<ReviewResult | null> {\n  while (true) {\n    if (isCancelled()) return null;\n    await sleep(POLL_INTERVAL_MS);\n    if (isCancelled()) return null;\n\n    const run = await getHistorianRun(runId);\n    if (!run) return null;\n\n    if (run.status === \"reviewing\") {\n      const cost = run.actualCost || 0;\n      const prompts =\n        run.systemPrompt && run.userPrompt\n          ? { systemPrompt: run.systemPrompt, userPrompt: run.userPrompt }\n          : undefined;\n      await deleteHistorianRun(runId);\n      return { notes: run.notes || [], cost, prompts };\n    }\n\n    if (run.status === \"failed\") {\n      const error = run.error || \"Unknown error\";\n      await deleteHistorianRun(runId);\n      throw new Error(error);\n    }\n  }\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "isCancelled", "type": "() => boolean", "optional": false}], "returnType": "Promise<ReviewResult | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::generateImageId", "name": "generateImageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Pure Functions\n// ============================================================================\n\nexport function generateImageId(entityId: string): string {\n  return `img_${entityId}_${Date.now()}`;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::classifyAspect", "name": "classifyAspect", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Classify aspect ratio from width/height.\n */\nexport function classifyAspect(width: number, height: number): ImageAspect {\n  const ratio = width / height;\n  if (ratio < 0.9) return \"portrait\";\n  if (ratio > 1.1) return \"landscape\";\n  return \"square\";\n}", "parameters": [{"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}], "returnType": "ImageAspect"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::extractImageDimensions", "name": "extractImageDimensions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Extract dimensions from an image blob using createImageBitmap (works in workers).\n */\nexport async function extractImageDimensions(\n  blob: Blob\n): Promise<{ width: number; height: number; aspect: ImageAspect }> {\n  const bitmap = await createImageBitmap(blob);\n  const { width, height } = bitmap;\n  bitmap.close();\n  return { width, height, aspect: classifyAspect(width, height) };\n}", "parameters": [{"name": "blob", "type": "Blob", "optional": false}], "returnType": "Promise<{ width: number; height: number; aspect: ImageAspect }>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::saveImage", "name": "saveImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// CRUD\n// ============================================================================\n\nexport async function saveImage(\n  imageId: string,\n  blob: Blob,\n  metadata: ImageMetadata\n): Promise<string> {\n  const { size: sizeOverride, ...rest } = metadata as ImageMetadata & { size?: unknown };\n  const requestedSize =\n    typeof sizeOverride === \"string\" && sizeOverride.trim() ? sizeOverride : rest.requestedSize;\n  const metadataRecord = {\n    imageId,\n    mimeType: blob.type || \"image/png\",\n    size: blob.size,\n    ...rest,\n    requestedSize,\n    savedAt: Date.now(),\n  };\n\n  console.log(`${LOG_PREFIX} Image save start`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.put(metadataRecord as any);\n    await db.imageBlobs.put({ imageId, blob });\n  });\n\n  console.log(`${LOG_PREFIX} Image save complete`, {\n    imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    size: blob.size,\n  });\n\n  return imageId;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}, {"name": "blob", "type": "Blob", "optional": false}, {"name": "metadata", "type": "ImageMetadata", "optional": false}], "returnType": "Promise<string>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImage", "name": "deleteImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "export async function deleteImage(imageId: string): Promise<void> {\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.delete(imageId);\n    await db.imageBlobs.delete(imageId);\n  });\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImages", "name": "searchImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Queries\n// ============================================================================\n\n/**\n * Search images with pagination \u2014 returns metadata only (no blobs).\n */\nexport async function searchImages(options: ImageSearchOptions = {}): Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, search, limit = 20, offset = 0 } = options;\n  const searchLower = search?.toLowerCase() || \"\";\n\n  // Fetch candidates \u2014 use index when filtering by projectId\n  const allRecords = projectId\n    ? await db.images.where(\"projectId\").equals(projectId).toArray()\n    : await db.images.toArray();\n\n  // Apply search filter (on entityName \u2014 lightweight)\n  const filtered = searchLower\n    ? allRecords.filter((r) => r.entityName && r.entityName.toLowerCase().includes(searchLower))\n    : allRecords;\n\n  const total = filtered.length;\n\n  // Paginate and project to lightweight list items (no blob)\n  const items: ImageListItem[] = filtered.slice(offset, offset + limit).map((r) => ({\n    imageId: r.imageId,\n    entityId: r.entityId,\n    projectId: r.projectId,\n    entityName: r.entityName,\n    entityKind: r.entityKind,\n    generatedAt: r.generatedAt,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "options", "type": "ImageSearchOptions", "optional": true}], "returnType": "Promise<{\n  items: ImageListItem[];\n  total: number;\n  hasMore: boolean;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageDataUrl", "name": "getImageDataUrl", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Load a single image's dataUrl by ID (on-demand loading).\n */\nexport async function getImageDataUrl(imageId: string): Promise<string | null> {\n  const blobRecord = await db.imageBlobs.get(imageId);\n  if (!blobRecord?.blob) return null;\n\n  try {\n    return await blobToDataUrl(blobRecord.blob);\n  } catch (err) {\n    console.warn(`Failed to convert image ${imageId} to dataUrl:`, err);\n    return null;\n  }\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<string | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::loadImage", "name": "loadImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Load / Browse (used by UI components that previously used Canonry imageStore)\n// ============================================================================\n\n/**\n * Load an image by ID and create an object URL.\n * Returns { url, ...metadata } or null if not found.\n * Caller is responsible for revoking the object URL.\n */\nexport async function loadImage(imageId: string): Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null> {\n  if (!imageId) return null;\n  const [metadata, blobRecord] = await Promise.all([\n    db.images.get(imageId),\n    db.imageBlobs.get(imageId),\n  ]);\n  if (!metadata || !blobRecord?.blob) return null;\n\n  const url = URL.createObjectURL(blobRecord.blob);\n  return {\n    url,\n    imageId: metadata.imageId,\n    entityId: metadata.entityId,\n    projectId: metadata.projectId,\n    mimeType: metadata.mimeType,\n    size: metadata.size,\n    generatedAt: metadata.generatedAt,\n    model: metadata.model,\n    originalPrompt: metadata.originalPrompt,\n    finalPrompt: metadata.finalPrompt,\n    revisedPrompt: metadata.revisedPrompt,\n    entityName: metadata.entityName,\n    entityKind: metadata.entityKind,\n    entityCulture: metadata.entityCulture,\n    imageType: metadata.imageType,\n    chronicleId: metadata.chronicleId,\n    imageRefId: metadata.imageRefId,\n    sceneDescription: metadata.sceneDescription,\n  };\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<{\n  url: string;\n  imageId: string;\n  entityId: string;\n  projectId: string;\n  mimeType: string;\n  size: number;\n  generatedAt: number;\n  model: string;\n  originalPrompt?: string;\n  finalPrompt?: string;\n  revisedPrompt?: string;\n  entityName?: string;\n  entityKind?: string;\n  entityCulture?: string;\n  imageType?: ImageType;\n  chronicleId?: string;\n  imageRefId?: string;\n  sceneDescription?: string;\n} | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageBlob", "name": "getImageBlob", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get raw image blob by ID.\n */\nexport async function getImageBlob(imageId: string): Promise<Blob | null> {\n  if (!imageId) return null;\n  const record = await db.imageBlobs.get(imageId);\n  return record?.blob || null;\n}", "parameters": [{"name": "imageId", "type": "string", "optional": false}], "returnType": "Promise<Blob | null>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getAllImages", "name": "getAllImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get all images (metadata only, no blobs) sorted newest first.\n */\nexport async function getAllImages(): Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n> {\n  const records = await db.images.toArray();\n  const images = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    projectId: record.projectId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    revisedPrompt: record.revisedPrompt,\n    estimatedCost: record.estimatedCost,\n    actualCost: record.actualCost,\n    inputTokens: record.inputTokens,\n    outputTokens: record.outputTokens,\n    width: record.width,\n    height: record.height,\n    aspect: record.aspect,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    imageRefId: record.imageRefId,\n    sceneDescription: record.sceneDescription,\n    mimeType: record.mimeType,\n    size: typeof record.size === \"number\" && Number.isFinite(record.size) ? record.size : 0,\n    savedAt: record.savedAt,\n    hasBlob: true,\n  }));\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n  return images;\n}", "parameters": [], "returnType": "Promise<\n  Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>\n>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::deleteImages", "name": "deleteImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Delete multiple images by ID.\n */\nexport async function deleteImages(imageIds: string[]): Promise<void> {\n  if (!imageIds?.length) return;\n  await db.transaction(\"rw\", [db.images, db.imageBlobs], async () => {\n    await db.images.bulkDelete(imageIds);\n    await db.imageBlobs.bulkDelete(imageIds);\n  });\n}", "parameters": [{"name": "imageIds", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getStorageStats", "name": "getStorageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get storage statistics (count, total size, breakdown by project).\n */\nexport async function getStorageStats(): Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}> {\n  const records = await db.images.toArray();\n\n  let totalSize = 0;\n  const byProject: Record<string, { count: number; size: number }> = {};\n\n  for (const img of records) {\n    const size = typeof img.size === \"number\" && Number.isFinite(img.size) ? img.size : 0;\n    totalSize += size;\n\n    const pid = img.projectId || \"unknown\";\n    if (!byProject[pid]) {\n      byProject[pid] = { count: 0, size: 0 };\n    }\n    byProject[pid].count++;\n    byProject[pid].size += size;\n  }\n\n  return { totalCount: records.length, totalSize, byProject };\n}", "parameters": [], "returnType": "Promise<{\n  totalCount: number;\n  totalSize: number;\n  byProject: Record<string, { count: number; size: number }>;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::getImageFilterOptions", "name": "getImageFilterOptions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Get unique values for a metadata field (for filter dropdowns).\n */\nexport async function getImageFilterOptions(\n  field: \"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"\n): Promise<string[]> {\n  const records = await db.images.toArray();\n  const values = new Set<string>();\n  for (const record of records) {\n    const val = (record as any)[field];\n    if (val) values.add(val);\n  }\n  return [...values].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "field", "type": "\"entityKind\" | \"entityCulture\" | \"model\" | \"projectId\"", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchImagesWithFilters", "name": "searchImagesWithFilters", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search images with rich filters (entity kind, culture, model, text search).\n * Returns metadata without blobs.\n */\nexport async function searchImagesWithFilters(\n  filters: {\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  } = {}\n): Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>> {\n  const records = await db.images.toArray();\n\n  let images: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }> = records.map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  if (filters.projectId) images = images.filter((img) => img.projectId === filters.projectId);\n  if (filters.entityKind) images = images.filter((img) => img.entityKind === filters.entityKind);\n  if (filters.entityCulture)\n    images = images.filter((img) => img.entityCulture === filters.entityCulture);\n  if (filters.model) images = images.filter((img) => img.model === filters.model);\n  if (filters.imageType) images = images.filter((img) => img.imageType === filters.imageType);\n  if (filters.chronicleId) images = images.filter((img) => img.chronicleId === filters.chronicleId);\n  if (filters.imageRefId) images = images.filter((img) => img.imageRefId === filters.imageRefId);\n\n  if (filters.searchText) {\n    const search = filters.searchText.toLowerCase();\n    images = images.filter(\n      (img) =>\n        img.entityName?.toLowerCase().includes(search) ||\n        img.originalPrompt?.toLowerCase().includes(search) ||\n        img.finalPrompt?.toLowerCase().includes(search) ||\n        img.revisedPrompt?.toLowerCase().includes(search)\n    );\n  }\n\n  images.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  if (filters.limit && filters.limit > 0) {\n    images = images.slice(0, filters.limit);\n  }\n\n  return images;\n}", "parameters": [{"name": "filters", "type": "{\n    projectId?: string;\n    entityKind?: string;\n    entityCulture?: string;\n    model?: string;\n    imageType?: string;\n    chronicleId?: string;\n    imageRefId?: string;\n    searchText?: string;\n    limit?: number;\n  }", "optional": true}], "returnType": "Promise<Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::searchChronicleImages", "name": "searchChronicleImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Search chronicle images with pagination.\n * Uses indexed queries when possible for better performance on large libraries.\n */\nexport async function searchChronicleImages(filters: {\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}> {\n  const { projectId, chronicleId, imageRefId, limit = 20, offset = 0 } = filters;\n\n  // Start with indexed query on chronicleId if provided, else projectId\n  const query = chronicleId\n    ? db.images.where(\"chronicleId\").equals(chronicleId)\n    : db.images.where(\"projectId\").equals(projectId);\n\n  let records = await query.toArray();\n\n  // Apply additional filters\n  if (chronicleId && !imageRefId) {\n    // Already filtered by chronicleId via index\n  } else if (imageRefId) {\n    records = records.filter((r) => r.imageRefId === imageRefId);\n  }\n\n  // Only include chronicle images\n  records = records.filter((r) => r.imageType === \"chronicle\");\n\n  // Sort by generatedAt descending\n  records.sort((a, b) => (b.generatedAt || 0) - (a.generatedAt || 0));\n\n  const total = records.length;\n\n  // Paginate\n  const items = records.slice(offset, offset + limit).map((record) => ({\n    ...record,\n    hasBlob: true,\n  }));\n\n  return {\n    items,\n    total,\n    hasMore: offset + items.length < total,\n  };\n}", "parameters": [{"name": "filters", "type": "{\n  projectId: string;\n  chronicleId?: string;\n  imageRefId?: string;\n  limit?: number;\n  offset?: number;\n}", "optional": false}], "returnType": "Promise<{\n  items: Array<Omit<ImageRecord, \"blob\"> & { hasBlob: boolean }>;\n  total: number;\n  hasMore: boolean;\n}>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::formatBytes", "name": "formatBytes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Format bytes to human-readable string.\n */\nexport function formatBytes(bytes: number): string {\n  if (!bytes || !Number.isFinite(bytes) || bytes <= 0) return \"0 B\";\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n}", "parameters": [{"name": "bytes", "type": "number", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::exportImagePrompts", "name": "exportImagePrompts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "// ============================================================================\n// Bulk Export for Prompt Analysis\n// ============================================================================\n\n/**\n * Export all image prompt data for analysis.\n * Excludes image blobs to keep export size manageable.\n */\nexport async function exportImagePrompts(): Promise<ImagePromptExport[]> {\n  const records = await db.images.toArray();\n\n  const exports: ImagePromptExport[] = records.map((record) => ({\n    imageId: record.imageId,\n    entityId: record.entityId,\n    entityName: record.entityName,\n    entityKind: record.entityKind,\n    entityCulture: record.entityCulture,\n    generatedAt: record.generatedAt,\n    model: record.model,\n    originalPrompt: record.originalPrompt,\n    formattingPrompt: record.formattingPrompt,\n    finalPrompt: record.finalPrompt,\n    revisedPrompt: record.revisedPrompt,\n    imageType: record.imageType,\n    chronicleId: record.chronicleId,\n    sceneDescription: record.sceneDescription,\n  }));\n\n  // Sort by generatedAt descending (newest first)\n  exports.sort((a, b) => b.generatedAt - a.generatedAt);\n  return exports;\n}", "parameters": [], "returnType": "Promise<ImagePromptExport[]>"}, {"id": "apps/illuminator/webui/src/lib/db/imageRepository.ts::downloadImagePromptExport", "name": "downloadImagePromptExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/imageRepository.ts", "sourceCode": "/**\n * Export image prompts and download as JSON file.\n */\nexport async function downloadImagePromptExport(): Promise<void> {\n  const exports = await exportImagePrompts();\n  const json = JSON.stringify(exports, null, 2);\n  const blob = new Blob([json], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `image-prompts-${new Date().toISOString().split(\"T\")[0]}.json`;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n\n  console.log(`Exported ${exports.length} image prompt records`);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/indexComputation.ts::computeRunIndexes", "name": "computeRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexComputation.ts", "sourceCode": "export function computeRunIndexes(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): RunIndexRecord {\n  // --- Prominence scale (exclude manual_ entities) ---\n  const prominenceValues = entities\n    .filter((e) => !e.id.startsWith(\"manual_\"))\n    .map((e) => e.prominence)\n    .filter((v): v is number => typeof v === \"number\" && Number.isFinite(v));\n\n  const prominenceScale = buildProminenceScale(prominenceValues, {\n    distribution: DEFAULT_PROMINENCE_DISTRIBUTION,\n  });\n\n  const renownedThreshold = prominenceThresholdFromScale(\"renowned\", prominenceScale);\n\n  // --- Era temporal info ---\n  const eraEntities = entities.filter(\n    (e) => e.kind === \"era\" && (e as any).temporal?.startTick != null\n  );\n  const sortedEras = [...eraEntities].sort(\n    (a, b) => (a as any).temporal.startTick - (b as any).temporal.startTick\n  );\n\n  const eraTemporalInfo: EraTemporalEntry[] = sortedEras.map((era, index) => {\n    const startTick: number = (era as any).temporal.startTick;\n    const endTick: number = (era as any).temporal.endTick ?? startTick;\n    const eraId = resolveEntityEraId(era) || era.id;\n    return {\n      id: eraId,\n      name: era.name,\n      summary: (era as any).summary || \"\",\n      order: index,\n      startTick,\n      endTick,\n      duration: endTick - startTick,\n    };\n  });\n\n  // --- Era ID aliases (entityId -> eraId for eraTemporalInfoByKey) ---\n  const eraIdAliases: Record<string, string> = {};\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") continue;\n    const eraId = resolveEntityEraId(entity);\n    if (eraId) {\n      eraIdAliases[entity.id] = eraId;\n    }\n  }\n\n  // --- Prominent by culture (all entities, threshold from scale) ---\n  const prominentByCulture: Record<string, Array<{ id: string; name: string }>> = {};\n  for (const entity of entities) {\n    if (!entity.culture) continue;\n    if (typeof entity.prominence !== \"number\" || entity.prominence < renownedThreshold) continue;\n    if (!prominentByCulture[entity.culture]) {\n      prominentByCulture[entity.culture] = [];\n    }\n    prominentByCulture[entity.culture].push({ id: entity.id, name: entity.name });\n  }\n\n  return {\n    simulationRunId,\n    prominenceScale,\n    renownedThreshold,\n    eraTemporalInfo,\n    eraIdAliases,\n    prominentByCulture,\n    computedAt: Date.now(),\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "RunIndexRecord"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::getRunIndexes", "name": "getRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function getRunIndexes(simulationRunId: string): Promise<RunIndexRecord | undefined> {\n  return db.runIndexes.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<RunIndexRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::upsertRunIndexes", "name": "upsertRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function upsertRunIndexes(record: RunIndexRecord): Promise<void> {\n  await db.runIndexes.put(record);\n}", "parameters": [{"name": "record", "type": "RunIndexRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/indexRepository.ts::deleteRunIndexes", "name": "deleteRunIndexes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/indexRepository.ts", "sourceCode": "export async function deleteRunIndexes(simulationRunId: string): Promise<void> {\n  await db.runIndexes.delete(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts::migrateFromLegacyDbs", "name": "migrateFromLegacyDbs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/migrateFromLegacyDbs.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Run all legacy migrations. Safe to call multiple times \u2014 already-migrated\n * databases are skipped via localStorage tracking.\n */\nexport async function migrateFromLegacyDbs(): Promise<void> {\n  const state = getState();\n  const allDbs = [\n    \"canonry-chronicles\",\n    \"canonry-images\",\n    \"canonry-costs\",\n    \"canonry-traits\",\n    \"canonry-historian\",\n    \"canonry-summary-revision\",\n    \"canonry-dynamics-generation\",\n    \"canonry-static-pages\",\n    \"illuminator-styles\",\n  ];\n\n  const pending = allDbs.filter((name) => !(name in state));\n  if (pending.length === 0) return;\n\n  console.log(`${LOG_PREFIX} Starting migration for ${pending.length} legacy databases:`, pending);\n\n  // Run all migrations in parallel \u2014 they're independent\n  await Promise.allSettled([\n    migrateChronicles(),\n    migrateImages(),\n    migrateCosts(),\n    migrateTraits(),\n    migrateHistorianRuns(),\n    migrateSummaryRevisionRuns(),\n    migrateDynamicsRuns(),\n    migrateStaticPages(),\n    migrateStyleLibrary(),\n  ]);\n\n  console.log(`${LOG_PREFIX} Migration complete`);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayout", "name": "getPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayout(\n  simulationRunId: string,\n  pageId: string\n): Promise<PageLayoutOverride | null> {\n  const record = await db.pageLayouts.get([simulationRunId, pageId]);\n  return record ?? null;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride | null>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::putPageLayout", "name": "putPageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function putPageLayout(override: PageLayoutOverride): Promise<void> {\n  await db.pageLayouts.put(override);\n}", "parameters": [{"name": "override", "type": "PageLayoutOverride", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::deletePageLayout", "name": "deletePageLayout", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function deletePageLayout(simulationRunId: string, pageId: string): Promise<void> {\n  await db.pageLayouts.delete([simulationRunId, pageId]);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getAllPageLayouts", "name": "getAllPageLayouts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getAllPageLayouts(simulationRunId: string): Promise<PageLayoutOverride[]> {\n  return db.pageLayouts.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PageLayoutOverride[]>"}, {"id": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts::getPageLayoutMap", "name": "getPageLayoutMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/pageLayoutRepository.ts", "sourceCode": "export async function getPageLayoutMap(\n  simulationRunId: string\n): Promise<Map<string, PageLayoutOverride>> {\n  const all = await getAllPageLayouts(simulationRunId);\n  const map = new Map<string, PageLayoutOverride>();\n  for (const o of all) {\n    map.set(o.pageId, o);\n  }\n  return map;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, PageLayoutOverride>>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::isRelationshipsSeeded", "name": "isRelationshipsSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed\n// ---------------------------------------------------------------------------\n\nexport async function isRelationshipsSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.relationships.where(\"simulationRunId\").equals(simulationRunId).count();\n  console.log(\"[RelationshipRepo] isRelationshipsSeeded\", {\n    simulationRunId,\n    count,\n    seeded: count > 0,\n  });\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::seedRelationships", "name": "seedRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "export async function seedRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<void> {\n  console.log(\"[RelationshipRepo] seedRelationships\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  const records: PersistedRelationship[] = relationships.map((rel) => ({\n    ...rel,\n    simulationRunId,\n  }));\n  await db.relationships.bulkPut(records);\n  console.log(\"[RelationshipRepo] seedRelationships complete\");\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::patchRelationships", "name": "patchRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Patch relationships without overwriting existing records.\n * Inserts only missing relationship keys (src/dst/kind).\n */\nexport async function patchRelationships(\n  simulationRunId: string,\n  relationships: WorldRelationship[]\n): Promise<number> {\n  if (!relationships?.length) return 0;\n\n  const existing = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  const existingKeys = new Set(existing.map((rel) => `${rel.src}:${rel.dst}:${rel.kind}`));\n\n  const toAdd: PersistedRelationship[] = [];\n  for (const rel of relationships) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!existingKeys.has(key)) {\n      toAdd.push({ ...rel, simulationRunId });\n    }\n  }\n\n  if (toAdd.length > 0) {\n    await db.relationships.bulkPut(toAdd);\n  }\n\n  return toAdd.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "relationships", "type": "WorldRelationship[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForRun", "name": "getRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getRelationshipsForRun(\n  simulationRunId: string\n): Promise<PersistedRelationship[]> {\n  const relationships = await db.relationships\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .toArray();\n  console.log(\"[RelationshipRepo] getRelationshipsForRun\", {\n    simulationRunId,\n    count: relationships.length,\n  });\n  return relationships;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::getRelationshipsForEntity", "name": "getRelationshipsForEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "/**\n * Get all relationships involving a specific entity (as src or dst).\n * Uses the existing 'src' and 'dst' indexes for efficient per-entity queries.\n */\nexport async function getRelationshipsForEntity(\n  simulationRunId: string,\n  entityId: string\n): Promise<PersistedRelationship[]> {\n  const [asSrc, asDst] = await Promise.all([\n    db.relationships\n      .where(\"src\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n    db.relationships\n      .where(\"dst\")\n      .equals(entityId)\n      .and((r) => r.simulationRunId === simulationRunId)\n      .toArray(),\n  ]);\n  const seen = new Set<string>();\n  const result: PersistedRelationship[] = [];\n  for (const rel of [...asSrc, ...asDst]) {\n    const key = `${rel.src}:${rel.dst}:${rel.kind}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(rel);\n    }\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedRelationship[]>"}, {"id": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts::deleteRelationshipsForRun", "name": "deleteRelationshipsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/relationshipRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteRelationshipsForRun(simulationRunId: string): Promise<void> {\n  await db.relationships.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::getSchema", "name": "getSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function getSchema(projectId: string): Promise<WorldSchemaRecord | undefined> {\n  return db.worldSchemas.get(projectId);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<WorldSchemaRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/schemaRepository.ts::upsertSchema", "name": "upsertSchema", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/schemaRepository.ts", "sourceCode": "export async function upsertSchema(projectId: string, schema: CanonrySchemaSlice): Promise<void> {\n  await db.worldSchemas.put({\n    projectId,\n    schema,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "schema", "type": "CanonrySchemaSlice", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function getSlot(\n  projectId: string,\n  slotIndex: number\n): Promise<SimulationSlotRecord | undefined> {\n  return db.simulationSlots.get([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<SimulationSlotRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::upsertSlot", "name": "upsertSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function upsertSlot(record: SimulationSlotRecord): Promise<void> {\n  await db.simulationSlots.put(record);\n}", "parameters": [{"name": "record", "type": "SimulationSlotRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/slotRepository.ts::deleteSlot", "name": "deleteSlot", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/slotRepository.ts", "sourceCode": "export async function deleteSlot(projectId: string, slotIndex: number): Promise<void> {\n  await db.simulationSlots.delete([projectId, slotIndex]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "slotIndex", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generatePageId", "name": "generatePageId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generatePageId(): string {\n  return `static_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::generateSlug", "name": "generateSlug", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, \"\")\n    .replace(/\\s+/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .replace(/^-|-$/g, \"\")\n    .substring(0, 100);\n}", "parameters": [{"name": "title", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::extractEntityLinks", "name": "extractEntityLinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function extractEntityLinks(content: string): string[] {\n  const regex = /\\[\\[([^\\]]+)\\]\\]/g; // eslint-disable-line sonarjs/slow-regex -- character-class bounded, no backtracking\n  const matches: string[] = [];\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const entityName = match[1].trim();\n    if (entityName && !matches.includes(entityName)) {\n      matches.push(entityName);\n    }\n  }\n\n  return matches;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::countWords", "name": "countWords", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export function countWords(content: string): number {\n  /* eslint-disable sonarjs/slow-regex -- character-class bounded markdown patterns, no backtracking */\n  const plainText = content\n    .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, \"$1\")\n    .replace(/\\[\\[([^\\]]+)\\]\\]/g, \"$1\")\n    .replace(/!\\[[^\\]]*\\]\\([^)]+\\)/g, \"\")\n    /* eslint-enable sonarjs/slow-regex */\n    .replace(/[#*_~`>]/g, \"\")\n    .replace(/\\n+/g, \" \")\n    .trim();\n\n  if (!plainText) return 0;\n  return plainText.split(/\\s+/).length;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::createStaticPage", "name": "createStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function createStaticPage(input: CreateStaticPageInput): Promise<StaticPage> {\n  const now = Date.now();\n  const content = input.content ?? \"\";\n\n  const page: StaticPage = {\n    pageId: generatePageId(),\n    projectId: input.projectId,\n    title: input.title,\n    slug: generateSlug(input.title),\n    content,\n    summary: input.summary,\n    status: input.status ?? \"draft\",\n    createdAt: now,\n    updatedAt: now,\n    linkedEntityIds: extractEntityLinks(content),\n    wordCount: countWords(content),\n  };\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "input", "type": "CreateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::updateStaticPage", "name": "updateStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function updateStaticPage(\n  pageId: string,\n  updates: UpdateStaticPageInput\n): Promise<StaticPage> {\n  const page = await db.staticPages.get(pageId);\n  if (!page) throw new Error(`Static page ${pageId} not found`);\n\n  if (updates.title !== undefined) {\n    page.title = updates.title;\n    page.slug = generateSlug(updates.title);\n  }\n  if (updates.content !== undefined) {\n    page.content = updates.content;\n    page.linkedEntityIds = extractEntityLinks(updates.content);\n    page.wordCount = countWords(updates.content);\n  }\n  if (updates.summary !== undefined) {\n    page.summary = updates.summary;\n  }\n  if (updates.status !== undefined) {\n    page.status = updates.status;\n  }\n  page.updatedAt = Date.now();\n\n  await db.staticPages.put(page);\n  return page;\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}, {"name": "updates", "type": "UpdateStaticPageInput", "optional": false}], "returnType": "Promise<StaticPage>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPage", "name": "getStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPage(pageId: string): Promise<StaticPage | undefined> {\n  return db.staticPages.get(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await db.staticPages.where(\"projectId\").equals(projectId).toArray();\n  pages.sort((a, b) => b.updatedAt - a.updatedAt);\n  return pages;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::getPublishedStaticPagesForProject", "name": "getPublishedStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function getPublishedStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const pages = await getStaticPagesForProject(projectId);\n  return pages.filter((page) => page.status === \"published\");\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPage", "name": "deleteStaticPage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPage(pageId: string): Promise<void> {\n  await db.staticPages.delete(pageId);\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/staticPageRepository.ts", "sourceCode": "export async function deleteStaticPagesForProject(projectId: string): Promise<number> {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n  await db.staticPages.bulkDelete(pages.map((p) => p.pageId));\n  return pages.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::loadStyleLibrary", "name": "loadStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function loadStyleLibrary(): Promise<StyleLibrary | null> {\n  const result = await db.styleLibrary.get(LIBRARY_KEY);\n  return result?.library ?? null;\n}", "parameters": [], "returnType": "Promise<StyleLibrary | null>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::saveStyleLibrary", "name": "saveStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function saveStyleLibrary(library: StyleLibrary): Promise<void> {\n  const record: StyleLibraryRecord = {\n    id: LIBRARY_KEY,\n    library,\n    savedAt: Date.now(),\n  };\n  await db.styleLibrary.put(record);\n}", "parameters": [{"name": "library", "type": "StyleLibrary", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::resetStyleLibrary", "name": "resetStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function resetStyleLibrary(): Promise<void> {\n  await db.styleLibrary.delete(LIBRARY_KEY);\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::getStyleLibrary", "name": "getStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function getStyleLibrary(): Promise<StyleLibrary> {\n  const stored = await loadStyleLibrary();\n  if (stored) return stored;\n  return createDefaultStyleLibrary();\n}", "parameters": [], "returnType": "Promise<StyleLibrary>"}, {"id": "apps/illuminator/webui/src/lib/db/styleRepository.ts::hasCustomStyleLibrary", "name": "hasCustomStyleLibrary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/styleRepository.ts", "sourceCode": "export async function hasCustomStyleLibrary(): Promise<boolean> {\n  const stored = await loadStyleLibrary();\n  return stored !== null;\n}", "parameters": [], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::generateRevisionRunId", "name": "generateRevisionRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export function generateRevisionRunId(): string {\n  return `revrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::createRevisionRun", "name": "createRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function createRevisionRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string,\n  batches: SummaryRevisionBatch[],\n  context: {\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }\n): Promise<SummaryRevisionRun> {\n  const now = Date.now();\n\n  const run: SummaryRevisionRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    batches,\n    currentBatchIndex: 0,\n    patchDecisions: {},\n    worldDynamicsContext: context.worldDynamicsContext,\n    staticPagesContext: context.staticPagesContext,\n    schemaContext: context.schemaContext,\n    revisionGuidance: context.revisionGuidance,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "batches", "type": "SummaryRevisionBatch[]", "optional": false}, {"name": "context", "type": "{\n    worldDynamicsContext: string;\n    staticPagesContext: string;\n    schemaContext: string;\n    revisionGuidance: string;\n  }", "optional": false}], "returnType": "Promise<SummaryRevisionRun>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::getRevisionRun", "name": "getRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function getRevisionRun(runId: string): Promise<SummaryRevisionRun | undefined> {\n  return db.summaryRevisionRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<SummaryRevisionRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::updateRevisionRun", "name": "updateRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function updateRevisionRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<SummaryRevisionRun> {\n  const run = await db.summaryRevisionRuns.get(runId);\n  if (!run) throw new Error(`Revision run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.batches !== undefined) run.batches = updates.batches;\n  if (updates.currentBatchIndex !== undefined) run.currentBatchIndex = updates.currentBatchIndex;\n  if (updates.patchDecisions !== undefined) run.patchDecisions = updates.patchDecisions;\n  if (updates.error !== undefined) (run as any).error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.summaryRevisionRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      SummaryRevisionRun,\n      | \"status\"\n      | \"batches\"\n      | \"currentBatchIndex\"\n      | \"patchDecisions\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<SummaryRevisionRun>"}, {"id": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts::deleteRevisionRun", "name": "deleteRevisionRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/summaryRevisionRepository.ts", "sourceCode": "export async function deleteRevisionRun(runId: string): Promise<void> {\n  await db.summaryRevisionRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getPalette", "name": "getPalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getPalette(\n  projectId: string,\n  entityKind: string\n): Promise<TraitPalette | null> {\n  const id = paletteId(projectId, entityKind);\n  const result = await db.traitPalettes.get(id);\n  return result || null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette | null>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::savePalette", "name": "savePalette", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function savePalette(palette: TraitPalette): Promise<void> {\n  await db.traitPalettes.put({\n    ...palette,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "palette", "type": "TraitPalette", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::updatePaletteItems", "name": "updatePaletteItems", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function updatePaletteItems(\n  projectId: string,\n  entityKind: string,\n  updates: {\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }\n): Promise<TraitPalette> {\n  const existing = await getPalette(projectId, entityKind);\n  const items = existing?.items || [];\n  const now = Date.now();\n\n  let filtered = items.filter((item) => !updates.removeIds?.includes(item.id));\n\n  for (const merge of updates.merges || []) {\n    const keepItem = filtered.find((i) => i.id === merge.keepId);\n    if (keepItem) {\n      keepItem.description = merge.newDescription;\n      const mergedItems = items.filter((i) => merge.mergeFromIds.includes(i.id));\n      keepItem.timesUsed += mergedItems.reduce((sum, i) => sum + i.timesUsed, 0);\n    }\n    filtered = filtered.filter((i) => !merge.mergeFromIds.includes(i.id));\n  }\n\n  for (const newItem of updates.newItems || []) {\n    filtered.push({\n      id: `palette_${now}_${crypto.randomUUID().slice(0, 8)}`,\n      category: newItem.category,\n      description: newItem.description,\n      examples: newItem.examples,\n      subtypes: newItem.subtypes,\n      era: newItem.era,\n      timesUsed: 0,\n      addedAt: now,\n    });\n  }\n\n  const palette: TraitPalette = {\n    id: paletteId(projectId, entityKind),\n    projectId,\n    entityKind,\n    items: filtered,\n    updatedAt: now,\n  };\n\n  await savePalette(palette);\n  return palette;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    removeIds?: string[];\n    merges?: Array<{ keepId: string; mergeFromIds: string[]; newDescription: string }>;\n    newItems?: Omit<PaletteItem, \"id\" | \"timesUsed\" | \"addedAt\">[];\n  }", "optional": false}], "returnType": "Promise<TraitPalette>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::incrementPaletteUsage", "name": "incrementPaletteUsage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function incrementPaletteUsage(\n  projectId: string,\n  entityKind: string,\n  traits: string[]\n): Promise<void> {\n  const palette = await getPalette(projectId, entityKind);\n  if (!palette || palette.items.length === 0) return;\n\n  const traitLower = traits.map((t) => t.toLowerCase()).join(\" \");\n  let updated = false;\n\n  for (const item of palette.items) {\n    const categoryWords = item.category.toLowerCase().split(/\\s+/);\n    const exampleWords = item.examples.flatMap((e) => e.toLowerCase().split(/\\s+/));\n    const allWords = [...categoryWords, ...exampleWords];\n\n    const matches = allWords.filter((w) => w.length > 4 && traitLower.includes(w));\n    if (matches.length >= 2) {\n      item.timesUsed += 1;\n      updated = true;\n    }\n  }\n\n  if (updated) {\n    await savePalette(palette);\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::registerUsedTraits", "name": "registerUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function registerUsedTraits(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  entityId: string,\n  entityName: string,\n  traits: string[]\n): Promise<void> {\n  if (traits.length === 0) return;\n\n  const id = usedTraitId(projectId, simulationRunId, entityKind, entityId);\n\n  const record: UsedTraitRecord = {\n    id,\n    projectId,\n    simulationRunId,\n    entityKind,\n    entityId,\n    entityName,\n    traits,\n    registeredAt: Date.now(),\n  };\n\n  await db.usedTraits.put(record);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "entityName", "type": "string", "optional": false}, {"name": "traits", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getUsedTraitsForRun", "name": "getUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string\n): Promise<UsedTraitRecord[]> {\n  if (!projectId || !simulationRunId || !entityKind) return [];\n\n  // Filter in memory \u2014 Dexie compound index not declared, use simple index\n  const records = await db.usedTraits.where(\"simulationRunId\").equals(simulationRunId).toArray();\n\n  return records.filter((r) => r.projectId === projectId && r.entityKind === entityKind);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<UsedTraitRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getHistoricalTraits", "name": "getHistoricalTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getHistoricalTraits(\n  projectId: string,\n  entityKind: string\n): Promise<string[]> {\n  if (!projectId || !entityKind) return [];\n\n  const records = await db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  return records.flatMap((r) => r.traits);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::countUsedTraits", "name": "countUsedTraits", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function countUsedTraits(projectId: string, entityKind: string): Promise<number> {\n  if (!projectId || !entityKind) return 0;\n\n  return db.usedTraits\n    .where(\"entityKind\")\n    .equals(entityKind)\n    .filter((r) => r.projectId === projectId)\n    .count();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::getTraitGuidance", "name": "getTraitGuidance", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function getTraitGuidance(\n  projectId: string,\n  simulationRunId: string,\n  entityKind: string,\n  subtype?: string,\n  eraId?: string\n): Promise<TraitGuidance> {\n  const palette = await getPalette(projectId, entityKind);\n  const allItems = palette?.items || [];\n\n  const categoryUsage: Record<string, number> = {};\n  for (const item of allItems) {\n    categoryUsage[item.category] = item.timesUsed;\n  }\n\n  if (!subtype) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  const subtypePool: PaletteItem[] = [];\n  const eraPool: PaletteItem[] = [];\n\n  for (const item of allItems) {\n    if (item.era) {\n      if (eraId && item.era.toLowerCase() === eraId.toLowerCase()) {\n        eraPool.push(item);\n      }\n    } else {\n      if (categoryMatchesSubtype(item, subtype)) {\n        subtypePool.push(item);\n      }\n    }\n  }\n\n  const numSubtypeCategories = Math.min(2, subtypePool.length);\n  const subtypeAssigned = selectCategoriesWeighted(subtypePool, numSubtypeCategories);\n  const eraAssigned = selectCategoriesWeighted(eraPool, 1);\n  const assigned = [...subtypeAssigned, ...eraAssigned];\n\n  if (assigned.length === 0) {\n    return {\n      assignedCategories: [],\n      categoryUsage,\n      selectionMethod: \"fallback\",\n    };\n  }\n\n  return {\n    assignedCategories: assigned,\n    categoryUsage,\n    selectionMethod: \"weighted-random\",\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entityKind", "type": "string", "optional": false}, {"name": "subtype", "type": "string", "optional": true}, {"name": "eraId", "type": "string", "optional": true}], "returnType": "Promise<TraitGuidance>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::deleteUsedTraitsForRun", "name": "deleteUsedTraitsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup / Export\n// ---------------------------------------------------------------------------\n\nexport async function deleteUsedTraitsForRun(\n  projectId: string,\n  simulationRunId: string\n): Promise<number> {\n  const records = await db.usedTraits\n    .where(\"simulationRunId\")\n    .equals(simulationRunId)\n    .filter((r) => r.projectId === projectId)\n    .toArray();\n\n  if (records.length === 0) return 0;\n  await db.usedTraits.bulkDelete(records.map((r) => r.id));\n  return records.length;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::exportPalettes", "name": "exportPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function exportPalettes(projectId: string): Promise<TraitPalette[]> {\n  return db.traitPalettes.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<TraitPalette[]>"}, {"id": "apps/illuminator/webui/src/lib/db/traitRepository.ts::importPalettes", "name": "importPalettes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/traitRepository.ts", "sourceCode": "export async function importPalettes(palettes: TraitPalette[]): Promise<void> {\n  await db.traitPalettes.bulkPut(palettes);\n}", "parameters": [{"name": "palettes", "type": "TraitPalette[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::createScaffold", "name": "createScaffold", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Scaffold\n// =============================================================================\n\nexport function createScaffold(projectId: string, simulationRunId: string): ContentTreeState {\n  return {\n    projectId,\n    simulationRunId,\n    nodes: [\n      {\n        id: generateId(),\n        name: \"Front Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Title Page\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Copyright\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Table of Contents\", type: \"folder\", children: [] },\n        ],\n      },\n      {\n        id: generateId(),\n        name: \"Body\",\n        type: \"folder\",\n        children: [],\n      },\n      {\n        id: generateId(),\n        name: \"Back Matter\",\n        type: \"folder\",\n        children: [\n          { id: generateId(), name: \"Appendix\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Glossary\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Index\", type: \"folder\", children: [] },\n          { id: generateId(), name: \"Colophon\", type: \"folder\", children: [] },\n        ],\n      },\n    ],\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::findNode", "name": "findNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function findNode(state: ContentTreeState, nodeId: string): ContentTreeNode | null {\n  return findInNodes(state.nodes, nodeId);\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeNode | null"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addFolder", "name": "addFolder", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Mutations\n// =============================================================================\n\nexport function addFolder(\n  state: ContentTreeState,\n  parentId: string,\n  name: string\n): ContentTreeState {\n  const newFolder: ContentTreeNode = {\n    id: generateId(),\n    name,\n    type: \"folder\",\n    children: [],\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newFolder, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::renameNode", "name": "renameNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function renameNode(\n  state: ContentTreeState,\n  nodeId: string,\n  name: string\n): ContentTreeState {\n  return {\n    ...state,\n    nodes: mapNodes(state.nodes, (node) => (node.id === nodeId ? { ...node, name } : { ...node })),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::deleteNode", "name": "deleteNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function deleteNode(state: ContentTreeState, nodeId: string): ContentTreeState {\n  return {\n    ...state,\n    nodes: removeNode(state.nodes, nodeId),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::moveNode", "name": "moveNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function moveNode(\n  state: ContentTreeState,\n  nodeId: string,\n  targetParentId: string,\n  index: number\n): ContentTreeState {\n  const node = findInNodes(state.nodes, nodeId);\n  if (!node) return state;\n\n  const withRemoved = removeNode(state.nodes, nodeId);\n  const withInserted = insertIntoParent(withRemoved, targetParentId, { ...node }, index);\n\n  return {\n    ...state,\n    nodes: withInserted,\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "targetParentId", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addContentItem", "name": "addContentItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function addContentItem(\n  state: ContentTreeState,\n  parentId: string,\n  item: { type: ContentNodeType; contentId: string; name: string }\n): ContentTreeState {\n  const newNode: ContentTreeNode = {\n    id: generateId(),\n    name: item.name,\n    type: item.type,\n    contentId: item.contentId,\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newNode, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "item", "type": "{ type: ContentNodeType; contentId: string; name: string }", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::flattenForExport", "name": "flattenForExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function flattenForExport(state: ContentTreeState): FlattenedNode[] {\n  const result: FlattenedNode[] = [];\n\n  function walk(nodes: ContentTreeNode[], parentPath: string, depth: number) {\n    nodes.forEach((node, index) => {\n      const prefix = String(index + 1).padStart(2, \"0\");\n      const segment = `${prefix}-${slugify(node.name)}`;\n      const path = parentPath ? `${parentPath}/${segment}` : segment;\n      result.push({ path, node, depth, index });\n      if (node.children) {\n        walk(node.children, path, depth + 1);\n      }\n    });\n  }\n\n  walk(state.nodes, \"\", 0);\n  return result;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "FlattenedNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::getAllContentIds", "name": "getAllContentIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Content ID Lookup\n// =============================================================================\n\nexport function getAllContentIds(state: ContentTreeState): Set<string> {\n  const ids = new Set<string>();\n  function walk(nodes: ContentTreeNode[]) {\n    for (const node of nodes) {\n      if (node.contentId) ids.add(node.contentId);\n      if (node.children) walk(node.children);\n    }\n  }\n  walk(state.nodes);\n  return ids;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "Set<string>"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::toArboristData", "name": "toArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Convert tree data to react-arborist format.\n * react-arborist expects { id, name, children } with children as arrays.\n */\nexport function toArboristData(nodes: ContentTreeNode[]): ContentTreeNode[] {\n  return nodes.map((node) => ({\n    ...node,\n    children: node.type === \"folder\" ? toArboristData(node.children || []) : undefined,\n  }));\n}", "parameters": [{"name": "nodes", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::fromArboristData", "name": "fromArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Rebuild ContentTreeNode[] from react-arborist's output after a move/reorder.\n */\nexport function fromArboristData(data: ContentTreeNode[]): ContentTreeNode[] {\n  return data.map((node) => ({\n    ...node,\n    children: node.children ? fromArboristData(node.children) : undefined,\n  }));\n}", "parameters": [{"name": "data", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::autoPopulateBody", "name": "autoPopulateBody", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Auto-populate the tree with content in Chronicler's natural book order.\n *\n * Body: eras in chronological order, each containing its narrative + chronicles.\n * Back Matter \u2192 Encyclopedia: entities grouped by culture then kind,\n *   each culture preceded by its static page.\n * Back Matter: remaining non-culture static pages.\n */\nexport function autoPopulateBody(\n  state: ContentTreeState,\n  input: AutoPopulateInput\n): ContentTreeState {\n  const bodyIndex = state.nodes.findIndex((n) => n.name === \"Body\" && n.type === \"folder\");\n  if (bodyIndex < 0) return state;\n\n  const backMatterIndex = state.nodes.findIndex(\n    (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n  );\n\n  // Collect existing content IDs to avoid duplicates\n  const existingIds = getAllContentIds(state);\n\n  // =========================================================================\n  // Body: Era folders with narratives + chronicles\n  // =========================================================================\n\n  const publishedChronicles = input.chronicles.filter(\n    (c) =>\n      (c.status === \"complete\" || c.status === \"assembly_ready\") && !existingIds.has(c.chronicleId)\n  );\n\n  const completedNarratives = input.eraNarratives.filter(\n    (n) =>\n      (n.status === \"complete\" || n.status === \"step_complete\") && !existingIds.has(n.narrativeId)\n  );\n\n  // Collect all era IDs from chronicles and narratives\n  const allEraIds = new Set<string>();\n  for (const c of publishedChronicles) {\n    if (c.focalEraId) allEraIds.add(c.focalEraId);\n  }\n  for (const n of completedNarratives) {\n    allEraIds.add(n.eraId);\n  }\n\n  const sortedEraIds = [...allEraIds].sort((a, b) => {\n    const orderA = input.eraOrder.get(a) ?? Infinity;\n    const orderB = input.eraOrder.get(b) ?? Infinity;\n    return orderA - orderB;\n  });\n\n  const bodyChildren: ContentTreeNode[] = [];\n\n  for (const eraId of sortedEraIds) {\n    const eraName =\n      completedNarratives.find((n) => n.eraId === eraId)?.eraName ||\n      publishedChronicles.find((c) => c.focalEraId === eraId)?.focalEraName ||\n      eraId;\n\n    const eraFolder: ContentTreeNode = {\n      id: generateId(),\n      name: eraName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Era narrative at top of folder (pick most recent if multiple)\n    const narrative = completedNarratives\n      .filter((n) => n.eraId === eraId)\n      .sort((a, b) => (b as any).updatedAt - (a as any).updatedAt)[0];\n    if (narrative) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: `${eraName} \u2014 Era Narrative`,\n        type: \"era_narrative\",\n        contentId: narrative.narrativeId,\n      });\n    }\n\n    // Chronicles sorted by eraYear then name\n    const eraChronicles = publishedChronicles\n      .filter((c) => c.focalEraId === eraId)\n      .sort((a, b) => {\n        const yearA = a.eraYear ?? Infinity;\n        const yearB = b.eraYear ?? Infinity;\n        if (yearA !== yearB) return yearA - yearB;\n        return a.title.localeCompare(b.title);\n      });\n\n    for (const c of eraChronicles) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n      });\n    }\n\n    if (eraFolder.children.length > 0) {\n      bodyChildren.push(eraFolder);\n    }\n  }\n\n  // Unassigned chronicles (no focalEra)\n  const unassigned = publishedChronicles\n    .filter((c) => !c.focalEraId)\n    .sort((a, b) => a.title.localeCompare(b.title));\n  if (unassigned.length > 0) {\n    const unassignedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Unassigned Era\",\n      type: \"folder\",\n      children: unassigned.map((c) => ({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\" as const,\n        contentId: c.chronicleId,\n      })),\n    };\n    bodyChildren.push(unassignedFolder);\n  }\n\n  // =========================================================================\n  // Back Matter \u2192 Encyclopedia: entities by culture then kind\n  // =========================================================================\n\n  const eligibleEntities = input.entities.filter(\n    (e) => e.description && e.kind !== \"era\" && !existingIds.has(e.id)\n  );\n\n  // Build culture \u2192 entity grouping\n  const byCulture = new Map<string, typeof eligibleEntities>();\n  const uncultured: typeof eligibleEntities = [];\n  for (const e of eligibleEntities) {\n    if (e.culture) {\n      const list = byCulture.get(e.culture) || [];\n      list.push(e);\n      byCulture.set(e.culture, list);\n    } else {\n      uncultured.push(e);\n    }\n  }\n\n  // Build culture name \u2192 static page mapping\n  const publishedPages = input.staticPages.filter(\n    (p) => p.status === \"published\" && !existingIds.has(p.pageId)\n  );\n  const culturePageMap = new Map<string, (typeof publishedPages)[number]>();\n  const nonCulturePages: typeof publishedPages = [];\n  for (const p of publishedPages) {\n    const { namespace, baseName } = parseNamespace(p.title);\n    if (namespace === \"Cultures\") {\n      culturePageMap.set(baseName.toLowerCase(), p);\n    } else {\n      nonCulturePages.push(p);\n    }\n  }\n\n  const encyclopediaChildren: ContentTreeNode[] = [];\n  const usedPageIds = new Set<string>();\n\n  const sortedCultures = [...byCulture.keys()].sort((a, b) => a.localeCompare(b));\n  for (const cultureName of sortedCultures) {\n    const cultureFolder: ContentTreeNode = {\n      id: generateId(),\n      name: cultureName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Culture static page at top\n    const culturePage = culturePageMap.get(cultureName.toLowerCase());\n    if (culturePage) {\n      cultureFolder.children.push({\n        id: generateId(),\n        name: culturePage.title,\n        type: \"static_page\",\n        contentId: culturePage.pageId,\n      });\n      usedPageIds.add(culturePage.pageId);\n    }\n\n    // Group entities by kind\n    const cultureEntities = byCulture.get(cultureName);\n    const byKind = new Map<string, typeof cultureEntities>();\n    for (const e of cultureEntities) {\n      const kind = e.kind;\n      const list = byKind.get(kind) || [];\n      list.push(e);\n      byKind.set(kind, list);\n    }\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      cultureFolder.children.push(kindFolder);\n    }\n\n    if (cultureFolder.children.length > 0) {\n      encyclopediaChildren.push(cultureFolder);\n    }\n  }\n\n  // Uncultured entities\n  if (uncultured.length > 0) {\n    const byKind = new Map<string, typeof uncultured>();\n    for (const e of uncultured) {\n      const list = byKind.get(e.kind) || [];\n      list.push(e);\n      byKind.set(e.kind, list);\n    }\n\n    const unculturedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Uncategorized\",\n      type: \"folder\",\n      children: [],\n    };\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      unculturedFolder.children.push(kindFolder);\n    }\n\n    if (unculturedFolder.children.length > 0) {\n      encyclopediaChildren.push(unculturedFolder);\n    }\n  }\n\n  // =========================================================================\n  // Assemble final tree\n  // =========================================================================\n\n  const newNodes = [...state.nodes];\n\n  // Replace Body children\n  newNodes[bodyIndex] = {\n    ...newNodes[bodyIndex],\n    children: bodyChildren,\n  };\n\n  // Add Encyclopedia + remaining static pages to Back Matter\n  if (backMatterIndex >= 0) {\n    const existingBackMatterChildren = [...(newNodes[backMatterIndex].children || [])];\n\n    // Insert Encyclopedia folder before existing back matter items\n    if (encyclopediaChildren.length > 0) {\n      const encyclopediaFolder: ContentTreeNode = {\n        id: generateId(),\n        name: \"Encyclopedia\",\n        type: \"folder\",\n        children: encyclopediaChildren,\n      };\n      existingBackMatterChildren.unshift(encyclopediaFolder);\n    }\n\n    // Add remaining non-culture static pages\n    const remainingPages = nonCulturePages.filter((p) => !usedPageIds.has(p.pageId));\n    for (const p of remainingPages) {\n      existingBackMatterChildren.push({\n        id: generateId(),\n        name: p.title,\n        type: \"static_page\",\n        contentId: p.pageId,\n      });\n    }\n\n    newNodes[backMatterIndex] = {\n      ...newNodes[backMatterIndex],\n      children: existingBackMatterChildren,\n    };\n  }\n\n  return {\n    ...state,\n    nodes: newNodes,\n    updatedAt: Date.now(),\n// ... (truncated)", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "input", "type": "AutoPopulateInput", "optional": false}], "returnType": "ContentTreeState"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::escapeXml", "name": "escapeXml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// XML Helpers\n// =============================================================================\n\nexport function escapeXml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::renderParagraphs", "name": "renderParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "export function renderParagraphs(paras: IcmlParagraph[]): string {\n  if (paras.length === 0) return \"\";\n  return paras.map(renderParagraph).join(\"\\n    <Br/>\\n\");\n}", "parameters": [{"name": "paras", "type": "IcmlParagraph[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::parseInlineRuns", "name": "parseInlineRuns", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Inline Markdown Parsing \u2192 IcmlRun[]\n// =============================================================================\n\n/**\n * Parse inline markdown formatting into character style runs.\n * Handles: ***bold italic***, **bold**, *italic*, `code`\n */\nexport function parseInlineRuns(text: string): IcmlRun[] {\n  const runs: IcmlRun[] = [];\n  // Order matters: bold-italic before bold before italic\n  const pattern = /(\\*\\*\\*(.+?)\\*\\*\\*|\\*\\*(.+?)\\*\\*|\\*(.+?)\\*|`(.+?)`)/g;\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(text)) !== null) {\n    // Text before this match\n    if (match.index > lastIndex) {\n      runs.push({ charStyle: \"\", text: text.slice(lastIndex, match.index) });\n    }\n\n    if (match[2]) {\n      // ***bold italic***\n      runs.push({ charStyle: CS_BOLD_ITALIC, text: match[2] });\n    } else if (match[3]) {\n      // **bold**\n      runs.push({ charStyle: CS_BOLD, text: match[3] });\n    } else if (match[4]) {\n      // *italic*\n      runs.push({ charStyle: CS_ITALIC, text: match[4] });\n    } else if (match[5]) {\n      // `code`\n      runs.push({ charStyle: CS_CODE, text: match[5] });\n    }\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Remaining text\n  if (lastIndex < text.length) {\n    runs.push({ charStyle: \"\", text: text.slice(lastIndex) });\n  }\n\n  // If no runs were generated, add the full text as a default run\n  if (runs.length === 0 && text.length > 0) {\n    runs.push({ charStyle: \"\", text });\n  }\n\n  // Split runs containing \u263d (U+263D) so the crescent gets the Symbol char style\n  // which maps to Segoe UI Symbol \u2014 Junicode doesn't have this glyph.\n  return splitSymbolRuns(runs);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "IcmlRun[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::plainPara", "name": "plainPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a simple paragraph with a single default-style run */\nexport function plainPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: [{ charStyle: \"\", text }] };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::styledPara", "name": "styledPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a paragraph with inline markdown parsed into runs */\nexport function styledPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: parseInlineRuns(text) };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::markdownToIcmlParagraphs", "name": "markdownToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Convert markdown text to ICML paragraphs. Handles:\n * - Headings (# ## ###)\n * - Blockquotes (>)\n * - Horizontal rules (--- or ***)\n * - Image markers (<!-- IMAGE: ... -->)\n * - Inline formatting (**bold**, *italic*, ***both***, `code`)\n */\nexport function markdownToIcmlParagraphs(markdown: string): IcmlParagraph[] {\n  if (!markdown || !markdown.trim()) return [];\n\n  const paras: IcmlParagraph[] = [];\n  const lines = markdown.split(\"\\n\");\n  let blockLines: string[] = [];\n  let afterHeading = false;\n\n  function flushBlock() {\n    const text = blockLines.join(\" \").trim();\n    if (text) {\n      const style = afterHeading ? PS_BODY_FIRST : PS_BODY;\n      paras.push(styledPara(style, text));\n      afterHeading = false;\n    }\n    blockLines = [];\n  }\n\n  for (const rawLine of lines) {\n    const line = rawLine;\n    const trimmed = line.trim();\n\n    // Empty line = flush paragraph\n    if (!trimmed) {\n      flushBlock();\n      continue;\n    }\n\n    // Image marker\n    const img = parseImageMarker(trimmed);\n    if (img) {\n      flushBlock();\n      paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: ${img.path}]`));\n      if (img.caption) {\n        paras.push(plainPara(PS_CAPTION, img.caption));\n      }\n      afterHeading = false;\n      continue;\n    }\n\n    // Heading\n    const headingMatch = /^(#{1,3})\\s+(.+)$/.exec(trimmed); // eslint-disable-line sonarjs/slow-regex -- single markdown line\n    if (headingMatch) {\n      flushBlock();\n      const level = headingMatch[1].length;\n      let headingStyle: string;\n      if (level === 1) headingStyle = PS_HEADING1;\n      else if (level === 2) headingStyle = PS_HEADING2;\n      else headingStyle = PS_HEADING3;\n      paras.push(styledPara(headingStyle, headingMatch[2]));\n      afterHeading = true;\n      continue;\n    }\n\n    // Horizontal rule \u2192 separator\n    if (/^[-*_]{3,}\\s*$/.test(trimmed)) {\n      flushBlock();\n      paras.push(plainPara(PS_SEPARATOR, \"* * *\"));\n      afterHeading = false;\n      continue;\n    }\n\n    // Blockquote\n    if (trimmed.startsWith(\">\")) {\n      flushBlock();\n      const quoteText = trimmed.replace(/^>\\s*/, \"\");\n      paras.push(styledPara(PS_BLOCKQUOTE, quoteText));\n      afterHeading = false;\n      continue;\n    }\n\n    // Regular text \u2014 accumulate into block\n    blockLines.push(trimmed);\n  }\n\n  flushBlock();\n  return paras;\n}", "parameters": [{"name": "markdown", "type": "string", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::getImageExt", "name": "getImageExt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Content Formatters\n// =============================================================================\n\nexport function getImageExt(image?: ImageMetadataRecord): string {\n  if (!image?.mimeType) return \"\";\n  if (image.mimeType.includes(\"png\")) return \".png\";\n  if (image.mimeType.includes(\"jpeg\") || image.mimeType.includes(\"jpg\")) return \".jpg\";\n  if (image.mimeType.includes(\"webp\")) return \".webp\";\n  return \"\";\n}", "parameters": [{"name": "image", "type": "ImageMetadataRecord", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::annotateContentWithImages", "name": "annotateContentWithImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Insert image markers into content text and return annotated markdown.\n * Mirrors the logic from markdownExport.ts.\n */\nexport function annotateContentWithImages(\n  content: string,\n  imageRefs?: { refs?: any[] },\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): string {\n  if (!imageRefs?.refs || !content) return content;\n\n  let annotated = content;\n\n  // Prompt-request images\n  const promptRefs = imageRefs.refs.filter(\n    (r: any) => r.type === \"prompt_request\" && r.status === \"complete\" && r.generatedImageId\n  );\n  const promptInsertions = promptRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of promptInsertions) {\n    const imgId = ref.generatedImageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Entity-ref images\n  const entityRefs = imageRefs.refs.filter((r: any) => r.type === \"entity_ref\");\n  const entityInsertions = entityRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of entityInsertions) {\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: entity-portrait-${ref.entityId} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Chronicle-ref images (for era narratives)\n  const chronicleRefs = imageRefs.refs.filter((r: any) => r.type === \"chronicle_ref\");\n  const chronicleInsertions = chronicleRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of chronicleInsertions) {\n    const imgId = ref.imageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  return annotated;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "imageRefs", "type": "{ refs?: any[] }", "optional": true}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::entityToIcmlParagraphs", "name": "entityToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an entity to ICML paragraphs */\nexport function entityToIcmlParagraphs(\n  entity: PersistedEntity,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, entity.name));\n\n  // Subtitle: kind / subtype\n  const subtitleParts = [entity.kind];\n  if (entity.subtype) subtitleParts.push(entity.subtype);\n  if (entity.culture) subtitleParts.push(entity.culture);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Metadata\n  paras.push(plainPara(PS_METADATA, `Prominence: ${entity.prominence} | Status: ${entity.status}`));\n\n  const aliases = entity.enrichment?.text?.aliases;\n  if (aliases?.length) {\n    paras.push(plainPara(PS_METADATA, `Also known as: ${aliases.join(\", \")}`));\n  }\n\n  if (entity.tags && Object.keys(entity.tags).length > 0) {\n    const tagStr = Object.entries(entity.tags)\n      .map(([k, v]) => `${k}: ${v}`)\n      .join(\" | \");\n    paras.push(plainPara(PS_METADATA, tagStr));\n  }\n\n  // Entity image\n  const imageId = entity.enrichment?.image?.imageId;\n  if (imageId) {\n    registerFn(imageId, \"entity\", entity.id, entity.name);\n    const ext = getImageExt(imageMap.get(imageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${imageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, `${entity.name} portrait`));\n  }\n\n  // Summary\n  if (entity.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, entity.summary));\n  }\n\n  // Description body\n  if (entity.description) {\n    const bodyParas = markdownToIcmlParagraphs(entity.description);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = entity.enrichment?.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::chronicleToIcmlParagraphs", "name": "chronicleToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a chronicle to ICML paragraphs */\nexport function chronicleToIcmlParagraphs(\n  chronicle: ChronicleRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const content = chronicle.finalContent || chronicle.assembledContent || \"\";\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, chronicle.title || \"Untitled Chronicle\"));\n\n  // Subtitle\n  const subtitleParts = [chronicle.format, chronicle.focusType];\n  if (chronicle.narrativeStyle?.name) subtitleParts.push(chronicle.narrativeStyle.name);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Summary\n  if (chronicle.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, chronicle.summary));\n  }\n\n  // Cover image\n  const coverImageId = chronicle.coverImage?.generatedImageId;\n  if (coverImageId && chronicle.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\", undefined, undefined, chronicle.chronicleId);\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, chronicle.title || \"Cover\"));\n  }\n\n  // Cast\n  if (chronicle.roleAssignments?.length) {\n    paras.push(plainPara(PS_HEADING2, \"Cast\"));\n    for (const ra of chronicle.roleAssignments) {\n      const emphasis = ra.isPrimary ? \"Primary\" : \"Supporting\";\n      paras.push({\n        paraStyle: PS_CAST_ENTRY,\n        runs: [\n          { charStyle: CS_BOLD, text: ra.role },\n          { charStyle: \"\", text: ` \\u2014 ${ra.entityName} (${ra.entityKind}, ${emphasis})` },\n        ],\n      });\n    }\n  }\n\n  // Narrative content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      chronicle.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = chronicle.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::eraNarrativeToIcmlParagraphs", "name": "eraNarrativeToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an era narrative to ICML paragraphs */\nexport function eraNarrativeToIcmlParagraphs(\n  narrative: EraNarrativeRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const { content } = resolveActiveContent(narrative);\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, narrative.eraName));\n\n  // Subtitle\n  paras.push(plainPara(PS_ITEM_SUBTITLE, `${narrative.tone} \\u2022 era narrative`));\n\n  // Thesis\n  if (narrative.threadSynthesis?.thesis) {\n    paras.push(styledPara(PS_BLOCKQUOTE, narrative.threadSynthesis.thesis));\n  }\n\n  // Threads\n  if (narrative.threadSynthesis?.threads?.length) {\n    const threadNames = narrative.threadSynthesis.threads.map((t: any) => t.name).join(\", \");\n    paras.push(plainPara(PS_METADATA, `Threads: ${threadNames}`));\n  }\n\n  // Cover image\n  const coverImageId = narrative.coverImage?.generatedImageId;\n  if (coverImageId && narrative.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\");\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, narrative.eraName));\n  }\n\n  // Content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      narrative.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "narrative", "type": "EraNarrativeRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::staticPageToIcmlParagraphs", "name": "staticPageToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a static page to ICML paragraphs */\nexport function staticPageToIcmlParagraphs(page: StaticPage): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, page.title));\n\n  // Content (already markdown with headings, etc.)\n  if (page.content) {\n    const bodyParas = markdownToIcmlParagraphs(page.content);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "page", "type": "StaticPage", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::createImageRegistrar", "name": "createImageRegistrar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Image Registration (mirrors markdownExport.ts pattern)\n// =============================================================================\n\nexport function createImageRegistrar(\n  referencedImages: Map<string, ExportImageEntry>,\n  imageMap: Map<string, ImageMetadataRecord>\n) {\n  return function registerImage(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ): void {\n    if (referencedImages.has(imgId)) return;\n    const img = imageMap.get(imgId);\n    const ext = getImageExt(img);\n    referencedImages.set(imgId, {\n      imageId: imgId,\n      filename: `${imgId}${ext}`,\n      width: img?.width,\n      height: img?.height,\n      aspect: img?.aspect,\n      imageType: type,\n      entityId: entityId || img?.entityId,\n      entityName: entityName || img?.entityName,\n      chronicleId: chronicleId || img?.chronicleId,\n      mimeType: img?.mimeType,\n    });\n  };\n}", "parameters": [{"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}], "returnType": "(imgId: string, type: any, entityId?: string, entityName?: string, chronicleId?: string) => void"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookParagraphs", "name": "buildBookParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Walk the content tree and produce an array of styled paragraphs.\n * Used by both ICML and IDML generators.\n */\nexport function buildBookParagraphs(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): IcmlParagraph[] {\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allParagraphs: IcmlParagraph[] = [];\n  const flattened = flattenForExport(treeState);\n  let prevWasContent = false;\n\n  for (const { node, depth } of flattened) {\n    if (node.type === \"folder\") {\n      if (prevWasContent) {\n        allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n        prevWasContent = false;\n      }\n\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      allParagraphs.push(plainPara(headingStyle, node.name));\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    if (prevWasContent) {\n      allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n    }\n\n    let contentParas: IcmlParagraph[] = [];\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n      }\n    }\n\n    if (contentParas.length > 0) {\n      allParagraphs.push(...contentParas);\n      prevWasContent = true;\n    }\n  }\n\n  return allParagraphs;\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "IcmlParagraph[]"}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookIcml", "name": "buildBookIcml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Build a complete ICML document from the content tree.\n * Wraps the shared paragraph output in ICML document structure.\n */\nexport function buildBookIcml(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): string {\n  const allParagraphs = buildBookParagraphs(treeState, contentMaps, imageMap, referencedImages);\n\n  const parts: string[] = [];\n  parts.push(ICML_HEADER);\n  parts.push(buildStyleDefinitions());\n  parts.push(buildStoryOpen());\n  parts.push(renderParagraphs(allParagraphs));\n  parts.push(ICML_FOOTER);\n  return parts.join(\"\\n\");\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts::buildIdmlPackage", "name": "buildIdmlPackage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build a complete IDML package as a Blob.\n *\n * The .idml file is a ZIP containing all the XML files that define\n * an InDesign document. Each content entry gets its own story and spread(s).\n */\nexport async function buildIdmlPackage(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  layoutOptions?: IdmlLayoutOptions\n): Promise<Blob> {\n  const layout = resolveLayout(layoutOptions);\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allStories: StoryFile[] = [];\n  const allSpreads: SpreadFile[] = [];\n  let currentPageNum = 1;\n  let entryCounter = 0;\n\n  const flattened = flattenForExport(treeState);\n\n  for (const { node, depth } of flattened) {\n    const entryId = `e${entryCounter++}`;\n\n    if (node.type === \"folder\") {\n      // Folder heading: simple story + 2-page spread\n      const storyId = `story_${entryId}`;\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      const paras = [plainPara(headingStyle, node.name)];\n\n      const storyXml = buildEntryStoryXml(storyId, paras, []);\n      allStories.push({\n        filename: `Stories/Story_${storyId}.xml`,\n        xml: storyXml,\n        storyId,\n      });\n\n      const masterId = MASTERS.D.spreadId; // folders use D-Encyclopedia master\n      const { spreads, pagesUsed } = buildEntrySpreads(\n        entryId,\n        storyId,\n        masterId,\n        2,\n        currentPageNum,\n        [],\n        [],\n        layout\n      );\n      allSpreads.push(...spreads);\n      currentPageNum += pagesUsed;\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    // Content entry: build paragraphs, classify notes, collect images\n    let contentParas: IcmlParagraph[] = [];\n    let footnotes: FootnoteInsert[] = [];\n    let callouts: { anchorPhrase: string; noteText: string; noteType: string }[] = [];\n    let images: ImagePlacement[] = [];\n    const masterKey = selectMaster(node.type, contentMaps, node.contentId);\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(entity.enrichment?.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(entity, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(chronicle.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(chronicle, imageMap);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n        // Era narratives don't have historian notes\n        images = collectEntryImages(narrative, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n        // Static pages have no images or notes\n      }\n    }\n\n    if (contentParas.length === 0) continue;\n\n    // Strip historian note paragraphs from the main content \u2014 in IDML,\n    // popout notes become inline footnotes and full notes become callout stories\n    if (footnotes.length > 0 || callouts.length > 0) {\n      contentParas = stripHistorianNotes(contentParas);\n    }\n\n    // Build main story (with inline footnotes)\n    const storyId = `story_${entryId}`;\n    const storyXml = buildEntryStoryXml(storyId, contentParas, footnotes);\n    allStories.push({\n      filename: `Stories/Story_${storyId}.xml`,\n      xml: storyXml,\n      storyId,\n    });\n\n    // Build callout stories\n    const calloutStoryRefs: { storyId: string }[] = [];\n    for (let ci = 0; ci < callouts.length; ci++) {\n      const callout = callouts[ci];\n      const calloutStoryId = `story_${entryId}_co${ci}`;\n      const calloutXml = buildCalloutStoryXml(\n        calloutStoryId,\n        callout.noteType,\n        callout.noteText,\n        callout.anchorPhrase\n      );\n      allStories.push({\n        filename: `Stories/Story_${calloutStoryId}.xml`,\n        xml: calloutXml,\n        storyId: calloutStoryId,\n      });\n      calloutStoryRefs.push({ storyId: calloutStoryId });\n    }\n\n    // Estimate pages and build spreads\n    const pageCount = estimateEntryPages(contentParas, images.length, layout.linesPerPage);\n    const masterId = MASTERS[masterKey].spreadId;\n\n    const { spreads, pagesUsed } = buildEntrySpreads(\n      entryId,\n      storyId,\n      masterId,\n      pageCount,\n      currentPageNum,\n      images,\n      calloutStoryRefs,\n      layout\n    );\n    allSpreads.push(...spreads);\n    currentPageNum += pagesUsed;\n  }\n\n  // Build master spread files\n  const masterKeys: MasterKey[] = [\"A\", \"B\", \"C\", \"D\"];\n  const masterSpreadFiles: { spreadId: string; filename: string }[] = [];\n  const masterStoryIds: string[] = [];\n\n  const zip = new JSZip();\n\n  // mimetype MUST be the first entry (uncompressed)\n  zip.file(\"mimetype\", MIMETYPE);\n\n  for (const key of masterKeys) {\n    const master = MASTERS[key];\n    const filename = `MasterSpreads/MasterSpread_${master.spreadId}.xml`;\n    zip.file(filename, buildMasterSpreadXml(master, layout));\n    masterSpreadFiles.push({ spreadId: master.spreadId, filename });\n\n    // Master story\n    const masterStoryFilename = `Stories/Story_${master.storyId}.xml`;\n    zip.file(masterStoryFilename, buildMasterStoryXml(master.storyId));\n    masterStoryIds.push(master.storyId);\n  }\n\n  // Structural files\n  zip.file(\"META-INF/container.xml\", buildContainerXml());\n\n  // Resources\n  zip.file(\"Resources/Graphic.xml\", buildGraphicXml());\n  zip.file(\"Resources/Fonts.xml\", buildFontsXml(layout.fontFamily));\n  zip.file(\"Resources/Styles.xml\", buildStylesXml(layout));\n  zip.file(\"Resources/Preferences.xml\", buildPreferencesXml(layout));\n\n  // Entry spreads\n  for (const spread of allSpreads) {\n    zip.file(spread.filename, spread.xml);\n  }\n\n  // Entry stories\n  for (const story of allStories) {\n    zip.file(story.filename, story.xml);\n  }\n\n  // XML structure\n  zip.file(\"XML/BackingStory.xml\", buildBackingStoryXml());\n  zip.file(\"XML/Tags.xml\", buildTagsXml());\n\n  // Designmap (must reference everything)\n  const totalPages = currentPageNum - 1;\n  zip.file(\n    \"designmap.xml\",\n    buildDesignmap(masterSpreadFiles, allSpreads, allStories, masterStoryIds, totalPages)\n  );\n\n  // Generate with STORE compression (standard for IDML)\n  return zip.generateAsync({ type: \"blob\", compression: \"STORE\" });\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "layoutOptions", "type": "IdmlLayoutOptions", "optional": true}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildExportZip", "name": "buildExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildExportZip(options: ExportOptions): Promise<Blob> {\n  const {\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  } = options;\n\n  const zip = new JSZip();\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n\n  // Collect all referenced image IDs for the manifest\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Flatten tree and generate files\n  const flattened = flattenForExport(treeState);\n\n  for (const { path, node } of flattened) {\n    if (node.type === \"folder\") {\n      // Create empty directory entry\n      zip.folder(path);\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    let markdown: string | null = null;\n\n    if (node.type === \"entity\") {\n      const entity = entityMap.get(node.contentId);\n      if (entity) {\n        markdown = formatEntityMarkdown(entity, referencedImages, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = chronicleMap.get(node.contentId);\n      if (chronicle) {\n        markdown = formatChronicleMarkdown(chronicle, referencedImages, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = pageMap.get(node.contentId);\n      if (page) {\n        markdown = formatStaticPageMarkdown(page, entities);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = narrativeMap.get(node.contentId);\n      if (narrative) {\n        markdown = formatEraNarrativeMarkdown(narrative, referencedImages, imageMap);\n      }\n    }\n\n    if (markdown) {\n      const filename = slugify(node.name) + \".md\";\n      zip.file(`${path}/${filename}`, markdown);\n    }\n  }\n\n  // Build manifest\n  const manifest = buildManifest(\n    treeState,\n    entities,\n    chronicles,\n    staticPages,\n    eraNarratives,\n    images,\n    referencedImages,\n    projectId,\n    simulationRunId,\n    s3Config\n  );\n  zip.file(\"manifest.json\", JSON.stringify(manifest, null, 2));\n\n  // S3 download script\n  if (s3Config) {\n    zip.file(\n      \"s3-config.json\",\n      JSON.stringify(\n        {\n          bucket: s3Config.bucket,\n          basePrefix: s3Config.basePrefix,\n          rawPrefix: s3Config.rawPrefix,\n          projectId,\n          region: s3Config.region,\n        },\n        null,\n        2\n      )\n    );\n\n    zip.file(\"download-images.sh\", buildDownloadScript());\n  }\n\n  return zip.generateAsync({ type: \"blob\" });\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildInDesignExportZip", "name": "buildInDesignExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildInDesignExportZip(options: ExportOptions): Promise<Blob> {\n  const { treeState, entities, chronicles, images, staticPages, eraNarratives, idmlLayout } =\n    options;\n\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Build a complete IDML package \u2014 opens directly in InDesign.\n  // IDML is already a ZIP internally, so we return the blob directly\n  // rather than wrapping it in another ZIP.\n  return buildIdmlPackage(\n    treeState,\n    { entityMap, chronicleMap, pageMap, narrativeMap },\n    imageMap,\n    referencedImages,\n    idmlLayout\n  );\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>"}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildIdmlImageScript", "name": "buildIdmlImageScript", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "// =============================================================================\n// IDML Image Download Script\n// =============================================================================\n\n/**\n * Generates a self-contained bash script that downloads all images referenced\n * by the IDML export from S3. The script embeds the S3 config and image list\n * directly \u2014 no manifest.json or s3-config.json needed.\n *\n * Place the script next to the .idml file and run it. It creates images/\n * alongside the IDML so InDesign resolves the `file:images/...` links.\n */\nexport function buildIdmlImageScript(options: ExportOptions): string {\n  const { entities, chronicles, eraNarratives, images, projectId, s3Config } = options;\n  if (!s3Config) return \"\";\n\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const seen = new Set<string>();\n  const imageEntries: { id: string; filename: string }[] = [];\n\n  // Match the extension logic used by idmlExport's collectEntryImages\n  // (defaults to .png when mimeType is unknown)\n  function idmlExt(img?: ImageMetadataRecord): string {\n    if (!img?.mimeType) return \".png\";\n    if (img.mimeType.includes(\"png\")) return \".png\";\n    if (img.mimeType.includes(\"jpeg\") || img.mimeType.includes(\"jpg\")) return \".jpg\";\n    if (img.mimeType.includes(\"webp\")) return \".webp\";\n    return \".png\";\n  }\n\n  function addImage(imageId: string) {\n    if (!imageId || seen.has(imageId)) return;\n    // Skip image IDs not present in metadata \u2014 they are likely malformed\n    // composite keys (e.g. chronicleId:imageRefId) that won't exist in S3\n    if (!imageMap.has(imageId)) return;\n    seen.add(imageId);\n    const ext = idmlExt(imageMap.get(imageId));\n    imageEntries.push({ id: imageId, filename: `${imageId}${ext}` });\n  }\n\n  // Entity portraits\n  for (const entity of entities) {\n    const imageId = entity.enrichment?.image?.imageId;\n    if (imageId) addImage(imageId);\n  }\n\n  // Chronicle covers and scene images\n  for (const chronicle of chronicles) {\n    if (chronicle.coverImage?.generatedImageId && chronicle.coverImage.status === \"complete\") {\n      addImage(chronicle.coverImage.generatedImageId);\n    }\n    if (chronicle.imageRefs?.refs) {\n      for (const ref of chronicle.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n      }\n    }\n  }\n\n  // Era narrative covers and inline refs\n  for (const narrative of eraNarratives) {\n    if (narrative.coverImage?.generatedImageId && narrative.coverImage?.status === \"complete\") {\n      addImage(narrative.coverImage.generatedImageId);\n    }\n    if (narrative.imageRefs?.refs) {\n      for (const ref of narrative.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n        if (ref.type === \"chronicle_ref\" && ref.imageId) {\n          addImage(ref.imageId);\n        }\n      }\n    }\n  }\n\n  if (imageEntries.length === 0) {\n    return `#!/usr/bin/env bash\n# No images referenced in this export.\necho \"No images to download.\"\n`;\n  }\n\n  const downloads = imageEntries.map((e) => `download_image \"${e.id}\" \"${e.filename}\"`).join(\"\\n\");\n\n  return `#!/usr/bin/env bash\n# Download images from S3 for InDesign IDML import\n# Generated by Illuminator Pre-Print Export\n#\n# Place this script next to your .idml file, then run it.\n# It creates an images/ directory alongside the IDML file\n# so InDesign resolves the linked image paths automatically.\n\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"\\${BASH_SOURCE[0]}\")\" && pwd)\"\nIMAGE_DIR=\"\\${SCRIPT_DIR}/images\"\n\n# --- Embedded S3 Configuration ---\nBUCKET=\"${s3Config.bucket}\"\nBASE_PREFIX=\"${s3Config.basePrefix}\"\nRAW_PREFIX=\"${s3Config.rawPrefix}\"\nPROJECT_ID=\"${projectId}\"\nREGION=\"${s3Config.region}\"\n\n# Build S3 key prefix, filtering out empty segments\nS3_PREFIX=$(echo \"\\${BASE_PREFIX}/\\${RAW_PREFIX}/\\${PROJECT_ID}\" | sed 's|/\\\\+|/|g; s|^/||; s|/$||')\n\n# --- Pre-flight checks ---\nif ! command -v aws &>/dev/null; then\n  echo \"ERROR: aws CLI is required but not installed.\"\n  echo \"  Install: https://aws.amazon.com/cli/\"\n  exit 1\nfi\n\nmkdir -p \"\\${IMAGE_DIR}\"\n\necho \"Downloading ${imageEntries.length} images from s3://\\${BUCKET}/\\${S3_PREFIX}/\"\necho \"Region: \\${REGION}\"\necho \"Target: \\${IMAGE_DIR}/\"\necho \"\"\n\nDOWNLOADED=0\nSKIPPED=0\nFAILED=0\n\ndownload_image() {\n  local IMAGE_ID=\"\\$1\"\n  local FILENAME=\"\\$2\"\n  local DEST=\"\\${IMAGE_DIR}/\\${FILENAME}\"\n\n  if [ -f \"\\${DEST}\" ]; then\n    SKIPPED=$((SKIPPED + 1))\n    return\n  fi\n\n  local S3_KEY=\"\\${S3_PREFIX}/\\${IMAGE_ID}\"\n  echo \"  GET  \\${FILENAME}\"\n  if aws s3 cp \"s3://\\${BUCKET}/\\${S3_KEY}\" \"\\${DEST}\" --region \"\\${REGION}\" --quiet 2>/dev/null; then\n    DOWNLOADED=$((DOWNLOADED + 1))\n  else\n    echo \"  FAIL \\${FILENAME}\"\n    FAILED=$((FAILED + 1))\n  fi\n}\n\n${downloads}\n\necho \"\"\necho \"Done. Downloaded: \\${DOWNLOADED}  Skipped: \\${SKIPPED}  Failed: \\${FAILED}\"\necho \"Images directory: \\${IMAGE_DIR}\"\n`;\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts::computePrePrintStats", "name": "computePrePrintStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts", "sourceCode": "export function computePrePrintStats(\n  entities: PersistedEntity[],\n  chronicles: ChronicleRecord[],\n  images: ImageMetadataRecord[],\n  staticPages: StaticPage[],\n  eraNarratives: EraNarrativeRecord[]\n): PrePrintStats {\n  // Filter to publishable content\n  const publishedChronicles = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n  const publishedPages = staticPages.filter((p) => p.status === \"published\");\n  const completedNarratives = eraNarratives.filter(\n    (n) => n.status === \"complete\" || n.status === \"step_complete\"\n  );\n\n  // =========================================================================\n  // Word & Character Counts\n  // =========================================================================\n\n  const chronicleBodyTexts = publishedChronicles.map(getPublishedContent);\n  const chronicleSummaryTexts = publishedChronicles.map((c) => c.summary || \"\");\n  const entityDescTexts = entities.map((e) => e.description || \"\");\n  const entitySummaryTexts = entities.map((e) => e.summary || \"\");\n  const captionTexts = collectCaptions(publishedChronicles);\n  const pageTexts = publishedPages.map((p) => p.content || \"\");\n\n  // Era narrative content from active version (with legacy fallback)\n  const narrativeTexts = completedNarratives.map((n) => {\n    const { content } = resolveActiveContent(n);\n    return content || \"\";\n  });\n\n  // Historian notes: collect from both entities and chronicles\n  const entityHistorianNotes: HistorianNote[] = [];\n  for (const e of entities) {\n    if (e.enrichment?.historianNotes?.length) {\n      entityHistorianNotes.push(...e.enrichment.historianNotes);\n    }\n  }\n  const chronicleHistorianNotes: HistorianNote[] = [];\n  for (const c of publishedChronicles) {\n    if (c.historianNotes?.length) {\n      chronicleHistorianNotes.push(...c.historianNotes);\n    }\n  }\n  const allHistorianNotes = [...entityHistorianNotes, ...chronicleHistorianNotes];\n\n  const sumWords = (texts: string[]) => texts.reduce((s, t) => s + countWords(t), 0);\n  const sumChars = (texts: string[]) => texts.reduce((s, t) => s + countChars(t), 0);\n\n  const entityHistorianNoteText = collectHistorianNoteTexts(entityHistorianNotes);\n  const chronicleHistorianNoteText = collectHistorianNoteTexts(chronicleHistorianNotes);\n\n  const wordBreakdown: WordCountBreakdown = {\n    chronicleBody: sumWords(chronicleBodyTexts),\n    chronicleSummaries: sumWords(chronicleSummaryTexts),\n    entityDescriptions: sumWords(entityDescTexts),\n    entitySummaries: sumWords(entitySummaryTexts),\n    eraNarrativeContent: sumWords(narrativeTexts),\n    imageCaptions: sumWords(captionTexts),\n    historianNotesEntity: countWords(entityHistorianNoteText),\n    historianNotesChronicle: countWords(chronicleHistorianNoteText),\n    staticPageContent: sumWords(pageTexts),\n  };\n\n  const charBreakdown: CharCountBreakdown = {\n    chronicleBody: sumChars(chronicleBodyTexts),\n    chronicleSummaries: sumChars(chronicleSummaryTexts),\n    entityDescriptions: sumChars(entityDescTexts),\n    entitySummaries: sumChars(entitySummaryTexts),\n    eraNarrativeContent: sumChars(narrativeTexts),\n    imageCaptions: sumChars(captionTexts),\n    historianNotesEntity: countChars(entityHistorianNoteText),\n    historianNotesChronicle: countChars(chronicleHistorianNoteText),\n    staticPageContent: sumChars(pageTexts),\n  };\n\n  const totalWords = Object.values(wordBreakdown).reduce((s, v) => s + v, 0);\n  const totalChars = Object.values(charBreakdown).reduce((s, v) => s + v, 0);\n\n  // =========================================================================\n  // Image Stats\n  // =========================================================================\n\n  const byAspect: Record<ImageAspect, number> = { portrait: 0, landscape: 0, square: 0 };\n  const byType: Record<ImageType | \"cover\", number> = { entity: 0, chronicle: 0, cover: 0 };\n  const bySize: Record<ChronicleImageSize, number> = {\n    small: 0,\n    medium: 0,\n    large: 0,\n    \"full-width\": 0,\n  };\n\n  let minW = Infinity,\n    maxW = 0,\n    minH = Infinity,\n    maxH = 0;\n  let hasDimensions = false;\n\n  for (const img of images) {\n    const aspect = img.aspect || \"square\";\n    byAspect[aspect]++;\n\n    const isCover = img.imageRefId === \"__cover_image__\";\n    const type = isCover ? \"cover\" : img.imageType || \"entity\";\n    byType[type]++;\n\n    if (img.width && img.height) {\n      hasDimensions = true;\n      if (img.width < minW) minW = img.width;\n      if (img.width > maxW) maxW = img.width;\n      if (img.height < minH) minH = img.height;\n      if (img.height > maxH) maxH = img.height;\n    }\n  }\n\n  // Count image size designations from chronicle image refs\n  for (const c of publishedChronicles) {\n    if (!c.imageRefs?.refs) continue;\n    for (const ref of c.imageRefs.refs) {\n      bySize[ref.size]++;\n    }\n  }\n\n  const totalStorageBytes = images.reduce((s, img) => s + (img.size || 0), 0);\n\n  const imageStats: ImageStats = {\n    total: images.length,\n    totalStorageBytes,\n    byAspect,\n    byType,\n    bySize,\n    dimensionRange: hasDimensions\n      ? { minWidth: minW, maxWidth: maxW, minHeight: minH, maxHeight: maxH }\n      : null,\n  };\n\n  // =========================================================================\n  // Completeness\n  // =========================================================================\n\n  const entitiesWithImage = entities.filter((e) => e.enrichment?.image?.imageId).length;\n  const totalEras = entities.filter((e) => e.kind === \"era\").length;\n\n  const completeness: CompletenessStats = {\n    entitiesTotal: entities.length,\n    entitiesWithDescription: entities.filter((e) => e.description).length,\n    entitiesWithImage,\n    entitiesWithSummary: entities.filter((e) => e.summary).length,\n    chroniclesTotal: publishedChronicles.length,\n    chroniclesPublished: publishedChronicles.filter((c) => c.status === \"complete\").length,\n    chroniclesWithHistorianNotes: publishedChronicles.filter((c) => c.historianNotes?.length)\n      .length,\n    chroniclesWithSceneImages: publishedChronicles.filter((c) =>\n      c.imageRefs?.refs?.some((r) => r.type === \"prompt_request\" && r.status === \"complete\")\n    ).length,\n    staticPagesTotal: staticPages.length,\n    staticPagesPublished: publishedPages.length,\n    eraNarrativesTotal: totalEras,\n    eraNarrativesComplete: eraNarratives.filter((n) => n.status === \"complete\").length,\n    eraNarrativesWithCoverImage: eraNarratives.filter((n) => n.coverImage?.status === \"complete\")\n      .length,\n  };\n\n  // =========================================================================\n  // Historian Notes\n  // =========================================================================\n\n  const byNoteType: Record<HistorianNoteType, number> = {\n    commentary: 0,\n    correction: 0,\n    tangent: 0,\n    skepticism: 0,\n    pedantic: 0,\n  };\n  for (const note of allHistorianNotes) {\n    if (byNoteType[note.type] !== undefined) {\n      byNoteType[note.type]++;\n    }\n  }\n\n  const historianNoteStats: HistorianNoteStats = {\n    total: allHistorianNotes.length,\n    byType: byNoteType,\n    onEntities: entityHistorianNotes.length,\n    onChronicles: chronicleHistorianNotes.length,\n  };\n\n  return {\n    totalWords,\n    totalChars,\n    estimatedPages: Math.ceil(totalWords / 250),\n    wordBreakdown,\n    charBreakdown,\n    images: imageStats,\n    completeness,\n    historianNotes: historianNoteStats,\n    calculatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "entities", "type": "PersistedEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "images", "type": "ImageMetadataRecord[]", "optional": false}, {"name": "staticPages", "type": "StaticPage[]", "optional": false}, {"name": "eraNarratives", "type": "EraNarrativeRecord[]", "optional": false}], "returnType": "PrePrintStats"}, {"id": "apps/illuminator/webui/src/workers/tasks/index.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/index.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts", "sourceCode": "export function getCallConfig(config: WorkerConfig, callType: LLMCallType): ResolvedLLMCallConfig {\n  return config.llmCallSettings[callType];\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx", "sourceCode": "export default function EntryPointStep({ entities, relationships, events }: Readonly<EntryPointStepProps>) {\n  const {\n    state,\n    eras,\n    selectEntryPoint,\n    clearEntryPoint,\n    setIncludeErasInNeighborhood,\n    simulationRunId,\n  } = useWizard();\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [sortBy, setSortBy] = useState<SortOption>(\"story-score\");\n  const [hoveredEntityId, setHoveredEntityId] = useState<string | null>(null);\n  const [onlyUnused, setOnlyUnused] = useState(false);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage stats when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageStats(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n        if (isActive) setUsageStats(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Compute story potentials for all entities\n  const entityPotentials = useMemo(() => {\n    return computeAllStoryPotentials(entities, relationships, events);\n  }, [entities, relationships, events]);\n\n  const usageCounts = useMemo(() => {\n    const counts = new Map<string, number>();\n    for (const [id, stats] of usageStats) {\n      counts.set(id, stats.usageCount);\n    }\n    return counts;\n  }, [usageStats]);\n\n  const usageMetrics = useMemo(() => {\n    if (entityPotentials.size === 0) return new Map<string, UsageMetrics>();\n\n    const entityIds = Array.from(entityPotentials.keys());\n    const adjacency = new Map<string, Set<string>>();\n    for (const id of entityIds) adjacency.set(id, new Set());\n\n    for (const rel of relationships) {\n      if (!adjacency.has(rel.src) || !adjacency.has(rel.dst)) continue;\n      adjacency.get(rel.src).add(rel.dst);\n      adjacency.get(rel.dst).add(rel.src);\n    }\n\n    const visitStamp = new Map<string, number>();\n    let stamp = 1;\n    const result = new Map<string, UsageMetrics>();\n\n    for (const id of entityIds) {\n      const usageCount = usageCounts.get(id) ?? 0;\n      const entity = entityPotentials.get(id);\n      const rawProminence = entity ? Number(entity.prominence) : 0;\n      const prominence = Number.isFinite(rawProminence) ? Math.max(0, rawProminence) : 0;\n\n      const firstHop = adjacency.get(id) || new Set<string>();\n      stamp += 1;\n      visitStamp.set(id, stamp);\n\n      let hop1Total = 0;\n      let hop1Unused = 0;\n      for (const neighbor of firstHop) {\n        if (visitStamp.get(neighbor) === stamp) continue;\n        visitStamp.set(neighbor, stamp);\n        hop1Total += 1;\n        if ((usageCounts.get(neighbor) ?? 0) === 0) hop1Unused += 1;\n      }\n\n      let hop2Total = 0;\n      let hop2Unused = 0;\n      for (const neighbor of firstHop) {\n        const neighborHops = adjacency.get(neighbor);\n        if (!neighborHops) continue;\n\n        for (const secondHop of neighborHops) {\n          if (visitStamp.get(secondHop) === stamp) continue;\n          visitStamp.set(secondHop, stamp);\n          hop2Total += 1;\n          if ((usageCounts.get(secondHop) ?? 0) === 0) hop2Unused += 1;\n        }\n      }\n\n      result.set(id, {\n        usageCount,\n        unusedSelf: usageCount === 0,\n        hop1Unused,\n        hop1Total,\n        hop2Unused,\n        hop2Total,\n        underusedScore: prominence / (usageCount + 1),\n        prominence,\n      });\n    }\n\n    return result;\n  }, [entityPotentials, relationships, usageCounts]);\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    return getUniqueKinds(entities);\n  }, [entities]);\n\n  // Era lookups: id -> color and id -> name\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  const eraNameMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const era of eras) {\n      map.set(era.id, era.name);\n    }\n    return map;\n  }, [eras]);\n\n  // Filter and sort entities\n  const filteredEntities = useMemo(() => {\n    let result = [...entityPotentials.values()];\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      result = result.filter((e) => selectedKinds.has(e.kind));\n    }\n\n    // Apply unused filter (requires usage stats)\n    if (onlyUnused && !usageLoading) {\n      result = result.filter((e) => (usageMetrics.get(e.id)?.usageCount ?? 0) === 0);\n    }\n\n    // Sort\n    result.sort((a, b) => {\n      switch (sortBy) {\n        case \"name\":\n          return a.name.localeCompare(b.name);\n        case \"connections\":\n          return b.connectionCount - a.connectionCount;\n        case \"underused\": {\n          const aScore = usageMetrics.get(a.id)?.underusedScore ?? 0;\n          const bScore = usageMetrics.get(b.id)?.underusedScore ?? 0;\n          if (bScore !== aScore) return bScore - aScore;\n          return b.potential.overallScore - a.potential.overallScore;\n        }\n        case \"story-score\":\n        default:\n          return b.potential.overallScore - a.potential.overallScore;\n      }\n    });\n\n    return result;\n  }, [entityPotentials, selectedKinds, sortBy, onlyUnused, usageLoading, usageMetrics]);\n\n  // Get entity for detail panel (hover takes priority over selection)\n  const detailEntity = useMemo(() => {\n    const id = hoveredEntityId || state.entryPointId;\n    if (!id) return null;\n    return entityPotentials.get(id) || null;\n  }, [hoveredEntityId, state.entryPointId, entityPotentials]);\n\n  // Get connections for constellation\n  const detailConnections = useMemo(() => {\n    if (!detailEntity) return [];\n    return getConnectedEntities(detailEntity.id, entities, relationships);\n  }, [detailEntity, entities, relationships]);\n  const detailUsage = useMemo(() => {\n    if (!detailEntity) return null;\n    return usageMetrics.get(detailEntity.id) || null;\n  }, [detailEntity, usageMetrics]);\n\n  const handleSelect = (entity: EntityWithPotential) => {\n    // Click again to deselect\n    if (state.entryPointId === entity.id) {\n      clearEntryPoint();\n      return;\n    }\n    // Convert back to EntityContext for the wizard\n    const { potential, connectionCount, eventCount, connectedKinds, eraIds, ...baseEntity } =\n      entity;\n    selectEntryPoint(baseEntity as EntityContext, entities, relationships, events);\n  };\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"eps-header\">\n        <h4 className=\"eps-title\">Select Entry Point</h4>\n        <p className=\"eps-subtitle\">\n          Choose the central entity for your chronicle. Higher story scores indicate richer\n          narrative potential.\n        </p>\n      </div>\n\n      {/* Two column layout - fixed height to prevent jumping */}\n      <div className=\"eps-layout\">\n        {/* Left: Entity list */}\n        <div className=\"eps-left\">\n          {/* Filter chips */}\n          <div className=\"eps-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n\n          {/* Sort control and options */}\n          <div className=\"eps-sort-row\">\n            <select\n              value={sortBy}\n              onChange={(e) => setSortBy(e.target.value as SortOption)}\n              className=\"illuminator-select eps-sort-select\"\n            >\n              <option value=\"story-score\">Sort by Story Score</option>\n              <option value=\"connections\">Sort by Connections</option>\n              <option value=\"underused\">Sort by Underused Score</option>\n              <option value=\"name\">Sort by Name</option>\n            </select>\n            <label className=\"eps-checkbox-label eps-checkbox-label-muted\">\n              <input\n                type=\"checkbox\"\n                checked={state.includeErasInNeighborhood}\n                onChange={(e) => setIncludeErasInNeighborhood(e.target.checked)}\n                className=\"eps-checkbox\"\n              />\n              Include eras in neighborhood\n            </label>\n            <label\n              className=\"eps-checkbox-label\"\n              style={{\n                '--eps-label-color': usageLoading ? \"var(--text-muted)\" : \"var(--text-secondary)\",\n                '--eps-label-cursor': usageLoading ? \"not-allowed\" : \"pointer\",\n              } as React.CSSProperties}\n            >\n              <input\n                type=\"checkbox\"\n                checked={onlyUnused}\n                onChange={(e) => setOnlyUnused(e.target.checked)}\n                className=\"eps-checkbox\"\n                disabled={usageLoading}\n              />\n              Only unused\n            </label>\n          </div>\n\n          {/* Entity list - fills remaining height */}\n          <div className=\"eps-entity-list\">\n            {filteredEntities.length === 0 ? (\n              <div className=\"eps-empty-list\">\n                No entities match the selected filters.\n              </div>\n            ) : (\n              filteredEntities.map((entity) => {\n                const isSelected = state.entryPointId === entity.id;\n                const isHovered = hoveredEntityId === entity.id;\n                const usage = usageMetrics.get(entity.id);\n\n                return (\n                  <div\n                    key={entity.id}\n                    onClick={() => handleSelect(entity)}\n                    onMouseEnter={() => setHoveredEntityId(entity.id)}\n                    onMouseLeave={() => setHoveredEntityId(null)}\n                    className={`eps-entity-row ${isSelected ? \"eps-entity-row-selected\" : \"\"} ${isHovered && !isSelected ? \"eps-entity-row-hovered\" : \"\"}`}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n// ... (truncated)", "parameters": [{"name": "{ entities, relationships, events }", "type": "Readonly<EntryPointStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx", "sourceCode": "export default function EventResolutionStep() {\n  const {\n    state,\n    toggleEvent,\n    toggleRelationship,\n    selectAllEvents,\n    deselectAllEvents,\n    selectAllRelationships,\n    deselectAllRelationships,\n    computeEventMetricsForSelection,\n    temporalContext,\n    detectedFocalEra,\n    eras,\n    setFocalEraOverride,\n    autoFillEvents,\n  } = useWizard();\n\n  const [, setEventMetrics] = useState<Map<string, EventSelectionMetrics>>(new Map());\n  const [brushSelection, setBrushSelection] = useState<[number, number] | null>(null);\n  const [minEventSignificance, setMinEventSignificance] = useState<number>(0);\n\n  // Recompute event metrics when the computation function changes\n  useEffect(() => {\n    const metrics = computeEventMetricsForSelection();\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync derived metrics cache to updated computation source\n    setEventMetrics(metrics);\n  }, [computeEventMetricsForSelection]);\n\n  // Get relevant relationships (between assigned entities + lens)\n  const lensEntityIds = useMemo(() => (state.lens ? [state.lens.entityId] : []), [state.lens]);\n\n  const relevantRelationships = useMemo(() => {\n    return getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensEntityIds\n    );\n  }, [state.roleAssignments, state.candidateRelationships, lensEntityIds]);\n\n  // Get ALL relevant events (involving assigned entities) - before filtering\n  const allRelevantEvents = useMemo(() => {\n    return getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Filter events by significance and exclude prominence-only events\n  const relevantEvents = useMemo(() => {\n    const entityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n    return filterChronicleEvents(allRelevantEvents, entityIds, {\n      minSignificance: minEventSignificance,\n      excludeProminenceOnly: true,\n    });\n  }, [allRelevantEvents, state.roleAssignments, minEventSignificance]);\n\n  // Get era ranges directly from era definitions\n  const eraRanges = useMemo(() => {\n    return getEraRanges(eras);\n  }, [eras]);\n\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  const timelineEvents = useMemo(() => {\n    return prepareTimelineEvents(\n      relevantEvents,\n      state.entryPointId,\n      assignedEntityIds,\n      state.selectedEventIds\n    );\n  }, [relevantEvents, state.entryPointId, assignedEntityIds, state.selectedEventIds]);\n\n  const intensityCurve = useMemo(() => {\n    return computeIntensityCurve(relevantEvents);\n  }, [relevantEvents]);\n\n  // Get timeline extent directly from era definitions\n  const timelineExtent = useMemo(() => {\n    return getTimelineExtent(eras);\n  }, [eras]);\n\n  // Build entity map for cast marker lookup\n  const entityMap = useMemo(() => {\n    const map = new Map<string, EntityContext>();\n    for (const entity of state.candidates) {\n      map.set(entity.id, entity);\n    }\n    return map;\n  }, [state.candidates]);\n\n  // Compute cast markers from role assignments, entry point, and lens\n  const castMarkers = useMemo(() => {\n    return prepareCastMarkers(state.roleAssignments, entityMap, state.entryPoint, state.lens);\n  }, [state.roleAssignments, entityMap, state.entryPoint, state.lens]);\n\n  // Collapse bidirectional relationships for display\n  const collapsedRelationships = useMemo(\n    () => collapseBidirectionalRelationships(relevantRelationships),\n    [relevantRelationships]\n  );\n\n  // Get all relationship IDs (flattened from collapsed)\n  const relevantRelationshipIds = useMemo(\n    () => collapsedRelationships.flatMap((cr) => cr.relationshipIds),\n    [collapsedRelationships]\n  );\n\n  const relevantEventIds = useMemo(() => relevantEvents.map((e) => e.id), [relevantEvents]);\n\n  // Count how many selected events are visible (pass the current filter)\n  const visibleSelectedCount = useMemo(() => {\n    const relevantIdSet = new Set(relevantEventIds);\n    return Array.from(state.selectedEventIds).filter((id) => relevantIdSet.has(id)).length;\n  }, [relevantEventIds, state.selectedEventIds]);\n\n  // Auto-select all on first mount if accepting defaults\n  useEffect(() => {\n    if (\n      state.acceptDefaults &&\n      state.selectedRelationshipIds.size === 0 &&\n      state.selectedEventIds.size === 0\n    ) {\n      selectAllRelationships(relevantRelationshipIds);\n      selectAllEvents(relevantEventIds);\n    }\n  }, [\n    state.acceptDefaults,\n    state.selectedRelationshipIds.size,\n    state.selectedEventIds.size,\n    selectAllRelationships,\n    selectAllEvents,\n    relevantRelationshipIds,\n    relevantEventIds,\n  ]);\n\n  // Handle brush selection change - select events in range\n  const handleBrushChange = useCallback(\n    (range: [number, number] | null) => {\n      setBrushSelection(range);\n      if (range) {\n        const eventsInRange = getEventsInRange(timelineEvents, range[0], range[1]);\n        const idsInRange = eventsInRange.map((e) => e.id);\n        // Select only events in range, deselect others\n        const newSelectedIds = new Set(idsInRange);\n        // Update selection\n        for (const id of relevantEventIds) {\n          const inNew = newSelectedIds.has(id);\n          const inCurrent = state.selectedEventIds.has(id);\n          if (inNew !== inCurrent) {\n            toggleEvent(id);\n          }\n        }\n      }\n    },\n    [timelineEvents, relevantEventIds, state.selectedEventIds, toggleEvent]\n  );\n\n  // Effective focal era\n  const effectiveFocalEraId = state.focalEraOverride || detectedFocalEra?.id || null;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ers-header\">\n        <div className=\"ers-header-row\">\n          <div>\n            <h4 className=\"ers-title\">Compose Narrative Arc</h4>\n            <p className=\"ers-subtitle\">\n              Select events from the timeline to build your narrative. Use the brush to select time\n              ranges.\n            </p>\n          </div>\n          <button\n            onClick={() => autoFillEvents(true)}\n            className=\"illuminator-btn ers-btn-sm\"\n          >\n            Auto-fill Events\n          </button>\n        </div>\n\n        {/* Filters */}\n        <div className=\"ers-filters\">\n          {/* Row 1: Focal Era selector */}\n          {temporalContext && (\n            <div className=\"ers-filter-row\">\n              <span className=\"ers-filter-label\">Focal Era:</span>\n              <select\n                value={state.focalEraOverride || temporalContext.focalEra.id}\n                onChange={(e) => {\n                  const selectedId = e.target.value;\n                  if (detectedFocalEra && selectedId === detectedFocalEra.id) {\n                    setFocalEraOverride(null);\n                  } else {\n                    setFocalEraOverride(selectedId);\n                  }\n                }}\n                className=\"illuminator-select ers-filter-select\"\n              >\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name}\n                    {detectedFocalEra?.id === era.id ? \" (detected)\" : \"\"}\n                  </option>\n                ))}\n              </select>\n              {state.focalEraOverride && (\n                <button\n                  onClick={() => setFocalEraOverride(null)}\n                  className=\"illuminator-btn ers-reset-btn\"\n                >\n                  Reset\n                </button>\n              )}\n            </div>\n          )}\n\n          {/* Row 2: Min Significance selector */}\n          <div className=\"ers-filter-row\">\n            <span className=\"ers-filter-label\">Min Significance:</span>\n            <select\n              value={minEventSignificance}\n              onChange={(e) => setMinEventSignificance(parseFloat(e.target.value))}\n              className=\"illuminator-select ers-filter-select\"\n            >\n              <option value={0}>All (&gt;0%)</option>\n              <option value={0.25}>Low (&gt;25%)</option>\n              <option value={0.5}>Medium (&gt;50%)</option>\n              <option value={0.75}>High (&gt;75%)</option>\n            </select>\n            <span className=\"ers-filter-count\">\n              {relevantEvents.length} events match filter\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Timeline Visualization */}\n      <div className=\"ers-timeline-section\">\n        {/* Intensity Sparkline */}\n        <IntensitySparkline\n          points={intensityCurve}\n          width={700}\n          height={40}\n          extent={timelineExtent}\n          selectedRange={brushSelection}\n        />\n\n        {/* Narrative Timeline with Era Lanes - compact overview */}\n        <div className=\"ers-timeline-gap\">\n          <NarrativeTimeline\n            events={timelineEvents}\n            eraRanges={eraRanges}\n            width={700}\n            height={castMarkers.length > 0 ? 148 : 120}\n            onToggleEvent={toggleEvent}\n            focalEraId={effectiveFocalEraId}\n            extent={timelineExtent}\n            castMarkers={castMarkers}\n          />\n        </div>\n\n        {/* Timeline Brush */}\n        <div className=\"ers-timeline-gap\">\n          <TimelineBrush\n            width={700}\n            height={36}\n            extent={timelineExtent}\n            selection={brushSelection}\n            onSelectionChange={handleBrushChange}\n          />\n        </div>\n\n        {/* Quick actions */}\n        <div className=\"ers-quick-actions\">\n          <button\n            onClick={() => selectAllEvents(relevantEventIds)}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Select All Events\n          </button>\n          <button\n            onClick={() => {\n              deselectAllEvents();\n              setBrushSelection(null);\n            }}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Clear Selection\n          </button>\n          <span\n            className=\"ers-selection-count\"\n            style={{\n              '--ers-count-color': state.selectedEventIds.size > MAX_CHRONICLE_EVENTS\n                ? \"var(--error)\"\n                : \"var(--text-muted)\",\n            } as React.CSSProperties}\n          >\n            {visibleSelectedCount} of {relevantEvents.length} visible selected\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx", "sourceCode": "export default function GenerateStep({ onGenerate: _onGenerate }: Readonly<GenerateStepProps>) {\n  const { state, setNarrativeDirection } = useWizard();\n\n  // Count primary vs supporting roles\n  const primaryCount = state.roleAssignments.filter((a) => a.isPrimary).length;\n  const supportingCount = state.roleAssignments.length - primaryCount;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"gs-header\">\n        <h4 className=\"gs-title\">Generate Chronicle</h4>\n        <p className=\"gs-subtitle\">\n          Review your selections and generate the chronicle.\n        </p>\n      </div>\n\n      {/* Summary */}\n      <div className=\"gs-summary\">\n        <div className=\"gs-summary-grid\">\n          {/* Style */}\n          <div>\n            <div className=\"gs-section-label\">\n              Narrative Style\n            </div>\n            <div className=\"gs-section-value\">\n              {state.narrativeStyle?.name}\n              <span\n                className={`gs-format-badge ${state.narrativeStyle?.format === \"story\" ? \"gs-format-badge-story\" : \"gs-format-badge-document\"}`}\n              >\n                {state.narrativeStyle?.format}\n              </span>\n            </div>\n          </div>\n\n          {/* Entry Point */}\n          <div>\n            <div className=\"gs-section-label\">\n              Entry Point\n            </div>\n            <div className=\"gs-section-value\">\n              {state.entryPoint?.name}\n              <span className=\"gs-section-meta\">\n                ({state.entryPoint?.kind})\n              </span>\n            </div>\n          </div>\n\n          {/* Ensemble */}\n          <div>\n            <div className=\"gs-section-label\">\n              Ensemble\n            </div>\n            <div className=\"gs-section-value\">\n              {state.roleAssignments.length} entities\n              <span className=\"gs-section-meta\">\n                ({primaryCount} primary, {supportingCount} supporting)\n              </span>\n            </div>\n          </div>\n\n          {/* Events & Relationships */}\n          <div>\n            <div className=\"gs-section-label\">\n              Context\n            </div>\n            <div className=\"gs-section-value\">\n              {state.selectedEventIds.size} events, {state.selectedRelationshipIds.size}{\" \"}\n              relationships\n            </div>\n          </div>\n        </div>\n\n        {/* Narrative Lens */}\n        {state.lens && (\n          <div className=\"gs-lens-section\">\n            <div className=\"gs-section-label\">\n              Narrative Lens\n            </div>\n            <div className=\"gs-lens-chip\">\n              <span className=\"gs-lens-icon\">&#x25C8;</span>\n              <span className=\"gs-lens-name\">{state.lens.entityName}</span>\n              <span className=\"gs-lens-kind\">\n                ({state.lens.entityKind})\n              </span>\n            </div>\n          </div>\n        )}\n\n        {/* Role Breakdown */}\n        <div className=\"gs-roles-section\">\n          <div className=\"gs-roles-label\">\n            Role Assignments\n          </div>\n          <div className=\"gs-roles-list\">\n            {state.roleAssignments.map((assignment) => (\n              <span\n                key={`${assignment.role}-${assignment.entityId}`}\n                className={`gs-role-chip ${assignment.isPrimary ? \"gs-role-chip-primary\" : \"gs-role-chip-support\"}`}\n                style={{\n                  '--gs-role-opacity': assignment.isPrimary ? 0.9 : 0.7,\n                } as React.CSSProperties}\n              >\n                <span className=\"gs-role-name\">{assignment.role}</span>\n                <span className=\"gs-role-entity\">\n                  {assignment.entityName}\n                </span>\n              </span>\n            ))}\n          </div>\n        </div>\n      </div>\n\n      {/* Narrative Direction */}\n      <div className=\"gs-direction-section\">\n        <div className=\"gs-section-label\">\n          Narrative Direction\n          <span className=\"gs-direction-optional\">\n            optional\n          </span>\n        </div>\n        <p className=\"gs-direction-desc\">\n          Concrete story purpose that shapes perspective and generation. Leave empty for open-ended\n          chronicles.\n        </p>\n        <textarea\n          value={state.narrativeDirection}\n          onChange={(e) => setNarrativeDirection(e.target.value)}\n          placeholder='e.g. \"This is the treaty document that ended the Faction Wars\" or \"An eyewitness account of the apocalyptic magic that ended the Orca Invasion\"'\n          className=\"gs-direction-textarea\"\n        />\n      </div>\n\n      {/* Info Box */}\n      <div className=\"gs-info-box\">\n        <span className=\"gs-info-icon\">\ud83d\udca1</span>\n        <span>\n          Click &quot;Generate Chronicle&quot; to start generation. The complete chronicle will be ready in\n          about 30-60 seconds.\n        </span>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onGenerate: _onGenerate }", "type": "Readonly<GenerateStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx", "sourceCode": "export default function RoleAssignmentStep() {\n  const {\n    state,\n    eras,\n    autoFillRoles,\n    addRoleAssignment,\n    removeRoleAssignment,\n    togglePrimary,\n    setLens,\n    clearLens,\n    computeMetrics,\n    simulationRunId,\n  } = useWizard();\n\n  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [metricsMap, setMetricsMap] = useState<Map<string, EntitySelectionMetrics>>(new Map());\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [selectedEras, setSelectedEras] = useState<Set<string>>(new Set());\n  const [connectionFilter, setConnectionFilter] = useState<string | null>(null);\n\n  const style = state.narrativeStyle;\n  const roles = getRoles(style);\n  const maxCastSize = 10;\n\n  // Load usage stats on mount\n  useEffect(() => {\n    if (!simulationRunId) {\n      throw new Error(\"[Chronicle Wizard] simulationRunId is required to load entity usage stats.\");\n    }\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n      });\n  }, [simulationRunId]);\n\n  const metricsKey = `${state.candidates.length}|${state.entryPointId}|${usageStats.size}|${state.roleAssignments.length}`;\n  useEffect(() => {\n    if (state.candidates.length === 0 || !state.entryPointId) return;\n    const metrics = computeMetrics(usageStats);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- recompute local metrics cache when candidate inputs change\n    setMetricsMap(metrics);\n  }, [metricsKey, state.candidates.length, state.entryPointId, usageStats]);\n\n  // Get assigned entity IDs\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  // Validation\n  const validation = useMemo(() => {\n    if (!roles.length) return { valid: true, errors: [], warnings: [] };\n    return validateRoleAssignments(state.roleAssignments, roles, maxCastSize);\n  }, [state.roleAssignments, roles, maxCastSize]);\n\n  // Get selected entity details\n  const selectedEntity = useMemo(() => {\n    if (!selectedEntityId) return null;\n    return state.candidates.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, state.candidates]);\n\n  const selectedMetrics = useMemo(() => {\n    if (!selectedEntityId) return undefined;\n    return metricsMap.get(selectedEntityId);\n  }, [selectedEntityId, metricsMap]);\n\n  // Era color map: eraId -> hex color (same palette as timeline)\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  // Get era name and color for selected entity\n  const selectedEntityEra = useMemo(() => {\n    if (!selectedEntity || eras.length === 0) return undefined;\n    const entityEraId = resolveEntityEraId(selectedEntity);\n    const era = entityEraId ? eras.find((e) => e.id === entityEraId) : undefined;\n    if (!era) return undefined;\n    return { name: era.name, color: eraColorMap.get(era.id) };\n  }, [selectedEntity, eras, eraColorMap]);\n\n  // Handle role assignment\n  const handleAssignToRole = useCallback(\n    (roleId: string) => {\n      if (!selectedEntityId) return;\n\n      const entity = state.candidates.find((e) => e.id === selectedEntityId);\n      if (!entity) return;\n\n      addRoleAssignment({\n        role: roleId,\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n        isPrimary: false,\n      });\n\n      setSelectedEntityId(null);\n    },\n    [selectedEntityId, state.candidates, addRoleAssignment]\n  );\n\n  // Handle remove from role\n  const handleRemoveFromRole = useCallback(\n    (entityId: string, roleId: string) => {\n      removeRoleAssignment(entityId, roleId);\n    },\n    [removeRoleAssignment]\n  );\n\n  // Build kind-to-category map\n  const kindToCategory = useMemo(() => {\n    const map = new Map<string, string>();\n    // Simple mapping - could be domain-specific\n    for (const candidate of state.candidates) {\n      map.set(candidate.kind, candidate.kind);\n    }\n    return map;\n  }, [state.candidates]);\n\n  const handleSetLens = useCallback(\n    (entity: { id: string; name: string; kind: string }) => {\n      const lens: NarrativeLens = {\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n      };\n      setLens(lens);\n    },\n    [setLens]\n  );\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const candidate of state.candidates) {\n      kinds.add(candidate.kind);\n    }\n    return Array.from(kinds).sort((a, b) => a.localeCompare(b));\n  }, [state.candidates]);\n\n  // Available eras from candidates (in era order, only eras with entities)\n  const availableEras = useMemo(() => {\n    const eraIds = new Set<string>();\n    for (const c of state.candidates) {\n      const eraId = resolveEntityEraId(c);\n      if (eraId) eraIds.add(eraId);\n    }\n    return eras.filter((e) => eraIds.has(e.id)).map((e) => e.id);\n  }, [state.candidates, eras]);\n\n  // Build connection maps for filtering\n  const connectionMaps = useMemo(() => {\n    // Map entity ID -> set of assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of state.candidateRelationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    return { connectedToAssigned };\n  }, [state.candidateRelationships, assignedEntityIds]);\n\n  // Filter candidates by selected kinds and connection filter (always include assigned entities)\n  const filteredCandidates = useMemo(() => {\n    let candidates = state.candidates;\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      candidates = candidates.filter(\n        (c) => selectedKinds.has(c.kind) || assignedEntityIds.has(c.id)\n      );\n    }\n\n    // Apply era filter\n    if (selectedEras.size > 0) {\n      candidates = candidates.filter((c) => {\n        const eraId = resolveEntityEraId(c);\n        return (eraId !== undefined && selectedEras.has(eraId)) || assignedEntityIds.has(c.id);\n      });\n    }\n\n    // Apply connection filter\n    if (connectionFilter && assignedEntityIds.size > 0) {\n      candidates = candidates.filter((c) => {\n        // Always include assigned entities\n        if (assignedEntityIds.has(c.id)) return true;\n\n        const connectedTo = connectionMaps.connectedToAssigned.get(c.id);\n        const connectionCount = connectedTo?.size ?? 0;\n\n        switch (connectionFilter) {\n          case \"linked\":\n            // Connected to at least one assigned entity\n            return connectionCount > 0;\n          case \"bridges\":\n            // Connected to 2+ assigned entities (bridges/connectors)\n            return connectionCount >= 2;\n          default:\n            return true;\n        }\n      });\n    }\n\n    return candidates;\n  }, [\n    state.candidates,\n    selectedKinds,\n    selectedEras,\n    assignedEntityIds,\n    connectionFilter,\n    connectionMaps,\n  ]);\n\n  // Filter relationships to only include those between filtered candidates\n  const filteredRelationships = useMemo(() => {\n    const filteredIds = new Set(filteredCandidates.map((c) => c.id));\n    return state.candidateRelationships.filter(\n      (r) => filteredIds.has(r.src) && filteredIds.has(r.dst)\n    );\n  }, [state.candidateRelationships, filteredCandidates]);\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ras-header\">\n        <div>\n          <h4 className=\"ras-title\">Build Your Ensemble</h4>\n          <p className=\"ras-subtitle\">\n            Click entities in the constellation to select, then click a role to assign.\n          </p>\n        </div>\n        <button\n          onClick={() => autoFillRoles(metricsMap)}\n          className=\"illuminator-btn ras-autofill-btn\"\n        >\n          Auto-fill Roles\n        </button>\n      </div>\n\n      {/* Validation Messages */}\n      {validation.errors.length > 0 && (\n        <div className=\"ras-errors\">\n          {validation.errors.map((error, i) => (\n            <div key={i} className=\"ras-error\">\n              {error}\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Main layout: Left (constellation + health) | Right (roles + detail) */}\n      <div className=\"ras-layout\">\n        {/* Left: Constellation + Ensemble Health */}\n        <div className=\"ras-left\">\n          {/* Kind filter chips */}\n          <div className=\"ras-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n          {/* Era filter chips */}\n          {availableEras.length > 1 && (\n            <div className=\"ras-filter-gap\">\n              <FilterChips\n                options={availableEras}\n                selected={selectedEras}\n                onSelectionChange={setSelectedEras}\n                label=\"Filter by Era\"\n                formatLabel={(eraId) => eras.find((e) => e.id === eraId)?.name ?? eraId}\n                getColor={(eraId) => eraColorMap.get(eraId) ?? \"var(--text-muted)\"}\n              />\n            </div>\n          )}\n          {/* Connection filter */}\n          <div className=\"ras-conn-filter\">\n            <span className=\"ras-conn-label\">Show:</span>\n            {[\n              { id: null, label: \"All\" },\n              { id: \"linked\", label: \"Linked to ensemble\" },\n              { id: \"bridges\", label: \"Bridges (2+ links)\" },\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx", "sourceCode": "export default function StyleStep({ styles }: Readonly<StyleStepProps>) {\n  const { state, selectStyle, setAcceptDefaults, simulationRunId } = useWizard();\n  const [searchText, setSearchText] = useState(\"\");\n  const [formatFilter, setFormatFilter] = useState<\"all\" | \"story\" | \"document\">(\"all\");\n  const [styleUsage, setStyleUsage] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setStyleUsage(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getNarrativeStyleUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setStyleUsage(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load narrative style usage stats:\", err);\n        if (isActive) setStyleUsage(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Filter styles\n  const filteredStyles = useMemo(() => {\n    return styles.filter((style) => {\n      // Format filter\n      if (formatFilter !== \"all\" && style.format !== formatFilter) {\n        return false;\n      }\n      // Search filter\n      if (searchText.trim()) {\n        const search = searchText.toLowerCase();\n        return (\n          style.name.toLowerCase().includes(search) ||\n          style.description.toLowerCase().includes(search) ||\n          style.tags?.some((tag) => tag.toLowerCase().includes(search))\n        );\n      }\n      return true;\n    });\n  }, [styles, formatFilter, searchText]);\n\n  // Group by format\n  const storyStyles = filteredStyles.filter((s) => s.format === \"story\");\n  const documentStyles = filteredStyles.filter((s) => s.format === \"document\");\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"sstep-header\">\n        <h4 className=\"sstep-title\">Select Narrative Style</h4>\n        <p className=\"sstep-subtitle\">\n          Choose a style that defines the structure and roles for your chronicle.\n        </p>\n      </div>\n\n      {/* Filters */}\n      <div className=\"sstep-filters\">\n        <input\n          type=\"text\"\n          value={searchText}\n          onChange={(e) => setSearchText(e.target.value)}\n          placeholder=\"Search styles...\"\n          className=\"illuminator-input sstep-search\"\n        />\n        <select\n          value={formatFilter}\n          onChange={(e) => setFormatFilter(e.target.value as \"all\" | \"story\" | \"document\")}\n          className=\"illuminator-select\"\n        >\n          <option value=\"all\">All Formats</option>\n          <option value=\"story\">Stories</option>\n          <option value=\"document\">Documents</option>\n        </select>\n\n        {/* Accept Defaults Checkbox */}\n        <label className=\"sstep-defaults-label\">\n          <input\n            type=\"checkbox\"\n            checked={state.acceptDefaults}\n            onChange={(e) => setAcceptDefaults(e.target.checked)}\n          />\n          Accept defaults for quick generation\n        </label>\n      </div>\n\n      {/* Styles Grid */}\n      <div className=\"sstep-scroll\">\n        {formatFilter === \"all\" || formatFilter === \"story\" ? (\n          <>\n            {storyStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Story Styles ({storyStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid sstep-grid-mb\">\n              {storyStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {formatFilter === \"all\" || formatFilter === \"document\" ? (\n          <>\n            {documentStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Document Styles ({documentStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid\">\n              {documentStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {filteredStyles.length === 0 && (\n          <div className=\"sstep-empty\">\n            No styles match your search.\n          </div>\n        )}\n      </div>\n\n      {/* Selected Style Details */}\n      {state.narrativeStyle && (\n        <div className=\"sstep-selected-detail\">\n          <h5 className=\"sstep-selected-name\">\n            {state.narrativeStyle.name}\n            <span\n              className={`sstep-format-badge ${state.narrativeStyle.format === \"story\" ? \"sstep-format-badge-story\" : \"sstep-format-badge-document\"}`}\n            >\n              {state.narrativeStyle.format}\n            </span>\n          </h5>\n          <p className=\"sstep-selected-desc\">\n            {state.narrativeStyle.description}\n          </p>\n          <div className=\"sstep-usage-info\">\n            {usageLoading\n              ? \"Usage in this run: \u2026\"\n              : `Usage in this run: ${styleUsage.get(state.narrativeStyle.id)?.usageCount ?? 0}x`}\n          </div>\n\n          {/* Role Requirements */}\n          <div>\n            <span className=\"sstep-roles-label\">\n              Required Roles:\n            </span>\n            <div className=\"sstep-roles-list\">\n              {getRoles(state.narrativeStyle).map((role) => (\n                <span\n                  key={role.role}\n                  className=\"sstep-role-chip\"\n                  title={role.description}\n                >\n                  {role.role}\n                  <span className=\"sstep-role-count\">\n                    ({role.count.min}-{role.count.max})\n                  </span>\n                </span>\n              ))}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ styles }", "type": "Readonly<StyleStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx", "sourceCode": "export default function EnsembleConstellation({\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}: Readonly<EnsembleConstellationProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);\n\n  // Compute layout\n  const nodes = useMemo(() => {\n    const layout = computeLayout(entryPointId, candidates, metricsMap, width, height);\n    const candidateMap = new Map(candidates.map((c) => [c.id, c]));\n    return layout.map((node) => {\n      const candidate = candidateMap.get(node.id);\n      const eraId = candidate?.eraId && candidate.eraId.length > 0 ? candidate.eraId : undefined;\n      return {\n        ...node,\n        isAssigned: assignedEntityIds.has(node.id),\n        eraColor: eraId ? (eraColorMap?.get(eraId) ?? \"#6b7280\") : \"#6b7280\",\n      };\n    });\n  }, [entryPointId, candidates, metricsMap, width, height, assignedEntityIds, eraColorMap]);\n\n  const nodeMap = useMemo(() => {\n    return new Map(nodes.map((n) => [n.id, n]));\n  }, [nodes]);\n\n  // Compute edges\n  const edges = useMemo(() => {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n    return computeEdges(relationships, nodeIds);\n  }, [relationships, nodes]);\n\n  // Compute bridge nodes (unassigned nodes connected to 2+ unique assigned entities)\n  const bridgeNodeIds = useMemo(() => {\n    // Map entity ID -> set of unique assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of relationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    const bridges = new Set<string>();\n    for (const [id, assignedConnections] of connectedToAssigned) {\n      if (assignedConnections.size >= 2) bridges.add(id);\n    }\n    return bridges;\n  }, [relationships, assignedEntityIds]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  const handleNodeClick = useCallback(\n    (nodeId: string) => {\n      if (selectedEntityId === nodeId) {\n        onSelectEntity(null);\n      } else {\n        onSelectEntity(nodeId);\n      }\n    },\n    [selectedEntityId, onSelectEntity]\n  );\n\n  // Determine node visual properties\n  const getNodeStyle = (node: ConstellationNode) => {\n    const isSelected = selectedEntityId === node.id;\n    const isHovered = hoveredNodeId === node.id;\n    const metrics = node.metrics;\n\n    // Base size\n    let radius = node.isEntryPoint ? 18 : 12;\n    if (isSelected || isHovered) radius += 2;\n\n    // Overused indicator\n    const isOverused = metrics && metrics.usageCount >= 5;\n\n    return { radius, isOverused, isSelected, isHovered };\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"ec-svg\"\n    >\n      {/* Orbit guides */}\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.25}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.5}\n      />\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.42}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.3}\n      />\n\n      {/* Edges */}\n      {edges.map((edge, i) => {\n        const source = nodeMap.get(edge.source);\n        const target = nodeMap.get(edge.target);\n        if (!source || !target) return null;\n\n        const sourceAssigned = assignedEntityIds.has(edge.source);\n        const targetAssigned = assignedEntityIds.has(edge.target);\n        const sourceSelected = selectedEntityId === edge.source || hoveredNodeId === edge.source;\n        const targetSelected = selectedEntityId === edge.target || hoveredNodeId === edge.target;\n\n        // Determine edge color and style based on node states\n        let strokeColor = \"var(--border-color)\";\n        let strokeOpacity = 0.2;\n        let strokeWidth = 1 + edge.strength * 1.5;\n\n        if (sourceAssigned && targetAssigned) {\n          // Both assigned - green, prominent\n          strokeColor = \"var(--success)\";\n          strokeOpacity = 0.7;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if ((sourceAssigned && targetSelected) || (targetAssigned && sourceSelected)) {\n          // One assigned, one selected - orange/gold\n          strokeColor = \"var(--warning)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceSelected || targetSelected) {\n          // One selected, neither assigned - purple\n          strokeColor = \"var(--accent-color)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceAssigned || targetAssigned) {\n          // One assigned, not selected - cyan to show potential ensemble connections\n          strokeColor = \"#06b6d4\"; // cyan\n          strokeOpacity = 0.5;\n          strokeWidth = 1.5 + edge.strength * 1.5;\n        }\n\n        return (\n          <line\n            key={i}\n            x1={source.x}\n            y1={source.y}\n            x2={target.x}\n            y2={target.y}\n            stroke={strokeColor}\n            strokeWidth={strokeWidth}\n            strokeOpacity={strokeOpacity}\n          />\n        );\n      })}\n\n      {/* Nodes */}\n      {nodes.map((node) => {\n        const style = getNodeStyle(node);\n        const color = getKindColor(node.kind);\n\n        return (\n          <g\n            key={node.id}\n            className=\"ec-cursor-pointer\"\n            onClick={() => handleNodeClick(node.id)}\n            onMouseEnter={() => setHoveredNodeId(node.id)}\n            onMouseLeave={() => setHoveredNodeId(null)}\n          >\n            {/* Overused glow */}\n            {style.isOverused && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 4}\n                fill=\"none\"\n                stroke=\"var(--error)\"\n                strokeWidth={2}\n                opacity={0.6}\n              />\n            )}\n\n            {/* Selection ring */}\n            {style.isSelected && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 3}\n                fill=\"none\"\n                stroke=\"var(--accent-color)\"\n                strokeWidth={2}\n              />\n            )}\n\n            {/* Bridge indicator (unassigned node connected to 2+ assigned) */}\n            {!node.isAssigned && !node.isEntryPoint && bridgeNodeIds.has(node.id) && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"#f59e0b\"\n                strokeWidth={2}\n                strokeDasharray=\"2,2\"\n              />\n            )}\n\n            {/* Assigned indicator */}\n            {node.isAssigned && !node.isEntryPoint && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"var(--success)\"\n                strokeWidth={2}\n                strokeDasharray=\"3,2\"\n              />\n            )}\n\n            {/* Node circle with era-colored ring */}\n            <circle\n              cx={node.x}\n              cy={node.y}\n              r={style.radius}\n              fill={node.isEntryPoint ? \"var(--accent-color)\" : color}\n              stroke={style.isHovered ? \"white\" : node.eraColor}\n              strokeWidth={2}\n            />\n\n            {/* Entry point star */}\n            {node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={5}\n                fontSize=\"14\"\n                fill=\"white\"\n                fontWeight=\"bold\"\n                className=\"ec-no-pointer\"\n              >\n                \u2605\n              </text>\n            )}\n\n            {/* Kind initial for non-entry-point nodes */}\n            {!node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={4}\n                fontSize=\"9\"\n                fill=\"white\"\n                fontWeight=\"500\"\n                className=\"ec-no-pointer\"\n              >\n                {node.kind.charAt(0).toUpperCase()}\n              </text>\n            )}\n          </g>\n        );\n      })}\n\n      {/* Tooltip layer - rendered on top of all nodes */}\n      {(() => {\n        const tooltipNodeId = hoveredNodeId || selectedEntityId;\n        const tooltipNode = tooltipNodeId ? nodeMap.get(tooltipNodeId) : null;\n        if (!tooltipNode) return null;\n\n        const style = getNodeStyle(tooltipNode);\n        const metrics = tooltipNode.metrics;\n        const usageCount = metrics?.usageCount ?? 0;\n        const linksToEnsemble = (() => {\n          if (tooltipNode.isAssigned) return null; // Don't show for assigned\n          let count = 0;\n          for (const rel of relationships) {\n// ... (truncated)", "parameters": [{"name": "{\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}", "type": "Readonly<EnsembleConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx", "sourceCode": "export default function EnsembleHealthBar({\n  assignments,\n  candidates,\n  kindToCategory,\n}: Readonly<EnsembleHealthBarProps>) {\n  // Compute category stats\n  const stats = useMemo(() => {\n    // Get all unique categories from candidates\n    const allCategories = new Set<string>();\n    const kindMap = kindToCategory || new Map<string, string>();\n\n    for (const candidate of candidates) {\n      const category = kindMap.get(candidate.kind) || candidate.kind;\n      allCategories.add(category);\n    }\n\n    // Count assigned categories\n    const assignedCategories = new Map<string, number>();\n    for (const assignment of assignments) {\n      const category = kindMap.get(assignment.entityKind) || assignment.entityKind;\n      assignedCategories.set(category, (assignedCategories.get(category) || 0) + 1);\n    }\n\n    // Find missing categories\n    const missingCategories: string[] = [];\n    for (const category of allCategories) {\n      if (!assignedCategories.has(category)) {\n        missingCategories.push(category);\n      }\n    }\n\n    // Calculate coverage percentage\n    const coveredCount = assignedCategories.size;\n    const totalCount = allCategories.size;\n    const coveragePercent = totalCount > 0 ? (coveredCount / totalCount) * 100 : 0;\n\n    return {\n      categories: [...allCategories],\n      assignedCategories,\n      missingCategories,\n      coveragePercent,\n      coveredCount,\n      totalCount,\n    };\n  }, [assignments, candidates, kindToCategory]);\n\n  const getColor = (category: string): string => {\n    return CATEGORY_COLORS[category.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (stats.totalCount === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"ehb-wrap\">\n      {/* Header */}\n      <div className=\"ehb-header\">\n        <span className=\"ehb-title\">\n          Ensemble Diversity\n        </span>\n        <span\n          className=\"ehb-count\"\n          style={{\n            '--ehb-count-color': stats.coveragePercent === 100 ? \"var(--success)\" : \"var(--text-muted)\",\n          } as React.CSSProperties}\n        >\n          {stats.coveredCount}/{stats.totalCount} categories\n        </span>\n      </div>\n\n      {/* Segmented bar */}\n      <div className=\"ehb-bar\">\n        {stats.categories.map((category, i) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const width = `${100 / stats.totalCount}%`;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              title={`${category}: ${count} assigned`}\n              className=\"ehb-bar-segment\"\n              style={{\n                '--ehb-seg-width': width,\n                '--ehb-seg-bg': isCovered ? color : \"transparent\",\n                '--ehb-seg-opacity': isCovered ? 1 : 0.3,\n                '--ehb-seg-border': i < stats.categories.length - 1 ? \"1px solid var(--bg-tertiary)\" : \"none\",\n              } as React.CSSProperties}\n            />\n          );\n        })}\n      </div>\n\n      {/* Category legend */}\n      <div\n        className=\"ehb-legend\"\n        style={{\n          '--ehb-legend-mb': stats.missingCategories.length > 0 ? \"8px\" : \"0\",\n        } as React.CSSProperties}\n      >\n        {stats.categories.map((category) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              className=\"ehb-legend-item\"\n              style={{\n                '--ehb-item-color': isCovered ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                '--ehb-item-opacity': isCovered ? 1 : 0.6,\n              } as React.CSSProperties}\n            >\n              <span\n                className=\"ehb-legend-dot\"\n                style={{\n                  '--ehb-dot-bg': isCovered ? color : \"var(--bg-secondary)\",\n                  '--ehb-dot-border': isCovered ? \"none\" : `1px solid ${color}`,\n                } as React.CSSProperties}\n              />\n              <span className=\"ehb-legend-label\">\n                {category}\n                {count > 1 && ` (${count})`}\n              </span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Missing categories warning */}\n      {stats.missingCategories.length > 0 && (\n        <div className=\"ehb-warning\">\n          <span className=\"ehb-warning-icon\">\ud83d\udca1</span>\n          <span>\n            Consider adding:{\" \"}\n            {stats.missingCategories.map((cat, i) => (\n              <span key={cat}>\n                <span className=\"ehb-missing-cat\">{cat}</span>\n                {i < stats.missingCategories.length - 1 && \", \"}\n              </span>\n            ))}\n          </span>\n        </div>\n      )}\n\n      {/* All covered celebration */}\n      {stats.missingCategories.length === 0 && stats.totalCount > 1 && (\n        <div className=\"ehb-success\">\n          <span>\u2713</span>\n          <span>All categories represented - diverse ensemble!</span>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  assignments,\n  candidates,\n  kindToCategory,\n}", "type": "Readonly<EnsembleHealthBarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx", "sourceCode": "export default function EntityDetailCard({\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}: Readonly<EntityDetailCardProps>) {\n  // Empty state\n  if (!entity) {\n    return (\n      <div className=\"edc-empty\">\n        <div className=\"edc-empty-sub\">No entity selected</div>\n        <div className=\"edc-empty-hint\">Click a node to see details</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edc-card\">\n      {/* Header - compact */}\n      <div className=\"edc-header\">\n        <div className=\"edc-name-row\">\n          {entity.name}\n          {isEntryPoint && (\n            <span className=\"edc-entry-badge\">\n              Entry\n            </span>\n          )}\n          {isAssigned && !isEntryPoint && (\n            <span className=\"edc-assigned-badge\">\n              Assigned\n            </span>\n          )}\n        </div>\n        <div className=\"edc-kind-line\">\n          {entity.kind}\n          {entity.subtype && ` \u00b7 ${entity.subtype}`}\n        </div>\n      </div>\n\n      {/* Metrics - two rows: stats on top, story effects below */}\n      {(metrics || eraName) && (\n        <div className=\"edc-metrics\">\n          {/* Row 1: Basic stats */}\n          <div className=\"edc-metric-row\">\n            {metrics && (\n              <>\n                <MetricChip\n                  label={(() => {\n                    if (metrics.distance === 0) return \"Entry\";\n                    if (metrics.distance === 1) return \"Direct\";\n                    if (metrics.distance >= 99) return \"Distant\";\n                    return `${metrics.distance}-hop`;\n                  })()}\n                />\n                <MetricChip\n                  label={`${metrics.usageCount}x used`}\n                  variant={(() => {\n                    if (metrics.usageCount >= 5) return \"error\" as const;\n                    if (metrics.usageCount >= 2) return \"warning\" as const;\n                    return \"default\" as const;\n                  })()}\n                />\n                <MetricChip label={`${(metrics.avgStrength * 100).toFixed(0)}% link`} />\n              </>\n            )}\n            {eraName && <MetricChip label={eraName} customColor={eraColor} />}\n          </div>\n          {/* Row 2: Story effects (always separate line) */}\n          {(metrics?.addsNewCategory || (metrics && metrics.newRelTypes > 0)) && (\n            <div className=\"edc-metric-row\">\n              {metrics?.addsNewCategory && <MetricChip label=\"+category\" variant=\"accent\" />}\n              {metrics && metrics.newRelTypes > 0 && (\n                <MetricChip label={`+${metrics.newRelTypes} rel`} variant=\"accent\" />\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}", "type": "Readonly<EntityDetailCardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx", "sourceCode": "export default function FilterChips<T extends string>({\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}: Readonly<FilterChipsProps<T>>) {\n  const handleChipClick = (option: T) => {\n    const newSelected = new Set(selected);\n\n    if (newSelected.has(option)) {\n      newSelected.delete(option);\n    } else {\n      if (!multiSelect) {\n        newSelected.clear();\n      }\n      newSelected.add(option);\n    }\n\n    onSelectionChange(newSelected);\n  };\n\n  const handleClearAll = () => {\n    onSelectionChange(new Set());\n  };\n\n  const getChipColor = (option: T): string => {\n    if (getColor) return getColor(option);\n    return KIND_COLORS[option.toLowerCase()] || \"var(--accent-color)\";\n  };\n\n  const getDisplayLabel = (option: T): string => {\n    if (formatLabel) return formatLabel(option);\n    // Capitalize first letter\n    return option.charAt(0).toUpperCase() + option.slice(1);\n  };\n\n  return (\n    <div className=\"fc-wrap\">\n      {label && (\n        <div className=\"fc-header\">\n          <span className=\"fc-label\">\n            {label}\n          </span>\n          {selected.size > 0 && (\n            <button\n              onClick={handleClearAll}\n              className=\"fc-clear-btn\"\n            >\n              Clear\n            </button>\n          )}\n        </div>\n      )}\n\n      <div className=\"fc-chips\">\n        {options.map((option) => {\n          const isSelected = selected.has(option);\n          const color = getChipColor(option);\n\n          return (\n            <button\n              key={option}\n              onClick={() => handleChipClick(option)}\n              className=\"fc-chip\"\n              style={{\n                '--fc-chip-border': isSelected ? `1px solid ${color}` : \"1px solid var(--border-color)\",\n                '--fc-chip-bg': isSelected ? color : \"transparent\",\n                '--fc-chip-color': isSelected ? \"white\" : \"var(--text-secondary)\",\n                '--fc-chip-weight': isSelected ? 500 : 400,\n              } as React.CSSProperties}\n            >\n              {/* Color dot when not selected */}\n              {!isSelected && (\n                <span\n                  className=\"fc-chip-dot\"\n                  style={{\n                    '--fc-dot-bg': color,\n                  } as React.CSSProperties}\n                />\n              )}\n              {getDisplayLabel(option)}\n            </button>\n          );\n        })}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}", "type": "Readonly<FilterChipsProps<T>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx", "sourceCode": "export default function IntensitySparkline({\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}: Readonly<IntensitySparklineProps>) {\n  // Match padding with NarrativeTimeline for visual alignment\n  const padding = { left: 40, right: 40, top: 4, bottom: 4 };\n  const innerWidth = width - padding.left - padding.right;\n  const innerHeight = height - padding.top - padding.bottom;\n\n  // Build the SVG path\n  const { areaPath, linePath } = useMemo(() => {\n    if (points.length < 2) {\n      return { areaPath: \"\", linePath: \"\" };\n    }\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const scaleY = (intensity: number) => padding.top + (1 - intensity) * innerHeight;\n\n    // Build line path\n    const lineParts: string[] = [];\n    const areaParts: string[] = [];\n\n    points.forEach((point, i) => {\n      const x = scaleX(point.tick);\n      const y = scaleY(point.intensity);\n\n      if (i === 0) {\n        lineParts.push(`M ${x} ${y}`);\n        areaParts.push(`M ${x} ${height - padding.bottom}`);\n        areaParts.push(`L ${x} ${y}`);\n      } else {\n        lineParts.push(`L ${x} ${y}`);\n        areaParts.push(`L ${x} ${y}`);\n      }\n    });\n\n    // Close the area path\n    const lastX = scaleX(points[points.length - 1].tick);\n    areaParts.push(`L ${lastX} ${height - padding.bottom}`);\n    areaParts.push(\"Z\");\n\n    return {\n      areaPath: areaParts.join(\" \"),\n      linePath: lineParts.join(\" \"),\n    };\n  }, [points, extent, innerWidth, innerHeight, height, padding]);\n\n  // Build highlight rect for selected range\n  const highlightRect = useMemo(() => {\n    if (!selectedRange) return null;\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const x1 = scaleX(selectedRange[0]);\n    const x2 = scaleX(selectedRange[1]);\n\n    return {\n      x: Math.min(x1, x2),\n      width: Math.abs(x2 - x1),\n    };\n  }, [selectedRange, extent, innerWidth, padding]);\n\n  if (points.length < 2) {\n    return (\n      <svg width={width} height={height}>\n        <text\n          x={width / 2}\n          y={height / 2}\n          textAnchor=\"middle\"\n          fontSize=\"10\"\n          fill=\"var(--text-muted)\"\n        >\n          Not enough data\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={width} height={height} className=\"is-svg\">\n      {/* Selected range highlight */}\n      {highlightRect && (\n        <rect\n          x={highlightRect.x}\n          y={0}\n          width={highlightRect.width}\n          height={height}\n          fill=\"rgba(99, 102, 241, 0.15)\"\n        />\n      )}\n\n      {/* Area fill */}\n      <path d={areaPath} fill={fillColor} />\n\n      {/* Line stroke */}\n      <path d={linePath} fill=\"none\" stroke={strokeColor} strokeWidth={1.5} />\n\n      {/* Label */}\n      <text x={4} y={12} fontSize=\"9\" fill=\"var(--text-muted)\" fontFamily=\"inherit\">\n        Narrative Intensity\n      </text>\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}", "type": "Readonly<IntensitySparklineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx", "sourceCode": "export default function MiniConstellation({\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}: Readonly<MiniConstellationProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const centerRadius = 16;\n  const nodeRadius = 10;\n  const orbitRadius = size / 2 - nodeRadius - 12;\n\n  // Limit and arrange connections\n  const visibleConnections = useMemo(() => {\n    // Group by kind and take most diverse sample\n    const byKind = new Map<string, ConnectedEntity[]>();\n    for (const conn of connections) {\n      const list = byKind.get(conn.kind) || [];\n      list.push(conn);\n      byKind.set(conn.kind, list);\n    }\n\n    // Take one from each kind first, then fill remaining\n    const result: ConnectedEntity[] = [];\n    const kindIterators = [...byKind.values()].map((list) => list[Symbol.iterator]());\n\n    while (result.length < maxConnections && kindIterators.length > 0) {\n      for (let i = kindIterators.length - 1; i >= 0; i--) {\n        if (result.length >= maxConnections) break;\n        const next = kindIterators[i].next();\n        if (next.done) {\n          kindIterators.splice(i, 1);\n        } else {\n          result.push(next.value);\n        }\n      }\n    }\n\n    return result;\n  }, [connections, maxConnections]);\n\n  const hiddenCount = connections.length - visibleConnections.length;\n\n  // Position nodes in a circle\n  const nodePositions = useMemo(() => {\n    const count = visibleConnections.length;\n    if (count === 0) return [];\n\n    const angleStep = (2 * Math.PI) / count;\n    const startAngle = -Math.PI / 2; // Start from top\n\n    return visibleConnections.map((conn, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        ...conn,\n        x: cx + orbitRadius * Math.cos(angle),\n        y: cy + orbitRadius * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [visibleConnections, cx, cy, orbitRadius]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (connections.length === 0) {\n    return (\n      <svg width={size} height={size} className=\"mc-svg\">\n        {/* Center node */}\n        <circle cx={cx} cy={cy} r={centerRadius} fill=\"var(--accent-color)\" />\n        <text x={cx} y={cy} textAnchor=\"middle\" dy={3} fontSize=\"10\" fill=\"white\" fontWeight=\"500\">\n          \u2605\n        </text>\n        <text\n          x={cx}\n          y={cy + centerRadius + 14}\n          textAnchor=\"middle\"\n          fontSize=\"9\"\n          fill=\"var(--text-muted)\"\n        >\n          No connections\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={size} height={size} className=\"mc-svg\">\n      {/* Connection lines */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n        const strength = node.strength ?? 0.5;\n\n        return (\n          <line\n            key={i}\n            x1={cx}\n            y1={cy}\n            x2={node.x}\n            y2={node.y}\n            stroke={color}\n            strokeWidth={1 + strength * 2}\n            strokeOpacity={0.4 + strength * 0.4}\n          />\n        );\n      })}\n\n      {/* Outer nodes */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n\n        return (\n          <g key={i}>\n            {/* Node circle */}\n            <circle cx={node.x} cy={node.y} r={nodeRadius} fill={color} opacity={0.9} />\n            {/* Kind initial */}\n            <text\n              x={node.x}\n              y={node.y}\n              textAnchor=\"middle\"\n              dy={3}\n              fontSize=\"8\"\n              fill=\"white\"\n              fontWeight=\"500\"\n            >\n              {node.kind.charAt(0).toUpperCase()}\n            </text>\n            {/* Name label */}\n            <title>{`${node.name} (${node.kind})\\n${node.relationshipKind}`}</title>\n          </g>\n        );\n      })}\n\n      {/* Center node (entry point) */}\n      <circle\n        cx={cx}\n        cy={cy}\n        r={centerRadius}\n        fill=\"var(--accent-color)\"\n        stroke=\"white\"\n        strokeWidth={2}\n      />\n      <text x={cx} y={cy} textAnchor=\"middle\" dy={4} fontSize=\"12\" fill=\"white\" fontWeight=\"600\">\n        \u2605\n      </text>\n\n      {/* Center label */}\n      <text x={cx} y={size - 6} textAnchor=\"middle\" fontSize=\"9\" fill=\"var(--text-muted)\">\n        {visibleConnections.length} connections\n        {hiddenCount > 0 && ` (+${hiddenCount})`}\n      </text>\n\n      {/* Legend - show unique kinds */}\n      {(() => {\n        const uniqueKinds = [...new Set(visibleConnections.map((c) => c.kind))];\n        if (uniqueKinds.length <= 4) {\n          return (\n            <g>\n              {uniqueKinds.map((kind, i) => (\n                <g key={kind} transform={`translate(${4 + i * 40}, 4)`}>\n                  <circle cx={4} cy={6} r={4} fill={getKindColor(kind)} />\n                  <text x={12} y={9} fontSize=\"8\" fill=\"var(--text-muted)\">\n                    {kind.slice(0, 4)}\n                  </text>\n                </g>\n              ))}\n            </g>\n          );\n        }\n        return null;\n      })()}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}", "type": "Readonly<MiniConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx", "sourceCode": "export default function NarrativeTimeline({\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}: Readonly<NarrativeTimelineProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredEvent, setHoveredEvent] = useState<TooltipData | null>(null);\n  const [hoveredCastMarker, setHoveredCastMarker] = useState<CastTooltipData | null>(null);\n\n  const padding = { left: 40, right: 40, top: 24, bottom: 32 };\n  const hasCastMarkers = castMarkers && castMarkers.length > 0;\n  const castTrackHeight = hasCastMarkers ? 28 : 0;\n  const laneHeight = height - padding.top - padding.bottom;\n  const eventAreaTop = padding.top + 20; // Leave room for era labels\n  const eventAreaHeight = laneHeight - 20 - castTrackHeight;\n  const castBaselineY = eventAreaTop + eventAreaHeight + 4;\n  const castMarkerCenterY = castBaselineY + 12;\n\n  // Use provided extent or compute from events as fallback\n  const extent = useMemo(() => {\n    if (extentProp) return extentProp;\n    return computeTimelineExtent(events.map((e) => ({ tick: e.tick }) as any));\n  }, [extentProp, events]);\n\n  // Scale functions\n  const scaleX = useCallback(\n    (tick: number) => tickToX(tick, extent, width, padding.left),\n    [extent, width, padding.left]\n  );\n\n  // Position events to avoid overlap using simple row allocation\n  const eventPositions = useMemo(() => {\n    const positions = new Map<string, { x: number; y: number; height: number; row: number }>();\n    const rows: Array<{ endX: number }> = [];\n    const eventWidth = 24;\n    const eventGap = 4;\n\n    // Sort by tick\n    const sorted = [...events].sort((a, b) => a.tick - b.tick);\n\n    for (const event of sorted) {\n      const x = scaleX(event.tick);\n      const eventHeight = getEventHeight(event.significance, 50, 20);\n\n      // Find first available row\n      let row = 0;\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].endX + eventGap < x) {\n          row = i;\n          break;\n        }\n        row = i + 1;\n      }\n\n      // Ensure row exists\n      while (rows.length <= row) {\n        rows.push({ endX: 0 });\n      }\n      rows[row].endX = x + eventWidth;\n\n      // Calculate y position (stack from bottom)\n      const y = eventAreaTop + eventAreaHeight - eventHeight - row * 12;\n\n      positions.set(event.id, { x, y, height: eventHeight, row });\n    }\n\n    return positions;\n  }, [events, scaleX, eventAreaTop, eventAreaHeight]);\n\n  // Generate tick marks\n  const tickMarks = useMemo(() => {\n    const [minTick, maxTick] = extent;\n    const range = maxTick - minTick;\n    const step = Math.ceil(range / 8);\n    const marks: number[] = [];\n\n    for (let tick = Math.ceil(minTick / step) * step; tick <= maxTick; tick += step) {\n      marks.push(tick);\n    }\n\n    return marks;\n  }, [extent]);\n\n  const handleEventClick = useCallback(\n    (e: React.MouseEvent, eventId: string) => {\n      e.stopPropagation();\n      onToggleEvent(eventId);\n    },\n    [onToggleEvent]\n  );\n\n  const handleEventHover = useCallback((event: TimelineEvent | null, e?: React.MouseEvent) => {\n    if (event && e && svgRef.current) {\n      const rect = svgRef.current.getBoundingClientRect();\n      setHoveredEvent({\n        event,\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    } else {\n      setHoveredEvent(null);\n    }\n  }, []);\n\n  return (\n    <div className=\"nt-wrap\">\n      <svg\n        ref={svgRef}\n        width={width}\n        height={height}\n        className=\"nt-svg\"\n      >\n        {/* Era bands */}\n        {eraRanges.map((era) => {\n          // Clamp era boundaries to the usable timeline area\n          const x1 = Math.max(scaleX(era.startTick), padding.left);\n          const x2 = Math.min(scaleX(era.endTick), width - padding.right);\n          const isFocal = focalEraId === era.id;\n          const bandWidth = x2 - x1;\n\n          // Skip eras that fall entirely outside the visible range\n          if (bandWidth <= 0) return null;\n\n          return (\n            <g key={era.id}>\n              {/* Era background band */}\n              <rect\n                x={x1}\n                y={padding.top}\n                width={bandWidth}\n                height={laneHeight}\n                fill={era.color}\n                opacity={isFocal ? 0.15 : 0.08}\n              />\n              {/* Era divider line */}\n              <line\n                x1={x1}\n                y1={padding.top}\n                x2={x1}\n                y2={height - padding.bottom}\n                stroke={era.color}\n                strokeWidth={isFocal ? 2 : 1}\n                strokeDasharray={isFocal ? \"none\" : \"4,4\"}\n              />\n              {/* Era label */}\n              <text\n                x={x1 + 6}\n                y={padding.top + 14}\n                fontSize=\"10\"\n                fontWeight={isFocal ? 600 : 400}\n                fill={era.color}\n              >\n                {era.name}\n                {isFocal && \" \u2605\"}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Timeline axis */}\n        <line\n          x1={padding.left}\n          y1={height - padding.bottom}\n          x2={width - padding.right}\n          y2={height - padding.bottom}\n          stroke=\"var(--border-color)\"\n          strokeWidth={1}\n        />\n\n        {/* Tick marks */}\n        {tickMarks.map((tick) => {\n          const x = scaleX(tick);\n          return (\n            <g key={tick}>\n              <line\n                x1={x}\n                y1={height - padding.bottom}\n                x2={x}\n                y2={height - padding.bottom + 4}\n                stroke=\"var(--text-muted)\"\n                strokeWidth={1}\n              />\n              <text\n                x={x}\n                y={height - padding.bottom + 16}\n                textAnchor=\"middle\"\n                fontSize=\"9\"\n                fill=\"var(--text-muted)\"\n              >\n                {tick}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Event cards */}\n        {events.map((event) => {\n          const pos = eventPositions.get(event.id);\n          if (!pos) return null;\n\n          const fill = getEventFill(event);\n          const cardWidth = 20;\n\n          return (\n            <g\n              key={event.id}\n              className=\"nt-cursor-pointer\"\n              onClick={(e) => handleEventClick(e, event.id)}\n              onMouseEnter={(e) => handleEventHover(event, e)}\n              onMouseLeave={() => handleEventHover(null)}\n            >\n              {/* Event card */}\n              <rect\n                x={pos.x - cardWidth / 2}\n                y={pos.y}\n                width={cardWidth}\n                height={pos.height}\n                rx={3}\n                fill={fill}\n                opacity={event.selected ? 1 : 0.4}\n                stroke={event.selected ? \"white\" : \"transparent\"}\n                strokeWidth={event.selected ? 2 : 0}\n              />\n              {/* Selection checkmark */}\n              {event.selected && (\n                <text\n                  x={pos.x}\n                  y={pos.y + pos.height / 2 + 4}\n                  textAnchor=\"middle\"\n                  fontSize=\"12\"\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  className=\"nt-no-pointer\"\n                >\n                  \u2713\n                </text>\n              )}\n            </g>\n          );\n        })}\n\n        {/* Cast creation markers */}\n        {hasCastMarkers && (\n          <g>\n            {/* Dashed baseline */}\n            <line\n              x1={padding.left}\n              y1={castBaselineY}\n              x2={width - padding.right}\n              y2={castBaselineY}\n              stroke=\"var(--border-color)\"\n              strokeWidth={1}\n              strokeDasharray=\"4,3\"\n            />\n            {/* \"Cast\" label */}\n            <text\n              x={padding.left - 4}\n              y={castMarkerCenterY + 3}\n              textAnchor=\"end\"\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n            >\n              Cast\n            </text>\n            {/* Markers */}\n            {castMarkers.map((marker) => {\n              if (typeof marker.createdAt !== \"number\" || Number.isNaN(marker.createdAt))\n                return null;\n              const x = scaleX(marker.createdAt);\n              const shape = getCastMarkerShape(marker.entityKind);\n              const color = getCastMarkerColor(marker.entityKind);\n              const isHovered = hoveredCastMarker?.marker.entityId === marker.entityId;\n\n              return (\n                <g\n                  key={marker.entityId}\n                  className=\"nt-cursor-pointer\"\n                  onMouseEnter={(e) => {\n                    if (svgRef.current) {\n                      const rect = svgRef.current.getBoundingClientRect();\n                      setHoveredCastMarker({\n                        marker,\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                      });\n                    }\n                  }}\n                  onMouseLeave={() => setHoveredCastMarker(null)}\n                >\n                  {/* Vertical tick from baseline to marker */}\n                  <line\n                    x1={x}\n                    y1={castBaselineY}\n                    x2={x}\n                    y2={castMarkerCenterY - shape.size / 2}\n// ... (truncated)", "parameters": [{"name": "{\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}", "type": "Readonly<NarrativeTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx", "sourceCode": "export default function RoleSlot({\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}: Readonly<RoleSlotProps>) {\n  const canAccept = hasSelection && !isAtMax;\n  const count = assignments.length;\n\n  const wrapClass = `rs-wrap ${canAccept ? \"rs-wrap-accept\" : isUnderMin ? \"rs-wrap-undermin\" : \"rs-wrap-default\"}`;\n\n  return (\n    <div\n      onClick={canAccept ? onAssign : undefined}\n      className={wrapClass}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      {/* Role header - single line */}\n      <div className={`rs-header ${assignments.length > 0 || canAccept ? \"rs-header-mb\" : \"\"}`}>\n        <div className=\"rs-name-row\">\n          <span className={`rs-role-name ${isUnderMin ? \"rs-role-name-error\" : \"rs-role-name-default\"}`}>\n            {role.role}\n          </span>\n          <span className={`rs-role-count ${isUnderMin ? \"rs-role-count-error\" : \"rs-role-count-default\"}`}>\n            {count}/{role.count.max}\n          </span>\n        </div>\n\n        {canAccept && (\n          <span className=\"rs-add-label\">\n            + Add\n          </span>\n        )}\n      </div>\n\n      {/* Assigned entities - visually distinct from header */}\n      {assignments.length > 0 && (\n        <div className=\"rs-assignments\">\n          {assignments.map((assignment) => (\n            <div\n              key={assignment.entityId}\n              className=\"rs-assignment-row\"\n              onClick={(e) => e.stopPropagation()}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              {/* Entity name */}\n              <span className=\"rs-entity-name\">\n                {assignment.entityName}\n                <span className=\"rs-entity-kind\">\n                  {assignment.entityKind}\n                </span>\n              </span>\n\n              {/* Primary/Support toggle - full text, more button-like */}\n              <button\n                onClick={() => onTogglePrimary(assignment.entityId)}\n                className={`rs-toggle-btn ${assignment.isPrimary ? \"rs-toggle-btn-primary\" : \"rs-toggle-btn-support\"}`}\n                title=\"Click to toggle primary/support\"\n              >\n                {assignment.isPrimary ? \"Primary\" : \"Support\"}\n              </button>\n\n              {/* Remove button */}\n              <button\n                onClick={() => onRemove(assignment.entityId)}\n                className=\"rs-remove-btn\"\n                title=\"Remove from role\"\n              >\n                \u00d7\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}", "type": "Readonly<RoleSlotProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "export default function StoryPotentialRadar({\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}: Readonly<StoryPotentialRadarProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const maxRadius = size / 2 - (showLabels ? 28 : 8);\n  const numAxes = AXES.length;\n  const angleStep = (2 * Math.PI) / numAxes;\n  // Start from top (-90 degrees)\n  const startAngle = -Math.PI / 2;\n\n  // Compute axis endpoints\n  const axisPoints = useMemo(() => {\n    return AXES.map((_, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + maxRadius * Math.cos(angle),\n        y: cy + maxRadius * Math.sin(angle),\n        labelX: cx + (maxRadius + 14) * Math.cos(angle),\n        labelY: cy + (maxRadius + 14) * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Compute polygon points for the data\n  const dataPoints = useMemo(() => {\n    return AXES.map((axis, i) => {\n      const value = potential[axis.key as keyof StoryPotential];\n      const radius = value * maxRadius;\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n        value,\n        label: axis.label,\n      };\n    });\n  }, [potential, cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Build polygon path\n  const polygonPath =\n    dataPoints.map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x} ${p.y}`).join(\" \") + \" Z\";\n\n  // Grid rings (25%, 50%, 75%, 100%)\n  const gridRings = [0.25, 0.5, 0.75, 1];\n\n  return (\n    <svg width={size} height={size} className=\"spr-svg\">\n      {/* Background */}\n      <circle cx={cx} cy={cy} r={maxRadius} fill=\"var(--bg-tertiary)\" />\n\n      {/* Grid rings */}\n      {gridRings.map((ring) => (\n        <circle\n          key={ring}\n          cx={cx}\n          cy={cy}\n          r={maxRadius * ring}\n          fill=\"none\"\n          stroke=\"var(--border-color)\"\n          strokeWidth={ring === 1 ? 1 : 0.5}\n          strokeDasharray={ring === 1 ? \"none\" : \"2,2\"}\n        />\n      ))}\n\n      {/* Axis lines */}\n      {axisPoints.map((point, i) => (\n        <line\n          key={i}\n          x1={cx}\n          y1={cy}\n          x2={point.x}\n          y2={point.y}\n          stroke=\"var(--border-color)\"\n          strokeWidth={0.5}\n        />\n      ))}\n\n      {/* Data polygon */}\n      <path\n        d={polygonPath}\n        fill=\"rgba(99, 102, 241, 0.3)\"\n        stroke=\"var(--accent-color)\"\n        strokeWidth={2}\n      />\n\n      {/* Data points */}\n      {dataPoints.map((point, i) => (\n        <g key={i}>\n          <circle\n            cx={point.x}\n            cy={point.y}\n            r={4}\n            fill=\"var(--accent-color)\"\n            stroke=\"white\"\n            strokeWidth={1.5}\n          />\n          {interactive && <title>{`${point.label}: ${(point.value * 100).toFixed(0)}%`}</title>}\n        </g>\n      ))}\n\n      {/* Axis labels */}\n      {showLabels &&\n        axisPoints.map((point, i) => {\n          const axis = AXES[i];\n\n          // Adjust text anchor based on position\n          let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n          if (point.labelX < cx - 10) textAnchor = \"end\";\n          else if (point.labelX > cx + 10) textAnchor = \"start\";\n\n          // Adjust vertical position\n          let dy = 4;\n          if (point.labelY < cy - maxRadius * 0.5) dy = 12;\n          else if (point.labelY > cy + maxRadius * 0.5) dy = -2;\n\n          return (\n            <text\n              key={i}\n              x={point.labelX}\n              y={point.labelY}\n              dy={dy}\n              textAnchor={textAnchor}\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n              fontFamily=\"inherit\"\n            >\n              {axis.shortLabel}\n            </text>\n          );\n        })}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}", "type": "Readonly<StoryPotentialRadarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx", "sourceCode": "export default function TimelineBrush({\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}: Readonly<TimelineBrushProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [dragMode, setDragMode] = useState<DragMode>(\"none\");\n  const [dragStart, setDragStart] = useState<{ x: number; selection: [number, number] | null }>({\n    x: 0,\n    selection: null,\n  });\n\n  const handleSize = 8;\n\n  // Convert selection to pixel positions\n  const selectionPx = selection\n    ? {\n        left: tickToX(selection[0], extent, width, padding),\n        right: tickToX(selection[1], extent, width, padding),\n      }\n    : null;\n\n  const getMouseX = useCallback((e: React.MouseEvent | MouseEvent) => {\n    if (!svgRef.current) return 0;\n    const rect = svgRef.current.getBoundingClientRect();\n    return e.clientX - rect.left;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, mode: DragMode) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragMode(mode);\n      setDragStart({ x: getMouseX(e), selection });\n    },\n    [selection, getMouseX]\n  );\n\n  const handleBackgroundMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      const x = getMouseX(e);\n      // If clicking outside selection, start creating new selection\n      if (!selectionPx || x < selectionPx.left - handleSize || x > selectionPx.right + handleSize) {\n        setDragMode(\"create\");\n        const tick = xToTick(x, extent, width, padding);\n        setDragStart({ x, selection: [tick, tick] });\n        onSelectionChange([tick, tick]);\n      }\n    },\n    [selectionPx, extent, width, padding, getMouseX, onSelectionChange, handleSize]\n  );\n\n  useEffect(() => {\n    if (dragMode === \"none\") return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const x = getMouseX(e);\n      const dx = x - dragStart.x;\n\n      if (dragMode === \"create\") {\n        const startTick = dragStart.selection[0];\n        const currentTick = xToTick(x, extent, width, padding);\n        const newSelection: [number, number] =\n          currentTick >= startTick ? [startTick, currentTick] : [currentTick, startTick];\n        onSelectionChange(newSelection);\n        return;\n      }\n\n      if (!dragStart.selection) return;\n\n      const [startTick, endTick] = dragStart.selection;\n\n      if (dragMode === \"left\") {\n        const newLeft = xToTick(\n          tickToX(startTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.min(newLeft, endTick - 1);\n        onSelectionChange([Math.max(extent[0], clamped), endTick]);\n      } else if (dragMode === \"right\") {\n        const newRight = xToTick(\n          tickToX(endTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.max(newRight, startTick + 1);\n        onSelectionChange([startTick, Math.min(extent[1], clamped)]);\n      } else if (dragMode === \"move\") {\n        const tickDelta =\n          xToTick(dragStart.x + dx, extent, width, padding) -\n          xToTick(dragStart.x, extent, width, padding);\n        let newStart = startTick + tickDelta;\n        let newEnd = endTick + tickDelta;\n\n        // Clamp to extent\n        if (newStart < extent[0]) {\n          const shift = extent[0] - newStart;\n          newStart = extent[0];\n          newEnd += shift;\n        }\n        if (newEnd > extent[1]) {\n          const shift = newEnd - extent[1];\n          newEnd = extent[1];\n          newStart -= shift;\n        }\n\n        onSelectionChange([Math.max(extent[0], newStart), Math.min(extent[1], newEnd)]);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setDragMode(\"none\");\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [dragMode, dragStart, extent, width, padding, getMouseX, onSelectionChange]);\n\n  const getCursor = (mode: DragMode) => {\n    switch (mode) {\n      case \"left\":\n      case \"right\":\n        return \"ew-resize\";\n      case \"move\":\n        return \"grab\";\n      case \"create\":\n        return \"crosshair\";\n      default:\n        return \"crosshair\";\n    }\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"tb-svg\"\n      style={{\n        '--tb-cursor': getCursor(dragMode === \"none\" ? \"create\" : dragMode),\n      } as React.CSSProperties}\n      onMouseDown={handleBackgroundMouseDown}\n    >\n      {/* Background track */}\n      <rect\n        x={padding}\n        y={4}\n        width={width - 2 * padding}\n        height={height - 8}\n        rx={4}\n        fill=\"var(--bg-tertiary)\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n      />\n\n      {/* Selection */}\n      {selectionPx && selectionPx.right - selectionPx.left >= minSelectionWidth && (\n        <g>\n          {/* Selection rect */}\n          <rect\n            x={selectionPx.left}\n            y={4}\n            width={selectionPx.right - selectionPx.left}\n            height={height - 8}\n            rx={4}\n            fill=\"rgba(99, 102, 241, 0.3)\"\n            stroke=\"var(--accent-color)\"\n            strokeWidth={1}\n            className=\"tb-grab\"\n            onMouseDown={(e) => handleMouseDown(e, \"move\")}\n          />\n\n          {/* Left handle */}\n          <rect\n            x={selectionPx.left - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"left\")}\n          />\n\n          {/* Right handle */}\n          <rect\n            x={selectionPx.right - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"right\")}\n          />\n\n          {/* Selection label */}\n          {selection && (\n            <text\n              x={(selectionPx.left + selectionPx.right) / 2}\n              y={height / 2 + 4}\n              textAnchor=\"middle\"\n              fontSize=\"10\"\n              fontWeight=\"500\"\n              fill=\"var(--accent-color)\"\n              className=\"tb-no-pointer\"\n            >\n              {selection[0]} \u2013 {selection[1]}\n            </text>\n          )}\n        </g>\n      )}\n\n      {/* Instructions when no selection */}\n      {!selectionPx && (\n        <text\n          x={width / 2}\n          y={height / 2 + 4}\n          textAnchor=\"middle\"\n          fontSize=\"11\"\n          fill=\"var(--text-muted)\"\n          className=\"tb-no-pointer\"\n        >\n          Drag to select time range\n        </text>\n      )}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}", "type": "Readonly<TimelineBrushProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts::assembleSections", "name": "assembleSections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts", "sourceCode": "export function assembleSections(\n  plan: ChroniclePlan,\n  _context: ChronicleGenerationContext,\n  options: {\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  } = {}\n): AssemblyResult {\n  const { includeTitle = true, includeSectionTitles = false } = options;\n\n  try {\n    const missingSections = plan.sections.filter((s) => !s.generatedContent);\n    if (missingSections.length > 0) {\n      return {\n        success: false,\n        error: `Missing content for ${missingSections.length} section(s): ${missingSections.map((s) => s.name).join(\", \")}`,\n      };\n    }\n\n    const parts: string[] = [];\n\n    if (includeTitle) {\n      parts.push(`# ${plan.title}\\n\\n`);\n    }\n\n    for (let i = 0; i < plan.sections.length; i += 1) {\n      const section = plan.sections[i];\n\n      if (i > 0) {\n        parts.push(\"\\n\\n---\\n\\n\");\n      }\n\n      if (includeSectionTitles && section.name) {\n        parts.push(`## ${section.name}\\n\\n`);\n      }\n\n      parts.push(section.generatedContent || \"\");\n    }\n\n    const content = parts.join(\"\");\n\n    return {\n      success: true,\n      content,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error during assembly\",\n    };\n  }\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "_context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "options", "type": "{\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  }", "optional": true}], "returnType": "AssemblyResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatFocusSummary", "name": "formatFocusSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatFocusSummary(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n  const nameForId = (id: string) => entityMap.get(id)?.name || id;\n\n  const lines = [\n    `Focus Mode: ${plan.focus.mode}`,\n    `Entrypoint: ${nameForId(plan.focus.entrypointId)}`,\n    plan.focus.primaryEntityIds?.length\n      ? `Primary: ${plan.focus.primaryEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n    plan.focus.supportingEntityIds?.length\n      ? `Supporting: ${plan.focus.supportingEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n  ].filter(Boolean);\n\n  return lines.join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatEntityRoster", "name": "formatEntityRoster", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatEntityRoster(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n\n  if (!plan.entityRoles || plan.entityRoles.length === 0) {\n    return \"(none)\";\n  }\n\n  return plan.entityRoles\n    .map((role) => {\n      const entity = entityMap.get(role.entityId);\n      const name = entity?.name || role.entityId;\n      const kind = entity?.kind || \"unknown\";\n      const subtype = entity?.subtype ? `/${entity.subtype}` : \"\";\n      const culture = entity?.culture || \"(none)\";\n      const tags = formatTags(entity?.tags);\n\n      return `- ${name} (${kind}${subtype})\n  Role: ${role.role}\n  Contribution: ${role.contribution}\n  Culture: ${culture}\n  Tags: ${tags}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatIssueList", "name": "formatIssueList", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatIssueList(report: CohesionReport, plan?: ChroniclePlan): string {\n  if (!report.issues || report.issues.length === 0) {\n    return \"(no issues listed)\";\n  }\n\n  const sectionMap = new Map(plan?.sections?.map((s) => [s.id, s.name]) || []);\n\n  return report.issues\n    .map((issue, index) => {\n      const sectionName = issue.sectionId\n        ? sectionMap.get(issue.sectionId) || issue.sectionId\n        : \"General\";\n      const suggestion = issue.suggestion\n        ? `Suggestion: ${issue.suggestion}`\n        : \"Suggestion: (none provided)\";\n      return `${index + 1}. [${issue.severity}] ${issue.checkType} (Section: ${sectionName})\n   ${issue.description}\n   ${suggestion}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "report", "type": "CohesionReport", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts::parseJsonResponse", "name": "parseJsonResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts", "sourceCode": "export function parseJsonResponse<T>(response: string): T {\n  const extracted = extractJsonBlock(response);\n  let fixed = applyJsonFixes(extracted);\n\n  try {\n    return JSON.parse(fixed) as T;\n  } catch (firstError) {\n    fixed = applyAggressiveFixes(fixed);\n\n    try {\n      return JSON.parse(fixed) as T;\n    } catch (secondError) {\n      const message = (secondError as Error).message;\n      const posMatch = message.match(/position (\\d+)/);\n      if (posMatch) {\n        const errorPos = parseInt(posMatch[1], 10);\n        const before = fixed.substring(0, errorPos);\n        const after = fixed.substring(errorPos);\n        const lastChar = before.trim().slice(-1);\n        const firstChar = after.trim()[0];\n\n        if (\n          (lastChar === '\"' || lastChar === \"}\" || lastChar === \"]\") &&\n          (firstChar === '\"' || firstChar === \"{\" || firstChar === \"[\")\n        ) {\n          const patched = before + \",\" + after;\n          return JSON.parse(patched) as T;\n        }\n      }\n\n      throw firstError;\n    }\n  }\n}", "parameters": [{"name": "response", "type": "string", "optional": false}], "returnType": "T"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::buildReferenceLookup", "name": "buildReferenceLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function buildReferenceLookup<T>(\n  items: T[],\n  getId: (item: T) => string,\n  getName: (item: T) => string | undefined\n): ReferenceLookup {\n  const ids = new Map<string, string>();\n  const names = new Map<string, string | null>();\n\n  for (const item of items) {\n    const id = getId(item);\n    if (id) {\n      ids.set(normalizeId(id), id);\n    }\n    const name = getName(item);\n    if (!name) continue;\n    const normalized = normalizeName(name);\n    if (!names.has(normalized)) {\n      names.set(normalized, id);\n    } else if (names.get(normalized) !== id) {\n      names.set(normalized, null);\n    }\n  }\n\n  return { ids, names };\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "getId", "type": "(item: T) => string", "optional": false}, {"name": "getName", "type": "(item: T) => string | undefined", "optional": false}], "returnType": "ReferenceLookup"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::resolveReference", "name": "resolveReference", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function resolveReference(value: string, lookup: ReferenceLookup): string {\n  const rawValue = String(value);\n  const directMatch = lookup.ids.get(normalizeId(rawValue));\n  if (directMatch) {\n    return directMatch;\n  }\n  const nameMatch = lookup.names.get(normalizeName(rawValue));\n  return nameMatch || rawValue;\n}", "parameters": [{"name": "value", "type": "string", "optional": false}, {"name": "lookup", "type": "ReferenceLookup", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts::parseValidationResponse", "name": "parseValidationResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts", "sourceCode": "export function parseValidationResponse(response: string, plan: ChroniclePlan): CohesionReport {\n  let jsonStr = response;\n  // eslint-disable-next-line sonarjs/slow-regex -- bounded LLM response text\n  const jsonMatch = response.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1];\n  }\n\n  const parsed = JSON.parse(jsonStr.trim());\n\n  const report: CohesionReport = {\n    overallScore: typeof parsed.overallScore === \"number\" ? parsed.overallScore : 50,\n    checks: {\n      plotStructure: normalizeCheck(parsed.checks?.plotStructure),\n      entityConsistency: normalizeCheck(parsed.checks?.entityConsistency),\n      sectionGoals: normalizeSectionGoals(parsed.checks?.sectionGoals, plan.sections),\n      resolution: normalizeCheck(parsed.checks?.resolution),\n      factualAccuracy: normalizeCheck(parsed.checks?.factualAccuracy),\n      themeExpression: normalizeCheck(parsed.checks?.themeExpression),\n    },\n    issues: (parsed.issues || []).map(normalizeIssue),\n    generatedAt: Date.now(),\n  };\n\n  return report;\n}", "parameters": [{"name": "response", "type": "string", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": false}], "returnType": "CohesionReport"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditSystemPrompt", "name": "buildCopyEditSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// System prompt\n// =============================================================================\n\nexport function buildCopyEditSystemPrompt(format: \"story\" | \"document\"): string {\n  if (format === \"document\") {\n    return `You are a senior editor doing a final polish on an in-universe document that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, tighter, more convincing as an artifact \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every piece of information the document conveys. If the same information appears in two sections that serve different purposes (e.g. a summary and a detailed account), both belong. If two sections serve the same purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Nothing the document *says* changes, but it shouldn't say the same thing twice for the same reason.\n- The document's voice and register. A bureaucratic report should stay bureaucratic. A folk collection should stay collected. Do not normalize register across sections that are intentionally different (e.g. quoted material vs. editorial framing).\n- World details. Names, places, customs, terminology, formatting conventions \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the register, density, or level of formality shifts abruptly between sections, ease the transition. The document should read as a single coherent artifact.\n\nTighten. Every word should earn its place. Look for redundant framing (\"it should be noted that\"), bureaucratic padding that doesn't serve the document's voice, repeated information that appears in multiple sections for the same purpose, and explanations that duplicate what the document already establishes.\n\nCut what doesn't work. If a section catalogs information without purpose, repeats the same content in template form, or pads the document without adding substance, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as document text \u2014 should be broken or cut.\n\nRead for consistency. Formatting conventions (headers, dates, citations, marginalia) should be uniform throughout. Where a convention appears in one section but not another, extend it.\n\nWhat you must not do:\n- Do not add new content, information, sections, or world details.\n- Do not impose a different voice on the document. Burnish the voice that is already there.\n- Do not restructure sections unless they are genuinely confusing.\n- Do not modernize or standardize language that is intentionally archaic or formal.\n\nYour changes should be invisible. A reader should not be able to tell the document was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n  }\n\n  return `You are a senior fiction editor doing a final polish on a piece that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, clearer, more efficient \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every plot point and beat. If two scenes serve the same narrative purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Scenes that cover the same event from different perspectives or for different reasons each belong; scenes that do the same dramatic work twice do not. Nothing that *happens* in the story changes, but the reader shouldn't experience the same purpose served twice.\n- Character voices. Where characters speak in distinct registers \u2014 dialect, formality, cultural cadence \u2014 that is intentional. Do not standardize dialogue or testimony into a uniform voice.\n- World details. Names, places, customs, terminology \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the prose rhythm changes abruptly \u2014 a shift in sentence length, descriptive density, or level of ornateness \u2014 ease the transition. The reader should never feel a bump between sections.\n\nTighten. Every word should earn its place. Look for filter words that create distance (\"she noticed,\" \"he felt\"), redundant modifiers, stage directions that reveal nothing about character, and emotional explanations that duplicate what the prose already shows. Where the same detail appears twice because it was imported from two different drafts, keep whichever instance lands harder and cut the other.\n\nCut what doesn't work. If a passage catalogs names or events in sequence, repeats the same dramatic beat in parallel structure (e.g., three characters experiencing the same effect in the same paragraph shape), or reads as a report of what happened rather than lived experience, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as narrative \u2014 should be broken or cut.\n\nRead for rhythm. Where a sentence fights you or the prose stumbles, recast it \u2014 but preserve its content and intent. If a passage is deliberately languid or dense, that may be the style working as intended. Only intervene where the prose works against the effect it is trying to achieve.\n\nWhat you must not do:\n- Do not add new content, ideas, scenes, details, or metaphors.\n- Do not impose a different voice on the narration. Burnish the voice that is already there.\n- Do not restructure paragraphs unless they are genuinely confusing.\n- Do not flatten distinctive character speech into standard grammar.\n\nYour changes should be invisible. A reader should not be able to tell the text was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n}", "parameters": [{"name": "format", "type": "\"story\" | \"document\"", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditUserPrompt", "name": "buildCopyEditUserPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// User prompt\n// =============================================================================\n\nexport function buildCopyEditUserPrompt(\n  text: string,\n  style: NarrativeStyle,\n  voiceContext?: {\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }\n): string {\n  const target = getWordCountRange(style);\n  const currentWords = countWords(text);\n  const styleName = style.name;\n  const craftPosture =\n    \"craftPosture\" in style ? (style.craftPosture) : undefined;\n\n  const parts: string[] = [];\n\n  parts.push(`## Format\\n${styleName}`);\n\n  parts.push(\n    `## Length\\nThe piece is ${currentWords} words. The natural range for this format is ${target.min}\u2013${target.max}. Use this as context for what length feels natural, but your job is to improve the prose, not to hit a number. If the piece needs to be shorter, cut what doesn't work. If it needs room, let it breathe.`\n  );\n\n  if (craftPosture) {\n    parts.push(`## Craft Posture\\n${craftPosture}`);\n  }\n\n  // Voice textures help the editor recognize intentional prose choices\n  const nv = voiceContext?.narrativeVoice;\n  if (nv && Object.keys(nv).length > 0) {\n    const voiceLines = Object.entries(nv)\n      .map(([key, value]) => `**${key}**: ${value}`)\n      .join(\"\\n\");\n    parts.push(`## Voice Textures (preserve these \u2014 they are intentional)\\n${voiceLines}`);\n  }\n\n  // Motifs help the editor recognize structural repetition vs draft artifacts\n  const motifs = voiceContext?.motifs;\n  if (motifs && motifs.length > 0) {\n    const motifLines = motifs.map((m) => `- \"${m}\"`).join(\"\\n\");\n    parts.push(\n      `## Recurring Motifs (these are structural \u2014 do not cut or collapse)\\n${motifLines}`\n    );\n  }\n\n  parts.push(`## Text\\n\\n${text}`);\n\n  return parts.join(\"\\n\\n\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "voiceContext", "type": "{\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }", "optional": true}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::applyWikilinks", "name": "applyWikilinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Apply wikilinks to content deterministically.\n * Replaces entity name mentions with [[entity]] syntax.\n *\n * Process: Replaces all mentions in a single pass using a combined regex\n * to avoid offset issues from multiple sequential replacements.\n */\nexport function applyWikilinks(content: string, entities: EntityContext[]): string {\n  // Filter and sort entities by name length descending\n  // (match longer names first to avoid partial matches)\n  const validEntities = entities\n    .filter((e) => e.name.length >= 3)\n    .sort((a, b) => b.name.length - a.name.length);\n\n  if (validEntities.length === 0) return content;\n\n  // Build a single regex that matches any entity name\n  const patterns = validEntities.map((e) => `\\\\b${escapeRegex(e.name)}\\\\b`);\n  const combinedPattern = new RegExp(`(${patterns.join(\"|\")})`, \"gi\");\n\n  // Single pass replacement - check each match to see if already linked\n  return content.replace(combinedPattern, (match, _group, offset) => {\n    // Check if this position is already inside a wikilink\n    if (isInsideWikilink(content, offset)) {\n      return match;\n    }\n    return `[[${match}]]`;\n  });\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult"}]