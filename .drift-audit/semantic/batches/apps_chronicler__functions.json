[{"id": "apps/chronicler/webui/src/ChroniclerRemote.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/ChroniclerRemote.tsx", "sourceCode": "export default function ChroniclerRemote({\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedWorldData,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}: Readonly<ChroniclerRemoteProps>) {\n  const { worldData, loading, loadError } = useWorldDataLoader({\n    projectId,\n    activeSlotIndex,\n    dexieSeededAt,\n    preloadedWorldData,\n  });\n\n  if (loading || loadError || !worldData) {\n    return <ChroniclerStatusScreen loading={loading} loadError={loadError} />;\n  }\n\n  return (\n    <WikiExplorer\n      projectId={projectId}\n      worldData={worldData}\n      loreData={null}\n      requestedPageId={requestedPageId}\n      onRequestedPageConsumed={onRequestedPageConsumed}\n      preloadedChronicles={preloadedChronicles}\n      preloadedStaticPages={preloadedStaticPages}\n      preloadedEraNarratives={preloadedEraNarratives}\n      prebakedParchmentUrl={prebakedParchmentUrl}\n      precomputedPageIndex={precomputedPageIndex}\n    />\n  );\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex = 0,\n  dexieSeededAt,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedWorldData,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}", "type": "Readonly<ChroniclerRemoteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/ChronicleIndex.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ChronicleIndex.tsx", "sourceCode": "export default function ChronicleIndex({\n  chronicles,\n  eraNarrativePages = [],\n  filter,\n  onNavigate,\n}: Readonly<ChronicleIndexProps>) {\n  const [sortMode, setSortMode] = useState(\"era_asc\");\n\n  const filtered = useMemo(() => {\n    return chronicles\n      .filter((page) => page.chronicle)\n      .filter((page) => {\n        if (filter.kind === \"all\") return true;\n        if (filter.kind === \"format\") return page.chronicle?.format === filter.format;\n        if (filter.kind === \"type\") return page.chronicle?.narrativeStyleId === filter.typeId;\n        if (filter.kind === \"era\") {\n          const focalEraId = page.chronicle?.temporalContext?.focalEra?.id;\n          if (focalEraId !== filter.eraId) return false;\n          if (filter.format && page.chronicle?.format !== filter.format) return false;\n          return true;\n        }\n        return true;\n      });\n  }, [chronicles, filter]);\n\n  const sorted = useMemo(() => {\n    const getEraInfo = (page: WikiPage) => {\n      const focalEra = page.chronicle?.temporalContext?.focalEra;\n      if (!focalEra) {\n        return { order: Number.POSITIVE_INFINITY, name: \"\", hasEra: false };\n      }\n      if (typeof focalEra.order === \"number\") {\n        return { order: focalEra.order, name: focalEra.name || \"\", hasEra: true };\n      }\n      if (typeof focalEra.startTick === \"number\") {\n        return { order: focalEra.startTick, name: focalEra.name || \"\", hasEra: true };\n      }\n      return { order: Number.POSITIVE_INFINITY, name: focalEra.name || \"\", hasEra: true };\n    };\n\n    return [...filtered].sort((a, b) => {\n      switch (sortMode) {\n        case \"era_asc\": {\n          const eraA = getEraInfo(a);\n          const eraB = getEraInfo(b);\n          if (eraA.hasEra !== eraB.hasEra) return eraA.hasEra ? -1 : 1;\n          if (eraA.order !== eraB.order) return eraA.order - eraB.order;\n          return eraA.name.localeCompare(eraB.name);\n        }\n        case \"era_desc\": {\n          const eraA = getEraInfo(a);\n          const eraB = getEraInfo(b);\n          if (eraA.hasEra !== eraB.hasEra) return eraA.hasEra ? -1 : 1;\n          if (eraA.order !== eraB.order) return eraB.order - eraA.order;\n          return eraB.name.localeCompare(eraA.name);\n        }\n        case \"updated_desc\":\n        default:\n          return (b.lastUpdated || 0) - (a.lastUpdated || 0);\n      }\n    });\n  }, [filtered, sortMode]);\n\n  // Build era narrative lookup by era name (label used in groups)\n  const eraNarrativeByEraName = useMemo(() => {\n    const map = new Map<string, WikiPage>();\n    for (const page of eraNarrativePages) {\n      if (page.eraNarrative) {\n        map.set(page.title, page); // era narrative title = era name\n      }\n    }\n    return map;\n  }, [eraNarrativePages]);\n\n  const groupedByEra = useMemo(() => {\n    const groups = new Map<\n      string,\n      { label: string; order: number; hasEra: boolean; items: WikiPage[] }\n    >();\n\n    const getEraInfo = (page: WikiPage) => {\n      const focalEra = page.chronicle?.temporalContext?.focalEra;\n      if (!focalEra) {\n        return { order: Number.POSITIVE_INFINITY, label: \"Unknown Era\", hasEra: false };\n      }\n      if (typeof focalEra.order === \"number\") {\n        return { order: focalEra.order, label: focalEra.name || \"Unknown Era\", hasEra: true };\n      }\n      if (typeof focalEra.startTick === \"number\") {\n        return { order: focalEra.startTick, label: focalEra.name || \"Unknown Era\", hasEra: true };\n      }\n      return {\n        order: Number.POSITIVE_INFINITY,\n        label: focalEra.name || \"Unknown Era\",\n        hasEra: true,\n      };\n    };\n\n    for (const page of sorted) {\n      const info = getEraInfo(page);\n      if (!groups.has(info.label)) {\n        groups.set(info.label, {\n          label: info.label,\n          order: info.order,\n          hasEra: info.hasEra,\n          items: [],\n        });\n      }\n      groups.get(info.label)?.items.push(page);\n    }\n\n    const entries = Array.from(groups.values());\n    if (sortMode === \"era_asc\" || sortMode === \"era_desc\") {\n      entries.sort((a, b) => {\n        if (a.hasEra !== b.hasEra) return a.hasEra ? -1 : 1;\n        if (a.order !== b.order) {\n          return sortMode === \"era_asc\" ? a.order - b.order : b.order - a.order;\n        }\n        return a.label.localeCompare(b.label);\n      });\n    }\n    return entries;\n  }, [sorted, sortMode]);\n\n  // Get era name for era-based filters\n  const eraName = useMemo(() => {\n    if (filter.kind !== \"era\") return null;\n    const chronicle = chronicles.find(\n      (c) => c.chronicle?.temporalContext?.focalEra?.id === filter.eraId\n    );\n    return chronicle?.chronicle?.temporalContext?.focalEra?.name || \"Unknown Era\";\n  }, [chronicles, filter]);\n\n  let heading: string;\n  if (filter.kind === \"format\") {\n    heading = filter.format === \"story\" ? \"Stories\" : \"Documents\";\n  } else if (filter.kind === \"type\") {\n    heading = `${formatChronicleSubtype(filter.typeId)} Chronicles`;\n  } else if (filter.kind === \"era\") {\n    if (filter.format === \"story\") {\n      heading = `Stories: ${eraName}`;\n    } else if (filter.format === \"document\") {\n      heading = `Documents: ${eraName}`;\n    } else {\n      heading = `Chronicles: ${eraName}`;\n    }\n  } else {\n    heading = \"Chronicles\";\n  }\n\n  let description: string;\n  if (filter.kind === \"all\") {\n    description = \"Accepted chronicles from Illuminator.\";\n  } else if (filter.kind === \"format\") {\n    const formatLabel = filter.format === \"story\" ? \"stories\" : \"documents\";\n    description = `Accepted ${formatLabel} from Illuminator.`;\n  } else if (filter.kind === \"era\") {\n    if (filter.format) {\n      const eraFormatLabel = filter.format === \"story\" ? \"Stories\" : \"Documents\";\n      description = `${eraFormatLabel} set during the ${eraName}.`;\n    } else {\n      description = `Chronicles set during the ${eraName}.`;\n    }\n  } else {\n    description = `Accepted chronicles of type ${formatChronicleSubtype(filter.typeId)}.`;\n  }\n\n  if (sorted.length === 0) {\n    return (\n      <div className={styles.container}>\n        <h1 className={styles.heading}>{heading}</h1>\n        <p className={styles.description}>{description}</p>\n        <div className={styles.empty}>No chronicles found.</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <h1 className={styles.heading}>{heading}</h1>\n      <div className={styles.descriptionRow}>\n        <p className={styles.description}>{description}</p>\n        <div className={styles.controls}>\n          <div className={styles.sortControl}>\n            <span className={styles.sortLabel}>Sort</span>\n            <select\n              className={styles.sortSelect}\n              value={sortMode}\n              onChange={(event) => setSortMode(event.target.value)}\n            >\n              {SORT_OPTIONS.map((option) => (\n                <option key={option.value} value={option.value}>\n                  {option.label}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      </div>\n\n      <div className={styles.list}>\n        {groupedByEra.map((group) => (\n          <div key={group.label} className={styles.group}>\n            <div className={styles.groupHeader}>{group.label}</div>\n            <div className={styles.groupItems}>\n              {/* Era narrative at the top of the group */}\n              {eraNarrativeByEraName.has(group.label) &&\n                (() => {\n                  const narrativePage = eraNarrativeByEraName.get(group.label)!;\n                  const thesis = narrativePage.content?.summary || \"\";\n                  return (\n                    <button\n                      key={narrativePage.id}\n                      className={styles.item}\n                      onClick={() => onNavigate(narrativePage.id)}\n                    >\n                      <div className={styles.itemHeader}>\n                        <span className={styles.itemTitle}>{narrativePage.title}</span>\n                        <div className={styles.badgeGroup}>\n                          <span className={styles.badge}>Era Narrative</span>\n                          <span className={styles.badgeSecondary}>synthetic</span>\n                        </div>\n                      </div>\n                      {thesis && <div className={styles.itemSummary}>{thesis}</div>}\n                    </button>\n                  );\n                })()}\n              {group.items.map((page) => {\n                const eraLabel = page.chronicle?.temporalContext?.focalEra?.name || \"Unknown Era\";\n                const isMultiEra = page.chronicle?.temporalContext?.isMultiEra;\n                const formatLabel = page.chronicle?.format === \"document\" ? \"Document\" : \"Story\";\n                const subtypeLabel = page.chronicle?.narrativeStyleId\n                  ? formatChronicleSubtype(page.chronicle.narrativeStyleId)\n                  : null;\n                const primaryEntities = (page.chronicle?.roleAssignments || [])\n                  .filter((role) => role.isPrimary)\n                  .map((role) => role.entityName)\n                  .filter(Boolean);\n                const primaryLabel = primaryEntities.length > 0 ? primaryEntities.join(\", \") : null;\n                const summary = page.content?.summary || \"\";\n\n                return (\n                  <button key={page.id} className={styles.item} onClick={() => onNavigate(page.id)}>\n                    <div className={styles.itemHeader}>\n                      <span className={styles.itemTitle}>{page.title}</span>\n                      <div className={styles.badgeGroup}>\n                        <span className={styles.badge}>{formatLabel}</span>\n                        {subtypeLabel && (\n                          <span className={styles.badgeSecondary}>{subtypeLabel}</span>\n                        )}\n                      </div>\n                    </div>\n                    <div className={styles.itemMeta}>\n                      <span>Era: {eraLabel}</span>\n                      {isMultiEra && <span>Multi-era</span>}\n                      {primaryLabel && <span>Primary: {primaryLabel}</span>}\n                    </div>\n                    {summary && <div className={styles.itemSummary}>{summary}</div>}\n                  </button>\n                );\n              })}\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  chronicles,\n  eraNarrativePages = [],\n  filter,\n  onNavigate,\n}", "type": "Readonly<ChronicleIndexProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/ChroniclerStatusScreen.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ChroniclerStatusScreen.tsx", "sourceCode": "export default function ChroniclerStatusScreen({\n  loading,\n  loadError,\n}: Readonly<ChroniclerStatusScreenProps>) {\n  if (loading) {\n    return (\n      <div className={styles.container}>\n        <div className={styles.content}>\n          <div className={styles.title}>Loading World Data</div>\n          <div className={styles.detail}>Reading from local storage...</div>\n        </div>\n      </div>\n    );\n  }\n\n  if (loadError) {\n    return (\n      <div className={styles.container}>\n        <div className={styles.content}>\n          <div className={styles.icon}>&#x2756;</div>\n          <div className={styles.title}>World Data Unavailable</div>\n          <div className={styles.detail}>{loadError}</div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.content}>\n        <div className={styles.icon}>&#x2756;</div>\n        <div className={styles.title}>No World Data</div>\n        <div className={styles.detail}>\n          Run a simulation in Lore Weave and enrich it with Illuminator to view the world chronicle.\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  loading,\n  loadError,\n}", "type": "Readonly<ChroniclerStatusScreenProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/EntityTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/EntityTimeline.tsx", "sourceCode": "export default function EntityTimeline({\n  events,\n  entityId,\n  entityIndex,\n  onNavigate,\n  onHoverEnter,\n  onHoverLeave,\n  loading = false,\n}: Readonly<EntityTimelineProps>) {\n  // Multi-expand state: set of expanded event IDs\n  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());\n  // Whether to show prominence-only events (default: hidden)\n  const [showProminenceOnly, setShowProminenceOnly] = useState(false);\n\n  /**\n   * Check if an event is \"prominence-only\" for this entity.\n   * An event is prominence-only if ALL of its effects for this entity\n   * are field_changed effects on the 'prominence' field.\n   */\n  const isProminenceOnlyEvent = useCallback(\n    (event: NarrativeEvent): boolean => {\n      const participant = event.participantEffects?.find((p) => p.entity.id === entityId);\n      if (!participant || participant.effects.length === 0) return false;\n\n      // Check if ALL effects are prominence field changes\n      return participant.effects.every(\n        (effect) => effect.type === \"field_changed\" && effect.field === \"prominence\"\n      );\n    },\n    [entityId]\n  );\n\n  // Filter and process events for this entity\n  const relevantEvents = useMemo(() => {\n    return events\n      .filter((event) => {\n        // Check if entity appears in participantEffects\n        if (!event.participantEffects?.some((p) => p.entity.id === entityId)) {\n          return false;\n        }\n        // Exclude prominence-only events unless checkbox is checked\n        if (!showProminenceOnly && isProminenceOnlyEvent(event)) {\n          return false;\n        }\n        return true;\n      })\n      .sort((a, b) => a.tick - b.tick); // Chronological order\n  }, [events, entityId, isProminenceOnlyEvent, showProminenceOnly]);\n\n  // Get participant effects for the current entity\n  const getEntityEffects = useCallback(\n    (event: NarrativeEvent): EntityEffect[] => {\n      const participant = event.participantEffects?.find((p) => p.entity.id === entityId);\n      return participant?.effects ?? [];\n    },\n    [entityId]\n  );\n\n  // Toggle expand state for an event\n  const toggleExpand = useCallback((eventId: string) => {\n    setExpandedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(eventId)) {\n        next.delete(eventId);\n      } else {\n        next.add(eventId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Get era name from entity index\n  const getEraName = useCallback(\n    (eraId: string): string => {\n      const era = entityIndex.get(eraId);\n      return era?.name ?? eraId;\n    },\n    [entityIndex]\n  );\n\n  // Build linkable entities list for entity linking\n  const linkableEntities = useMemo(() => {\n    return Array.from(entityIndex.values()).map((e) => ({ name: e.name, id: e.id }));\n  }, [entityIndex]);\n\n  // Render description with wiki links\n  const renderDescription = useCallback(\n    // eslint-disable-next-line sonarjs/function-return-type -- returns React.ReactNode by design\n    (event: NarrativeEvent): React.ReactNode => {\n      const description = event.description || \"\";\n      return linkifyText(description, linkableEntities, onNavigate, {\n        linkStyle: entityLinkStyle,\n        onHoverEnter,\n        onHoverLeave,\n      });\n    },\n    [linkableEntities, onNavigate, onHoverEnter, onHoverLeave]\n  );\n\n  if (relevantEvents.length === 0 && !showProminenceOnly) {\n    return (\n      <div className={styles.container}>\n        <label className={styles.filterRow}>\n          <input\n            type=\"checkbox\"\n            checked={showProminenceOnly}\n            onChange={(e) => setShowProminenceOnly(e.target.checked)}\n            className={styles.checkbox}\n          />\n          <span className={styles.checkboxLabel}>Show prominence-only events</span>\n        </label>\n        <div className={styles.emptyState}>\n          {loading\n            ? \"Loading narrative history...\"\n            : \"No timeline events recorded for this entity.\"}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.container}>\n      <label className={styles.filterRow}>\n        <input\n          type=\"checkbox\"\n          checked={showProminenceOnly}\n          onChange={(e) => setShowProminenceOnly(e.target.checked)}\n          className={styles.checkbox}\n        />\n        <span className={styles.checkboxLabel}>Show prominence-only events</span>\n      </label>\n      <table className={styles.table}>\n        <thead>\n          <tr className={styles.headerRow}>\n            <th className={styles.thTick}>Tick</th>\n            <th className={styles.thEra}>Era</th>\n            <th className={styles.th}>Event</th>\n            <th className={styles.thExpand}></th>\n          </tr>\n        </thead>\n        <tbody>\n          {relevantEvents.map((event) => {\n            const isExpanded = expandedIds.has(event.id);\n            const effects = getEntityEffects(event);\n            const canExpand = effects.length > 0;\n\n            return (\n              <React.Fragment key={event.id}>\n                {/* Main event row */}\n                <tr\n                  className={isExpanded ? styles.rowExpanded : styles.row}\n                  onClick={() => canExpand && toggleExpand(event.id)}\n                >\n                  <td className={`${styles.td} ${styles.tdTick}`}>{event.tick}</td>\n                  <td className={`${styles.td} ${styles.tdEra}`}>{getEraName(event.era)}</td>\n                  <td\n                    className={`${styles.td} ${styles.tdEvent} ${getWeightClass(getWeightTier(event.significance ?? 0.5))}`}\n                  >\n                    {renderDescription(event)}\n                  </td>\n                  <td className={`${styles.td} ${styles.tdExpand}`}>\n                    {canExpand && (\n                      <span\n                        className={`${styles.expandIcon} ${isExpanded ? styles.expandIconOpen : \"\"}`}\n                      >\n                        \u25b6\n                      </span>\n                    )}\n                  </td>\n                </tr>\n\n                {/* Expanded effects row */}\n                {isExpanded && (\n                  <tr className={styles.effectsRow}>\n                    <td colSpan={4} className={styles.effectsCell}>\n                      {effects.length > 0 ? (\n                        <ul className={styles.effectsList}>\n                          {effects.map((effect, idx) => {\n                            const { icon, colorClass } = getEffectStyle(effect.type);\n                            return (\n                              <li key={idx} className={styles.effectItem}>\n                                <span className={`${styles.effectIcon} ${colorClass}`}>{icon}</span>\n                                <span className={styles.effectDescription}>\n                                  {linkifyText(effect.description, linkableEntities, onNavigate, {\n                                    linkStyle: entityLinkStyle,\n                                    onHoverEnter,\n                                    onHoverLeave,\n                                  })}\n                                </span>\n                              </li>\n                            );\n                          })}\n                        </ul>\n                      ) : (\n                        <span className={styles.noEffects}>No specific effects recorded</span>\n                      )}\n                    </td>\n                  </tr>\n                )}\n              </React.Fragment>\n            );\n          })}\n        </tbody>\n      </table>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  events,\n  entityId,\n  entityIndex,\n  onNavigate,\n  onHoverEnter,\n  onHoverLeave,\n  loading = false,\n}", "type": "Readonly<EntityTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/ImageLightbox.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ImageLightbox.tsx", "sourceCode": "export default function ImageLightbox({\n  isOpen,\n  imageUrl,\n  title,\n  summary,\n  onClose,\n}: Readonly<ImageLightboxProps>) {\n  const mouseDownOnOverlay = useRef(false);\n\n  const handleOverlayMouseDown = (e: MouseEvent<HTMLDivElement>) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e: MouseEvent<HTMLDivElement>) => {\n    if (mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (!isOpen) return undefined;\n    document.addEventListener(\"keydown\", handleKeyDown);\n    const previousOverflow = document.body.style.overflow;\n    document.body.style.overflow = \"hidden\";\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      document.body.style.overflow = previousOverflow;\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen || !imageUrl) return null;\n\n  return (\n    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions, jsx-a11y/no-noninteractive-tabindex -- dialog overlay needs interaction handlers\n    <div\n      className={styles.overlay}\n      onMouseDown={handleOverlayMouseDown}\n      onClick={handleOverlayClick}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={title || \"Image viewer\"}\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }}\n    >\n      <button onClick={onClose} className={styles.closeButton}>\n        Close\n      </button>\n      <div className={styles.content}>\n        <img src={imageUrl} alt={title || \"Expanded view\"} className={styles.image} />\n        <div className={styles.caption}>\n          {title && <div className={styles.title}>{title}</div>}\n          {summary && <div className={styles.summary}>{summary}</div>}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  isOpen,\n  imageUrl,\n  title,\n  summary,\n  onClose,\n}", "type": "Readonly<ImageLightboxProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element | null"}, {"id": "apps/chronicler/webui/src/components/ProminenceTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/ProminenceTimeline.tsx", "sourceCode": "export default function ProminenceTimeline({\n  events,\n  entityId,\n  initialProminence = 2.5,\n  prominenceScale,\n}: Readonly<ProminenceTimelineProps>) {\n  const [hoveredPoint, setHoveredPoint] = useState<{\n    point: ProminenceDataPoint;\n    x: number;\n    y: number;\n  } | null>(null);\n\n  // Extract prominence data from events\n  const dataPoints = useMemo(\n    () => extractProminenceData(events, entityId, initialProminence, prominenceScale),\n    [events, entityId, initialProminence, prominenceScale]\n  );\n  const prominenceLevels = useMemo(() => {\n    return prominenceScale.labels.map((label, index) => ({\n      threshold: index === 0 ? prominenceScale.min : prominenceScale.thresholds[index - 1],\n      label,\n      color: PROMINENCE_COLORS[label as keyof typeof PROMINENCE_COLORS],\n    }));\n  }, [prominenceScale]);\n\n  // Calculate graph dimensions and scales\n  const graphMetrics = useMemo(() => {\n    if (dataPoints.length === 0) {\n      return null;\n    }\n\n    // Start line from first data point (entity's initial prominence), not tick 0\n    // First point is the previousValue at the first event tick, then each subsequent newValue\n    const firstPoint = { tick: dataPoints[0].tick, value: dataPoints[0].previousValue };\n    const allPoints = [firstPoint, ...dataPoints.map((p) => ({ tick: p.tick, value: p.newValue }))];\n\n    // Ribbon spans full era, but line only starts from first event\n    const minTick = 0;\n    const maxTick = Math.max(...allPoints.map((p) => p.tick), 1);\n    const minValue = 0;\n    const maxValue = 5;\n\n    // Graph dimensions (full width ribbon)\n    const leftPadding = 0;\n    const rightPadding = 0;\n    const topPadding = 0;\n    const bottomPadding = 0;\n\n    return {\n      allPoints,\n      minTick,\n      maxTick,\n      minValue,\n      maxValue,\n      leftPadding,\n      rightPadding,\n      topPadding,\n      bottomPadding,\n      xScale: (tick: number) =>\n        leftPadding + ((tick - minTick) / (maxTick - minTick)) * (100 - leftPadding - rightPadding),\n      yScale: (value: number) =>\n        topPadding +\n        ((maxValue - value) / (maxValue - minValue)) * (100 - topPadding - bottomPadding),\n    };\n  }, [dataPoints]);\n\n  // Find threshold crossings\n  const thresholdCrossings = useMemo(() => {\n    return dataPoints.filter((p) => p.crossesThreshold !== null);\n  }, [dataPoints]);\n\n  // Build SVG path for the line\n  const linePath = useMemo(() => {\n    if (!graphMetrics || graphMetrics.allPoints.length === 0) return \"\";\n\n    const points = graphMetrics.allPoints;\n    const pathParts: string[] = [];\n\n    // Start at first point\n    pathParts.push(\n      `M ${graphMetrics.xScale(points[0].tick)} ${graphMetrics.yScale(points[0].value)}`\n    );\n\n    // Step line (horizontal then vertical to show discrete changes)\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      // Horizontal line to new tick\n      pathParts.push(`L ${graphMetrics.xScale(curr.tick)} ${graphMetrics.yScale(prev.value)}`);\n      // Vertical line to new value\n      pathParts.push(`L ${graphMetrics.xScale(curr.tick)} ${graphMetrics.yScale(curr.value)}`);\n    }\n\n    return pathParts.join(\" \");\n  }, [graphMetrics]);\n\n  // Handle point hover\n  const handlePointHover = useCallback(\n    (point: ProminenceDataPoint | null, e?: React.MouseEvent) => {\n      if (point && e) {\n        const rect = (e.target as SVGElement).closest(\"svg\")?.getBoundingClientRect();\n        if (rect) {\n          setHoveredPoint({\n            point,\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top,\n          });\n        }\n      } else {\n        setHoveredPoint(null);\n      }\n    },\n    []\n  );\n\n  const resolveLabel = (value: number) => prominenceLabelFromScale(value, prominenceScale);\n  const resolveColor = (value: number) => {\n    const label = resolveLabel(value);\n    return PROMINENCE_COLORS[label as keyof typeof PROMINENCE_COLORS];\n  };\n\n  if (dataPoints.length === 0) {\n    return null; // Don't render anything if no prominence changes\n  }\n\n  return (\n    <div className={styles.container}>\n      <div className={styles.title}>Prominence Over Time</div>\n\n      <div className={styles.graphContainer}>\n        <svg className={styles.svg} viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n          {graphMetrics && (\n            <>\n              {/* Background level bands */}\n              {prominenceLevels.map((level, i) => {\n                const nextThreshold = prominenceLevels[i + 1]?.threshold ?? prominenceScale.max;\n                return (\n                  <rect\n                    key={level.label}\n                    x={0}\n                    y={graphMetrics.yScale(nextThreshold)}\n                    width={100}\n                    height={\n                      graphMetrics.yScale(level.threshold) - graphMetrics.yScale(nextThreshold)\n                    }\n                    fill={level.color}\n                    opacity={0.1}\n                  />\n                );\n              })}\n\n              {/* Horizontal grid lines for each level threshold */}\n              {prominenceScale.thresholds.map((threshold) => (\n                <line\n                  key={`grid-${threshold}`}\n                  x1={0}\n                  y1={graphMetrics.yScale(threshold)}\n                  x2={100}\n                  y2={graphMetrics.yScale(threshold)}\n                  stroke={graphColors.levelLine}\n                  strokeWidth={0.2}\n                />\n              ))}\n\n              {/* Main line */}\n              <path\n                d={linePath}\n                fill=\"none\"\n                stroke={graphColors.line}\n                strokeWidth={0.8}\n                vectorEffect=\"non-scaling-stroke\"\n              />\n\n              {/* Threshold crossing markers (vertical lines) */}\n              {thresholdCrossings.map((point, i) => (\n                <g key={`crossing-${i}`}>\n                  <line\n                    x1={graphMetrics.xScale(point.tick)}\n                    y1={0}\n                    x2={graphMetrics.xScale(point.tick)}\n                    y2={100}\n                    stroke={graphColors.marker}\n                    strokeWidth={0.5}\n                    opacity={0.7}\n                  />\n                </g>\n              ))}\n\n              {/* Data points - only show threshold crossings as dots */}\n              {thresholdCrossings.map((point, i) => (\n                <circle\n                  key={`point-${i}`}\n                  cx={graphMetrics.xScale(point.tick)}\n                  cy={graphMetrics.yScale(point.newValue)}\n                  r={2}\n                  fill={graphColors.marker}\n                  className={styles.dataPoint}\n                  onMouseEnter={(e) => handlePointHover(point, e)}\n                  onMouseLeave={() => handlePointHover(null)}\n                />\n              ))}\n            </>\n          )}\n        </svg>\n\n        {/* Tooltip - shows narrative description on hover */}\n        {hoveredPoint && (\n          <div\n            className={styles.tooltip}\n            // eslint-disable-next-line local/no-inline-styles -- dynamic position from mouse event\n            style={\n              {\n                \"--tooltip-left\": `${hoveredPoint.x + 10}px`,\n                \"--tooltip-top\": `${hoveredPoint.y - 40}px`,\n              } as React.CSSProperties\n            }\n          >\n            <div className={styles.tooltipValue}>\n              { }\n              <span\n                style={\n                  {\n                    \"--prominence-color\": resolveColor(hoveredPoint.point.previousValue),\n                  } as React.CSSProperties\n                }\n                className={styles.transitionColor}\n              >\n                {resolveLabel(hoveredPoint.point.previousValue)}\n              </span>\n              { }\n              <span\n                style={{ \"--prominence-color\": graphColors.textMuted } as React.CSSProperties}\n                className={styles.transitionColor}\n              >\n                &rarr;\n              </span>\n              { }\n              <span\n                style={\n                  {\n                    \"--prominence-color\": resolveColor(hoveredPoint.point.newValue),\n                  } as React.CSSProperties\n                }\n                className={styles.transitionColor}\n              >\n                {resolveLabel(hoveredPoint.point.newValue)}\n              </span>\n            </div>\n            <div className={styles.tooltipDescription}>{hoveredPoint.point.description}</div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  events,\n  entityId,\n  initialProminence = 2.5,\n  prominenceScale,\n}", "type": "Readonly<ProminenceTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element | null"}, {"id": "apps/chronicler/webui/src/components/WikiExplorer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiExplorer.tsx", "sourceCode": "export default function WikiExplorer({\n  projectId,\n  worldData,\n  loreData,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}: Readonly<WikiExplorerProps>) {\n  // Initialize from hash on mount\n  const [currentPageId, setCurrentPageId] = useState<string | null>(() => parseHashPageId());\n  const [searchQuery, setSearchQuery] = useState(\"\");\n\n  // Responsive layout\n  const breakpoint = useBreakpoint();\n  const isMobile = breakpoint === \"mobile\";\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\n\n  // Chronicles and static pages: use preloaded data when available, else load from IndexedDB\n  const [chronicles, setChronicles] = useState<ChronicleRecord[]>(() =>\n    preloadedChronicles ? normalizeChronicles(preloadedChronicles) : []\n  );\n  const [staticPages, setStaticPages] = useState<StaticPage[]>(() =>\n    preloadedStaticPages ? normalizeStaticPages(preloadedStaticPages) : []\n  );\n  const [eraNarratives, setEraNarratives] = useState<EraNarrativeViewRecord[]>(\n    () => preloadedEraNarratives ?? []\n  );\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [parchmentConfig] = useState<ParchmentConfig>(() => ({ ...DEFAULT_PARCHMENT_CONFIG }));\n  const simulationRunId = (worldData as { metadata?: { simulationRunId?: string } }).metadata\n    ?.simulationRunId;\n\n  // Load chronicles from IndexedDB when simulationRunId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedChronicles) return;\n    if (!simulationRunId) {\n      setChronicles([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadChronicles() {\n      try {\n        const loadedChronicles = await getCompletedChroniclesForSimulation(simulationRunId!);\n        if (!cancelled) {\n          setChronicles(normalizeChronicles(loadedChronicles));\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load chronicles:\", err);\n        if (!cancelled) {\n          setChronicles([]);\n        }\n      }\n    }\n\n    void loadChronicles();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedChronicles, simulationRunId]);\n\n  // Load static pages from IndexedDB when projectId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedStaticPages) return;\n    if (!projectId) {\n      setStaticPages([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadStaticPages() {\n      try {\n        const loadedPages = await getPublishedStaticPagesForProject(projectId!);\n        if (!cancelled) {\n          setStaticPages(normalizeStaticPages(loadedPages));\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load static pages:\", err);\n        if (!cancelled) {\n          setStaticPages([]);\n        }\n      }\n    }\n\n    void loadStaticPages();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedStaticPages, projectId]);\n\n  // Load era narratives from IndexedDB when simulationRunId changes (skipped when preloaded)\n  useEffect(() => {\n    if (preloadedEraNarratives) return;\n    if (!simulationRunId) {\n      setEraNarratives([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    async function loadEraNarratives() {\n      try {\n        const loaded = await getCompletedEraNarrativesForSimulation(simulationRunId!);\n        if (!cancelled) {\n          setEraNarratives(loaded);\n        }\n      } catch (err) {\n        console.error(\"[WikiExplorer] Failed to load era narratives:\", err);\n        if (!cancelled) {\n          setEraNarratives([]);\n        }\n      }\n    }\n\n    void loadEraNarratives();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [preloadedEraNarratives, simulationRunId]);\n\n  // Validate world data before building index\n  // Returns first validation error found, or null if valid\n  const dataError = useMemo((): { message: string; details: string } | null => {\n    for (const entity of worldData.hardState) {\n      // Validate prominence is numeric\n      if (typeof entity.prominence !== \"number\") {\n        const prom: unknown = entity.prominence;\n        return {\n          message: \"Invalid entity data format\",\n          details:\n            `Entity \"${entity.name}\" (${entity.id}) has prominence=\"${String(prom)}\" (${typeof prom}). ` +\n            `Expected a number (0-5). The saved simulation data may be from an older format.`,\n        };\n      }\n    }\n    return null;\n  }, [worldData]);\n\n  const prominenceScale = useMemo(() => {\n    if (dataError) {\n      return buildProminenceScale([], { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n    }\n    const values = worldData.hardState\n      .map((entity) => entity.prominence)\n      .filter((value) => typeof value === \"number\" && Number.isFinite(value));\n    return buildProminenceScale(values, { distribution: DEFAULT_PROMINENCE_DISTRIBUTION });\n  }, [worldData, dataError]);\n\n  // Build lightweight page index (fast) - only if data is valid\n  // When precomputedPageIndex is provided, deserialize it instead of computing from scratch\n  const { pageIndex, entityIndex } = useMemo(() => {\n    if (dataError) {\n      return {\n        pageIndex: {\n          entries: [],\n          byId: new Map<string, PageIndexEntry>(),\n          byName: new Map<string, string>(),\n          byAlias: new Map<string, string>(),\n          bySlug: new Map<string, string>(),\n          categories: [],\n          byBaseName: new Map<string, DisambiguationEntry[]>(),\n        } satisfies WikiPageIndex,\n        entityIndex: new Map<string, HardState>(),\n      };\n    }\n    const idx = precomputedPageIndex\n      ? deserializePageIndex(precomputedPageIndex)\n      : buildPageIndex(\n          worldData,\n          loreData,\n          chronicles,\n          staticPages,\n          prominenceScale,\n          eraNarratives\n        );\n    const entityIdx = new Map<string, HardState>();\n    for (const entity of worldData.hardState) {\n      entityIdx.set(entity.id, entity);\n    }\n    return { pageIndex: idx, entityIndex: entityIdx };\n  }, [\n    worldData,\n    loreData,\n    chronicles,\n    staticPages,\n    dataError,\n    prominenceScale,\n    precomputedPageIndex,\n    eraNarratives,\n  ]);\n\n  const resolvePageId = useCallback(\n    (pageId: string | null): string | null => {\n      if (!pageId) return null;\n      if (pageIndex.byId.has(pageId)) return pageId;\n      const resolved = pageIndex.bySlug.get(pageId);\n      return resolved ?? pageId;\n    },\n    [pageIndex]\n  );\n\n  const resolveUrlId = useCallback(\n    (pageId: string | null): string | null => {\n      if (!pageId) return null;\n      const resolvedId = resolvePageId(pageId);\n      if (!resolvedId) return pageId;\n      const entry = pageIndex.byId.get(resolvedId);\n      const shouldUseSlug =\n        entry &&\n        (entry.type === \"entity\" ||\n          entry.type === \"chronicle\" ||\n          entry.type === \"static\" ||\n          entry.type === \"era_narrative\");\n      return shouldUseSlug && entry?.slug ? entry.slug : pageId;\n    },\n    [pageIndex, resolvePageId]\n  );\n\n  // Sync hash changes to state (for back/forward buttons)\n  useEffect(() => {\n    const handleHashChange = () => {\n      const rawPageId = parseHashPageId();\n      const pageId = resolvePageId(rawPageId);\n      setCurrentPageId(pageId);\n      setSearchQuery(\"\");\n\n      if (rawPageId) {\n        const canonicalUrlId = resolveUrlId(rawPageId);\n        if (canonicalUrlId) {\n          const canonicalHash = buildPageHash(canonicalUrlId);\n          if (window.location.hash !== canonicalHash) {\n            window.history.replaceState(null, \"\", canonicalHash);\n          }\n        }\n      }\n    };\n\n    handleHashChange();\n    window.addEventListener(\"hashchange\", handleHashChange);\n    return () => window.removeEventListener(\"hashchange\", handleHashChange);\n  }, [resolvePageId, resolveUrlId]);\n\n  // Handle external navigation requests (e.g., from Archivist)\n  // Use useLayoutEffect to update state synchronously before paint, avoiding flash of home page\n  useLayoutEffect(() => {\n    if (!requestedPageId) return;\n\n    // Update state immediately (before paint)\n    const resolvedPageId = resolvePageId(requestedPageId);\n    setCurrentPageId(resolvedPageId);\n    setSearchQuery(\"\");\n\n    // Update hash (this will be picked up by hashchange listener for future back navigation)\n    const urlId = resolveUrlId(requestedPageId) ?? requestedPageId;\n    const newHash = buildPageHash(urlId);\n    if (window.location.hash !== newHash) {\n      window.location.hash = newHash;\n    }\n\n    // Signal that the request has been handled\n    onRequestedPageConsumed?.();\n  }, [requestedPageId, onRequestedPageConsumed, resolvePageId, resolveUrlId]);\n\n  // Page cache - stores fully built pages by ID\n  // Use useMemo to create a NEW cache when data changes, ensuring synchronous invalidation\n  // (useEffect runs after render, which causes stale cache reads when chunks load)\n  const pageCache = useMemo(\n    () => new Map<string, WikiPage>(),\n    [worldData, loreData, chronicles, staticPages, eraNarratives]\n  );\n\n  // Get a page from cache or build it on-demand\n  const getPage = useCallback(\n    (pageId: string): WikiPage | null => {\n      // Resolve slug to canonical ID for consistent caching\n      const canonicalId = pageIndex.byId.has(pageId)\n        ? pageId\n        : (pageIndex.bySlug.get(pageId) ?? pageId);\n\n      if (pageCache.has(canonicalId)) {\n        return pageCache.get(canonicalId)!;\n      }\n\n      const page = buildPageById(\n        canonicalId,\n        worldData,\n        loreData,\n        null,\n        pageIndex,\n        chronicles,\n        staticPages,\n// ... (truncated)", "parameters": [{"name": "{\n  projectId,\n  worldData,\n  loreData,\n  requestedPageId,\n  onRequestedPageConsumed,\n  preloadedChronicles,\n  preloadedStaticPages,\n  preloadedEraNarratives,\n  prebakedParchmentUrl,\n  precomputedPageIndex,\n}", "type": "Readonly<WikiExplorerProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/WikiNav.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiNav.tsx", "sourceCode": "export default function WikiNav({\n  categories,\n  pages,\n  chronicles,\n  staticPages,\n  currentPageId,\n  searchQuery,\n  onSearchQueryChange,\n  onNavigate,\n  onGoHome,\n  onRefreshIndex,\n  isRefreshing,\n  isDrawer,\n  onCloseDrawer,\n}: Readonly<WikiNavProps>) {\n  // Collapsible section state\n  const [loreExpanded, setLoreExpanded] = useState(false);\n  const [expandedEras, setExpandedEras] = useState<Set<string>>(new Set());\n  const [appendicesExpanded, setAppendicesExpanded] = useState(false);\n\n  // Get top categories for quick access (entity kinds)\n  const topCategories = categories.filter((c) => c.id.startsWith(\"kind-\")).slice(0, 10);\n\n  // Organize static pages by namespace\n  const frontMatterPages: WikiPage[] = [];\n  const lorePages: WikiPage[] = [];\n  const culturePages: WikiPage[] = [];\n  const systemPages: WikiPage[] = [];\n  const otherPages: WikiPage[] = [];\n\n  for (const page of staticPages) {\n    const title = page.title;\n    // Front matter: specific key pages\n    if (title === \"Lore:Foreword to the Annotated Chronicle\") {\n      frontMatterPages.unshift(page); // Foreword first\n    } else if (title === \"System:About This Project\") {\n      frontMatterPages.push(page); // About second\n    } else if (title.startsWith(\"Lore:\")) {\n      lorePages.push(page);\n    } else if (title.startsWith(\"Cultures:\")) {\n      culturePages.push(page);\n    } else if (title.startsWith(\"System:\")) {\n      systemPages.push(page);\n    } else {\n      otherPages.push(page);\n    }\n  }\n\n  // Sort lore pages alphabetically by title (without prefix)\n  lorePages.sort((a, b) =>\n    a.title.replace(\"Lore:\", \"\").localeCompare(b.title.replace(\"Lore:\", \"\"))\n  );\n  culturePages.sort((a, b) =>\n    a.title.replace(\"Cultures:\", \"\").localeCompare(b.title.replace(\"Cultures:\", \"\"))\n  );\n  systemPages.sort((a, b) =>\n    a.title.replace(\"System:\", \"\").localeCompare(b.title.replace(\"System:\", \"\"))\n  );\n\n  // Random page function\n  const handleRandomPage = () => {\n    const entityPages = pages.filter((p) => p.type === \"entity\" || p.type === \"era\");\n    if (entityPages.length > 0) {\n      // eslint-disable-next-line sonarjs/pseudo-random -- non-security random page selection\n      const randomIndex = Math.floor(Math.random() * entityPages.length);\n      onNavigate(entityPages[randomIndex].id);\n    }\n  };\n\n  const chroniclePages = chronicles.filter((page) => page.chronicle);\n  const storyChronicles = chroniclePages.filter((page) => page.chronicle?.format === \"story\");\n  const documentChronicles = chroniclePages.filter((page) => page.chronicle?.format === \"document\");\n\n  // Build era narrative lookup from all pages (eraId -> page)\n  const eraNarrativeByEraId = new Map<string, WikiPage>();\n  for (const page of pages) {\n    if (page.type === \"era_narrative\" && page.eraNarrative?.eraId) {\n      eraNarrativeByEraId.set(page.eraNarrative.eraId, page);\n    }\n  }\n\n  // Group chronicles by era\n  const chroniclesByEra = chroniclePages.reduce((groups, page) => {\n    const focalEra = page.chronicle?.temporalContext?.focalEra;\n    const eraId = focalEra?.id || \"unknown\";\n    const eraName = focalEra?.name || \"Unknown Era\";\n    const eraOrder = focalEra?.order ?? focalEra?.startTick ?? Infinity;\n\n    if (!groups.has(eraId)) {\n      groups.set(eraId, { eraId, eraName, eraOrder, stories: [], documents: [], all: [] });\n    }\n\n    const group = groups.get(eraId)!;\n    group.all.push(page);\n    if (page.chronicle?.format === \"story\") {\n      group.stories.push(page);\n    } else if (page.chronicle?.format === \"document\") {\n      group.documents.push(page);\n    }\n\n    return groups;\n  }, new Map<string, { eraId: string; eraName: string; eraOrder: number; stories: WikiPage[]; documents: WikiPage[]; all: WikiPage[] }>());\n\n  // Sort eras chronologically (by order or startTick)\n  const sortedEras = Array.from(chroniclesByEra.values()).sort((a, b) => a.eraOrder - b.eraOrder);\n\n  const toggleEra = (eraId: string) => {\n    setExpandedEras((prev) => {\n      const next = new Set(prev);\n      if (next.has(eraId)) {\n        next.delete(eraId);\n      } else {\n        next.add(eraId);\n      }\n      return next;\n    });\n  };\n\n  return (\n    <div className={styles.container}>\n      {/* Drawer header with close button (mobile only) */}\n      {isDrawer && (\n        <div className={styles.drawerHeader}>\n          <span className={styles.drawerTitle}>Navigation</span>\n          <button\n            onClick={onCloseDrawer}\n            className={styles.drawerClose}\n            aria-label=\"Close navigation\"\n          >\n            \u00d7\n          </button>\n        </div>\n      )}\n\n      <nav className={styles.nav}>\n        {/* FRONT MATTER - Key introductory pages */}\n        {frontMatterPages.length > 0 && (\n          <div className={styles.section}>\n            {frontMatterPages.map((page) => {\n              const isActive = currentPageId === page.id;\n              // Display name without namespace prefix\n              const displayName = page.title.includes(\":\") ? page.title.split(\":\")[1] : page.title;\n              return (\n                <button\n                  key={page.id}\n                  className={isActive ? styles.navItemActive : styles.navItem}\n                  onClick={() => onNavigate(page.id)}\n                >\n                  {displayName}\n                </button>\n              );\n            })}\n          </div>\n        )}\n\n        {/* LORE - World essays and background (collapsible) */}\n        {lorePages.length > 0 && (\n          <div className={styles.section}>\n            <button\n              className={styles.sectionTitleCollapsible}\n              onClick={() => setLoreExpanded(!loreExpanded)}\n              aria-expanded={loreExpanded}\n            >\n              <span className={styles.collapseIcon}>{loreExpanded ? \"\u25bc\" : \"\u25b6\"}</span>\n              Lore\n              <span className={styles.badge}>({lorePages.length})</span>\n            </button>\n            {loreExpanded &&\n              lorePages.map((page) => {\n                const isActive = currentPageId === page.id;\n                const displayName = page.title.replace(\"Lore:\", \"\");\n                return (\n                  <button\n                    key={page.id}\n                    className={isActive ? styles.navItemActive : styles.navItem}\n                    onClick={() => onNavigate(page.id)}\n                  >\n                    {displayName}\n                  </button>\n                );\n              })}\n          </div>\n        )}\n\n        {/* CHRONICLES - The stories, organized by era */}\n        {chroniclePages.length > 0 && (\n          <div className={styles.section}>\n            <div className={styles.sectionTitle}>Chronicles</div>\n\n            {/* Era sections */}\n            {sortedEras.map((era) => {\n              const isExpanded = expandedEras.has(era.eraId);\n              const eraAllId = `chronicles-era-${era.eraId}`;\n              const eraStoriesId = `chronicles-era-${era.eraId}-story`;\n              const eraDocsId = `chronicles-era-${era.eraId}-document`;\n\n              return (\n                <div key={era.eraId}>\n                  <button\n                    className={styles.eraSectionTitle}\n                    onClick={() => toggleEra(era.eraId)}\n                    aria-expanded={isExpanded}\n                  >\n                    <span className={styles.collapseIcon}>{isExpanded ? \"\u25bc\" : \"\u25b6\"}</span>\n                    {era.eraName}\n                    <span className={styles.badge}>({era.all.length})</span>\n                  </button>\n                  {isExpanded && (\n                    <>\n                      {eraNarrativeByEraId.has(era.eraId) &&\n                        (() => {\n                          const narrativePage = eraNarrativeByEraId.get(era.eraId)!;\n                          const isActive = currentPageId === narrativePage.id;\n                          return (\n                            <button\n                              className={\n                                isActive\n                                  ? styles.navItemEraNarrativeActive\n                                  : styles.navItemEraNarrative\n                              }\n                              onClick={() => onNavigate(narrativePage.id)}\n                            >\n                              Era Narrative\n                            </button>\n                          );\n                        })()}\n                      <button\n                        className={\n                          currentPageId === eraAllId\n                            ? styles.navItemIndentedActive\n                            : styles.navItemIndented\n                        }\n                        onClick={() => onNavigate(eraAllId)}\n                      >\n                        View All\n                        <span\n                          className={currentPageId === eraAllId ? styles.badgeActive : styles.badge}\n                        >\n                          ({era.all.length})\n                        </span>\n                      </button>\n                      {era.stories.length > 0 && (\n                        <button\n                          className={\n                            currentPageId === eraStoriesId\n                              ? styles.navItemIndentedActive\n                              : styles.navItemIndented\n                          }\n                          onClick={() => onNavigate(eraStoriesId)}\n                        >\n                          Stories\n                          <span\n                            className={\n                              currentPageId === eraStoriesId ? styles.badgeActive : styles.badge\n                            }\n                          >\n                            ({era.stories.length})\n                          </span>\n                        </button>\n                      )}\n                      {era.documents.length > 0 && (\n                        <button\n                          className={\n                            currentPageId === eraDocsId\n                              ? styles.navItemIndentedActive\n                              : styles.navItemIndented\n                          }\n                          onClick={() => onNavigate(eraDocsId)}\n                        >\n                          Documents\n                          <span\n                            className={\n                              currentPageId === eraDocsId ? styles.badgeActive : styles.badge\n                            }\n                          >\n                            ({era.documents.length})\n                          </span>\n                        </button>\n                      )}\n                    </>\n                  )}\n                </div>\n              );\n            })}\n\n            {/* All Stories / All Documents at bottom */}\n            {storyChronicles.length > 0 && (\n              <button\n                className={\n                  currentPageId === \"chronicles-story\" ? styles.navItemActive : styles.navItem\n                }\n                onClick={() => onNavigate(\"chronicles-story\")}\n              >\n                All Stories\n                <span\n                  className={\n                    currentPageId === \"chronicles-story\" ? styles.badgeActive : styles.badge\n                  }\n                >\n                  ({storyChronicles.length})\n// ... (truncated)", "parameters": [{"name": "{\n  categories,\n  pages,\n  chronicles,\n  staticPages,\n  currentPageId,\n  searchQuery,\n  onSearchQueryChange,\n  onNavigate,\n  onGoHome,\n  onRefreshIndex,\n  isRefreshing,\n  isDrawer,\n  onCloseDrawer,\n}", "type": "Readonly<WikiNavProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/WikiPage.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiPage.tsx", "sourceCode": "export default function WikiPageView({\n  page,\n  pages,\n  entityIndex,\n  disambiguation,\n  onNavigate,\n  onNavigateToEntity,\n  prominenceScale,\n  breakpoint = \"desktop\",\n  layoutOverride,\n}: Readonly<WikiPageViewProps>) {\n  const isMobile = breakpoint === \"mobile\";\n  const isTablet = breakpoint === \"tablet\";\n  const showInfoboxInline = isMobile || isTablet;\n  const isEntityPage = page.type === \"entity\" || page.type === \"era\";\n  const entityIdForTimeline = isEntityPage ? page.id : null;\n  const narrativeEvents = useEntityNarrativeEvents(entityIdForTimeline);\n  const narrativeLoading = useEntityNarrativeLoading(entityIdForTimeline);\n  const [showSeedModal, setShowSeedModal] = useState(false);\n  const [activeImage, setActiveImage] = useState<{\n    url: string;\n    title: string;\n    summary?: string;\n  } | null>(null);\n  const [timelineOpen, setTimelineOpen] = useState(false);\n  const [hoveredBacklink, setHoveredBacklink] = useState<{\n    id: string;\n    position: { x: number; y: number };\n  } | null>(null);\n  const hoverTimeoutRef = useRef<number | null>(null);\n\n  // Handle entity link hover with delay to prevent flicker\n  const handleEntityHoverEnter = useCallback((id: string, e: React.MouseEvent) => {\n    // Capture position immediately - React synthetic events are pooled\n    const x = e.clientX;\n    const y = e.clientY;\n\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n    }\n    hoverTimeoutRef.current = window.setTimeout(() => {\n      setHoveredBacklink({\n        id,\n        position: { x, y },\n      });\n    }, 200); // 200ms delay before showing preview\n  }, []);\n\n  const handleEntityHoverLeave = useCallback(() => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredBacklink(null);\n  }, []);\n\n  // Clear hover when clicking to navigate\n  const handleEntityClick = useCallback(\n    (entityId: string) => {\n      handleEntityHoverLeave();\n      onNavigateToEntity(entityId);\n    },\n    [handleEntityHoverLeave, onNavigateToEntity]\n  );\n\n  // Get hovered entity data for preview\n  const hoveredEntity = useMemo(() => {\n    if (!hoveredBacklink) return null;\n    return entityIndex.get(hoveredBacklink.id) || null;\n  }, [hoveredBacklink, entityIndex]);\n\n  // Get summary for hovered entity\n  const hoveredSummary = useMemo(() => {\n    if (!hoveredBacklink) return undefined;\n    const page = pages.find((p) => p.id === hoveredBacklink.id);\n    return page?.content?.summary;\n  }, [hoveredBacklink, pages]);\n\n  // Load image for hovered entity on demand\n  const hoveredImageId = hoveredEntity?.enrichment?.image?.imageId;\n  const { url: hoveredImageUrl } = useImageUrl(hoveredImageId);\n\n  const pageById = useMemo(() => new Map(pages.map((p) => [p.id, p])), [pages]);\n  const imageIdToEntityId = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const entity of entityIndex.values()) {\n      const imageId = entity.enrichment?.image?.imageId;\n      if (imageId && !map.has(imageId)) {\n        map.set(imageId, entity.id);\n      }\n    }\n    return map;\n  }, [entityIndex]);\n\n  const resolveImageDetails = useCallback(\n    ({\n      entityId,\n      imageId,\n      caption,\n      fallbackTitle,\n      fallbackSummary,\n      suppressSummaryFallback,\n      captionOnly,\n    }: {\n      entityId?: string;\n      imageId?: string;\n      caption?: string;\n      fallbackTitle?: string;\n      fallbackSummary?: string;\n      suppressSummaryFallback?: boolean;\n      captionOnly?: boolean;\n    }) => {\n      if (captionOnly) {\n        return { title: caption || \"\", summary: \"\" };\n      }\n      let resolvedEntityId = entityId;\n      if (!resolvedEntityId && imageId) {\n        resolvedEntityId = imageIdToEntityId.get(imageId);\n      }\n\n      let title = \"\";\n      let summary = \"\";\n\n      if (resolvedEntityId) {\n        const entity = entityIndex.get(resolvedEntityId);\n        const entityPage = pageById.get(resolvedEntityId);\n        title = entity?.name || entityPage?.title || \"\";\n        summary = entityPage?.content.summary || \"\";\n      }\n\n      if (!title) {\n        title = fallbackTitle || caption || page.title;\n      }\n      if (!summary) {\n        if (suppressSummaryFallback) {\n          summary = fallbackSummary || caption || \"\";\n        } else {\n          summary = fallbackSummary || page.content.summary || caption || \"\";\n        }\n      }\n\n      return { title, summary };\n    },\n    [imageIdToEntityId, entityIndex, pageById, page.content.summary, page.title]\n  );\n\n  const openImageModal = useCallback(\n    (\n      imageUrl: string,\n      info: {\n        entityId?: string;\n        imageId?: string;\n        caption?: string;\n        fallbackTitle?: string;\n        fallbackSummary?: string;\n        suppressSummaryFallback?: boolean;\n        captionOnly?: boolean;\n      }\n    ) => {\n      if (!imageUrl) return;\n      const { title, summary } = resolveImageDetails(info);\n      setActiveImage({ url: imageUrl, title, summary });\n    },\n    [resolveImageDetails]\n  );\n\n  const closeImageModal = useCallback(() => {\n    setActiveImage(null);\n  }, []);\n\n  const handleInlineImageOpen = useCallback(\n    async (thumbUrl: string, image: WikiSectionImage) => {\n      // Try to load full-size image for lightbox, fall back to thumbnail\n      let fullUrl = thumbUrl;\n      if (image.imageId) {\n        try {\n          const loaded = await useImageStore.getState().loadUrl(image.imageId, \"full\");\n          if (loaded) fullUrl = loaded;\n        } catch {\n          // Fall back to thumbnail\n        }\n      }\n      openImageModal(fullUrl, {\n        entityId: image.entityId,\n        imageId: image.imageId,\n        caption: image.caption,\n        suppressSummaryFallback: image.type === \"chronicle_image\",\n        captionOnly: image.type === \"chronicle_image\",\n      });\n    },\n    [openImageModal]\n  );\n\n  // Build seed data for chronicle pages\n  const seedData = useMemo((): ChronicleSeedData | null => {\n    if (page.type !== \"chronicle\" || !page.chronicle) return null;\n    const chronicle = page.chronicle;\n    if (!chronicle.narrativeStyleId && !chronicle.roleAssignments?.length) return null;\n\n    // Get entrypoint name\n    const entrypoint = chronicle.entrypointId ? entityIndex.get(chronicle.entrypointId) : undefined;\n\n    return {\n      narrativeStyleId: chronicle.narrativeStyleId || \"\",\n      entrypointId: chronicle.entrypointId,\n      entrypointName: entrypoint?.name,\n      roleAssignments: chronicle.roleAssignments || [],\n      selectedEventIds: chronicle.selectedEventIds || [],\n      selectedRelationshipIds: chronicle.selectedRelationshipIds || [],\n      temporalContext: chronicle.temporalContext,\n    };\n  }, [page, entityIndex]);\n\n  // Compute backlinks\n  const chronicleLinks = useMemo(() => {\n    return pages.filter(\n      (p) =>\n        p.type === \"chronicle\" &&\n        p.chronicle &&\n        p.id !== page.id &&\n        p.linkedEntities.includes(page.id)\n    );\n  }, [pages, page.id]);\n\n  // Era narrative source chronicle pages (resolved from IDs)\n  const sourceChronicleLinks = useMemo(() => {\n    const ids = page.eraNarrative?.sourceChronicleIds;\n    if (!ids || ids.length === 0) return [];\n    return ids.map((id) => pages.find((p) => p.id === id)).filter((p): p is WikiPage => p != null);\n  }, [pages, page.eraNarrative?.sourceChronicleIds]);\n\n  const backlinks = useMemo(() => {\n    return pages.filter(\n      (p) =>\n        p.id !== page.id &&\n        p.type !== \"chronicle\" &&\n        p.type !== \"category\" &&\n        p.linkedEntities.includes(page.id)\n    );\n  }, [pages, page.id]);\n\n  // Build name to ID map for link resolution (entities + static pages)\n  // Use Unicode NFC normalization to ensure consistent string comparison\n  // (important for names with special characters like \u263d, ~, accents, etc.)\n  const entityNameMap = useMemo(() => {\n    const map = new Map<string, string>();\n    // Add entity names\n    for (const [id, entity] of entityIndex) {\n      map.set(entity.name.toLowerCase().normalize(\"NFC\"), id);\n    }\n    // Add static page titles (full title and base name without namespace)\n    for (const p of pages) {\n      if (p.type !== \"static\") continue;\n      const titleLower = p.title.toLowerCase().normalize(\"NFC\");\n      if (!map.has(titleLower)) {\n        map.set(titleLower, p.id);\n      }\n      // Also add base name (e.g., \"The Berg\" from \"World:The Berg\")\n      const colonIdx = p.title.indexOf(\":\");\n      if (colonIdx > 0 && colonIdx < p.title.length - 1) {\n        const baseName = p.title\n          .slice(colonIdx + 1)\n          .trim()\n          .toLowerCase()\n          .normalize(\"NFC\");\n        if (baseName && !map.has(baseName)) {\n          map.set(baseName, p.id);\n        }\n      }\n    }\n    return map;\n  }, [entityIndex, pages]);\n\n  const aliasMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const candidate of pages) {\n      if (candidate.type !== \"entity\" || !candidate.aliases?.length) continue;\n      for (const alias of candidate.aliases) {\n        // Use Unicode NFC normalization for consistent string comparison\n        const normalized = alias.toLowerCase().trim().normalize(\"NFC\");\n        if (!normalized || entityNameMap.has(normalized)) continue;\n        if (!map.has(normalized)) {\n          map.set(normalized, candidate.id);\n        }\n      }\n    }\n    return map;\n  }, [pages, entityNameMap]);\n\n  // Build linkable names for auto-linking (used by applyWikiLinks)\n  const linkableNames = useMemo(() => {\n    const names: Array<{ name: string; id: string }> = [];\n    // Add entity names\n    for (const [id, entity] of entityIndex) {\n      names.push({ name: entity.name, id });\n    }\n    // Add entity aliases\n    for (const candidate of pages) {\n      if (candidate.type !== \"entity\" || !candidate.aliases?.length) continue;\n      for (const alias of candidate.aliases) {\n// ... (truncated)", "parameters": [{"name": "{\n  page,\n  pages,\n  entityIndex,\n  disambiguation,\n  onNavigate,\n  onNavigateToEntity,\n  prominenceScale,\n  breakpoint = \"desktop\",\n  layoutOverride,\n}", "type": "Readonly<WikiPageViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/components/WikiSearch.tsx::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/components/WikiSearch.tsx", "sourceCode": "export default function WikiSearch({\n  pages,\n  query,\n  onQueryChange,\n  onSelect,\n  expandDirection = \"down\",\n}: Readonly<WikiSearchProps>) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Build fuse.js search index\n  const fuse = useMemo(() => {\n    return new Fuse(pages, {\n      keys: [\n        { name: \"title\", weight: 2 },\n        { name: \"aliases\", weight: 1.5 },\n        { name: \"content.summary\", weight: 1.2 },\n        { name: \"content.sections.heading\", weight: 0.5 },\n        { name: \"content.sections.content\", weight: 1 },\n      ],\n      threshold: 0.3,\n      includeScore: true,\n      minMatchCharLength: 2,\n    });\n  }, [pages]);\n\n  // Search results\n  const results = useMemo(() => {\n    if (!query || query.length < 2) return [];\n    return fuse.search(query).slice(0, 10);\n  }, [fuse, query]);\n\n  // Handle keyboard navigation\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (!isOpen || results.length === 0) return;\n\n    switch (e.key) {\n      case \"ArrowDown\":\n        e.preventDefault();\n        setSelectedIndex((i) => Math.min(i + 1, results.length - 1));\n        break;\n      case \"ArrowUp\":\n        e.preventDefault();\n        setSelectedIndex((i) => Math.max(i - 1, 0));\n        break;\n      case \"Enter\":\n        e.preventDefault();\n        if (results[selectedIndex]) {\n          onSelect(results[selectedIndex].item.id);\n          setIsOpen(false);\n          onQueryChange(\"\");\n        }\n        break;\n      case \"Escape\":\n        setIsOpen(false);\n        break;\n    }\n  };\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (e: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  // Reset keyboard selection when result set changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- derived UI selection reset on results refresh\n    setSelectedIndex(0);\n  }, [results]);\n\n  return (\n    <div ref={containerRef} className={styles.container}>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        value={query}\n        onChange={(e) => {\n          onQueryChange(e.target.value);\n          setIsOpen(true);\n        }}\n        onFocus={() => setIsOpen(true)}\n        onKeyDown={handleKeyDown}\n        className={styles.input}\n      />\n\n      {isOpen && query.length >= 2 && (\n        <div className={expandDirection === \"up\" ? styles.dropdownUp : styles.dropdown}>\n          {results.length > 0 ? (\n            results.map((result, index) => (\n              <button\n                key={result.item.id}\n                className={index === selectedIndex ? styles.resultSelected : styles.result}\n                onClick={() => {\n                  onSelect(result.item.id);\n                  setIsOpen(false);\n                  onQueryChange(\"\");\n                }}\n                onMouseEnter={() => setSelectedIndex(index)}\n              >\n                {result.item.title}\n                <span className={styles.resultType}>{result.item.type}</span>\n              </button>\n            ))\n          ) : (\n            <div className={styles.noResults}>No results found</div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  pages,\n  query,\n  onQueryChange,\n  onSelect,\n  expandDirection = \"down\",\n}", "type": "Readonly<WikiSearchProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts::default", "name": "default", "kind": "function", "filePath": "apps/chronicler/webui/src/hooks/useWorldDataLoader.ts", "sourceCode": "export default function useWorldDataLoader({\n  projectId,\n  activeSlotIndex,\n  dexieSeededAt,\n  preloadedWorldData,\n}: WorldDataLoaderOptions): WorldDataLoaderResult {\n  const [worldDataState, setWorldDataState] = useState<WorldState | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [loadError, setLoadError] = useState<string | null>(null);\n\n  const narrativeBackend = useMemo(() => new IndexedDBBackend(), []);\n  const hasPreloadedWorld = preloadedWorldData !== undefined;\n\n  const effective = resolveEffectiveState(\n    projectId,\n    hasPreloadedWorld,\n    preloadedWorldData,\n    worldDataState,\n    loading,\n    loadError\n  );\n  const simulationRunId = effective.worldData?.metadata?.simulationRunId ?? null;\n\n  useEffect(() => {\n    if (hasPreloadedWorld) return;\n    if (!projectId) return;\n\n    let cancelled = false;\n    queueMicrotask(() => {\n      if (cancelled) return;\n      setLoading(true);\n      setLoadError(null);\n    });\n\n    buildWorldStateForSlot(projectId, activeSlotIndex)\n      .then((loaded) => {\n        if (cancelled) return;\n        setWorldDataState(loaded);\n      })\n      .catch((err: unknown) => {\n        if (cancelled) return;\n        console.error(\"[ChroniclerRemote] Failed to load world data:\", err);\n        setWorldDataState(null);\n        setLoadError(err instanceof Error ? err.message : \"Failed to load world data from Dexie.\");\n      })\n      .finally(() => {\n        if (cancelled) return;\n        setLoading(false);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [activeSlotIndex, dexieSeededAt, hasPreloadedWorld, projectId]);\n\n  useEffect(() => {\n    const store = useNarrativeStore.getState();\n    store.configureBackend(narrativeBackend);\n    if (store.simulationRunId !== simulationRunId) {\n      store.setSimulationRunId(simulationRunId);\n    }\n  }, [narrativeBackend, simulationRunId]);\n\n  return effective;\n}", "parameters": [{"name": "{\n  projectId,\n  activeSlotIndex,\n  dexieSeededAt,\n  preloadedWorldData,\n}", "type": "WorldDataLoaderOptions", "optional": false}], "returnType": "WorldDataLoaderResult"}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getCompletedChroniclesForSimulation", "name": "getCompletedChroniclesForSimulation", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get all completed chronicles for a simulation run\n */\nexport async function getCompletedChroniclesForSimulation(\n  simulationRunId: string\n): Promise<ChronicleRecord[]> {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(CHRONICLE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allChronicles = request.result as ChronicleRecord[];\n          // Filter to only completed chronicles\n          const completed = allChronicles.filter((c) => c.status === \"complete\" && c.acceptedAt);\n          // Sort by acceptedAt descending\n          completed.sort((a, b) => (b.acceptedAt || 0) - (a.acceptedAt || 0));\n          resolve(completed);\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get chronicles\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicles:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>"}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getChronicle", "name": "getChronicle", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get a single chronicle by ID\n */\nexport async function getChronicle(chronicleId: string): Promise<ChronicleRecord | null> {\n  if (!chronicleId) return null;\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(CHRONICLE_STORE_NAME, \"readonly\");\n        const request = tx.objectStore(CHRONICLE_STORE_NAME).get(chronicleId);\n\n        request.onsuccess = () => resolve((request.result as ChronicleRecord | undefined) ?? null);\n        request.onerror = () => reject(request.error ?? new Error(\"Failed to get chronicle\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[chronicleStorage] Failed to load chronicle:\", err);\n    return null;\n  }\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord | null>"}, {"id": "apps/chronicler/webui/src/lib/chronicleStorage.ts::getChronicleContent", "name": "getChronicleContent", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/chronicleStorage.ts", "sourceCode": "/**\n * Get the content to display for a chronicle\n * Prefers finalContent (accepted), falls back to assembledContent\n */\nexport function getChronicleContent(chronicle: ChronicleRecord): string {\n  return chronicle.finalContent || chronicle.assembledContent || \"\";\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}], "returnType": "string"}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::escapeRegex", "name": "escapeRegex", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "// ============================================================================\n// Core Utilities\n// ============================================================================\n\n/**\n * Escape special regex characters in a string\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}", "parameters": [{"name": "str", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::buildNamePattern", "name": "buildNamePattern", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Build a regex pattern for a single name with smart word boundaries.\n *\n * Uses \\b for names starting/ending with word chars ([a-zA-Z0-9_]),\n * but uses lookaround for non-word chars (\u263d, ~, (, ), ', etc.) where \\b fails.\n *\n * Examples:\n * - \"Aurora Berg\" -> \\bAurora Berg\\b\n * - \"The Syndicate (aw-sworn)\" -> \\bThe Syndicate \\(aw-sworn\\)(?!\\w)\n * - \"\u263d'whelm Noctnecsiavcaeis~\" -> (?<!\\w)\u263d'whelm Noctnecsiavcaeis~(?!\\w)\n */\nexport function buildNamePattern(name: string): string {\n  const escaped = escapeRegex(name);\n  const firstChar = name.charAt(0);\n  const lastChar = name.charAt(name.length - 1);\n  const startBoundary = /\\w/.test(firstChar) ? \"\\\\b\" : \"(?<!\\\\w)\";\n  const endBoundary = /\\w/.test(lastChar) ? \"\\\\b\" : \"(?!\\\\w)\";\n  return `${startBoundary}${escaped}${endBoundary}`;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::buildCombinedPattern", "name": "buildCombinedPattern", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Build a combined regex pattern that matches any of the given names.\n * Names are sorted by length (longest first) to ensure longer matches take priority.\n *\n * @param names - Array of names to match (minimum 3 chars each)\n * @param flags - Regex flags (default: 'gi' for global, case-insensitive)\n */\nexport function buildCombinedPattern(names: string[], flags: string = \"gi\"): RegExp | null {\n  const validNames = names.filter((name) => name.length >= 3).sort((a, b) => b.length - a.length); // Longer names first\n\n  if (validNames.length === 0) return null;\n\n  const patterns = validNames.map(buildNamePattern);\n  return new RegExp(`(${patterns.join(\"|\")})`, flags);\n}", "parameters": [{"name": "names", "type": "string[]", "optional": false}, {"name": "flags", "type": "string", "optional": true}], "returnType": "RegExp | null"}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Apply wikilinks to content - wraps entity/page name mentions with [[...]] syntax.\n * Only links first occurrence of each name per section (Wikipedia MOS:LINK style).\n * Used at render time to make entity names clickable in markdown content.\n *\n * @param content - Raw text content (may contain markdown headings)\n * @param names - Array of { name, id } for entities and static pages to link\n */\nexport function applyWikiLinks(\n  content: string,\n  names: Array<{ name: string; id: string }>\n): string {\n  const nameStrings = names.map((n) => n.name);\n  const combinedPattern = buildCombinedPattern(nameStrings);\n\n  if (!combinedPattern) return content;\n\n  // Split by section headings (## or #), keeping the delimiter\n  // This regex captures the heading line so we can preserve it\n  const sectionSplitRegex = /^(#{1,3}\\s+.*)$/gm; // eslint-disable-line sonarjs/slow-regex -- single markdown lines, no backtracking risk\n  const parts = content.split(sectionSplitRegex);\n\n  // Process each part - headings pass through, content gets wiki-linked\n  const result: string[] = [];\n  for (const part of parts) {\n    if (part.match(/^#{1,3}\\s+/)) {\n      // This is a heading - pass through unchanged\n      result.push(part);\n    } else {\n      // This is content - apply wiki links (first occurrence per section)\n      result.push(applyWikiLinksToSection(part, combinedPattern));\n    }\n  }\n\n  return result.join(\"\");\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "names", "type": "Array<{ name: string; id: string }>", "optional": false}], "returnType": "string"}, {"id": "apps/chronicler/webui/src/lib/entityLinking.ts::linkifyText", "name": "linkifyText", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/entityLinking.ts", "sourceCode": "/**\n * Convert text to React nodes with clickable entity links.\n * Used for non-markdown content like timeline tables where we need React elements.\n *\n * @param text - Plain text to process\n * @param entities - Array of { name, id } for entities to link\n * @param onNavigate - Callback when an entity link is clicked\n * @param options - Optional configuration\n */\n// eslint-disable-next-line sonarjs/function-return-type -- returns React.ReactNode by design\nexport function linkifyText(\n  text: string,\n  entities: LinkableEntity[],\n  onNavigate: (entityId: string) => void,\n  options: LinkifyOptions = {}\n): React.ReactNode {\n  const {\n    linkStyle = defaultLinkStyle,\n    firstOccurrenceOnly = true,\n    onHoverEnter,\n    onHoverLeave,\n  } = options;\n\n  // Sort by name length (longest first) to match longer names first\n  const sortedEntities = [...entities].sort((a, b) => b.name.length - a.name.length);\n\n  let result: React.ReactNode[] = [text];\n  const linkedNames = new Set<string>();\n\n  for (const { name, id } of sortedEntities) {\n    if (name.length < 3) continue;\n\n    // Skip if we already linked this name and firstOccurrenceOnly is true\n    const nameLower = name.toLowerCase();\n    if (firstOccurrenceOnly && linkedNames.has(nameLower)) continue;\n\n    const regex = new RegExp(buildNamePattern(name), \"gi\");\n    const newResult: React.ReactNode[] = [];\n    let foundMatch = false;\n\n    for (const part of result) {\n      if (typeof part !== \"string\") {\n        newResult.push(part);\n        continue;\n      }\n\n      // Skip if firstOccurrenceOnly and we already found a match for this name\n      if (firstOccurrenceOnly && foundMatch) {\n        newResult.push(part);\n        continue;\n      }\n\n      let lastIndex = 0;\n      let match: RegExpExecArray | null;\n      const segments: React.ReactNode[] = [];\n\n      while ((match = regex.exec(part)) !== null) {\n        // Add text before match\n        if (match.index > lastIndex) {\n          segments.push(part.slice(lastIndex, match.index));\n        }\n\n        // Add linked entity\n        segments.push(\n          React.createElement(\n            \"span\",\n            {\n              key: `${id}-${match.index}`,\n              style: linkStyle,\n              onClick: (e: React.MouseEvent) => {\n                e.stopPropagation();\n                onNavigate(id);\n              },\n              onMouseEnter: onHoverEnter ? (e: React.MouseEvent) => onHoverEnter(id, e) : undefined,\n              onMouseLeave: onHoverLeave,\n            },\n            match[0]\n          )\n        );\n\n        lastIndex = regex.lastIndex;\n        foundMatch = true;\n\n        // If firstOccurrenceOnly, stop after first match\n        if (firstOccurrenceOnly) break;\n      }\n\n      if (segments.length > 0) {\n        // Add remaining text after last match\n        if (lastIndex < part.length) {\n          segments.push(part.slice(lastIndex));\n        }\n        newResult.push(...segments);\n      } else {\n        newResult.push(part);\n      }\n    }\n\n    if (foundMatch) {\n      linkedNames.add(nameLower);\n    }\n    result = newResult;\n  }\n\n  return React.createElement(React.Fragment, null, ...result);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "entities", "type": "LinkableEntity[]", "optional": false}, {"name": "onNavigate", "type": "(entityId: string) => void", "optional": false}, {"name": "options", "type": "LinkifyOptions", "optional": true}], "returnType": "React.ReactNode"}, {"id": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts::getCompletedEraNarrativesForSimulation", "name": "getCompletedEraNarrativesForSimulation", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts", "sourceCode": "/**\n * Get all completed era narratives for a simulation run.\n * Returns at most one narrative per era (the most recently updated).\n */\nexport async function getCompletedEraNarrativesForSimulation(\n  simulationRunId: string\n): Promise<EraNarrativeViewRecord[]> {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Check if the store exists (older DB versions may not have it)\n      if (!db.objectStoreNames.contains(ERA_NARRATIVE_STORE_NAME)) {\n        return [];\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(ERA_NARRATIVE_STORE_NAME, \"readonly\");\n        const store = tx.objectStore(ERA_NARRATIVE_STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allRecords = request.result as Record<string, unknown>[];\n          const projected = allRecords\n            .map(projectToViewRecord)\n            .filter((r): r is EraNarrativeViewRecord => r !== null);\n\n          // Keep only the latest completed narrative per era\n          const byEra = new Map<string, EraNarrativeViewRecord>();\n          for (const record of projected) {\n            const existing = byEra.get(record.eraId);\n            if (!existing || record.updatedAt > existing.updatedAt) {\n              byEra.set(record.eraId, record);\n            }\n          }\n\n          resolve(Array.from(byEra.values()));\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get era narratives\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[eraNarrativeStorage] Failed to load era narratives:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<EraNarrativeViewRecord[]>"}, {"id": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts::getEraNarrativeContent", "name": "getEraNarrativeContent", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/eraNarrativeStorage.ts", "sourceCode": "/**\n * Get the display content for an era narrative.\n */\nexport function getEraNarrativeContent(narrative: EraNarrativeViewRecord): string {\n  return narrative.content;\n}", "parameters": [{"name": "narrative", "type": "EraNarrativeViewRecord", "optional": false}], "returnType": "string"}, {"id": "apps/chronicler/webui/src/lib/fuzzyAnchor.ts::resolveAnchorPhrase", "name": "resolveAnchorPhrase", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/fuzzyAnchor.ts", "sourceCode": "/**\n * Resolve an LLM-produced anchor phrase to a verbatim substring in the text.\n *\n * Returns null if no reasonable match is found.\n */\nexport function resolveAnchorPhrase(anchorPhrase: string, text: string): FuzzyAnchorResult | null {\n  if (!anchorPhrase || !text) return null;\n\n  // 1. Exact match (case-insensitive)\n  const lowerText = text.toLowerCase();\n  const lowerPhrase = anchorPhrase.toLowerCase();\n  const exactIdx = lowerText.indexOf(lowerPhrase);\n  if (exactIdx >= 0) {\n    return {\n      phrase: text.slice(exactIdx, exactIdx + anchorPhrase.length),\n      index: exactIdx,\n      method: \"exact\",\n    };\n  }\n\n  // 2. Fuzzy locate: find the region with highest content-word overlap\n  const phraseContentWords = contentWords(anchorPhrase);\n  if (phraseContentWords.length === 0) return null;\n\n  const phraseWordSet = new Set(phraseContentWords);\n  const words = wordPositions(text);\n  if (words.length === 0) return null;\n\n  // Window size: match the anchor phrase word count, with some slack\n  const anchorWordCount = anchorPhrase.split(/\\s+/).length;\n  const windowSize = Math.max(anchorWordCount, 4);\n  const halfWindow = Math.floor(windowSize / 2);\n\n  let bestScore = 0;\n  let bestCenter = -1;\n\n  // Score each word position by counting how many content words from the\n  // phrase appear within a window around it\n  for (let i = 0; i < words.length; i++) {\n    let score = 0;\n    const start = Math.max(0, i - halfWindow);\n    const end = Math.min(words.length, i + halfWindow + 1);\n    for (let j = start; j < end; j++) {\n      if (phraseWordSet.has(words[j].normalized)) {\n        score++;\n      }\n    }\n    if (score > bestScore) {\n      bestScore = score;\n      bestCenter = i;\n    }\n  }\n\n  // Require at least 40% of content words to match\n  if (bestScore < Math.max(1, Math.ceil(phraseContentWords.length * 0.4))) {\n    return null;\n  }\n\n  // 3. Extract a verbatim span from the best region\n  // Take a window of similar word count centered on bestCenter\n  const spanStart = Math.max(0, bestCenter - halfWindow);\n  const spanEnd = Math.min(words.length - 1, bestCenter + halfWindow);\n  const charStart = words[spanStart].start;\n  const charEnd = words[spanEnd].end;\n\n  let candidate = text.slice(charStart, charEnd);\n\n  // Trim to sentence boundaries if the span crosses them \u2014 find the\n  // innermost sentence that contains the center word\n  const centerCharStart = words[bestCenter].start;\n  const centerCharEnd = words[bestCenter].end;\n\n  // Find sentence start (look backwards for . ! ? followed by space, or start of text)\n  let sentenceStart = charStart;\n  for (let c = centerCharStart - 1; c >= Math.max(0, charStart - 200); c--) {\n    if (c === 0) {\n      sentenceStart = 0;\n      break;\n    }\n    const ch = text[c];\n    if ((ch === \".\" || ch === \"!\" || ch === \"?\") && c + 1 < text.length && /\\s/.test(text[c + 1])) {\n      sentenceStart = c + 2; // skip punctuation + space\n      break;\n    }\n  }\n\n  // Find sentence end (look forwards for . ! ?)\n  let sentenceEnd = charEnd;\n  for (let c = centerCharEnd; c < Math.min(text.length, charEnd + 200); c++) {\n    const ch = text[c];\n    if (ch === \".\" || ch === \"!\" || ch === \"?\") {\n      sentenceEnd = c + 1;\n      break;\n    }\n  }\n\n  // Use the sentence if it's a reasonable length; otherwise use the raw span\n  const sentence = text.slice(sentenceStart, sentenceEnd).trim();\n  if (sentence.length > 0 && sentence.length <= 300) {\n    candidate = sentence;\n  }\n\n  // Pick a unique sub-span if the candidate appears multiple times\n  // Try progressively shorter unique substrings from the center\n  if (candidate.length > 0) {\n    const firstOccurrence = text.indexOf(candidate);\n    const secondOccurrence = text.indexOf(candidate, firstOccurrence + 1);\n    if (secondOccurrence >= 0) {\n      // Not unique \u2014 try to shorten from the center of the best region\n      // Fall back to using the center word's sentence with more context\n      const uniqueCandidate = findUniqueSpan(text, centerCharStart, anchorWordCount);\n      if (uniqueCandidate) {\n        candidate = uniqueCandidate;\n      }\n    }\n  }\n\n  if (!candidate || candidate.length < 3) return null;\n\n  const finalIdx = text.indexOf(candidate);\n  if (finalIdx < 0) return null;\n\n  return {\n    phrase: candidate,\n    index: finalIdx,\n    method: \"fuzzy\",\n  };\n}", "parameters": [{"name": "anchorPhrase", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "FuzzyAnchorResult | null"}, {"id": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts::openIlluminatorDb", "name": "openIlluminatorDb", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts", "sourceCode": "export function openIlluminatorDb(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME);\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // If another connection triggers a version upgrade while we're\n      // still open, close immediately so we don't block it.\n      db.onversionchange = () => {\n        db.close();\n      };\n\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(request.error || new Error(\"Failed to open illuminator DB\"));\n    };\n  });\n}", "parameters": [], "returnType": "Promise<IDBDatabase>"}, {"id": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts::readPageLayouts", "name": "readPageLayouts", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/illuminatorDbReader.ts", "sourceCode": "/**\n * Read all page layout overrides for a simulation run.\n * Returns a Map keyed by pageId for fast lookup.\n * Gracefully returns empty map if the store doesn't exist yet (pre-v10 DB).\n */\nexport async function readPageLayouts(\n  simulationRunId: string\n): Promise<Map<string, PageLayoutOverride>> {\n  const map = new Map<string, PageLayoutOverride>();\n  if (!simulationRunId) return map;\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Guard: store may not exist if Illuminator hasn't upgraded to v10 yet\n      if (!db.objectStoreNames.contains(PAGE_LAYOUTS_STORE)) {\n        return map;\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(PAGE_LAYOUTS_STORE, \"readonly\");\n        const store = tx.objectStore(PAGE_LAYOUTS_STORE);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const records = request.result as PageLayoutOverride[];\n          for (const r of records) {\n            map.set(r.pageId, r);\n          }\n          resolve(map);\n        };\n        request.onerror = () => reject(request.error || new Error(\"Failed to read page layouts\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[illuminatorDbReader] Failed to load page layouts:\", err);\n    return map;\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, PageLayoutOverride>>"}, {"id": "apps/chronicler/webui/src/lib/staticPageStorage.ts::getStaticPage", "name": "getStaticPage", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/staticPageStorage.ts", "sourceCode": "// ============================================================================\n// Read-only Storage Operations\n// ============================================================================\n\n/**\n * Get a single static page by ID\n */\nexport async function getStaticPage(pageId: string): Promise<StaticPage | undefined> {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const req = tx.objectStore(STATIC_PAGE_STORE_NAME).get(pageId);\n      req.onsuccess = () => resolve((req.result as StaticPage | undefined) ?? undefined);\n      req.onerror = () => reject(req.error ?? new Error(\"Failed to get static page\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage | undefined>"}, {"id": "apps/chronicler/webui/src/lib/staticPageStorage.ts::getPublishedStaticPagesForProject", "name": "getPublishedStaticPagesForProject", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/staticPageStorage.ts", "sourceCode": "/**\n * Get published static pages for a project (main read function for Chronicler)\n */\nexport async function getPublishedStaticPagesForProject(projectId: string): Promise<StaticPage[]> {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const req = index.getAll(projectId);\n      req.onsuccess = () => {\n        const pages = (req.result as StaticPage[])\n          .filter((page) => page.status === \"published\")\n          .sort((a, b) => b.updatedAt - a.updatedAt);\n        resolve(pages);\n      };\n      req.onerror = () => reject(req.error || new Error(\"Failed to get static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<StaticPage[]>"}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildWikiPages", "name": "buildWikiPages", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build all wiki pages from world data (legacy full build)\n *\n * @param chronicles - Completed ChronicleRecords from IndexedDB (preferred source for chronicles)\n */\nexport function buildWikiPages(\n  worldData: WorldState,\n  loreData: LoreData | null,\n  imageData: ImageMetadata | null,\n  chronicles: ChronicleRecord[] = [],\n  prominenceScale?: ProminenceScale\n): WikiPage[] {\n  const pages: WikiPage[] = [];\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  const loreIndex = buildLoreIndex(loreData);\n  const aliasIndex = buildAliasIndex(worldData);\n  const imageIndex = buildImageIndex(worldData, imageData);\n\n  // Build entity pages\n  for (const entity of worldData.hardState) {\n    const page = buildEntityPage(\n      entity,\n      worldData,\n      loreIndex,\n      imageIndex,\n      aliasIndex,\n      resolvedProminenceScale,\n      chronicles\n    );\n    pages.push(page);\n  }\n\n  // Build chronicle pages from ChronicleRecords (IndexedDB)\n  const chroniclePages = buildChroniclePagesFromChronicles(chronicles, worldData, aliasIndex);\n  pages.push(...chroniclePages);\n\n  // Build category pages\n  const categories = buildCategories(worldData, pages);\n  for (const category of categories) {\n    pages.push(buildCategoryPage(category, pages));\n  }\n\n  return pages;\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}, {"name": "loreData", "type": "LoreData | null", "optional": false}, {"name": "imageData", "type": "ImageMetadata | null", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}], "returnType": "WikiPage[]"}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildPageIndex", "name": "buildPageIndex", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "export function buildPageIndex(\n  worldData: WorldState,\n  _loreData: LoreData | null,\n  chronicles: ChronicleRecord[] = [],\n  staticPages: StaticPage[] = [],\n  prominenceScale?: ProminenceScale,\n  eraNarratives: EraNarrativeViewRecord[] = []\n): WikiPageIndex {\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  const state: PageIndexState = {\n    entries: [],\n    byId: new Map(),\n    byName: new Map(),\n    byAlias: new Map(),\n    bySlug: new Map(),\n  };\n\n  const entityByName = new Map(worldData.hardState.map((e) => [e.name.toLowerCase(), e.id]));\n\n  const eraNarrativeByEraId = new Map<string, EraNarrativeViewRecord>();\n  for (const narrative of eraNarratives) {\n    if (narrative.status === \"complete\" && narrative.content) {\n      eraNarrativeByEraId.set(narrative.eraId, narrative);\n    }\n  }\n\n  indexEntityEntries(worldData, resolvedProminenceScale, eraNarrativeByEraId, state);\n  indexEraNarrativeEntries(eraNarrativeByEraId, state);\n  indexChronicleEntries(chronicles, state);\n\n  const linkableNames = buildLinkableNames(worldData, staticPages);\n  extractChronicleBacklinks(chronicles, state.entries, linkableNames, worldData, state.byAlias, state.byName);\n  indexStaticPageEntries(staticPages, linkableNames, entityByName, state);\n\n  const categories = indexCategoryEntries(state.entries, state);\n  indexRegionEntries(worldData, state);\n\n  const byBaseName = buildDisambiguationIndex(state.entries);\n\n  return { entries: state.entries, byId: state.byId, byName: state.byName, byAlias: state.byAlias, bySlug: state.bySlug, categories, byBaseName };\n}", "parameters": [{"name": "worldData", "type": "WorldState", "optional": false}, {"name": "_loreData", "type": "LoreData | null", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "staticPages", "type": "StaticPage[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}, {"name": "eraNarratives", "type": "EraNarrativeViewRecord[]", "optional": true}], "returnType": "WikiPageIndex"}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildPageById", "name": "buildPageById", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build a single page by ID (on-demand)\n * Returns null if page not found\n *\n * @param chronicles - Completed ChronicleRecords from IndexedDB (for chronicle pages)\n * @param staticPages - Published StaticPages from IndexedDB\n */\nexport function buildPageById(\n  pageId: string,\n  worldData: WorldState,\n  loreData: LoreData | null,\n  imageData: ImageMetadata | null,\n  pageIndex: WikiPageIndex,\n  chronicles: ChronicleRecord[] = [],\n  staticPages: StaticPage[] = [],\n  prominenceScale?: ProminenceScale,\n  eraNarratives: EraNarrativeViewRecord[] = []\n): WikiPage | null {\n  const resolvedProminenceScale = resolveProminenceScale(worldData, prominenceScale);\n  let indexEntry = pageIndex.byId.get(pageId);\n  if (!indexEntry) {\n    // Slug fallback: supports renamed entity URLs and slug-based deep links\n    const resolvedId = pageIndex.bySlug.get(pageId);\n    if (resolvedId) indexEntry = pageIndex.byId.get(resolvedId);\n    if (!indexEntry) return null;\n  }\n\n  const loreIndex = buildLoreIndex(loreData);\n  const imageIndex = buildImageIndex(worldData, imageData);\n\n  // Build alias index from page index\n  const aliasIndex = pageIndex.byAlias;\n\n  // Entity page\n  if (indexEntry.type === \"entity\" || indexEntry.type === \"era\") {\n    const entity = worldData.hardState.find((e) => e.id === pageId);\n    if (!entity) return null;\n    return buildEntityPage(\n      entity,\n      worldData,\n      loreIndex,\n      imageIndex,\n      aliasIndex,\n      resolvedProminenceScale,\n      chronicles\n    );\n  }\n\n  // Era narrative page - long-form era synthesis\n  if (indexEntry.type === \"era_narrative\") {\n    const narrative = eraNarratives.find((n) => n.narrativeId === pageId);\n    if (!narrative) return null;\n    return buildEraNarrativePage(narrative, worldData, aliasIndex, pageIndex.byName);\n  }\n\n  // Chronicle page - look up in ChronicleRecords\n  if (indexEntry.type === \"chronicle\") {\n    const chronicle = chronicles.find((c) => c.chronicleId === pageId);\n    if (!chronicle) return null;\n    return buildChroniclePageFromChronicle(chronicle, worldData, aliasIndex, pageIndex.byName);\n  }\n\n  // Category page\n  if (indexEntry.type === \"category\") {\n    const catId = pageId.replace(\"category-\", \"\");\n    const category = pageIndex.categories.find((c) => c.id === catId);\n    if (!category) return null;\n\n    // Build minimal page list for category\n    const pagesInCategory = pageIndex.entries\n      .filter((e) => e.categories.includes(catId))\n      .map((e) => ({\n        id: e.id,\n        title: e.title,\n        type: e.type,\n        slug: e.slug,\n        content: { sections: [], summary: e.summary },\n        categories: e.categories,\n        linkedEntities: e.linkedEntities,\n        images: [],\n        lastUpdated: e.lastUpdated,\n      })) as WikiPage[];\n\n    return buildCategoryPage(category, pagesInCategory);\n  }\n\n  // Static page - look up in StaticPages\n  if (indexEntry.type === \"static\") {\n    const staticPage = staticPages.find((p) => p.pageId === pageId);\n    if (!staticPage) return null;\n    return buildStaticPageFromStaticPage(\n      staticPage,\n      worldData,\n      loreData,\n      aliasIndex,\n      pageIndex.byName\n    );\n  }\n\n  // Region page\n  if (indexEntry.type === \"region\") {\n    // Extract region ID from page ID (format: \"region:region_id\")\n    const regionId = pageId.replace(\"region:\", \"\");\n    const regionInfo = findRegionById(worldData, regionId);\n    if (!regionInfo) return null;\n    return buildRegionPage(regionInfo.region, regionInfo.entityKind, worldData, aliasIndex);\n  }\n\n  return null;\n}", "parameters": [{"name": "pageId", "type": "string", "optional": false}, {"name": "worldData", "type": "WorldState", "optional": false}, {"name": "loreData", "type": "LoreData | null", "optional": false}, {"name": "imageData", "type": "ImageMetadata | null", "optional": false}, {"name": "pageIndex", "type": "WikiPageIndex", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": true}, {"name": "staticPages", "type": "StaticPage[]", "optional": true}, {"name": "prominenceScale", "type": "ProminenceScale", "optional": true}, {"name": "eraNarratives", "type": "EraNarrativeViewRecord[]", "optional": true}], "returnType": "WikiPage | null"}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::buildCategories", "name": "buildCategories", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Build all categories from pages\n */\nexport function buildCategories(_worldData: WorldState, pages: WikiPage[]): WikiCategory[] {\n  // _worldData reserved for future category enrichment\n  const categoryMap = new Map<string, WikiCategory>();\n\n  // Collect all category IDs from pages\n  for (const page of pages) {\n    for (const catId of page.categories) {\n      if (!categoryMap.has(catId)) {\n        categoryMap.set(catId, {\n          id: catId,\n          name: formatCategoryName(catId),\n          type: \"auto\",\n          pageCount: 0,\n        });\n      }\n      categoryMap.get(catId)!.pageCount++;\n    }\n  }\n\n  return Array.from(categoryMap.values()).sort((a, b) => b.pageCount - a.pageCount);\n}", "parameters": [{"name": "_worldData", "type": "WorldState", "optional": false}, {"name": "pages", "type": "WikiPage[]", "optional": false}], "returnType": "WikiCategory[]"}, {"id": "apps/chronicler/webui/src/lib/wikiBuilder.ts::applyWikiLinks", "name": "applyWikiLinks", "kind": "function", "filePath": "apps/chronicler/webui/src/lib/wikiBuilder.ts", "sourceCode": "/**\n * Apply wikilinks to content - wraps entity/page name mentions with [[...]] syntax.\n * Only links first occurrence of each name per section (Wikipedia MOS:LINK style).\n * Used at render time to make entity names clickable in markdown content.\n *\n * @param content - Raw text content (may contain markdown headings)\n * @param names - Array of { name, id } for entities and static pages to link\n */\nexport function applyWikiLinks(\n  content: string,\n  names: Array<{ name: string; id: string }>\n): string {\n  const nameStrings = names.map((n) => n.name);\n  const combinedPattern = buildCombinedPattern(nameStrings);\n\n  if (!combinedPattern) return content;\n\n  // Split by section headings (## or #), keeping the delimiter\n  // This regex captures the heading line so we can preserve it\n  const sectionSplitRegex = /^(#{1,3}\\s+.*)$/gm; // eslint-disable-line sonarjs/slow-regex -- single markdown lines, no backtracking risk\n  const parts = content.split(sectionSplitRegex);\n\n  // Process each part - headings pass through, content gets wiki-linked\n  const result: string[] = [];\n  for (const part of parts) {\n    if (part.match(/^#{1,3}\\s+/)) {\n      // This is a heading - pass through unchanged\n      result.push(part);\n    } else {\n      // This is content - apply wiki links (first occurrence per section)\n      result.push(applyWikiLinksToSection(part, combinedPattern));\n    }\n  }\n\n  return result.join(\"\");\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "names", "type": "Array<{ name: string; id: string }>", "optional": false}], "returnType": "string"}]