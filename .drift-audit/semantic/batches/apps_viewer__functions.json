[{"id": "apps/viewer/webui/src/App.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/App.jsx", "sourceCode": "export default function App() {\n  const {\n    bundle,\n    status,\n    error,\n    bundleRequestUrl,\n    loadBundle,\n    dexieSeededAt,\n    preloadedChronicles,\n    preloadedStaticPages,\n    preloadedEraNarratives,\n  } = useBundleLoader();\n  const [chroniclerRequestedPage, setChroniclerRequestedPage] = useState(null);\n  const clearChroniclerRequestedPage = useCallback(() => setChroniclerRequestedPage(null), []);\n\n  if (status !== \"ready\" || !bundle?.worldData) {\n    return (\n      <StatusScreen\n        status={status}\n        error={error}\n        bundleRequestUrl={bundleRequestUrl}\n        onRetry={loadBundle}\n        worldData={bundle?.worldData}\n      />\n    );\n  }\n\n  return (\n    <div className=\"app\">\n      <header className=\"app-header\">\n        <button\n          type=\"button\"\n          className=\"brand\"\n          onClick={() => {\n            setChroniclerRequestedPage(\"home\");\n            window.location.hash = \"#/\";\n          }}\n        >\n          <span className=\"brand-icon\" aria-hidden=\"true\">\n            &#x2756;\n          </span>\n          <span className=\"brand-title\">The Ice Remembers</span>\n        </button>\n        <HeaderSearch\n          projectId={bundle.projectId}\n          slotIndex={bundle.slot?.index ?? 0}\n          dexieSeededAt={dexieSeededAt}\n          onNavigate={setChroniclerRequestedPage}\n        />\n        <div className=\"header-spacer\" />\n      </header>\n      <main className=\"app-main\">\n        <div className=\"panel chronicler-scope\">\n          <ChroniclerRemote\n            projectId={bundle.projectId}\n            activeSlotIndex={bundle.slot?.index ?? 0}\n            requestedPageId={chroniclerRequestedPage}\n            onRequestedPageConsumed={clearChroniclerRequestedPage}\n            dexieSeededAt={dexieSeededAt}\n            preloadedWorldData={bundle.worldData}\n            preloadedChronicles={preloadedChronicles}\n            preloadedStaticPages={preloadedStaticPages}\n            preloadedEraNarratives={preloadedEraNarratives}\n            prebakedParchmentUrl={parchmentTileUrl}\n            precomputedPageIndex={bundle.precomputedPageIndex}\n          />\n        </div>\n      </main>\n      <footer className=\"app-footer\">\n        <span>Copyright \u00a9 2026</span>\n        <a href=\"https://ahara.io\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <img src=\"/tsonu-combined.png\" alt=\"tsonu\" height=\"14\" />\n        </a>\n      </footer>\n    </div>\n  );\n}", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleUrl", "name": "resolveBundleUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleUrl() {\n  return new URL(DEFAULT_BUNDLE_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string"}, {"id": "apps/viewer/webui/src/bundleLoader.js::resolveBundleManifestUrl", "name": "resolveBundleManifestUrl", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function resolveBundleManifestUrl() {\n  return new URL(DEFAULT_BUNDLE_MANIFEST_PATH, resolveBaseUrl()).toString();\n}", "parameters": [], "returnType": "string"}, {"id": "apps/viewer/webui/src/bundleLoader.js::normalizeBundle", "name": "normalizeBundle", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export function normalizeBundle(raw, bundleUrl) {\n  if (!raw || typeof raw !== \"object\") return null;\n\n  const baseUrl = new URL(\".\", bundleUrl).toString();\n  const resolveUrl = (value) => resolveAssetUrl(value, baseUrl);\n\n  return {\n    ...raw,\n    chronicles: Array.isArray(raw.chronicles) ? raw.chronicles : [],\n    staticPages: Array.isArray(raw.staticPages) ? raw.staticPages : [],\n    images: resolveImageMap(raw.images, resolveUrl),\n    imageData: resolveImageData(raw.imageData, resolveUrl),\n  };\n}", "parameters": [{"name": "raw", "type": "any", "optional": false}, {"name": "bundleUrl", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleViaManifest", "name": "loadBundleViaManifest", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleViaManifest(manifestUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(manifestUrl);\n  const manifest = await fetchJson(manifestUrl, { cache: \"no-store\" });\n  if (!manifest || manifest.format !== \"viewer-bundle-manifest\") {\n    throw new Error(\"Bundle manifest missing or invalid.\");\n  }\n\n  const manifestBaseUrl = new URL(\".\", manifestUrl).toString();\n  const corePath = manifest.core;\n  if (typeof corePath !== \"string\") {\n    throw new Error(\"Bundle manifest is missing core path.\");\n  }\n  const coreUrl = resolveAssetUrl(corePath, manifestBaseUrl);\n  setBundleRequestUrl(coreUrl);\n  const data = await fetchJson(coreUrl);\n\n  const normalized = validateAndNormalizeBundle(data, coreUrl);\n  configureNarrativeBackend(\n    manifest,\n    manifestBaseUrl,\n    normalized.worldData?.metadata?.simulationRunId\n  );\n  return normalized;\n}", "parameters": [{"name": "manifestUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/viewer/webui/src/bundleLoader.js::loadBundleFallback", "name": "loadBundleFallback", "kind": "function", "filePath": "apps/viewer/webui/src/bundleLoader.js", "sourceCode": "export async function loadBundleFallback(fallbackUrl, setBundleRequestUrl) {\n  setBundleRequestUrl(fallbackUrl);\n  const data = await fetchJson(fallbackUrl, { cache: \"no-store\" });\n  const normalized = validateAndNormalizeBundle(data, fallbackUrl);\n  const totalEvents = normalized.worldData.narrativeHistory.length;\n\n  if (totalEvents > 0) {\n    useNarrativeStore.getState().ingestChunk(normalized.worldData.narrativeHistory);\n  }\n  useNarrativeStore.getState().setStatus({\n    loading: false,\n    totalExpected: totalEvents,\n    chunksLoaded: totalEvents ? 1 : 0,\n    chunksTotal: totalEvents ? 1 : 0,\n  });\n\n  return normalized;\n}", "parameters": [{"name": "fallbackUrl", "type": "any", "optional": false}, {"name": "setBundleRequestUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/viewer/webui/src/HeaderSearch.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/HeaderSearch.jsx", "sourceCode": "export default function HeaderSearch({ projectId, slotIndex, dexieSeededAt, onNavigate }) {\n  const [query, setQuery] = useState(\"\");\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const containerRef = useRef(null);\n  const { pages, isIndexLoading } = useSearchIndex(projectId, slotIndex, dexieSeededAt);\n\n  const fuse = useMemo(\n    () =>\n      new Fuse(pages, {\n        keys: [\n          { name: \"title\", weight: 2 },\n          { name: \"content.summary\", weight: 1 },\n        ],\n        threshold: 0.3,\n        includeScore: true,\n        minMatchCharLength: 2,\n      }),\n    [pages]\n  );\n\n  const results = useMemo(() => {\n    if (!query || query.length < 2) return [];\n    return fuse.search(query).slice(0, 8);\n  }, [fuse, query]);\n\n  const handleSelect = useCallback(\n    (id) => {\n      if (id) onNavigate(id);\n      setIsOpen(false);\n      setQuery(\"\");\n    },\n    [onNavigate]\n  );\n\n  const handleKeyDown = useKeyboardNavigation(\n    results,\n    selectedIndex,\n    setSelectedIndex,\n    handleSelect\n  );\n\n  useEffect(() => {\n    const onClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) setIsOpen(false);\n    };\n    document.addEventListener(\"mousedown\", onClickOutside);\n    return () => document.removeEventListener(\"mousedown\", onClickOutside);\n  }, []);\n\n  return (\n    <div className=\"header-search\" ref={containerRef}>\n      <input\n        type=\"text\"\n        className=\"header-search-input\"\n        placeholder=\"Search wiki...\"\n        value={query}\n        onChange={(e) => {\n          setQuery(e.target.value);\n          setSelectedIndex(0);\n          setIsOpen(true);\n        }}\n        onFocus={() => setIsOpen(true)}\n        onKeyDown={(e) => {\n          if (isOpen) handleKeyDown(e);\n        }}\n      />\n      {isOpen && query.length >= 2 && (\n        <div className=\"header-search-dropdown\">\n          {results.length > 0 ? (\n            results.map((result, index) => (\n              <button\n                key={result.item.id}\n                type=\"button\"\n                className={`header-search-result ${index === selectedIndex ? \"selected\" : \"\"}`}\n                onClick={() => handleSelect(result.item.id)}\n                onMouseEnter={() => setSelectedIndex(index)}\n              >\n                <span className=\"header-search-result-title\">{result.item.title}</span>\n                <span className=\"header-search-result-type\">{result.item.type}</span>\n              </button>\n            ))\n          ) : (\n            <div className=\"header-search-no-results\">\n              {isIndexLoading ? \"Indexing pages...\" : \"No results found\"}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ projectId, slotIndex, dexieSeededAt, onNavigate }", "type": "{ projectId: any; slotIndex: any; dexieSeededAt: any; onNavigate: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/StatusScreen.jsx::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/StatusScreen.jsx", "sourceCode": "export default function StatusScreen({ status, error, bundleRequestUrl, onRetry, worldData }) {\n  if (status === \"loading\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Loading viewer bundle...</div>\n            <div className=\"state-detail\">Fetching {bundleRequestUrl}</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (status === \"error\") {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title state-error\">Bundle unavailable</div>\n            <div className=\"state-detail\">\n              {error?.message || \"Failed to load the viewer bundle.\"}\n            </div>\n            <div className=\"state-detail\">Expected at: {bundleRequestUrl}</div>\n            <div className=\"state-actions\">\n              <button className=\"button\" onClick={onRetry} type=\"button\">\n                Retry\n              </button>\n              <button\n                className=\"button secondary\"\n                onClick={() => window.location.reload()}\n                type=\"button\"\n              >\n                Reload page\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (!worldData) {\n    return (\n      <div className=\"app\">\n        <div className=\"state-screen\">\n          <div className=\"state-card\">\n            <div className=\"state-title\">Bundle is empty</div>\n            <div className=\"state-detail\">No world data found in {bundleRequestUrl}.</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}", "parameters": [{"name": "{ status, error, bundleRequestUrl, onRetry, worldData }", "type": "{ status: any; error: any; bundleRequestUrl: any; onRetry: any; worldData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/viewer/webui/src/useBundleLoader.js::default", "name": "default", "kind": "function", "filePath": "apps/viewer/webui/src/useBundleLoader.js", "sourceCode": "export default function useBundleLoader() {\n  const { bundle, status, error, bundleRequestUrl, loadBundle } = useLoadBundle();\n  const dexieSeededAt = useDexiePersistence(bundle);\n  const preloads = useBundlePreloads(bundle);\n\n  return { bundle, status, error, bundleRequestUrl, loadBundle, dexieSeededAt, ...preloads };\n}", "parameters": [], "returnType": "{ preloadedChronicles: any; preloadedStaticPages: any; preloadedEraNarratives: any; bundle: any; status: string; error: any; bundleRequestUrl: string; loadBundle: () => Promise<void>; dexieSeededAt: number; }"}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::overwriteWorldDataInDexie", "name": "overwriteWorldDataInDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "export async function overwriteWorldDataInDexie({\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}: {\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}) {\n  if (!projectId || !worldData) return;\n\n  const simulationRunId = worldData?.metadata?.simulationRunId;\n  if (!simulationRunId) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    // Determine which stores to include in the transaction\n    const storeNames = [\n      \"entities\",\n      \"relationships\",\n      \"narrativeEvents\",\n      \"simulationSlots\",\n      \"worldSchemas\",\n      \"coordinateStates\",\n      \"chronicles\",\n      \"staticPages\",\n    ];\n    const hasEraNarrativesStore = db.objectStoreNames.contains(\"eraNarratives\");\n    if (hasEraNarrativesStore) {\n      storeNames.push(\"eraNarratives\");\n    }\n\n    const tx = db.transaction(storeNames, \"readwrite\");\n\n    const entitiesStore = tx.objectStore(\"entities\");\n    const relationshipsStore = tx.objectStore(\"relationships\");\n    const eventsStore = tx.objectStore(\"narrativeEvents\");\n    const slotsStore = tx.objectStore(\"simulationSlots\");\n    const schemasStore = tx.objectStore(\"worldSchemas\");\n    const coordinateStore = tx.objectStore(\"coordinateStates\");\n    const chroniclesStore = tx.objectStore(\"chronicles\");\n    const staticPagesStore = tx.objectStore(\"staticPages\");\n    const eraNarrativesStore = hasEraNarrativesStore ? tx.objectStore(\"eraNarratives\") : null;\n\n    const deleteOps = [\n      deleteByIndex(entitiesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(relationshipsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(eventsStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(chroniclesStore, \"simulationRunId\", simulationRunId),\n      deleteByIndex(staticPagesStore, \"projectId\", projectId),\n    ];\n    if (eraNarrativesStore) {\n      deleteOps.push(deleteByIndex(eraNarrativesStore, \"simulationRunId\", simulationRunId));\n    }\n    await Promise.all(deleteOps);\n\n    const entities = Array.isArray(worldData.hardState)\n      ? worldData.hardState.map((entity: any) => ({ ...entity, simulationRunId }))\n      : [];\n    const relationships = Array.isArray(worldData.relationships)\n      ? worldData.relationships.map((rel: any) => ({ ...rel, simulationRunId }))\n      : [];\n    const narrativeEvents = Array.isArray(worldData.narrativeHistory)\n      ? worldData.narrativeHistory.map((event: any) => ({ ...event, simulationRunId }))\n      : [];\n\n    const slotRecord = {\n      projectId,\n      slotIndex,\n      simulationRunId,\n      finalTick: Number.isFinite(worldData.metadata?.tick) ? worldData.metadata.tick : null,\n      finalEraId: worldData.metadata?.era ?? null,\n      label: null,\n      isTemporary: slotIndex === 0,\n      updatedAt: Date.now(),\n    };\n\n    await Promise.all([\n      bulkPut(entitiesStore, entities),\n      bulkPut(relationshipsStore, relationships),\n      bulkPut(eventsStore, narrativeEvents),\n      requestToPromise(slotsStore.put(slotRecord)),\n      worldData.schema\n        ? requestToPromise(\n            schemasStore.put({ projectId, schema: worldData.schema, updatedAt: Date.now() })\n          )\n        : Promise.resolve(),\n      worldData.coordinateState\n        ? requestToPromise(\n            coordinateStore.put({\n              simulationRunId,\n              coordinateState: worldData.coordinateState,\n              updatedAt: Date.now(),\n            })\n          )\n        : Promise.resolve(),\n    ]);\n\n    if (Array.isArray(chronicles) && chronicles.length > 0) {\n      const normalizedChronicles = chronicles.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(chroniclesStore, normalizedChronicles);\n    }\n\n    if (Array.isArray(staticPages) && staticPages.length > 0) {\n      const normalizedPages = staticPages.map((page: any) => ({\n        ...page,\n        projectId: page.projectId || projectId,\n      }));\n      await bulkPut(staticPagesStore, normalizedPages);\n    }\n\n    if (eraNarrativesStore && Array.isArray(eraNarratives) && eraNarratives.length > 0) {\n      const normalizedNarratives = eraNarratives.map((record: any) => ({\n        ...record,\n        projectId: record.projectId || projectId,\n        simulationRunId: record.simulationRunId || simulationRunId,\n      }));\n      await bulkPut(eraNarrativesStore, normalizedNarratives);\n    }\n\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{\n  projectId,\n  slotIndex = 0,\n  worldData,\n  chronicles = [],\n  staticPages = [],\n  eraNarratives = [],\n   \n}", "type": "{\n  projectId: string;\n  slotIndex?: number;\n  worldData: any;\n  chronicles?: any[];\n  staticPages?: any[];\n  eraNarratives?: any[];\n}", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts::appendNarrativeEventsToDexie", "name": "appendNarrativeEventsToDexie", "kind": "function", "filePath": "apps/viewer/webui/src/lib/illuminatorDbWriter.ts", "sourceCode": "// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function appendNarrativeEventsToDexie(simulationRunId: string, events: any[]) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) return;\n\n  const db = await openIlluminatorDbForWrite();\n  try {\n    const tx = db.transaction([\"narrativeEvents\"], \"readwrite\");\n    const store = tx.objectStore(\"narrativeEvents\");\n    const records = events.map((event) => ({ ...event, simulationRunId }));\n    await bulkPut(store, records);\n    await waitForTransaction(tx);\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "events", "type": "any[]", "optional": false}], "returnType": "Promise<void>"}]