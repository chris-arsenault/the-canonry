[{"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::createClients", "name": "createClients", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export function createClients(config: WorkerConfig): {\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n} {\n  // LLMClient model is set per-call; use a default for the base client\n  const llmClient = new LLMClient({\n    enabled: Boolean(config.anthropicApiKey),\n    apiKey: config.anthropicApiKey,\n    model: \"claude-sonnet-4-6\", // Default; overridden per call\n  });\n\n  const imageClient = new ImageClient({\n    enabled: Boolean(config.openaiApiKey),\n    apiKey: config.openaiApiKey,\n    model: config.imageModel || \"dall-e-3\",\n    size: config.imageSize || \"1024x1024\",\n    quality: config.imageQuality || \"standard\",\n  });\n\n  return { llmClient, imageClient };\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}], "returnType": "{\n  llmClient: LLMClient;\n  imageClient: ImageClient;\n}"}, {"id": "apps/illuminator/webui/src/workers/enrichmentCore.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/enrichmentCore.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleVersionSelector.jsx", "sourceCode": "export default function ChronicleVersionSelector({\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}) {\n  const isActive = selectedVersionId === activeVersionId;\n  const canDelete = versions.length > 1 && onDeleteVersion;\n  const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);\n  const confirmingDelete = confirmingDeleteId === selectedVersionId;\n\n  useEffect(() => {\n    if (!confirmingDeleteId) return;\n    const stillExists = versions.some((v) => v.id === confirmingDeleteId);\n    if (!stillExists || confirmingDeleteId !== selectedVersionId || disabled) {\n      setConfirmingDeleteId(null);\n    }\n  }, [confirmingDeleteId, selectedVersionId, versions, disabled]);\n\n  const handleDeleteClick = () => {\n    if (confirmingDelete) {\n      onDeleteVersion(selectedVersionId);\n      setConfirmingDeleteId(null);\n    } else {\n      setConfirmingDeleteId(selectedVersionId);\n    }\n  };\n\n  return (\n    <div className=\"cvs-container\">\n      <select\n        value={selectedVersionId}\n        onChange={(e) => {\n          onSelectVersion(e.target.value);\n          setConfirmingDeleteId(null);\n        }}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-version\"\n      >\n        {versions.map((version) => (\n          <option key={version.id} value={version.id}>\n            {version.label}\n          </option>\n        ))}\n      </select>\n      <select\n        value={compareToVersionId}\n        onChange={(e) => onSelectCompareVersion(e.target.value)}\n        disabled={disabled}\n        className=\"illuminator-select cvs-select-compare\"\n        title=\"Select a version to diff against\"\n      >\n        <option value=\"\">Compare to...</option>\n        {versions\n          .filter((v) => v.id !== selectedVersionId)\n          .map((version) => (\n            <option key={version.id} value={version.id}>\n              {version.shortLabel || version.label}\n            </option>\n          ))}\n      </select>\n      {isActive ? (\n        <span className=\"cvs-active-badge\">Active</span>\n      ) : (\n        <button\n          onClick={() => onSetActiveVersion?.(selectedVersionId)}\n          disabled={disabled || !onSetActiveVersion}\n          className=\"cvs-btn-make-active\"\n        >\n          Make Active\n        </button>\n      )}\n      {canDelete && (\n        <button\n          onClick={handleDeleteClick}\n          onBlur={() => setConfirmingDeleteId(null)}\n          disabled={disabled}\n          title={confirmingDelete ? \"Click again to confirm deletion\" : \"Delete this version\"}\n          className={`cvs-btn-delete${confirmingDelete ? \" cvs-btn-delete-confirming\" : \"\"}`}\n        >\n          {confirmingDelete ? \"Confirm Delete\" : \"Delete\"}\n        </button>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  versions,\n  selectedVersionId,\n  activeVersionId,\n  compareToVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  disabled,\n}", "type": "{ versions: any; selectedVersionId: any; activeVersionId: any; compareToVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; disabled: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ChronicleWorkspace.jsx", "sourceCode": "export default function ChronicleWorkspace({\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}) {\n  const isComplete = item.status === \"complete\";\n\n  // ---------------------------------------------------------------------------\n  // Entity map\n  // ---------------------------------------------------------------------------\n  const entityMap = useMemo(() => {\n    if (!entities) return new Map();\n    return new Map(entities.map((e) => [e.id, e]));\n  }, [entities]);\n\n  // ---------------------------------------------------------------------------\n  // Version state & memos\n  // ---------------------------------------------------------------------------\n  const versions = useMemo(() => {\n    const stepLabel = (step) => {\n      if (!step) return null;\n      const labels = {\n        generate: \"initial\",\n        regenerate: \"regenerate\",\n        creative: \"creative\",\n        combine: \"combine\",\n        copy_edit: \"copy-edit\",\n      };\n      return labels[step] || step;\n    };\n\n    const sorted = [...(item.generationHistory || [])].sort(\n      (a, b) => a.generatedAt - b.generatedAt\n    );\n    const seen = new Set();\n    const unique = [];\n    for (const version of sorted) {\n      if (seen.has(version.versionId)) continue;\n      seen.add(version.versionId);\n      unique.push(version);\n    }\n    return unique.map((version, index) => {\n      const samplingLabel = version.sampling ?? \"unspecified\";\n      const step = stepLabel(version.step);\n      const stepDisplay = step || `sampling ${samplingLabel}`;\n      return {\n        id: version.versionId,\n        content: version.content,\n        wordCount: version.wordCount,\n        shortLabel: `V${index + 1}`,\n        label: `Version ${index + 1} \\u2022 ${new Date(version.generatedAt).toLocaleString()} \\u2022 ${stepDisplay}`,\n      };\n    });\n  }, [item.generationHistory]);\n\n  const activeVersionId = item.activeVersionId || versions[versions.length - 1]?.id;\n\n  const [selectedVersionId, setSelectedVersionId] = useState(activeVersionId);\n  const [compareToVersionId, setCompareToVersionId] = useState(\"\");\n\n  useEffect(() => {\n    setSelectedVersionId(activeVersionId);\n    setCompareToVersionId(\"\");\n  }, [activeVersionId, item.chronicleId]);\n\n  useEffect(() => {\n    if (versions.length === 0) return;\n\n    const hasSelected = versions.some((v) => v.id === selectedVersionId);\n    let nextSelected = selectedVersionId;\n    if (!hasSelected) {\n      const hasActive = versions.some((v) => v.id === activeVersionId);\n      nextSelected = hasActive ? activeVersionId : versions[versions.length - 1].id;\n      setSelectedVersionId(nextSelected);\n    }\n\n    if (compareToVersionId) {\n      const hasCompare = versions.some((v) => v.id === compareToVersionId);\n      if (!hasCompare || compareToVersionId === nextSelected) {\n        setCompareToVersionId(\"\");\n      }\n    }\n  }, [versions, selectedVersionId, compareToVersionId, activeVersionId]);\n\n  const selectedVersion = useMemo(\n    () => versions.find((v) => v.id === selectedVersionId) || versions[versions.length - 1],\n    [versions, selectedVersionId]\n  );\n\n  const compareToVersion = useMemo(\n    () => (compareToVersionId ? versions.find((v) => v.id === compareToVersionId) : null),\n    [versions, compareToVersionId]\n  );\n\n  const versionLabelMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.shortLabel);\n    return map;\n  }, [versions]);\n\n  const versionContentMap = useMemo(() => {\n    const map = new Map();\n    for (const v of versions) map.set(v.id, v.content);\n    return map;\n  }, [versions]);\n\n  const getVersionLabel = (versionId) => versionLabelMap.get(versionId) || \"Unknown\";\n\n  const formatTargetIndicator = (targetVersionId) => {\n    if (!targetVersionId) return null;\n    const targetLabel = getVersionLabel(targetVersionId);\n    const activeLabel = getVersionLabel(activeVersionId);\n    if (targetVersionId === activeVersionId) return null;\n    return `Targets ${targetLabel} \\u2022 Active ${activeLabel}`;\n  };\n\n  const summaryIndicator = formatTargetIndicator(item.summaryTargetVersionId);\n  const imageRefsIndicator = formatTargetIndicator(item.imageRefsTargetVersionId);\n  const imageRefsTargetContent =\n    versionContentMap.get(item.imageRefsTargetVersionId || activeVersionId) ||\n    item.assembledContent;\n\n  const compareRunning = refinements?.compare?.running || false;\n  const combineRunning = refinements?.combine?.running || false;\n  const copyEditRunning = refinements?.copyEdit?.running || false;\n  const temporalCheckRunning = refinements?.temporalCheck?.running || false;\n  const quickCheckRunning = refinements?.quickCheck?.running || false;\n\n  // ---------------------------------------------------------------------------\n  // Tertiary cast \u2014 manual detect + persisted on ChronicleRecord\n  // ---------------------------------------------------------------------------\n  const detectTertiaryCast = useCallback(async () => {\n    if (!simulationRunId) return;\n    const content = isComplete\n      ? item.finalContent\n      : selectedVersion?.content || item.assembledContent;\n    if (!content) return;\n\n    // Read fresh entities from Dexie so newly added/edited entities are included\n    const freshEntities = await getEntitiesForRun(simulationRunId);\n    const freshEntityMap = new Map(freshEntities.map((e) => [e.id, e]));\n\n    // Build name/alias dictionary for Aho-Corasick (exclude eras \u2014 too generic)\n    const wikiEntities = [];\n    for (const entity of freshEntities) {\n      if (entity.kind === \"era\") continue;\n      wikiEntities.push({ id: entity.id, name: entity.name });\n      const aliases = entity.enrichment?.text?.aliases;\n      if (Array.isArray(aliases)) {\n        for (const alias of aliases) {\n          if (typeof alias === \"string\" && alias.length >= 3) {\n            wikiEntities.push({ id: entity.id, name: alias });\n          }\n        }\n      }\n    }\n\n    const mentions = findEntityMentions(content, wikiEntities);\n\n    const declaredIds = new Set(item.selectedEntityIds || []);\n\n    // Preserve existing accepted/rejected decisions for entities still detected\n    const prevDecisions = new Map((item.tertiaryCast || []).map((e) => [e.entityId, e.accepted]));\n\n    const seen = new Set();\n    const entries = [];\n    for (const m of mentions) {\n      if (declaredIds.has(m.entityId) || seen.has(m.entityId)) continue;\n      seen.add(m.entityId);\n      const entity = freshEntityMap.get(m.entityId);\n      if (entity) {\n        entries.push({\n          entityId: entity.id,\n          name: entity.name,\n          kind: entity.kind,\n          matchedAs: content.slice(m.start, m.end),\n          matchStart: m.start,\n          matchEnd: m.end,\n          accepted: prevDecisions.get(entity.id) ?? true,\n        });\n      }\n    }\n\n    const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n    await updateChronicleTertiaryCast(item.chronicleId, entries);\n    await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n  }, [\n    simulationRunId,\n    isComplete,\n    item.finalContent,\n    item.assembledContent,\n    item.selectedEntityIds,\n    item.chronicleId,\n    item.tertiaryCast,\n    selectedVersion,\n  ]);\n\n  const toggleTertiaryCast = useCallback(\n    async (entityId) => {\n      const current = item.tertiaryCast || [];\n      const updated = current.map((e) =>\n        e.entityId === entityId ? { ...e, accepted: !e.accepted } : e\n      );\n      const { updateChronicleTertiaryCast } = await import(\"../../lib/db/chronicleRepository\");\n      await updateChronicleTertiaryCast(item.chronicleId, updated);\n      await useChronicleStore.getState().refreshChronicle(item.chronicleId);\n    },\n    [item.chronicleId, item.tertiaryCast]\n  );\n\n  // ---------------------------------------------------------------------------\n  // Seed data\n  // ---------------------------------------------------------------------------\n  const seedData = useMemo(\n    () => ({\n      narrativeStyleId: item.narrativeStyleId || \"\",\n      narrativeStyleName:\n        item.narrativeStyle?.name ||\n        styleLibrary?.narrativeStyles?.find((s) => s.id === item.narrativeStyleId)?.name,\n      entrypointId: item.entrypointId,\n      entrypointName: item.entrypointId\n        ? entities?.find((e) => e.id === item.entrypointId)?.name\n// ... (truncated)", "parameters": [{"name": "{\n  item,\n\n  // Actions\n  onAccept,\n  onRegenerate,\n  onRegenerateWithSampling,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onCompareVersions,\n  onCombineVersions,\n  onCopyEdit,\n  onTemporalCheck,\n  onQuickCheck,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onAcceptPendingTitle,\n  onRejectPendingTitle,\n  onGenerateImageRefs,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleTemporalContext,\n  onUpdateChronicleActiveVersion,\n  onDeleteVersion,\n  onUpdateCombineInstructions,\n  onUnpublish,\n\n  // Cover image\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  styleSelection,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n\n  // Image layout edits\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n\n  // Image ref selections (version migration)\n  onApplyImageRefSelections,\n\n  // Select existing image for a ref\n  onSelectExistingImage,\n\n  // Select existing image for cover\n  onSelectExistingCoverImage,\n\n  // Export\n  onExport,\n\n  // Lore backport\n  onBackportLore,\n\n  // Historian review\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  isHistorianActive,\n  onUpdateHistorianNote,\n  onGeneratePrep,\n\n  // State\n  isGenerating,\n  refinements,\n\n  // Data\n  simulationRunId,\n  worldSchema,\n  entities,\n  styleLibrary,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  eras,\n  events,\n  onNavigateToTab,\n}", "type": "{ item: any; onAccept: any; onRegenerate: any; onRegenerateWithSampling: any; onRegenerateFull: any; onRegenerateCreative: any; onCompareVersions: any; onCombineVersions: any; onCopyEdit: any; onTemporalCheck: any; onQuickCheck: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onAcceptPendingTitle: any; onRejectPendingTitle: any; onGenerateImageRefs: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: an...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ContentTab.jsx", "sourceCode": "// ============================================================================\n// Content Tab\n// ============================================================================\n\nexport default function ContentTab({\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}) {\n  const content = isComplete\n    ? item.finalContent\n    : selectedVersion?.content || item.assembledContent;\n\n  const wc = isComplete\n    ? item.finalContent?.split(/\\s+/).filter(Boolean).length || 0\n    : (selectedVersion?.wordCount ??\n      (item.assembledContent?.split(/\\s+/).filter(Boolean).length || 0));\n\n  const copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\n  const [summaryExpanded, setSummaryExpanded] = useState(false);\n  const [tertiaryCastExpanded, setTertiaryCastExpanded] = useState(false);\n  const [hoveredTertiaryId, setHoveredTertiaryId] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n\n  const handleTertiaryMouseEnter = useCallback((entityId) => {\n    clearTimeout(hoverTimeoutRef.current);\n    setHoveredTertiaryId(entityId);\n  }, []);\n  const handleTertiaryMouseLeave = useCallback(() => {\n    hoverTimeoutRef.current = setTimeout(() => setHoveredTertiaryId(null), 150);\n  }, []);\n\n  const hasTertiaryCast = item.tertiaryCast?.length > 0;\n  const tertiaryExpanded = tertiaryCastExpanded && hasTertiaryCast;\n\n  return (\n    <div>\n      {/* Summary (collapsible) */}\n      {item.summary && (\n        <div className=\"ctab-summary-section\">\n          <div\n            onClick={() => setSummaryExpanded((v) => !v)}\n            className={`ctab-summary-header ${summaryExpanded ? \"ctab-summary-header-expanded\" : \"\"}`}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            <span className=\"ctab-summary-label\">\n              <span className=\"ctab-collapse-icon\">{summaryExpanded ? \"\\u25BC\" : \"\\u25B6\"}</span>\n              Summary\n            </span>\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                navigator.clipboard.writeText(item.summary);\n              }}\n              className=\"ctab-copy-btn\"\n            >\n              Copy\n            </button>\n          </div>\n          {summaryExpanded && <div className=\"ctab-summary-body\">{item.summary}</div>}\n        </div>\n      )}\n\n      {/* Tertiary cast -- entities mentioned but not in declared cast (persisted) */}\n      <div className=\"ctab-tertiary-section\">\n        <div\n          onClick={() => hasTertiaryCast && setTertiaryCastExpanded((v) => !v)}\n          className={`ctab-tertiary-header ${hasTertiaryCast ? \"ctab-tertiary-header-expandable\" : \"ctab-tertiary-header-default\"} ${tertiaryExpanded ? \"ctab-tertiary-header-expanded\" : \"ctab-tertiary-header-collapsed\"}`}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className=\"ctab-tertiary-label\">\n            {hasTertiaryCast && (\n              <span className=\"ctab-collapse-icon\">\n                {tertiaryCastExpanded ? \"\\u25BC\" : \"\\u25B6\"}\n              </span>\n            )}\n            Tertiary Cast\n            {hasTertiaryCast && (\n              <span className=\"ctab-tertiary-count\">\n                {item.tertiaryCast.filter((e) => e.accepted).length}/{item.tertiaryCast.length}\n              </span>\n            )}\n          </span>\n          <button\n            onClick={(e) => {\n              e.stopPropagation();\n              onDetectTertiaryCast?.();\n            }}\n            disabled={!content}\n            className={`ctab-detect-btn ${content ? \"ctab-detect-btn-enabled\" : \"ctab-detect-btn-disabled\"}`}\n          >\n            {item.tertiaryCast ? \"Re-detect\" : \"Detect\"}\n          </button>\n        </div>\n        {tertiaryExpanded && (\n          <div className=\"ctab-tertiary-body\">\n            <div className=\"ctab-tertiary-chips\">\n              {item.tertiaryCast.map((entry) => {\n                const isHovered = hoveredTertiaryId === entry.entityId;\n                // Build context snippet from content if we have match positions\n                let contextSnippet = null;\n                if (isHovered && content && entry.matchStart != null && entry.matchEnd != null) {\n                  const radius = 80;\n                  const snippetStart = Math.max(0, entry.matchStart - radius);\n                  const snippetEnd = Math.min(content.length, entry.matchEnd + radius);\n                  const before =\n                    (snippetStart > 0 ? \"\\u2026\" : \"\") +\n                    content.slice(snippetStart, entry.matchStart);\n                  const matched = content.slice(entry.matchStart, entry.matchEnd);\n                  const after =\n                    content.slice(entry.matchEnd, snippetEnd) +\n                    (snippetEnd < content.length ? \"\\u2026\" : \"\");\n                  contextSnippet = { before, matched, after };\n                }\n                return (\n                  <span\n                    key={entry.entityId}\n                    className=\"ctab-tertiary-chip-wrapper\"\n                    onMouseEnter={() => handleTertiaryMouseEnter(entry.entityId)}\n                    onMouseLeave={handleTertiaryMouseLeave}\n                  >\n                    <span\n                      onClick={() => onToggleTertiaryCast?.(entry.entityId)}\n                      className={`ctab-tertiary-chip ${entry.accepted ? \"ctab-tertiary-chip-accepted\" : \"ctab-tertiary-chip-rejected\"}`}\n                      role=\"button\"\n                      tabIndex={0}\n                      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                    >\n                      {entry.name}\n                      <span className=\"ctab-tertiary-chip-kind\">{entry.kind}</span>\n                    </span>\n                    {isHovered && (\n                      <div className=\"ctab-tertiary-tooltip\">\n                        <div className=\"ctab-tooltip-header\">\n                          <span>{entry.kind}</span>\n                          <span>click to {entry.accepted ? \"reject\" : \"accept\"}</span>\n                        </div>\n                        {contextSnippet && (\n                          <div className=\"ctab-tooltip-context\">\n                            {contextSnippet.before}\n                            <span className=\"ctab-tooltip-match-highlight\">\n                              {contextSnippet.matched}\n                            </span>\n                            {contextSnippet.after}\n                          </div>\n                        )}\n                        {!contextSnippet && entry.matchedAs !== entry.name && (\n                          <div className=\"ctab-tooltip-matched-as\">\n                            matched as &ldquo;\n                            <span className=\"ctab-tooltip-matched-name\">{entry.matchedAs}</span>\n                            &rdquo;\n                          </div>\n                        )}\n                        <div className=\"ctab-tooltip-arrow\" />\n                      </div>\n                    )}\n                  </span>\n                );\n              })}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Version selector for assembly mode */}\n      {!isComplete && versions && versions.length > 1 && (\n        <div className=\"ctab-version-selector\">\n          <ChronicleVersionSelector\n            versions={versions}\n            selectedVersionId={selectedVersionId}\n            activeVersionId={activeVersionId}\n            compareToVersionId={compareToVersionId}\n            onSelectVersion={onSelectVersion}\n            onSelectCompareVersion={onSelectCompareVersion}\n            onSetActiveVersion={onSetActiveVersion}\n            onDeleteVersion={onDeleteVersion}\n            disabled={isGenerating}\n          />\n        </div>\n      )}\n\n      <AssembledContentViewer\n        content={content}\n        wordCount={wc}\n        onCopy={() => copyToClipboard(content)}\n        compareContent={!isComplete ? compareToVersion?.content : undefined}\n        compareLabel={!isComplete ? compareToVersion?.shortLabel : undefined}\n        onQuickCheck={onQuickCheck}\n        quickCheckRunning={quickCheckRunning}\n        quickCheckReport={item.quickCheckReport}\n        onShowQuickCheck={onShowQuickCheck}\n        onFindReplace={onFindReplace}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isComplete,\n  versions,\n  selectedVersion,\n  compareToVersion,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  isGenerating,\n  onQuickCheck,\n  quickCheckRunning,\n  onShowQuickCheck,\n  onFindReplace,\n  onDetectTertiaryCast,\n  onToggleTertiaryCast,\n}", "type": "{ item: any; isComplete: any; versions: any; selectedVersion: any; compareToVersion: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; isGenerating: any; onQuickCheck: any; quickCheckRunning: any; onShowQuickCheck: any; onFindReplace: any; onDetectTertiaryCast: any; onToggleTertiaryCast: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/EnrichmentTab.jsx", "sourceCode": "export default function EnrichmentTab({\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}) {\n  const titleState = refinements?.title || {};\n  const summaryState = refinements?.summary || {};\n  const formatTimestamp = (ts) => new Date(ts).toLocaleString();\n\n  const titleDisabled = isGenerating || titleState.running;\n  const summaryDisabled = isGenerating || summaryState.running;\n\n  return (\n    <div>\n      <div className=\"enrtab-container\">\n        <div className=\"enrtab-heading\">Post-Publish Enrichment</div>\n        <div className=\"enrtab-sections\">\n          {/* Title */}\n          {onGenerateTitle && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Title</div>\n                <div className=\"enrtab-hint\">\n                  Two-phase title generation: extract fragments, then shape candidates.\n                </div>\n                {item.titleGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.titleGeneratedAt)}\n                  </div>\n                )}\n                {item.titleCandidates?.length > 0 && (\n                  <div className=\"enrtab-candidates\">\n                    <span className=\"enrtab-candidate-selected\">&#x25C6; {item.title}</span>\n                    <br />\n                    {item.titleCandidates.map((c, i) => (\n                      <span key={i}>\n                        <span className=\"enrtab-candidate-alt\">&#x25C7;</span> {c}\n                        {i < item.titleCandidates.length - 1 ? <br /> : null}\n                      </span>\n                    ))}\n                  </div>\n                )}\n                {item.titleFragments?.length > 0 && (\n                  <div className=\"enrtab-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateTitle}\n                disabled={titleDisabled}\n                className={`enrtab-button ${titleDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {titleState.running ? \"Generating...\" : \"Regenerate Title\"}\n              </button>\n            </div>\n          )}\n\n          {/* Summary */}\n          {onGenerateSummary && (\n            <div className=\"enrtab-row\">\n              <div>\n                <div className=\"enrtab-label\">Summary</div>\n                <div className=\"enrtab-hint\">\n                  Regenerate the short summary for chronicle listings.\n                </div>\n                {item.summaryGeneratedAt && (\n                  <div className=\"enrtab-timestamp\">\n                    Last generated: {formatTimestamp(item.summaryGeneratedAt)}\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onGenerateSummary}\n                disabled={summaryDisabled}\n                className={`enrtab-button ${summaryDisabled ? \"enrtab-button-disabled\" : \"\"}`}\n              >\n                {summaryState.running ? \"Generating...\" : \"Regenerate Summary\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onGenerateTitle,\n  onGenerateSummary,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onGenerateTitle: any; onGenerateSummary: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/HistorianTab.jsx", "sourceCode": "export default function HistorianTab({\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}) {\n  return <div>\n      {/* Tone Assignment */}\n      {onSetAssignedTone && <div className=\"htab-section\">\n          <div className=\"htab-tone-header\">\n            <div className=\"htab-section-title\">Tone</div>\n            {item.toneRanking?.ranking && <div className=\"htab-tone-ranking\">\n                Ranked:{\" \"}\n                {item.toneRanking.ranking.map((tone, i) => {\n            const meta = TONE_META[tone];\n            const perTone = item.toneRanking.rationales?.[tone];\n            return <span key={i}\n            className=\"htab-tone-rank-item\"\n            title={perTone || item.toneRanking.rationale || undefined} style={{\n              // eslint-disable-next-line local/no-inline-styles -- dynamic opacity based on rank index\n              \"--htab-rank-opacity\": i === 0 ? 1 : i === 1 ? 0.6 : 0.4\n            }}>\n                      {i > 0 ? \" > \" : \"\"}\n                      {meta?.label || tone}\n                    </span>;\n          })}\n              </div>}\n            {onDetectTone && <button onClick={onDetectTone} disabled={isGenerating} className=\"htab-tone-detect-btn\" title=\"Run LLM tone detection for this chronicle\">\n                Detect\n              </button>}\n          </div>\n          <div className=\"htab-tone-buttons\">\n            {ANNOTATION_TONES.map(tone => {\n          const meta = TONE_META[tone];\n          const isAssigned = item.assignedTone === tone;\n          const perTone = item.toneRanking?.rationales?.[tone];\n          return <button key={tone} onClick={() => onSetAssignedTone(tone)} className={`htab-tone-btn ${isAssigned ? \"htab-tone-btn-active\" : \"\"}`} title={perTone || meta?.description || tone}>\n                  {meta?.symbol} {meta?.label || tone}\n                </button>;\n        })}\n          </div>\n        </div>}\n\n      {/* Historian Review */}\n      {onHistorianReview && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb12\">Annotate</div>\n          <div className=\"htab-annotate-row\">\n            {item.assignedTone && (() => {\n          const meta = TONE_META[item.assignedTone];\n          return <button onClick={() => onHistorianReview(item.assignedTone)} disabled={isGenerating || isHistorianActive} className=\"htab-annotate-btn\" title={`Run historian review with assigned tone: ${meta?.label || item.assignedTone}`}>\n                    <span className=\"htab-annotate-btn-symbol\">{meta?.symbol || \"?\"}</span>\n                    {item.historianNotes?.length > 0 ? \"Re-annotate\" : \"Annotate\"} (\n                    {meta?.label || item.assignedTone})\n                  </button>;\n        })()}\n            <HistorianToneSelector onSelect={tone => onHistorianReview(tone)} disabled={isGenerating || isHistorianActive} hasNotes={item.historianNotes?.length > 0} label={item.assignedTone ? \"Override\" : undefined} />\n            {!item.assignedTone && <div className=\"htab-annotate-hint\">\n                Select a tone to generate historian margin notes.\n              </div>}\n          </div>\n        </div>}\n\n      {/* Margin Notes */}\n      {item.historianNotes?.length > 0 && <div className=\"htab-margin-notes\">\n          <HistorianMarginNotes notes={item.historianNotes} sourceText={item.finalContent} onUpdateNote={onUpdateHistorianNote ? (noteId, updates) => onUpdateHistorianNote(\"chronicle\", item.chronicleId, noteId, updates) : undefined} />\n        </div>}\n\n      {/* Historian Prep */}\n      {onGeneratePrep && <div className=\"htab-section\">\n          <div className=\"htab-section-title htab-section-title-mb8\">Historian Prep</div>\n          <div className=\"htab-prep-description\">\n            Private reading notes in the historian&apos;s voice \u2014 observations and thematic threads for\n            era narrative input.\n          </div>\n          <div className=\"htab-prep-actions\">\n            <button onClick={onGeneratePrep} disabled={isGenerating} className=\"htab-prep-btn\" title={item.historianPrep ? \"Regenerate historian reading notes for this chronicle\" : \"Generate historian reading notes for this chronicle\"}>\n              {item.historianPrep ? \"Regenerate Prep Brief\" : \"Generate Prep Brief\"}\n            </button>\n            {item.historianPrepGeneratedAt && <span className=\"htab-prep-date\" title={`Generated ${new Date(item.historianPrepGeneratedAt).toLocaleString()}`}>\n                Generated {new Date(item.historianPrepGeneratedAt).toLocaleDateString()}\n              </span>}\n          </div>\n          {item.historianPrep && <div className=\"htab-prep-content\">{item.historianPrep}</div>}\n        </div>}\n\n      {/* Lore Backport */}\n      {onBackportLore && <div className=\"htab-section\">\n          <div className=\"htab-lore-title\">Lore Integration</div>\n          <BackportLoreButton item={item} onBackportLore={onBackportLore} isGenerating={isGenerating} />\n        </div>}\n\n      {!onHistorianReview && !onBackportLore && !onGeneratePrep && (item.historianNotes?.length ?? 0) <= 0 && <div className=\"htab-empty\">No historian tools available for this chronicle.</div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  isHistorianActive,\n  onHistorianReview,\n  onSetAssignedTone,\n  onDetectTone,\n  onUpdateHistorianNote,\n  onBackportLore,\n  onGeneratePrep\n}", "type": "{ item: any; isGenerating: any; isHistorianActive: any; onHistorianReview: any; onSetAssignedTone: any; onDetectTone: any; onUpdateHistorianNote: any; onBackportLore: any; onGeneratePrep: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ImagesTab.jsx", "sourceCode": "// ============================================================================\n// Images Tab\n// ============================================================================\n\nexport default function ImagesTab({\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}) {\n  // Compatibility analysis state\n  const [compatibilityAnalysis, setCompatibilityAnalysis] = useState(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [isApplying, setIsApplying] = useState(false);\n  const [imageRefSelections, setImageRefSelections] = useState([]);\n\n  // Cover image picker state\n  const [showCoverImagePicker, setShowCoverImagePicker] = useState(false);\n\n  // Check if image refs are for a different version\n  const hasVersionMismatch = useMemo(() => {\n    if (!item.imageRefs || !item.imageRefsTargetVersionId || !activeVersionId) return false;\n    return item.imageRefsTargetVersionId !== activeVersionId;\n  }, [item.imageRefs, item.imageRefsTargetVersionId, activeVersionId]);\n\n  // Handle analyze compatibility\n  const handleAnalyzeCompatibility = useCallback(() => {\n    if (!item.imageRefs || !versions || !activeVersionId || !item.imageRefsTargetVersionId) return;\n    setIsAnalyzing(true);\n\n    // Find the content for source and target versions\n    const sourceVersion = versions.find(v => v.id === item.imageRefsTargetVersionId);\n    const targetVersion = versions.find(v => v.id === activeVersionId);\n    const sourceContent = sourceVersion?.content || \"\";\n    const targetContent = targetVersion?.content || chronicleText || \"\";\n    if (!sourceContent || !targetContent) {\n      console.warn(\"[ImagesTab] Missing content for compatibility analysis\");\n      setIsAnalyzing(false);\n      return;\n    }\n    try {\n      const analysis = analyzeImageRefCompatibility(item.imageRefs, sourceContent, targetContent, item.imageRefsTargetVersionId, activeVersionId);\n      setCompatibilityAnalysis(analysis);\n      setImageRefSelections(createDefaultSelections(analysis));\n    } catch (err) {\n      console.error(\"[ImagesTab] Compatibility analysis failed:\", err);\n    }\n    setIsAnalyzing(false);\n  }, [item.imageRefs, item.imageRefsTargetVersionId, versions, activeVersionId, chronicleText]);\n\n  // Handle selection change\n  const handleSelectionChange = useCallback((refId, action) => {\n    setImageRefSelections(prev => prev.map(s => s.refId === refId ? {\n      ...s,\n      action\n    } : s));\n  }, []);\n\n  // Handle apply selections\n  const handleApplySelections = useCallback(async () => {\n    if (!onApplyImageRefSelections || !activeVersionId || imageRefSelections.length === 0) return;\n    setIsApplying(true);\n    try {\n      await onApplyImageRefSelections(imageRefSelections, activeVersionId);\n      // Clear analysis state after successful apply\n      setCompatibilityAnalysis(null);\n      setImageRefSelections([]);\n    } catch (err) {\n      console.error(\"[ImagesTab] Failed to apply selections:\", err);\n    }\n    setIsApplying(false);\n  }, [onApplyImageRefSelections, activeVersionId, imageRefSelections]);\n  return <div>\n      {/* Cover Image */}\n      {(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-cover-section\">\n          <div className=\"itab-cover-heading\">Cover Image</div>\n          <div className=\"itab-cover-layout\">\n            <div className=\"itab-cover-info\">\n              <div className=\"itab-cover-desc\">\n                Generate a montage-style cover image for this chronicle.\n              </div>\n              {!item.coverImage && <div className=\"itab-cover-status itab-cover-status-default\">Not run yet</div>}\n              {item.coverImage && item.coverImage.status === \"pending\" && <div className=\"itab-cover-status itab-cover-status-pending\">\n                  Scene ready - click Generate Image to create\n                </div>}\n              {item.coverImage && item.coverImage.status === \"generating\" && <div className=\"itab-cover-status itab-cover-status-generating\">\n                  Generating image...\n                </div>}\n              {item.coverImage && item.coverImage.status === \"complete\" && <div className=\"itab-cover-status itab-cover-status-complete\">Complete</div>}\n              {item.coverImage && item.coverImage.status === \"failed\" && <div className=\"itab-cover-status itab-cover-status-failed\">\n                  Failed{item.coverImage.error ? `: ${item.coverImage.error}` : \"\"}\n                </div>}\n              {item.coverImage?.sceneDescription && <div className=\"itab-scene-desc\">{item.coverImage.sceneDescription}</div>}\n              <CoverImagePreview imageId={item.coverImage?.generatedImageId} onImageClick={onImageClick} />\n            </div>\n            <div className=\"itab-cover-actions\">\n              <div className=\"itab-cover-btn-row\">\n                {onGenerateCoverImageScene && <button onClick={onGenerateCoverImageScene} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                    {item.coverImage ? \"Regen Scene\" : \"Gen Scene\"}\n                  </button>}\n                {onGenerateCoverImage && item.coverImage && (item.coverImage.status === \"pending\" || item.coverImage.status === \"complete\" || item.coverImage.status === \"failed\") && <button onClick={onGenerateCoverImage} disabled={isGenerating} className={`itab-cover-btn ${isGenerating ? \"itab-cover-btn-disabled\" : \"itab-cover-btn-enabled\"}`}>\n                      {item.coverImage.status === \"complete\" ? \"Regen Image\" : \"Gen Image\"}\n                    </button>}\n                {onSelectExistingCoverImage && item.coverImage && !isGenerating && <button onClick={() => setShowCoverImagePicker(true)} className=\"itab-cover-btn itab-cover-btn-enabled\">\n                    Select Existing\n                  </button>}\n              </div>\n            </div>\n          </div>\n        </div>}\n\n      {/* Cover Image Picker */}\n      {item.projectId && <ChronicleImagePicker isOpen={showCoverImagePicker} onClose={() => setShowCoverImagePicker(false)} onSelect={imageId => {\n      if (onSelectExistingCoverImage) {\n        onSelectExistingCoverImage(imageId);\n      }\n      setShowCoverImagePicker(false);\n    }} projectId={item.projectId} chronicleId={item.chronicleId} currentImageId={item.coverImage?.generatedImageId} />}\n\n      {/* Version Mismatch Warning */}\n      {hasVersionMismatch && item.imageRefs && <ImageRefVersionWarning item={item} versions={versions} activeVersionId={activeVersionId} chronicleText={chronicleText} onAnalyzeCompatibility={handleAnalyzeCompatibility} isAnalyzing={isAnalyzing} />}\n\n      {/* Compatibility Analysis Results */}\n      {compatibilityAnalysis && item.imageRefs && <ImageRefCompatibilityResults analysis={compatibilityAnalysis} imageRefs={item.imageRefs} entityMap={entityMap} onSelectionChange={handleSelectionChange} selections={imageRefSelections} onApply={handleApplySelections} isApplying={isApplying} />}\n\n      {/* Image Anchors */}\n      {item.imageRefs && entityMap && <div>\n          <div className=\"itab-anchors-heading\">\n            Image Anchors\n            <span className=\"itab-anchors-count\">({item.imageRefs.refs?.length || 0} placed)</span>\n          </div>\n          <ChronicleImagePanel imageRefs={item.imageRefs} entities={entityMap} onGenerateImage={onGenerateChronicleImage} onResetImage={onResetChronicleImage} onRegenerateDescription={onRegenerateDescription} onUpdateAnchorText={onUpdateChronicleAnchorText} onUpdateSize={onUpdateChronicleImageSize} onUpdateJustification={onUpdateChronicleImageJustification} onSelectExistingImage={onSelectExistingImage} projectId={item.projectId} chronicleId={item.chronicleId} chronicleText={chronicleText} isGenerating={isGenerating} styleLibrary={styleLibrary} styleSelection={styleSelection} cultures={cultures} cultureIdentities={cultureIdentities} worldContext={worldContext} chronicleTitle={item.title || item.name} imageSize={imageSize} imageQuality={imageQuality} imageModel={imageModel} imageGenSettings={imageGenSettings} onOpenImageSettings={onOpenImageSettings} />\n        </div>}\n\n      {!item.imageRefs && !(onGenerateCoverImageScene || onGenerateCoverImage) && <div className=\"itab-empty\">\n          No images generated yet. Use the Pipeline tab to generate image refs and cover images.\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  entityMap,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onGenerateChronicleImage,\n  onResetChronicleImage,\n  onRegenerateDescription,\n  onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification,\n  styleLibrary,\n  styleSelection,\n  cultures,\n  cultureIdentities,\n  worldContext,\n  imageSize,\n  imageQuality,\n  imageModel,\n  imageGenSettings,\n  onOpenImageSettings,\n  chronicleText,\n  versions,\n  activeVersionId,\n  onApplyImageRefSelections,\n  onSelectExistingImage,\n  onSelectExistingCoverImage\n}", "type": "{ item: any; isGenerating: any; entityMap: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onGenerateChronicleImage: any; onResetChronicleImage: any; onRegenerateDescription: any; onUpdateChronicleAnchorText: any; onUpdateChronicleImageSize: any; onUpdateChronicleImageJustification: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; imageSize: any; imageQuality: any; imageModel: any; imageGenSettings: any; ...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/PipelineTab.jsx", "sourceCode": "// ============================================================================\n// Pipeline Tab\n// ============================================================================\n\nexport default function PipelineTab({\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}) {\n  const summaryState = refinements?.summary || {};\n  const titleState = refinements?.title || {};\n  const imageRefsState = refinements?.imageRefs || {};\n\n  const completedCount = [\n    summaryState.generatedAt,\n    titleState.generatedAt,\n    item.coverImage?.status === \"complete\",\n    imageRefsState.generatedAt,\n    item.cohesionReport,\n  ].filter(Boolean).length;\n\n  return (\n    <div>\n      {/* Refinement Checklist */}\n      <div className=\"pt-checklist\">\n        <div className=\"pt-checklist-header\">\n          <span>Refinements</span>\n          <span className=\"pt-checklist-count\">{completedCount}/5 complete</span>\n        </div>\n        <div className=\"pt-checklist-items\">\n          <RefinementRow\n            label=\"Summary\"\n            description=\"Generate a short summary for chronicle listings.\"\n            state={summaryState}\n            indicator={summaryIndicator}\n            onAction={onGenerateSummary}\n            isGenerating={isGenerating}\n          />\n\n          {/* Title - with candidates display */}\n          <div className=\"pt-refrow\">\n            <div className=\"pt-refrow-content\">\n              <div className=\"pt-refrow-title\">\n                <span\n                  className={`pt-refrow-checkbox ${titleState.generatedAt ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                >\n                  {titleState.generatedAt ? \"\\u2611\" : \"\\u2610\"}\n                </span>\n                Title\n              </div>\n              <div className=\"pt-refrow-description\">\n                Generate an evocative title using single-pass candidate generation.\n              </div>\n              {titleState.generatedAt && (\n                <div className=\"pt-refrow-meta\">\n                  Done - {new Date(titleState.generatedAt).toLocaleString()}\n                  {titleState.model ? ` - ${titleState.model}` : \"\"}\n                </div>\n              )}\n              {item.titleCandidates?.length > 0 && (\n                <div className=\"pt-title-candidates\">\n                  <span className=\"pt-title-selected\">&#x25C6; {item.title}</span>\n                  <br />\n                  {item.titleCandidates.map((c, i) => (\n                    <span key={i}>\n                      <span className=\"pt-title-candidate-icon\">&#x25C7;</span> {c}\n                      {i < item.titleCandidates.length - 1 ? <br /> : null}\n                    </span>\n                  ))}\n                </div>\n              )}\n              {item.titleFragments?.length > 0 && (\n                <div className=\"pt-title-fragments\">~ {item.titleFragments.join(\" \\u00b7 \")}</div>\n              )}\n              {!titleState.generatedAt && !titleState.running && (\n                <div className=\"pt-refrow-meta\">Not run yet</div>\n              )}\n              {titleState.running && <div className=\"pt-refrow-meta\">Running...</div>}\n            </div>\n            {onGenerateTitle && (\n              <button\n                onClick={onGenerateTitle}\n                disabled={isGenerating || titleState.running}\n                className={`pt-refrow-btn ${isGenerating || titleState.running ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {titleState.generatedAt ? \"Regenerate\" : \"Generate\"}\n              </button>\n            )}\n          </div>\n\n          <CoverImageControls\n            item={item}\n            onGenerateCoverImageScene={onGenerateCoverImageScene}\n            onGenerateCoverImage={onGenerateCoverImage}\n            isGenerating={isGenerating}\n            onImageClick={onImageClick}\n          />\n\n          <RefinementRow\n            label=\"Image Refs\"\n            description=\"Generate image placement suggestions for this chronicle.\"\n            state={imageRefsState}\n            indicator={imageRefsIndicator}\n            onAction={onGenerateImageRefs}\n            isGenerating={isGenerating}\n          />\n\n          {onValidate && (\n            <div className=\"pt-refrow\">\n              <div>\n                <div className=\"pt-refrow-title\">\n                  <span\n                    className={`pt-refrow-checkbox ${item.cohesionReport ? \"pt-refrow-checkbox-done\" : \"pt-refrow-checkbox-pending\"}`}\n                  >\n                    {item.cohesionReport ? \"\\u2611\" : \"\\u2610\"}\n                  </span>\n                  Validate\n                </div>\n                <div className=\"pt-refrow-description\">\n                  Run quality validation to check narrative coherence.\n                </div>\n                {item.cohesionReport && (\n                  <div className=\"pt-refrow-meta\">\n                    Done - Score: {item.cohesionReport.overallScore}/100\n                  </div>\n                )}\n              </div>\n              <button\n                onClick={onValidate}\n                disabled={isGenerating}\n                className={`pt-refrow-btn ${isGenerating ? \"pt-refrow-btn-disabled\" : \"pt-refrow-btn-enabled\"}`}\n              >\n                {item.cohesionReport ? \"Revalidate\" : \"Validate\"}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  isGenerating,\n  refinements,\n  onValidate,\n  onGenerateSummary,\n  onGenerateTitle,\n  onGenerateImageRefs,\n  onGenerateCoverImageScene,\n  onGenerateCoverImage,\n  onImageClick,\n  onRegenerateWithSampling: _onRegenerateWithSampling,\n  entityMap: _entityMap,\n  styleLibrary: _styleLibrary,\n  styleSelection: _styleSelection,\n  cultures: _cultures,\n  cultureIdentities: _cultureIdentities,\n  worldContext: _worldContext,\n  summaryIndicator,\n  imageRefsIndicator,\n  imageRefsTargetContent: _imageRefsTargetContent,\n  imageSize: _imageSize,\n  imageQuality: _imageQuality,\n  imageModel: _imageModel,\n  imageGenSettings: _imageGenSettings,\n  onOpenImageSettings: _onOpenImageSettings,\n  onGenerateChronicleImage: _onGenerateChronicleImage,\n  onResetChronicleImage: _onResetChronicleImage,\n  onRegenerateDescription: _onRegenerateDescription,\n  onUpdateChronicleAnchorText: _onUpdateChronicleAnchorText,\n  onUpdateChronicleImageSize: _onUpdateChronicleImageSize,\n  onUpdateChronicleImageJustification: _onUpdateChronicleImageJustification,\n}", "type": "{ item: any; isGenerating: any; refinements: any; onValidate: any; onGenerateSummary: any; onGenerateTitle: any; onGenerateImageRefs: any; onGenerateCoverImageScene: any; onGenerateCoverImage: any; onImageClick: any; onRegenerateWithSampling: any; entityMap: any; styleLibrary: any; styleSelection: any; cultures: any; cultureIdentities: any; worldContext: any; summaryIndicator: any; imageRefsIndicator: any; imageRefsTargetContent: any; imageSize: any; imageQuality: any; imageModel: any; imageG...", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/ReferenceTab.jsx", "sourceCode": "// ============================================================================\n// Reference Tab\n// ============================================================================\n\nexport default function ReferenceTab({\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}) {\n  return (\n    <div>\n      {item.perspectiveSynthesis && (\n        <PerspectiveSynthesisViewer synthesis={item.perspectiveSynthesis} />\n      )}\n\n      <ExpandableSeedSection seed={seedData} defaultExpanded={false} />\n\n      {item.factCoverageReport && (\n        <>\n          <FactCoverageGrid report={item.factCoverageReport} />\n          <FactCoverageViewer\n            report={item.factCoverageReport}\n            generatedAt={item.factCoverageReportGeneratedAt}\n          />\n        </>\n      )}\n\n      <TemporalContextEditor\n        item={item}\n        eras={eras}\n        events={events}\n        entities={entities}\n        onUpdateTemporalContext={onUpdateTemporalContext}\n        onTemporalCheck={onTemporalCheck}\n        temporalCheckRunning={temporalCheckRunning}\n        isGenerating={isGenerating}\n      />\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  eras,\n  events,\n  entities,\n  isGenerating,\n  onUpdateTemporalContext,\n  onTemporalCheck,\n  temporalCheckRunning,\n  seedData,\n}", "type": "{ item: any; eras: any; events: any; entities: any; isGenerating: any; onUpdateTemporalContext: any; onTemporalCheck: any; temporalCheckRunning: any; seedData: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/VersionsTab.jsx", "sourceCode": "export default function VersionsTab({\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}) {\n  const [editingCombineInstructions, setEditingCombineInstructions] = useState(false);\n  const [combineInstructionsDraft, setCombineInstructionsDraft] = useState(\"\");\n\n  // Get current LLM settings for display\n  const llmConfigDisplay = useMemo(() => {\n    const perspectiveConfig = getCallConfig(\"perspective.synthesis\");\n    const generationConfig = getCallConfig(\"chronicle.generation\");\n    return {\n      perspective: formatLLMConfig(perspectiveConfig),\n      generation: formatLLMConfig(generationConfig)\n    };\n  }, []);\n  return <div>\n      {/* Version Selector */}\n      <div className=\"vtab-selector-wrap\">\n        <ChronicleVersionSelector versions={versions} selectedVersionId={selectedVersionId} activeVersionId={activeVersionId} compareToVersionId={compareToVersionId} onSelectVersion={onSelectVersion} onSelectCompareVersion={onSelectCompareVersion} onSetActiveVersion={onSetActiveVersion} onDeleteVersion={onDeleteVersion} disabled={isGenerating} />\n      </div>\n\n      {/* Compare & Combine */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">\n          Version Analysis\n          <span className=\"vtab-section-title-count\">\n            ({versions.length} version{versions.length !== 1 ? \"s\" : \"\"} available)\n          </span>\n        </div>\n        <div className=\"vtab-button-row\">\n          <button onClick={onCompareVersions} disabled={isGenerating || compareRunning || combineRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {compareRunning ? \"Comparing...\" : \"Compare Versions\"}\n          </button>\n          <button onClick={onCombineVersions} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || versions.length < 2} className=\"vtab-action-btn\">\n            {combineRunning ? \"Combining...\" : \"Combine Versions\"}\n          </button>\n          <button onClick={onCopyEdit} disabled={isGenerating || compareRunning || combineRunning || copyEditRunning || !item.assembledContent} title=\"Polish pass \u2014 smooths voice, trims to word count target, tightens prose. Produces a new version.\" className=\"vtab-action-btn\">\n            {copyEditRunning ? \"Copy-editing...\" : \"Copy-edit\"}\n          </button>\n          <button onClick={() => {\n          const list = item.generationHistory || [];\n          const byId = new Map();\n          for (const v of list) {\n            const arr = byId.get(v.versionId) || [];\n            arr.push(v);\n            byId.set(v.versionId, arr);\n          }\n          const duplicates = Array.from(byId.entries()).filter(([, arr]) => arr.length > 1).map(([id, arr]) => ({\n            id,\n            count: arr.length\n          }));\n          console.warn(\"[Chronicle][Debug] Version dump\", {\n            chronicleId: item.chronicleId,\n            activeVersionId: item.activeVersionId,\n            acceptedVersionId: item.acceptedVersionId,\n            assembledAt: item.assembledAt,\n            assembledContentLength: item.assembledContent?.length || 0,\n            versionCount: list.length,\n            duplicates,\n            versions: list.map((v, i) => ({\n              index: i,\n              versionId: v.versionId,\n              generatedAt: v.generatedAt,\n              step: v.step,\n              sampling: v.sampling,\n              model: v.model,\n              wordCount: v.wordCount,\n              contentLength: v.content?.length || 0\n            }))\n          });\n        }} disabled={isGenerating} title=\"Dump generationHistory to console\" className=\"vtab-action-btn\">\n            Dump Versions\n          </button>\n        </div>\n        <div className=\"vtab-hint-text\">\n          {versions.length < 2 ? \"Create a new version first to enable comparison and combination.\" : \"Compare produces an analysis report. Combine synthesizes all drafts into a new version. Copy-edit polishes the active version.\"}\n          {item.comparisonReport && !item.combineInstructions && <span className=\"vtab-warning-text\">\n              {\" \"}\n              Combine instructions missing \u2014 combine will use generic criteria.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(\"\");\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Set manually\n                </button>}\n            </span>}\n          {item.combineInstructions && <span className=\"vtab-success-text\">\n              {\" \"}\n              Combine instructions ready.\n              {onUpdateCombineInstructions && <button onClick={() => {\n            setCombineInstructionsDraft(item.combineInstructions);\n            setEditingCombineInstructions(true);\n          }} className=\"vtab-inline-btn\">\n                  Edit\n                </button>}\n            </span>}\n        </div>\n\n        {/* Combine Instructions Editor */}\n        {editingCombineInstructions && <div className=\"vtab-instructions-editor\">\n            <textarea value={combineInstructionsDraft} onChange={e => setCombineInstructionsDraft(e.target.value)} placeholder=\"Enter combine instructions \u2014 editorial direction for how to merge versions...\" className=\"vtab-textarea\" />\n            <div className=\"vtab-editor-actions\">\n              <button onClick={() => {\n            onUpdateCombineInstructions(combineInstructionsDraft.trim());\n            setEditingCombineInstructions(false);\n          }} disabled={!combineInstructionsDraft.trim()} className=\"vtab-save-btn\"\n          // eslint-disable-next-line local/no-inline-styles -- dynamic save button appearance from draft state\n          style={{\n            \"--vtab-save-bg\": combineInstructionsDraft.trim() ? \"var(--accent-color, #6366f1)\" : \"var(--bg-tertiary)\",\n            \"--vtab-save-color\": combineInstructionsDraft.trim() ? \"#fff\" : \"var(--text-muted)\",\n            \"--vtab-save-cursor\": combineInstructionsDraft.trim() ? \"pointer\" : \"not-allowed\"\n          }}>\n                Save\n              </button>\n              <button onClick={() => setEditingCombineInstructions(false)} className=\"vtab-cancel-btn\">\n                Cancel\n              </button>\n              {item.combineInstructions && <button onClick={() => {\n            onUpdateCombineInstructions(\"\");\n            setEditingCombineInstructions(false);\n          }} className=\"vtab-clear-btn\">\n                  Clear\n                </button>}\n            </div>\n          </div>}\n      </div>\n\n      {/* Create New Version */}\n      <div className=\"vtab-section\">\n        <div className=\"vtab-section-title\">Create New Version</div>\n\n        <div className=\"vtab-button-row-mb\">\n          {/* Regenerate with existing perspective */}\n          <button onClick={() => onRegenerateWithSampling?.()} disabled={isGenerating || compareRunning || combineRunning || !item.generationSystemPrompt || !item.generationUserPrompt} title=\"Reuse stored prompts with current LLM sampling settings (fast, same perspective)\" className=\"vtab-regen-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with existing perspective\"}\n          </button>\n\n          {/* Regenerate with new perspective */}\n          <button onClick={() => onRegenerateFull?.()} disabled={isGenerating || compareRunning || combineRunning || !onRegenerateFull} title=\"Run fresh perspective synthesis with current world facts & tone (slower, may differ significantly)\" className=\"vtab-regen-primary-btn\">\n            {isGenerating ? \"Generating...\" : \"Regenerate with new perspective\"}\n          </button>\n\n          {/* Regenerate with creative freedom (story format only) */}\n          {onRegenerateCreative && <button onClick={() => onRegenerateCreative?.()} disabled={isGenerating || compareRunning || combineRunning} title=\"Same PS, different generation prompt \u2014 neutral framing, softened structure, no craft posture. Reuses existing perspective synthesis.\" className=\"vtab-regen-creative-btn\">\n              {isGenerating ? \"Generating...\" : \"Creative freedom\"}\n            </button>}\n        </div>\n\n        <div className=\"vtab-llm-config\">\n          <span className=\"vtab-llm-config-label\">LLM Config:</span>{\" \"}\n          <span title=\"perspective.synthesis\">perspective: {llmConfigDisplay.perspective}</span>\n          {\" \u00b7 \"}\n          <span title=\"chronicle.generation\">generation: {llmConfigDisplay.generation}</span>\n          {(!item.generationSystemPrompt || !item.generationUserPrompt) && <span className=\"vtab-warning-inline\">\n              Existing perspective unavailable (legacy chronicle).\n            </span>}\n          {!onRegenerateFull && <span className=\"vtab-warning-inline\">\n              New perspective requires toneFragments and canonFactsWithMetadata.\n            </span>}\n        </div>\n      </div>\n\n      {/* Comparison Report */}\n      {item.comparisonReport && <div className=\"vtab-report-section\">\n          <div className=\"vtab-report-header\">\n            <span className=\"vtab-report-title\">Comparison Report</span>\n            <div className=\"vtab-report-actions\">\n              {item.comparisonReportGeneratedAt && <span className=\"vtab-report-timestamp\">\n                  {new Date(item.comparisonReportGeneratedAt).toLocaleString()}\n                </span>}\n              <button onClick={() => {\n            const blob = new Blob([item.comparisonReport], {\n              type: \"text/markdown\"\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = `comparison-report-${item.chronicleId.slice(0, 20)}-${Date.now()}.md`;\n            a.click();\n            URL.revokeObjectURL(url);\n          }} className=\"vtab-export-btn\">\n                Export\n              </button>\n            </div>\n          </div>\n          <div className=\"vtab-report-body\">{item.comparisonReport}</div>\n        </div>}\n    </div>;\n}", "parameters": [{"name": "{\n  item,\n  versions,\n  selectedVersionId,\n  compareToVersionId,\n  activeVersionId,\n  isGenerating,\n  onSelectVersion,\n  onSelectCompareVersion,\n  onSetActiveVersion,\n  onDeleteVersion,\n  onCompareVersions,\n  onCombineVersions,\n  onRegenerateFull,\n  onRegenerateCreative,\n  onRegenerateWithSampling,\n  onUpdateCombineInstructions,\n  onCopyEdit,\n  compareRunning,\n  combineRunning,\n  copyEditRunning\n}", "type": "{ item: any; versions: any; selectedVersionId: any; compareToVersionId: any; activeVersionId: any; isGenerating: any; onSelectVersion: any; onSelectCompareVersion: any; onSetActiveVersion: any; onDeleteVersion: any; onCompareVersions: any; onCombineVersions: any; onRegenerateFull: any; onRegenerateCreative: any; onRegenerateWithSampling: any; onUpdateCombineInstructions: any; onCopyEdit: any; compareRunning: any; combineRunning: any; copyEditRunning: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceHeader.jsx", "sourceCode": "export default function WorkspaceHeader({\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}) {\n  const [menuOpen, setMenuOpen] = useState(false);\n  const menuRef = useRef(null);\n\n  useEffect(() => {\n    if (!menuOpen) return;\n    const handleClick = (e) => {\n      if (menuRef.current && !menuRef.current.contains(e.target)) setMenuOpen(false);\n    };\n    document.addEventListener(\"mousedown\", handleClick);\n    return () => document.removeEventListener(\"mousedown\", handleClick);\n  }, [menuOpen]);\n\n  return (\n    <div className=\"chronicle-workspace-header\">\n      <div className=\"chronicle-workspace-header-info\">\n        <h3>{item.title || item.name || \"Untitled Chronicle\"}</h3>\n        <div className=\"chronicle-workspace-header-stats\">\n          {wordCount.toLocaleString()} words\n          {item.selectionSummary && (\n            <span>\n              {\" \"}\n              &middot; {item.selectionSummary.entityCount} entities,{\" \"}\n              {item.selectionSummary.eventCount} events\n            </span>\n          )}\n          {item.focusType && (\n            <span> &middot; {item.focusType === \"single\" ? \"Single focus\" : \"Ensemble\"}</span>\n          )}\n          <span> &middot; sampling {item.generationSampling ?? \"unspecified\"}</span>\n        </div>\n      </div>\n      <div className=\"chronicle-workspace-header-actions\">\n        {!isComplete && onAccept && (\n          <button onClick={onAccept} disabled={isGenerating} className=\"wsh-btn-accept\">\n            Accept &#x2713;\n          </button>\n        )}\n        {isComplete && onUnpublish && (\n          <button\n            onClick={onUnpublish}\n            className=\"wsh-btn-unpublish\"\n            title=\"Revert to assembly review without discarding content\"\n          >\n            Unpublish\n          </button>\n        )}\n        <button onClick={onRegenerate} disabled={isGenerating} className=\"wsh-btn-regenerate\">\n          &#x27F3; {isComplete ? \"Restart\" : \"Regenerate\"}\n        </button>\n        <div className=\"workspace-overflow-menu\" ref={menuRef}>\n          <button onClick={() => setMenuOpen(!menuOpen)} className=\"wsh-btn-overflow\">\n            &hellip;\n          </button>\n          {menuOpen && (\n            <div className=\"workspace-overflow-dropdown\">\n              {onExport && (\n                <button\n                  className=\"workspace-overflow-item\"\n                  onClick={() => {\n                    onExport();\n                    setMenuOpen(false);\n                  }}\n                  title=\"Export chronicle with full generation context as JSON\"\n                >\n                  Export\n                </button>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  item,\n  wordCount,\n  isGenerating,\n  isComplete,\n  onAccept,\n  onRegenerate,\n  onExport,\n  onUnpublish,\n}", "type": "{ item: any; wordCount: any; isGenerating: any; isComplete: any; onAccept: any; onRegenerate: any; onExport: any; onUnpublish: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/chronicle-workspace/WorkspaceTabBar.jsx", "sourceCode": "export default function WorkspaceTabBar({ tabs, activeTab, onTabChange }) {\n  return (\n    <div className=\"workspace-subtabs\">\n      {tabs.map((tab) => (\n        <button\n          key={tab.id}\n          className={\n            \"workspace-subtab\" +\n            (activeTab === tab.id ? \" active\" : \"\") +\n            (tab.align === \"right\" ? \" right-aligned\" : \"\")\n          }\n          onClick={() => onTabChange(tab.id)}\n        >\n          {tab.label}\n          {tab.indicator ? ` ${tab.indicator}` : \"\"}\n        </button>\n      ))}\n    </div>\n  );\n}", "parameters": [{"name": "{ tabs, activeTab, onTabChange }", "type": "{ tabs: any; activeTab: any; onTabChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/ChronicleWizard.tsx", "sourceCode": "// =============================================================================\n// Main Component (wraps with provider)\n// =============================================================================\n\nexport default function ChronicleWizard(props: Readonly<ChronicleWizardProps>) {\n  if (!props.isOpen) return null;\n\n  return (\n    <WizardProvider\n      entityKinds={props.entityKinds}\n      eras={props.eras ?? []}\n      simulationRunId={props.simulationRunId}\n    >\n      <InnerWizard {...props} />\n    </WizardProvider>\n  );\n}", "parameters": [{"name": "props", "type": "Readonly<ChronicleWizardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentPalette.tsx", "sourceCode": "export default function ContentPalette({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}: Readonly<ContentPaletteProps>) {\n  const [filter, setFilter] = useState(\"\");\n  const [typeFilter, setTypeFilter] = useState<TypeFilter>(\"all\");\n  const [sortBy, setSortBy] = useState<SortBy>(\"type\");\n\n  const allItems = useMemo<PaletteItem[]>(() => {\n    const items: PaletteItem[] = [];\n\n    for (const e of entities) {\n      if (!e.description || usedIds.has(e.id) || e.kind === \"era\") continue;\n      items.push({\n        type: \"entity\",\n        contentId: e.id,\n        name: e.name,\n        subtitle: `${e.kind}${e.subtype ? \" / \" + e.subtype : \"\"}`,\n        wordCount: countWords(e.description || \"\"),\n      });\n    }\n\n    for (const c of chronicles) {\n      if (c.status !== \"complete\" && c.status !== \"assembly_ready\") continue;\n      if (usedIds.has(c.chronicleId)) continue;\n      const content = c.finalContent || c.assembledContent || \"\";\n      items.push({\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n        name: c.title || \"Untitled Chronicle\",\n        subtitle: `${c.format} \\u2022 ${c.focusType}`,\n        wordCount: countWords(content),\n      });\n    }\n\n    for (const n of eraNarratives) {\n      if (n.status !== \"complete\" && n.status !== \"step_complete\") continue;\n      if (usedIds.has(n.narrativeId)) continue;\n      const { content } = resolveActiveContent(n);\n      items.push({\n        type: \"era_narrative\",\n        contentId: n.narrativeId,\n        name: n.eraName,\n        subtitle: `${n.tone} \\u2022 era narrative`,\n        wordCount: countWords(content || \"\"),\n      });\n    }\n\n    for (const p of staticPages) {\n      if (p.status !== \"published\" || usedIds.has(p.pageId)) continue;\n      items.push({\n        type: \"static_page\",\n        contentId: p.pageId,\n        name: p.title,\n        subtitle: `${p.wordCount.toLocaleString()} words`,\n        wordCount: p.wordCount,\n      });\n    }\n\n    return items;\n  }, [entities, chronicles, eraNarratives, staticPages, usedIds]);\n\n  const filteredItems = useMemo(() => {\n    let items = allItems;\n\n    // Type filter\n    if (typeFilter !== \"all\") {\n      items = items.filter((i) => i.type === typeFilter);\n    }\n\n    // Text filter\n    if (filter) {\n      const lower = filter.toLowerCase();\n      items = items.filter(\n        (i) => i.name.toLowerCase().includes(lower) || i.subtitle.toLowerCase().includes(lower)\n      );\n    }\n\n    // Sort\n    items = [...items].sort((a, b) => {\n      if (sortBy === \"name\") return a.name.localeCompare(b.name);\n      if (sortBy === \"words\") return b.wordCount - a.wordCount;\n      // 'type': group by type, then name\n      if (a.type !== b.type) return a.type.localeCompare(b.type);\n      return a.name.localeCompare(b.name);\n    });\n\n    return items;\n  }, [allItems, typeFilter, filter, sortBy]);\n\n  const handleClick = (item: PaletteItem) => {\n    if (!selectedFolderId) return;\n    onAddContent({ type: item.type, contentId: item.contentId, name: item.name });\n  };\n\n  return (\n    <div className=\"preprint-palette\">\n      <div className=\"preprint-palette-controls\">\n        <input\n          type=\"text\"\n          className=\"preprint-input preprint-palette-search\"\n          placeholder=\"Search content...\"\n          value={filter}\n          onChange={(e) => setFilter(e.target.value)}\n        />\n        <div className=\"preprint-palette-filters\">\n          {TYPE_FILTER_LABELS.map((tf) => (\n            <button\n              key={tf.value}\n              className={`preprint-palette-chip ${typeFilter === tf.value ? \"active\" : \"\"}`}\n              onClick={() => setTypeFilter(tf.value)}\n            >\n              {tf.label}\n            </button>\n          ))}\n          <select\n            className=\"preprint-palette-sort\"\n            value={sortBy}\n            onChange={(e) => setSortBy(e.target.value as SortBy)}\n            title=\"Sort order\"\n          >\n            {SORT_OPTIONS.map((s) => (\n              <option key={s.value} value={s.value}>\n                {s.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n\n      <div className=\"preprint-palette-list\">\n        {filteredItems.length === 0 && (\n          <div className=\"preprint-palette-empty\">\n            {allItems.length === 0\n              ? \"All content has been placed in the tree.\"\n              : \"No items match the current filters.\"}\n          </div>\n        )}\n        {filteredItems.map((item) => (\n          <PaletteItemRow\n            key={`${item.type}-${item.contentId}`}\n            item={item}\n            disabled={!selectedFolderId}\n            onClick={() => handleClick(item)}\n          />\n        ))}\n      </div>\n\n      <div className=\"preprint-palette-footer\">\n        {filteredItems.length} of {allItems.length} items\n        {!selectedFolderId && allItems.length > 0 && (\n          <span className=\"preprint-palette-hint\"> \u2014 select a folder to add</span>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  usedIds,\n  selectedFolderId,\n  onAddContent,\n}", "type": "Readonly<ContentPaletteProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ContentTreeView.tsx", "sourceCode": "// \u2500\u2500 Main component \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport default function ContentTreeView({\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}: Readonly<ContentTreeViewProps>) {\n  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);\n  const [newFolderParent, setNewFolderParent] = useState<string | null>(null);\n  const [newFolderName, setNewFolderName] = useState(\"\");\n  const treeRef = useRef<any>(null);\n\n  // Build set of used content IDs\n  const usedIds = useMemo(\n    () => (treeState ? getAllContentIds(treeState) : new Set<string>()),\n    [treeState]\n  );\n\n  // Enrich tree nodes with metadata for display\n  const enrichedData = useMemo<TreeNodeData[]>(() => {\n    if (!treeState) return [];\n\n    const entityMap = new Map(entities.map((e) => [e.id, e]));\n    const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n    const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n    const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n\n    function enrich(nodes: ContentTreeNode[]): TreeNodeData[] {\n      return nodes.map((node) => {\n        const enriched: TreeNodeData = { ...node };\n\n        if (node.type === \"entity\" && node.contentId) {\n          const ent = entityMap.get(node.contentId);\n          if (ent) {\n            enriched.meta = {\n              wordCount: countWords(ent.description || \"\"),\n              imageCount: ent.enrichment?.image?.imageId ? 1 : 0,\n              hasDescription: !!ent.description,\n              hasImage: !!ent.enrichment?.image?.imageId,\n            };\n          }\n        } else if (node.type === \"chronicle\" && node.contentId) {\n          const chr = chronicleMap.get(node.contentId);\n          if (chr) {\n            const content = chr.finalContent || chr.assembledContent || \"\";\n            const imgCount = countCompletedPromptImages(chr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content),\n              imageCount: imgCount + (chr.coverImage?.generatedImageId ? 1 : 0),\n              hasDescription: !!content,\n              hasImage: imgCount > 0,\n            };\n          }\n        } else if (node.type === \"static_page\" && node.contentId) {\n          const page = pageMap.get(node.contentId);\n          if (page) {\n            enriched.meta = {\n              wordCount: page.wordCount,\n              imageCount: 0,\n              hasDescription: !!page.content,\n              hasImage: true, // Pages don't require images\n            };\n          }\n        } else if (node.type === \"era_narrative\" && node.contentId) {\n          const narr = narrativeMap.get(node.contentId);\n          if (narr) {\n            const { content } = resolveActiveContent(narr);\n            const imgCount =\n              (narr.coverImage?.generatedImageId ? 1 : 0) +\n              countNarrativeImageRefs(narr.imageRefs?.refs);\n            enriched.meta = {\n              wordCount: countWords(content || \"\"),\n              imageCount: imgCount,\n              hasDescription: !!content,\n              hasImage: !!narr.coverImage?.generatedImageId,\n            };\n          }\n        }\n\n        if (node.children) {\n          enriched.children = enrich(node.children);\n        }\n\n        return enriched;\n      });\n    }\n\n    return enrich(toArboristData(treeState.nodes));\n  }, [treeState, entities, chronicles, staticPages, eraNarratives]);\n\n  // Handlers\n  const handleCreateScaffold = useCallback(() => {\n    const scaffold = createScaffold(projectId, simulationRunId);\n    onTreeChange(scaffold);\n  }, [projectId, simulationRunId, onTreeChange]);\n\n  const handleMove: MoveHandler<TreeNodeData> = useCallback(\n    ({ dragIds, parentId, index }) => {\n      if (!treeState || dragIds.length === 0) return;\n      const api = treeRef.current;\n      if (!api) return;\n\n      let newState = treeState;\n      for (const dragId of dragIds) {\n        const node = findNode(newState, dragId);\n        if (!node) continue;\n        const { nodes: withoutNode } = {\n          ...newState,\n          nodes: removeNodeFromTree(newState.nodes, dragId),\n        };\n        if (parentId) {\n          newState = {\n            ...newState,\n            nodes: insertNodeInTree(withoutNode, parentId, { ...node }, index),\n            updatedAt: Date.now(),\n          };\n        } else {\n          const rootNodes = [...withoutNode];\n          rootNodes.splice(index, 0, { ...node });\n          newState = { ...newState, nodes: rootNodes, updatedAt: Date.now() };\n        }\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleRename: RenameHandler<TreeNodeData> = useCallback(\n    ({ id, name }) => {\n      if (!treeState) return;\n      onTreeChange(renameNode(treeState, id, name));\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleDelete: DeleteHandler<TreeNodeData> = useCallback(\n    ({ ids }) => {\n      if (!treeState) return;\n      let newState = treeState;\n      for (const id of ids) {\n        newState = deleteNode(newState, id);\n      }\n      onTreeChange(newState);\n    },\n    [treeState, onTreeChange]\n  );\n\n  const handleAddFolder = useCallback(() => {\n    if (!treeState || !newFolderParent || !newFolderName.trim()) return;\n    onTreeChange(addFolder(treeState, newFolderParent, newFolderName.trim()));\n    setNewFolderName(\"\");\n    setNewFolderParent(null);\n  }, [treeState, newFolderParent, newFolderName, onTreeChange]);\n\n  const handleAddContent = useCallback(\n    (item: { type: ContentNodeType; contentId: string; name: string }) => {\n      if (!treeState || !selectedNodeId) return;\n      const target = findNode(treeState, selectedNodeId);\n      if (!target || target.type !== \"folder\") return;\n      onTreeChange(addContentItem(treeState, selectedNodeId, item));\n    },\n    [treeState, selectedNodeId, onTreeChange]\n  );\n\n  // Auto-populate\n  const handleAutoPopulate = useCallback(() => {\n    if (!treeState) return;\n\n    const bodyNode = treeState.nodes.find((n) => n.name === \"Body\" && n.type === \"folder\");\n    const backMatterNode = treeState.nodes.find(\n      (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n    );\n    const hasExistingContent =\n      (bodyNode?.children?.length ?? 0) > 0 ||\n      (backMatterNode?.children?.some((c) => c.name === \"Encyclopedia\") ?? false);\n\n    if (hasExistingContent) {\n      if (\n        !confirm(\n          \"Body and Back Matter already have content. Replace with auto-populated structure?\"\n        )\n      )\n        return;\n    }\n\n    const chronicleInput = chronicles\n      .filter((c) => c.status === \"complete\" || c.status === \"assembly_ready\")\n      .map((c) => ({\n        chronicleId: c.chronicleId,\n        title: c.title || \"Untitled Chronicle\",\n        status: c.status,\n        focalEraId: c.temporalContext?.focalEra?.id || (c as any).focalEra?.id,\n        focalEraName: c.temporalContext?.focalEra?.name || (c as any).focalEra?.name,\n        eraYear: c.eraYear,\n      }));\n\n    const narrativeInput = eraNarratives.map((n) => ({\n      narrativeId: n.narrativeId,\n      eraId: n.eraId,\n      eraName: n.eraName,\n      status: n.status,\n    }));\n\n    const entityInput = entities.map((e) => ({\n      id: e.id,\n      name: e.name,\n      kind: e.kind,\n      subtype: e.subtype,\n      culture: e.culture,\n      description: e.description,\n    }));\n\n    const pageInput = staticPages.map((p) => ({\n      pageId: p.pageId,\n      title: p.title,\n      status: p.status,\n    }));\n\n    const newTree = autoPopulateBody(treeState, {\n      chronicles: chronicleInput,\n      eraNarratives: narrativeInput,\n      entities: entityInput,\n      staticPages: pageInput,\n      eraOrder: eraOrderMap,\n    });\n\n    onTreeChange(newTree);\n  }, [treeState, chronicles, eraNarratives, entities, staticPages, eraOrderMap, onTreeChange]);\n\n  // No tree yet: show scaffold button\n  if (!treeState) {\n    return (\n      <div className=\"preprint-tree-empty\">\n        <p className=\"ctv-empty-msg\">\n          Create a book structure to organize content for print. The scaffold includes standard\n          Front Matter, Body, and Back Matter sections.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCreateScaffold}>\n          Create Book Scaffold\n        </button>\n      </div>\n    );\n  }\n\n  const selectedNode = selectedNodeId ? findNode(treeState, selectedNodeId) : null;\n  const isSelectedFolder = selectedNode?.type === \"folder\";\n\n  return (\n    <div className=\"preprint-tree-layout\">\n      <div className=\"preprint-tree-toolbar\">\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleAutoPopulate}\n          title=\"Auto-populate Body and Encyclopedia from Chronicler's era ordering\"\n        >\n          Auto-Populate\n        </button>\n        <button\n          className=\"preprint-action-button small\"\n          disabled={!isSelectedFolder}\n          onClick={() => {\n            if (selectedNodeId) setNewFolderParent(selectedNodeId);\n          }}\n          title=\"Add folder to selected folder\"\n        >\n          + Folder\n        </button>\n        <button\n          className=\"preprint-action-button small danger\"\n          disabled={!selectedNodeId}\n          onClick={() => {\n            if (selectedNodeId && confirm(\"Delete this node and all children?\")) {\n              onTreeChange(deleteNode(treeState, selectedNodeId));\n              setSelectedNodeId(null);\n            }\n          }}\n          title=\"Delete selected node\"\n        >\n          Delete\n        </button>\n        <div className=\"ctv-toolbar-spacer\" />\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCreateScaffold}\n          title=\"Reset to default scaffold (replaces current tree)\"\n        >\n          Reset Scaffold\n        </button>\n      </div>\n\n      <DndProvider backend={HTML5Backend}>\n        <div className=\"preprint-tree-split\">\n          <div className=\"preprint-tree-left\">\n            <TreePane\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  staticPages,\n  eraNarratives,\n  eraOrderMap,\n  treeState,\n  projectId,\n  simulationRunId,\n  onTreeChange,\n}", "type": "Readonly<ContentTreeViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/ExportView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/ExportView.tsx", "sourceCode": "export default function ExportView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}: Readonly<ExportViewProps>) {\n  const [exporting, setExporting] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [exportFormat, setExportFormat] = useState<ExportFormat>(\"markdown\");\n  const [idmlLayout, setIdmlLayout] = useState<IdmlLayoutOptions>({ ...DEFAULT_IDML_LAYOUT });\n  const [customFont, setCustomFont] = useState(\"\");\n\n  // Read S3 config from localStorage (set by Canonry AWS panel)\n  const s3Config = useMemo<S3ExportConfig | null>(() => {\n    try {\n      const raw = localStorage.getItem(\"canonry.aws.config\");\n      if (!raw) return null;\n      const parsed = JSON.parse(raw);\n      if (!parsed.imageBucket) return null;\n      return {\n        bucket: parsed.imageBucket,\n        basePrefix: parsed.imagePrefix || \"\",\n        rawPrefix: parsed.rawPrefix || \"raw\",\n        region: parsed.region || \"us-east-1\",\n      };\n    } catch {\n      return null;\n    }\n  }, []);\n\n  const handleExport = useCallback(async () => {\n    if (!treeState) return;\n\n    setExporting(true);\n    setError(null);\n\n    try {\n      const exportOptions = {\n        treeState,\n        entities,\n        chronicles,\n        images,\n        staticPages,\n        eraNarratives,\n        projectId,\n        simulationRunId,\n        s3Config,\n        idmlLayout,\n      };\n\n      const blob =\n        exportFormat === \"indesign\"\n          ? await buildInDesignExportZip(exportOptions)\n          : await buildExportZip(exportOptions);\n\n      const timestamp = new Date().toISOString().slice(0, 10);\n      const filename =\n        exportFormat === \"indesign\"\n          ? `preprint-${timestamp}.idml`\n          : `preprint-markdown-${timestamp}.zip`;\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (err: any) {\n      setError(err.message || \"Export failed\");\n    } finally {\n      setExporting(false);\n    }\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n    exportFormat,\n    idmlLayout,\n  ]);\n\n  const handleDownloadScript = useCallback(() => {\n    const script = buildIdmlImageScript({\n      treeState: treeState,\n      entities,\n      chronicles,\n      images,\n      staticPages,\n      eraNarratives,\n      projectId,\n      simulationRunId,\n      s3Config,\n    });\n    if (!script) return;\n\n    const blob = new Blob([script], { type: \"text/x-shellscript\" });\n    const timestamp = new Date().toISOString().slice(0, 10);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = `download-images-${timestamp}.sh`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }, [\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  ]);\n\n  if (!treeState) {\n    return (\n      <div className=\"ev-empty-msg\">\n        Create a content tree first (Content Tree tab) before exporting.\n      </div>\n    );\n  }\n\n  const s3Contents = s3Config\n    ? [\n        { label: \"s3-config.json\", description: \"S3 bucket and prefix configuration\" },\n        {\n          label: \"download-images.sh\",\n          description: \"Bash script to pull images from S3 (requires aws CLI + jq)\",\n        },\n      ]\n    : [];\n\n  return (\n    <div className=\"preprint-export\">\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Export Format</h2>\n        </div>\n\n        <div className=\"preprint-export-format-selector\">\n          <label\n            className={`preprint-export-format-option${exportFormat === \"markdown\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"markdown\"\n              checked={exportFormat === \"markdown\"}\n              onChange={() => setExportFormat(\"markdown\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>Markdown ZIP</strong>\n              <span>Folder hierarchy of .md files with YAML frontmatter</span>\n            </div>\n          </label>\n          <label\n            className={`preprint-export-format-option${exportFormat === \"indesign\" ? \" active\" : \"\"}`}\n          >\n            <input\n              type=\"radio\"\n              name=\"exportFormat\"\n              value=\"indesign\"\n              checked={exportFormat === \"indesign\"}\n              onChange={() => setExportFormat(\"indesign\")}\n            />\n            <div className=\"preprint-export-format-label\">\n              <strong>InDesign IDML</strong>\n              <span>Native InDesign document with pages and styles</span>\n            </div>\n          </label>\n        </div>\n\n        <p className=\"ev-format-desc\">\n          {FORMAT_DESCRIPTIONS[exportFormat]}\n        </p>\n\n        {exportFormat === \"indesign\" && (\n          <div className=\"preprint-export-config\">\n            <div className=\"preprint-stats-subsection\">Layout Options</div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Page Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.pagePreset}\n                onChange={(e) => setIdmlLayout((prev) => ({ ...prev, pagePreset: e.target.value }))}\n              >\n                {Object.entries(IDML_PAGE_PRESETS).map(([key, preset]) => (\n                  <option key={key} value={key}>\n                    {preset.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Font</span>\n              <select\n                className=\"preprint-export-select\"\n                value={\n                  IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any)\n                    ? idmlLayout.fontFamily\n                    : \"__custom__\"\n                }\n                onChange={(e) => {\n                  if (e.target.value === \"__custom__\") {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: customFont || \"Junicode\" }));\n                  } else {\n                    setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                  }\n                }}\n              >\n                {IDML_FONT_PRESETS.map((f) => (\n                  <option key={f} value={f}>\n                    {f}\n                  </option>\n                ))}\n                <option value=\"__custom__\">Custom...</option>\n              </select>\n            </div>\n\n            {!IDML_FONT_PRESETS.includes(idmlLayout.fontFamily as any) && (\n              <div className=\"preprint-stats-row\">\n                <span>Custom Font</span>\n                <input\n                  type=\"text\"\n                  className=\"preprint-export-input\"\n                  value={customFont}\n                  placeholder=\"Font family name\"\n                  onChange={(e) => {\n                    setCustomFont(e.target.value);\n                    if (e.target.value) {\n                      setIdmlLayout((prev) => ({ ...prev, fontFamily: e.target.value }));\n                    }\n                  }}\n                />\n              </div>\n            )}\n\n            <div className=\"preprint-stats-row\">\n              <span>Body Size</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodySize}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodySize: Number(e.target.value) }))\n                }\n              >\n                {[9, 10, 11, 12, 13, 14].map((s) => (\n                  <option key={s} value={s}>\n                    {s}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Leading</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.bodyLeading}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, bodyLeading: Number(e.target.value) }))\n                }\n              >\n                {[11, 12, 13, 14, 15, 16, 18].map((l) => (\n                  <option key={l} value={l}>\n                    {l}pt\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"preprint-stats-row\">\n              <span>Columns</span>\n              <select\n                className=\"preprint-export-select\"\n                value={idmlLayout.columnCount}\n                onChange={(e) =>\n                  setIdmlLayout((prev) => ({ ...prev, columnCount: Number(e.target.value) }))\n                }\n              >\n                <option value={1}>1</option>\n                <option value={2}>2</option>\n              </select>\n            </div>\n\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n  treeState,\n  projectId,\n  simulationRunId,\n}", "type": "Readonly<ExportViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/PageLayoutEditor.tsx", "sourceCode": "export default function PageLayoutEditor({\n  pageId,\n  pageName,\n  simulationRunId,\n}: Readonly<PageLayoutEditorProps>) {\n  const [override, setOverride] = useState<PageLayoutOverride | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [dirty, setDirty] = useState(false);\n\n  // Load existing override\n  useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n    void getPageLayout(simulationRunId, pageId).then((result) => {\n      if (!cancelled) {\n        setOverride(result);\n        setLoading(false);\n        setDirty(false);\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [simulationRunId, pageId]);\n\n  const update = useCallback(\n    <K extends OverrideField>(field: K, value: PageLayoutOverride[K] | undefined) => {\n      setOverride((prev) => {\n        const base = prev ?? { pageId, simulationRunId, updatedAt: Date.now() };\n        const next = { ...base, [field]: value === \"\" ? undefined : value, updatedAt: Date.now() };\n        return next;\n      });\n      setDirty(true);\n    },\n    [pageId, simulationRunId]\n  );\n\n  const handleSave = useCallback(async () => {\n    if (!override) return;\n    await putPageLayout(override);\n    setDirty(false);\n  }, [override]);\n\n  const handleClear = useCallback(async () => {\n    await deletePageLayout(simulationRunId, pageId);\n    setOverride(null);\n    setDirty(false);\n  }, [simulationRunId, pageId]);\n\n  if (loading) {\n    return (\n      <div className=\"preprint-layout-editor\">\n        <div className=\"preprint-layout-loading\">Loading...</div>\n      </div>\n    );\n  }\n\n  const hasOverride =\n    override &&\n    Object.keys(override).some(\n      (k) =>\n        ![\"pageId\", \"simulationRunId\", \"updatedAt\"].includes(k) &&\n        (override as any)[k] !== undefined\n    );\n\n  return (\n    <div className=\"preprint-layout-editor\">\n      <div className=\"preprint-layout-header\">\n        <span className=\"preprint-layout-title\" title={pageName}>\n          Layout: {pageName}\n        </span>\n        {hasOverride && (\n          <button\n            className=\"preprint-layout-clear\"\n            onClick={() => void handleClear()}\n            title=\"Reset to engine defaults\"\n          >\n            Clear\n          </button>\n        )}\n      </div>\n\n      <div className=\"preprint-layout-fields\">\n        <SelectField\n          label=\"Layout Mode\"\n          value={override?.layoutMode ?? \"\"}\n          options={LAYOUT_MODES}\n          onChange={(v) => update(\"layoutMode\", (v as LayoutMode) || undefined)}\n        />\n\n        <SelectField\n          label=\"Annotations\"\n          value={override?.annotationDisplay ?? \"\"}\n          options={ANNOTATION_DISPLAY}\n          onChange={(v) => update(\"annotationDisplay\", (v as AnnotationDisplay) || undefined)}\n        />\n\n        <SelectField\n          label=\"Note Position\"\n          value={override?.annotationPosition ?? \"\"}\n          options={ANNOTATION_POSITION}\n          onChange={(v) => update(\"annotationPosition\", (v as AnnotationPosition) || undefined)}\n        />\n\n        <SelectField\n          label=\"Image Layout\"\n          value={override?.imageLayout ?? \"\"}\n          options={IMAGE_LAYOUT}\n          onChange={(v) => update(\"imageLayout\", (v as ImageLayout) || undefined)}\n        />\n\n        <SelectField\n          label=\"Content Width\"\n          value={override?.contentWidth ?? \"\"}\n          options={CONTENT_WIDTH}\n          onChange={(v) => update(\"contentWidth\", (v as ContentWidth) || undefined)}\n        />\n\n        <SelectField\n          label=\"Text Align\"\n          value={override?.textAlign ?? \"\"}\n          options={TEXT_ALIGN}\n          onChange={(v) => update(\"textAlign\", (v as TextAlign) || undefined)}\n        />\n\n        <div className=\"preprint-layout-row\">\n          <label className=\"preprint-layout-label\">\n            <input\n              type=\"checkbox\"\n              checked={override?.dropcap ?? false}\n              onChange={(e) => update(\"dropcap\", e.target.checked || undefined)}\n            />\n            Drop cap\n          </label>\n        </div>\n\n        <div className=\"preprint-layout-row\">\n          <label htmlFor=\"custom-css-class\" className=\"preprint-layout-label-block\">Custom CSS class</label>\n          <input id=\"custom-css-class\"\n            type=\"text\"\n            className=\"preprint-input preprint-layout-text\"\n            value={override?.customClass ?? \"\"}\n            onChange={(e) => update(\"customClass\", e.target.value || undefined)}\n            placeholder=\"e.g. my-custom-layout\"\n          />\n        </div>\n      </div>\n\n      {dirty && (\n        <div className=\"preprint-layout-actions\">\n          <button className=\"preprint-layout-save\" onClick={() => void handleSave()}>\n            Save\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  pageId,\n  pageName,\n  simulationRunId,\n}", "type": "Readonly<PageLayoutEditorProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/StatsView.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/StatsView.tsx", "sourceCode": "export default function StatsView({\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}: Readonly<StatsViewProps>) {\n  const [stats, setStats] = useState<PrePrintStats | null>(null);\n  const [calculating, setCalculating] = useState(false);\n\n  const handleCalculate = useCallback(() => {\n    setCalculating(true);\n    // Use setTimeout to allow UI to show spinner before computation blocks\n    setTimeout(() => {\n      const result = computePrePrintStats(entities, chronicles, images, staticPages, eraNarratives);\n      setStats(result);\n      setCalculating(false);\n    }, 50);\n  }, [entities, chronicles, images, staticPages, eraNarratives]);\n\n  if (!stats) {\n    return (\n      <div className=\"preprint-stats-empty\">\n        <p className=\"sv-empty-msg\">\n          Calculate statistics for print preparation. This scans all entities, chronicles, era\n          narratives, images, and static pages to produce word counts, image inventory, and\n          completeness checks.\n        </p>\n        <button className=\"preprint-action-button\" onClick={handleCalculate} disabled={calculating}>\n          {calculating ? \"Calculating...\" : \"Calculate Stats\"}\n        </button>\n      </div>\n    );\n  }\n\n  const wb = stats.wordBreakdown;\n  const cb = stats.charBreakdown;\n  const img = stats.images;\n  const comp = stats.completeness;\n  const hn = stats.historianNotes;\n\n  return (\n    <div className=\"preprint-stats\">\n      <div className=\"preprint-stats-header\">\n        <span className=\"sv-calc-meta\">\n          Calculated {new Date(stats.calculatedAt).toLocaleString()}\n        </span>\n        <button\n          className=\"preprint-action-button small\"\n          onClick={handleCalculate}\n          disabled={calculating}\n        >\n          {calculating ? \"Recalculating...\" : \"Recalculate\"}\n        </button>\n      </div>\n\n      {/* Page Estimate */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Page Estimate</h2>\n        </div>\n        <div className=\"preprint-stats-hero\">\n          <div className=\"preprint-stats-hero-number\">{stats.estimatedPages.toLocaleString()}</div>\n          <div className=\"preprint-stats-hero-label\">estimated pages (250 words/page)</div>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total words</span>\n          <span className=\"preprint-stats-value\">{stats.totalWords.toLocaleString()}</span>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total characters</span>\n          <span className=\"preprint-stats-value\">{stats.totalChars.toLocaleString()}</span>\n        </div>\n      </div>\n\n      {/* Word Count Breakdown */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Word & Character Counts</h2>\n        </div>\n        <div className=\"preprint-stats-table\">\n          <div className=\"preprint-stats-table-header\">\n            <span>Content Type</span>\n            <span>Words</span>\n            <span>Chars</span>\n            <span>% of Total</span>\n          </div>\n          <WordRow\n            label=\"Chronicle body text\"\n            words={wb.chronicleBody}\n            chars={cb.chronicleBody}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Chronicle summaries\"\n            words={wb.chronicleSummaries}\n            chars={cb.chronicleSummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Era narrative content\"\n            words={wb.eraNarrativeContent}\n            chars={cb.eraNarrativeContent}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity descriptions\"\n            words={wb.entityDescriptions}\n            chars={cb.entityDescriptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Entity summaries\"\n            words={wb.entitySummaries}\n            chars={cb.entitySummaries}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Image captions\"\n            words={wb.imageCaptions}\n            chars={cb.imageCaptions}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (entity)\"\n            words={wb.historianNotesEntity}\n            chars={cb.historianNotesEntity}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Historian notes (chronicle)\"\n            words={wb.historianNotesChronicle}\n            chars={cb.historianNotesChronicle}\n            total={stats.totalWords}\n          />\n          <WordRow\n            label=\"Static page content\"\n            words={wb.staticPageContent}\n            chars={cb.staticPageContent}\n            total={stats.totalWords}\n          />\n        </div>\n      </div>\n\n      {/* Image Inventory */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Image Inventory</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total images</span>\n          <span className=\"preprint-stats-value\">{img.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Total storage</span>\n          <span className=\"preprint-stats-value\">{formatBytes(img.totalStorageBytes)}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Orientation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Portrait</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.portrait} ({pct(img.byAspect.portrait, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Landscape</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.landscape} ({pct(img.byAspect.landscape, img.total)})\n          </span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Square</span>\n          <span className=\"preprint-stats-value\">\n            {img.byAspect.square} ({pct(img.byAspect.square, img.total)})\n          </span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n        <div className=\"preprint-stats-row\">\n          <span>Entity portraits</span>\n          <span className=\"preprint-stats-value\">{img.byType.entity}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Chronicle scenes</span>\n          <span className=\"preprint-stats-value\">{img.byType.chronicle}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Cover images</span>\n          <span className=\"preprint-stats-value\">{img.byType.cover}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Size Designation</div>\n        <div className=\"preprint-stats-row\">\n          <span>Small (inline)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.small}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Medium (half-page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.medium}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Large (3/4 page)</span>\n          <span className=\"preprint-stats-value\">{img.bySize.large}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>Full-width</span>\n          <span className=\"preprint-stats-value\">{img.bySize[\"full-width\"]}</span>\n        </div>\n\n        {img.dimensionRange && (\n          <>\n            <div className=\"preprint-stats-subsection\">Dimensions (pixels)</div>\n            <div className=\"preprint-stats-row\">\n              <span>Width range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minWidth} \u2013 {img.dimensionRange.maxWidth}px\n              </span>\n            </div>\n            <div className=\"preprint-stats-row\">\n              <span>Height range</span>\n              <span className=\"preprint-stats-value\">\n                {img.dimensionRange.minHeight} \u2013 {img.dimensionRange.maxHeight}px\n              </span>\n            </div>\n          </>\n        )}\n      </div>\n\n      {/* Completeness */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Completeness</h2>\n        </div>\n        <CompletenessRow\n          label=\"Entities with description\"\n          count={comp.entitiesWithDescription}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with image\"\n          count={comp.entitiesWithImage}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Entities with summary\"\n          count={comp.entitiesWithSummary}\n          total={comp.entitiesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles published\"\n          count={comp.chroniclesPublished}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with historian notes\"\n          count={comp.chroniclesWithHistorianNotes}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Chronicles with scene images\"\n          count={comp.chroniclesWithSceneImages}\n          total={comp.chroniclesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives complete\"\n          count={comp.eraNarrativesComplete}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Era narratives with cover image\"\n          count={comp.eraNarrativesWithCoverImage}\n          total={comp.eraNarrativesTotal}\n        />\n        <CompletenessRow\n          label=\"Static pages published\"\n          count={comp.staticPagesPublished}\n          total={comp.staticPagesTotal}\n        />\n      </div>\n\n      {/* Historian Notes */}\n      <div className=\"illuminator-card\">\n        <div className=\"illuminator-card-header\">\n          <h2 className=\"illuminator-card-title\">Historian Notes</h2>\n        </div>\n        <div className=\"preprint-stats-row total\">\n          <span>Total notes</span>\n          <span className=\"preprint-stats-value\">{hn.total}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On entities</span>\n          <span className=\"preprint-stats-value\">{hn.onEntities}</span>\n        </div>\n        <div className=\"preprint-stats-row\">\n          <span>On chronicles</span>\n          <span className=\"preprint-stats-value\">{hn.onChronicles}</span>\n        </div>\n\n        <div className=\"preprint-stats-subsection\">By Type</div>\n// ... (truncated)", "parameters": [{"name": "{\n  entities,\n  chronicles,\n  images,\n  staticPages,\n  eraNarratives,\n}", "type": "Readonly<StatsViewProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/preprint/TreeNodeRenderer.tsx", "sourceCode": "export default function TreeNodeRenderer({\n  node,\n  style,\n  dragHandle\n}: Readonly<NodeRendererProps<TreeNodeData>>) {\n  const data = node.data;\n  const meta = data.meta;\n  const isFolder = data.type === \"folder\";\n  return <div className={`preprint-tree-node ${node.isSelected ? \"selected\" : \"\"} ${isFolder ? \"folder\" : \"content\"}`} ref={dragHandle} onClick={() => node.isInternal && node.toggle()} role=\"button\" tabIndex={0} onKeyDown={e => {\n    if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click();\n  }} style={style}>\n      <span className=\"preprint-tree-node-icon\" title={TYPE_LABELS[data.type] || data.type}>\n        {(() => {\n        if (isFolder) return node.isOpen ? \"\\u{1F4C2}\" : \"\\u{1F4C1}\";\n        return TYPE_ICONS[data.type] || \"?\";\n      })()}\n      </span>\n\n      {node.isEditing ? <input type=\"text\" className=\"preprint-tree-node-edit\" defaultValue={data.name}\n    // eslint-disable-next-line jsx-a11y/no-autofocus\n    autoFocus onBlur={() => node.reset()} onKeyDown={e => {\n      if (e.key === \"Enter\") node.submit((e.target as HTMLInputElement).value);\n      if (e.key === \"Escape\") node.reset();\n    }} /> : <span className=\"preprint-tree-node-name\" title={data.name}>\n          {data.name}\n        </span>}\n\n      {!isFolder && meta && <span className=\"preprint-tree-node-meta\">\n          {meta.wordCount !== undefined && <span className=\"preprint-tree-node-wc\" title=\"Word count\">\n              {meta.wordCount.toLocaleString()}w\n            </span>}\n          {meta.imageCount !== undefined && meta.imageCount > 0 && <span className=\"preprint-tree-node-ic\" title=\"Images\">\n              \\u25A3 {meta.imageCount}\n            </span>}\n          <span className=\"preprint-tree-node-status\" title={(() => {\n        if (meta.hasDescription && meta.hasImage) return \"Complete\";\n        if (meta.hasDescription) return \"Missing image\";\n        return \"Missing content\";\n      })()} style={{\n        '--tree-status-color': (() => {\n          if (meta.hasDescription && meta.hasImage) return \"#22c55e\";\n          if (meta.hasDescription) return \"#f59e0b\";\n          return \"#ef4444\";\n        })()\n      } as React.CSSProperties}>\n            {(() => {\n          if (meta.hasDescription && meta.hasImage) return \"\\u25CF\";\n          if (meta.hasDescription) return \"\\u25D2\";\n          return \"\\u25CB\";\n        })()}\n          </span>\n        </span>}\n    </div>;\n}", "parameters": [{"name": "{\n  node,\n  style,\n  dragHandle\n}", "type": "Readonly<NodeRendererProps<TreeNodeData>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/illuminator/webui/src/lib/chronicle/focus.ts::applyFocusToContext", "name": "applyFocusToContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/focus.ts", "sourceCode": "export function applyFocusToContext(\n  context: ChronicleGenerationContext,\n  focus: NarrativeFocus\n): ChronicleGenerationContext {\n  const entitySet = new Set(focus.selectedEntityIds);\n  const eventSet = new Set(focus.selectedEventIds);\n\n  const filteredEntities = context.entities.filter((e) => entitySet.has(e.id));\n  const filteredEvents = context.events.filter((e) => eventSet.has(e.id));\n  const filteredRelationships = context.relationships.filter(\n    (r) => entitySet.has(r.src) && entitySet.has(r.dst)\n  );\n\n  return {\n    ...context,\n    entities: filteredEntities,\n    events: filteredEvents,\n    relationships: filteredRelationships,\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "focus", "type": "NarrativeFocus", "optional": false}], "returnType": "ChronicleGenerationContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::toCulture", "name": "toCulture", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Convert CultureDefinition (Canonry) to Culture (name-forge)\n */\nexport function toCulture(def: CultureDefinition): Culture | null {\n  if (!def.naming) return null;\n\n  return {\n    id: def.id,\n    name: def.name,\n    description: def.description,\n    domains: def.naming.domains || [],\n    lexemeLists: def.naming.lexemeLists || {},\n    grammars: def.naming.grammars || [],\n    profiles: def.naming.profiles || [],\n  };\n}", "parameters": [{"name": "def", "type": "CultureDefinition", "optional": false}], "returnType": "Culture | null"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::generateNameBank", "name": "generateNameBank", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Generate a name bank for the given cultures.\n *\n * @param cultures - All culture definitions from the project\n * @param cultureIds - Culture IDs to generate names for\n * @returns Map of culture ID -> array of generated names\n */\nexport async function generateNameBank(\n  cultures: CultureDefinition[],\n  cultureIds: string[]\n): Promise<Record<string, string[]>> {\n  const nameBank: Record<string, string[]> = {};\n  const uniqueCultureIds = [...new Set(cultureIds)];\n\n  for (const cultureId of uniqueCultureIds) {\n    const cultureDef = cultures.find((c) => c.id === cultureId);\n    if (!cultureDef) continue;\n\n    const culture = toCulture(cultureDef);\n    if (!culture) continue;\n\n    try {\n      const result = await generate(culture, {\n        kind: \"npc\",\n        count: NAMES_PER_CULTURE,\n        seed: `namebank-${cultureId}-${Date.now()}`,\n      });\n      nameBank[cultureId] = result.names;\n    } catch (e) {\n      console.warn(`[NameBank] Failed to generate names for culture ${cultureId}:`, e);\n      // Continue without names for this culture\n    }\n  }\n\n  return nameBank;\n}", "parameters": [{"name": "cultures", "type": "CultureDefinition[]", "optional": false}, {"name": "cultureIds", "type": "string[]", "optional": false}], "returnType": "Promise<Record<string, string[]>>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts::extractCultureIds", "name": "extractCultureIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/nameBank.ts", "sourceCode": "/**\n * Extract unique culture IDs from a list of entities.\n */\nexport function extractCultureIds(entities: Array<{ culture?: string }>): string[] {\n  const cultureIds = entities\n    .map((e) => e.culture)\n    .filter((c): c is string => c !== undefined && c !== null && c !== \"\");\n  return [...new Set(cultureIds)];\n}", "parameters": [{"name": "entities", "type": "Array<{ culture?: string }>", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildEntityLookup", "name": "buildEntityLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildEntityLookup(\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): Map<string, { name: string; kind?: string }> {\n  const lookup = new Map<string, { name: string; kind?: string }>();\n\n  for (const entity of entities) {\n    lookup.set(entity.id, { name: entity.name, kind: entity.kind });\n  }\n\n  for (const rel of relationships) {\n    if (!lookup.has(rel.src)) {\n      lookup.set(rel.src, { name: rel.sourceName, kind: rel.sourceKind });\n    }\n    if (!lookup.has(rel.dst)) {\n      lookup.set(rel.dst, { name: rel.targetName, kind: rel.targetKind });\n    }\n  }\n\n  return lookup;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "Map<string, { name: string; kind?: string }>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts::buildRelationshipPairSummaries", "name": "buildRelationshipPairSummaries", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/relationshipGraph.ts", "sourceCode": "export function buildRelationshipPairSummaries(\n  entityIds: string[],\n  relationships: RelationshipContext[]\n): RelationshipPairSummary[] {\n  const uniqueIds = Array.from(new Set(entityIds));\n  const adjacency = buildAdjacency(relationships);\n  const summaries: RelationshipPairSummary[] = [];\n\n  for (let i = 0; i < uniqueIds.length; i += 1) {\n    const entityAId = uniqueIds[i];\n    const neighborsA = collectNeighborLinks(adjacency, entityAId);\n\n    for (let j = i + 1; j < uniqueIds.length; j += 1) {\n      const entityBId = uniqueIds[j];\n      const neighborsB = collectNeighborLinks(adjacency, entityBId);\n\n      const direct = (adjacency.get(entityAId) || []).filter(\n        (rel) => rel.src === entityBId || rel.dst === entityBId\n      );\n\n      const sharedNeighbors: SharedNeighborLink[] = [];\n      for (const [neighborId, linksFromA] of neighborsA.entries()) {\n        const linksFromB = neighborsB.get(neighborId);\n        if (!linksFromB) continue;\n        sharedNeighbors.push({ neighborId, linksFromA, linksFromB });\n      }\n\n      sharedNeighbors.sort((a, b) => a.neighborId.localeCompare(b.neighborId));\n\n      summaries.push({\n        entityAId,\n        entityBId,\n        direct,\n        sharedNeighbors,\n      });\n    }\n  }\n\n  return summaries;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "RelationshipPairSummary[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildKindToCategoryMap", "name": "buildKindToCategoryMap", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Category Resolution\n// =============================================================================\n\n/**\n * Build a mapping from entity kind to its category.\n * Used to resolve domain-agnostic categories to domain-specific kinds at runtime.\n */\nexport function buildKindToCategoryMap(\n  entityKinds: EntityKindDefinition[]\n): Map<string, EntityCategory> {\n  const map = new Map<string, EntityCategory>();\n  for (const kind of entityKinds) {\n    if (kind.category) {\n      map.set(kind.kind, kind.category);\n    }\n  }\n  return map;\n}", "parameters": [{"name": "entityKinds", "type": "EntityKindDefinition[]", "optional": false}], "returnType": "Map<string, EntityCategory>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildNeighborGraph", "name": "buildNeighborGraph", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build a graph of entities reachable within maxDepth hops from entrypoint.\n */\nexport function buildNeighborGraph(\n  relationships: RelationshipContext[],\n  entrypointId: string,\n  maxDepth: number = 2\n): NeighborGraph {\n  const adjacency = new Map<string, Set<string>>();\n  for (const rel of relationships) {\n    if (!adjacency.has(rel.src)) adjacency.set(rel.src, new Set());\n    if (!adjacency.has(rel.dst)) adjacency.set(rel.dst, new Set());\n    adjacency.get(rel.src).add(rel.dst);\n    adjacency.get(rel.dst).add(rel.src);\n  }\n\n  const distances = new Map<string, number>();\n  const queue: Array<{ id: string; depth: number }> = [{ id: entrypointId, depth: 0 }];\n  distances.set(entrypointId, 0);\n\n  while (queue.length > 0) {\n    const { id, depth } = queue.shift();\n    if (depth >= maxDepth) continue;\n    const neighbors = adjacency.get(id);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (distances.has(neighbor)) continue;\n      distances.set(neighbor, depth + 1);\n      queue.push({ id: neighbor, depth: depth + 1 });\n    }\n  }\n\n  return { ids: new Set(distances.keys()), distances };\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "entrypointId", "type": "string", "optional": false}, {"name": "maxDepth", "type": "number", "optional": true}], "returnType": "NeighborGraph"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEntityMetrics", "name": "computeEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single entity.\n */\nexport function computeEntityMetrics(\n  entity: EntityContext,\n  ctx: MetricsContext\n): EntitySelectionMetrics {\n  const {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  } = ctx;\n\n  // Distance\n  const distance = distances.get(entity.id) ?? 99;\n\n  // Average relationship strength to entry point\n  const relsToEntry = relationships.filter(\n    (r) =>\n      (r.src === entity.id && r.dst === entryPointId) ||\n      (r.dst === entity.id && r.src === entryPointId)\n  );\n  const avgStrength =\n    relsToEntry.length > 0\n      ? relsToEntry.reduce((sum, r) => sum + (r.strength ?? 0.5), 0) / relsToEntry.length\n      : 0;\n\n  // Usage count\n  const usage = usageStats.get(entity.id);\n  const usageCount = usage?.usageCount ?? 0;\n\n  // Era alignment - check if entity shares any era with entry point\n  const entityEraId = resolveEntityEraId(entity);\n  const eraAligned =\n    entryPointEras.size === 0 || (entityEraId !== undefined && entryPointEras.has(entityEraId));\n\n  // Category novelty\n  const entityCategory = kindToCategory.get(entity.kind);\n  const addsNewCategory =\n    entityCategory !== undefined && !currentCastCategories.has(entityCategory);\n\n  // Relationship type diversity\n  const entityRelTypes = new Set(\n    relationships.filter((r) => r.src === entity.id || r.dst === entity.id).map((r) => r.kind)\n  );\n  const newRelTypes = [...entityRelTypes].filter((t) => !currentCastRelTypes.has(t)).length;\n\n  return {\n    entityId: entity.id,\n    distance,\n    avgStrength,\n    usageCount,\n    eraAligned,\n    addsNewCategory,\n    newRelTypes,\n  };\n}", "parameters": [{"name": "entity", "type": "EntityContext", "optional": false}, {"name": "ctx", "type": "MetricsContext", "optional": false}], "returnType": "EntitySelectionMetrics"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEntityMetrics", "name": "computeAllEntityMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate entities.\n */\nexport function computeAllEntityMetrics(\n  candidates: EntityContext[],\n  entryPointId: string,\n  relationships: RelationshipContext[],\n  distances: Map<string, number>,\n  usageStats: Map<string, { usageCount: number }>,\n  currentAssignments: ChronicleRoleAssignment[],\n  kindToCategory: Map<string, EntityCategory>\n): Map<string, EntitySelectionMetrics> {\n  const entryPointEraId = resolveEntityEraId(candidates.find((e) => e.id === entryPointId));\n  const entryPointEras = new Set(entryPointEraId ? [entryPointEraId] : []);\n\n  // Get current cast's categories and relationship types\n  const assignedIds = new Set(currentAssignments.map((a) => a.entityId));\n  const currentCastCategories = new Set<EntityCategory>();\n  const currentCastRelTypes = new Set<string>();\n\n  for (const assignment of currentAssignments) {\n    const entity = candidates.find((e) => e.id === assignment.entityId);\n    if (entity) {\n      const cat = kindToCategory.get(entity.kind);\n      if (cat) currentCastCategories.add(cat);\n    }\n  }\n\n  for (const rel of relationships) {\n    if (assignedIds.has(rel.src) || assignedIds.has(rel.dst)) {\n      currentCastRelTypes.add(rel.kind);\n    }\n  }\n\n  const ctx: MetricsContext = {\n    entryPointId,\n    relationships,\n    distances,\n    usageStats,\n    entryPointEras,\n    currentCastCategories,\n    currentCastRelTypes,\n    kindToCategory,\n  };\n\n  const metricsMap = new Map<string, EntitySelectionMetrics>();\n  for (const entity of candidates) {\n    metricsMap.set(entity.id, computeEntityMetrics(entity, ctx));\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "distances", "type": "Map<string, number>", "optional": false}, {"name": "usageStats", "type": "Map<string, { usageCount: number }>", "optional": false}, {"name": "currentAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}], "returnType": "Map<string, EntitySelectionMetrics>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalScope", "name": "computeTemporalScope", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Temporal Utilities\n// =============================================================================\n\n/**\n * Compute temporal scope from tick range.\n */\nexport function computeTemporalScope(\n  tickRange: [number, number],\n  isMultiEra: boolean\n): TemporalScope {\n  const duration = tickRange[1] - tickRange[0];\n\n  if (isMultiEra) return \"saga\";\n  if (duration >= 50) return \"saga\";\n  if (duration >= 20) return \"arc\";\n  if (duration >= 5) return \"episode\";\n  return \"moment\";\n}", "parameters": [{"name": "tickRange", "type": "[number, number]", "optional": false}, {"name": "isMultiEra", "type": "boolean", "optional": false}], "returnType": "TemporalScope"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::findEraForEvent", "name": "findEraForEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Find era for an event - by direct ID match.\n */\nexport function findEraForEvent(\n  event: { tick: number; era?: string },\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  // Direct ID match (event.era should match era.id)\n  if (event.era) {\n    const byId = eras.find((e) => e.id === event.era);\n    if (byId) return byId;\n  }\n  return undefined;\n}", "parameters": [{"name": "event", "type": "{ tick: number; era?: string }", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeFocalEra", "name": "computeFocalEra", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the focal era from a set of events.\n * Returns the era that contains the most events.\n */\nexport function computeFocalEra(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[]\n): EraTemporalInfo | undefined {\n  if (events.length === 0 || eras.length === 0) {\n    return eras[0]; // Default to first era\n  }\n\n  // Count events per era\n  const eraCounts = new Map<string, number>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) {\n      eraCounts.set(era.id, (eraCounts.get(era.id) || 0) + 1);\n    }\n  }\n\n  // Find era with most events\n  let maxCount = 0;\n  let focalEraId: string | undefined;\n  for (const [eraId, count] of eraCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      focalEraId = eraId;\n    }\n  }\n\n  return eras.find((e) => e.id === focalEraId) || eras[0];\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "EraTemporalInfo | undefined"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeTemporalContext", "name": "computeTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute the complete temporal context for a chronicle.\n */\nexport function computeTemporalContext(\n  events: NarrativeEventContext[],\n  eras: EraTemporalInfo[],\n  entryPoint?: EntityContext,\n  focalEraOverrideId?: string | null\n): ChronicleTemporalContext {\n  // Compute tick range from events\n  let minTick = Infinity;\n  let maxTick = -Infinity;\n\n  for (const event of events) {\n    minTick = Math.min(minTick, event.tick);\n    maxTick = Math.max(maxTick, event.tick);\n  }\n\n  // Include entry point creation tick if available\n  if (entryPoint) {\n    minTick = Math.min(minTick, entryPoint.createdAt);\n  }\n\n  // Handle edge case of no events\n  if (minTick === Infinity) {\n    minTick = entryPoint?.createdAt ?? 0;\n    maxTick = minTick;\n  }\n\n  const chronicleTickRange: [number, number] = [minTick, maxTick];\n\n  // Find touched eras by event era IDs\n  const touchedEraIds = new Set<string>();\n  for (const event of events) {\n    const era = findEraForEvent(event, eras);\n    if (era) touchedEraIds.add(era.id);\n  }\n\n  const isMultiEra = touchedEraIds.size > 1;\n  const temporalScope = computeTemporalScope(chronicleTickRange, isMultiEra);\n\n  // Compute focal era (use override if provided)\n  const overrideEra = focalEraOverrideId\n    ? eras.find((e) => e.id === focalEraOverrideId)\n    : undefined;\n  const focalEra = overrideEra || computeFocalEra(events, eras) || eras[0];\n\n  // Build temporal description\n  const temporalDescription = buildTemporalDescription(\n    focalEra,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds.size\n  );\n\n  return {\n    focalEra,\n    allEras: eras,\n    chronicleTickRange,\n    temporalScope,\n    isMultiEra,\n    touchedEraIds: Array.from(touchedEraIds),\n    temporalDescription,\n  };\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "entryPoint", "type": "EntityContext", "optional": true}, {"name": "focalEraOverrideId", "type": "string | null", "optional": true}], "returnType": "ChronicleTemporalContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeEventMetrics", "name": "computeEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute selection metrics for a single event.\n */\nexport function computeEventMetrics(\n  event: NarrativeEventContext,\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): EventSelectionMetrics {\n  // Use event era ID and resolve name from eras when possible\n  const eventEra = findEraForEvent(event, eras);\n  const eraId = eventEra?.id || event.era;\n  const eraName = eventEra?.name || event.era;\n\n  // Count how many assigned entities are involved\n  let assignedCount = 0;\n  if (event.subjectId && assignedEntityIds.has(event.subjectId)) assignedCount++;\n  if (event.objectId && assignedEntityIds.has(event.objectId)) assignedCount++;\n\n  // Check if event involves entry point\n  const involvesEntryPoint = event.subjectId === entryPointId || event.objectId === entryPointId;\n\n  return {\n    eventId: event.id,\n    tick: event.tick,\n    eraId,\n    eraName,\n    inFocalEra: eraId === focalEraId,\n    tickDistance: Math.abs(event.tick - entryPointTick),\n    involvesEntryPoint,\n    assignedEntityCount: assignedCount,\n    significance: event.significance,\n  };\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "EventSelectionMetrics"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::computeAllEventMetrics", "name": "computeAllEventMetrics", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Compute metrics for all candidate events.\n */\nexport function computeAllEventMetrics(\n  events: NarrativeEventContext[],\n  entryPointId: string,\n  entryPointTick: number,\n  focalEraId: string,\n  eras: EraTemporalInfo[],\n  assignedEntityIds: Set<string>\n): Map<string, EventSelectionMetrics> {\n  const metricsMap = new Map<string, EventSelectionMetrics>();\n\n  for (const event of events) {\n    metricsMap.set(\n      event.id,\n      computeEventMetrics(event, entryPointId, entryPointTick, focalEraId, eras, assignedEntityIds)\n    );\n  }\n\n  return metricsMap;\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "entryPointTick", "type": "number", "optional": false}, {"name": "focalEraId", "type": "string", "optional": false}, {"name": "eras", "type": "EraTemporalInfo[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "Map<string, EventSelectionMetrics>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::scoreEventForSelection", "name": "scoreEventForSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Score an event for selection based on temporal alignment and relevance.\n */\nexport function scoreEventForSelection(\n  event: NarrativeEventContext,\n  metrics: EventSelectionMetrics,\n  preferFocalEra: boolean = true\n): number {\n  let score = 0;\n\n  // Base score from significance\n  score += metrics.significance * 30;\n\n  // Bonus for involving entry point\n  if (metrics.involvesEntryPoint) {\n    score += 20;\n  }\n\n  // Bonus for involving multiple assigned entities\n  score += metrics.assignedEntityCount * 10;\n\n  // Era alignment bonus/penalty\n  if (preferFocalEra) {\n    if (metrics.inFocalEra) {\n      score += 15;\n    } else {\n      score -= 10; // Soft penalty for cross-era events\n    }\n  }\n\n  // Temporal proximity bonus (closer to entry point creation = more relevant)\n  // Diminishing returns: 0-10 ticks = 10pts, 10-50 ticks = 5pts, 50+ ticks = 0pts\n  if (metrics.tickDistance <= 10) {\n    score += 10;\n  } else if (metrics.tickDistance <= 50) {\n    score += 5;\n  }\n\n  // Small randomization to break ties\n  // eslint-disable-next-line sonarjs/pseudo-random -- non-security tie-breaking jitter\n  score += Math.random() * 3;\n\n  return score;\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "metrics", "type": "EventSelectionMetrics", "optional": false}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestEventSelection", "name": "suggestEventSelection", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Auto-select events based on temporal alignment and relevance.\n * Returns event IDs sorted by score.\n */\nexport function suggestEventSelection(\n  events: NarrativeEventContext[],\n  metricsMap: Map<string, EventSelectionMetrics>,\n  maxEvents: number = 8,\n  preferFocalEra: boolean = true\n): string[] {\n  const scored = events.map((event) => {\n    const metrics = metricsMap.get(event.id);\n    if (!metrics) return { id: event.id, score: 0 };\n    return {\n      id: event.id,\n      score: scoreEventForSelection(event, metrics, preferFocalEra),\n    };\n  });\n\n  scored.sort((a, b) => b.score - a.score);\n\n  return scored.slice(0, maxEvents).map((s) => s.id);\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "metricsMap", "type": "Map<string, EventSelectionMetrics>", "optional": false}, {"name": "maxEvents", "type": "number", "optional": true}, {"name": "preferFocalEra", "type": "boolean", "optional": true}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::suggestRoleAssignments", "name": "suggestRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "export function suggestRoleAssignments(\n  candidates: EntityContext[],\n  roles: RoleDefinition[],\n  entryPointId: string,\n  _rules: unknown, // Deprecated - entity selection rules removed\n  relationships: RelationshipContext[],\n  _kindToCategory: Map<string, EntityCategory>,\n  metricsMap?: Map<string, EntitySelectionMetrics>\n): ChronicleRoleAssignment[] {\n  const assignments: ChronicleRoleAssignment[] = [];\n  const usedEntityIds = new Set<string>();\n\n  const entryPoint = candidates.find((e) => e.id === entryPointId);\n  const roleScores = buildRoleScores(candidates, roles, relationships, metricsMap);\n\n  if (entryPoint) {\n    assignEntryPoint(entryPoint, roles, assignments, usedEntityIds);\n  }\n\n  assignRemainingRoles(roles, roleScores, assignments, usedEntityIds);\n\n  return assignments;\n}", "parameters": [{"name": "candidates", "type": "EntityContext[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "entryPointId", "type": "string", "optional": false}, {"name": "_rules", "type": "unknown", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "_kindToCategory", "type": "Map<string, EntityCategory>", "optional": false}, {"name": "metricsMap", "type": "Map<string, EntitySelectionMetrics>", "optional": true}], "returnType": "ChronicleRoleAssignment[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::validateRoleAssignments", "name": "validateRoleAssignments", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Role Assignment Validation\n// =============================================================================\n\n/**\n * Validate role assignments against style constraints.\n */\nexport function validateRoleAssignments(\n  assignments: ChronicleRoleAssignment[],\n  roles: RoleDefinition[],\n  maxCastSize: number\n): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check total cast size\n  if (assignments.length > maxCastSize) {\n    errors.push(`Too many entities assigned (${assignments.length}/${maxCastSize} max)`);\n  }\n\n  // Check each role's min/max constraints\n  for (const roleDef of roles) {\n    const roleCount = assignments.filter((a) => a.role === roleDef.role).length;\n\n    if (roleCount < roleDef.count.min) {\n      if (roleDef.count.min === 1) {\n        errors.push(`Role \"${roleDef.role}\" requires at least 1 entity`);\n      } else {\n        errors.push(\n          `Role \"${roleDef.role}\" requires at least ${roleDef.count.min} entities (has ${roleCount})`\n        );\n      }\n    }\n\n    if (roleCount > roleDef.count.max) {\n      warnings.push(`Role \"${roleDef.role}\" has ${roleCount} entities (max ${roleDef.count.max})`);\n    }\n  }\n\n  // Check for duplicate entity assignments\n  const entityCounts = new Map<string, number>();\n  for (const assignment of assignments) {\n    const count = entityCounts.get(assignment.entityId) || 0;\n    entityCounts.set(assignment.entityId, count + 1);\n  }\n  for (const [entityId, count] of entityCounts) {\n    if (count > 1) {\n      const entity = assignments.find((a) => a.entityId === entityId);\n      warnings.push(`Entity \"${entity?.entityName}\" is assigned to ${count} roles`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "roles", "type": "RoleDefinition[]", "optional": false}, {"name": "maxCastSize", "type": "number", "optional": false}], "returnType": "ValidationResult"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantRelationships", "name": "getRelevantRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "// =============================================================================\n// Relationship & Event Selection\n// =============================================================================\n\n/**\n * Get relationships between assigned entities.\n */\nexport function getRelevantRelationships(\n  assignments: ChronicleRoleAssignment[],\n  allRelationships: RelationshipContext[],\n  extraEntityIds?: Iterable<string>\n): RelationshipContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n  if (extraEntityIds) {\n    for (const id of extraEntityIds) assignedIds.add(id);\n  }\n  return allRelationships.filter((r) => assignedIds.has(r.src) && assignedIds.has(r.dst));\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "extraEntityIds", "type": "Iterable<string>", "optional": true}], "returnType": "RelationshipContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::makeRelationshipId", "name": "makeRelationshipId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Create relationship ID from components.\n */\nexport function makeRelationshipId(src: string, dst: string, kind: string): string {\n  return `${src}:${dst}:${kind}`;\n}", "parameters": [{"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::collapseBidirectionalRelationships", "name": "collapseBidirectionalRelationships", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Collapse bidirectional relationships into single entries.\n * A\u2194B shown once instead of A\u2192B and B\u2192A separately.\n */\nexport function collapseBidirectionalRelationships(\n  relationships: RelationshipContext[]\n): CollapsedRelationship[] {\n  const result: CollapsedRelationship[] = [];\n  const processed = new Set<string>();\n\n  // Index relationships by normalized key (sorted src/dst + kind)\n  const byNormalizedKey = new Map<string, RelationshipContext[]>();\n  for (const rel of relationships) {\n    const normalizedKey = [rel.src, rel.dst].sort((a, b) => a.localeCompare(b)).join(\":\") + \":\" + rel.kind;\n    const existing = byNormalizedKey.get(normalizedKey) || [];\n    existing.push(rel);\n    byNormalizedKey.set(normalizedKey, existing);\n  }\n\n  for (const rel of relationships) {\n    const relId = makeRelationshipId(rel.src, rel.dst, rel.kind);\n    if (processed.has(relId)) continue;\n    processed.add(relId);\n\n    // Check for reverse relationship\n    const reverseId = makeRelationshipId(rel.dst, rel.src, rel.kind);\n    const reverseRel = relationships.find(\n      (r) => r.src === rel.dst && r.dst === rel.src && r.kind === rel.kind\n    );\n\n    if (reverseRel && !processed.has(reverseId)) {\n      // Bidirectional - collapse into one entry\n      processed.add(reverseId);\n      const avgStrength = ((rel.strength ?? 0.5) + (reverseRel.strength ?? 0.5)) / 2;\n      result.push({\n        primary: rel,\n        reverse: reverseRel,\n        isBidirectional: true,\n        relationshipIds: [relId, reverseId],\n        strength: avgStrength,\n      });\n    } else {\n      // Unidirectional\n      result.push({\n        primary: rel,\n        reverse: undefined,\n        isBidirectional: false,\n        relationshipIds: [relId],\n        strength: rel.strength ?? 0.5,\n      });\n    }\n  }\n\n  return result;\n}", "parameters": [{"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "CollapsedRelationship[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::getRelevantEvents", "name": "getRelevantEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Get events involving assigned entities.\n * Returns ALL matching events - UI is responsible for limiting final selection.\n */\nexport function getRelevantEvents(\n  assignments: ChronicleRoleAssignment[],\n  allEvents: NarrativeEventContext[]\n): NarrativeEventContext[] {\n  const assignedIds = new Set(assignments.map((a) => a.entityId));\n\n  // Return all events involving assigned entities - no artificial limit\n  // Final selection is limited to MAX_CHRONICLE_EVENTS in the UI\n  return allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && assignedIds.has(e.subjectId)) ||\n      (e.objectId && assignedIds.has(e.objectId))\n  );\n}", "parameters": [{"name": "assignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "NarrativeEventContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::isProminenceOnlyChronicleEvent", "name": "isProminenceOnlyChronicleEvent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Check if an event is prominence-only based on its stateChanges.\n * An event is \"prominence-only\" if ALL of its state changes are\n * field === 'prominence' changes. These events are typically noise\n * (gradual prominence shifts) rather than narratively interesting.\n */\nexport function isProminenceOnlyChronicleEvent(\n  event: NarrativeEventContext,\n  assignedEntityIds: Set<string>\n): boolean {\n  // Events with no stateChanges are NOT prominence-only (they might be actions, relationships, etc.)\n  if (!event.stateChanges || event.stateChanges.length === 0) {\n    return false;\n  }\n\n  // Only consider stateChanges for assigned entities\n  const relevantChanges = event.stateChanges.filter((sc) => assignedEntityIds.has(sc.entityId));\n\n  // If no relevant changes, not prominence-only\n  if (relevantChanges.length === 0) {\n    return false;\n  }\n\n  // Check if ALL relevant changes are prominence changes\n  return relevantChanges.every((sc) => sc.field === \"prominence\");\n}", "parameters": [{"name": "event", "type": "NarrativeEventContext", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}], "returnType": "boolean"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::filterChronicleEvents", "name": "filterChronicleEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Filter chronicle events by quality criteria.\n * Applies significance threshold and prominence-only exclusion.\n *\n * @param events - Events to filter (typically from getRelevantEvents)\n * @param assignedEntityIds - Set of assigned entity IDs for prominence check\n * @param options - Filter options\n * @returns Filtered events\n */\nexport function filterChronicleEvents(\n  events: NarrativeEventContext[],\n  assignedEntityIds: Set<string>,\n  options: ChronicleEventFilterOptions = {}\n): NarrativeEventContext[] {\n  const { minSignificance = 0, excludeProminenceOnly = true } = options;\n\n  return events.filter((event) => {\n    // Filter by significance threshold\n    if (event.significance < minSignificance) {\n      return false;\n    }\n\n    // Exclude prominence-only events if configured\n    if (excludeProminenceOnly && isProminenceOnlyChronicleEvent(event, assignedEntityIds)) {\n      return false;\n    }\n\n    return true;\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "options", "type": "ChronicleEventFilterOptions", "optional": true}], "returnType": "NarrativeEventContext[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts::buildWizardSelectionContext", "name": "buildWizardSelectionContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/selectionWizard.ts", "sourceCode": "/**\n * Build the selection context for the wizard given an entry point.\n * Returns candidates within 2-hop neighborhood.\n */\nexport function buildWizardSelectionContext(\n  entryPoint: EntityContext,\n  allEntities: EntityContext[],\n  allRelationships: RelationshipContext[],\n  allEvents: NarrativeEventContext[],\n  style: NarrativeStyle,\n  options: SelectionContextOptions = {}\n): WizardSelectionContext {\n  const { includeErasInNeighborhood = false } = options;\n\n  // Build set of era entity IDs for filtering\n  const eraEntityIds = new Set(allEntities.filter((e) => e.kind === \"era\").map((e) => e.id));\n\n  // Filter relationships for graph traversal - exclude those involving era nodes\n  const graphRelationships = includeErasInNeighborhood\n    ? allRelationships\n    : allRelationships.filter((r) => !eraEntityIds.has(r.src) && !eraEntityIds.has(r.dst));\n\n  // Build 2-hop neighborhood\n  const neighborGraph = buildNeighborGraph(graphRelationships, entryPoint.id, 2);\n\n  // Filter entities to those in the neighborhood\n  const neighborEntities = allEntities.filter((e) => neighborGraph.ids.has(e.id));\n\n  // Filter out era entities \u2014 they're time periods, not cast members\n  const filteredCandidates = neighborEntities.filter((e) => e.kind !== \"era\");\n\n  // Ensure entry point is included\n  const candidates = filteredCandidates.some((e) => e.id === entryPoint.id)\n    ? filteredCandidates\n    : [entryPoint, ...filteredCandidates];\n\n  // Get relationships between candidates\n  const candidateIds = new Set(candidates.map((e) => e.id));\n  const candidateRelationships = allRelationships.filter(\n    (r) => candidateIds.has(r.src) && candidateIds.has(r.dst)\n  );\n\n  // Get events involving candidates + world-structuring events (always available)\n  const candidateEvents = allEvents.filter(\n    (e) =>\n      e.eventKind === \"creation_batch\" ||\n      (e.subjectId && candidateIds.has(e.subjectId)) ||\n      (e.objectId && candidateIds.has(e.objectId))\n  );\n\n  return {\n    entryPoint,\n    candidates,\n    candidateRelationships,\n    candidateEvents,\n    distances: neighborGraph.distances,\n  };\n}", "parameters": [{"name": "entryPoint", "type": "EntityContext", "optional": false}, {"name": "allEntities", "type": "EntityContext[]", "optional": false}, {"name": "allRelationships", "type": "RelationshipContext[]", "optional": false}, {"name": "allEvents", "type": "NarrativeEventContext[]", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "options", "type": "SelectionContextOptions", "optional": true}], "returnType": "WizardSelectionContext"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeStoryPotential", "name": "computeStoryPotential", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Compute story potential for a single entity\n */\nexport function computeStoryPotential(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[],\n  maxValues: {\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }\n): StoryPotential {\n  const entity = entities.find((e) => e.id === entityId);\n  if (!entity) {\n    return {\n      connections: 0,\n      temporalSpan: 0,\n      roleDiversity: 0,\n      eventInvolvement: 0,\n      prominence: 0,\n      overallScore: 0,\n    };\n  }\n\n  // Count connections\n  const entityRels = relationships.filter((r) => r.src === entityId || r.dst === entityId);\n  const connectionCount = entityRels.length;\n\n  // Get connected entity kinds\n  const connectedIds = new Set<string>();\n  for (const rel of entityRels) {\n    connectedIds.add(rel.src === entityId ? rel.dst : rel.src);\n  }\n  const connectedKinds = new Set<string>();\n  for (const id of connectedIds) {\n    const connected = entities.find((e) => e.id === id);\n    if (connected) connectedKinds.add(connected.kind);\n  }\n\n  // Count events and get eras\n  const entityEvents = events.filter(\n    (e) =>\n      e.subjectId === entityId ||\n      e.objectId === entityId ||\n      e.participants?.some((p) => p.id === entityId)\n  );\n  const eventCount = entityEvents.length;\n  const eraIds = new Set(entityEvents.map((e) => e.era));\n\n  // Normalize values\n  const connections =\n    maxValues.maxConnections > 0 ? Math.min(connectionCount / maxValues.maxConnections, 1) : 0;\n\n  const temporalSpan = maxValues.maxEras > 0 ? Math.min(eraIds.size / maxValues.maxEras, 1) : 0;\n\n  const roleDiversity =\n    maxValues.maxKinds > 0 ? Math.min(connectedKinds.size / maxValues.maxKinds, 1) : 0;\n\n  const eventInvolvement =\n    maxValues.maxEvents > 0 ? Math.min(eventCount / maxValues.maxEvents, 1) : 0;\n\n  const prominence = normalizeProminence(entity.prominence);\n\n  // Compute weighted score\n  const overallScore =\n    WEIGHTS.connections * connections +\n    WEIGHTS.temporalSpan * temporalSpan +\n    WEIGHTS.roleDiversity * roleDiversity +\n    WEIGHTS.eventInvolvement * eventInvolvement +\n    WEIGHTS.prominence * prominence;\n\n  return {\n    connections,\n    temporalSpan,\n    roleDiversity,\n    eventInvolvement,\n    prominence,\n    overallScore,\n  };\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "maxValues", "type": "{\n    maxConnections: number;\n    maxEvents: number;\n    maxKinds: number;\n    maxEras: number;\n  }", "optional": false}], "returnType": "StoryPotential"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::computeAllStoryPotentials", "name": "computeAllStoryPotentials", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "export function computeAllStoryPotentials(\n  entities: EntityContext[],\n  relationships: RelationshipContext[],\n  events: NarrativeEventContext[]\n): Map<string, EntityWithPotential> {\n  const rawStats = new Map<string, RawEntityStats>();\n  let maxConnections = 0;\n  let maxEvents = 0;\n  let maxKinds = 0;\n  let maxEras = 0;\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = computeEntityRawStats(entity, entities, relationships, events);\n    rawStats.set(entity.id, stats);\n    maxConnections = Math.max(maxConnections, stats.connectionCount);\n    maxEvents = Math.max(maxEvents, stats.eventCount);\n    maxKinds = Math.max(maxKinds, stats.connectedKinds.length);\n    maxEras = Math.max(maxEras, stats.eraIds.length);\n  }\n\n  const result = new Map<string, EntityWithPotential>();\n  const maxValues = { maxConnections, maxEvents, maxKinds, maxEras };\n\n  for (const entity of entities) {\n    if (entity.kind === \"era\") continue;\n    const stats = rawStats.get(entity.id);\n    if (!stats) continue;\n\n    const potential = computeStoryPotential(entity.id, entities, relationships, events, maxValues);\n    result.set(entity.id, { ...entity, potential, ...stats });\n  }\n\n  return result;\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}, {"name": "events", "type": "NarrativeEventContext[]", "optional": false}], "returnType": "Map<string, EntityWithPotential>"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getConnectedEntities", "name": "getConnectedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get 1-hop connected entities for mini constellation\n */\nexport function getConnectedEntities(\n  entityId: string,\n  entities: EntityContext[],\n  relationships: RelationshipContext[]\n): ConnectedEntity[] {\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const connected: ConnectedEntity[] = [];\n\n  for (const rel of relationships) {\n    let connectedId: string | null = null;\n\n    if (rel.src === entityId) {\n      connectedId = rel.dst;\n    } else if (rel.dst === entityId) {\n      connectedId = rel.src;\n    }\n\n    if (connectedId) {\n      const entity = entityMap.get(connectedId);\n      if (entity && entity.kind !== \"era\") {\n        // Avoid duplicates but track all relationship kinds\n        const existing = connected.find((c) => c.id === connectedId);\n        if (!existing) {\n          connected.push({\n            id: connectedId,\n            name: entity.name,\n            kind: entity.kind,\n            relationshipKind: rel.kind,\n            strength: rel.strength,\n          });\n        }\n      }\n    }\n  }\n\n  return connected;\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}, {"name": "relationships", "type": "RelationshipContext[]", "optional": false}], "returnType": "ConnectedEntity[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::getUniqueKinds", "name": "getUniqueKinds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Get unique entity kinds from a list\n */\nexport function getUniqueKinds(entities: EntityContext[]): string[] {\n  const kinds = new Set<string>();\n  for (const entity of entities) {\n    if (entity.kind !== \"era\") {\n      kinds.add(entity.kind);\n    }\n  }\n  return [...kinds].sort((a, b) => a.localeCompare(b));\n}", "parameters": [{"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts::scoreToRating", "name": "scoreToRating", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/storyPotential.ts", "sourceCode": "/**\n * Convert story score to visual rating (1-5 dots)\n */\nexport function scoreToRating(score: number): number {\n  return Math.max(1, Math.min(5, Math.round(score * 5)));\n}", "parameters": [{"name": "score", "type": "number", "optional": false}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEraRanges", "name": "getEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Convert eras to era ranges for timeline display.\n * Uses the actual era boundaries - no computation.\n */\nexport function getEraRanges(\n  eras: Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n): EraRange[] {\n  return eras.map((era, i) => ({\n    id: era.id,\n    name: era.name,\n    startTick: era.startTick,\n    endTick: era.endTick ?? era.startTick + 100, // fallback for ongoing era\n    color: ERA_COLORS[i % ERA_COLORS.length],\n  }));\n}", "parameters": [{"name": "eras", "type": "Array<{ id: string; name: string; startTick: number; endTick: number | null }>", "optional": false}], "returnType": "EraRange[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareTimelineEvents", "name": "prepareTimelineEvents", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Transform events into timeline format\n */\nexport function prepareTimelineEvents(\n  events: NarrativeEventContext[],\n  entryPointId: string | null,\n  assignedEntityIds: Set<string>,\n  selectedEventIds: Set<string>\n): TimelineEvent[] {\n  return events.map((event) => {\n    const participants = event.participants || [];\n    const participantIds = new Set(participants.map((p) => p.id));\n\n    // Check if entry point or subject/object\n    const involvesEntryPoint =\n      entryPointId !== null &&\n      (event.subjectId === entryPointId ||\n        event.objectId === entryPointId ||\n        participantIds.has(entryPointId));\n\n    // Check if any cast member is involved\n    const involvesCastMember = [...assignedEntityIds].some(\n      (id) => event.subjectId === id || event.objectId === id || participantIds.has(id)\n    );\n\n    return {\n      id: event.id,\n      tick: event.tick,\n      eraId: event.era,\n      headline: event.headline,\n      description: event.description,\n      significance: event.significance,\n      involvesEntryPoint,\n      involvesCastMember,\n      participantCount: participants.length + (event.subjectId ? 1 : 0) + (event.objectId ? 1 : 0),\n      eventKind: event.eventKind,\n      selected: selectedEventIds.has(event.id),\n    };\n  });\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "entryPointId", "type": "string | null", "optional": false}, {"name": "assignedEntityIds", "type": "Set<string>", "optional": false}, {"name": "selectedEventIds", "type": "Set<string>", "optional": false}], "returnType": "TimelineEvent[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeIntensityCurve", "name": "computeIntensityCurve", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Compute intensity curve for sparkline\n * Uses a rolling window to smooth the data\n */\nexport function computeIntensityCurve(\n  events: NarrativeEventContext[],\n  windowSize: number = 10\n): IntensityPoint[] {\n  if (events.length === 0) return [];\n\n  // Sort by tick\n  const sorted = [...events].sort((a, b) => a.tick - b.tick);\n  const minTick = sorted[0].tick;\n  const maxTick = sorted[sorted.length - 1].tick;\n\n  // Create intensity map\n  const tickSignificance = new Map<number, number>();\n  for (const event of sorted) {\n    const current = tickSignificance.get(event.tick) || 0;\n    tickSignificance.set(event.tick, current + event.significance);\n  }\n\n  // Generate points at regular intervals\n  const numPoints = Math.min(50, maxTick - minTick + 1);\n  const step = Math.max(1, Math.floor((maxTick - minTick) / numPoints));\n  const points: IntensityPoint[] = [];\n\n  for (let tick = minTick; tick <= maxTick; tick += step) {\n    // Sum significance in window around this tick\n    let intensity = 0;\n    const halfWindow = Math.floor(windowSize / 2);\n\n    for (const [t, sig] of tickSignificance) {\n      if (t >= tick - halfWindow && t <= tick + halfWindow) {\n        // Weight by distance from center\n        const distance = Math.abs(t - tick);\n        const weight = 1 - distance / (halfWindow + 1);\n        intensity += sig * weight;\n      }\n    }\n\n    points.push({ tick, intensity });\n  }\n\n  // Normalize to 0-1\n  const maxIntensity = Math.max(...points.map((p) => p.intensity), 0.001);\n  return points.map((p) => ({\n    tick: p.tick,\n    intensity: p.intensity / maxIntensity,\n  }));\n}", "parameters": [{"name": "events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "windowSize", "type": "number", "optional": true}], "returnType": "IntensityPoint[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventsInRange", "name": "getEventsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get events within a tick range\n */\nexport function getEventsInRange(\n  events: TimelineEvent[],\n  startTick: number,\n  endTick: number\n): TimelineEvent[] {\n  return events.filter((e) => e.tick >= startTick && e.tick <= endTick);\n}", "parameters": [{"name": "events", "type": "TimelineEvent[]", "optional": false}, {"name": "startTick", "type": "number", "optional": false}, {"name": "endTick", "type": "number", "optional": false}], "returnType": "TimelineEvent[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getTimelineExtent", "name": "getTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get timeline extent from era boundaries.\n * Returns [0, maxEndTick] - the full simulation range.\n */\nexport function getTimelineExtent(\n  eras: Array<{ startTick: number; endTick: number | null }>\n): [number, number] {\n  if (eras.length === 0) return [0, 100];\n\n  const maxTick = Math.max(...eras.map((e) => e.endTick ?? e.startTick + 100));\n\n  return [0, maxTick];\n}", "parameters": [{"name": "eras", "type": "Array<{ startTick: number; endTick: number | null }>", "optional": false}], "returnType": "[number, number]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::tickToX", "name": "tickToX", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale a tick value to SVG x coordinate\n */\nexport function tickToX(\n  tick: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  return padding + ((tick - minTick) / range) * usableWidth;\n}", "parameters": [{"name": "tick", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::xToTick", "name": "xToTick", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Scale SVG x coordinate back to tick value\n */\nexport function xToTick(\n  x: number,\n  extent: [number, number],\n  width: number,\n  padding: number = 0\n): number {\n  const [minTick, maxTick] = extent;\n  const range = maxTick - minTick || 1;\n  const usableWidth = width - 2 * padding;\n  const normalized = (x - padding) / usableWidth;\n  return Math.round(minTick + normalized * range);\n}", "parameters": [{"name": "x", "type": "number", "optional": false}, {"name": "extent", "type": "[number, number]", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "padding", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventFill", "name": "getEventFill", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get fill pattern based on involvement level\n */\nexport function getEventFill(event: TimelineEvent): string {\n  if (event.involvesEntryPoint) return \"var(--accent-color)\";\n  if (event.involvesCastMember) return \"var(--accent-color-muted, rgba(99, 102, 241, 0.6))\";\n  return \"var(--text-muted)\";\n}", "parameters": [{"name": "event", "type": "TimelineEvent", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getEventHeight", "name": "getEventHeight", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get event height based on significance (for visual weight)\n */\nexport function getEventHeight(\n  significance: number,\n  maxHeight: number = 40,\n  minHeight: number = 16\n): number {\n  return minHeight + significance * (maxHeight - minHeight);\n}", "parameters": [{"name": "significance", "type": "number", "optional": false}, {"name": "maxHeight", "type": "number", "optional": true}, {"name": "minHeight", "type": "number", "optional": true}], "returnType": "number"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerShape", "name": "getCastMarkerShape", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get SVG path data for a cast marker based on entity kind.\n * Paths are centered at (0,0) \u2014 use transform to position.\n */\nexport function getCastMarkerShape(kind: string): { path: string; size: number } {\n  switch (kind) {\n    case \"person\":\n      // Diamond\n      return { path: \"M 0 -4 L 4 0 L 0 4 L -4 0 Z\", size: 8 };\n    case \"faction\":\n      // Circle\n      return { path: \"M 0 -3.5 A 3.5 3.5 0 1 1 0 3.5 A 3.5 3.5 0 1 1 0 -3.5 Z\", size: 7 };\n    case \"location\":\n      // Square\n      return { path: \"M -3 -3 L 3 -3 L 3 3 L -3 3 Z\", size: 6 };\n    case \"occurrence\":\n      // 6-pointed star (outer=4, inner=2)\n      return {\n        path: \"M 0 -4 L 1 -1.7 L 3.5 -2 L 2 0 L 3.5 2 L 1 1.7 L 0 4 L -1 1.7 L -3.5 2 L -2 0 L -3.5 -2 L -1 -1.7 Z\",\n        size: 8,\n      };\n    default:\n      // Triangle\n      return { path: \"M 0 -3.5 L 3.5 3 L -3.5 3 Z\", size: 7 };\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "{ path: string; size: number }"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::getCastMarkerColor", "name": "getCastMarkerColor", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Get color for a cast marker based on entity kind.\n * Uses a pastel palette distinct from event card fills.\n */\nexport function getCastMarkerColor(kind: string): string {\n  switch (kind) {\n    case \"person\":\n      return \"#818cf8\";\n    case \"faction\":\n      return \"#a78bfa\";\n    case \"location\":\n      return \"#34d399\";\n    case \"occurrence\":\n      return \"#fbbf24\";\n    case \"ability\":\n      return \"#f472b6\";\n    case \"rule\":\n      return \"#22d3ee\";\n    default:\n      return \"#9ca3af\";\n  }\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::prepareCastMarkers", "name": "prepareCastMarkers", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "/**\n * Build cast markers from role assignments, lens, and entity data.\n * Includes the entry point and lens (if provided) and dedupes by entity ID.\n */\nexport function prepareCastMarkers(\n  roleAssignments: ChronicleRoleAssignment[],\n  entityMap: Map<string, EntityContext>,\n  entryPoint?: EntityContext | null,\n  lens?: NarrativeLens | null\n): CastMarker[] {\n  const seen = new Set<string>();\n  const markers: CastMarker[] = [];\n\n  if (entryPoint) {\n    seen.add(entryPoint.id);\n    markers.push({\n      entityId: entryPoint.id,\n      entityName: entryPoint.name,\n      entityKind: entryPoint.kind,\n      subtype: entryPoint.subtype,\n      createdAt: entryPoint.createdAt,\n      isPrimary: true,\n      isEntryPoint: true,\n      isLens: false,\n    });\n  }\n\n  if (lens && !seen.has(lens.entityId)) {\n    seen.add(lens.entityId);\n    const lensEntity = entityMap.get(lens.entityId);\n    if (lensEntity) {\n      markers.push({\n        entityId: lens.entityId,\n        entityName: lens.entityName,\n        entityKind: lens.entityKind,\n        subtype: lensEntity.subtype,\n        createdAt: lensEntity.createdAt,\n        isPrimary: false,\n        isEntryPoint: false,\n        isLens: true,\n      });\n    }\n  }\n\n  for (const assignment of roleAssignments) {\n    if (seen.has(assignment.entityId)) continue;\n    seen.add(assignment.entityId);\n\n    const entity = entityMap.get(assignment.entityId);\n    if (!entity) continue;\n\n    markers.push({\n      entityId: assignment.entityId,\n      entityName: assignment.entityName,\n      entityKind: assignment.entityKind,\n      subtype: entity.subtype,\n      createdAt: entity.createdAt,\n      role: assignment.role,\n      isPrimary: assignment.isPrimary,\n      isEntryPoint: false,\n      isLens: false,\n    });\n  }\n\n  markers.sort((a, b) => a.createdAt - b.createdAt);\n  return markers;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}, {"name": "entityMap", "type": "Map<string, EntityContext>", "optional": false}, {"name": "entryPoint", "type": "EntityContext | null", "optional": true}, {"name": "lens", "type": "NarrativeLens | null", "optional": true}], "returnType": "CastMarker[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeEraRanges", "name": "computeEraRanges", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeEraRanges = (\n  _events: NarrativeEventContext[],\n  eras: Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>\n) =>\n  getEraRanges(\n    eras as Array<{ id: string; name: string; startTick: number; endTick: number | null }>\n  )", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ id: string; name: string; startTick?: number; endTick?: number | null }>", "optional": false}], "returnType": "EraRange[]"}, {"id": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts::computeTimelineExtent", "name": "computeTimelineExtent", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/timelineUtils.ts", "sourceCode": "computeTimelineExtent = (\n  _events: NarrativeEventContext[],\n  eras?: Array<{ endTick?: number | null; startTick?: number }>\n): [number, number] => {\n  if (!eras || eras.length === 0) return [0, 100];\n  return getTimelineExtent(eras as Array<{ startTick: number; endTick: number | null }>);\n}", "parameters": [{"name": "_events", "type": "NarrativeEventContext[]", "optional": false}, {"name": "eras", "type": "Array<{ endTick?: number | null; startTick?: number }>", "optional": true}], "returnType": "[number, number]"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleNav.ts::buildNavItem", "name": "buildNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleNav.ts", "sourceCode": "export function buildNavItem(record: ChronicleRecord): ChronicleNavItem {\n  const primaryCount = record.roleAssignments?.filter((r) => r.isPrimary).length || 0;\n  const supportingCount = (record.roleAssignments?.length || 0) - primaryCount;\n  const historianNoteCount = (record.historianNotes || []).filter(isNoteActive).length;\n  const displayName =\n    record.title ||\n    (record.roleAssignments?.length > 0\n      ? record.roleAssignments\n          .filter((r) => r.isPrimary)\n          .map((r) => r.entityName)\n          .join(\" & \") || record.roleAssignments[0]?.entityName\n      : \"\") ||\n    \"Untitled Chronicle\";\n\n  const backportProgress = computeBackportProgress(record);\n\n  let focalEraOrder: number | undefined;\n  if (typeof record.temporalContext?.focalEra?.order === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.order;\n  } else if (typeof record.temporalContext?.focalEra?.startTick === \"number\") {\n    focalEraOrder = record.temporalContext.focalEra.startTick;\n  }\n\n  return {\n    id: record.chronicleId,\n    chronicleId: record.chronicleId,\n    name: displayName,\n    status: deriveStatus(record),\n    title: record.title,\n    format: record.format,\n    focusType: record.focusType,\n    primaryCount,\n    supportingCount,\n    narrativeStyleId: record.narrativeStyleId,\n    narrativeStyleName: record.narrativeStyle?.name,\n    perspectiveSynthesis: !!record.perspectiveSynthesis,\n    combineInstructions: !!record.combineInstructions,\n    coverImageComplete: record.coverImage?.status === \"complete\",\n    backportDone: backportProgress.done,\n    backportTotal: backportProgress.total,\n    historianNoteCount,\n    lens: record.lens ? { entityName: record.lens.entityName } : undefined,\n    imageRefCompleteCount:\n      record.imageRefs?.refs?.filter(\n        (r: { type: string; status?: string }) =>\n          r.type === \"prompt_request\" && r.status === \"complete\"\n      ).length || 0,\n    failureStep: record.failureStep,\n    createdAt: record.createdAt || 0,\n    updatedAt: record.updatedAt || 0,\n    selectedEntityIds: record.selectedEntityIds,\n    roleAssignments: record.roleAssignments,\n    wordCount: (record.finalContent || record.assembledContent || \"\")\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean).length,\n    focalEraName: record.temporalContext?.focalEra?.name,\n    focalEraOrder,\n    focalEraStartTick: record.temporalContext?.focalEra?.startTick,\n    eraYear: record.eraYear,\n    hasTemporalNarrative: !!record.perspectiveSynthesis?.temporalNarrative,\n    hasTemporalCheck: !!record.temporalCheckReport,\n    hasHistorianPrep: !!record.historianPrep,\n    hasSummary: !!record.summary,\n    toneRanking: record.toneRanking?.ranking,\n    assignedTone: record.assignedTone,\n    eraNarrativeWeight: record.narrativeStyle?.eraNarrativeWeight,\n  };\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "ChronicleNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::generateChronicleId", "name": "generateChronicleId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Pure functions (no DB access)\n// ============================================================================\n\n/**\n * Generate a unique chronicle ID\n */\nexport function generateChronicleId(): string {\n  return `chronicle_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveTitleFromRoles", "name": "deriveTitleFromRoles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Derive a title from role assignments\n */\nexport function deriveTitleFromRoles(roleAssignments: ChronicleRoleAssignment[]): string {\n  const primary = roleAssignments.filter((r) => r.isPrimary);\n  if (primary.length === 0) {\n    const first = roleAssignments[0];\n    return first ? `Chronicle of ${first.entityName}` : \"Untitled Chronicle\";\n  }\n  if (primary.length === 1) {\n    return `Chronicle of ${primary[0].entityName}`;\n  }\n  if (primary.length === 2) {\n    return `${primary[0].entityName} and ${primary[1].entityName}`;\n  }\n  return `${primary[0].entityName} and ${primary.length - 1} others`;\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deriveFocusType", "name": "deriveFocusType", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Determine focus type from role assignments\n */\nexport function deriveFocusType(roleAssignments: ChronicleRoleAssignment[]): ChronicleFocusType {\n  const primaryCount = roleAssignments.filter((r) => r.isPrimary).length;\n  if (primaryCount <= 1) return \"single\";\n  return \"ensemble\";\n}", "parameters": [{"name": "roleAssignments", "type": "ChronicleRoleAssignment[]", "optional": false}], "returnType": "ChronicleFocusType"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicleShell", "name": "createChronicleShell", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Create operations\n// ============================================================================\n\n/**\n * Create a shell chronicle record before generation starts.\n * This provides immediate UI feedback while generation is in progress.\n */\nexport async function createChronicleShell(\n  chronicleId: string,\n  metadata: ChronicleShellMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    generationSampling: metadata.generationSampling,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation state - starts as 'generating'\n    status: \"generating\",\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: 0,\n    totalActualCost: 0,\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleShellMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::createChronicle", "name": "createChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Create a chronicle record (single-shot generation, goes directly to assembly_ready)\n */\nexport async function createChronicle(\n  chronicleId: string,\n  metadata: ChronicleMetadata\n): Promise<ChronicleRecord> {\n  if (!metadata.generationSampling) {\n    throw new Error(`Chronicle ${chronicleId} missing generationSampling (required)`);\n  }\n  const focusType = deriveFocusType(metadata.roleAssignments);\n  const title = metadata.title || deriveTitleFromRoles(metadata.roleAssignments);\n  const assembledAt = Date.now();\n  const activeVersionId = createUniqueVersionId(new Set(), assembledAt);\n  const initialVersion: ChronicleGenerationVersion = {\n    versionId: activeVersionId,\n    generatedAt: assembledAt,\n    content: metadata.assembledContent,\n    wordCount: countWords(metadata.assembledContent),\n    model: metadata.model,\n    sampling: metadata.generationSampling,\n    systemPrompt: metadata.generationSystemPrompt,\n    userPrompt: metadata.generationUserPrompt,\n    step: \"generate\",\n  };\n  const record: ChronicleRecord = {\n    chronicleId,\n    projectId: metadata.projectId,\n    simulationRunId: metadata.simulationRunId,\n\n    // Chronicle identity\n    title,\n    format: metadata.format,\n    focusType,\n    narrativeStyleId: metadata.narrativeStyleId,\n    narrativeStyle: metadata.narrativeStyle,\n    roleAssignments: metadata.roleAssignments,\n    lens: metadata.lens,\n    selectedEntityIds: metadata.selectedEntityIds,\n    selectedEventIds: metadata.selectedEventIds,\n    selectedRelationshipIds: metadata.selectedRelationshipIds,\n    temporalContext: metadata.temporalContext,\n    narrativeDirection: metadata.narrativeDirection,\n\n    // Mechanical\n    entrypointId: metadata.entrypointId,\n\n    // Generation result\n    selectionSummary: metadata.selectionSummary,\n    perspectiveSynthesis: metadata.perspectiveSynthesis,\n    generationSystemPrompt: metadata.generationSystemPrompt,\n    generationUserPrompt: metadata.generationUserPrompt,\n    generationSampling: metadata.generationSampling,\n    generationStep: \"generate\",\n    generationHistory: [initialVersion],\n    activeVersionId,\n    status: \"assembly_ready\",\n    assembledContent: metadata.assembledContent,\n    assembledAt,\n    editVersion: 0,\n    validationStale: false,\n    totalEstimatedCost: metadata.cost.estimated,\n    totalActualCost: metadata.cost.actual,\n    totalInputTokens: metadata.cost.inputTokens,\n    totalOutputTokens: metadata.cost.outputTokens,\n    model: metadata.model,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n  };\n\n  await db.chronicles.put(record);\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "metadata", "type": "ChronicleMetadata", "optional": false}], "returnType": "Promise<ChronicleRecord>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssembly", "name": "updateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read-modify-write operations\n// ============================================================================\n\n/**\n * Update chronicle with assembled content (regeneration)\n */\nexport async function updateChronicleAssembly(\n  chronicleId: string,\n  assembledContent: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.updatedAt = Date.now();\n  record.activeVersionId = nextVersion.versionId;\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::regenerateChronicleAssembly", "name": "regenerateChronicleAssembly", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Replace chronicle assembled content via sampling regeneration.\n * Appends a new version to generationHistory and clears refinements.\n */\nexport async function regenerateChronicleAssembly(\n  chronicleId: string,\n  updates: {\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is already accepted`);\n  }\n  if (!updates.sampling) {\n    throw new Error(`Chronicle ${chronicleId} missing sampling for regeneration`);\n  }\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: updates.assembledContent,\n    wordCount: countWords(updates.assembledContent),\n    model: updates.model,\n    sampling: updates.sampling,\n    systemPrompt: updates.systemPrompt,\n    userPrompt: updates.userPrompt,\n    step: updates.step,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = updates.assembledContent;\n  record.assembledAt = generatedAt;\n  record.status = \"assembly_ready\";\n  record.generationSystemPrompt = updates.systemPrompt;\n  record.generationUserPrompt = updates.userPrompt;\n  record.generationSampling = updates.sampling;\n  record.generationStep = updates.step;\n  record.activeVersionId = nextVersion.versionId;\n\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  record.summaryTargetVersionId = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.editVersion = 0;\n  record.editedAt = undefined;\n\n  record.totalEstimatedCost += updates.cost.estimated;\n  record.totalActualCost += updates.cost.actual;\n  record.totalInputTokens += updates.cost.inputTokens;\n  record.totalOutputTokens += updates.cost.outputTokens;\n  record.model = updates.model;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    assembledContent: string;\n    systemPrompt: string;\n    userPrompt: string;\n    model: string;\n    sampling?: ChronicleRecord[\"generationSampling\"];\n    cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number };\n    step?: VersionStep;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEdit", "name": "updateChronicleEdit", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with revised content (post-validation edits)\n */\nexport async function updateChronicleEdit(\n  chronicleId: string,\n  assembledContent: string,\n  cost?: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const generatedAt = Date.now();\n  const existingIds = new Set((record.generationHistory || []).map((v) => v.versionId));\n  const versionId = createUniqueVersionId(existingIds, generatedAt);\n  const systemPrompt =\n    record.generationSystemPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const userPrompt =\n    record.generationUserPrompt ||\n    \"(prompt not stored - chronicle generated before prompt storage was implemented)\";\n  const nextVersion: ChronicleGenerationVersion = {\n    versionId,\n    generatedAt,\n    content: assembledContent,\n    wordCount: countWords(assembledContent),\n    model: record.model || \"unknown\",\n    sampling: record.generationSampling,\n    systemPrompt,\n    userPrompt,\n    step: record.generationStep,\n  };\n  record.generationHistory = [...(record.generationHistory || []), nextVersion];\n\n  record.assembledContent = assembledContent;\n  record.assembledAt = generatedAt;\n  record.editedAt = generatedAt;\n  record.editVersion = (record.editVersion || 0) + 1;\n  record.cohesionReport = undefined;\n  record.validatedAt = undefined;\n  record.summary = undefined;\n  record.summaryGeneratedAt = undefined;\n  record.summaryModel = undefined;\n  // Preserve imageRefs and coverImage - user decides via keep/regenerate UI\n  record.validationStale = false;\n  record.status = \"editing\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  if (cost) {\n    record.totalEstimatedCost += cost.estimated;\n    record.totalActualCost += cost.actual;\n    record.totalInputTokens += cost.inputTokens;\n    record.totalOutputTokens += cost.outputTokens;\n  }\n  record.activeVersionId = nextVersion.versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "assembledContent", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFailure", "name": "updateChronicleFailure", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as failed (worker error)\n */\nexport async function updateChronicleFailure(\n  chronicleId: string,\n  step: ChronicleStep,\n  reason: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"failed\";\n  record.failureStep = step;\n  record.failureReason = reason;\n  record.failedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "step", "type": "ChronicleStep", "optional": false}, {"name": "reason", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCohesion", "name": "updateChronicleCohesion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cohesion report (validation complete)\n */\nexport async function updateChronicleCohesion(\n  chronicleId: string,\n  cohesionReport: CohesionReport,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.cohesionReport = cohesionReport;\n  record.validatedAt = Date.now();\n  record.status = \"validation_ready\";\n  record.failureStep = undefined;\n  record.failureReason = undefined;\n  record.failedAt = undefined;\n  record.validationStale = false;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "cohesionReport", "type": "CohesionReport", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleComparisonReport", "name": "updateChronicleComparisonReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Store a version comparison report (text analysis, no new draft).\n */\nexport async function updateChronicleComparisonReport(\n  chronicleId: string,\n  report: string,\n  combineInstructions?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.comparisonReport = report;\n  record.comparisonReportGeneratedAt = Date.now();\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalCheckReport", "name": "updateChronicleTemporalCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleTemporalCheckReport(\n  chronicleId: string,\n  report: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.temporalCheckReport = report;\n  record.temporalCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleQuickCheckReport", "name": "updateChronicleQuickCheckReport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleQuickCheckReport(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").QuickCheckReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.quickCheckReport = report;\n  record.quickCheckReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").QuickCheckReport", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleFactCoverage", "name": "updateChronicleFactCoverage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle fact coverage analysis report\n */\nexport async function updateChronicleFactCoverage(\n  chronicleId: string,\n  report: import(\"../chronicleTypes\").FactCoverageReport\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.factCoverageReport = report;\n  record.factCoverageReportGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "report", "type": "import(\"../chronicleTypes\").FactCoverageReport", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::repairFactCoverageWasFaceted", "name": "repairFactCoverageWasFaceted", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * One-shot fixup: recompute wasFaceted on all stored factCoverageReports\n * using perspectiveSynthesis.facets[].factId instead of fuzzy text matching.\n */\nexport async function repairFactCoverageWasFaceted(): Promise<number> {\n  const all = await db.chronicles.toArray();\n  let patched = 0;\n  for (const record of all) {\n    if (!record.factCoverageReport?.entries?.length) continue;\n    const facetedIds = new Set(\n      (record.perspectiveSynthesis?.facets ?? []).map((f: { factId: string }) => f.factId)\n    );\n    let changed = false;\n    for (const entry of record.factCoverageReport.entries) {\n      const correct = facetedIds.has(entry.factId);\n      if (entry.wasFaceted !== correct) {\n        entry.wasFaceted = correct;\n        changed = true;\n      }\n    }\n    if (changed) {\n      record.updatedAt = Date.now();\n      await db.chronicles.put(record);\n      patched++;\n    }\n  }\n  console.log(`[repairFactCoverageWasFaceted] Patched ${patched} chronicles`);\n  return patched;\n}", "parameters": [], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeCorpusFactStrength", "name": "computeCorpusFactStrength", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute corpus-wide fact strength scores from all chronicles with coverage reports.\n * Returns a Map of factId \u2192 strength percentage (0-100).\n * Weighted: integral=3, prevalent=2, mentioned=1, missing=0, divided by max possible.\n */\nexport async function computeCorpusFactStrength(\n  simulationRunId: string\n): Promise<Map<string, number>> {\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const totals = new Map<string, { weighted: number; count: number }>();\n\n  const ratingWeight: Record<string, number> = {\n    integral: 3,\n    prevalent: 2,\n    mentioned: 1,\n    missing: 0,\n  };\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.factCoverageReport?.entries?.length) continue;\n    for (const entry of chronicle.factCoverageReport.entries) {\n      const agg = totals.get(entry.factId) || { weighted: 0, count: 0 };\n      agg.weighted += ratingWeight[entry.rating] ?? 0;\n      agg.count += 1;\n      totals.set(entry.factId, agg);\n    }\n  }\n\n  const result = new Map<string, number>();\n  for (const [factId, agg] of totals) {\n    result.set(factId, agg.count > 0 ? Math.round((agg.weighted / (agg.count * 3)) * 100) : 0);\n  }\n  return result;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, number>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::computeAnnotationReinforcementCounts", "name": "computeAnnotationReinforcementCounts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Count how many annotations have reinforced each canon fact.\n * Scans both chronicle.reinforcedFacts and entity.enrichment.reinforcedFacts.\n */\nexport async function computeAnnotationReinforcementCounts(\n  simulationRunId: string\n): Promise<ReinforcementCounts> {\n  const counts = new Map<string, number>();\n  let totalAnnotationsWithGuidance = 0;\n\n  // Chronicle reinforcements\n  const chronicles = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const c of chronicles) {\n    if (!c.reinforcedFacts?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of c.reinforcedFacts) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  // Entity reinforcements\n  const entities = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  for (const e of entities) {\n    const rf = e.enrichment?.reinforcedFacts;\n    if (!rf?.length) continue;\n    totalAnnotationsWithGuidance++;\n    for (const factId of rf) {\n      counts.set(factId, (counts.get(factId) ?? 0) + 1);\n    }\n  }\n\n  return { counts, totalAnnotationsWithGuidance };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ReinforcementCounts>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTertiaryCast", "name": "updateChronicleTertiaryCast", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle tertiary cast (detected entity mentions not in declared cast)\n */\nexport async function updateChronicleTertiaryCast(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").TertiaryCastEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.tertiaryCast = entries;\n  record.tertiaryCastDetectedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").TertiaryCastEntry[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianPrep", "name": "updateChronicleHistorianPrep", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with historian prep brief\n */\nexport async function updateChronicleHistorianPrep(\n  chronicleId: string,\n  historianPrep: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianPrep = historianPrep;\n  record.historianPrepGeneratedAt = Date.now();\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianPrep", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleSummary", "name": "updateChronicleSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with summary and title refinement\n */\nexport async function updateChronicleSummary(\n  chronicleId: string,\n  summary: string,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.summary = summary;\n  record.summaryGeneratedAt = Date.now();\n  record.summaryModel = model;\n  record.summaryTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTitle", "name": "updateChronicleTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with title generation results.\n * Always writes to pending fields \u2014 user must accept via modal.\n */\nexport async function updateChronicleTitle(\n  chronicleId: string,\n  title: string,\n  candidates: string[],\n  fragments: string[],\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = title;\n  record.pendingTitleCandidates = candidates;\n  record.pendingTitleFragments = fragments;\n  record.titleFragments = fragments;\n  record.titleGeneratedAt = Date.now();\n  record.titleModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "title", "type": "string", "optional": false}, {"name": "candidates", "type": "string[]", "optional": false}, {"name": "fragments", "type": "string[]", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptPendingTitle", "name": "acceptPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Accept a pending title\n */\nexport async function acceptPendingTitle(chronicleId: string, chosenTitle?: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.pendingTitle) throw new Error(`No pending title for chronicle ${chronicleId}`);\n\n  record.title = chosenTitle || record.pendingTitle;\n  record.titleCandidates = record.pendingTitleCandidates;\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "chosenTitle", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::rejectPendingTitle", "name": "rejectPendingTitle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reject a pending title on a published chronicle\n */\nexport async function rejectPendingTitle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.pendingTitle = undefined;\n  record.pendingTitleCandidates = undefined;\n  record.pendingTitleFragments = undefined;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRefs", "name": "updateChronicleImageRefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with image refs refinement\n */\nexport async function updateChronicleImageRefs(\n  chronicleId: string,\n  imageRefs: ChronicleImageRefs,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string,\n  targetVersionId?: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.imageRefs = imageRefs;\n  record.imageRefsGeneratedAt = Date.now();\n  record.imageRefsModel = model;\n  record.imageRefsTargetVersionId = targetVersionId;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "imageRefs", "type": "ChronicleImageRefs", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}, {"name": "targetVersionId", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleImageRef", "name": "updateChronicleImageRef", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleImageRef(\n  chronicleId: string,\n  refId: string,\n  updates: {\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const refIndex = record.imageRefs.refs.findIndex((r) => r.refId === refId);\n  if (refIndex === -1) {\n    throw new Error(`Image ref ${refId} not found in chronicle ${chronicleId}`);\n  }\n\n  const ref = record.imageRefs.refs[refIndex];\n  const wantsPromptUpdates =\n    updates.status !== undefined ||\n    updates.generatedImageId !== undefined ||\n    updates.error !== undefined ||\n    updates.sceneDescription !== undefined;\n\n  if (wantsPromptUpdates && ref.type !== \"prompt_request\") {\n    throw new Error(`Image ref ${refId} is not a prompt request`);\n  }\n\n  applyBaseImageRefUpdates(ref, updates);\n  if (ref.type === \"prompt_request\") {\n    applyPromptRequestUpdates(ref, updates);\n  }\n\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "refId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status?: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n    anchorText?: string;\n    anchorIndex?: number;\n    caption?: string;\n    size?: \"small\" | \"medium\" | \"large\" | \"full-width\";\n    justification?: \"left\" | \"right\" | null;\n    sceneDescription?: string;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::applyImageRefSelections", "name": "applyImageRefSelections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Apply image ref selections after version change.\n * - 'reuse': Keep the ref as-is\n * - 'regenerate': Reset the ref (clear generated image, set status to pending)\n * - 'skip': Remove the ref entirely\n *\n * Also updates imageRefsTargetVersionId to the new version.\n */\nexport async function applyImageRefSelections(\n  chronicleId: string,\n  selections: Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>,\n  newTargetVersionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.imageRefs) throw new Error(`Chronicle ${chronicleId} has no image refs`);\n\n  const selectionMap = new Map(selections.map((s) => [s.refId, s.action]));\n\n  // Filter and transform refs based on selections\n  const updatedRefs = record.imageRefs.refs\n    .filter((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      return action !== \"skip\";\n    })\n    .map((ref) => {\n      const action = selectionMap.get(ref.refId) ?? \"reuse\";\n      if (action === \"regenerate\" && ref.type === \"prompt_request\") {\n        // Reset prompt request refs for regeneration\n        return {\n          ...ref,\n          status: \"pending\" as const,\n          generatedImageId: undefined,\n          error: undefined,\n        };\n      }\n      return ref;\n    });\n\n  record.imageRefs = {\n    ...record.imageRefs,\n    refs: updatedRefs,\n  };\n  record.imageRefsTargetVersionId = newTargetVersionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "selections", "type": "Array<{ refId: string; action: \"reuse\" | \"regenerate\" | \"skip\" }>", "optional": false}, {"name": "newTargetVersionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImage", "name": "updateChronicleCoverImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle with cover image scene description\n */\nexport async function updateChronicleCoverImage(\n  chronicleId: string,\n  coverImage: ChronicleCoverImage,\n  cost: { estimated: number; actual: number; inputTokens: number; outputTokens: number },\n  model: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.coverImage = coverImage;\n  record.coverImageGeneratedAt = Date.now();\n  record.coverImageModel = model;\n  record.totalEstimatedCost += cost.estimated;\n  record.totalActualCost += cost.actual;\n  record.totalInputTokens += cost.inputTokens;\n  record.totalOutputTokens += cost.outputTokens;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "coverImage", "type": "ChronicleCoverImage", "optional": false}, {"name": "cost", "type": "{ estimated: number; actual: number; inputTokens: number; outputTokens: number }", "optional": false}, {"name": "model", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCoverImageStatus", "name": "updateChronicleCoverImageStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update cover image generation status (after image generation completes)\n */\nexport async function updateChronicleCoverImageStatus(\n  chronicleId: string,\n  updates: {\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n  if (!record.coverImage) throw new Error(`Chronicle ${chronicleId} has no cover image`);\n\n  record.coverImage.status = updates.status;\n  if (updates.generatedImageId !== undefined) {\n    record.coverImage.generatedImageId = updates.generatedImageId || undefined;\n  }\n  if (updates.error !== undefined) {\n    record.coverImage.error = updates.error || undefined;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "updates", "type": "{\n    status: \"pending\" | \"generating\" | \"complete\" | \"failed\";\n    generatedImageId?: string;\n    error?: string;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleTemporalContext", "name": "updateChronicleTemporalContext", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update chronicle temporal context (e.g., post-publish corrections)\n */\nexport async function updateChronicleTemporalContext(\n  chronicleId: string,\n  temporalContext: ChronicleTemporalContext | undefined | null\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (temporalContext) {\n    record.temporalContext = temporalContext;\n  } else {\n    delete record.temporalContext;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "temporalContext", "type": "ChronicleTemporalContext | undefined | null", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::refreshEraSummariesInChronicles", "name": "refreshEraSummariesInChronicles", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function refreshEraSummariesInChronicles(\n  simulationRunId: string,\n  currentEras: EraTemporalInfo[]\n): Promise<number> {\n  const summaryMap = new Map(currentEras.map((e) => [e.id, e.summary || \"\"]));\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const record of records) {\n    const changed = patchTemporalContext(record, summaryMap) || patchPerspectiveSynthesisFocalEra(record, summaryMap);\n    if (changed) {\n      record.updatedAt = Date.now();\n      toUpdate.push(record);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "currentEras", "type": "EraTemporalInfo[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::acceptChronicle", "name": "acceptChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Mark chronicle as complete (user accepted)\n */\nexport async function acceptChronicle(\n  chronicleId: string,\n  options?: { finalContent?: string; acceptedVersionId?: string }\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const fallbackActive = getLatestVersion(versions)?.versionId;\n  const activeVersionId = options?.acceptedVersionId || record.activeVersionId || fallbackActive;\n  const activeVersion = versions.find((v) => v.versionId === activeVersionId);\n  const acceptedVersionId = activeVersionId || record.acceptedVersionId;\n\n  record.finalContent = options?.finalContent ?? activeVersion?.content ?? record.assembledContent;\n  record.acceptedVersionId = acceptedVersionId;\n  record.activeVersionId = acceptedVersionId;\n  record.acceptedAt = Date.now();\n  record.status = \"complete\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "options", "type": "{ finalContent?: string; acceptedVersionId?: string }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::unpublishChronicle", "name": "unpublishChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Unpublish a completed chronicle, reverting it to assembly_ready.\n */\nexport async function unpublishChronicle(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  delete record.finalContent;\n  delete record.acceptedAt;\n  delete record.acceptedVersionId;\n  record.status = \"assembly_ready\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleActiveVersion", "name": "updateChronicleActiveVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update which generation version should be published when accepting.\n */\nexport async function updateChronicleActiveVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before changing versions`);\n  }\n\n  ensureChronicleVersions(record);\n  if (!record.generationHistory?.some((v) => v.versionId === versionId)) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  record.activeVersionId = versionId;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleCombineInstructions", "name": "updateChronicleCombineInstructions", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Manually set or update combine instructions for a chronicle.\n */\nexport async function updateChronicleCombineInstructions(\n  chronicleId: string,\n  combineInstructions: string | undefined\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (combineInstructions) {\n    record.combineInstructions = combineInstructions;\n  } else {\n    delete record.combineInstructions;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "combineInstructions", "type": "string | undefined", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicleVersion", "name": "deleteChronicleVersion", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a specific version from a chronicle's generation history.\n * If the deleted version was the current or active version, switches to the most recent remaining version.\n */\nexport async function deleteChronicleVersion(\n  chronicleId: string,\n  versionId: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  if (record.status === \"complete\" || record.finalContent) {\n    throw new Error(`Chronicle ${chronicleId} is accepted; unpublish before deleting versions`);\n  }\n\n  ensureChronicleVersions(record);\n  const versions = record.generationHistory || [];\n  const matchIndex = versions.findIndex((v) => v.versionId === versionId);\n  if (matchIndex === -1) {\n    throw new Error(`Version ${versionId} not found in chronicle ${chronicleId}`);\n  }\n  if (versions.length <= 1) {\n    throw new Error(`Cannot delete the only version of chronicle ${chronicleId}`);\n  }\n\n  const latest = getLatestVersion(versions);\n  const isCurrentVersion = latest?.versionId === versionId;\n  const remaining = versions.filter((v) => v.versionId !== versionId);\n\n  if (isCurrentVersion) {\n    const nextLatest = getLatestVersion(remaining);\n    if (!nextLatest) {\n      throw new Error(`Cannot delete current version with no history to restore`);\n    }\n    record.assembledContent = nextLatest.content;\n    record.assembledAt = nextLatest.generatedAt;\n    record.model = nextLatest.model || record.model;\n    record.generationSystemPrompt = nextLatest.systemPrompt;\n    record.generationUserPrompt = nextLatest.userPrompt;\n    record.generationSampling = nextLatest.sampling;\n    record.generationStep = nextLatest.step;\n  }\n\n  record.generationHistory = remaining;\n\n  if (record.activeVersionId === versionId) {\n    record.activeVersionId = getLatestVersion(remaining)?.versionId;\n  }\n  if (record.summaryTargetVersionId === versionId) {\n    record.summaryTargetVersionId = record.activeVersionId;\n  }\n  if (record.imageRefsTargetVersionId === versionId) {\n    record.imageRefsTargetVersionId = record.activeVersionId;\n  }\n\n  record.updatedAt = Date.now();\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "versionId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleEntityBackportStatus", "name": "updateChronicleEntityBackportStatus", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Merge per-entity backport status entries into a chronicle's entityBackportStatus map.\n */\nexport async function updateChronicleEntityBackportStatus(\n  chronicleId: string,\n  entries: import(\"../chronicleTypes\").EntityBackportEntry[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  const existing = record.entityBackportStatus || {};\n  for (const entry of entries) {\n    existing[entry.entityId] = entry;\n  }\n  record.entityBackportStatus = existing;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "entries", "type": "import(\"../chronicleTypes\").EntityBackportEntry[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleHistorianNotes", "name": "updateChronicleHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Update historian notes on a chronicle.\n */\nexport async function updateChronicleHistorianNotes(\n  chronicleId: string,\n  historianNotes: HistorianNote[],\n  prompts?: { systemPrompt: string; userPrompt: string },\n  reinforcedFacts?: string[]\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.historianNotes = historianNotes;\n  if (reinforcedFacts) {\n    record.reinforcedFacts = reinforcedFacts;\n  }\n  if (prompts) {\n    record.historianReviewSystemPrompt = prompts.systemPrompt;\n    record.historianReviewUserPrompt = prompts.userPrompt;\n  }\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "historianNotes", "type": "HistorianNote[]", "optional": false}, {"name": "prompts", "type": "{ systemPrompt: string; userPrompt: string }", "optional": true}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::startChronicleValidation", "name": "startChronicleValidation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Start validation step (user approved assembly)\n */\nexport async function startChronicleValidation(chronicleId: string): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.status = \"validating\";\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::batchUpdateChronicleEraYears", "name": "batchUpdateChronicleEraYears", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Read operations\n// ============================================================================\n\n/**\n * Get a chronicle record\n */\n/**\n * Batch update historian-assigned era years for multiple chronicles.\n */\nexport async function batchUpdateChronicleEraYears(\n  assignments: Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>\n): Promise<number> {\n  const ids = assignments.map((a) => a.chronicleId);\n  const records = await db.chronicles.where(\"chronicleId\").anyOf(ids).toArray();\n  const recordMap = new Map(records.map((r) => [r.chronicleId, r]));\n  const now = Date.now();\n\n  const toUpdate: ChronicleRecord[] = [];\n  for (const assignment of assignments) {\n    const record = recordMap.get(assignment.chronicleId);\n    if (!record) continue;\n    record.eraYear = assignment.eraYear;\n    record.eraYearReasoning = assignment.eraYearReasoning;\n    record.updatedAt = now;\n    toUpdate.push(record);\n  }\n\n  if (toUpdate.length > 0) {\n    await db.chronicles.bulkPut(toUpdate);\n  }\n\n  return toUpdate.length;\n}", "parameters": [{"name": "assignments", "type": "Array<{ chronicleId: string; eraYear: number; eraYearReasoning?: string }>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChronicle", "name": "getChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function getChronicle(chronicleId: string): Promise<ChronicleRecord | undefined> {\n  const record = await db.chronicles.get(chronicleId);\n  if (record && ensureChronicleVersions(record)) {\n    await db.chronicles.put(record);\n  }\n  return record;\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getChroniclesForSimulation", "name": "getChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Get all chronicles for a specific simulation run\n */\nexport async function getChroniclesForSimulation(\n  simulationRunId: string\n): Promise<ChronicleRecord[]> {\n  const records = await db.chronicles.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const updates: ChronicleRecord[] = [];\n  for (const record of records) {\n    if (ensureChronicleVersions(record)) {\n      updates.push(record);\n    }\n  }\n  if (updates.length > 0) {\n    await db.chronicles.bulkPut(updates);\n  }\n  return records;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ChronicleRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChronicle", "name": "deleteChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete a chronicle\n */\nexport async function deleteChronicle(chronicleId: string): Promise<void> {\n  await db.chronicles.delete(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::deleteChroniclesForSimulation", "name": "deleteChroniclesForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Delete all chronicles for a simulation run\n */\nexport async function deleteChroniclesForSimulation(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  if (chronicles.length === 0) return 0;\n\n  const ids = chronicles.map((c) => c.chronicleId);\n  await db.chronicles.bulkDelete(ids);\n  return chronicles.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::putChronicle", "name": "putChronicle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Entity Rename Support\n// ============================================================================\n\n/**\n * Write a fully-updated chronicle record back to the database.\n * Used by the entity rename flow to persist chronicle patches.\n */\nexport async function putChronicle(record: ChronicleRecord): Promise<void> {\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "record", "type": "ChronicleRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getEntityUsageStats", "name": "getEntityUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Computed queries\n// ============================================================================\n\n/**\n * Compute entity usage statistics from existing chronicles.\n * Returns a map of entityId -> usage stats.\n */\nexport async function getEntityUsageStats(\n  simulationRunId: string\n): Promise<Map<string, EntityUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, EntityUsageStats>();\n\n  for (const chronicle of chronicles) {\n    // Only count chronicles that have been generated (not just shells)\n    if (chronicle.status === \"generating\") continue;\n\n    for (const entityId of chronicle.selectedEntityIds) {\n      const existing = stats.get(entityId);\n      if (existing) {\n        existing.usageCount += 1;\n        existing.chronicleIds.push(chronicle.chronicleId);\n      } else {\n        stats.set(entityId, {\n          entityId,\n          usageCount: 1,\n          chronicleIds: [chronicle.chronicleId],\n        });\n      }\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, EntityUsageStats>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::getNarrativeStyleUsageStats", "name": "getNarrativeStyleUsageStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Compute narrative style usage statistics from existing chronicles.\n * Returns a map of styleId -> usage stats.\n */\nexport async function getNarrativeStyleUsageStats(\n  simulationRunId: string\n): Promise<Map<string, NarrativeStyleUsageStats>> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const stats = new Map<string, NarrativeStyleUsageStats>();\n\n  for (const chronicle of chronicles) {\n    if (!chronicle.narrativeStyleId) continue;\n\n    const existing = stats.get(chronicle.narrativeStyleId);\n    if (existing) {\n      existing.usageCount += 1;\n      existing.chronicleIds.push(chronicle.chronicleId);\n    } else {\n      stats.set(chronicle.narrativeStyleId, {\n        styleId: chronicle.narrativeStyleId,\n        usageCount: 1,\n        chronicleIds: [chronicle.chronicleId],\n      });\n    }\n  }\n\n  return stats;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<Map<string, NarrativeStyleUsageStats>>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::reconcileBackportStatusFromEntities", "name": "reconcileBackportStatusFromEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function reconcileBackportStatusFromEntities(\n  simulationRunId: string,\n  entities: Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>\n): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const entityBackrefs = buildEntityBackrefIndex(entities);\n  const now = Date.now();\n  const toUpdate: ChronicleRecord[] = [];\n\n  for (const chronicle of chronicles) {\n    const eligibleIds = getEligibleEntityIds(chronicle);\n    const newStatus: Record<string, import(\"../chronicleTypes\").EntityBackportEntry> = {};\n    for (const entityId of eligibleIds) {\n      const backrefSet = entityBackrefs.get(entityId);\n      if (backrefSet && backrefSet.has(chronicle.chronicleId)) {\n        newStatus[entityId] = { entityId, status: \"backported\", updatedAt: now };\n      }\n    }\n\n    if (hasBackportStatusChanged(chronicle.entityBackportStatus || {}, newStatus)) {\n      chronicle.entityBackportStatus = newStatus;\n      chronicle.updatedAt = now;\n      toUpdate.push(chronicle);\n    }\n  }\n\n  if (toUpdate.length > 0) await db.chronicles.bulkPut(toUpdate);\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "Array<{\n    id: string;\n    enrichment?: { chronicleBackrefs?: Array<{ chronicleId: string }> };\n  }>", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::resetAllBackportFlags", "name": "resetAllBackportFlags", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "/**\n * Reset entityBackportStatus on all chronicles in a simulation.\n * Returns the count of chronicles that were updated.\n */\nexport async function resetAllBackportFlags(simulationRunId: string): Promise<number> {\n  const chronicles = await getChroniclesForSimulation(simulationRunId);\n  const toUpdate = chronicles.filter((c) => {\n    const status = c.entityBackportStatus;\n    return status && Object.keys(status).length > 0;\n  });\n\n  if (toUpdate.length === 0) return 0;\n\n  const now = Date.now();\n  await db.chronicles.bulkPut(\n    toUpdate.map((c) => ({\n      ...c,\n      entityBackportStatus: {},\n      updatedAt: now,\n    }))\n  );\n\n  return toUpdate.length;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleToneRanking", "name": "updateChronicleToneRanking", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "// ============================================================================\n// Tone Ranking & Assignment\n// ============================================================================\n\nexport async function updateChronicleToneRanking(\n  chronicleId: string,\n  ranking: [string, string, string],\n  rationale: string,\n  cost?: number,\n  rationales?: Record<string, string>\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.toneRanking = {\n    ranking: ranking as [\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n      import(\"../historianTypes\").HistorianTone,\n    ],\n    rationale,\n    rationales,\n    generatedAt: Date.now(),\n    actualCost: cost,\n  };\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "ranking", "type": "[string, string, string]", "optional": false}, {"name": "rationale", "type": "string", "optional": false}, {"name": "cost", "type": "number", "optional": true}, {"name": "rationales", "type": "Record<string, string>", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts::updateChronicleAssignedTone", "name": "updateChronicleAssignedTone", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleRepository.ts", "sourceCode": "export async function updateChronicleAssignedTone(\n  chronicleId: string,\n  tone: string\n): Promise<void> {\n  const record = await db.chronicles.get(chronicleId);\n  if (!record) throw new Error(`Chronicle ${chronicleId} not found`);\n\n  record.assignedTone = tone as import(\"../historianTypes\").HistorianTone;\n  record.updatedAt = Date.now();\n\n  await db.chronicles.put(record);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}, {"name": "tone", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts::getChronicleFromStore", "name": "getChronicleFromStore", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/chronicleSelectors.ts", "sourceCode": "/**\n * Get a chronicle record imperatively (not a subscription).\n * For use in event handlers and callbacks.\n */\nexport function getChronicleFromStore(chronicleId: string): ChronicleRecord | undefined {\n  return useChronicleStore.getState().cache.get(chronicleId);\n}", "parameters": [{"name": "chronicleId", "type": "string", "optional": false}], "returnType": "ChronicleRecord | undefined"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::loadTree", "name": "loadTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function loadTree(\n  projectId: string,\n  simulationRunId: string\n): Promise<ContentTreeState | null> {\n  const record = await db.contentTrees.get([projectId, simulationRunId]);\n  return record ?? null;\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<ContentTreeState | null>"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::saveTree", "name": "saveTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function saveTree(tree: ContentTreeState): Promise<void> {\n  await db.contentTrees.put(tree);\n}", "parameters": [{"name": "tree", "type": "ContentTreeState", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts::deleteTree", "name": "deleteTree", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/contentTreeRepository.ts", "sourceCode": "export async function deleteTree(projectId: string, simulationRunId: string): Promise<void> {\n  await db.contentTrees.delete([projectId, simulationRunId]);\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::getCoordinateState", "name": "getCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function getCoordinateState(\n  simulationRunId: string\n): Promise<CoordinateStateRecord | undefined> {\n  return db.coordinateStates.get(simulationRunId);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CoordinateStateRecord | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts::upsertCoordinateState", "name": "upsertCoordinateState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/coordinateStateRepository.ts", "sourceCode": "export async function upsertCoordinateState(\n  simulationRunId: string,\n  coordinateState: CoordinateState\n): Promise<void> {\n  await db.coordinateStates.put({\n    simulationRunId,\n    coordinateState,\n    updatedAt: Date.now(),\n  });\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "coordinateState", "type": "CoordinateState", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::generateCostId", "name": "generateCostId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function generateCostId(): string {\n  return `cost_${Date.now()}_${crypto.randomUUID().slice(0, 9)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::createCostRecord", "name": "createCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function createCostRecord(input: CostRecordInput): CostRecord {\n  return {\n    id: input.id ?? generateCostId(),\n    timestamp: input.timestamp ?? Date.now(),\n    projectId: input.projectId,\n    simulationRunId: input.simulationRunId,\n    entityId: input.entityId,\n    entityName: input.entityName,\n    entityKind: input.entityKind,\n    chronicleId: input.chronicleId,\n    type: input.type,\n    model: input.model,\n    estimatedCost: input.estimatedCost,\n    actualCost: input.actualCost,\n    inputTokens: input.inputTokens,\n    outputTokens: input.outputTokens,\n  };\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "CostRecord"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecord", "name": "saveCostRecord", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecord(record: CostRecord): Promise<void> {\n  console.debug(`${LOG_PREFIX} Save start`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n  await db.costs.put(record);\n  console.debug(`${LOG_PREFIX} Save complete`, {\n    id: record.id,\n    type: record.type,\n    model: record.model,\n  });\n}", "parameters": [{"name": "record", "type": "CostRecord", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::saveCostRecordWithDefaults", "name": "saveCostRecordWithDefaults", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function saveCostRecordWithDefaults(input: CostRecordInput): Promise<void> {\n  return saveCostRecord(createCostRecord(input));\n}", "parameters": [{"name": "input", "type": "CostRecordInput", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForProject", "name": "getCostsForProject", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForProject(projectId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"projectId\").equals(projectId).toArray();\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsForSimulation", "name": "getCostsForSimulation", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsForSimulation(simulationRunId: string): Promise<CostRecord[]> {\n  return db.costs.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getAllCosts", "name": "getAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getAllCosts(): Promise<CostRecord[]> {\n  return db.costs.toArray();\n}", "parameters": [], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostsInRange", "name": "getCostsInRange", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostsInRange(startTime: number, endTime: number): Promise<CostRecord[]> {\n  return db.costs.where(\"timestamp\").between(startTime, endTime, true, true).toArray();\n}", "parameters": [{"name": "startTime", "type": "number", "optional": false}, {"name": "endTime", "type": "number", "optional": false}], "returnType": "Promise<CostRecord[]>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::summarizeCosts", "name": "summarizeCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export function summarizeCosts(records: CostRecord[]): CostSummary {\n  const summary: CostSummary = {\n    totalEstimated: 0,\n    totalActual: 0,\n    count: records.length,\n    byType: {} as Record<CostType, { estimated: number; actual: number; count: number }>,\n    byModel: {},\n  };\n\n  for (const record of records) {\n    summary.totalEstimated += record.estimatedCost;\n    summary.totalActual += record.actualCost;\n\n    if (!summary.byType[record.type]) {\n      summary.byType[record.type] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byType[record.type].estimated += record.estimatedCost;\n    summary.byType[record.type].actual += record.actualCost;\n    summary.byType[record.type].count++;\n\n    if (!summary.byModel[record.model]) {\n      summary.byModel[record.model] = { estimated: 0, actual: 0, count: 0 };\n    }\n    summary.byModel[record.model].estimated += record.estimatedCost;\n    summary.byModel[record.model].actual += record.actualCost;\n    summary.byModel[record.model].count++;\n  }\n\n  return summary;\n}", "parameters": [{"name": "records", "type": "CostRecord[]", "optional": false}], "returnType": "CostSummary"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::clearAllCosts", "name": "clearAllCosts", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function clearAllCosts(): Promise<void> {\n  await db.costs.clear();\n}", "parameters": [], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/costRepository.ts::getCostCount", "name": "getCostCount", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/costRepository.ts", "sourceCode": "export async function getCostCount(): Promise<number> {\n  return db.costs.count();\n}", "parameters": [], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::generateRunId", "name": "generateRunId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export function generateRunId(): string {\n  return `dynrun_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::createDynamicsRun", "name": "createDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function createDynamicsRun(\n  runId: string,\n  projectId: string,\n  simulationRunId: string\n): Promise<DynamicsRun> {\n  const now = Date.now();\n\n  const run: DynamicsRun = {\n    runId,\n    projectId,\n    simulationRunId,\n    status: \"pending\",\n    messages: [],\n    totalInputTokens: 0,\n    totalOutputTokens: 0,\n    totalActualCost: 0,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "projectId", "type": "string", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::getDynamicsRun", "name": "getDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function getDynamicsRun(runId: string): Promise<DynamicsRun | undefined> {\n  return db.dynamicsRuns.get(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<DynamicsRun | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::updateDynamicsRun", "name": "updateDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function updateDynamicsRun(\n  runId: string,\n  updates: Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >\n): Promise<DynamicsRun> {\n  const run = await db.dynamicsRuns.get(runId);\n  if (!run) throw new Error(`Dynamics run ${runId} not found`);\n\n  if (updates.status !== undefined) run.status = updates.status;\n  if (updates.messages !== undefined) run.messages = updates.messages;\n  if (updates.proposedDynamics !== undefined) run.proposedDynamics = updates.proposedDynamics;\n  if (updates.userFeedback !== undefined) run.userFeedback = updates.userFeedback;\n  if (updates.error !== undefined) run.error = updates.error;\n  if (updates.totalInputTokens !== undefined) run.totalInputTokens = updates.totalInputTokens;\n  if (updates.totalOutputTokens !== undefined) run.totalOutputTokens = updates.totalOutputTokens;\n  if (updates.totalActualCost !== undefined) run.totalActualCost = updates.totalActualCost;\n  run.updatedAt = Date.now();\n\n  await db.dynamicsRuns.put(run);\n  return run;\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}, {"name": "updates", "type": "Partial<\n    Pick<\n      DynamicsRun,\n      | \"status\"\n      | \"messages\"\n      | \"proposedDynamics\"\n      | \"userFeedback\"\n      | \"error\"\n      | \"totalInputTokens\"\n      | \"totalOutputTokens\"\n      | \"totalActualCost\"\n    >\n  >", "optional": false}], "returnType": "Promise<DynamicsRun>"}, {"id": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts::deleteDynamicsRun", "name": "deleteDynamicsRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/dynamicsRepository.ts", "sourceCode": "export async function deleteDynamicsRun(runId: string): Promise<void> {\n  await db.dynamicsRuns.delete(runId);\n}", "parameters": [{"name": "runId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::registerQueue", "name": "registerQueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "/**\n * Called by IlluminatorRemote to register the enrichment queue functions.\n */\nexport function registerQueue(enqueue: EnqueueFn, cancel: CancelFn): void {\n  _enqueue = enqueue;\n  _cancel = cancel;\n}", "parameters": [{"name": "enqueue", "type": "EnqueueFn", "optional": false}, {"name": "cancel", "type": "CancelFn", "optional": false}], "returnType": "void"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getEnqueue", "name": "getEnqueue", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getEnqueue(): EnqueueFn {\n  if (!_enqueue) {\n    throw new Error(\"registerQueue must be called before getEnqueue\");\n  }\n  return _enqueue;\n}", "parameters": [], "returnType": "EnqueueFn"}, {"id": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts::getCancel", "name": "getCancel", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/enrichmentQueueBridge.ts", "sourceCode": "export function getCancel(): CancelFn {\n  if (!_cancel) {\n    throw new Error(\"registerQueue must be called before getCancel\");\n  }\n  return _cancel;\n}", "parameters": [], "returnType": "CancelFn"}, {"id": "apps/illuminator/webui/src/lib/db/entityNav.ts::buildEntityNavItem", "name": "buildEntityNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityNav.ts", "sourceCode": "export function buildEntityNavItem(entity: PersistedEntity): EntityNavItem {\n  const backrefs = entity.enrichment?.chronicleBackrefs || [];\n  return {\n    id: entity.id,\n    name: entity.name,\n    kind: entity.kind,\n    subtype: entity.subtype,\n    prominence: entity.prominence,\n    culture: entity.culture,\n    status: entity.status,\n    summary: entity.summary,\n    eraId: entity.eraId,\n    hasDescription: !!(entity.summary && entity.description),\n    hasVisualThesis: !!entity.enrichment?.text?.visualThesis,\n    imageId: entity.enrichment?.image?.imageId,\n    descriptionCost: entity.enrichment?.text?.actualCost,\n    imageCost: entity.enrichment?.image?.actualCost,\n    aliases: entity.enrichment?.text?.aliases || [],\n    slugAliases: entity.enrichment?.slugAliases || [],\n    backrefCount: backrefs.length,\n    unconfiguredBackrefCount: backrefs.filter(\n      (b: { imageSource?: unknown }) => b.imageSource === undefined\n    ).length,\n    isManual: entity.id.startsWith(\"manual_\"),\n    lockedSummary: !!entity.lockedSummary,\n    hasHistorianNotes: (entity.enrichment?.historianNotes?.length ?? 0) > 0,\n    hasHistorianEdition: (entity.enrichment?.descriptionHistory || []).some(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ),\n    historianEditionCount: (entity.enrichment?.descriptionHistory || []).filter(\n      (h: { source?: string }) => h.source === \"historian-edition\"\n    ).length,\n    descriptionWordCount: entity.description ? entity.description.split(/\\s+/).length : 0,\n  };\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}], "returnType": "EntityNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::isSeeded", "name": "isSeeded", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Seed (Phase 1 bridge \u2014 replaced by Lore Weave write in future)\n// ---------------------------------------------------------------------------\n\n/**\n * Check whether entities have already been seeded for this simulation run.\n */\nexport async function isSeeded(simulationRunId: string): Promise<boolean> {\n  const count = await db.entities.where(\"simulationRunId\").equals(simulationRunId).count();\n  return count > 0;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<boolean>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::seedEntities", "name": "seedEntities", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-write entities from worldData.hardState into Dexie.\n * Stamps each record with simulationRunId. Skips if already seeded.\n */\nexport async function seedEntities(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<void> {\n  const records: PersistedEntity[] = entities.map((e) => ({\n    ...e,\n    simulationRunId,\n  }));\n  await db.entities.bulkPut(records);\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::createEntity", "name": "createEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Manual Creation\n// ---------------------------------------------------------------------------\n\n/**\n * Create a single entity manually. Generates a collision-safe ID\n * with a `manual_` prefix.\n */\nexport async function createEntity(\n  simulationRunId: string,\n  entity: Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<PersistedEntity> {\n  if (!simulationRunId) {\n    throw new Error(\"simulationRunId is required to create an entity\");\n  }\n  const now = Date.now();\n  const id = `manual_${entity.kind}_${now}_${crypto.randomUUID().slice(0, 8)}`;\n  const record: PersistedEntity = {\n    ...entity,\n    id,\n    createdAt: now,\n    updatedAt: now,\n    simulationRunId,\n  };\n  await db.entities.put(record);\n  return record;\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entity", "type": "Omit<WorldEntity, \"id\" | \"createdAt\" | \"updatedAt\">", "optional": false}], "returnType": "Promise<PersistedEntity>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntity", "name": "deleteEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function deleteEntity(entityId: string): Promise<void> {\n  if (!entityId.startsWith(\"manual_\")) {\n    throw new Error(\"Only manually-created entities can be deleted\");\n  }\n  await db.entities.delete(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::patchEntitiesFromHardState", "name": "patchEntitiesFromHardState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Patch entities from hard state without overwriting existing values.\n * - Inserts missing entities\n * - For existing entities, fills only undefined/null fields (keeps enrichment intact)\n */\nexport async function patchEntitiesFromHardState(\n  simulationRunId: string,\n  entities: WorldEntity[]\n): Promise<{ added: number; patched: number }> {\n  if (!entities?.length) return { added: 0, patched: 0 };\n\n  const existing = await db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n  const existingById = new Map(existing.map((e) => [e.id, e]));\n  let added = 0;\n  let patched = 0;\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const worldEntity of entities) {\n      const current = existingById.get(worldEntity.id);\n      if (!current) {\n        await db.entities.put({ ...worldEntity, simulationRunId });\n        added += 1;\n        continue;\n      }\n\n      const updates: Partial<PersistedEntity> = {};\n      for (const [key, value] of Object.entries(worldEntity)) {\n        if (key === \"enrichment\") continue;\n        if (value === undefined || value === null) continue;\n        const currentValue = (current as any)[key];\n        if (currentValue === undefined || currentValue === null) {\n          (updates as any)[key] = value;\n        }\n      }\n\n      if (Object.keys(updates).length > 0) {\n        await db.entities.update(current.id, updates);\n        patched += 1;\n      }\n    }\n  });\n\n  return { added, patched };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entities", "type": "WorldEntity[]", "optional": false}], "returnType": "Promise<{ added: number; patched: number }>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntity", "name": "getEntity", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Reads\n// ---------------------------------------------------------------------------\n\nexport async function getEntity(entityId: string): Promise<PersistedEntity | undefined> {\n  return db.entities.get(entityId);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity | undefined>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByIds", "name": "getEntitiesByIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByIds(entityIds: string[]): Promise<PersistedEntity[]> {\n  const results = await db.entities.bulkGet(entityIds);\n  return results.filter((e): e is PersistedEntity => e !== undefined);\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesForRun", "name": "getEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesForRun(simulationRunId: string): Promise<PersistedEntity[]> {\n  return db.entities.where(\"simulationRunId\").equals(simulationRunId).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntityIdsForRun", "name": "getEntityIdsForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntityIdsForRun(simulationRunId: string): Promise<string[]> {\n  const ids = await db.entities.where(\"simulationRunId\").equals(simulationRunId).primaryKeys();\n  return ids.map((id) => String(id));\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::getEntitiesByKind", "name": "getEntitiesByKind", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function getEntitiesByKind(\n  simulationRunId: string,\n  kind: string\n): Promise<PersistedEntity[]> {\n  return db.entities.where(\"[simulationRunId+kind]\").equals([simulationRunId, kind]).toArray();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}], "returnType": "Promise<PersistedEntity[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityField", "name": "updateEntityField", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Single-field updates\n// ---------------------------------------------------------------------------\n\nexport async function updateEntityField(\n  entityId: string,\n  field: string,\n  value: unknown\n): Promise<void> {\n  await db.entities.update(entityId, { [field]: value });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "field", "type": "string", "optional": false}, {"name": "value", "type": "unknown", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateEntityFields", "name": "updateEntityFields", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function updateEntityFields(\n  entityId: string,\n  fields: Partial<PersistedEntity>\n): Promise<void> {\n  await db.entities.update(entityId, fields);\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "fields", "type": "Partial<PersistedEntity>", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRename", "name": "applyRename", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function applyRename(\n  targetEntityId: string | null,\n  newName: string,\n  entityPatches: EntityPatch[],\n  simulationRunId: string,\n  addOldNameAsAlias?: boolean\n): Promise<string[]> {\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    if (targetEntityId) {\n      await renameTargetEntity(targetEntityId, newName, addOldNameAsAlias, updatedIds);\n    }\n\n    for (const patch of entityPatches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let changed = false;\n      const updates: Partial<PersistedEntity> = {};\n\n      for (const [key, value] of Object.entries(patch.changes)) {\n        if (!key.startsWith(\"__replacements_\")) continue;\n        const field = key.replace(\"__replacements_\", \"\");\n        const replacements: FieldReplacement[] = JSON.parse(value);\n        if (applyFieldReplacement(field, replacements, entity, updates)) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        await db.entities.update(patch.entityId, updates);\n        if (!updatedIds.includes(patch.entityId)) updatedIds.push(patch.entityId);\n      }\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "targetEntityId", "type": "string | null", "optional": false}, {"name": "newName", "type": "string", "optional": false}, {"name": "entityPatches", "type": "EntityPatch[]", "optional": false}, {"name": "simulationRunId", "type": "string", "optional": false}, {"name": "addOldNameAsAlias", "type": "boolean", "optional": true}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyDescriptionResult", "name": "applyDescriptionResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Worker enrichment results\n// ---------------------------------------------------------------------------\n\n/**\n * Apply a description enrichment result from the worker.\n * Pushes current description to history if overwriting, merges enrichment.text.\n */\nexport async function applyDescriptionResult(\n  entityId: string,\n  enrichment: Partial<EntityEnrichment>,\n  summary?: string | null,\n  description?: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    // Push description history if overwriting an existing description\n    let baseEnrichment = entity.enrichment || {};\n    if (description !== undefined && entity.description) {\n      const history = [...(baseEnrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"description-task\",\n      });\n      baseEnrichment = { ...baseEnrichment, descriptionHistory: history };\n    }\n\n    const updates: Partial<PersistedEntity> = {\n      enrichment: { ...baseEnrichment, ...enrichment },\n    };\n    if (summary !== undefined) updates.summary = summary ?? undefined;\n    if (description !== undefined) updates.description = description;\n\n    await db.entities.update(entityId, updates);\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "enrichment", "type": "Partial<EntityEnrichment>", "optional": false}, {"name": "summary", "type": "string | null", "optional": true}, {"name": "description", "type": "string", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyVisualThesisResult", "name": "applyVisualThesisResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply a visual thesis result \u2014 updates only visual fields on enrichment.text,\n * preserving existing aliases, description, and summary.\n */\nexport async function applyVisualThesisResult(\n  entityId: string,\n  visualThesis: string,\n  visualTraits: string[],\n  meta: {\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const existingText = entity.enrichment?.text;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        text: {\n          aliases: existingText?.aliases || [],\n          visualThesis,\n          visualTraits,\n          generatedAt: meta.generatedAt,\n          model: meta.model,\n          estimatedCost: meta.estimatedCost,\n          actualCost: meta.actualCost,\n          inputTokens: meta.inputTokens,\n          outputTokens: meta.outputTokens,\n          chainDebug: meta.chainDebug,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "visualThesis", "type": "string", "optional": false}, {"name": "visualTraits", "type": "string[]", "optional": false}, {"name": "meta", "type": "{\n    generatedAt: number;\n    model: string;\n    estimatedCost?: number;\n    actualCost?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n    chainDebug?: DescriptionChainDebug;\n  }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyImageResult", "name": "applyImageResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an image enrichment result from the worker.\n */\nexport async function applyImageResult(\n  entityId: string,\n  imageEnrichment: EntityEnrichment[\"image\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, image: imageEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageEnrichment", "type": "EntityEnrichment[\"image\"]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyEntityChronicleResult", "name": "applyEntityChronicleResult", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply an entity chronicle enrichment result from the worker.\n */\nexport async function applyEntityChronicleResult(\n  entityId: string,\n  chronicleEnrichment: EntityEnrichment[\"entityChronicle\"]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, entityChronicle: chronicleEnrichment },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "chronicleEnrichment", "type": "EntityEnrichment[\"entityChronicle\"]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::assignImage", "name": "assignImage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// User actions\n// ---------------------------------------------------------------------------\n\n/**\n * Assign an existing library image to an entity.\n */\nexport async function assignImage(\n  entityId: string,\n  imageId: string,\n  imageMetadata?: { generatedAt?: number; model?: string; revisedPrompt?: string }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: {\n        ...entity.enrichment,\n        image: {\n          imageId,\n          generatedAt: imageMetadata?.generatedAt || Date.now(),\n          model: imageMetadata?.model || \"assigned\",\n          revisedPrompt: imageMetadata?.revisedPrompt,\n          estimatedCost: 0,\n          actualCost: 0,\n        },\n      },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "imageId", "type": "string", "optional": false}, {"name": "imageMetadata", "type": "{ generatedAt?: number; model?: string; revisedPrompt?: string }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateDescriptionManual", "name": "updateDescriptionManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's description. Pushes current description to history\n * with source 'manual', bumps text.generatedAt to prevent enrichment overwrites.\n */\nexport async function updateDescriptionManual(\n  entityId: string,\n  description: string\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n\n    let enrichment = entity.enrichment || {};\n\n    // Push current description to history\n    if (entity.description) {\n      const history = [...(enrichment.descriptionHistory || [])];\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"manual\",\n      });\n      enrichment = { ...enrichment, descriptionHistory: history };\n    }\n\n    // Bump text.generatedAt so enrichment workers won't overwrite\n    if (enrichment.text) {\n      enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n    }\n\n    await db.entities.update(entityId, { description, enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "description", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateSummaryManual", "name": "updateSummaryManual", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Manually update an entity's summary. Sets lockedSummary to prevent enrichment overwrites.\n */\nexport async function updateSummaryManual(entityId: string, summary: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, { summary, lockedSummary: true });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "summary", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::undoDescription", "name": "undoDescription", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Undo the last description change by popping from descriptionHistory.\n */\nexport async function undoDescription(entityId: string): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (history.length === 0) return;\n    const previous = history.pop();\n    await db.entities.update(entityId, {\n      description: previous.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::restoreDescriptionFromHistory", "name": "restoreDescriptionFromHistory", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Restore a specific description history entry as the active description.\n * The current description is pushed to history before the swap.\n */\nexport async function restoreDescriptionFromHistory(\n  entityId: string,\n  historyIndex: number\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const history = [...(entity.enrichment?.descriptionHistory || [])];\n    if (historyIndex < 0 || historyIndex >= history.length) return;\n\n    const selected = history[historyIndex];\n\n    // Push current description to history\n    if (entity.description) {\n      history.push({\n        description: entity.description,\n        replacedAt: Date.now(),\n        source: \"version-restore\",\n      });\n    }\n\n    // Remove the selected entry from history\n    history.splice(historyIndex, 1);\n\n    await db.entities.update(entityId, {\n      description: selected.description,\n      enrichment: { ...entity.enrichment, descriptionHistory: history },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "historyIndex", "type": "number", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateBackrefs", "name": "updateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Set chronicle backrefs on an entity.\n */\nexport async function updateBackrefs(\n  entityId: string,\n  backrefs: NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "backrefs", "type": "NonNullable<EntityEnrichment[\"chronicleBackrefs\"]>", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::updateAliases", "name": "updateAliases", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Aliases\n// ---------------------------------------------------------------------------\n\n/**\n * Update the text aliases on an entity.\n */\nexport async function updateAliases(entityId: string, aliases: string[]): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const text = entity.enrichment?.text || {\n      aliases: [],\n      visualTraits: [],\n      generatedAt: 0,\n      model: \"\",\n    };\n    await db.entities.update(entityId, {\n      enrichment: { ...entity.enrichment, text: { ...text, aliases } },\n    });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "aliases", "type": "string[]", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::applyRevisionPatches", "name": "applyRevisionPatches", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Apply revision patches from summary revision, lore backport, or copy-edit.\n * Pushes descriptionHistory, bumps text.generatedAt. Returns updated entity IDs.\n */\nexport async function applyRevisionPatches(\n  patches: RevisionPatch[],\n  source: string\n): Promise<string[]> {\n  if (!patches?.length) return [];\n  const updatedIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      let enrichment = entity.enrichment || {};\n\n      // Push description history if overwriting\n      if (patch.description !== undefined && entity.description) {\n        const history = [...(enrichment.descriptionHistory || [])];\n        history.push({\n          description: entity.description,\n          replacedAt: Date.now(),\n          source,\n        });\n        enrichment = { ...enrichment, descriptionHistory: history };\n      }\n\n      // Bump text.generatedAt so stale persisted data won't overwrite\n      if (patch.description !== undefined && enrichment.text) {\n        enrichment = { ...enrichment, text: { ...enrichment.text, generatedAt: Date.now() } };\n      }\n\n      const updates: Partial<PersistedEntity> = { enrichment };\n      if (patch.summary !== undefined) updates.summary = patch.summary;\n      if (patch.description !== undefined) updates.description = patch.description;\n\n      await db.entities.update(patch.entityId, updates);\n      updatedIds.push(patch.entityId);\n    }\n  });\n\n  return updatedIds;\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "source", "type": "string", "optional": false}], "returnType": "Promise<string[]>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::revalidateBackrefs", "name": "revalidateBackrefs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "export async function revalidateBackrefs(\n  patches: RevisionPatch[],\n  options?: {\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const patch of patches) {\n      if (!patch.description && !options?.chronicleId) continue;\n\n      const entity = await db.entities.get(patch.entityId);\n      if (!entity) continue;\n\n      const desc = patch.description || entity.description || \"\";\n      let backrefs = [...(entity.enrichment?.chronicleBackrefs || [])];\n      if (backrefs.length === 0 && !patch.anchorPhrase) continue;\n\n      if (patch.description && backrefs.length > 0) {\n        backrefs = backrefs.map((br) =>\n          reResolveBackref(br, desc, entity.description, Boolean(options?.fuzzyFallback))\n        );\n      }\n\n      if (options?.chronicleId && patch.anchorPhrase) {\n        upsertBackref(backrefs, options.chronicleId, patch.anchorPhrase, desc, entity.id);\n      }\n\n      await db.entities.update(patch.entityId, {\n        enrichment: { ...entity.enrichment, chronicleBackrefs: backrefs },\n      });\n    }\n  });\n}", "parameters": [{"name": "patches", "type": "RevisionPatch[]", "optional": false}, {"name": "options", "type": "{\n    chronicleId?: string;\n    fuzzyFallback?: boolean;\n  }", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::setHistorianNotes", "name": "setHistorianNotes", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Historian\n// ---------------------------------------------------------------------------\n\n/**\n * Set historian notes on an entity.\n */\nexport async function setHistorianNotes(\n  entityId: string,\n  notes: NonNullable<EntityEnrichment[\"historianNotes\"]>,\n  reinforcedFacts?: string[]\n): Promise<void> {\n  await db.transaction(\"rw\", db.entities, async () => {\n    const entity = await db.entities.get(entityId);\n    if (!entity) return;\n    const enrichment = { ...entity.enrichment, historianNotes: notes };\n    if (reinforcedFacts) {\n      enrichment.reinforcedFacts = reinforcedFacts;\n    }\n    await db.entities.update(entityId, { enrichment });\n  });\n}", "parameters": [{"name": "entityId", "type": "string", "optional": false}, {"name": "notes", "type": "NonNullable<EntityEnrichment[\"historianNotes\"]>", "optional": false}, {"name": "reinforcedFacts", "type": "string[]", "optional": true}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::resetEntitiesToPreBackportState", "name": "resetEntitiesToPreBackportState", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Backport Reset\n// ---------------------------------------------------------------------------\n\n/**\n * Reset entity descriptions to their pre-backport state.\n * Optionally accepts an entity list to ensure reset covers entities not yet persisted in Dexie.\n * For each entity that has lore-backport entries in descriptionHistory:\n * - Find the first 'lore-backport' entry\n * - Restore the description from that entry (which is the pre-backport state)\n * - Truncate history to remove all entries from that point onward\n * - Clear chronicleBackrefs (these were set by backport operations)\n *\n * Returns count of entities that were reset.\n */\nexport async function resetEntitiesToPreBackportState(\n  simulationRunId: string,\n  entitiesOverride?: PersistedEntity[]\n): Promise<{ resetCount: number; entityIds: string[] }> {\n  const entities = entitiesOverride?.length\n    ? entitiesOverride\n    : await getEntitiesForRun(simulationRunId);\n  const resetEntityIds: string[] = [];\n\n  await db.transaction(\"rw\", db.entities, async () => {\n    const existing = await db.entities.bulkGet(entities.map((entity) => entity.id));\n    const existingIds = new Set(existing.filter(Boolean).map((entity) => entity.id));\n\n    for (const entity of entities) {\n      const history = entity.enrichment?.descriptionHistory || [];\n      if (history.length === 0) continue;\n\n      // Find the first 'lore-backport' entry\n      const firstBackportIndex = history.findIndex((h) => h.source === \"lore-backport\");\n      if (firstBackportIndex === -1) continue; // Never backported\n\n      // The description in that entry is the pre-backport state\n      const preBackportDescription = history[firstBackportIndex].description;\n\n      // Truncate history to remove entries from the first backport onward\n      const newHistory = history.slice(0, firstBackportIndex);\n\n      // Clear chronicleBackrefs since those were set by backport\n      const newEnrichment = {\n        ...entity.enrichment,\n        descriptionHistory: newHistory,\n        chronicleBackrefs: [],\n      };\n\n      const updates = {\n        description: preBackportDescription,\n        enrichment: newEnrichment,\n      };\n\n      if (existingIds.has(entity.id)) {\n        await db.entities.update(entity.id, updates);\n      } else {\n        await db.entities.put({\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n          ...updates,\n        });\n      }\n\n      resetEntityIds.push(entity.id);\n    }\n  });\n\n  return {\n    resetCount: resetEntityIds.length,\n    entityIds: resetEntityIds,\n  };\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}, {"name": "entitiesOverride", "type": "PersistedEntity[]", "optional": true}], "returnType": "Promise<{ resetCount: number; entityIds: string[] }>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::deleteEntitiesForRun", "name": "deleteEntitiesForRun", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "// ---------------------------------------------------------------------------\n// Cleanup\n// ---------------------------------------------------------------------------\n\nexport async function deleteEntitiesForRun(simulationRunId: string): Promise<void> {\n  await db.entities.where(\"simulationRunId\").equals(simulationRunId).delete();\n}", "parameters": [{"name": "simulationRunId", "type": "string", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/illuminator/webui/src/lib/db/entityRepository.ts::convertLongEditionsToLegacy", "name": "convertLongEditionsToLegacy", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/entityRepository.ts", "sourceCode": "/**\n * Bulk-convert all historian-edition history entries to 'legacy-copy-edit' source.\n * Clears the historian-edition slate so entities can go through a fresh edition cycle.\n *\n * Returns the count of entities modified.\n */\nexport async function convertLongEditionsToLegacy(entityIds: string[]): Promise<number> {\n  let modified = 0;\n  await db.transaction(\"rw\", db.entities, async () => {\n    for (const entityId of entityIds) {\n      const entity = await db.entities.get(entityId);\n      if (!entity) continue;\n\n      const history = [...(entity.enrichment?.descriptionHistory || [])];\n      let changed = false;\n      for (let i = 0; i < history.length; i++) {\n        if (history[i].source === \"historian-edition\") {\n          history[i] = { ...history[i], source: \"legacy-copy-edit\" };\n          changed = true;\n        }\n      }\n\n      if (!changed) continue;\n\n      await db.entities.update(entityId, {\n        enrichment: { ...entity.enrichment, descriptionHistory: history },\n      });\n      modified++;\n    }\n  });\n  return modified;\n}", "parameters": [{"name": "entityIds", "type": "string[]", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts::buildEraNarrativeNavItem", "name": "buildEraNarrativeNavItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeNav.ts", "sourceCode": "export function buildEraNarrativeNavItem(\n  record: EraNarrativeRecord,\n  eraOrder?: number\n): EraNarrativeNavItem {\n  const wordCount = record.narrative?.editedWordCount ?? record.narrative?.wordCount ?? 0;\n\n  return {\n    id: `eranarr:${record.narrativeId}`,\n    narrativeId: record.narrativeId,\n    itemType: \"era_narrative\",\n    name: record.eraName,\n    eraName: record.eraName,\n    eraId: record.eraId,\n    status: record.status,\n    tone: record.tone,\n    currentStep: record.currentStep,\n    wordCount,\n    totalActualCost: record.totalActualCost,\n    threadCount: record.threadSynthesis?.threads?.length ?? 0,\n    movementCount: record.threadSynthesis?.movements?.length ?? 0,\n    hasThesis: !!record.threadSynthesis?.thesis,\n    createdAt: record.createdAt,\n    updatedAt: record.updatedAt,\n    focalEraName: record.eraName,\n    focalEraOrder: eraOrder,\n    eraYear: undefined,\n  };\n}", "parameters": [{"name": "record", "type": "EraNarrativeRecord", "optional": false}, {"name": "eraOrder", "type": "number", "optional": true}], "returnType": "EraNarrativeNavItem"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateEraNarrativeId", "name": "generateEraNarrativeId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateEraNarrativeId(): string {\n  return `eranarr_${Date.now()}_${crypto.randomUUID().slice(0, 8)}`;\n}", "parameters": [], "returnType": "string"}, {"id": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts::generateVersionId", "name": "generateVersionId", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/db/eraNarrativeRepository.ts", "sourceCode": "export function generateVersionId(): string {\n  return `enver_${Date.now()}_${crypto.randomUUID().slice(0, 6)}`;\n}", "parameters": [], "returnType": "string"}]