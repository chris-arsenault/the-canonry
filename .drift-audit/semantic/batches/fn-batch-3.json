[{"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::findNode", "name": "findNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function findNode(state: ContentTreeState, nodeId: string): ContentTreeNode | null {\n  return findInNodes(state.nodes, nodeId);\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeNode | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addFolder", "name": "addFolder", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Mutations\n// =============================================================================\n\nexport function addFolder(\n  state: ContentTreeState,\n  parentId: string,\n  name: string\n): ContentTreeState {\n  const newFolder: ContentTreeNode = {\n    id: generateId(),\n    name,\n    type: \"folder\",\n    children: [],\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newFolder, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::renameNode", "name": "renameNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function renameNode(\n  state: ContentTreeState,\n  nodeId: string,\n  name: string\n): ContentTreeState {\n  return {\n    ...state,\n    nodes: mapNodes(state.nodes, (node) => (node.id === nodeId ? { ...node, name } : { ...node })),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::deleteNode", "name": "deleteNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function deleteNode(state: ContentTreeState, nodeId: string): ContentTreeState {\n  return {\n    ...state,\n    nodes: removeNode(state.nodes, nodeId),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::moveNode", "name": "moveNode", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function moveNode(\n  state: ContentTreeState,\n  nodeId: string,\n  targetParentId: string,\n  index: number\n): ContentTreeState {\n  const node = findInNodes(state.nodes, nodeId);\n  if (!node) return state;\n\n  const withRemoved = removeNode(state.nodes, nodeId);\n  const withInserted = insertIntoParent(withRemoved, targetParentId, { ...node }, index);\n\n  return {\n    ...state,\n    nodes: withInserted,\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "nodeId", "type": "string", "optional": false}, {"name": "targetParentId", "type": "string", "optional": false}, {"name": "index", "type": "number", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::addContentItem", "name": "addContentItem", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function addContentItem(\n  state: ContentTreeState,\n  parentId: string,\n  item: { type: ContentNodeType; contentId: string; name: string }\n): ContentTreeState {\n  const newNode: ContentTreeNode = {\n    id: generateId(),\n    name: item.name,\n    type: item.type,\n    contentId: item.contentId,\n  };\n\n  return {\n    ...state,\n    nodes: insertIntoParent(state.nodes, parentId, newNode, Infinity),\n    updatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "parentId", "type": "string", "optional": false}, {"name": "item", "type": "{ type: ContentNodeType; contentId: string; name: string }", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::flattenForExport", "name": "flattenForExport", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "export function flattenForExport(state: ContentTreeState): FlattenedNode[] {\n  const result: FlattenedNode[] = [];\n\n  function walk(nodes: ContentTreeNode[], parentPath: string, depth: number) {\n    nodes.forEach((node, index) => {\n      const prefix = String(index + 1).padStart(2, \"0\");\n      const segment = `${prefix}-${slugify(node.name)}`;\n      const path = parentPath ? `${parentPath}/${segment}` : segment;\n      result.push({ path, node, depth, index });\n      if (node.children) {\n        walk(node.children, path, depth + 1);\n      }\n    });\n  }\n\n  walk(state.nodes, \"\", 0);\n  return result;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "FlattenedNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::getAllContentIds", "name": "getAllContentIds", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "// =============================================================================\n// Content ID Lookup\n// =============================================================================\n\nexport function getAllContentIds(state: ContentTreeState): Set<string> {\n  const ids = new Set<string>();\n  function walk(nodes: ContentTreeNode[]) {\n    for (const node of nodes) {\n      if (node.contentId) ids.add(node.contentId);\n      if (node.children) walk(node.children);\n    }\n  }\n  walk(state.nodes);\n  return ids;\n}", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}], "returnType": "Set<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::toArboristData", "name": "toArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Convert tree data to react-arborist format.\n * react-arborist expects { id, name, children } with children as arrays.\n */\nexport function toArboristData(nodes: ContentTreeNode[]): ContentTreeNode[] {\n  return nodes.map((node) => ({\n    ...node,\n    children: node.type === \"folder\" ? toArboristData(node.children || []) : undefined,\n  }));\n}", "parameters": [{"name": "nodes", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::fromArboristData", "name": "fromArboristData", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Rebuild ContentTreeNode[] from react-arborist's output after a move/reorder.\n */\nexport function fromArboristData(data: ContentTreeNode[]): ContentTreeNode[] {\n  return data.map((node) => ({\n    ...node,\n    children: node.children ? fromArboristData(node.children) : undefined,\n  }));\n}", "parameters": [{"name": "data", "type": "ContentTreeNode[]", "optional": false}], "returnType": "ContentTreeNode[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/contentTree.ts::autoPopulateBody", "name": "autoPopulateBody", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/contentTree.ts", "sourceCode": "/**\n * Auto-populate the tree with content in Chronicler's natural book order.\n *\n * Body: eras in chronological order, each containing its narrative + chronicles.\n * Back Matter \u2192 Encyclopedia: entities grouped by culture then kind,\n *   each culture preceded by its static page.\n * Back Matter: remaining non-culture static pages.\n */\nexport function autoPopulateBody(\n  state: ContentTreeState,\n  input: AutoPopulateInput\n): ContentTreeState {\n  const bodyIndex = state.nodes.findIndex((n) => n.name === \"Body\" && n.type === \"folder\");\n  if (bodyIndex < 0) return state;\n\n  const backMatterIndex = state.nodes.findIndex(\n    (n) => n.name === \"Back Matter\" && n.type === \"folder\"\n  );\n\n  // Collect existing content IDs to avoid duplicates\n  const existingIds = getAllContentIds(state);\n\n  // =========================================================================\n  // Body: Era folders with narratives + chronicles\n  // =========================================================================\n\n  const publishedChronicles = input.chronicles.filter(\n    (c) =>\n      (c.status === \"complete\" || c.status === \"assembly_ready\") && !existingIds.has(c.chronicleId)\n  );\n\n  const completedNarratives = input.eraNarratives.filter(\n    (n) =>\n      (n.status === \"complete\" || n.status === \"step_complete\") && !existingIds.has(n.narrativeId)\n  );\n\n  // Collect all era IDs from chronicles and narratives\n  const allEraIds = new Set<string>();\n  for (const c of publishedChronicles) {\n    if (c.focalEraId) allEraIds.add(c.focalEraId);\n  }\n  for (const n of completedNarratives) {\n    allEraIds.add(n.eraId);\n  }\n\n  const sortedEraIds = [...allEraIds].sort((a, b) => {\n    const orderA = input.eraOrder.get(a) ?? Infinity;\n    const orderB = input.eraOrder.get(b) ?? Infinity;\n    return orderA - orderB;\n  });\n\n  const bodyChildren: ContentTreeNode[] = [];\n\n  for (const eraId of sortedEraIds) {\n    const eraName =\n      completedNarratives.find((n) => n.eraId === eraId)?.eraName ||\n      publishedChronicles.find((c) => c.focalEraId === eraId)?.focalEraName ||\n      eraId;\n\n    const eraFolder: ContentTreeNode = {\n      id: generateId(),\n      name: eraName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Era narrative at top of folder (pick most recent if multiple)\n    const narrative = completedNarratives\n      .filter((n) => n.eraId === eraId)\n      .sort((a, b) => (b as any).updatedAt - (a as any).updatedAt)[0];\n    if (narrative) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: `${eraName} \u2014 Era Narrative`,\n        type: \"era_narrative\",\n        contentId: narrative.narrativeId,\n      });\n    }\n\n    // Chronicles sorted by eraYear then name\n    const eraChronicles = publishedChronicles\n      .filter((c) => c.focalEraId === eraId)\n      .sort((a, b) => {\n        const yearA = a.eraYear ?? Infinity;\n        const yearB = b.eraYear ?? Infinity;\n        if (yearA !== yearB) return yearA - yearB;\n        return a.title.localeCompare(b.title);\n      });\n\n    for (const c of eraChronicles) {\n      eraFolder.children.push({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\",\n        contentId: c.chronicleId,\n      });\n    }\n\n    if (eraFolder.children.length > 0) {\n      bodyChildren.push(eraFolder);\n    }\n  }\n\n  // Unassigned chronicles (no focalEra)\n  const unassigned = publishedChronicles\n    .filter((c) => !c.focalEraId)\n    .sort((a, b) => a.title.localeCompare(b.title));\n  if (unassigned.length > 0) {\n    const unassignedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Unassigned Era\",\n      type: \"folder\",\n      children: unassigned.map((c) => ({\n        id: generateId(),\n        name: c.title || \"Untitled Chronicle\",\n        type: \"chronicle\" as const,\n        contentId: c.chronicleId,\n      })),\n    };\n    bodyChildren.push(unassignedFolder);\n  }\n\n  // =========================================================================\n  // Back Matter \u2192 Encyclopedia: entities by culture then kind\n  // =========================================================================\n\n  const eligibleEntities = input.entities.filter(\n    (e) => e.description && e.kind !== \"era\" && !existingIds.has(e.id)\n  );\n\n  // Build culture \u2192 entity grouping\n  const byCulture = new Map<string, typeof eligibleEntities>();\n  const uncultured: typeof eligibleEntities = [];\n  for (const e of eligibleEntities) {\n    if (e.culture) {\n      const list = byCulture.get(e.culture) || [];\n      list.push(e);\n      byCulture.set(e.culture, list);\n    } else {\n      uncultured.push(e);\n    }\n  }\n\n  // Build culture name \u2192 static page mapping\n  const publishedPages = input.staticPages.filter(\n    (p) => p.status === \"published\" && !existingIds.has(p.pageId)\n  );\n  const culturePageMap = new Map<string, (typeof publishedPages)[number]>();\n  const nonCulturePages: typeof publishedPages = [];\n  for (const p of publishedPages) {\n    const { namespace, baseName } = parseNamespace(p.title);\n    if (namespace === \"Cultures\") {\n      culturePageMap.set(baseName.toLowerCase(), p);\n    } else {\n      nonCulturePages.push(p);\n    }\n  }\n\n  const encyclopediaChildren: ContentTreeNode[] = [];\n  const usedPageIds = new Set<string>();\n\n  const sortedCultures = [...byCulture.keys()].sort((a, b) => a.localeCompare(b));\n  for (const cultureName of sortedCultures) {\n    const cultureFolder: ContentTreeNode = {\n      id: generateId(),\n      name: cultureName,\n      type: \"folder\",\n      children: [],\n    };\n\n    // Culture static page at top\n    const culturePage = culturePageMap.get(cultureName.toLowerCase());\n    if (culturePage) {\n      cultureFolder.children.push({\n        id: generateId(),\n        name: culturePage.title,\n        type: \"static_page\",\n        contentId: culturePage.pageId,\n      });\n      usedPageIds.add(culturePage.pageId);\n    }\n\n    // Group entities by kind\n    const cultureEntities = byCulture.get(cultureName);\n    const byKind = new Map<string, typeof cultureEntities>();\n    for (const e of cultureEntities) {\n      const kind = e.kind;\n      const list = byKind.get(kind) || [];\n      list.push(e);\n      byKind.set(kind, list);\n    }\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      cultureFolder.children.push(kindFolder);\n    }\n\n    if (cultureFolder.children.length > 0) {\n      encyclopediaChildren.push(cultureFolder);\n    }\n  }\n\n  // Uncultured entities\n  if (uncultured.length > 0) {\n    const byKind = new Map<string, typeof uncultured>();\n    for (const e of uncultured) {\n      const list = byKind.get(e.kind) || [];\n      list.push(e);\n      byKind.set(e.kind, list);\n    }\n\n    const unculturedFolder: ContentTreeNode = {\n      id: generateId(),\n      name: \"Uncategorized\",\n      type: \"folder\",\n      children: [],\n    };\n\n    const sortedKinds = [...byKind.keys()].sort((a, b) => a.localeCompare(b));\n    for (const kind of sortedKinds) {\n      const kindEntities = byKind.get(kind).sort((a, b) => a.name.localeCompare(b.name));\n      const kindFolder: ContentTreeNode = {\n        id: generateId(),\n        name: kind.charAt(0).toUpperCase() + kind.slice(1) + \"s\",\n        type: \"folder\",\n        children: kindEntities.map((e) => ({\n          id: generateId(),\n          name: e.name,\n          type: \"entity\" as const,\n          contentId: e.id,\n        })),\n      };\n      unculturedFolder.children.push(kindFolder);\n    }\n\n    if (unculturedFolder.children.length > 0) {\n      encyclopediaChildren.push(unculturedFolder);\n    }\n  }\n\n  // =========================================================================\n  // Assemble final tree\n  // =========================================================================\n\n  const newNodes = [...state.nodes];\n\n  // Replace Body children\n  newNodes[bodyIndex] = {\n    ...newNodes[bodyIndex],\n    children: bodyChildren,\n  };\n\n  // Add Encyclopedia + remaining static pages to Back Matter\n  if (backMatterIndex >= 0) {\n    const existingBackMatterChildren = [...(newNodes[backMatterIndex].children || [])];\n\n    // Insert Encyclopedia folder before existing back matter items\n    if (encyclopediaChildren.length > 0) {\n      const encyclopediaFolder: ContentTreeNode = {\n        id: generateId(),\n        name: \"Encyclopedia\",\n        type: \"folder\",\n        children: encyclopediaChildren,\n      };\n      existingBackMatterChildren.unshift(encyclopediaFolder);\n    }\n\n    // Add remaining non-culture static pages\n    const remainingPages = nonCulturePages.filter((p) => !usedPageIds.has(p.pageId));\n    for (const p of remainingPages) {\n      existingBackMatterChildren.push({\n        id: generateId(),\n        name: p.title,\n        type: \"static_page\",\n        contentId: p.pageId,\n      });\n    }\n\n    newNodes[backMatterIndex] = {\n      ...newNodes[backMatterIndex],\n      children: existingBackMatterChildren,\n    };\n  }\n\n  return {\n    ...state,\n    nodes: newNodes,\n    updatedAt: Date.now(),\n// ... (truncated)", "parameters": [{"name": "state", "type": "ContentTreeState", "optional": false}, {"name": "input", "type": "AutoPopulateInput", "optional": false}], "returnType": "ContentTreeState", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./prePrintTypes", "specifiers": ["ContentTreeNode", "ContentTreeState", "ContentNodeType"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::escapeXml", "name": "escapeXml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// XML Helpers\n// =============================================================================\n\nexport function escapeXml(text: string): string {\n  return text\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::renderParagraphs", "name": "renderParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "export function renderParagraphs(paras: IcmlParagraph[]): string {\n  if (paras.length === 0) return \"\";\n  return paras.map(renderParagraph).join(\"\\n    <Br/>\\n\");\n}", "parameters": [{"name": "paras", "type": "IcmlParagraph[]", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::parseInlineRuns", "name": "parseInlineRuns", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Inline Markdown Parsing \u2192 IcmlRun[]\n// =============================================================================\n\n/**\n * Parse inline markdown formatting into character style runs.\n * Handles: ***bold italic***, **bold**, *italic*, `code`\n */\nexport function parseInlineRuns(text: string): IcmlRun[] {\n  const runs: IcmlRun[] = [];\n  // Order matters: bold-italic before bold before italic\n  const pattern = /(\\*\\*\\*(.+?)\\*\\*\\*|\\*\\*(.+?)\\*\\*|\\*(.+?)\\*|`(.+?)`)/g;\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(text)) !== null) {\n    // Text before this match\n    if (match.index > lastIndex) {\n      runs.push({ charStyle: \"\", text: text.slice(lastIndex, match.index) });\n    }\n\n    if (match[2]) {\n      // ***bold italic***\n      runs.push({ charStyle: CS_BOLD_ITALIC, text: match[2] });\n    } else if (match[3]) {\n      // **bold**\n      runs.push({ charStyle: CS_BOLD, text: match[3] });\n    } else if (match[4]) {\n      // *italic*\n      runs.push({ charStyle: CS_ITALIC, text: match[4] });\n    } else if (match[5]) {\n      // `code`\n      runs.push({ charStyle: CS_CODE, text: match[5] });\n    }\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Remaining text\n  if (lastIndex < text.length) {\n    runs.push({ charStyle: \"\", text: text.slice(lastIndex) });\n  }\n\n  // If no runs were generated, add the full text as a default run\n  if (runs.length === 0 && text.length > 0) {\n    runs.push({ charStyle: \"\", text });\n  }\n\n  // Split runs containing \u263d (U+263D) so the crescent gets the Symbol char style\n  // which maps to Segoe UI Symbol \u2014 Junicode doesn't have this glyph.\n  return splitSymbolRuns(runs);\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "IcmlRun[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::plainPara", "name": "plainPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a simple paragraph with a single default-style run */\nexport function plainPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: [{ charStyle: \"\", text }] };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::styledPara", "name": "styledPara", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Create a paragraph with inline markdown parsed into runs */\nexport function styledPara(style: string, text: string): IcmlParagraph {\n  return { paraStyle: style, runs: parseInlineRuns(text) };\n}", "parameters": [{"name": "style", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], "returnType": "IcmlParagraph", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::markdownToIcmlParagraphs", "name": "markdownToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Convert markdown text to ICML paragraphs. Handles:\n * - Headings (# ## ###)\n * - Blockquotes (>)\n * - Horizontal rules (--- or ***)\n * - Image markers (<!-- IMAGE: ... -->)\n * - Inline formatting (**bold**, *italic*, ***both***, `code`)\n */\nexport function markdownToIcmlParagraphs(markdown: string): IcmlParagraph[] {\n  if (!markdown || !markdown.trim()) return [];\n\n  const paras: IcmlParagraph[] = [];\n  const lines = markdown.split(\"\\n\");\n  let blockLines: string[] = [];\n  let afterHeading = false;\n\n  function flushBlock() {\n    const text = blockLines.join(\" \").trim();\n    if (text) {\n      const style = afterHeading ? PS_BODY_FIRST : PS_BODY;\n      paras.push(styledPara(style, text));\n      afterHeading = false;\n    }\n    blockLines = [];\n  }\n\n  for (const rawLine of lines) {\n    const line = rawLine;\n    const trimmed = line.trim();\n\n    // Empty line = flush paragraph\n    if (!trimmed) {\n      flushBlock();\n      continue;\n    }\n\n    // Image marker\n    const img = parseImageMarker(trimmed);\n    if (img) {\n      flushBlock();\n      paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: ${img.path}]`));\n      if (img.caption) {\n        paras.push(plainPara(PS_CAPTION, img.caption));\n      }\n      afterHeading = false;\n      continue;\n    }\n\n    // Heading\n    const headingMatch = /^(#{1,3})\\s+(.+)$/.exec(trimmed); // eslint-disable-line sonarjs/slow-regex -- single markdown line\n    if (headingMatch) {\n      flushBlock();\n      const level = headingMatch[1].length;\n      let headingStyle: string;\n      if (level === 1) headingStyle = PS_HEADING1;\n      else if (level === 2) headingStyle = PS_HEADING2;\n      else headingStyle = PS_HEADING3;\n      paras.push(styledPara(headingStyle, headingMatch[2]));\n      afterHeading = true;\n      continue;\n    }\n\n    // Horizontal rule \u2192 separator\n    if (/^[-*_]{3,}\\s*$/.test(trimmed)) {\n      flushBlock();\n      paras.push(plainPara(PS_SEPARATOR, \"* * *\"));\n      afterHeading = false;\n      continue;\n    }\n\n    // Blockquote\n    if (trimmed.startsWith(\">\")) {\n      flushBlock();\n      const quoteText = trimmed.replace(/^>\\s*/, \"\");\n      paras.push(styledPara(PS_BLOCKQUOTE, quoteText));\n      afterHeading = false;\n      continue;\n    }\n\n    // Regular text \u2014 accumulate into block\n    blockLines.push(trimmed);\n  }\n\n  flushBlock();\n  return paras;\n}", "parameters": [{"name": "markdown", "type": "string", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::getImageExt", "name": "getImageExt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Content Formatters\n// =============================================================================\n\nexport function getImageExt(image?: ImageMetadataRecord): string {\n  if (!image?.mimeType) return \"\";\n  if (image.mimeType.includes(\"png\")) return \".png\";\n  if (image.mimeType.includes(\"jpeg\") || image.mimeType.includes(\"jpg\")) return \".jpg\";\n  if (image.mimeType.includes(\"webp\")) return \".webp\";\n  return \"\";\n}", "parameters": [{"name": "image", "type": "ImageMetadataRecord", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::annotateContentWithImages", "name": "annotateContentWithImages", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Insert image markers into content text and return annotated markdown.\n * Mirrors the logic from markdownExport.ts.\n */\nexport function annotateContentWithImages(\n  content: string,\n  imageRefs?: { refs?: any[] },\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): string {\n  if (!imageRefs?.refs || !content) return content;\n\n  let annotated = content;\n\n  // Prompt-request images\n  const promptRefs = imageRefs.refs.filter(\n    (r: any) => r.type === \"prompt_request\" && r.status === \"complete\" && r.generatedImageId\n  );\n  const promptInsertions = promptRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of promptInsertions) {\n    const imgId = ref.generatedImageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Entity-ref images\n  const entityRefs = imageRefs.refs.filter((r: any) => r.type === \"entity_ref\");\n  const entityInsertions = entityRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of entityInsertions) {\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: entity-portrait-${ref.entityId} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  // Chronicle-ref images (for era narratives)\n  const chronicleRefs = imageRefs.refs.filter((r: any) => r.type === \"chronicle_ref\");\n  const chronicleInsertions = chronicleRefs\n    .map((ref: any) => ({\n      ref,\n      insertAt: resolveInsertPosition(content, ref.anchorText, ref.anchorIndex),\n    }))\n    .sort((a: any, b: any) => b.insertAt - a.insertAt);\n\n  for (const { ref, insertAt } of chronicleInsertions) {\n    const imgId = ref.imageId;\n    registerFn(imgId, \"chronicle\");\n    const ext = getImageExt(imageMap.get(imgId));\n    const caption = ref.caption || \"\";\n    const marker = `\\n\\n<!-- IMAGE: images/${imgId}${ext} | size: ${ref.size} | float: ${ref.justification || \"none\"} | caption: \"${caption}\" -->\\n\\n`;\n    annotated = annotated.slice(0, insertAt) + marker + annotated.slice(insertAt);\n  }\n\n  return annotated;\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "imageRefs", "type": "{ refs?: any[] }", "optional": true}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::entityToIcmlParagraphs", "name": "entityToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an entity to ICML paragraphs */\nexport function entityToIcmlParagraphs(\n  entity: PersistedEntity,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, entity.name));\n\n  // Subtitle: kind / subtype\n  const subtitleParts = [entity.kind];\n  if (entity.subtype) subtitleParts.push(entity.subtype);\n  if (entity.culture) subtitleParts.push(entity.culture);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Metadata\n  paras.push(plainPara(PS_METADATA, `Prominence: ${entity.prominence} | Status: ${entity.status}`));\n\n  const aliases = entity.enrichment?.text?.aliases;\n  if (aliases?.length) {\n    paras.push(plainPara(PS_METADATA, `Also known as: ${aliases.join(\", \")}`));\n  }\n\n  if (entity.tags && Object.keys(entity.tags).length > 0) {\n    const tagStr = Object.entries(entity.tags)\n      .map(([k, v]) => `${k}: ${v}`)\n      .join(\" | \");\n    paras.push(plainPara(PS_METADATA, tagStr));\n  }\n\n  // Entity image\n  const imageId = entity.enrichment?.image?.imageId;\n  if (imageId) {\n    registerFn(imageId, \"entity\", entity.id, entity.name);\n    const ext = getImageExt(imageMap.get(imageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${imageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, `${entity.name} portrait`));\n  }\n\n  // Summary\n  if (entity.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, entity.summary));\n  }\n\n  // Description body\n  if (entity.description) {\n    const bodyParas = markdownToIcmlParagraphs(entity.description);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = entity.enrichment?.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "entity", "type": "PersistedEntity", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::chronicleToIcmlParagraphs", "name": "chronicleToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a chronicle to ICML paragraphs */\nexport function chronicleToIcmlParagraphs(\n  chronicle: ChronicleRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const content = chronicle.finalContent || chronicle.assembledContent || \"\";\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, chronicle.title || \"Untitled Chronicle\"));\n\n  // Subtitle\n  const subtitleParts = [chronicle.format, chronicle.focusType];\n  if (chronicle.narrativeStyle?.name) subtitleParts.push(chronicle.narrativeStyle.name);\n  paras.push(plainPara(PS_ITEM_SUBTITLE, subtitleParts.join(\" \\u2022 \")));\n\n  // Summary\n  if (chronicle.summary) {\n    paras.push(styledPara(PS_BLOCKQUOTE, chronicle.summary));\n  }\n\n  // Cover image\n  const coverImageId = chronicle.coverImage?.generatedImageId;\n  if (coverImageId && chronicle.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\", undefined, undefined, chronicle.chronicleId);\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, chronicle.title || \"Cover\"));\n  }\n\n  // Cast\n  if (chronicle.roleAssignments?.length) {\n    paras.push(plainPara(PS_HEADING2, \"Cast\"));\n    for (const ra of chronicle.roleAssignments) {\n      const emphasis = ra.isPrimary ? \"Primary\" : \"Supporting\";\n      paras.push({\n        paraStyle: PS_CAST_ENTRY,\n        runs: [\n          { charStyle: CS_BOLD, text: ra.role },\n          { charStyle: \"\", text: ` \\u2014 ${ra.entityName} (${ra.entityKind}, ${emphasis})` },\n        ],\n      });\n    }\n  }\n\n  // Narrative content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      chronicle.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  // Historian notes\n  const notes = chronicle.historianNotes?.filter((n: HistorianNote) => isNoteActive(n));\n  if (notes?.length) {\n    const fullNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"full\");\n    const popoutNotes = notes.filter((n: HistorianNote) => noteDisplay(n) === \"popout\");\n\n    if (fullNotes.length > 0 || popoutNotes.length > 0) {\n      paras.push(plainPara(PS_HEADING2, \"Historian\\u2019s Notes\"));\n    }\n\n    for (const note of fullNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_BOLD, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: note.text },\n          { charStyle: CS_ITALIC, text: ` (anchored to: \\u201C${note.anchorPhrase}\\u201D)` },\n        ],\n      });\n    }\n\n    for (const note of popoutNotes) {\n      const typeLabel = note.type.charAt(0).toUpperCase() + note.type.slice(1);\n      paras.push({\n        paraStyle: PS_HISTORIAN_NOTE,\n        runs: [\n          { charStyle: CS_ITALIC, text: `[${typeLabel}] ` },\n          { charStyle: \"\", text: `${note.text} \\u2014 \\u201C${note.anchorPhrase}\\u201D` },\n        ],\n      });\n    }\n  }\n\n  return paras;\n}", "parameters": [{"name": "chronicle", "type": "ChronicleRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::eraNarrativeToIcmlParagraphs", "name": "eraNarrativeToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert an era narrative to ICML paragraphs */\nexport function eraNarrativeToIcmlParagraphs(\n  narrative: EraNarrativeRecord,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  registerFn: (\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void\n): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n  const { content } = resolveActiveContent(narrative);\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, narrative.eraName));\n\n  // Subtitle\n  paras.push(plainPara(PS_ITEM_SUBTITLE, `${narrative.tone} \\u2022 era narrative`));\n\n  // Thesis\n  if (narrative.threadSynthesis?.thesis) {\n    paras.push(styledPara(PS_BLOCKQUOTE, narrative.threadSynthesis.thesis));\n  }\n\n  // Threads\n  if (narrative.threadSynthesis?.threads?.length) {\n    const threadNames = narrative.threadSynthesis.threads.map((t: any) => t.name).join(\", \");\n    paras.push(plainPara(PS_METADATA, `Threads: ${threadNames}`));\n  }\n\n  // Cover image\n  const coverImageId = narrative.coverImage?.generatedImageId;\n  if (coverImageId && narrative.coverImage?.status === \"complete\") {\n    registerFn(coverImageId, \"cover\");\n    const ext = getImageExt(imageMap.get(coverImageId));\n    paras.push(plainPara(PS_IMAGE_PLACEHOLDER, `[IMAGE: images/${coverImageId}${ext}]`));\n    paras.push(plainPara(PS_CAPTION, narrative.eraName));\n  }\n\n  // Content with inline images\n  if (content) {\n    const annotated = annotateContentWithImages(\n      content,\n      narrative.imageRefs,\n      imageMap,\n      referencedImages,\n      registerFn\n    );\n    const bodyParas = markdownToIcmlParagraphs(annotated);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "narrative", "type": "EraNarrativeRecord", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "registerFn", "type": "(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ) => void", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::staticPageToIcmlParagraphs", "name": "staticPageToIcmlParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/** Convert a static page to ICML paragraphs */\nexport function staticPageToIcmlParagraphs(page: StaticPage): IcmlParagraph[] {\n  const paras: IcmlParagraph[] = [];\n\n  // Title\n  paras.push(plainPara(PS_ITEM_TITLE, page.title));\n\n  // Content (already markdown with headings, etc.)\n  if (page.content) {\n    const bodyParas = markdownToIcmlParagraphs(page.content);\n    paras.push(...bodyParas);\n  }\n\n  return paras;\n}", "parameters": [{"name": "page", "type": "StaticPage", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::createImageRegistrar", "name": "createImageRegistrar", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "// =============================================================================\n// Image Registration (mirrors markdownExport.ts pattern)\n// =============================================================================\n\nexport function createImageRegistrar(\n  referencedImages: Map<string, ExportImageEntry>,\n  imageMap: Map<string, ImageMetadataRecord>\n) {\n  return function registerImage(\n    imgId: string,\n    type: ImageSourceType,\n    entityId?: string,\n    entityName?: string,\n    chronicleId?: string\n  ): void {\n    if (referencedImages.has(imgId)) return;\n    const img = imageMap.get(imgId);\n    const ext = getImageExt(img);\n    referencedImages.set(imgId, {\n      imageId: imgId,\n      filename: `${imgId}${ext}`,\n      width: img?.width,\n      height: img?.height,\n      aspect: img?.aspect,\n      imageType: type,\n      entityId: entityId || img?.entityId,\n      entityName: entityName || img?.entityName,\n      chronicleId: chronicleId || img?.chronicleId,\n      mimeType: img?.mimeType,\n    });\n  };\n}", "parameters": [{"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}], "returnType": "(imgId: string, type: any, entityId?: string, entityName?: string, chronicleId?: string) => void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookParagraphs", "name": "buildBookParagraphs", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Walk the content tree and produce an array of styled paragraphs.\n * Used by both ICML and IDML generators.\n */\nexport function buildBookParagraphs(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): IcmlParagraph[] {\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allParagraphs: IcmlParagraph[] = [];\n  const flattened = flattenForExport(treeState);\n  let prevWasContent = false;\n\n  for (const { node, depth } of flattened) {\n    if (node.type === \"folder\") {\n      if (prevWasContent) {\n        allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n        prevWasContent = false;\n      }\n\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      allParagraphs.push(plainPara(headingStyle, node.name));\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    if (prevWasContent) {\n      allParagraphs.push(plainPara(PS_SEPARATOR, \"* * *\"));\n    }\n\n    let contentParas: IcmlParagraph[] = [];\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n      }\n    }\n\n    if (contentParas.length > 0) {\n      allParagraphs.push(...contentParas);\n      prevWasContent = true;\n    }\n  }\n\n  return allParagraphs;\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "IcmlParagraph[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts::buildBookIcml", "name": "buildBookIcml", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/icmlExport.ts", "sourceCode": "/**\n * Build a complete ICML document from the content tree.\n * Wraps the shared paragraph output in ICML document structure.\n */\nexport function buildBookIcml(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>\n): string {\n  const allParagraphs = buildBookParagraphs(treeState, contentMaps, imageMap, referencedImages);\n\n  const parts: string[] = [];\n  parts.push(ICML_HEADER);\n  parts.push(buildStyleDefinitions());\n  parts.push(buildStoryOpen());\n  parts.push(renderParagraphs(allParagraphs));\n  parts.push(ICML_FOOTER);\n  return parts.join(\"\\n\");\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts::buildIdmlPackage", "name": "buildIdmlPackage", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/idmlExport.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build a complete IDML package as a Blob.\n *\n * The .idml file is a ZIP containing all the XML files that define\n * an InDesign document. Each content entry gets its own story and spread(s).\n */\nexport async function buildIdmlPackage(\n  treeState: ContentTreeState,\n  contentMaps: ContentMaps,\n  imageMap: Map<string, ImageMetadataRecord>,\n  referencedImages: Map<string, ExportImageEntry>,\n  layoutOptions?: IdmlLayoutOptions\n): Promise<Blob> {\n  const layout = resolveLayout(layoutOptions);\n  const registerFn = createImageRegistrar(referencedImages, imageMap);\n\n  const allStories: StoryFile[] = [];\n  const allSpreads: SpreadFile[] = [];\n  let currentPageNum = 1;\n  let entryCounter = 0;\n\n  const flattened = flattenForExport(treeState);\n\n  for (const { node, depth } of flattened) {\n    const entryId = `e${entryCounter++}`;\n\n    if (node.type === \"folder\") {\n      // Folder heading: simple story + 2-page spread\n      const storyId = `story_${entryId}`;\n      const headingStyle = depth <= 0 ? PS_SECTION_HEADING : PS_ERA_HEADING;\n      const paras = [plainPara(headingStyle, node.name)];\n\n      const storyXml = buildEntryStoryXml(storyId, paras, []);\n      allStories.push({\n        filename: `Stories/Story_${storyId}.xml`,\n        xml: storyXml,\n        storyId,\n      });\n\n      const masterId = MASTERS.D.spreadId; // folders use D-Encyclopedia master\n      const { spreads, pagesUsed } = buildEntrySpreads(\n        entryId,\n        storyId,\n        masterId,\n        2,\n        currentPageNum,\n        [],\n        [],\n        layout\n      );\n      allSpreads.push(...spreads);\n      currentPageNum += pagesUsed;\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    // Content entry: build paragraphs, classify notes, collect images\n    let contentParas: IcmlParagraph[] = [];\n    let footnotes: FootnoteInsert[] = [];\n    let callouts: { anchorPhrase: string; noteText: string; noteType: string }[] = [];\n    let images: ImagePlacement[] = [];\n    const masterKey = selectMaster(node.type, contentMaps, node.contentId);\n\n    if (node.type === \"entity\") {\n      const entity = contentMaps.entityMap.get(node.contentId);\n      if (entity) {\n        contentParas = entityToIcmlParagraphs(entity, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(entity.enrichment?.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(entity, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = contentMaps.chronicleMap.get(node.contentId);\n      if (chronicle) {\n        contentParas = chronicleToIcmlParagraphs(chronicle, imageMap, referencedImages, registerFn);\n        const notes = classifyHistorianNotes(chronicle.historianNotes);\n        footnotes = notes.footnotes;\n        callouts = notes.callouts;\n        images = collectEntryImages(chronicle, imageMap);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = contentMaps.narrativeMap.get(node.contentId);\n      if (narrative) {\n        contentParas = eraNarrativeToIcmlParagraphs(\n          narrative,\n          imageMap,\n          referencedImages,\n          registerFn\n        );\n        // Era narratives don't have historian notes\n        images = collectEntryImages(narrative, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = contentMaps.pageMap.get(node.contentId);\n      if (page) {\n        contentParas = staticPageToIcmlParagraphs(page);\n        // Static pages have no images or notes\n      }\n    }\n\n    if (contentParas.length === 0) continue;\n\n    // Strip historian note paragraphs from the main content \u2014 in IDML,\n    // popout notes become inline footnotes and full notes become callout stories\n    if (footnotes.length > 0 || callouts.length > 0) {\n      contentParas = stripHistorianNotes(contentParas);\n    }\n\n    // Build main story (with inline footnotes)\n    const storyId = `story_${entryId}`;\n    const storyXml = buildEntryStoryXml(storyId, contentParas, footnotes);\n    allStories.push({\n      filename: `Stories/Story_${storyId}.xml`,\n      xml: storyXml,\n      storyId,\n    });\n\n    // Build callout stories\n    const calloutStoryRefs: { storyId: string }[] = [];\n    for (let ci = 0; ci < callouts.length; ci++) {\n      const callout = callouts[ci];\n      const calloutStoryId = `story_${entryId}_co${ci}`;\n      const calloutXml = buildCalloutStoryXml(\n        calloutStoryId,\n        callout.noteType,\n        callout.noteText,\n        callout.anchorPhrase\n      );\n      allStories.push({\n        filename: `Stories/Story_${calloutStoryId}.xml`,\n        xml: calloutXml,\n        storyId: calloutStoryId,\n      });\n      calloutStoryRefs.push({ storyId: calloutStoryId });\n    }\n\n    // Estimate pages and build spreads\n    const pageCount = estimateEntryPages(contentParas, images.length, layout.linesPerPage);\n    const masterId = MASTERS[masterKey].spreadId;\n\n    const { spreads, pagesUsed } = buildEntrySpreads(\n      entryId,\n      storyId,\n      masterId,\n      pageCount,\n      currentPageNum,\n      images,\n      calloutStoryRefs,\n      layout\n    );\n    allSpreads.push(...spreads);\n    currentPageNum += pagesUsed;\n  }\n\n  // Build master spread files\n  const masterKeys: MasterKey[] = [\"A\", \"B\", \"C\", \"D\"];\n  const masterSpreadFiles: { spreadId: string; filename: string }[] = [];\n  const masterStoryIds: string[] = [];\n\n  const zip = new JSZip();\n\n  // mimetype MUST be the first entry (uncompressed)\n  zip.file(\"mimetype\", MIMETYPE);\n\n  for (const key of masterKeys) {\n    const master = MASTERS[key];\n    const filename = `MasterSpreads/MasterSpread_${master.spreadId}.xml`;\n    zip.file(filename, buildMasterSpreadXml(master, layout));\n    masterSpreadFiles.push({ spreadId: master.spreadId, filename });\n\n    // Master story\n    const masterStoryFilename = `Stories/Story_${master.storyId}.xml`;\n    zip.file(masterStoryFilename, buildMasterStoryXml(master.storyId));\n    masterStoryIds.push(master.storyId);\n  }\n\n  // Structural files\n  zip.file(\"META-INF/container.xml\", buildContainerXml());\n\n  // Resources\n  zip.file(\"Resources/Graphic.xml\", buildGraphicXml());\n  zip.file(\"Resources/Fonts.xml\", buildFontsXml(layout.fontFamily));\n  zip.file(\"Resources/Styles.xml\", buildStylesXml(layout));\n  zip.file(\"Resources/Preferences.xml\", buildPreferencesXml(layout));\n\n  // Entry spreads\n  for (const spread of allSpreads) {\n    zip.file(spread.filename, spread.xml);\n  }\n\n  // Entry stories\n  for (const story of allStories) {\n    zip.file(story.filename, story.xml);\n  }\n\n  // XML structure\n  zip.file(\"XML/BackingStory.xml\", buildBackingStoryXml());\n  zip.file(\"XML/Tags.xml\", buildTagsXml());\n\n  // Designmap (must reference everything)\n  const totalPages = currentPageNum - 1;\n  zip.file(\n    \"designmap.xml\",\n    buildDesignmap(masterSpreadFiles, allSpreads, allStories, masterStoryIds, totalPages)\n  );\n\n  // Generate with STORE compression (standard for IDML)\n  return zip.generateAsync({ type: \"blob\", compression: \"STORE\" });\n}", "parameters": [{"name": "treeState", "type": "ContentTreeState", "optional": false}, {"name": "contentMaps", "type": "ContentMaps", "optional": false}, {"name": "imageMap", "type": "Map<string, ImageMetadataRecord>", "optional": false}, {"name": "referencedImages", "type": "Map<string, ExportImageEntry>", "optional": false}, {"name": "layoutOptions", "type": "IdmlLayoutOptions", "optional": true}], "returnType": "Promise<Blob>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "jszip", "specifiers": ["JSZip"], "category": "external"}, {"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportImageEntry", "IdmlLayoutOptions"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["IDML_PAGE_PRESETS", "DEFAULT_IDML_LAYOUT"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}, {"source": "./icmlExport", "specifiers": ["escapeXml", "renderParagraphs", "PARAGRAPH_STYLE_DEFS", "CHARACTER_STYLE_DEFS", "entityToIcmlParagraphs", "chronicleToIcmlParagraphs", "eraNarrativeToIcmlParagraphs", "staticPageToIcmlParagraphs", "createImageRegistrar", "plainPara", "PS_SECTION_HEADING", "PS_ERA_HEADING", "PS_FOOTNOTE_TEXT", "PS_CALLOUT_BODY", "PS_HISTORIAN_NOTE", "PS_HEADING2", "CS_BOLD", "CS_NONE"], "category": "internal"}, {"source": "./icmlExport", "specifiers": ["ContentMaps", "ParagraphStyleDef", "CharacterStyleDef", "IcmlParagraph"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildExportZip", "name": "buildExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildExportZip(options: ExportOptions): Promise<Blob> {\n  const {\n    treeState,\n    entities,\n    chronicles,\n    images,\n    staticPages,\n    eraNarratives,\n    projectId,\n    simulationRunId,\n    s3Config,\n  } = options;\n\n  const zip = new JSZip();\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n\n  // Collect all referenced image IDs for the manifest\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Flatten tree and generate files\n  const flattened = flattenForExport(treeState);\n\n  for (const { path, node } of flattened) {\n    if (node.type === \"folder\") {\n      // Create empty directory entry\n      zip.folder(path);\n      continue;\n    }\n\n    if (!node.contentId) continue;\n\n    let markdown: string | null = null;\n\n    if (node.type === \"entity\") {\n      const entity = entityMap.get(node.contentId);\n      if (entity) {\n        markdown = formatEntityMarkdown(entity, referencedImages, imageMap);\n      }\n    } else if (node.type === \"chronicle\") {\n      const chronicle = chronicleMap.get(node.contentId);\n      if (chronicle) {\n        markdown = formatChronicleMarkdown(chronicle, referencedImages, imageMap);\n      }\n    } else if (node.type === \"static_page\") {\n      const page = pageMap.get(node.contentId);\n      if (page) {\n        markdown = formatStaticPageMarkdown(page, entities);\n      }\n    } else if (node.type === \"era_narrative\") {\n      const narrative = narrativeMap.get(node.contentId);\n      if (narrative) {\n        markdown = formatEraNarrativeMarkdown(narrative, referencedImages, imageMap);\n      }\n    }\n\n    if (markdown) {\n      const filename = slugify(node.name) + \".md\";\n      zip.file(`${path}/${filename}`, markdown);\n    }\n  }\n\n  // Build manifest\n  const manifest = buildManifest(\n    treeState,\n    entities,\n    chronicles,\n    staticPages,\n    eraNarratives,\n    images,\n    referencedImages,\n    projectId,\n    simulationRunId,\n    s3Config\n  );\n  zip.file(\"manifest.json\", JSON.stringify(manifest, null, 2));\n\n  // S3 download script\n  if (s3Config) {\n    zip.file(\n      \"s3-config.json\",\n      JSON.stringify(\n        {\n          bucket: s3Config.bucket,\n          basePrefix: s3Config.basePrefix,\n          rawPrefix: s3Config.rawPrefix,\n          projectId,\n          region: s3Config.region,\n        },\n        null,\n        2\n      )\n    );\n\n    zip.file(\"download-images.sh\", buildDownloadScript());\n  }\n\n  return zip.generateAsync({ type: \"blob\" });\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "jszip", "specifiers": ["JSZip"], "category": "external"}, {"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleImageRef"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportManifest", "ExportImageEntry", "S3ExportConfig", "IdmlLayoutOptions"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}, {"source": "../db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}, {"source": "./idmlExport", "specifiers": ["buildIdmlPackage"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildInDesignExportZip", "name": "buildInDesignExportZip", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "export async function buildInDesignExportZip(options: ExportOptions): Promise<Blob> {\n  const { treeState, entities, chronicles, images, staticPages, eraNarratives, idmlLayout } =\n    options;\n\n  const entityMap = new Map(entities.map((e) => [e.id, e]));\n  const chronicleMap = new Map(chronicles.map((c) => [c.chronicleId, c]));\n  const pageMap = new Map(staticPages.map((p) => [p.pageId, p]));\n  const narrativeMap = new Map(eraNarratives.map((n) => [n.narrativeId, n]));\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const referencedImages = new Map<string, ExportImageEntry>();\n\n  // Build a complete IDML package \u2014 opens directly in InDesign.\n  // IDML is already a ZIP internally, so we return the blob directly\n  // rather than wrapping it in another ZIP.\n  return buildIdmlPackage(\n    treeState,\n    { entityMap, chronicleMap, pageMap, narrativeMap },\n    imageMap,\n    referencedImages,\n    idmlLayout\n  );\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "Promise<Blob>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "jszip", "specifiers": ["JSZip"], "category": "external"}, {"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleImageRef"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportManifest", "ExportImageEntry", "S3ExportConfig", "IdmlLayoutOptions"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}, {"source": "../db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}, {"source": "./idmlExport", "specifiers": ["buildIdmlPackage"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts::buildIdmlImageScript", "name": "buildIdmlImageScript", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/markdownExport.ts", "sourceCode": "// =============================================================================\n// IDML Image Download Script\n// =============================================================================\n\n/**\n * Generates a self-contained bash script that downloads all images referenced\n * by the IDML export from S3. The script embeds the S3 config and image list\n * directly \u2014 no manifest.json or s3-config.json needed.\n *\n * Place the script next to the .idml file and run it. It creates images/\n * alongside the IDML so InDesign resolves the `file:images/...` links.\n */\nexport function buildIdmlImageScript(options: ExportOptions): string {\n  const { entities, chronicles, eraNarratives, images, projectId, s3Config } = options;\n  if (!s3Config) return \"\";\n\n  const imageMap = new Map(images.map((i) => [i.imageId, i]));\n  const seen = new Set<string>();\n  const imageEntries: { id: string; filename: string }[] = [];\n\n  // Match the extension logic used by idmlExport's collectEntryImages\n  // (defaults to .png when mimeType is unknown)\n  function idmlExt(img?: ImageMetadataRecord): string {\n    if (!img?.mimeType) return \".png\";\n    if (img.mimeType.includes(\"png\")) return \".png\";\n    if (img.mimeType.includes(\"jpeg\") || img.mimeType.includes(\"jpg\")) return \".jpg\";\n    if (img.mimeType.includes(\"webp\")) return \".webp\";\n    return \".png\";\n  }\n\n  function addImage(imageId: string) {\n    if (!imageId || seen.has(imageId)) return;\n    // Skip image IDs not present in metadata \u2014 they are likely malformed\n    // composite keys (e.g. chronicleId:imageRefId) that won't exist in S3\n    if (!imageMap.has(imageId)) return;\n    seen.add(imageId);\n    const ext = idmlExt(imageMap.get(imageId));\n    imageEntries.push({ id: imageId, filename: `${imageId}${ext}` });\n  }\n\n  // Entity portraits\n  for (const entity of entities) {\n    const imageId = entity.enrichment?.image?.imageId;\n    if (imageId) addImage(imageId);\n  }\n\n  // Chronicle covers and scene images\n  for (const chronicle of chronicles) {\n    if (chronicle.coverImage?.generatedImageId && chronicle.coverImage.status === \"complete\") {\n      addImage(chronicle.coverImage.generatedImageId);\n    }\n    if (chronicle.imageRefs?.refs) {\n      for (const ref of chronicle.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n      }\n    }\n  }\n\n  // Era narrative covers and inline refs\n  for (const narrative of eraNarratives) {\n    if (narrative.coverImage?.generatedImageId && narrative.coverImage?.status === \"complete\") {\n      addImage(narrative.coverImage.generatedImageId);\n    }\n    if (narrative.imageRefs?.refs) {\n      for (const ref of narrative.imageRefs.refs) {\n        if (ref.type === \"prompt_request\" && ref.status === \"complete\" && ref.generatedImageId) {\n          addImage(ref.generatedImageId);\n        }\n        if (ref.type === \"chronicle_ref\" && ref.imageId) {\n          addImage(ref.imageId);\n        }\n      }\n    }\n  }\n\n  if (imageEntries.length === 0) {\n    return `#!/usr/bin/env bash\n# No images referenced in this export.\necho \"No images to download.\"\n`;\n  }\n\n  const downloads = imageEntries.map((e) => `download_image \"${e.id}\" \"${e.filename}\"`).join(\"\\n\");\n\n  return `#!/usr/bin/env bash\n# Download images from S3 for InDesign IDML import\n# Generated by Illuminator Pre-Print Export\n#\n# Place this script next to your .idml file, then run it.\n# It creates an images/ directory alongside the IDML file\n# so InDesign resolves the linked image paths automatically.\n\nset -euo pipefail\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"\\${BASH_SOURCE[0]}\")\" && pwd)\"\nIMAGE_DIR=\"\\${SCRIPT_DIR}/images\"\n\n# --- Embedded S3 Configuration ---\nBUCKET=\"${s3Config.bucket}\"\nBASE_PREFIX=\"${s3Config.basePrefix}\"\nRAW_PREFIX=\"${s3Config.rawPrefix}\"\nPROJECT_ID=\"${projectId}\"\nREGION=\"${s3Config.region}\"\n\n# Build S3 key prefix, filtering out empty segments\nS3_PREFIX=$(echo \"\\${BASE_PREFIX}/\\${RAW_PREFIX}/\\${PROJECT_ID}\" | sed 's|/\\\\+|/|g; s|^/||; s|/$||')\n\n# --- Pre-flight checks ---\nif ! command -v aws &>/dev/null; then\n  echo \"ERROR: aws CLI is required but not installed.\"\n  echo \"  Install: https://aws.amazon.com/cli/\"\n  exit 1\nfi\n\nmkdir -p \"\\${IMAGE_DIR}\"\n\necho \"Downloading ${imageEntries.length} images from s3://\\${BUCKET}/\\${S3_PREFIX}/\"\necho \"Region: \\${REGION}\"\necho \"Target: \\${IMAGE_DIR}/\"\necho \"\"\n\nDOWNLOADED=0\nSKIPPED=0\nFAILED=0\n\ndownload_image() {\n  local IMAGE_ID=\"\\$1\"\n  local FILENAME=\"\\$2\"\n  local DEST=\"\\${IMAGE_DIR}/\\${FILENAME}\"\n\n  if [ -f \"\\${DEST}\" ]; then\n    SKIPPED=$((SKIPPED + 1))\n    return\n  fi\n\n  local S3_KEY=\"\\${S3_PREFIX}/\\${IMAGE_ID}\"\n  echo \"  GET  \\${FILENAME}\"\n  if aws s3 cp \"s3://\\${BUCKET}/\\${S3_KEY}\" \"\\${DEST}\" --region \"\\${REGION}\" --quiet 2>/dev/null; then\n    DOWNLOADED=$((DOWNLOADED + 1))\n  else\n    echo \"  FAIL \\${FILENAME}\"\n    FAILED=$((FAILED + 1))\n  fi\n}\n\n${downloads}\n\necho \"\"\necho \"Done. Downloaded: \\${DOWNLOADED}  Skipped: \\${SKIPPED}  Failed: \\${FAILED}\"\necho \"Images directory: \\${IMAGE_DIR}\"\n`;\n}", "parameters": [{"name": "options", "type": "ExportOptions", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "jszip", "specifiers": ["JSZip"], "category": "external"}, {"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord", "ChronicleImageRef"], "category": "internal"}, {"source": "./prePrintStats", "specifiers": ["ImageMetadataRecord"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["isNoteActive", "noteDisplay"], "category": "internal"}, {"source": "../fuzzyAnchor", "specifiers": ["resolveAnchorPhrase"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["ContentTreeState", "ExportManifest", "ExportImageEntry", "S3ExportConfig", "IdmlLayoutOptions"], "category": "internal"}, {"source": "./contentTree", "specifiers": ["flattenForExport"], "category": "internal"}, {"source": "../db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}, {"source": "./idmlExport", "specifiers": ["buildIdmlPackage"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts::computePrePrintStats", "name": "computePrePrintStats", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/preprint/prePrintStats.ts", "sourceCode": "export function computePrePrintStats(\n  entities: PersistedEntity[],\n  chronicles: ChronicleRecord[],\n  images: ImageMetadataRecord[],\n  staticPages: StaticPage[],\n  eraNarratives: EraNarrativeRecord[]\n): PrePrintStats {\n  // Filter to publishable content\n  const publishedChronicles = chronicles.filter(\n    (c) => c.status === \"complete\" || c.status === \"assembly_ready\"\n  );\n  const publishedPages = staticPages.filter((p) => p.status === \"published\");\n  const completedNarratives = eraNarratives.filter(\n    (n) => n.status === \"complete\" || n.status === \"step_complete\"\n  );\n\n  // =========================================================================\n  // Word & Character Counts\n  // =========================================================================\n\n  const chronicleBodyTexts = publishedChronicles.map(getPublishedContent);\n  const chronicleSummaryTexts = publishedChronicles.map((c) => c.summary || \"\");\n  const entityDescTexts = entities.map((e) => e.description || \"\");\n  const entitySummaryTexts = entities.map((e) => e.summary || \"\");\n  const captionTexts = collectCaptions(publishedChronicles);\n  const pageTexts = publishedPages.map((p) => p.content || \"\");\n\n  // Era narrative content from active version (with legacy fallback)\n  const narrativeTexts = completedNarratives.map((n) => {\n    const { content } = resolveActiveContent(n);\n    return content || \"\";\n  });\n\n  // Historian notes: collect from both entities and chronicles\n  const entityHistorianNotes: HistorianNote[] = [];\n  for (const e of entities) {\n    if (e.enrichment?.historianNotes?.length) {\n      entityHistorianNotes.push(...e.enrichment.historianNotes);\n    }\n  }\n  const chronicleHistorianNotes: HistorianNote[] = [];\n  for (const c of publishedChronicles) {\n    if (c.historianNotes?.length) {\n      chronicleHistorianNotes.push(...c.historianNotes);\n    }\n  }\n  const allHistorianNotes = [...entityHistorianNotes, ...chronicleHistorianNotes];\n\n  const sumWords = (texts: string[]) => texts.reduce((s, t) => s + countWords(t), 0);\n  const sumChars = (texts: string[]) => texts.reduce((s, t) => s + countChars(t), 0);\n\n  const entityHistorianNoteText = collectHistorianNoteTexts(entityHistorianNotes);\n  const chronicleHistorianNoteText = collectHistorianNoteTexts(chronicleHistorianNotes);\n\n  const wordBreakdown: WordCountBreakdown = {\n    chronicleBody: sumWords(chronicleBodyTexts),\n    chronicleSummaries: sumWords(chronicleSummaryTexts),\n    entityDescriptions: sumWords(entityDescTexts),\n    entitySummaries: sumWords(entitySummaryTexts),\n    eraNarrativeContent: sumWords(narrativeTexts),\n    imageCaptions: sumWords(captionTexts),\n    historianNotesEntity: countWords(entityHistorianNoteText),\n    historianNotesChronicle: countWords(chronicleHistorianNoteText),\n    staticPageContent: sumWords(pageTexts),\n  };\n\n  const charBreakdown: CharCountBreakdown = {\n    chronicleBody: sumChars(chronicleBodyTexts),\n    chronicleSummaries: sumChars(chronicleSummaryTexts),\n    entityDescriptions: sumChars(entityDescTexts),\n    entitySummaries: sumChars(entitySummaryTexts),\n    eraNarrativeContent: sumChars(narrativeTexts),\n    imageCaptions: sumChars(captionTexts),\n    historianNotesEntity: countChars(entityHistorianNoteText),\n    historianNotesChronicle: countChars(chronicleHistorianNoteText),\n    staticPageContent: sumChars(pageTexts),\n  };\n\n  const totalWords = Object.values(wordBreakdown).reduce((s, v) => s + v, 0);\n  const totalChars = Object.values(charBreakdown).reduce((s, v) => s + v, 0);\n\n  // =========================================================================\n  // Image Stats\n  // =========================================================================\n\n  const byAspect: Record<ImageAspect, number> = { portrait: 0, landscape: 0, square: 0 };\n  const byType: Record<ImageType | \"cover\", number> = { entity: 0, chronicle: 0, cover: 0 };\n  const bySize: Record<ChronicleImageSize, number> = {\n    small: 0,\n    medium: 0,\n    large: 0,\n    \"full-width\": 0,\n  };\n\n  let minW = Infinity,\n    maxW = 0,\n    minH = Infinity,\n    maxH = 0;\n  let hasDimensions = false;\n\n  for (const img of images) {\n    const aspect = img.aspect || \"square\";\n    byAspect[aspect]++;\n\n    const isCover = img.imageRefId === \"__cover_image__\";\n    const type = isCover ? \"cover\" : img.imageType || \"entity\";\n    byType[type]++;\n\n    if (img.width && img.height) {\n      hasDimensions = true;\n      if (img.width < minW) minW = img.width;\n      if (img.width > maxW) maxW = img.width;\n      if (img.height < minH) minH = img.height;\n      if (img.height > maxH) maxH = img.height;\n    }\n  }\n\n  // Count image size designations from chronicle image refs\n  for (const c of publishedChronicles) {\n    if (!c.imageRefs?.refs) continue;\n    for (const ref of c.imageRefs.refs) {\n      bySize[ref.size]++;\n    }\n  }\n\n  const totalStorageBytes = images.reduce((s, img) => s + (img.size || 0), 0);\n\n  const imageStats: ImageStats = {\n    total: images.length,\n    totalStorageBytes,\n    byAspect,\n    byType,\n    bySize,\n    dimensionRange: hasDimensions\n      ? { minWidth: minW, maxWidth: maxW, minHeight: minH, maxHeight: maxH }\n      : null,\n  };\n\n  // =========================================================================\n  // Completeness\n  // =========================================================================\n\n  const entitiesWithImage = entities.filter((e) => e.enrichment?.image?.imageId).length;\n  const totalEras = entities.filter((e) => e.kind === \"era\").length;\n\n  const completeness: CompletenessStats = {\n    entitiesTotal: entities.length,\n    entitiesWithDescription: entities.filter((e) => e.description).length,\n    entitiesWithImage,\n    entitiesWithSummary: entities.filter((e) => e.summary).length,\n    chroniclesTotal: publishedChronicles.length,\n    chroniclesPublished: publishedChronicles.filter((c) => c.status === \"complete\").length,\n    chroniclesWithHistorianNotes: publishedChronicles.filter((c) => c.historianNotes?.length)\n      .length,\n    chroniclesWithSceneImages: publishedChronicles.filter((c) =>\n      c.imageRefs?.refs?.some((r) => r.type === \"prompt_request\" && r.status === \"complete\")\n    ).length,\n    staticPagesTotal: staticPages.length,\n    staticPagesPublished: publishedPages.length,\n    eraNarrativesTotal: totalEras,\n    eraNarrativesComplete: eraNarratives.filter((n) => n.status === \"complete\").length,\n    eraNarrativesWithCoverImage: eraNarratives.filter((n) => n.coverImage?.status === \"complete\")\n      .length,\n  };\n\n  // =========================================================================\n  // Historian Notes\n  // =========================================================================\n\n  const byNoteType: Record<HistorianNoteType, number> = {\n    commentary: 0,\n    correction: 0,\n    tangent: 0,\n    skepticism: 0,\n    pedantic: 0,\n  };\n  for (const note of allHistorianNotes) {\n    if (byNoteType[note.type] !== undefined) {\n      byNoteType[note.type]++;\n    }\n  }\n\n  const historianNoteStats: HistorianNoteStats = {\n    total: allHistorianNotes.length,\n    byType: byNoteType,\n    onEntities: entityHistorianNotes.length,\n    onChronicles: chronicleHistorianNotes.length,\n  };\n\n  return {\n    totalWords,\n    totalChars,\n    estimatedPages: Math.ceil(totalWords / 250),\n    wordBreakdown,\n    charBreakdown,\n    images: imageStats,\n    completeness,\n    historianNotes: historianNoteStats,\n    calculatedAt: Date.now(),\n  };\n}", "parameters": [{"name": "entities", "type": "PersistedEntity[]", "optional": false}, {"name": "chronicles", "type": "ChronicleRecord[]", "optional": false}, {"name": "images", "type": "ImageMetadataRecord[]", "optional": false}, {"name": "staticPages", "type": "StaticPage[]", "optional": false}, {"name": "eraNarratives", "type": "EraNarrativeRecord[]", "optional": false}], "returnType": "PrePrintStats", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../db/illuminatorDb", "specifiers": ["PersistedEntity"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleRecord"], "category": "internal"}, {"source": "../imageTypes", "specifiers": ["ImageRecord", "ImageAspect", "ImageType"], "category": "internal"}, {"source": "../staticPageTypes", "specifiers": ["StaticPage"], "category": "internal"}, {"source": "../eraNarrativeTypes", "specifiers": ["EraNarrativeRecord"], "category": "internal"}, {"source": "../historianTypes", "specifiers": ["HistorianNote", "HistorianNoteType"], "category": "internal"}, {"source": "./prePrintTypes", "specifiers": ["PrePrintStats", "WordCountBreakdown", "CharCountBreakdown", "ImageStats", "CompletenessStats", "HistorianNoteStats"], "category": "internal"}, {"source": "../chronicleTypes", "specifiers": ["ChronicleImageSize"], "category": "internal"}, {"source": "../db/staticPageRepository", "specifiers": ["countWords"], "category": "internal"}, {"source": "../db/eraNarrativeRepository", "specifiers": ["resolveActiveContent"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/workers/tasks/index.ts::executeTask", "name": "executeTask", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/index.ts", "sourceCode": "export async function executeTask<TType extends WorkerTask[\"type\"]>(\n  task: Extract<WorkerTask, { type: TType }>,\n  context: TaskContext\n): Promise<TaskResult> {\n  const handler = TASK_HANDLERS[task.type];\n\n  // Wrap llmClient to auto-inject streaming callbacks into every complete() call.\n  // This is transparent to task handlers \u2014 they call llmClient.complete() as usual.\n  if (context.onThinkingDelta || context.onTextDelta) {\n    const original = context.llmClient;\n    const wrapped = Object.create(original) as typeof original;\n    wrapped.complete = (req) =>\n      original.complete({\n        ...req,\n        onThinkingDelta: context.onThinkingDelta,\n        onTextDelta: context.onTextDelta,\n      });\n    return handler.execute(task, { ...context, llmClient: wrapped });\n  }\n\n  return handler.execute(task, context);\n}", "parameters": [{"name": "task", "type": "Extract<WorkerTask, { type: TType }>", "optional": false}, {"name": "context", "type": "TaskContext", "optional": false}], "returnType": "Promise<TaskResult>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../lib/enrichmentTypes", "specifiers": ["WorkerTask"], "category": "internal"}, {"source": "./taskTypes", "specifiers": ["TaskHandlerMap", "TaskContext"], "category": "internal"}, {"source": "../types", "specifiers": ["TaskResult"], "category": "internal"}, {"source": "./descriptionTask", "specifiers": ["descriptionTask"], "category": "internal"}, {"source": "./visualThesisTask", "specifiers": ["visualThesisTask"], "category": "internal"}, {"source": "./imageTask", "specifiers": ["imageTask"], "category": "internal"}, {"source": "./chronicleTask", "specifiers": ["chronicleTask"], "category": "internal"}, {"source": "./paletteExpansionTask", "specifiers": ["paletteExpansionTask"], "category": "internal"}, {"source": "./dynamicsGenerationTask", "specifiers": ["dynamicsGenerationTask"], "category": "internal"}, {"source": "./summaryRevisionTask", "specifiers": ["summaryRevisionTask"], "category": "internal"}, {"source": "./chronicleLoreBackportTask", "specifiers": ["chronicleLoreBackportTask"], "category": "internal"}, {"source": "./historianEditionTask", "specifiers": ["historianEditionTask"], "category": "internal"}, {"source": "./historianReviewTask", "specifiers": ["historianReviewTask"], "category": "internal"}, {"source": "./historianChronologyTask", "specifiers": ["historianChronologyTask"], "category": "internal"}, {"source": "./historianPrepTask", "specifiers": ["historianPrepTask"], "category": "internal"}, {"source": "./eraNarrativeTask", "specifiers": ["eraNarrativeTask"], "category": "internal"}, {"source": "./motifVariationTask", "specifiers": ["motifVariationTask"], "category": "internal"}, {"source": "./factCoverageTask", "specifiers": ["factCoverageTask"], "category": "internal"}, {"source": "./toneRankingTask", "specifiers": ["toneRankingTask"], "category": "internal"}, {"source": "./bulkToneRankingTask", "specifiers": ["bulkToneRankingTask"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts::getCallConfig", "name": "getCallConfig", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/llmCallConfig.ts", "sourceCode": "export function getCallConfig(config: WorkerConfig, callType: LLMCallType): ResolvedLLMCallConfig {\n  return config.llmCallSettings[callType];\n}", "parameters": [{"name": "config", "type": "WorkerConfig", "optional": false}, {"name": "callType", "type": "LLMCallType", "optional": false}], "returnType": "ResolvedLLMCallConfig", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../lib/llmCallTypes", "specifiers": ["LLMCallType"], "category": "internal"}, {"source": "../../lib/llmModelSettings", "specifiers": ["ResolvedLLMCallConfig"], "category": "internal"}, {"source": "../types", "specifiers": ["WorkerConfig"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::stripLeadingWrapper", "name": "stripLeadingWrapper", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function stripLeadingWrapper(text: string): string {\n  if (!text) return text;\n  return text\n    .replace(/```json\\s*/g, \"\")\n    .replace(/```\\s*/g, \"\")\n    .replace(/^\\s*JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+JSON\\s*:\\s*/i, \"\")\n    .replace(/^\\s*Here\\s+is\\s+the\\s+response\\s*:\\s*/i, \"\")\n    .trim();\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::extractFirstJsonObject", "name": "extractFirstJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function extractFirstJsonObject(text: string): string | null {\n  const state: JsonScanState = { inString: false, escaped: false, depth: 0, start: -1 };\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (state.inString) {\n      handleStringChar(char, state);\n      continue;\n    }\n    const result = handleStructuralChar(char, i, state, text);\n    if (result !== null) return result;\n  }\n\n  return null;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}], "returnType": "string | null", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonObject", "name": "parseJsonObject", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonObject<T extends Record<string, unknown>>(\n  text: string,\n  label?: string\n): T {\n  const parsed = parseJsonValue<T>(text, label);\n  if (!parsed || typeof parsed !== \"object\" || Array.isArray(parsed)) {\n    const name = label ? ` for ${label}` : \"\";\n    console.warn(\"[Parser] JSON parse failed - expected object\", {\n      label: label || \"json\",\n      parsedType: Array.isArray(parsed) ? \"array\" : typeof parsed,\n    });\n    throw new Error(`Expected JSON object${name}`);\n  }\n  return parsed;\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/workers/tasks/textParsing.ts::parseJsonValue", "name": "parseJsonValue", "kind": "function", "filePath": "apps/illuminator/webui/src/workers/tasks/textParsing.ts", "sourceCode": "export function parseJsonValue<T>(text: string, label?: string): T {\n  const cleaned = stripLeadingWrapper(text);\n  const candidate = extractFirstJsonObject(cleaned) || cleaned;\n  const labelName = label || \"json\";\n\n  try {\n    const parsed = JSON.parse(candidate) as T;\n    console.log(\"[Parser] Parsed JSON\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n    });\n    return parsed;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : \"Unknown error\";\n    const prefix = label ? `Failed to parse ${label}: ` : \"Failed to parse JSON: \";\n    console.warn(\"[Parser] JSON parse failed\", {\n      label: labelName,\n      inputChars: text.length,\n      candidateChars: candidate.length,\n      error: message,\n      snippet: candidate.slice(0, 240),\n    });\n    throw new Error(`${prefix}${message}`);\n  }\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "label", "type": "string", "optional": true}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EntryPointStep.tsx", "sourceCode": "export default function EntryPointStep({ entities, relationships, events }: Readonly<EntryPointStepProps>) {\n  const {\n    state,\n    eras,\n    selectEntryPoint,\n    clearEntryPoint,\n    setIncludeErasInNeighborhood,\n    simulationRunId,\n  } = useWizard();\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [sortBy, setSortBy] = useState<SortOption>(\"story-score\");\n  const [hoveredEntityId, setHoveredEntityId] = useState<string | null>(null);\n  const [onlyUnused, setOnlyUnused] = useState(false);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage stats when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageStats(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n        if (isActive) setUsageStats(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Compute story potentials for all entities\n  const entityPotentials = useMemo(() => {\n    return computeAllStoryPotentials(entities, relationships, events);\n  }, [entities, relationships, events]);\n\n  const usageCounts = useMemo(() => {\n    const counts = new Map<string, number>();\n    for (const [id, stats] of usageStats) {\n      counts.set(id, stats.usageCount);\n    }\n    return counts;\n  }, [usageStats]);\n\n  const usageMetrics = useMemo(() => {\n    if (entityPotentials.size === 0) return new Map<string, UsageMetrics>();\n\n    const entityIds = Array.from(entityPotentials.keys());\n    const adjacency = new Map<string, Set<string>>();\n    for (const id of entityIds) adjacency.set(id, new Set());\n\n    for (const rel of relationships) {\n      if (!adjacency.has(rel.src) || !adjacency.has(rel.dst)) continue;\n      adjacency.get(rel.src).add(rel.dst);\n      adjacency.get(rel.dst).add(rel.src);\n    }\n\n    const visitStamp = new Map<string, number>();\n    let stamp = 1;\n    const result = new Map<string, UsageMetrics>();\n\n    for (const id of entityIds) {\n      const usageCount = usageCounts.get(id) ?? 0;\n      const entity = entityPotentials.get(id);\n      const rawProminence = entity ? Number(entity.prominence) : 0;\n      const prominence = Number.isFinite(rawProminence) ? Math.max(0, rawProminence) : 0;\n\n      const firstHop = adjacency.get(id) || new Set<string>();\n      stamp += 1;\n      visitStamp.set(id, stamp);\n\n      let hop1Total = 0;\n      let hop1Unused = 0;\n      for (const neighbor of firstHop) {\n        if (visitStamp.get(neighbor) === stamp) continue;\n        visitStamp.set(neighbor, stamp);\n        hop1Total += 1;\n        if ((usageCounts.get(neighbor) ?? 0) === 0) hop1Unused += 1;\n      }\n\n      let hop2Total = 0;\n      let hop2Unused = 0;\n      for (const neighbor of firstHop) {\n        const neighborHops = adjacency.get(neighbor);\n        if (!neighborHops) continue;\n\n        for (const secondHop of neighborHops) {\n          if (visitStamp.get(secondHop) === stamp) continue;\n          visitStamp.set(secondHop, stamp);\n          hop2Total += 1;\n          if ((usageCounts.get(secondHop) ?? 0) === 0) hop2Unused += 1;\n        }\n      }\n\n      result.set(id, {\n        usageCount,\n        unusedSelf: usageCount === 0,\n        hop1Unused,\n        hop1Total,\n        hop2Unused,\n        hop2Total,\n        underusedScore: prominence / (usageCount + 1),\n        prominence,\n      });\n    }\n\n    return result;\n  }, [entityPotentials, relationships, usageCounts]);\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    return getUniqueKinds(entities);\n  }, [entities]);\n\n  // Era lookups: id -> color and id -> name\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  const eraNameMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const era of eras) {\n      map.set(era.id, era.name);\n    }\n    return map;\n  }, [eras]);\n\n  // Filter and sort entities\n  const filteredEntities = useMemo(() => {\n    let result = [...entityPotentials.values()];\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      result = result.filter((e) => selectedKinds.has(e.kind));\n    }\n\n    // Apply unused filter (requires usage stats)\n    if (onlyUnused && !usageLoading) {\n      result = result.filter((e) => (usageMetrics.get(e.id)?.usageCount ?? 0) === 0);\n    }\n\n    // Sort\n    result.sort((a, b) => {\n      switch (sortBy) {\n        case \"name\":\n          return a.name.localeCompare(b.name);\n        case \"connections\":\n          return b.connectionCount - a.connectionCount;\n        case \"underused\": {\n          const aScore = usageMetrics.get(a.id)?.underusedScore ?? 0;\n          const bScore = usageMetrics.get(b.id)?.underusedScore ?? 0;\n          if (bScore !== aScore) return bScore - aScore;\n          return b.potential.overallScore - a.potential.overallScore;\n        }\n        case \"story-score\":\n        default:\n          return b.potential.overallScore - a.potential.overallScore;\n      }\n    });\n\n    return result;\n  }, [entityPotentials, selectedKinds, sortBy, onlyUnused, usageLoading, usageMetrics]);\n\n  // Get entity for detail panel (hover takes priority over selection)\n  const detailEntity = useMemo(() => {\n    const id = hoveredEntityId || state.entryPointId;\n    if (!id) return null;\n    return entityPotentials.get(id) || null;\n  }, [hoveredEntityId, state.entryPointId, entityPotentials]);\n\n  // Get connections for constellation\n  const detailConnections = useMemo(() => {\n    if (!detailEntity) return [];\n    return getConnectedEntities(detailEntity.id, entities, relationships);\n  }, [detailEntity, entities, relationships]);\n  const detailUsage = useMemo(() => {\n    if (!detailEntity) return null;\n    return usageMetrics.get(detailEntity.id) || null;\n  }, [detailEntity, usageMetrics]);\n\n  const handleSelect = (entity: EntityWithPotential) => {\n    // Click again to deselect\n    if (state.entryPointId === entity.id) {\n      clearEntryPoint();\n      return;\n    }\n    // Convert back to EntityContext for the wizard\n    const { potential, connectionCount, eventCount, connectedKinds, eraIds, ...baseEntity } =\n      entity;\n    selectEntryPoint(baseEntity as EntityContext, entities, relationships, events);\n  };\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"eps-header\">\n        <h4 className=\"eps-title\">Select Entry Point</h4>\n        <p className=\"eps-subtitle\">\n          Choose the central entity for your chronicle. Higher story scores indicate richer\n          narrative potential.\n        </p>\n      </div>\n\n      {/* Two column layout - fixed height to prevent jumping */}\n      <div className=\"eps-layout\">\n        {/* Left: Entity list */}\n        <div className=\"eps-left\">\n          {/* Filter chips */}\n          <div className=\"eps-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n\n          {/* Sort control and options */}\n          <div className=\"eps-sort-row\">\n            <select\n              value={sortBy}\n              onChange={(e) => setSortBy(e.target.value as SortOption)}\n              className=\"illuminator-select eps-sort-select\"\n            >\n              <option value=\"story-score\">Sort by Story Score</option>\n              <option value=\"connections\">Sort by Connections</option>\n              <option value=\"underused\">Sort by Underused Score</option>\n              <option value=\"name\">Sort by Name</option>\n            </select>\n            <label className=\"eps-checkbox-label eps-checkbox-label-muted\">\n              <input\n                type=\"checkbox\"\n                checked={state.includeErasInNeighborhood}\n                onChange={(e) => setIncludeErasInNeighborhood(e.target.checked)}\n                className=\"eps-checkbox\"\n              />\n              Include eras in neighborhood\n            </label>\n            <label\n              className=\"eps-checkbox-label\"\n              style={{\n                '--eps-label-color': usageLoading ? \"var(--text-muted)\" : \"var(--text-secondary)\",\n                '--eps-label-cursor': usageLoading ? \"not-allowed\" : \"pointer\",\n              } as React.CSSProperties}\n            >\n              <input\n                type=\"checkbox\"\n                checked={onlyUnused}\n                onChange={(e) => setOnlyUnused(e.target.checked)}\n                className=\"eps-checkbox\"\n                disabled={usageLoading}\n              />\n              Only unused\n            </label>\n          </div>\n\n          {/* Entity list - fills remaining height */}\n          <div className=\"eps-entity-list\">\n            {filteredEntities.length === 0 ? (\n              <div className=\"eps-empty-list\">\n                No entities match the selected filters.\n              </div>\n            ) : (\n              filteredEntities.map((entity) => {\n                const isSelected = state.entryPointId === entity.id;\n                const isHovered = hoveredEntityId === entity.id;\n                const usage = usageMetrics.get(entity.id);\n\n                return (\n                  <div\n                    key={entity.id}\n                    onClick={() => handleSelect(entity)}\n                    onMouseEnter={() => setHoveredEntityId(entity.id)}\n                    onMouseLeave={() => setHoveredEntityId(null)}\n                    className={`eps-entity-row ${isSelected ? \"eps-entity-row-selected\" : \"\"} ${isHovered && !isSelected ? \"eps-entity-row-hovered\" : \"\"}`}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n// ... (truncated)", "parameters": [{"name": "{ entities, relationships, events }", "type": "Readonly<EntryPointStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect"], "category": "framework"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext", "NarrativeEventContext"], "category": "internal"}, {"source": "../WizardContext", "specifiers": ["useWizard"], "category": "internal"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["computeAllStoryPotentials", "getConnectedEntities", "getUniqueKinds", "EntityWithPotential"], "category": "internal"}, {"source": "../../../lib/db/chronicleRepository", "specifiers": ["getEntityUsageStats"], "category": "internal"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["getEraRanges"], "category": "internal"}, {"source": "../visualizations", "specifiers": ["FilterChips", "StoryPotentialRadarWithScore", "StoryScoreBar", "MiniConstellation"], "category": "internal"}, {"source": "./EntryPointStep.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/EventResolutionStep.tsx", "sourceCode": "export default function EventResolutionStep() {\n  const {\n    state,\n    toggleEvent,\n    toggleRelationship,\n    selectAllEvents,\n    deselectAllEvents,\n    selectAllRelationships,\n    deselectAllRelationships,\n    computeEventMetricsForSelection,\n    temporalContext,\n    detectedFocalEra,\n    eras,\n    setFocalEraOverride,\n    autoFillEvents,\n  } = useWizard();\n\n  const [, setEventMetrics] = useState<Map<string, EventSelectionMetrics>>(new Map());\n  const [brushSelection, setBrushSelection] = useState<[number, number] | null>(null);\n  const [minEventSignificance, setMinEventSignificance] = useState<number>(0);\n\n  // Recompute event metrics when the computation function changes\n  useEffect(() => {\n    const metrics = computeEventMetricsForSelection();\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- sync derived metrics cache to updated computation source\n    setEventMetrics(metrics);\n  }, [computeEventMetricsForSelection]);\n\n  // Get relevant relationships (between assigned entities + lens)\n  const lensEntityIds = useMemo(() => (state.lens ? [state.lens.entityId] : []), [state.lens]);\n\n  const relevantRelationships = useMemo(() => {\n    return getRelevantRelationships(\n      state.roleAssignments,\n      state.candidateRelationships,\n      lensEntityIds\n    );\n  }, [state.roleAssignments, state.candidateRelationships, lensEntityIds]);\n\n  // Get ALL relevant events (involving assigned entities) - before filtering\n  const allRelevantEvents = useMemo(() => {\n    return getRelevantEvents(\n      state.roleAssignments,\n      state.candidateEvents\n    );\n  }, [state.roleAssignments, state.candidateEvents]);\n\n  // Filter events by significance and exclude prominence-only events\n  const relevantEvents = useMemo(() => {\n    const entityIds = new Set(state.roleAssignments.map((a) => a.entityId));\n    return filterChronicleEvents(allRelevantEvents, entityIds, {\n      minSignificance: minEventSignificance,\n      excludeProminenceOnly: true,\n    });\n  }, [allRelevantEvents, state.roleAssignments, minEventSignificance]);\n\n  // Get era ranges directly from era definitions\n  const eraRanges = useMemo(() => {\n    return getEraRanges(eras);\n  }, [eras]);\n\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  const timelineEvents = useMemo(() => {\n    return prepareTimelineEvents(\n      relevantEvents,\n      state.entryPointId,\n      assignedEntityIds,\n      state.selectedEventIds\n    );\n  }, [relevantEvents, state.entryPointId, assignedEntityIds, state.selectedEventIds]);\n\n  const intensityCurve = useMemo(() => {\n    return computeIntensityCurve(relevantEvents);\n  }, [relevantEvents]);\n\n  // Get timeline extent directly from era definitions\n  const timelineExtent = useMemo(() => {\n    return getTimelineExtent(eras);\n  }, [eras]);\n\n  // Build entity map for cast marker lookup\n  const entityMap = useMemo(() => {\n    const map = new Map<string, EntityContext>();\n    for (const entity of state.candidates) {\n      map.set(entity.id, entity);\n    }\n    return map;\n  }, [state.candidates]);\n\n  // Compute cast markers from role assignments, entry point, and lens\n  const castMarkers = useMemo(() => {\n    return prepareCastMarkers(state.roleAssignments, entityMap, state.entryPoint, state.lens);\n  }, [state.roleAssignments, entityMap, state.entryPoint, state.lens]);\n\n  // Collapse bidirectional relationships for display\n  const collapsedRelationships = useMemo(\n    () => collapseBidirectionalRelationships(relevantRelationships),\n    [relevantRelationships]\n  );\n\n  // Get all relationship IDs (flattened from collapsed)\n  const relevantRelationshipIds = useMemo(\n    () => collapsedRelationships.flatMap((cr) => cr.relationshipIds),\n    [collapsedRelationships]\n  );\n\n  const relevantEventIds = useMemo(() => relevantEvents.map((e) => e.id), [relevantEvents]);\n\n  // Count how many selected events are visible (pass the current filter)\n  const visibleSelectedCount = useMemo(() => {\n    const relevantIdSet = new Set(relevantEventIds);\n    return Array.from(state.selectedEventIds).filter((id) => relevantIdSet.has(id)).length;\n  }, [relevantEventIds, state.selectedEventIds]);\n\n  // Auto-select all on first mount if accepting defaults\n  useEffect(() => {\n    if (\n      state.acceptDefaults &&\n      state.selectedRelationshipIds.size === 0 &&\n      state.selectedEventIds.size === 0\n    ) {\n      selectAllRelationships(relevantRelationshipIds);\n      selectAllEvents(relevantEventIds);\n    }\n  }, [\n    state.acceptDefaults,\n    state.selectedRelationshipIds.size,\n    state.selectedEventIds.size,\n    selectAllRelationships,\n    selectAllEvents,\n    relevantRelationshipIds,\n    relevantEventIds,\n  ]);\n\n  // Handle brush selection change - select events in range\n  const handleBrushChange = useCallback(\n    (range: [number, number] | null) => {\n      setBrushSelection(range);\n      if (range) {\n        const eventsInRange = getEventsInRange(timelineEvents, range[0], range[1]);\n        const idsInRange = eventsInRange.map((e) => e.id);\n        // Select only events in range, deselect others\n        const newSelectedIds = new Set(idsInRange);\n        // Update selection\n        for (const id of relevantEventIds) {\n          const inNew = newSelectedIds.has(id);\n          const inCurrent = state.selectedEventIds.has(id);\n          if (inNew !== inCurrent) {\n            toggleEvent(id);\n          }\n        }\n      }\n    },\n    [timelineEvents, relevantEventIds, state.selectedEventIds, toggleEvent]\n  );\n\n  // Effective focal era\n  const effectiveFocalEraId = state.focalEraOverride || detectedFocalEra?.id || null;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ers-header\">\n        <div className=\"ers-header-row\">\n          <div>\n            <h4 className=\"ers-title\">Compose Narrative Arc</h4>\n            <p className=\"ers-subtitle\">\n              Select events from the timeline to build your narrative. Use the brush to select time\n              ranges.\n            </p>\n          </div>\n          <button\n            onClick={() => autoFillEvents(true)}\n            className=\"illuminator-btn ers-btn-sm\"\n          >\n            Auto-fill Events\n          </button>\n        </div>\n\n        {/* Filters */}\n        <div className=\"ers-filters\">\n          {/* Row 1: Focal Era selector */}\n          {temporalContext && (\n            <div className=\"ers-filter-row\">\n              <span className=\"ers-filter-label\">Focal Era:</span>\n              <select\n                value={state.focalEraOverride || temporalContext.focalEra.id}\n                onChange={(e) => {\n                  const selectedId = e.target.value;\n                  if (detectedFocalEra && selectedId === detectedFocalEra.id) {\n                    setFocalEraOverride(null);\n                  } else {\n                    setFocalEraOverride(selectedId);\n                  }\n                }}\n                className=\"illuminator-select ers-filter-select\"\n              >\n                {eras.map((era) => (\n                  <option key={era.id} value={era.id}>\n                    {era.name}\n                    {detectedFocalEra?.id === era.id ? \" (detected)\" : \"\"}\n                  </option>\n                ))}\n              </select>\n              {state.focalEraOverride && (\n                <button\n                  onClick={() => setFocalEraOverride(null)}\n                  className=\"illuminator-btn ers-reset-btn\"\n                >\n                  Reset\n                </button>\n              )}\n            </div>\n          )}\n\n          {/* Row 2: Min Significance selector */}\n          <div className=\"ers-filter-row\">\n            <span className=\"ers-filter-label\">Min Significance:</span>\n            <select\n              value={minEventSignificance}\n              onChange={(e) => setMinEventSignificance(parseFloat(e.target.value))}\n              className=\"illuminator-select ers-filter-select\"\n            >\n              <option value={0}>All (&gt;0%)</option>\n              <option value={0.25}>Low (&gt;25%)</option>\n              <option value={0.5}>Medium (&gt;50%)</option>\n              <option value={0.75}>High (&gt;75%)</option>\n            </select>\n            <span className=\"ers-filter-count\">\n              {relevantEvents.length} events match filter\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Timeline Visualization */}\n      <div className=\"ers-timeline-section\">\n        {/* Intensity Sparkline */}\n        <IntensitySparkline\n          points={intensityCurve}\n          width={700}\n          height={40}\n          extent={timelineExtent}\n          selectedRange={brushSelection}\n        />\n\n        {/* Narrative Timeline with Era Lanes - compact overview */}\n        <div className=\"ers-timeline-gap\">\n          <NarrativeTimeline\n            events={timelineEvents}\n            eraRanges={eraRanges}\n            width={700}\n            height={castMarkers.length > 0 ? 148 : 120}\n            onToggleEvent={toggleEvent}\n            focalEraId={effectiveFocalEraId}\n            extent={timelineExtent}\n            castMarkers={castMarkers}\n          />\n        </div>\n\n        {/* Timeline Brush */}\n        <div className=\"ers-timeline-gap\">\n          <TimelineBrush\n            width={700}\n            height={36}\n            extent={timelineExtent}\n            selection={brushSelection}\n            onSelectionChange={handleBrushChange}\n          />\n        </div>\n\n        {/* Quick actions */}\n        <div className=\"ers-quick-actions\">\n          <button\n            onClick={() => selectAllEvents(relevantEventIds)}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Select All Events\n          </button>\n          <button\n            onClick={() => {\n              deselectAllEvents();\n              setBrushSelection(null);\n            }}\n            className=\"illuminator-btn ers-action-btn\"\n          >\n            Clear Selection\n          </button>\n          <span\n            className=\"ers-selection-count\"\n            style={{\n              '--ers-count-color': state.selectedEventIds.size > MAX_CHRONICLE_EVENTS\n                ? \"var(--error)\"\n                : \"var(--text-muted)\",\n            } as React.CSSProperties}\n          >\n            {visibleSelectedCount} of {relevantEvents.length} visible selected\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useEffect"], "category": "framework"}, {"source": "../WizardContext", "specifiers": ["useWizard"], "category": "internal"}, {"source": "../../../lib/chronicle/selectionWizard", "specifiers": ["getRelevantRelationships", "getRelevantEvents", "filterChronicleEvents", "collapseBidirectionalRelationships", "MAX_CHRONICLE_EVENTS", "EventSelectionMetrics"], "category": "internal"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["getEraRanges", "prepareTimelineEvents", "computeIntensityCurve", "getTimelineExtent", "getEventsInRange", "prepareCastMarkers"], "category": "internal"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}, {"source": "../visualizations", "specifiers": ["IntensitySparkline", "TimelineBrush", "NarrativeTimeline"], "category": "internal"}, {"source": "./EventResolutionStep.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/GenerateStep.tsx", "sourceCode": "export default function GenerateStep({ onGenerate: _onGenerate }: Readonly<GenerateStepProps>) {\n  const { state, setNarrativeDirection } = useWizard();\n\n  // Count primary vs supporting roles\n  const primaryCount = state.roleAssignments.filter((a) => a.isPrimary).length;\n  const supportingCount = state.roleAssignments.length - primaryCount;\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"gs-header\">\n        <h4 className=\"gs-title\">Generate Chronicle</h4>\n        <p className=\"gs-subtitle\">\n          Review your selections and generate the chronicle.\n        </p>\n      </div>\n\n      {/* Summary */}\n      <div className=\"gs-summary\">\n        <div className=\"gs-summary-grid\">\n          {/* Style */}\n          <div>\n            <div className=\"gs-section-label\">\n              Narrative Style\n            </div>\n            <div className=\"gs-section-value\">\n              {state.narrativeStyle?.name}\n              <span\n                className={`gs-format-badge ${state.narrativeStyle?.format === \"story\" ? \"gs-format-badge-story\" : \"gs-format-badge-document\"}`}\n              >\n                {state.narrativeStyle?.format}\n              </span>\n            </div>\n          </div>\n\n          {/* Entry Point */}\n          <div>\n            <div className=\"gs-section-label\">\n              Entry Point\n            </div>\n            <div className=\"gs-section-value\">\n              {state.entryPoint?.name}\n              <span className=\"gs-section-meta\">\n                ({state.entryPoint?.kind})\n              </span>\n            </div>\n          </div>\n\n          {/* Ensemble */}\n          <div>\n            <div className=\"gs-section-label\">\n              Ensemble\n            </div>\n            <div className=\"gs-section-value\">\n              {state.roleAssignments.length} entities\n              <span className=\"gs-section-meta\">\n                ({primaryCount} primary, {supportingCount} supporting)\n              </span>\n            </div>\n          </div>\n\n          {/* Events & Relationships */}\n          <div>\n            <div className=\"gs-section-label\">\n              Context\n            </div>\n            <div className=\"gs-section-value\">\n              {state.selectedEventIds.size} events, {state.selectedRelationshipIds.size}{\" \"}\n              relationships\n            </div>\n          </div>\n        </div>\n\n        {/* Narrative Lens */}\n        {state.lens && (\n          <div className=\"gs-lens-section\">\n            <div className=\"gs-section-label\">\n              Narrative Lens\n            </div>\n            <div className=\"gs-lens-chip\">\n              <span className=\"gs-lens-icon\">&#x25C8;</span>\n              <span className=\"gs-lens-name\">{state.lens.entityName}</span>\n              <span className=\"gs-lens-kind\">\n                ({state.lens.entityKind})\n              </span>\n            </div>\n          </div>\n        )}\n\n        {/* Role Breakdown */}\n        <div className=\"gs-roles-section\">\n          <div className=\"gs-roles-label\">\n            Role Assignments\n          </div>\n          <div className=\"gs-roles-list\">\n            {state.roleAssignments.map((assignment) => (\n              <span\n                key={`${assignment.role}-${assignment.entityId}`}\n                className={`gs-role-chip ${assignment.isPrimary ? \"gs-role-chip-primary\" : \"gs-role-chip-support\"}`}\n                style={{\n                  '--gs-role-opacity': assignment.isPrimary ? 0.9 : 0.7,\n                } as React.CSSProperties}\n              >\n                <span className=\"gs-role-name\">{assignment.role}</span>\n                <span className=\"gs-role-entity\">\n                  {assignment.entityName}\n                </span>\n              </span>\n            ))}\n          </div>\n        </div>\n      </div>\n\n      {/* Narrative Direction */}\n      <div className=\"gs-direction-section\">\n        <div className=\"gs-section-label\">\n          Narrative Direction\n          <span className=\"gs-direction-optional\">\n            optional\n          </span>\n        </div>\n        <p className=\"gs-direction-desc\">\n          Concrete story purpose that shapes perspective and generation. Leave empty for open-ended\n          chronicles.\n        </p>\n        <textarea\n          value={state.narrativeDirection}\n          onChange={(e) => setNarrativeDirection(e.target.value)}\n          placeholder='e.g. \"This is the treaty document that ended the Faction Wars\" or \"An eyewitness account of the apocalyptic magic that ended the Orca Invasion\"'\n          className=\"gs-direction-textarea\"\n        />\n      </div>\n\n      {/* Info Box */}\n      <div className=\"gs-info-box\">\n        <span className=\"gs-info-icon\">\ud83d\udca1</span>\n        <span>\n          Click &quot;Generate Chronicle&quot; to start generation. The complete chronicle will be ready in\n          about 30-60 seconds.\n        </span>\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{ onGenerate: _onGenerate }", "type": "Readonly<GenerateStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../WizardContext", "specifiers": ["useWizard"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./GenerateStep.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/RoleAssignmentStep.tsx", "sourceCode": "export default function RoleAssignmentStep() {\n  const {\n    state,\n    eras,\n    autoFillRoles,\n    addRoleAssignment,\n    removeRoleAssignment,\n    togglePrimary,\n    setLens,\n    clearLens,\n    computeMetrics,\n    simulationRunId,\n  } = useWizard();\n\n  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);\n  const [usageStats, setUsageStats] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [metricsMap, setMetricsMap] = useState<Map<string, EntitySelectionMetrics>>(new Map());\n  const [selectedKinds, setSelectedKinds] = useState<Set<string>>(new Set());\n  const [selectedEras, setSelectedEras] = useState<Set<string>>(new Set());\n  const [connectionFilter, setConnectionFilter] = useState<string | null>(null);\n\n  const style = state.narrativeStyle;\n  const roles = getRoles(style);\n  const maxCastSize = 10;\n\n  // Load usage stats on mount\n  useEffect(() => {\n    if (!simulationRunId) {\n      throw new Error(\"[Chronicle Wizard] simulationRunId is required to load entity usage stats.\");\n    }\n    getEntityUsageStats(simulationRunId)\n      .then((stats) => {\n        setUsageStats(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load entity usage stats:\", err);\n      });\n  }, [simulationRunId]);\n\n  const metricsKey = `${state.candidates.length}|${state.entryPointId}|${usageStats.size}|${state.roleAssignments.length}`;\n  useEffect(() => {\n    if (state.candidates.length === 0 || !state.entryPointId) return;\n    const metrics = computeMetrics(usageStats);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- recompute local metrics cache when candidate inputs change\n    setMetricsMap(metrics);\n  }, [metricsKey, state.candidates.length, state.entryPointId, usageStats]);\n\n  // Get assigned entity IDs\n  const assignedEntityIds = useMemo(() => {\n    return new Set(state.roleAssignments.map((a) => a.entityId));\n  }, [state.roleAssignments]);\n\n  // Validation\n  const validation = useMemo(() => {\n    if (!roles.length) return { valid: true, errors: [], warnings: [] };\n    return validateRoleAssignments(state.roleAssignments, roles, maxCastSize);\n  }, [state.roleAssignments, roles, maxCastSize]);\n\n  // Get selected entity details\n  const selectedEntity = useMemo(() => {\n    if (!selectedEntityId) return null;\n    return state.candidates.find((e) => e.id === selectedEntityId) || null;\n  }, [selectedEntityId, state.candidates]);\n\n  const selectedMetrics = useMemo(() => {\n    if (!selectedEntityId) return undefined;\n    return metricsMap.get(selectedEntityId);\n  }, [selectedEntityId, metricsMap]);\n\n  // Era color map: eraId -> hex color (same palette as timeline)\n  const eraColorMap = useMemo(() => {\n    const map = new Map<string, string>();\n    for (const range of getEraRanges(eras)) {\n      map.set(range.id, range.color);\n    }\n    return map;\n  }, [eras]);\n\n  // Get era name and color for selected entity\n  const selectedEntityEra = useMemo(() => {\n    if (!selectedEntity || eras.length === 0) return undefined;\n    const entityEraId = resolveEntityEraId(selectedEntity);\n    const era = entityEraId ? eras.find((e) => e.id === entityEraId) : undefined;\n    if (!era) return undefined;\n    return { name: era.name, color: eraColorMap.get(era.id) };\n  }, [selectedEntity, eras, eraColorMap]);\n\n  // Handle role assignment\n  const handleAssignToRole = useCallback(\n    (roleId: string) => {\n      if (!selectedEntityId) return;\n\n      const entity = state.candidates.find((e) => e.id === selectedEntityId);\n      if (!entity) return;\n\n      addRoleAssignment({\n        role: roleId,\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n        isPrimary: false,\n      });\n\n      setSelectedEntityId(null);\n    },\n    [selectedEntityId, state.candidates, addRoleAssignment]\n  );\n\n  // Handle remove from role\n  const handleRemoveFromRole = useCallback(\n    (entityId: string, roleId: string) => {\n      removeRoleAssignment(entityId, roleId);\n    },\n    [removeRoleAssignment]\n  );\n\n  // Build kind-to-category map\n  const kindToCategory = useMemo(() => {\n    const map = new Map<string, string>();\n    // Simple mapping - could be domain-specific\n    for (const candidate of state.candidates) {\n      map.set(candidate.kind, candidate.kind);\n    }\n    return map;\n  }, [state.candidates]);\n\n  const handleSetLens = useCallback(\n    (entity: { id: string; name: string; kind: string }) => {\n      const lens: NarrativeLens = {\n        entityId: entity.id,\n        entityName: entity.name,\n        entityKind: entity.kind,\n      };\n      setLens(lens);\n    },\n    [setLens]\n  );\n\n  // Get available kinds for filter chips\n  const availableKinds = useMemo(() => {\n    const kinds = new Set<string>();\n    for (const candidate of state.candidates) {\n      kinds.add(candidate.kind);\n    }\n    return Array.from(kinds).sort((a, b) => a.localeCompare(b));\n  }, [state.candidates]);\n\n  // Available eras from candidates (in era order, only eras with entities)\n  const availableEras = useMemo(() => {\n    const eraIds = new Set<string>();\n    for (const c of state.candidates) {\n      const eraId = resolveEntityEraId(c);\n      if (eraId) eraIds.add(eraId);\n    }\n    return eras.filter((e) => eraIds.has(e.id)).map((e) => e.id);\n  }, [state.candidates, eras]);\n\n  // Build connection maps for filtering\n  const connectionMaps = useMemo(() => {\n    // Map entity ID -> set of assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of state.candidateRelationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    return { connectedToAssigned };\n  }, [state.candidateRelationships, assignedEntityIds]);\n\n  // Filter candidates by selected kinds and connection filter (always include assigned entities)\n  const filteredCandidates = useMemo(() => {\n    let candidates = state.candidates;\n\n    // Apply kind filter\n    if (selectedKinds.size > 0) {\n      candidates = candidates.filter(\n        (c) => selectedKinds.has(c.kind) || assignedEntityIds.has(c.id)\n      );\n    }\n\n    // Apply era filter\n    if (selectedEras.size > 0) {\n      candidates = candidates.filter((c) => {\n        const eraId = resolveEntityEraId(c);\n        return (eraId !== undefined && selectedEras.has(eraId)) || assignedEntityIds.has(c.id);\n      });\n    }\n\n    // Apply connection filter\n    if (connectionFilter && assignedEntityIds.size > 0) {\n      candidates = candidates.filter((c) => {\n        // Always include assigned entities\n        if (assignedEntityIds.has(c.id)) return true;\n\n        const connectedTo = connectionMaps.connectedToAssigned.get(c.id);\n        const connectionCount = connectedTo?.size ?? 0;\n\n        switch (connectionFilter) {\n          case \"linked\":\n            // Connected to at least one assigned entity\n            return connectionCount > 0;\n          case \"bridges\":\n            // Connected to 2+ assigned entities (bridges/connectors)\n            return connectionCount >= 2;\n          default:\n            return true;\n        }\n      });\n    }\n\n    return candidates;\n  }, [\n    state.candidates,\n    selectedKinds,\n    selectedEras,\n    assignedEntityIds,\n    connectionFilter,\n    connectionMaps,\n  ]);\n\n  // Filter relationships to only include those between filtered candidates\n  const filteredRelationships = useMemo(() => {\n    const filteredIds = new Set(filteredCandidates.map((c) => c.id));\n    return state.candidateRelationships.filter(\n      (r) => filteredIds.has(r.src) && filteredIds.has(r.dst)\n    );\n  }, [state.candidateRelationships, filteredCandidates]);\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"ras-header\">\n        <div>\n          <h4 className=\"ras-title\">Build Your Ensemble</h4>\n          <p className=\"ras-subtitle\">\n            Click entities in the constellation to select, then click a role to assign.\n          </p>\n        </div>\n        <button\n          onClick={() => autoFillRoles(metricsMap)}\n          className=\"illuminator-btn ras-autofill-btn\"\n        >\n          Auto-fill Roles\n        </button>\n      </div>\n\n      {/* Validation Messages */}\n      {validation.errors.length > 0 && (\n        <div className=\"ras-errors\">\n          {validation.errors.map((error, i) => (\n            <div key={i} className=\"ras-error\">\n              {error}\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Main layout: Left (constellation + health) | Right (roles + detail) */}\n      <div className=\"ras-layout\">\n        {/* Left: Constellation + Ensemble Health */}\n        <div className=\"ras-left\">\n          {/* Kind filter chips */}\n          <div className=\"ras-filter-gap\">\n            <FilterChips\n              options={availableKinds}\n              selected={selectedKinds}\n              onSelectionChange={setSelectedKinds}\n              label=\"Filter by Kind\"\n            />\n          </div>\n          {/* Era filter chips */}\n          {availableEras.length > 1 && (\n            <div className=\"ras-filter-gap\">\n              <FilterChips\n                options={availableEras}\n                selected={selectedEras}\n                onSelectionChange={setSelectedEras}\n                label=\"Filter by Era\"\n                formatLabel={(eraId) => eras.find((e) => e.id === eraId)?.name ?? eraId}\n                getColor={(eraId) => eraColorMap.get(eraId) ?? \"var(--text-muted)\"}\n              />\n            </div>\n          )}\n          {/* Connection filter */}\n          <div className=\"ras-conn-filter\">\n            <span className=\"ras-conn-label\">Show:</span>\n            {[\n              { id: null, label: \"All\" },\n              { id: \"linked\", label: \"Linked to ensemble\" },\n              { id: \"bridges\", label: \"Bridges (2+ links)\" },\n// ... (truncated)", "parameters": [], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect", "useCallback"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["StoryNarrativeStyle", "DocumentNarrativeStyle", "RoleDefinition"], "category": "external"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["NarrativeLens"], "category": "internal"}, {"source": "../WizardContext", "specifiers": ["useWizard"], "category": "internal"}, {"source": "../../../lib/chronicle/selectionWizard", "specifiers": ["validateRoleAssignments", "EntitySelectionMetrics"], "category": "internal"}, {"source": "../../../lib/db/chronicleRepository", "specifiers": ["getEntityUsageStats"], "category": "internal"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["getEraRanges"], "category": "internal"}, {"source": "../visualizations", "specifiers": ["EnsembleConstellation", "RoleSlot", "EntityDetailCard", "EnsembleHealthBar", "FilterChips"], "category": "internal"}, {"source": "./RoleAssignmentStep.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/steps/StyleStep.tsx", "sourceCode": "export default function StyleStep({ styles }: Readonly<StyleStepProps>) {\n  const { state, selectStyle, setAcceptDefaults, simulationRunId } = useWizard();\n  const [searchText, setSearchText] = useState(\"\");\n  const [formatFilter, setFormatFilter] = useState<\"all\" | \"story\" | \"document\">(\"all\");\n  const [styleUsage, setStyleUsage] = useState<Map<string, { usageCount: number }>>(new Map());\n  const [usageLoading, setUsageLoading] = useState(false);\n\n  // Clear usage when no simulationRunId\n  useEffect(() => {\n    if (simulationRunId) return;\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setStyleUsage(new Map());\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- clear async usage state when simulation is unset\n    setUsageLoading(false);\n  }, [simulationRunId]);\n\n  useEffect(() => {\n    if (!simulationRunId) return;\n\n    let isActive = true;\n    setUsageLoading(true);\n\n    getNarrativeStyleUsageStats(simulationRunId)\n      .then((stats) => {\n        if (isActive) setStyleUsage(stats);\n      })\n      .catch((err) => {\n        console.error(\"[Chronicle Wizard] Failed to load narrative style usage stats:\", err);\n        if (isActive) setStyleUsage(new Map());\n      })\n      .finally(() => {\n        if (isActive) setUsageLoading(false);\n      });\n\n    return () => {\n      isActive = false;\n    };\n  }, [simulationRunId]);\n\n  // Filter styles\n  const filteredStyles = useMemo(() => {\n    return styles.filter((style) => {\n      // Format filter\n      if (formatFilter !== \"all\" && style.format !== formatFilter) {\n        return false;\n      }\n      // Search filter\n      if (searchText.trim()) {\n        const search = searchText.toLowerCase();\n        return (\n          style.name.toLowerCase().includes(search) ||\n          style.description.toLowerCase().includes(search) ||\n          style.tags?.some((tag) => tag.toLowerCase().includes(search))\n        );\n      }\n      return true;\n    });\n  }, [styles, formatFilter, searchText]);\n\n  // Group by format\n  const storyStyles = filteredStyles.filter((s) => s.format === \"story\");\n  const documentStyles = filteredStyles.filter((s) => s.format === \"document\");\n\n  return (\n    <div>\n      {/* Header */}\n      <div className=\"sstep-header\">\n        <h4 className=\"sstep-title\">Select Narrative Style</h4>\n        <p className=\"sstep-subtitle\">\n          Choose a style that defines the structure and roles for your chronicle.\n        </p>\n      </div>\n\n      {/* Filters */}\n      <div className=\"sstep-filters\">\n        <input\n          type=\"text\"\n          value={searchText}\n          onChange={(e) => setSearchText(e.target.value)}\n          placeholder=\"Search styles...\"\n          className=\"illuminator-input sstep-search\"\n        />\n        <select\n          value={formatFilter}\n          onChange={(e) => setFormatFilter(e.target.value as \"all\" | \"story\" | \"document\")}\n          className=\"illuminator-select\"\n        >\n          <option value=\"all\">All Formats</option>\n          <option value=\"story\">Stories</option>\n          <option value=\"document\">Documents</option>\n        </select>\n\n        {/* Accept Defaults Checkbox */}\n        <label className=\"sstep-defaults-label\">\n          <input\n            type=\"checkbox\"\n            checked={state.acceptDefaults}\n            onChange={(e) => setAcceptDefaults(e.target.checked)}\n          />\n          Accept defaults for quick generation\n        </label>\n      </div>\n\n      {/* Styles Grid */}\n      <div className=\"sstep-scroll\">\n        {formatFilter === \"all\" || formatFilter === \"story\" ? (\n          <>\n            {storyStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Story Styles ({storyStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid sstep-grid-mb\">\n              {storyStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {formatFilter === \"all\" || formatFilter === \"document\" ? (\n          <>\n            {documentStyles.length > 0 && formatFilter === \"all\" && (\n              <h5 className=\"sstep-group-heading\">\n                Document Styles ({documentStyles.length})\n              </h5>\n            )}\n            <div className=\"sstep-grid\">\n              {documentStyles.map((style) => (\n                <StyleCard\n                  key={style.id}\n                  style={style}\n                  isSelected={state.narrativeStyleId === style.id}\n                  usageCount={styleUsage.get(style.id)?.usageCount ?? 0}\n                  usageLoading={usageLoading}\n                  onSelect={() => selectStyle(style, state.acceptDefaults)}\n                />\n              ))}\n            </div>\n          </>\n        ) : null}\n\n        {filteredStyles.length === 0 && (\n          <div className=\"sstep-empty\">\n            No styles match your search.\n          </div>\n        )}\n      </div>\n\n      {/* Selected Style Details */}\n      {state.narrativeStyle && (\n        <div className=\"sstep-selected-detail\">\n          <h5 className=\"sstep-selected-name\">\n            {state.narrativeStyle.name}\n            <span\n              className={`sstep-format-badge ${state.narrativeStyle.format === \"story\" ? \"sstep-format-badge-story\" : \"sstep-format-badge-document\"}`}\n            >\n              {state.narrativeStyle.format}\n            </span>\n          </h5>\n          <p className=\"sstep-selected-desc\">\n            {state.narrativeStyle.description}\n          </p>\n          <div className=\"sstep-usage-info\">\n            {usageLoading\n              ? \"Usage in this run: \u2026\"\n              : `Usage in this run: ${styleUsage.get(state.narrativeStyle.id)?.usageCount ?? 0}x`}\n          </div>\n\n          {/* Role Requirements */}\n          <div>\n            <span className=\"sstep-roles-label\">\n              Required Roles:\n            </span>\n            <div className=\"sstep-roles-list\">\n              {getRoles(state.narrativeStyle).map((role) => (\n                <span\n                  key={role.role}\n                  className=\"sstep-role-chip\"\n                  title={role.description}\n                >\n                  {role.role}\n                  <span className=\"sstep-role-count\">\n                    ({role.count.min}-{role.count.max})\n                  </span>\n                </span>\n              ))}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ styles }", "type": "Readonly<StyleStepProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useEffect"], "category": "framework"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "RoleDefinition"], "category": "external"}, {"source": "../WizardContext", "specifiers": ["useWizard"], "category": "internal"}, {"source": "../../../lib/db/chronicleRepository", "specifiers": ["getNarrativeStyleUsageStats"], "category": "internal"}, {"source": "./StyleStep.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleConstellation.tsx", "sourceCode": "export default function EnsembleConstellation({\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}: Readonly<EnsembleConstellationProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredNodeId, setHoveredNodeId] = useState<string | null>(null);\n\n  // Compute layout\n  const nodes = useMemo(() => {\n    const layout = computeLayout(entryPointId, candidates, metricsMap, width, height);\n    const candidateMap = new Map(candidates.map((c) => [c.id, c]));\n    return layout.map((node) => {\n      const candidate = candidateMap.get(node.id);\n      const eraId = candidate?.eraId && candidate.eraId.length > 0 ? candidate.eraId : undefined;\n      return {\n        ...node,\n        isAssigned: assignedEntityIds.has(node.id),\n        eraColor: eraId ? (eraColorMap?.get(eraId) ?? \"#6b7280\") : \"#6b7280\",\n      };\n    });\n  }, [entryPointId, candidates, metricsMap, width, height, assignedEntityIds, eraColorMap]);\n\n  const nodeMap = useMemo(() => {\n    return new Map(nodes.map((n) => [n.id, n]));\n  }, [nodes]);\n\n  // Compute edges\n  const edges = useMemo(() => {\n    const nodeIds = new Set(nodes.map((n) => n.id));\n    return computeEdges(relationships, nodeIds);\n  }, [relationships, nodes]);\n\n  // Compute bridge nodes (unassigned nodes connected to 2+ unique assigned entities)\n  const bridgeNodeIds = useMemo(() => {\n    // Map entity ID -> set of unique assigned entity IDs it connects to\n    const connectedToAssigned = new Map<string, Set<string>>();\n\n    for (const rel of relationships) {\n      const srcAssigned = assignedEntityIds.has(rel.src);\n      const dstAssigned = assignedEntityIds.has(rel.dst);\n\n      if (srcAssigned && !dstAssigned) {\n        if (!connectedToAssigned.has(rel.dst)) connectedToAssigned.set(rel.dst, new Set());\n        connectedToAssigned.get(rel.dst).add(rel.src);\n      }\n      if (dstAssigned && !srcAssigned) {\n        if (!connectedToAssigned.has(rel.src)) connectedToAssigned.set(rel.src, new Set());\n        connectedToAssigned.get(rel.src).add(rel.dst);\n      }\n    }\n\n    const bridges = new Set<string>();\n    for (const [id, assignedConnections] of connectedToAssigned) {\n      if (assignedConnections.size >= 2) bridges.add(id);\n    }\n    return bridges;\n  }, [relationships, assignedEntityIds]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  const handleNodeClick = useCallback(\n    (nodeId: string) => {\n      if (selectedEntityId === nodeId) {\n        onSelectEntity(null);\n      } else {\n        onSelectEntity(nodeId);\n      }\n    },\n    [selectedEntityId, onSelectEntity]\n  );\n\n  // Determine node visual properties\n  const getNodeStyle = (node: ConstellationNode) => {\n    const isSelected = selectedEntityId === node.id;\n    const isHovered = hoveredNodeId === node.id;\n    const metrics = node.metrics;\n\n    // Base size\n    let radius = node.isEntryPoint ? 18 : 12;\n    if (isSelected || isHovered) radius += 2;\n\n    // Overused indicator\n    const isOverused = metrics && metrics.usageCount >= 5;\n\n    return { radius, isOverused, isSelected, isHovered };\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"ec-svg\"\n    >\n      {/* Orbit guides */}\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.25}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.5}\n      />\n      <circle\n        cx={width / 2}\n        cy={height / 2}\n        r={Math.min(width, height) * 0.42}\n        fill=\"none\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n        strokeDasharray=\"4,4\"\n        opacity={0.3}\n      />\n\n      {/* Edges */}\n      {edges.map((edge, i) => {\n        const source = nodeMap.get(edge.source);\n        const target = nodeMap.get(edge.target);\n        if (!source || !target) return null;\n\n        const sourceAssigned = assignedEntityIds.has(edge.source);\n        const targetAssigned = assignedEntityIds.has(edge.target);\n        const sourceSelected = selectedEntityId === edge.source || hoveredNodeId === edge.source;\n        const targetSelected = selectedEntityId === edge.target || hoveredNodeId === edge.target;\n\n        // Determine edge color and style based on node states\n        let strokeColor = \"var(--border-color)\";\n        let strokeOpacity = 0.2;\n        let strokeWidth = 1 + edge.strength * 1.5;\n\n        if (sourceAssigned && targetAssigned) {\n          // Both assigned - green, prominent\n          strokeColor = \"var(--success)\";\n          strokeOpacity = 0.7;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if ((sourceAssigned && targetSelected) || (targetAssigned && sourceSelected)) {\n          // One assigned, one selected - orange/gold\n          strokeColor = \"var(--warning)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceSelected || targetSelected) {\n          // One selected, neither assigned - purple\n          strokeColor = \"var(--accent-color)\";\n          strokeOpacity = 0.8;\n          strokeWidth = 2 + edge.strength * 2;\n        } else if (sourceAssigned || targetAssigned) {\n          // One assigned, not selected - cyan to show potential ensemble connections\n          strokeColor = \"#06b6d4\"; // cyan\n          strokeOpacity = 0.5;\n          strokeWidth = 1.5 + edge.strength * 1.5;\n        }\n\n        return (\n          <line\n            key={i}\n            x1={source.x}\n            y1={source.y}\n            x2={target.x}\n            y2={target.y}\n            stroke={strokeColor}\n            strokeWidth={strokeWidth}\n            strokeOpacity={strokeOpacity}\n          />\n        );\n      })}\n\n      {/* Nodes */}\n      {nodes.map((node) => {\n        const style = getNodeStyle(node);\n        const color = getKindColor(node.kind);\n\n        return (\n          <g\n            key={node.id}\n            className=\"ec-cursor-pointer\"\n            onClick={() => handleNodeClick(node.id)}\n            onMouseEnter={() => setHoveredNodeId(node.id)}\n            onMouseLeave={() => setHoveredNodeId(null)}\n          >\n            {/* Overused glow */}\n            {style.isOverused && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 4}\n                fill=\"none\"\n                stroke=\"var(--error)\"\n                strokeWidth={2}\n                opacity={0.6}\n              />\n            )}\n\n            {/* Selection ring */}\n            {style.isSelected && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 3}\n                fill=\"none\"\n                stroke=\"var(--accent-color)\"\n                strokeWidth={2}\n              />\n            )}\n\n            {/* Bridge indicator (unassigned node connected to 2+ assigned) */}\n            {!node.isAssigned && !node.isEntryPoint && bridgeNodeIds.has(node.id) && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"#f59e0b\"\n                strokeWidth={2}\n                strokeDasharray=\"2,2\"\n              />\n            )}\n\n            {/* Assigned indicator */}\n            {node.isAssigned && !node.isEntryPoint && (\n              <circle\n                cx={node.x}\n                cy={node.y}\n                r={style.radius + 2}\n                fill=\"none\"\n                stroke=\"var(--success)\"\n                strokeWidth={2}\n                strokeDasharray=\"3,2\"\n              />\n            )}\n\n            {/* Node circle with era-colored ring */}\n            <circle\n              cx={node.x}\n              cy={node.y}\n              r={style.radius}\n              fill={node.isEntryPoint ? \"var(--accent-color)\" : color}\n              stroke={style.isHovered ? \"white\" : node.eraColor}\n              strokeWidth={2}\n            />\n\n            {/* Entry point star */}\n            {node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={5}\n                fontSize=\"14\"\n                fill=\"white\"\n                fontWeight=\"bold\"\n                className=\"ec-no-pointer\"\n              >\n                \u2605\n              </text>\n            )}\n\n            {/* Kind initial for non-entry-point nodes */}\n            {!node.isEntryPoint && (\n              <text\n                x={node.x}\n                y={node.y}\n                textAnchor=\"middle\"\n                dy={4}\n                fontSize=\"9\"\n                fill=\"white\"\n                fontWeight=\"500\"\n                className=\"ec-no-pointer\"\n              >\n                {node.kind.charAt(0).toUpperCase()}\n              </text>\n            )}\n          </g>\n        );\n      })}\n\n      {/* Tooltip layer - rendered on top of all nodes */}\n      {(() => {\n        const tooltipNodeId = hoveredNodeId || selectedEntityId;\n        const tooltipNode = tooltipNodeId ? nodeMap.get(tooltipNodeId) : null;\n        if (!tooltipNode) return null;\n\n        const style = getNodeStyle(tooltipNode);\n        const metrics = tooltipNode.metrics;\n        const usageCount = metrics?.usageCount ?? 0;\n        const linksToEnsemble = (() => {\n          if (tooltipNode.isAssigned) return null; // Don't show for assigned\n          let count = 0;\n          for (const rel of relationships) {\n// ... (truncated)", "parameters": [{"name": "{\n  entryPointId,\n  candidates,\n  relationships,\n  assignedEntityIds,\n  metricsMap,\n  selectedEntityId,\n  onSelectEntity,\n  width = 400,\n  height = 350,\n  eraColorMap,\n}", "type": "Readonly<EnsembleConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef"], "category": "framework"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["EntityContext", "RelationshipContext"], "category": "internal"}, {"source": "../../../lib/chronicle/selectionWizard", "specifiers": ["EntitySelectionMetrics"], "category": "internal"}, {"source": "./EnsembleConstellation.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EnsembleHealthBar.tsx", "sourceCode": "export default function EnsembleHealthBar({\n  assignments,\n  candidates,\n  kindToCategory,\n}: Readonly<EnsembleHealthBarProps>) {\n  // Compute category stats\n  const stats = useMemo(() => {\n    // Get all unique categories from candidates\n    const allCategories = new Set<string>();\n    const kindMap = kindToCategory || new Map<string, string>();\n\n    for (const candidate of candidates) {\n      const category = kindMap.get(candidate.kind) || candidate.kind;\n      allCategories.add(category);\n    }\n\n    // Count assigned categories\n    const assignedCategories = new Map<string, number>();\n    for (const assignment of assignments) {\n      const category = kindMap.get(assignment.entityKind) || assignment.entityKind;\n      assignedCategories.set(category, (assignedCategories.get(category) || 0) + 1);\n    }\n\n    // Find missing categories\n    const missingCategories: string[] = [];\n    for (const category of allCategories) {\n      if (!assignedCategories.has(category)) {\n        missingCategories.push(category);\n      }\n    }\n\n    // Calculate coverage percentage\n    const coveredCount = assignedCategories.size;\n    const totalCount = allCategories.size;\n    const coveragePercent = totalCount > 0 ? (coveredCount / totalCount) * 100 : 0;\n\n    return {\n      categories: [...allCategories],\n      assignedCategories,\n      missingCategories,\n      coveragePercent,\n      coveredCount,\n      totalCount,\n    };\n  }, [assignments, candidates, kindToCategory]);\n\n  const getColor = (category: string): string => {\n    return CATEGORY_COLORS[category.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (stats.totalCount === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"ehb-wrap\">\n      {/* Header */}\n      <div className=\"ehb-header\">\n        <span className=\"ehb-title\">\n          Ensemble Diversity\n        </span>\n        <span\n          className=\"ehb-count\"\n          style={{\n            '--ehb-count-color': stats.coveragePercent === 100 ? \"var(--success)\" : \"var(--text-muted)\",\n          } as React.CSSProperties}\n        >\n          {stats.coveredCount}/{stats.totalCount} categories\n        </span>\n      </div>\n\n      {/* Segmented bar */}\n      <div className=\"ehb-bar\">\n        {stats.categories.map((category, i) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const width = `${100 / stats.totalCount}%`;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              title={`${category}: ${count} assigned`}\n              className=\"ehb-bar-segment\"\n              style={{\n                '--ehb-seg-width': width,\n                '--ehb-seg-bg': isCovered ? color : \"transparent\",\n                '--ehb-seg-opacity': isCovered ? 1 : 0.3,\n                '--ehb-seg-border': i < stats.categories.length - 1 ? \"1px solid var(--bg-tertiary)\" : \"none\",\n              } as React.CSSProperties}\n            />\n          );\n        })}\n      </div>\n\n      {/* Category legend */}\n      <div\n        className=\"ehb-legend\"\n        style={{\n          '--ehb-legend-mb': stats.missingCategories.length > 0 ? \"8px\" : \"0\",\n        } as React.CSSProperties}\n      >\n        {stats.categories.map((category) => {\n          const count = stats.assignedCategories.get(category) || 0;\n          const isCovered = count > 0;\n          const color = getColor(category);\n\n          return (\n            <div\n              key={category}\n              className=\"ehb-legend-item\"\n              style={{\n                '--ehb-item-color': isCovered ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                '--ehb-item-opacity': isCovered ? 1 : 0.6,\n              } as React.CSSProperties}\n            >\n              <span\n                className=\"ehb-legend-dot\"\n                style={{\n                  '--ehb-dot-bg': isCovered ? color : \"var(--bg-secondary)\",\n                  '--ehb-dot-border': isCovered ? \"none\" : `1px solid ${color}`,\n                } as React.CSSProperties}\n              />\n              <span className=\"ehb-legend-label\">\n                {category}\n                {count > 1 && ` (${count})`}\n              </span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Missing categories warning */}\n      {stats.missingCategories.length > 0 && (\n        <div className=\"ehb-warning\">\n          <span className=\"ehb-warning-icon\">\ud83d\udca1</span>\n          <span>\n            Consider adding:{\" \"}\n            {stats.missingCategories.map((cat, i) => (\n              <span key={cat}>\n                <span className=\"ehb-missing-cat\">{cat}</span>\n                {i < stats.missingCategories.length - 1 && \", \"}\n              </span>\n            ))}\n          </span>\n        </div>\n      )}\n\n      {/* All covered celebration */}\n      {stats.missingCategories.length === 0 && stats.totalCount > 1 && (\n        <div className=\"ehb-success\">\n          <span>\u2713</span>\n          <span>All categories represented - diverse ensemble!</span>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  assignments,\n  candidates,\n  kindToCategory,\n}", "type": "Readonly<EnsembleHealthBarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment"], "category": "internal"}, {"source": "./EnsembleHealthBar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/EntityDetailCard.tsx", "sourceCode": "export default function EntityDetailCard({\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}: Readonly<EntityDetailCardProps>) {\n  // Empty state\n  if (!entity) {\n    return (\n      <div className=\"edc-empty\">\n        <div className=\"edc-empty-sub\">No entity selected</div>\n        <div className=\"edc-empty-hint\">Click a node to see details</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edc-card\">\n      {/* Header - compact */}\n      <div className=\"edc-header\">\n        <div className=\"edc-name-row\">\n          {entity.name}\n          {isEntryPoint && (\n            <span className=\"edc-entry-badge\">\n              Entry\n            </span>\n          )}\n          {isAssigned && !isEntryPoint && (\n            <span className=\"edc-assigned-badge\">\n              Assigned\n            </span>\n          )}\n        </div>\n        <div className=\"edc-kind-line\">\n          {entity.kind}\n          {entity.subtype && ` \u00b7 ${entity.subtype}`}\n        </div>\n      </div>\n\n      {/* Metrics - two rows: stats on top, story effects below */}\n      {(metrics || eraName) && (\n        <div className=\"edc-metrics\">\n          {/* Row 1: Basic stats */}\n          <div className=\"edc-metric-row\">\n            {metrics && (\n              <>\n                <MetricChip\n                  label={(() => {\n                    if (metrics.distance === 0) return \"Entry\";\n                    if (metrics.distance === 1) return \"Direct\";\n                    if (metrics.distance >= 99) return \"Distant\";\n                    return `${metrics.distance}-hop`;\n                  })()}\n                />\n                <MetricChip\n                  label={`${metrics.usageCount}x used`}\n                  variant={(() => {\n                    if (metrics.usageCount >= 5) return \"error\" as const;\n                    if (metrics.usageCount >= 2) return \"warning\" as const;\n                    return \"default\" as const;\n                  })()}\n                />\n                <MetricChip label={`${(metrics.avgStrength * 100).toFixed(0)}% link`} />\n              </>\n            )}\n            {eraName && <MetricChip label={eraName} customColor={eraColor} />}\n          </div>\n          {/* Row 2: Story effects (always separate line) */}\n          {(metrics?.addsNewCategory || (metrics && metrics.newRelTypes > 0)) && (\n            <div className=\"edc-metric-row\">\n              {metrics?.addsNewCategory && <MetricChip label=\"+category\" variant=\"accent\" />}\n              {metrics && metrics.newRelTypes > 0 && (\n                <MetricChip label={`+${metrics.newRelTypes} rel`} variant=\"accent\" />\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  entity,\n  metrics,\n  eraName,\n  eraColor,\n  isEntryPoint = false,\n  isAssigned = false,\n}", "type": "Readonly<EntityDetailCardProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../../../lib/chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}, {"source": "../../../lib/chronicle/selectionWizard", "specifiers": ["EntitySelectionMetrics"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./EntityDetailCard.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/FilterChips.tsx", "sourceCode": "export default function FilterChips<T extends string>({\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}: Readonly<FilterChipsProps<T>>) {\n  const handleChipClick = (option: T) => {\n    const newSelected = new Set(selected);\n\n    if (newSelected.has(option)) {\n      newSelected.delete(option);\n    } else {\n      if (!multiSelect) {\n        newSelected.clear();\n      }\n      newSelected.add(option);\n    }\n\n    onSelectionChange(newSelected);\n  };\n\n  const handleClearAll = () => {\n    onSelectionChange(new Set());\n  };\n\n  const getChipColor = (option: T): string => {\n    if (getColor) return getColor(option);\n    return KIND_COLORS[option.toLowerCase()] || \"var(--accent-color)\";\n  };\n\n  const getDisplayLabel = (option: T): string => {\n    if (formatLabel) return formatLabel(option);\n    // Capitalize first letter\n    return option.charAt(0).toUpperCase() + option.slice(1);\n  };\n\n  return (\n    <div className=\"fc-wrap\">\n      {label && (\n        <div className=\"fc-header\">\n          <span className=\"fc-label\">\n            {label}\n          </span>\n          {selected.size > 0 && (\n            <button\n              onClick={handleClearAll}\n              className=\"fc-clear-btn\"\n            >\n              Clear\n            </button>\n          )}\n        </div>\n      )}\n\n      <div className=\"fc-chips\">\n        {options.map((option) => {\n          const isSelected = selected.has(option);\n          const color = getChipColor(option);\n\n          return (\n            <button\n              key={option}\n              onClick={() => handleChipClick(option)}\n              className=\"fc-chip\"\n              style={{\n                '--fc-chip-border': isSelected ? `1px solid ${color}` : \"1px solid var(--border-color)\",\n                '--fc-chip-bg': isSelected ? color : \"transparent\",\n                '--fc-chip-color': isSelected ? \"white\" : \"var(--text-secondary)\",\n                '--fc-chip-weight': isSelected ? 500 : 400,\n              } as React.CSSProperties}\n            >\n              {/* Color dot when not selected */}\n              {!isSelected && (\n                <span\n                  className=\"fc-chip-dot\"\n                  style={{\n                    '--fc-dot-bg': color,\n                  } as React.CSSProperties}\n                />\n              )}\n              {getDisplayLabel(option)}\n            </button>\n          );\n        })}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  options,\n  selected,\n  onSelectionChange,\n  label,\n  multiSelect = true,\n  formatLabel,\n  getColor,\n}", "type": "Readonly<FilterChipsProps<T>>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./FilterChips.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/IntensitySparkline.tsx", "sourceCode": "export default function IntensitySparkline({\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}: Readonly<IntensitySparklineProps>) {\n  // Match padding with NarrativeTimeline for visual alignment\n  const padding = { left: 40, right: 40, top: 4, bottom: 4 };\n  const innerWidth = width - padding.left - padding.right;\n  const innerHeight = height - padding.top - padding.bottom;\n\n  // Build the SVG path\n  const { areaPath, linePath } = useMemo(() => {\n    if (points.length < 2) {\n      return { areaPath: \"\", linePath: \"\" };\n    }\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const scaleY = (intensity: number) => padding.top + (1 - intensity) * innerHeight;\n\n    // Build line path\n    const lineParts: string[] = [];\n    const areaParts: string[] = [];\n\n    points.forEach((point, i) => {\n      const x = scaleX(point.tick);\n      const y = scaleY(point.intensity);\n\n      if (i === 0) {\n        lineParts.push(`M ${x} ${y}`);\n        areaParts.push(`M ${x} ${height - padding.bottom}`);\n        areaParts.push(`L ${x} ${y}`);\n      } else {\n        lineParts.push(`L ${x} ${y}`);\n        areaParts.push(`L ${x} ${y}`);\n      }\n    });\n\n    // Close the area path\n    const lastX = scaleX(points[points.length - 1].tick);\n    areaParts.push(`L ${lastX} ${height - padding.bottom}`);\n    areaParts.push(\"Z\");\n\n    return {\n      areaPath: areaParts.join(\" \"),\n      linePath: lineParts.join(\" \"),\n    };\n  }, [points, extent, innerWidth, innerHeight, height, padding]);\n\n  // Build highlight rect for selected range\n  const highlightRect = useMemo(() => {\n    if (!selectedRange) return null;\n\n    const [minTick, maxTick] = extent;\n    const tickRange = maxTick - minTick || 1;\n\n    const scaleX = (tick: number) => padding.left + ((tick - minTick) / tickRange) * innerWidth;\n\n    const x1 = scaleX(selectedRange[0]);\n    const x2 = scaleX(selectedRange[1]);\n\n    return {\n      x: Math.min(x1, x2),\n      width: Math.abs(x2 - x1),\n    };\n  }, [selectedRange, extent, innerWidth, padding]);\n\n  if (points.length < 2) {\n    return (\n      <svg width={width} height={height}>\n        <text\n          x={width / 2}\n          y={height / 2}\n          textAnchor=\"middle\"\n          fontSize=\"10\"\n          fill=\"var(--text-muted)\"\n        >\n          Not enough data\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={width} height={height} className=\"is-svg\">\n      {/* Selected range highlight */}\n      {highlightRect && (\n        <rect\n          x={highlightRect.x}\n          y={0}\n          width={highlightRect.width}\n          height={height}\n          fill=\"rgba(99, 102, 241, 0.15)\"\n        />\n      )}\n\n      {/* Area fill */}\n      <path d={areaPath} fill={fillColor} />\n\n      {/* Line stroke */}\n      <path d={linePath} fill=\"none\" stroke={strokeColor} strokeWidth={1.5} />\n\n      {/* Label */}\n      <text x={4} y={12} fontSize=\"9\" fill=\"var(--text-muted)\" fontFamily=\"inherit\">\n        Narrative Intensity\n      </text>\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  points,\n  width,\n  height,\n  extent,\n  selectedRange,\n  fillColor = \"rgba(99, 102, 241, 0.2)\",\n  strokeColor = \"rgba(99, 102, 241, 0.6)\",\n}", "type": "Readonly<IntensitySparklineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["IntensityPoint"], "category": "internal"}, {"source": "./IntensitySparkline.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/MiniConstellation.tsx", "sourceCode": "export default function MiniConstellation({\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}: Readonly<MiniConstellationProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const centerRadius = 16;\n  const nodeRadius = 10;\n  const orbitRadius = size / 2 - nodeRadius - 12;\n\n  // Limit and arrange connections\n  const visibleConnections = useMemo(() => {\n    // Group by kind and take most diverse sample\n    const byKind = new Map<string, ConnectedEntity[]>();\n    for (const conn of connections) {\n      const list = byKind.get(conn.kind) || [];\n      list.push(conn);\n      byKind.set(conn.kind, list);\n    }\n\n    // Take one from each kind first, then fill remaining\n    const result: ConnectedEntity[] = [];\n    const kindIterators = [...byKind.values()].map((list) => list[Symbol.iterator]());\n\n    while (result.length < maxConnections && kindIterators.length > 0) {\n      for (let i = kindIterators.length - 1; i >= 0; i--) {\n        if (result.length >= maxConnections) break;\n        const next = kindIterators[i].next();\n        if (next.done) {\n          kindIterators.splice(i, 1);\n        } else {\n          result.push(next.value);\n        }\n      }\n    }\n\n    return result;\n  }, [connections, maxConnections]);\n\n  const hiddenCount = connections.length - visibleConnections.length;\n\n  // Position nodes in a circle\n  const nodePositions = useMemo(() => {\n    const count = visibleConnections.length;\n    if (count === 0) return [];\n\n    const angleStep = (2 * Math.PI) / count;\n    const startAngle = -Math.PI / 2; // Start from top\n\n    return visibleConnections.map((conn, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        ...conn,\n        x: cx + orbitRadius * Math.cos(angle),\n        y: cy + orbitRadius * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [visibleConnections, cx, cy, orbitRadius]);\n\n  const getKindColor = (kind: string): string => {\n    return KIND_COLORS[kind.toLowerCase()] || \"var(--text-muted)\";\n  };\n\n  if (connections.length === 0) {\n    return (\n      <svg width={size} height={size} className=\"mc-svg\">\n        {/* Center node */}\n        <circle cx={cx} cy={cy} r={centerRadius} fill=\"var(--accent-color)\" />\n        <text x={cx} y={cy} textAnchor=\"middle\" dy={3} fontSize=\"10\" fill=\"white\" fontWeight=\"500\">\n          \u2605\n        </text>\n        <text\n          x={cx}\n          y={cy + centerRadius + 14}\n          textAnchor=\"middle\"\n          fontSize=\"9\"\n          fill=\"var(--text-muted)\"\n        >\n          No connections\n        </text>\n      </svg>\n    );\n  }\n\n  return (\n    <svg width={size} height={size} className=\"mc-svg\">\n      {/* Connection lines */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n        const strength = node.strength ?? 0.5;\n\n        return (\n          <line\n            key={i}\n            x1={cx}\n            y1={cy}\n            x2={node.x}\n            y2={node.y}\n            stroke={color}\n            strokeWidth={1 + strength * 2}\n            strokeOpacity={0.4 + strength * 0.4}\n          />\n        );\n      })}\n\n      {/* Outer nodes */}\n      {nodePositions.map((node, i) => {\n        const color = getKindColor(node.kind);\n\n        return (\n          <g key={i}>\n            {/* Node circle */}\n            <circle cx={node.x} cy={node.y} r={nodeRadius} fill={color} opacity={0.9} />\n            {/* Kind initial */}\n            <text\n              x={node.x}\n              y={node.y}\n              textAnchor=\"middle\"\n              dy={3}\n              fontSize=\"8\"\n              fill=\"white\"\n              fontWeight=\"500\"\n            >\n              {node.kind.charAt(0).toUpperCase()}\n            </text>\n            {/* Name label */}\n            <title>{`${node.name} (${node.kind})\\n${node.relationshipKind}`}</title>\n          </g>\n        );\n      })}\n\n      {/* Center node (entry point) */}\n      <circle\n        cx={cx}\n        cy={cy}\n        r={centerRadius}\n        fill=\"var(--accent-color)\"\n        stroke=\"white\"\n        strokeWidth={2}\n      />\n      <text x={cx} y={cy} textAnchor=\"middle\" dy={4} fontSize=\"12\" fill=\"white\" fontWeight=\"600\">\n        \u2605\n      </text>\n\n      {/* Center label */}\n      <text x={cx} y={size - 6} textAnchor=\"middle\" fontSize=\"9\" fill=\"var(--text-muted)\">\n        {visibleConnections.length} connections\n        {hiddenCount > 0 && ` (+${hiddenCount})`}\n      </text>\n\n      {/* Legend - show unique kinds */}\n      {(() => {\n        const uniqueKinds = [...new Set(visibleConnections.map((c) => c.kind))];\n        if (uniqueKinds.length <= 4) {\n          return (\n            <g>\n              {uniqueKinds.map((kind, i) => (\n                <g key={kind} transform={`translate(${4 + i * 40}, 4)`}>\n                  <circle cx={4} cy={6} r={4} fill={getKindColor(kind)} />\n                  <text x={12} y={9} fontSize=\"8\" fill=\"var(--text-muted)\">\n                    {kind.slice(0, 4)}\n                  </text>\n                </g>\n              ))}\n            </g>\n          );\n        }\n        return null;\n      })()}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  centerName: _centerName,\n  connections,\n  size = 180,\n  maxConnections = 8,\n}", "type": "Readonly<MiniConstellationProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["ConnectedEntity"], "category": "internal"}, {"source": "./MiniConstellation.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/NarrativeTimeline.tsx", "sourceCode": "export default function NarrativeTimeline({\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}: Readonly<NarrativeTimelineProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [hoveredEvent, setHoveredEvent] = useState<TooltipData | null>(null);\n  const [hoveredCastMarker, setHoveredCastMarker] = useState<CastTooltipData | null>(null);\n\n  const padding = { left: 40, right: 40, top: 24, bottom: 32 };\n  const hasCastMarkers = castMarkers && castMarkers.length > 0;\n  const castTrackHeight = hasCastMarkers ? 28 : 0;\n  const laneHeight = height - padding.top - padding.bottom;\n  const eventAreaTop = padding.top + 20; // Leave room for era labels\n  const eventAreaHeight = laneHeight - 20 - castTrackHeight;\n  const castBaselineY = eventAreaTop + eventAreaHeight + 4;\n  const castMarkerCenterY = castBaselineY + 12;\n\n  // Use provided extent or compute from events as fallback\n  const extent = useMemo(() => {\n    if (extentProp) return extentProp;\n    return computeTimelineExtent(events.map((e) => ({ tick: e.tick }) as any));\n  }, [extentProp, events]);\n\n  // Scale functions\n  const scaleX = useCallback(\n    (tick: number) => tickToX(tick, extent, width, padding.left),\n    [extent, width, padding.left]\n  );\n\n  // Position events to avoid overlap using simple row allocation\n  const eventPositions = useMemo(() => {\n    const positions = new Map<string, { x: number; y: number; height: number; row: number }>();\n    const rows: Array<{ endX: number }> = [];\n    const eventWidth = 24;\n    const eventGap = 4;\n\n    // Sort by tick\n    const sorted = [...events].sort((a, b) => a.tick - b.tick);\n\n    for (const event of sorted) {\n      const x = scaleX(event.tick);\n      const eventHeight = getEventHeight(event.significance, 50, 20);\n\n      // Find first available row\n      let row = 0;\n      for (let i = 0; i < rows.length; i++) {\n        if (rows[i].endX + eventGap < x) {\n          row = i;\n          break;\n        }\n        row = i + 1;\n      }\n\n      // Ensure row exists\n      while (rows.length <= row) {\n        rows.push({ endX: 0 });\n      }\n      rows[row].endX = x + eventWidth;\n\n      // Calculate y position (stack from bottom)\n      const y = eventAreaTop + eventAreaHeight - eventHeight - row * 12;\n\n      positions.set(event.id, { x, y, height: eventHeight, row });\n    }\n\n    return positions;\n  }, [events, scaleX, eventAreaTop, eventAreaHeight]);\n\n  // Generate tick marks\n  const tickMarks = useMemo(() => {\n    const [minTick, maxTick] = extent;\n    const range = maxTick - minTick;\n    const step = Math.ceil(range / 8);\n    const marks: number[] = [];\n\n    for (let tick = Math.ceil(minTick / step) * step; tick <= maxTick; tick += step) {\n      marks.push(tick);\n    }\n\n    return marks;\n  }, [extent]);\n\n  const handleEventClick = useCallback(\n    (e: React.MouseEvent, eventId: string) => {\n      e.stopPropagation();\n      onToggleEvent(eventId);\n    },\n    [onToggleEvent]\n  );\n\n  const handleEventHover = useCallback((event: TimelineEvent | null, e?: React.MouseEvent) => {\n    if (event && e && svgRef.current) {\n      const rect = svgRef.current.getBoundingClientRect();\n      setHoveredEvent({\n        event,\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    } else {\n      setHoveredEvent(null);\n    }\n  }, []);\n\n  return (\n    <div className=\"nt-wrap\">\n      <svg\n        ref={svgRef}\n        width={width}\n        height={height}\n        className=\"nt-svg\"\n      >\n        {/* Era bands */}\n        {eraRanges.map((era) => {\n          // Clamp era boundaries to the usable timeline area\n          const x1 = Math.max(scaleX(era.startTick), padding.left);\n          const x2 = Math.min(scaleX(era.endTick), width - padding.right);\n          const isFocal = focalEraId === era.id;\n          const bandWidth = x2 - x1;\n\n          // Skip eras that fall entirely outside the visible range\n          if (bandWidth <= 0) return null;\n\n          return (\n            <g key={era.id}>\n              {/* Era background band */}\n              <rect\n                x={x1}\n                y={padding.top}\n                width={bandWidth}\n                height={laneHeight}\n                fill={era.color}\n                opacity={isFocal ? 0.15 : 0.08}\n              />\n              {/* Era divider line */}\n              <line\n                x1={x1}\n                y1={padding.top}\n                x2={x1}\n                y2={height - padding.bottom}\n                stroke={era.color}\n                strokeWidth={isFocal ? 2 : 1}\n                strokeDasharray={isFocal ? \"none\" : \"4,4\"}\n              />\n              {/* Era label */}\n              <text\n                x={x1 + 6}\n                y={padding.top + 14}\n                fontSize=\"10\"\n                fontWeight={isFocal ? 600 : 400}\n                fill={era.color}\n              >\n                {era.name}\n                {isFocal && \" \u2605\"}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Timeline axis */}\n        <line\n          x1={padding.left}\n          y1={height - padding.bottom}\n          x2={width - padding.right}\n          y2={height - padding.bottom}\n          stroke=\"var(--border-color)\"\n          strokeWidth={1}\n        />\n\n        {/* Tick marks */}\n        {tickMarks.map((tick) => {\n          const x = scaleX(tick);\n          return (\n            <g key={tick}>\n              <line\n                x1={x}\n                y1={height - padding.bottom}\n                x2={x}\n                y2={height - padding.bottom + 4}\n                stroke=\"var(--text-muted)\"\n                strokeWidth={1}\n              />\n              <text\n                x={x}\n                y={height - padding.bottom + 16}\n                textAnchor=\"middle\"\n                fontSize=\"9\"\n                fill=\"var(--text-muted)\"\n              >\n                {tick}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Event cards */}\n        {events.map((event) => {\n          const pos = eventPositions.get(event.id);\n          if (!pos) return null;\n\n          const fill = getEventFill(event);\n          const cardWidth = 20;\n\n          return (\n            <g\n              key={event.id}\n              className=\"nt-cursor-pointer\"\n              onClick={(e) => handleEventClick(e, event.id)}\n              onMouseEnter={(e) => handleEventHover(event, e)}\n              onMouseLeave={() => handleEventHover(null)}\n            >\n              {/* Event card */}\n              <rect\n                x={pos.x - cardWidth / 2}\n                y={pos.y}\n                width={cardWidth}\n                height={pos.height}\n                rx={3}\n                fill={fill}\n                opacity={event.selected ? 1 : 0.4}\n                stroke={event.selected ? \"white\" : \"transparent\"}\n                strokeWidth={event.selected ? 2 : 0}\n              />\n              {/* Selection checkmark */}\n              {event.selected && (\n                <text\n                  x={pos.x}\n                  y={pos.y + pos.height / 2 + 4}\n                  textAnchor=\"middle\"\n                  fontSize=\"12\"\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  className=\"nt-no-pointer\"\n                >\n                  \u2713\n                </text>\n              )}\n            </g>\n          );\n        })}\n\n        {/* Cast creation markers */}\n        {hasCastMarkers && (\n          <g>\n            {/* Dashed baseline */}\n            <line\n              x1={padding.left}\n              y1={castBaselineY}\n              x2={width - padding.right}\n              y2={castBaselineY}\n              stroke=\"var(--border-color)\"\n              strokeWidth={1}\n              strokeDasharray=\"4,3\"\n            />\n            {/* \"Cast\" label */}\n            <text\n              x={padding.left - 4}\n              y={castMarkerCenterY + 3}\n              textAnchor=\"end\"\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n            >\n              Cast\n            </text>\n            {/* Markers */}\n            {castMarkers.map((marker) => {\n              if (typeof marker.createdAt !== \"number\" || Number.isNaN(marker.createdAt))\n                return null;\n              const x = scaleX(marker.createdAt);\n              const shape = getCastMarkerShape(marker.entityKind);\n              const color = getCastMarkerColor(marker.entityKind);\n              const isHovered = hoveredCastMarker?.marker.entityId === marker.entityId;\n\n              return (\n                <g\n                  key={marker.entityId}\n                  className=\"nt-cursor-pointer\"\n                  onMouseEnter={(e) => {\n                    if (svgRef.current) {\n                      const rect = svgRef.current.getBoundingClientRect();\n                      setHoveredCastMarker({\n                        marker,\n                        x: e.clientX - rect.left,\n                        y: e.clientY - rect.top,\n                      });\n                    }\n                  }}\n                  onMouseLeave={() => setHoveredCastMarker(null)}\n                >\n                  {/* Vertical tick from baseline to marker */}\n                  <line\n                    x1={x}\n                    y1={castBaselineY}\n                    x2={x}\n                    y2={castMarkerCenterY - shape.size / 2}\n// ... (truncated)", "parameters": [{"name": "{\n  events,\n  eraRanges,\n  width,\n  height,\n  onToggleEvent,\n  focalEraId,\n  extent: extentProp,\n  castMarkers,\n}", "type": "Readonly<NarrativeTimelineProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useCallback", "useRef"], "category": "framework"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["TimelineEvent", "EraRange", "CastMarker", "computeTimelineExtent", "tickToX", "getEventFill", "getEventHeight", "getCastMarkerShape", "getCastMarkerColor"], "category": "internal"}, {"source": "./NarrativeTimeline.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/RoleSlot.tsx", "sourceCode": "export default function RoleSlot({\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}: Readonly<RoleSlotProps>) {\n  const canAccept = hasSelection && !isAtMax;\n  const count = assignments.length;\n\n  const wrapClass = `rs-wrap ${canAccept ? \"rs-wrap-accept\" : isUnderMin ? \"rs-wrap-undermin\" : \"rs-wrap-default\"}`;\n\n  return (\n    <div\n      onClick={canAccept ? onAssign : undefined}\n      className={wrapClass}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n    >\n      {/* Role header - single line */}\n      <div className={`rs-header ${assignments.length > 0 || canAccept ? \"rs-header-mb\" : \"\"}`}>\n        <div className=\"rs-name-row\">\n          <span className={`rs-role-name ${isUnderMin ? \"rs-role-name-error\" : \"rs-role-name-default\"}`}>\n            {role.role}\n          </span>\n          <span className={`rs-role-count ${isUnderMin ? \"rs-role-count-error\" : \"rs-role-count-default\"}`}>\n            {count}/{role.count.max}\n          </span>\n        </div>\n\n        {canAccept && (\n          <span className=\"rs-add-label\">\n            + Add\n          </span>\n        )}\n      </div>\n\n      {/* Assigned entities - visually distinct from header */}\n      {assignments.length > 0 && (\n        <div className=\"rs-assignments\">\n          {assignments.map((assignment) => (\n            <div\n              key={assignment.entityId}\n              className=\"rs-assignment-row\"\n              onClick={(e) => e.stopPropagation()}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              {/* Entity name */}\n              <span className=\"rs-entity-name\">\n                {assignment.entityName}\n                <span className=\"rs-entity-kind\">\n                  {assignment.entityKind}\n                </span>\n              </span>\n\n              {/* Primary/Support toggle - full text, more button-like */}\n              <button\n                onClick={() => onTogglePrimary(assignment.entityId)}\n                className={`rs-toggle-btn ${assignment.isPrimary ? \"rs-toggle-btn-primary\" : \"rs-toggle-btn-support\"}`}\n                title=\"Click to toggle primary/support\"\n              >\n                {assignment.isPrimary ? \"Primary\" : \"Support\"}\n              </button>\n\n              {/* Remove button */}\n              <button\n                onClick={() => onRemove(assignment.entityId)}\n                className=\"rs-remove-btn\"\n                title=\"Remove from role\"\n              >\n                \u00d7\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  role,\n  assignments,\n  hasSelection,\n  isAtMax,\n  isUnderMin,\n  onAssign,\n  onRemove,\n  onTogglePrimary,\n}", "type": "Readonly<RoleSlotProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["RoleDefinition"], "category": "external"}, {"source": "../../../lib/chronicleTypes", "specifiers": ["ChronicleRoleAssignment"], "category": "internal"}, {"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "./RoleSlot.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/StoryPotentialRadar.tsx", "sourceCode": "export default function StoryPotentialRadar({\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}: Readonly<StoryPotentialRadarProps>) {\n  const cx = size / 2;\n  const cy = size / 2;\n  const maxRadius = size / 2 - (showLabels ? 28 : 8);\n  const numAxes = AXES.length;\n  const angleStep = (2 * Math.PI) / numAxes;\n  // Start from top (-90 degrees)\n  const startAngle = -Math.PI / 2;\n\n  // Compute axis endpoints\n  const axisPoints = useMemo(() => {\n    return AXES.map((_, i) => {\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + maxRadius * Math.cos(angle),\n        y: cy + maxRadius * Math.sin(angle),\n        labelX: cx + (maxRadius + 14) * Math.cos(angle),\n        labelY: cy + (maxRadius + 14) * Math.sin(angle),\n        angle,\n      };\n    });\n  }, [cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Compute polygon points for the data\n  const dataPoints = useMemo(() => {\n    return AXES.map((axis, i) => {\n      const value = potential[axis.key as keyof StoryPotential];\n      const radius = value * maxRadius;\n      const angle = startAngle + i * angleStep;\n      return {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n        value,\n        label: axis.label,\n      };\n    });\n  }, [potential, cx, cy, maxRadius, angleStep, startAngle]);\n\n  // Build polygon path\n  const polygonPath =\n    dataPoints.map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x} ${p.y}`).join(\" \") + \" Z\";\n\n  // Grid rings (25%, 50%, 75%, 100%)\n  const gridRings = [0.25, 0.5, 0.75, 1];\n\n  return (\n    <svg width={size} height={size} className=\"spr-svg\">\n      {/* Background */}\n      <circle cx={cx} cy={cy} r={maxRadius} fill=\"var(--bg-tertiary)\" />\n\n      {/* Grid rings */}\n      {gridRings.map((ring) => (\n        <circle\n          key={ring}\n          cx={cx}\n          cy={cy}\n          r={maxRadius * ring}\n          fill=\"none\"\n          stroke=\"var(--border-color)\"\n          strokeWidth={ring === 1 ? 1 : 0.5}\n          strokeDasharray={ring === 1 ? \"none\" : \"2,2\"}\n        />\n      ))}\n\n      {/* Axis lines */}\n      {axisPoints.map((point, i) => (\n        <line\n          key={i}\n          x1={cx}\n          y1={cy}\n          x2={point.x}\n          y2={point.y}\n          stroke=\"var(--border-color)\"\n          strokeWidth={0.5}\n        />\n      ))}\n\n      {/* Data polygon */}\n      <path\n        d={polygonPath}\n        fill=\"rgba(99, 102, 241, 0.3)\"\n        stroke=\"var(--accent-color)\"\n        strokeWidth={2}\n      />\n\n      {/* Data points */}\n      {dataPoints.map((point, i) => (\n        <g key={i}>\n          <circle\n            cx={point.x}\n            cy={point.y}\n            r={4}\n            fill=\"var(--accent-color)\"\n            stroke=\"white\"\n            strokeWidth={1.5}\n          />\n          {interactive && <title>{`${point.label}: ${(point.value * 100).toFixed(0)}%`}</title>}\n        </g>\n      ))}\n\n      {/* Axis labels */}\n      {showLabels &&\n        axisPoints.map((point, i) => {\n          const axis = AXES[i];\n\n          // Adjust text anchor based on position\n          let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n          if (point.labelX < cx - 10) textAnchor = \"end\";\n          else if (point.labelX > cx + 10) textAnchor = \"start\";\n\n          // Adjust vertical position\n          let dy = 4;\n          if (point.labelY < cy - maxRadius * 0.5) dy = 12;\n          else if (point.labelY > cy + maxRadius * 0.5) dy = -2;\n\n          return (\n            <text\n              key={i}\n              x={point.labelX}\n              y={point.labelY}\n              dy={dy}\n              textAnchor={textAnchor}\n              fontSize=\"9\"\n              fill=\"var(--text-muted)\"\n              fontFamily=\"inherit\"\n            >\n              {axis.shortLabel}\n            </text>\n          );\n        })}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  potential,\n  size = 160,\n  showLabels = true,\n  interactive = true,\n}", "type": "Readonly<StoryPotentialRadarProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useMemo"], "category": "framework"}, {"source": "../../../lib/chronicle/storyPotential", "specifiers": ["StoryPotential"], "category": "internal"}, {"source": "./StoryPotentialRadar.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx::default", "name": "default", "kind": "function", "filePath": "apps/illuminator/webui/src/components/ChronicleWizard/visualizations/TimelineBrush.tsx", "sourceCode": "export default function TimelineBrush({\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}: Readonly<TimelineBrushProps>) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [dragMode, setDragMode] = useState<DragMode>(\"none\");\n  const [dragStart, setDragStart] = useState<{ x: number; selection: [number, number] | null }>({\n    x: 0,\n    selection: null,\n  });\n\n  const handleSize = 8;\n\n  // Convert selection to pixel positions\n  const selectionPx = selection\n    ? {\n        left: tickToX(selection[0], extent, width, padding),\n        right: tickToX(selection[1], extent, width, padding),\n      }\n    : null;\n\n  const getMouseX = useCallback((e: React.MouseEvent | MouseEvent) => {\n    if (!svgRef.current) return 0;\n    const rect = svgRef.current.getBoundingClientRect();\n    return e.clientX - rect.left;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, mode: DragMode) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragMode(mode);\n      setDragStart({ x: getMouseX(e), selection });\n    },\n    [selection, getMouseX]\n  );\n\n  const handleBackgroundMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      const x = getMouseX(e);\n      // If clicking outside selection, start creating new selection\n      if (!selectionPx || x < selectionPx.left - handleSize || x > selectionPx.right + handleSize) {\n        setDragMode(\"create\");\n        const tick = xToTick(x, extent, width, padding);\n        setDragStart({ x, selection: [tick, tick] });\n        onSelectionChange([tick, tick]);\n      }\n    },\n    [selectionPx, extent, width, padding, getMouseX, onSelectionChange, handleSize]\n  );\n\n  useEffect(() => {\n    if (dragMode === \"none\") return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const x = getMouseX(e);\n      const dx = x - dragStart.x;\n\n      if (dragMode === \"create\") {\n        const startTick = dragStart.selection[0];\n        const currentTick = xToTick(x, extent, width, padding);\n        const newSelection: [number, number] =\n          currentTick >= startTick ? [startTick, currentTick] : [currentTick, startTick];\n        onSelectionChange(newSelection);\n        return;\n      }\n\n      if (!dragStart.selection) return;\n\n      const [startTick, endTick] = dragStart.selection;\n\n      if (dragMode === \"left\") {\n        const newLeft = xToTick(\n          tickToX(startTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.min(newLeft, endTick - 1);\n        onSelectionChange([Math.max(extent[0], clamped), endTick]);\n      } else if (dragMode === \"right\") {\n        const newRight = xToTick(\n          tickToX(endTick, extent, width, padding) + dx,\n          extent,\n          width,\n          padding\n        );\n        const clamped = Math.max(newRight, startTick + 1);\n        onSelectionChange([startTick, Math.min(extent[1], clamped)]);\n      } else if (dragMode === \"move\") {\n        const tickDelta =\n          xToTick(dragStart.x + dx, extent, width, padding) -\n          xToTick(dragStart.x, extent, width, padding);\n        let newStart = startTick + tickDelta;\n        let newEnd = endTick + tickDelta;\n\n        // Clamp to extent\n        if (newStart < extent[0]) {\n          const shift = extent[0] - newStart;\n          newStart = extent[0];\n          newEnd += shift;\n        }\n        if (newEnd > extent[1]) {\n          const shift = newEnd - extent[1];\n          newEnd = extent[1];\n          newStart -= shift;\n        }\n\n        onSelectionChange([Math.max(extent[0], newStart), Math.min(extent[1], newEnd)]);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setDragMode(\"none\");\n    };\n\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [dragMode, dragStart, extent, width, padding, getMouseX, onSelectionChange]);\n\n  const getCursor = (mode: DragMode) => {\n    switch (mode) {\n      case \"left\":\n      case \"right\":\n        return \"ew-resize\";\n      case \"move\":\n        return \"grab\";\n      case \"create\":\n        return \"crosshair\";\n      default:\n        return \"crosshair\";\n    }\n  };\n\n  return (\n    <svg\n      ref={svgRef}\n      width={width}\n      height={height}\n      className=\"tb-svg\"\n      style={{\n        '--tb-cursor': getCursor(dragMode === \"none\" ? \"create\" : dragMode),\n      } as React.CSSProperties}\n      onMouseDown={handleBackgroundMouseDown}\n    >\n      {/* Background track */}\n      <rect\n        x={padding}\n        y={4}\n        width={width - 2 * padding}\n        height={height - 8}\n        rx={4}\n        fill=\"var(--bg-tertiary)\"\n        stroke=\"var(--border-color)\"\n        strokeWidth={1}\n      />\n\n      {/* Selection */}\n      {selectionPx && selectionPx.right - selectionPx.left >= minSelectionWidth && (\n        <g>\n          {/* Selection rect */}\n          <rect\n            x={selectionPx.left}\n            y={4}\n            width={selectionPx.right - selectionPx.left}\n            height={height - 8}\n            rx={4}\n            fill=\"rgba(99, 102, 241, 0.3)\"\n            stroke=\"var(--accent-color)\"\n            strokeWidth={1}\n            className=\"tb-grab\"\n            onMouseDown={(e) => handleMouseDown(e, \"move\")}\n          />\n\n          {/* Left handle */}\n          <rect\n            x={selectionPx.left - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"left\")}\n          />\n\n          {/* Right handle */}\n          <rect\n            x={selectionPx.right - handleSize / 2}\n            y={height / 2 - 12}\n            width={handleSize}\n            height={24}\n            rx={2}\n            fill=\"var(--accent-color)\"\n            className=\"tb-ew-resize\"\n            onMouseDown={(e) => handleMouseDown(e, \"right\")}\n          />\n\n          {/* Selection label */}\n          {selection && (\n            <text\n              x={(selectionPx.left + selectionPx.right) / 2}\n              y={height / 2 + 4}\n              textAnchor=\"middle\"\n              fontSize=\"10\"\n              fontWeight=\"500\"\n              fill=\"var(--accent-color)\"\n              className=\"tb-no-pointer\"\n            >\n              {selection[0]} \u2013 {selection[1]}\n            </text>\n          )}\n        </g>\n      )}\n\n      {/* Instructions when no selection */}\n      {!selectionPx && (\n        <text\n          x={width / 2}\n          y={height / 2 + 4}\n          textAnchor=\"middle\"\n          fontSize=\"11\"\n          fill=\"var(--text-muted)\"\n          className=\"tb-no-pointer\"\n        >\n          Drag to select time range\n        </text>\n      )}\n    </svg>\n  );\n}", "parameters": [{"name": "{\n  width,\n  height,\n  extent,\n  padding = 40,\n  selection,\n  onSelectionChange,\n  minSelectionWidth = 20,\n}", "type": "Readonly<TimelineBrushProps>", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback", "useRef", "useEffect"], "category": "framework"}, {"source": "../../../lib/chronicle/timelineUtils", "specifiers": ["tickToX", "xToTick"], "category": "internal"}, {"source": "./TimelineBrush.css", "specifiers": [], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts::assembleSections", "name": "assembleSections", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/assembly.ts", "sourceCode": "export function assembleSections(\n  plan: ChroniclePlan,\n  _context: ChronicleGenerationContext,\n  options: {\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  } = {}\n): AssemblyResult {\n  const { includeTitle = true, includeSectionTitles = false } = options;\n\n  try {\n    const missingSections = plan.sections.filter((s) => !s.generatedContent);\n    if (missingSections.length > 0) {\n      return {\n        success: false,\n        error: `Missing content for ${missingSections.length} section(s): ${missingSections.map((s) => s.name).join(\", \")}`,\n      };\n    }\n\n    const parts: string[] = [];\n\n    if (includeTitle) {\n      parts.push(`# ${plan.title}\\n\\n`);\n    }\n\n    for (let i = 0; i < plan.sections.length; i += 1) {\n      const section = plan.sections[i];\n\n      if (i > 0) {\n        parts.push(\"\\n\\n---\\n\\n\");\n      }\n\n      if (includeSectionTitles && section.name) {\n        parts.push(`## ${section.name}\\n\\n`);\n      }\n\n      parts.push(section.generatedContent || \"\");\n    }\n\n    const content = parts.join(\"\");\n\n    return {\n      success: true,\n      content,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error during assembly\",\n    };\n  }\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "_context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "options", "type": "{\n    includeTitle?: boolean;\n    includeSectionTitles?: boolean;\n  }", "optional": true}], "returnType": "AssemblyResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["AssemblyResult", "ChronicleGenerationContext", "ChroniclePlan"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatFocusSummary", "name": "formatFocusSummary", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatFocusSummary(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n  const nameForId = (id: string) => entityMap.get(id)?.name || id;\n\n  const lines = [\n    `Focus Mode: ${plan.focus.mode}`,\n    `Entrypoint: ${nameForId(plan.focus.entrypointId)}`,\n    plan.focus.primaryEntityIds?.length\n      ? `Primary: ${plan.focus.primaryEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n    plan.focus.supportingEntityIds?.length\n      ? `Supporting: ${plan.focus.supportingEntityIds.map(nameForId).join(\", \")}`\n      : \"\",\n  ].filter(Boolean);\n\n  return lines.join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChroniclePlan", "ChronicleGenerationContext", "CohesionReport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatEntityRoster", "name": "formatEntityRoster", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatEntityRoster(\n  plan: ChroniclePlan,\n  context: ChronicleGenerationContext\n): string {\n  const entityMap = new Map(context.entities.map((entity) => [entity.id, entity]));\n\n  if (!plan.entityRoles || plan.entityRoles.length === 0) {\n    return \"(none)\";\n  }\n\n  return plan.entityRoles\n    .map((role) => {\n      const entity = entityMap.get(role.entityId);\n      const name = entity?.name || role.entityId;\n      const kind = entity?.kind || \"unknown\";\n      const subtype = entity?.subtype ? `/${entity.subtype}` : \"\";\n      const culture = entity?.culture || \"(none)\";\n      const tags = formatTags(entity?.tags);\n\n      return `- ${name} (${kind}${subtype})\n  Role: ${role.role}\n  Contribution: ${role.contribution}\n  Culture: ${culture}\n  Tags: ${tags}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "plan", "type": "ChroniclePlan", "optional": false}, {"name": "context", "type": "ChronicleGenerationContext", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChroniclePlan", "ChronicleGenerationContext", "CohesionReport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts::formatIssueList", "name": "formatIssueList", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/editing.ts", "sourceCode": "export function formatIssueList(report: CohesionReport, plan?: ChroniclePlan): string {\n  if (!report.issues || report.issues.length === 0) {\n    return \"(no issues listed)\";\n  }\n\n  const sectionMap = new Map(plan?.sections?.map((s) => [s.id, s.name]) || []);\n\n  return report.issues\n    .map((issue, index) => {\n      const sectionName = issue.sectionId\n        ? sectionMap.get(issue.sectionId) || issue.sectionId\n        : \"General\";\n      const suggestion = issue.suggestion\n        ? `Suggestion: ${issue.suggestion}`\n        : \"Suggestion: (none provided)\";\n      return `${index + 1}. [${issue.severity}] ${issue.checkType} (Section: ${sectionName})\n   ${issue.description}\n   ${suggestion}`;\n    })\n    .join(\"\\n\");\n}", "parameters": [{"name": "report", "type": "CohesionReport", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChroniclePlan", "ChronicleGenerationContext", "CohesionReport"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts::parseJsonResponse", "name": "parseJsonResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/jsonParsing.ts", "sourceCode": "export function parseJsonResponse<T>(response: string): T {\n  const extracted = extractJsonBlock(response);\n  let fixed = applyJsonFixes(extracted);\n\n  try {\n    return JSON.parse(fixed) as T;\n  } catch (firstError) {\n    fixed = applyAggressiveFixes(fixed);\n\n    try {\n      return JSON.parse(fixed) as T;\n    } catch (secondError) {\n      const message = (secondError as Error).message;\n      const posMatch = message.match(/position (\\d+)/);\n      if (posMatch) {\n        const errorPos = parseInt(posMatch[1], 10);\n        const before = fixed.substring(0, errorPos);\n        const after = fixed.substring(errorPos);\n        const lastChar = before.trim().slice(-1);\n        const firstChar = after.trim()[0];\n\n        if (\n          (lastChar === '\"' || lastChar === \"}\" || lastChar === \"]\") &&\n          (firstChar === '\"' || firstChar === \"{\" || firstChar === \"[\")\n        ) {\n          const patched = before + \",\" + after;\n          return JSON.parse(patched) as T;\n        }\n      }\n\n      throw firstError;\n    }\n  }\n}", "parameters": [{"name": "response", "type": "string", "optional": false}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::buildReferenceLookup", "name": "buildReferenceLookup", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function buildReferenceLookup<T>(\n  items: T[],\n  getId: (item: T) => string,\n  getName: (item: T) => string | undefined\n): ReferenceLookup {\n  const ids = new Map<string, string>();\n  const names = new Map<string, string | null>();\n\n  for (const item of items) {\n    const id = getId(item);\n    if (id) {\n      ids.set(normalizeId(id), id);\n    }\n    const name = getName(item);\n    if (!name) continue;\n    const normalized = normalizeName(name);\n    if (!names.has(normalized)) {\n      names.set(normalized, id);\n    } else if (names.get(normalized) !== id) {\n      names.set(normalized, null);\n    }\n  }\n\n  return { ids, names };\n}", "parameters": [{"name": "items", "type": "T[]", "optional": false}, {"name": "getId", "type": "(item: T) => string", "optional": false}, {"name": "getName", "type": "(item: T) => string | undefined", "optional": false}], "returnType": "ReferenceLookup", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts::resolveReference", "name": "resolveReference", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/referenceResolution.ts", "sourceCode": "export function resolveReference(value: string, lookup: ReferenceLookup): string {\n  const rawValue = String(value);\n  const directMatch = lookup.ids.get(normalizeId(rawValue));\n  if (directMatch) {\n    return directMatch;\n  }\n  const nameMatch = lookup.names.get(normalizeName(rawValue));\n  return nameMatch || rawValue;\n}", "parameters": [{"name": "value", "type": "string", "optional": false}, {"name": "lookup", "type": "ReferenceLookup", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts::parseValidationResponse", "name": "parseValidationResponse", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/shared/validationParsing.ts", "sourceCode": "export function parseValidationResponse(response: string, plan: ChroniclePlan): CohesionReport {\n  let jsonStr = response;\n  // eslint-disable-next-line sonarjs/slow-regex -- bounded LLM response text\n  const jsonMatch = response.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1];\n  }\n\n  const parsed = JSON.parse(jsonStr.trim());\n\n  const report: CohesionReport = {\n    overallScore: typeof parsed.overallScore === \"number\" ? parsed.overallScore : 50,\n    checks: {\n      plotStructure: normalizeCheck(parsed.checks?.plotStructure),\n      entityConsistency: normalizeCheck(parsed.checks?.entityConsistency),\n      sectionGoals: normalizeSectionGoals(parsed.checks?.sectionGoals, plan.sections),\n      resolution: normalizeCheck(parsed.checks?.resolution),\n      factualAccuracy: normalizeCheck(parsed.checks?.factualAccuracy),\n      themeExpression: normalizeCheck(parsed.checks?.themeExpression),\n    },\n    issues: (parsed.issues || []).map(normalizeIssue),\n    generatedAt: Date.now(),\n  };\n\n  return report;\n}", "parameters": [{"name": "response", "type": "string", "optional": false}, {"name": "plan", "type": "ChroniclePlan", "optional": false}], "returnType": "CohesionReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["CohesionReport", "CohesionCheck", "SectionGoalCheck", "CohesionIssue", "ChroniclePlan"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditSystemPrompt", "name": "buildCopyEditSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// System prompt\n// =============================================================================\n\nexport function buildCopyEditSystemPrompt(format: \"story\" | \"document\"): string {\n  if (format === \"document\") {\n    return `You are a senior editor doing a final polish on an in-universe document that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, tighter, more convincing as an artifact \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every piece of information the document conveys. If the same information appears in two sections that serve different purposes (e.g. a summary and a detailed account), both belong. If two sections serve the same purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Nothing the document *says* changes, but it shouldn't say the same thing twice for the same reason.\n- The document's voice and register. A bureaucratic report should stay bureaucratic. A folk collection should stay collected. Do not normalize register across sections that are intentionally different (e.g. quoted material vs. editorial framing).\n- World details. Names, places, customs, terminology, formatting conventions \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the register, density, or level of formality shifts abruptly between sections, ease the transition. The document should read as a single coherent artifact.\n\nTighten. Every word should earn its place. Look for redundant framing (\"it should be noted that\"), bureaucratic padding that doesn't serve the document's voice, repeated information that appears in multiple sections for the same purpose, and explanations that duplicate what the document already establishes.\n\nCut what doesn't work. If a section catalogs information without purpose, repeats the same content in template form, or pads the document without adding substance, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as document text \u2014 should be broken or cut.\n\nRead for consistency. Formatting conventions (headers, dates, citations, marginalia) should be uniform throughout. Where a convention appears in one section but not another, extend it.\n\nWhat you must not do:\n- Do not add new content, information, sections, or world details.\n- Do not impose a different voice on the document. Burnish the voice that is already there.\n- Do not restructure sections unless they are genuinely confusing.\n- Do not modernize or standardize language that is intentionally archaic or formal.\n\nYour changes should be invisible. A reader should not be able to tell the document was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n  }\n\n  return `You are a senior fiction editor doing a final polish on a piece that was assembled from multiple drafts. Your job is to burnish it \u2014 make it cleaner, clearer, more efficient \u2014 not to rewrite it.\n\nWhat you must preserve:\n- Every plot point and beat. If two scenes serve the same narrative purpose \u2014 a common artifact of combining drafts \u2014 merge them into one. Scenes that cover the same event from different perspectives or for different reasons each belong; scenes that do the same dramatic work twice do not. Nothing that *happens* in the story changes, but the reader shouldn't experience the same purpose served twice.\n- Character voices. Where characters speak in distinct registers \u2014 dialect, formality, cultural cadence \u2014 that is intentional. Do not standardize dialogue or testimony into a uniform voice.\n- World details. Names, places, customs, terminology \u2014 leave them exactly as they are.\n\nWhat you are here to do:\n\nSmooth the seams. This text was stitched together from different drafts. Where the prose rhythm changes abruptly \u2014 a shift in sentence length, descriptive density, or level of ornateness \u2014 ease the transition. The reader should never feel a bump between sections.\n\nTighten. Every word should earn its place. Look for filter words that create distance (\"she noticed,\" \"he felt\"), redundant modifiers, stage directions that reveal nothing about character, and emotional explanations that duplicate what the prose already shows. Where the same detail appears twice because it was imported from two different drafts, keep whichever instance lands harder and cut the other.\n\nCut what doesn't work. If a passage catalogs names or events in sequence, repeats the same dramatic beat in parallel structure (e.g., three characters experiencing the same effect in the same paragraph shape), or reads as a report of what happened rather than lived experience, you have permission to compress or remove it. Machine-generation patterns \u2014 template repetition, list-like sequences, prompt content surfacing as narrative \u2014 should be broken or cut.\n\nRead for rhythm. Where a sentence fights you or the prose stumbles, recast it \u2014 but preserve its content and intent. If a passage is deliberately languid or dense, that may be the style working as intended. Only intervene where the prose works against the effect it is trying to achieve.\n\nWhat you must not do:\n- Do not add new content, ideas, scenes, details, or metaphors.\n- Do not impose a different voice on the narration. Burnish the voice that is already there.\n- Do not restructure paragraphs unless they are genuinely confusing.\n- Do not flatten distinctive character speech into standard grammar.\n\nYour changes should be invisible. A reader should not be able to tell the text was edited.\n\nOutput only the edited text \u2014 no commentary, no tracked changes, no explanations.`;\n}", "parameters": [{"name": "format", "type": "\"story\" | \"document\"", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts::buildCopyEditUserPrompt", "name": "buildCopyEditUserPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/copyEditPrompt.ts", "sourceCode": "// =============================================================================\n// User prompt\n// =============================================================================\n\nexport function buildCopyEditUserPrompt(\n  text: string,\n  style: NarrativeStyle,\n  voiceContext?: {\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }\n): string {\n  const target = getWordCountRange(style);\n  const currentWords = countWords(text);\n  const styleName = style.name;\n  const craftPosture =\n    \"craftPosture\" in style ? (style.craftPosture) : undefined;\n\n  const parts: string[] = [];\n\n  parts.push(`## Format\\n${styleName}`);\n\n  parts.push(\n    `## Length\\nThe piece is ${currentWords} words. The natural range for this format is ${target.min}\u2013${target.max}. Use this as context for what length feels natural, but your job is to improve the prose, not to hit a number. If the piece needs to be shorter, cut what doesn't work. If it needs room, let it breathe.`\n  );\n\n  if (craftPosture) {\n    parts.push(`## Craft Posture\\n${craftPosture}`);\n  }\n\n  // Voice textures help the editor recognize intentional prose choices\n  const nv = voiceContext?.narrativeVoice;\n  if (nv && Object.keys(nv).length > 0) {\n    const voiceLines = Object.entries(nv)\n      .map(([key, value]) => `**${key}**: ${value}`)\n      .join(\"\\n\");\n    parts.push(`## Voice Textures (preserve these \u2014 they are intentional)\\n${voiceLines}`);\n  }\n\n  // Motifs help the editor recognize structural repetition vs draft artifacts\n  const motifs = voiceContext?.motifs;\n  if (motifs && motifs.length > 0) {\n    const motifLines = motifs.map((m) => `- \"${m}\"`).join(\"\\n\");\n    parts.push(\n      `## Recurring Motifs (these are structural \u2014 do not cut or collapse)\\n${motifLines}`\n    );\n  }\n\n  parts.push(`## Text\\n\\n${text}`);\n\n  return parts.join(\"\\n\\n\");\n}", "parameters": [{"name": "text", "type": "string", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "voiceContext", "type": "{\n    narrativeVoice?: Record<string, string>;\n    motifs?: string[];\n  }", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle"], "category": "external"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::applyWikilinks", "name": "applyWikilinks", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Apply wikilinks to content deterministically.\n * Replaces entity name mentions with [[entity]] syntax.\n *\n * Process: Replaces all mentions in a single pass using a combined regex\n * to avoid offset issues from multiple sequential replacements.\n */\nexport function applyWikilinks(content: string, entities: EntityContext[]): string {\n  // Filter and sort entities by name length descending\n  // (match longer names first to avoid partial matches)\n  const validEntities = entities\n    .filter((e) => e.name.length >= 3)\n    .sort((a, b) => b.name.length - a.name.length);\n\n  if (validEntities.length === 0) return content;\n\n  // Build a single regex that matches any entity name\n  const patterns = validEntities.map((e) => `\\\\b${escapeRegex(e.name)}\\\\b`);\n  const combinedPattern = new RegExp(`(${patterns.join(\"|\")})`, \"gi\");\n\n  // Single pass replacement - check each match to see if already linked\n  return content.replace(combinedPattern, (match, _group, offset) => {\n    // Check if this position is already inside a wikilink\n    if (isInsideWikilink(content, offset)) {\n      return match;\n    }\n    return `[[${match}]]`;\n  });\n}", "parameters": [{"name": "content", "type": "string", "optional": false}, {"name": "entities", "type": "EntityContext[]", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/index.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["EntityContext"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildV2Prompt", "name": "buildV2Prompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Build the V2 single-shot prompt.\n */\nexport function buildV2Prompt(\n  context: ChronicleGenerationContext,\n  style: NarrativeStyle,\n  selection: V2SelectionResult\n): string {\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const narrativeVoiceSection = buildNarrativeVoiceSection(context.narrativeVoice);\n  const entityDirectivesSection = buildEntityDirectivesSection(context.entityDirectives);\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  if (style.format === \"story\") {\n    return buildStoryPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  } else {\n    return buildDocumentPrompt(\n      context,\n      selection,\n      primaryEntityIds,\n      narrativeVoiceSection,\n      entityDirectivesSection,\n      nameBankSection,\n      style,\n      prominenceScale\n    );\n  }\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "style", "type": "NarrativeStyle", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext", "EntityContext", "NarrativeEventContext", "ChronicleTemporalContext", "EraTemporalInfo"], "category": "internal"}, {"source": "../selectionWizard", "specifiers": ["collapseBidirectionalRelationships", "CollapsedRelationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "StoryNarrativeStyle", "DocumentNarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./types", "specifiers": ["V2SelectionResult"], "category": "internal"}, {"source": "../../perspectiveSynthesizer", "specifiers": ["EntityDirective"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getMaxTokensFromStyle", "name": "getMaxTokensFromStyle", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get max tokens based on word count target.\n * Rough estimate: 1 token ~= 0.75 words, plus buffer.\n */\nexport function getMaxTokensFromStyle(style: NarrativeStyle): number {\n  const maxWords =\n    style.format === \"story\"\n      ? (style).pacing.totalWordCount.max\n      : getDocumentWordCount(style).max;\n\n  // Add 50% buffer for safety, but never go below a practical minimum.\n  const minAutoMaxTokens = 1024;\n  const estimated = Math.ceil((maxWords / 0.75) * 1.5);\n  return Math.max(estimated, minAutoMaxTokens);\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext", "EntityContext", "NarrativeEventContext", "ChronicleTemporalContext", "EraTemporalInfo"], "category": "internal"}, {"source": "../selectionWizard", "specifiers": ["collapseBidirectionalRelationships", "CollapsedRelationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "StoryNarrativeStyle", "DocumentNarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./types", "specifiers": ["V2SelectionResult"], "category": "internal"}, {"source": "../../perspectiveSynthesizer", "specifiers": ["EntityDirective"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getV2SystemPrompt", "name": "getV2SystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Get the system prompt for V2 generation.\n * Describes prompt structure and establishes guidance hierarchy.\n */\nexport function getV2SystemPrompt(style: NarrativeStyle): string {\n  if (style.format === \"story\") {\n    return `You are an expert fantasy author writing engaging fiction. Your readers expect vivid characters, emotional truth, and prose that lands.\n\nYour prompt contains:\n\nCRAFT (how to write):\n- Narrative Structure: Your beat sheet \u2014 scene progression and emotional shape\n- Writing Style: Prose craft specific to this story type, including craft posture (density and restraint constraints)\n\nSTORY BIBLE (background reference, not requirements):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history \u2014 bring alive through specificity\n\nWORLD DATA (what to write about):\n- Cast: Characters to bring alive \u2014 descriptions show their FINAL state, but you're writing PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the story without being a character\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 show these through character experience, don't document them\n\nCRITICAL: Entity descriptions reflect who characters BECAME. Write them as they WERE during the story's events. A character described as dead was alive when your story takes place.\n\nCraft defines how to write; Story Bible is background reference. The world exists through what characters notice, do, and feel.`;\n  } else {\n    return `You are crafting an in-universe document that feels authentic and alive. Your prompt contains:\n\nCRAFT (how to write):\n- Document Instructions: Structure, voice, tone - THIS DEFINES YOUR DOCUMENT\n- Perspective: This chronicle's thematic angle and suggested motifs\n\nSTORY BIBLE (background reference):\n- Tone & Atmosphere: Notes on emotional texture\n- Character Notes: Relationships and history\n\nWORLD DATA (what to write about):\n- Cast: Characters referenced \u2014 descriptions show their FINAL state, but the document may depict PAST EVENTS when they were alive/active\n- Narrative Lens (optional): A contextual entity that shapes the document's assumptions\n- World: Setting context and canon facts\n- Historical Context: Era, timeline, and current conditions that shape what's possible\n- Events: What happened \u2014 reference naturally, don't list\n\nCRITICAL: Entity descriptions reflect who characters BECAME. If depicting past events, write them as they WERE during those events.\n\nDocument Instructions define the document's structure and format \u2014 they are primary. The Perspective provides thematic focus, not prose style. Write as the document's author would write, not as a storyteller.\n\nWrite authentically as if the document exists within the world. No meta-commentary.`;\n  }\n}", "parameters": [{"name": "style", "type": "NarrativeStyle", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext", "EntityContext", "NarrativeEventContext", "ChronicleTemporalContext", "EraTemporalInfo"], "category": "internal"}, {"source": "../selectionWizard", "specifiers": ["collapseBidirectionalRelationships", "CollapsedRelationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "StoryNarrativeStyle", "DocumentNarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./types", "specifiers": ["V2SelectionResult"], "category": "internal"}, {"source": "../../perspectiveSynthesizer", "specifiers": ["EntityDirective"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::getCreativeSystemPrompt", "name": "getCreativeSystemPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "// =============================================================================\n// Creative Freedom Mode\n// =============================================================================\n\n/**\n * System prompt for creative freedom generation.\n *\n * Key differences from structured (getV2SystemPrompt):\n * - Fiction writer identity with competitive frame (\"structured version already exists\")\n * - Pushes toward risk: \"find what it missed \u2014 the angle, the voice, the structure it didn't try\"\n * - Anti-AI-tells: \"the measure is whether a reader would say 'this is a story'\"\n * - Same PS, same data \u2014 only the generation prompt framing differs.\n */\nexport function getCreativeSystemPrompt(): string {\n  return `You are a fiction writer. Find the one detail that makes this story specific \u2014 the gesture, the object, the sensory moment no other story contains. Build outward from there. The measure is whether a reader finishes this and sits with it. Avoid the patterns, rhythms, and hedging that mark machine-generated text.\n\nYour prompt contains:\n\nGUIDANCE (pre-synthesized \u2014 follow their intent, find your own voice):\n- Tone & Atmosphere: Synthesized prose guidance for this chronicle\n- Character Notes: Per-entity guidance for portrayal\n\nWORLD DATA (what to write about):\n- Cast: Characters and narrative roles\n- World: Setting, canon facts, events, relationships\n\nEntity descriptions reflect who characters BECAME. Write them as they WERE during the story's events.\n\nTone & Atmosphere and Character Notes are pre-synthesized guidance \u2014 follow their intent closely, but express them in your own voice.`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext", "EntityContext", "NarrativeEventContext", "ChronicleTemporalContext", "EraTemporalInfo"], "category": "internal"}, {"source": "../selectionWizard", "specifiers": ["collapseBidirectionalRelationships", "CollapsedRelationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "StoryNarrativeStyle", "DocumentNarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./types", "specifiers": ["V2SelectionResult"], "category": "internal"}, {"source": "../../perspectiveSynthesizer", "specifiers": ["EntityDirective"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts::buildCreativeStoryPrompt", "name": "buildCreativeStoryPrompt", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/promptBuilder.ts", "sourceCode": "/**\n * Build the creative freedom prompt for story format.\n *\n * This is a FULLY SEPARATE prompt from buildStoryPrompt \u2014 intentional duplication.\n * Same PS outputs, same world data, same entity selection. The differences from\n * the structured prompt are:\n *\n * 1. Fiction writer identity focused on finding the specific, haunting detail\n * 2. Creative target (\"one image the reader won't forget\") instead of requirements list\n * 3. Structure presented as a starting shape, not a prescription\n * 4. Same craft posture as structured \u2014 constraints fuel creativity, not freedom\n *\n * The creative mode runs the same PS as the structured prompt, so it receives\n * the same narrative voice, entity directives, faceted facts, and motifs.\n * The difference is purely in how the generation prompt frames and presents\n * this material to the LLM.\n */\nexport function buildCreativeStoryPrompt(\n  context: ChronicleGenerationContext,\n  selection: V2SelectionResult\n): string {\n  const style = context.narrativeStyle as StoryNarrativeStyle;\n  const pacing = style.pacing;\n  const wordRange = `${pacing.totalWordCount.min}-${pacing.totalWordCount.max}`;\n\n  const primaryEntityIds = new Set(context.focus?.primaryEntityIds || []);\n  const prominenceScale = buildProminenceScaleForEntities([\n    ...selection.entities,\n    context.lensEntity,\n  ]);\n\n  // === TASK DATA ===\n\n  // 1. TASK \u2014 creative target, not permissions list\n  const taskSection = `# Task\nWrite a ${wordRange} word story.\n\nFind the one image the reader won't forget. Build outward from there.\n\n- You may reassign characters to different roles or invent minor characters\n- The narrative structure below is a starting shape, not a requirement\n- Write directly with no section headers or meta-commentary`;\n\n  // 2. NARRATIVE STRUCTURE \u2014 softened: presented as suggestion\n  const structureSection = buildCreativeStructureSection(style);\n\n  // 3. EVENT USAGE\n  const eventSection = buildEventUsageSection(style);\n\n  // 4. NARRATIVE VOICE \u2014 V0-style header (not \"Story Bible\")\n  let narrativeVoiceSection = \"\";\n  if (context.narrativeVoice && Object.keys(context.narrativeVoice).length > 0) {\n    const voiceLines: string[] = [\"# Tone & Atmosphere\"];\n    voiceLines.push(\"Synthesized prose guidance for this chronicle:\");\n    voiceLines.push(\"\");\n    for (const [key, value] of Object.entries(context.narrativeVoice)) {\n      voiceLines.push(`**${key}**: ${value}`);\n    }\n    narrativeVoiceSection = voiceLines.join(\"\\n\");\n  }\n\n  // 5. ENTITY WRITING DIRECTIVES \u2014 V0-style header (not \"Story Bible\")\n  let entityDirectivesSection = \"\";\n  if (context.entityDirectives && context.entityDirectives.length > 0) {\n    const directiveLines: string[] = [\"# Character Notes\"];\n    directiveLines.push(\n      \"Specific guidance for writing each entity \u2014 interpret creatively, don't reproduce this language directly:\"\n    );\n    directiveLines.push(\"\");\n    for (const directive of context.entityDirectives) {\n      directiveLines.push(`**${directive.entityName}**: ${directive.directive}`);\n    }\n    entityDirectivesSection = directiveLines.join(\"\\n\");\n  }\n\n  // 6. WRITING STYLE \u2014 same as structured, including craft posture\n  const styleSection = buildCreativeStyleSection(context.tone, style);\n\n  // === WORLD DATA ===\n\n  // 7. CAST (unified roles + characters \u2014 same as structured)\n  const castSection = buildUnifiedCastSection(selection, primaryEntityIds, style, prominenceScale);\n\n  // 7b. NARRATIVE LENS (contextual frame entity)\n  const lensSection = buildNarrativeLensSection(context, prominenceScale);\n\n  // 8. WORLD (setting context only, no style)\n  const worldSection = buildWorldSection(context);\n\n  // 9. NAME BANK (practical data)\n  const nameBankSection = buildNameBankSection(context.nameBank, selection.entities);\n\n  // 10. HISTORICAL CONTEXT\n  const temporalSection = buildTemporalSection(context.temporalContext, context.temporalNarrative);\n\n  // 11 & 12. RELATIONSHIPS + EVENTS\n  const dataSection = buildDataSection(selection);\n\n  // NARRATIVE DIRECTION (optional, between task and structure)\n  const narrativeDirectionSection = buildNarrativeDirectionSection(context.narrativeDirection);\n\n  // Combine sections in order: TASK DATA then WORLD DATA\n  const sections = [\n    // TASK DATA\n    taskSection,\n    narrativeDirectionSection,\n    structureSection,\n    eventSection,\n    narrativeVoiceSection,\n    entityDirectivesSection,\n    styleSection,\n    // WORLD DATA\n    castSection,\n    lensSection,\n    worldSection,\n    nameBankSection,\n    temporalSection,\n    dataSection,\n  ].filter(Boolean);\n\n  return sections.join(\"\\n\\n\");\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "selection", "type": "V2SelectionResult", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext", "EntityContext", "NarrativeEventContext", "ChronicleTemporalContext", "EraTemporalInfo"], "category": "internal"}, {"source": "../selectionWizard", "specifiers": ["collapseBidirectionalRelationships", "CollapsedRelationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["NarrativeStyle", "StoryNarrativeStyle", "DocumentNarrativeStyle", "ProminenceScale", "buildProminenceScale", "DEFAULT_PROMINENCE_DISTRIBUTION", "prominenceLabelFromScale"], "category": "external"}, {"source": "./types", "specifiers": ["V2SelectionResult"], "category": "internal"}, {"source": "../../perspectiveSynthesizer", "specifiers": ["EntityDirective"], "category": "internal"}]}, {"id": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts::selectEntitiesV2", "name": "selectEntitiesV2", "kind": "function", "filePath": "apps/illuminator/webui/src/lib/chronicle/v2/selectionV2.ts", "sourceCode": "/**\n * Extract selected entities/relationships/events from chronicle focus.\n *\n * The wizard has already done the selection work via role assignments.\n * This function just extracts and formats for prompt building.\n */\nexport function selectEntitiesV2(\n  context: ChronicleGenerationContext,\n  config: V2SelectionConfig = DEFAULT_V2_CONFIG\n): V2SelectionResult {\n  if (!context.focus?.roleAssignments?.length) {\n    throw new Error(\"V2 selection requires focus with role assignments\");\n  }\n\n  const selectedEntityIds = new Set(context.focus.selectedEntityIds);\n  const selectedEntities = context.entities.filter((e) => selectedEntityIds.has(e.id));\n\n  // Use selected relationships from focus\n  const selectedRelationships = context.focus.selectedRelationshipIds?.length\n    ? context.relationships.filter((r) => {\n        const relId = `${r.src}:${r.dst}:${r.kind}`;\n        return context.focus!.selectedRelationshipIds.includes(relId);\n      })\n    : context.relationships.filter(\n        (r) => selectedEntityIds.has(r.src) && selectedEntityIds.has(r.dst)\n      );\n\n  // Use selected events from focus\n  const selectedEventIds = new Set(context.focus.selectedEventIds || []);\n  const selectedEvents =\n    selectedEventIds.size > 0\n      ? context.events.filter((e) => selectedEventIds.has(e.id))\n      : context.events\n          .filter(\n            (e) =>\n              selectedEntityIds.has(e.subjectId || \"\") || selectedEntityIds.has(e.objectId || \"\")\n          )\n          .slice(0, config.maxEvents);\n\n  return {\n    entities: selectedEntities,\n    relationships: selectedRelationships.slice(0, config.maxRelationships),\n    events: selectedEvents.slice(0, config.maxEvents),\n  };\n}", "parameters": [{"name": "context", "type": "ChronicleGenerationContext", "optional": false}, {"name": "config", "type": "V2SelectionConfig", "optional": true}], "returnType": "V2SelectionResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../chronicleTypes", "specifiers": ["ChronicleGenerationContext"], "category": "internal"}, {"source": "./types", "specifiers": ["V2SelectionConfig", "V2SelectionResult"], "category": "internal"}, {"source": "./types", "specifiers": ["DEFAULT_V2_CONFIG"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/index.ts::generateId", "name": "generateId", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function generateId(prefix: string): string {\n  return `${prefix}_${idCounter++}`;\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::pickRandom", "name": "pickRandom", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function pickRandom<T>(array: T[]): T {\r\n  return array[Math.floor(secureRandom() * array.length)];\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}], "returnType": "T", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::pickMultiple", "name": "pickMultiple", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function pickMultiple<T>(array: T[], count: number): T[] {\r\n  const shuffled = shuffle(array);\r\n  return shuffled.slice(0, Math.min(count, array.length));\r\n}", "parameters": [{"name": "array", "type": "T[]", "optional": false}, {"name": "count", "type": "number", "optional": false}], "returnType": "T[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::findEntities", "name": "findEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Find entities matching criteria\r\n */\r\nexport function findEntities(\r\n  graph: Graph,\r\n  criteria: Partial<HardState>\r\n): HardState[] {\r\n  const results: HardState[] = [];\r\n\r\n  graph.forEachEntity(entity => {\r\n    let matches = true;\r\n\r\n    for (const [key, value] of Object.entries(criteria)) {\r\n      if (entity[key as keyof HardState] !== value) {\r\n        matches = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches) {\r\n      results.push(entity);\r\n    }\r\n  });\r\n\r\n  return results;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "criteria", "type": "Partial<HardState>", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getRelated", "name": "getRelated", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get related entities via relationships\r\n */\r\nexport function getRelated(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipKind?: string,\r\n  direction: 'src' | 'dst' | 'both' = 'both',\r\n  options?: RelationshipQueryOptions\r\n): HardState[] {\r\n  const related: Array<{ entity: HardState; strength: number }> = [];\r\n  const opts = options || {};\r\n\r\n  graph.getRelationships().forEach(rel => {\r\n    if (relationshipKind && rel.kind !== relationshipKind) return;\r\n\r\n    // Strength filtering\r\n    const strength = rel.strength ?? 0.5;\r\n    if (opts.minStrength !== undefined && strength < opts.minStrength) return;\r\n    if (opts.maxStrength !== undefined && strength > opts.maxStrength) return;\r\n\r\n    if ((direction === 'src' || direction === 'both') && rel.src === entityId) {\r\n      const entity = graph.getEntity(rel.dst);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n\r\n    if ((direction === 'dst' || direction === 'both') && rel.dst === entityId) {\r\n      const entity = graph.getEntity(rel.src);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n  });\r\n\r\n  // Sort by strength if requested\r\n  if (opts.sortByStrength) {\r\n    related.sort((a, b) => b.strength - a.strength);\r\n  }\r\n\r\n  return related.map(r => r.entity);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": true}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}, {"name": "options", "type": "RelationshipQueryOptions", "optional": true}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function hasRelationship(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind?: string\r\n): boolean {\r\n  return graph.getRelationships().some(rel =>\r\n    rel.src === srcId &&\r\n    rel.dst === dstId &&\r\n    (!kind || rel.kind === kind)\r\n  );\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": true}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::normalizeInitialState", "name": "normalizeInitialState", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function normalizeInitialState(entities: RawEntityInput[]): HardState[] {\n  return entities.map((entity, index) => {\n    if (!entity.id) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no id. ` +\n        `Seed entities must include a stable id used by relationships.`\n      );\n    }\n    if (!entity.name) {\n      throw new Error(\n        `normalizeInitialState: entity at index ${index} has no name. ` +\n        `Initial state entities must have names defined in JSON.`\n      );\n    }\n    if (!entity.coordinates) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no coordinates. ` +\n        `Initial state entities must have coordinates defined in JSON.`\n      );\n    }\n    if (!entity.kind) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no kind.`\n      );\n    }\n    if (!entity.subtype) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no subtype.`\n      );\n    }\n    if (!entity.status) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no status.`\n      );\n    }\n    if (!entity.prominence) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no prominence.`\n      );\n    }\n    if (!entity.culture) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no culture.`\n      );\n    }\n\n    // Handle both old array format and new KVP format for tags\n    let tags: EntityTags;\n    if (Array.isArray(entity.tags)) {\n      tags = arrayToTags(entity.tags);\n    } else {\n      tags = entity.tags || {};\n    }\n\n    const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n    return {\n      id: entity.id,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      name: entity.name,\n      summary: entity.summary,\n      narrativeHint,\n      description: entity.description || '',\n      status: entity.status,\n      prominence: entity.prominence,\n      culture: entity.culture,\n      tags,\n      createdAt: 0,\n      updatedAt: 0,\n      coordinates: entity.coordinates\n    };\n  });\n}", "parameters": [{"name": "entities", "type": "RawEntityInput[]", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::slugifyName", "name": "slugifyName", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Slugify a name for use in IDs or other contexts\n */\nexport function slugifyName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '') || 'unknown'; // eslint-disable-line sonarjs/slow-regex -- short slug string, no ReDoS risk\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::generateEntityIdFromName", "name": "generateEntityIdFromName", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Generate a stable entity ID from a name, with optional collision handling.\n */\nexport function generateEntityIdFromName(\n  name: string,\n  hasEntity?: (id: string) => boolean,\n  log?: (message: string, context?: Record<string, unknown>) => void\n): string {\n  const baseId = slugifyName(name);\n  if (!hasEntity) return baseId;\n  if (!hasEntity(baseId)) return baseId;\n\n  let suffix = 2;\n  let candidate = `${baseId}-${suffix}`;\n  while (hasEntity(candidate)) {\n    suffix += 1;\n    candidate = `${baseId}-${suffix}`;\n  }\n\n  log?.(`Entity id collision for \"${name}\". Using \"${candidate}\".`, {\n    name,\n    baseId,\n    resolvedId: candidate\n  });\n\n  return candidate;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "hasEntity", "type": "(id: string) => boolean", "optional": true}, {"name": "log", "type": "(message: string, context?: Record<string, unknown>) => void", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::archiveRelationship", "name": "archiveRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Archive a relationship by marking it as historical.\r\n */\r\nexport function archiveRelationship(\r\n  graph: Graph,\r\n  src: string,\r\n  dst: string,\r\n  kind: string,\r\n  reason?: string\r\n): void {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === src &&\r\n    r.dst === dst &&\r\n    r.kind === kind &&\r\n    r.status !== 'historical'\r\n  );\r\n\r\n  if (rel) {\r\n    const age = graph.tick - (rel.createdAt ?? 0);\r\n    rel.status = 'historical';\r\n    rel.archivedAt = graph.tick;\r\n\r\n    // Record archival for context-based event generation\r\n    graph.mutationTracker?.recordRelationshipArchived({\r\n      srcId: src,\r\n      dstId: dst,\r\n      kind,\r\n      age,\r\n      reason,\r\n    });\r\n  }\r\n\r\n  const srcEntity = graph.getEntity(src);\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  const dstEntity = graph.getEntity(dst);\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "reason", "type": "string", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::modifyRelationshipStrength", "name": "modifyRelationshipStrength", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Modify relationship strength by delta\r\n */\r\nexport function modifyRelationshipStrength(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind: string,\r\n  delta: number\r\n): boolean {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === srcId && r.dst === dstId && r.kind === kind\r\n  );\r\n\r\n  if (!rel) return false;\r\n\r\n  const currentStrength = rel.strength ?? 0.5;\r\n  rel.strength = Math.max(0.0, Math.min(1.0, currentStrength + delta));\r\n\r\n  const srcEntity = graph.getEntity(srcId);\r\n  const dstEntity = graph.getEntity(dstId);\r\n\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  return true;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "delta", "type": "number", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::mergeTags", "name": "mergeTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Merge multiple tag objects. Later tags override earlier ones.\r\n */\r\nexport function mergeTags(...tagSets: (EntityTags | undefined)[]): EntityTags {\r\n  const result: EntityTags = {};\r\n  for (const tags of tagSets) {\r\n    if (tags) {\r\n      Object.assign(result, tags);\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "tagSets", "type": "(EntityTags | undefined)[]", "optional": false}], "returnType": "EntityTags", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::hasTag", "name": "hasTag", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if an entity has a specific tag.\r\n * @param tags - The entity's tags\r\n * @param key - The tag key to check\r\n * @param value - Optional: specific value to match (if not provided, checks key existence)\r\n */\r\nexport function hasTag(tags: EntityTags | undefined, key: string, value?: string | boolean): boolean {\r\n  if (!tags) return false;\r\n  if (!(key in tags)) return false;\r\n  if (value === undefined) return true;\r\n  return tags[key] === value;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "value", "type": "string | boolean", "optional": true}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getTagValue", "name": "getTagValue", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get a tag's value, with optional default.\r\n */\r\nexport function getTagValue<T extends string | boolean>(\r\n  tags: EntityTags | undefined,\r\n  key: string,\r\n  defaultValue?: T\r\n): T | undefined {\r\n  if (!tags || !(key in tags)) return defaultValue;\r\n  return tags[key] as T;\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "defaultValue", "type": "T", "optional": true}], "returnType": "T | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getTrueTagKeys", "name": "getTrueTagKeys", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get all tag keys that have truthy values.\r\n */\r\nexport function getTrueTagKeys(tags: EntityTags | undefined): string[] {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => value === true)\r\n    .map(([key]) => key);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "string[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getStringTags", "name": "getStringTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Get all string-valued tags as key-value entries.\r\n */\r\nexport function getStringTags(tags: EntityTags | undefined): Array<[string, string]> {\r\n  if (!tags) return [];\r\n  return Object.entries(tags)\r\n    .filter(([_, value]) => typeof value === 'string')\r\n    .map(([key, value]) => [key, value as string]);\r\n}", "parameters": [{"name": "tags", "type": "EntityTags | undefined", "optional": false}], "returnType": "Array<[string, string]>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::arrayToTags", "name": "arrayToTags", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Convert array tags to EntityTags (KVP) format.\r\n * Plain strings become boolean true, \"key:value\" becomes string value.\r\n */\r\nexport function arrayToTags(arr: string[] | undefined): EntityTags {\r\n  if (!arr) return {};\r\n  const result: EntityTags = {};\r\n  for (const tag of arr) {\r\n    if (tag.startsWith('!')) {\r\n      result[tag.slice(1)] = false;\r\n    } else if (tag.includes(':')) {\r\n      const [key, ...valueParts] = tag.split(':');\r\n      result[key] = valueParts.join(':');\r\n    } else {\r\n      result[tag] = true;\r\n    }\r\n  }\r\n  return result;\r\n}", "parameters": [{"name": "arr", "type": "string[] | undefined", "optional": false}], "returnType": "EntityTags", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::rollProbability", "name": "rollProbability", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if a probabilistic event should occur, scaled by an era modifier.\r\n *\r\n * @param baseProbability - Base chance of the event occurring (0.0 to 1.0)\r\n *                         e.g., 0.3 = 30% chance\r\n * @param eraModifier - Era-based multiplier for the probability\r\n *                      > 1 increases likelihood, < 1 decreases it\r\n * @returns true if the event should occur\r\n *\r\n * @example\r\n * // 30% base chance, doubled in conflict era (modifier = 2)\r\n * if (rollProbability(0.3, eraModifier)) {\r\n *   createConflict();\r\n * }\r\n */\r\nexport function rollProbability(baseProbability: number, eraModifier: number = 1.0): boolean {\r\n  const p = baseProbability;\r\n\r\n  // Edge cases: probability of 0 or 1 should be deterministic\r\n  if (p <= 0) return false;\r\n  if (p >= 1) return true;\r\n\r\n  // odds scaling\r\n  const odds = p / (1 - p);\r\n  const scaledOdds = Math.pow(odds, eraModifier);\r\n  const scaledP = scaledOdds / (1 + scaledOdds);\r\n\r\n  return secureRandom() < scaledP;\r\n}", "parameters": [{"name": "baseProbability", "type": "number", "optional": false}, {"name": "eraModifier", "type": "number", "optional": true}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::addEntity", "name": "addEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export async function addEntity(graph: Graph, entity: Partial<HardState>, source?: string, placementStrategy?: string): Promise<string> {\n  validateEntityForAdd(entity);\n\n  const coords = entity.coordinates!;\n  const tags: EntityTags = Array.isArray(entity.tags) ? arrayToTags(entity.tags) : { ...(entity.tags || {}) };\n\n  const entityId = generateEntityIdFromName(entity.name!, id => graph.hasEntity(id));\n\n  // Delegate to Graph.createEntity()\n  // Use validated coords to satisfy TypeScript (already validated above)\n  if (typeof coords.z !== 'number') {\n    throw new Error(\n      `addEntity: coordinates must include numeric z. ` +\n      `Entity kind: ${entity.kind}, name: ${entity.name || 'unnamed'}. ` +\n      `Received: ${JSON.stringify(coords)}.`\n    );\n  }\n  const validCoords = { x: coords.x, y: coords.y, z: coords.z };\n\n  const currentEraEntity = entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA\n    ? graph.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0]\n    : undefined;\n  const explicitEraId = entity.eraId;\n  let resolvedEraId: string | undefined;\n  if (typeof explicitEraId === 'string' && explicitEraId) {\n    resolvedEraId = explicitEraId;\n  } else if (entity.kind === FRAMEWORK_ENTITY_KINDS.ERA) {\n    resolvedEraId = entity.subtype;\n  } else {\n    resolvedEraId = currentEraEntity?.id;\n  }\n\n  const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n  const createdId = await graph.createEntity({\n    id: entityId,\n    kind: entity.kind!,\n    subtype: entity.subtype!,\n    coordinates: validCoords,\n    tags,\n    eraId: resolvedEraId,\n    name: entity.name,\n    description: entity.description,\n    narrativeHint,\n    status: entity.status!,\n    prominence: entity.prominence!,\n    culture: entity.culture!,\n    temporal: entity.temporal,\n    source,\n    placementStrategy\n  });\n\n  // Create CREATED_DURING relationship to current era (unless entity is an era itself)\n  // This is a framework-level temporal relationship distinct from spatial \"originated_in\"\n  if (entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA && currentEraEntity) {\n    graph.addRelationship(\n      FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING,\n      entityId,\n      currentEraEntity.id,\n      FRAMEWORK_RELATIONSHIP_PROPERTIES[FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING].defaultStrength\n    );\n  }\n\n  return createdId;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "Partial<HardState>", "optional": false}, {"name": "source", "type": "string", "optional": true}, {"name": "placementStrategy", "type": "string", "optional": true}], "returnType": "Promise<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::addRelationship", "name": "addRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP MUTATION\r\n// ===========================\r\n\r\n/**\r\n * Add a relationship between two entities.\r\n * Distance is ALWAYS computed from Euclidean distance between coordinates.\r\n */\r\nexport function addRelationship(\r\n  graph: Graph,\r\n  kind: string,\r\n  srcId: string,\r\n  dstId: string,\r\n  strength: number = 0.5\r\n): void {\r\n  graph.addRelationship(kind, srcId, dstId, strength);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::canFormRelationship", "name": "canFormRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP COOLDOWN\r\n// ===========================\r\n\r\n/**\r\n * Check if an entity can form a new relationship based on cooldown.\r\n */\r\nexport function canFormRelationship(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string,\r\n  cooldownTicks: number\r\n): boolean {\r\n  const entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n  if (!entityCooldowns) return true;\r\n\r\n  const lastFormationTick = entityCooldowns.get(relationshipType);\r\n  if (lastFormationTick === undefined) return true;\r\n\r\n  return (graph.tick - lastFormationTick) >= cooldownTicks;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}, {"name": "cooldownTicks", "type": "number", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::recordRelationshipFormation", "name": "recordRelationshipFormation", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Record that an entity has formed a relationship.\r\n */\r\nexport function recordRelationshipFormation(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string\r\n): void {\r\n  let entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n\r\n  if (!entityCooldowns) {\r\n    entityCooldowns = new Map();\r\n    graph.relationshipCooldowns.set(entityId, entityCooldowns);\r\n  }\r\n\r\n  entityCooldowns.set(relationshipType, graph.tick);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getConnectionWeight", "name": "getConnectionWeight", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Calculate relationship formation weight based on existing connection count.\r\n * Favors underconnected entities to balance network density and prevent hubs.\r\n */\r\nexport function getConnectionWeight(graph: Graph, entity: HardState): number {\r\n  const connectionCount = graph.getEntityRelationships(entity.id, 'both').length;\r\n\r\n  // Boost isolated/underconnected entities\r\n  if (connectionCount === 0) return 3.0;    // Strongly boost isolated\r\n  if (connectionCount <= 2) return 2.0;     // Boost underconnected (below median)\r\n  if (connectionCount <= 5) return 1.0;     // Normal\r\n  if (connectionCount <= 10) return 0.5;    // Reduce well-connected\r\n  return 0.2;                               // Heavily reduce hubs (15+)\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::validateWorld", "name": "validateWorld", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// validateLorePresence moved to @illuminator\n\n/**\n * Run all validators and generate a complete report\n */\nexport function validateWorld(graph: Graph, config: EngineConfig): ValidationReport {\n  const results: ValidationResult[] = [\n    validateConnectedEntities(graph),\n    validateNPCStructure(graph, config),\n    validateRelationshipIntegrity(graph)\n    // validateLorePresence moved to @illuminator\n  ];\n\n  const passed = results.filter(r => r.passed).length;\n  const failed = results.filter(r => !r.passed).length;\n\n  return {\n    totalChecks: results.length,\n    passed,\n    failed,\n    results\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::calculateSimilarity", "name": "calculateSimilarity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Calculate similarity score between two entities based on criteria\n */\nexport function calculateSimilarity(\n  e1: HardState,\n  e2: HardState,\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime\n): { score: number; matchedCriteria: string[] } {\n  let score = 0;\n  const matchedCriteria: string[] = [];\n\n  for (const criterion of criteria) {\n    let matches = false;\n\n    switch (criterion.type) {\n      case 'shared_relationship': {\n        if (!criterion.relationshipKind) break;\n        const direction = criterion.direction || 'src';\n\n        const e1Related = graphView.getConnectedEntities(e1.id, criterion.relationshipKind, direction);\n        const e2Related = graphView.getConnectedEntities(e2.id, criterion.relationshipKind, direction);\n        const e1RelatedIds = new Set(e1Related.map(r => r.id));\n        matches = e2Related.some(r => e1RelatedIds.has(r.id));\n        break;\n      }\n\n      case 'shared_tags': {\n        const e1Tags = new Set(Object.keys(e1.tags || {}));\n        const e2Tags = new Set(Object.keys(e2.tags || {}));\n        const intersection = Array.from(e1Tags).filter(t => e2Tags.has(t)).length;\n        const union = new Set([...e1Tags, ...e2Tags]).size;\n        const jaccard = union > 0 ? intersection / union : 0;\n        matches = jaccard >= (criterion.threshold || 0.3);\n        break;\n      }\n\n      case 'temporal_proximity': {\n        const timeDiff = Math.abs(e1.createdAt - e2.createdAt);\n        matches = timeDiff <= (criterion.threshold || 30);\n        break;\n      }\n\n      case 'same_subtype': {\n        matches = e1.subtype === e2.subtype;\n        break;\n      }\n\n      case 'same_culture': {\n        matches = e1.culture === e2.culture;\n        break;\n      }\n\n      case 'custom': {\n        if (criterion.predicate) {\n          matches = criterion.predicate(e1, e2, graphView);\n        }\n        break;\n      }\n    }\n\n    if (matches) {\n      score += criterion.weight;\n      matchedCriteria.push(criterion.type);\n    }\n  }\n\n  return { score, matchedCriteria };\n}", "parameters": [{"name": "e1", "type": "HardState", "optional": false}, {"name": "e2", "type": "HardState", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "{ score: number; matchedCriteria: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::detectClusters", "name": "detectClusters", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function detectClusters(\n  entities: HardState[],\n  config: ClusterConfig,\n  graphView: WorldRuntime\n): Cluster[] {\n  if (entities.length < config.minSize) {\n    return [];\n  }\n\n  // Sort by creation time (cluster chronologically related entities)\n  const sorted = [...entities].sort((a, b) => a.createdAt - b.createdAt);\n\n  // Greedy clustering: try to add each entity to an existing cluster or create new one\n  const clusters: Cluster[] = [];\n  const clusterJoinThreshold = config.clusterJoinThreshold ?? 0.7;\n\n  for (const entity of sorted) {\n    const matched = tryAddToExistingCluster(entity, clusters, config, clusterJoinThreshold, graphView);\n    if (!matched) {\n      clusters.push({\n        entities: [entity],\n        score: config.minimumScore,\n        matchedCriteria: []\n      });\n    }\n  }\n\n  // Filter clusters by minimum size and apply maximum size\n  const validClusters = clusters.filter(c => {\n    if (c.entities.length < config.minSize) return false;\n    if (config.maxSize && c.entities.length > config.maxSize) {\n      // Truncate cluster to max size (keep earliest created)\n      c.entities = c.entities.slice(0, config.maxSize);\n    }\n    return true;\n  });\n\n  return validClusters;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "config", "type": "ClusterConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "Cluster[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::filterClusterableEntities", "name": "filterClusterableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Filter entities that are eligible for clustering.\n * Excludes historical entities and meta-entities.\n *\n * @param entities - All entities to filter\n * @returns Filtered entities eligible for clustering\n */\nexport function filterClusterableEntities(entities: HardState[]): HardState[] {\n  return entities.filter(e =>\n    e.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    e.status !== FRAMEWORK_STATUS.SUBSUMED &&\n    !hasTag(e.tags, FRAMEWORK_TAGS.META_ENTITY)\n  );\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::findBestClusterMatch", "name": "findBestClusterMatch", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Find the best cluster match for a new entity.\n * Useful for deciding which existing cluster to add a new entity to.\n *\n * @param entity - Entity to find cluster for\n * @param clusters - Existing clusters\n * @param criteria - Similarity criteria\n * @param graphView - Graph view for relationship queries\n * @param minimumScore - Minimum score to be considered a match\n * @returns Best matching cluster or undefined\n */\nexport function findBestClusterMatch(\n  entity: HardState,\n  clusters: Cluster[],\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime,\n  minimumScore: number\n): Cluster | undefined {\n  let bestCluster: Cluster | undefined;\n  let bestScore = 0;\n\n  for (const cluster of clusters) {\n    let totalScore = 0;\n    let count = 0;\n\n    for (const member of cluster.entities) {\n      const { score } = calculateSimilarity(entity, member, criteria, graphView);\n      totalScore += score;\n      count++;\n    }\n\n    const avgScore = count > 0 ? totalScore / count : 0;\n\n    if (avgScore >= minimumScore && avgScore > bestScore) {\n      bestCluster = cluster;\n      bestScore = avgScore;\n    }\n  }\n\n  return bestCluster;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "clusters", "type": "Cluster[]", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "minimumScore", "type": "number", "optional": false}], "returnType": "Cluster | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::archiveEntity", "name": "archiveEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Mark an entity as historical and optionally archive its relationships.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity to archive\n * @param options - Archival options\n */\nexport function archiveEntity(\n  graph: Graph,\n  entityId: string,\n  options: ArchiveEntityOptions = {}\n): void {\n  const entity = graph.getEntity(entityId);\n  if (!entity) return;\n\n  const {\n    archiveRelationships: shouldArchiveRels = true,\n    excludeRelationshipKinds = [],\n    status = FRAMEWORK_STATUS.HISTORICAL\n  } = options;\n\n  // Mark entity as historical (use updateEntity to trigger mutation tracking)\n  graph.updateEntity(entityId, { status });\n\n  // Archive relationships if requested\n  if (shouldArchiveRels) {\n    const entityRelationships = graph.getRelationships().filter(r =>\n      (r.src === entityId || r.dst === entityId) &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n      !excludeRelationshipKinds.includes(r.kind)\n    );\n\n    entityRelationships.forEach(rel => {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::archiveEntities", "name": "archiveEntities", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Archive multiple entities at once.\n *\n * @param graph - The world graph\n * @param entityIds - IDs of entities to archive\n * @param options - Archival options\n */\nexport function archiveEntities(\n  graph: Graph,\n  entityIds: string[],\n  options: ArchiveEntityOptions = {}\n): void {\n  entityIds.forEach(id => archiveEntity(graph, id, options));\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityIds", "type": "string[]", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::transferRelationships", "name": "transferRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Transfer relationships from source entities to a target entity.\n * Creates new relationships with the target and optionally archives originals.\n *\n * @param graph - The world graph\n * @param sourceIds - IDs of entities to transfer relationships from\n * @param targetId - ID of entity to transfer relationships to\n * @param options - Transfer options\n * @returns Number of relationships transferred\n */\nexport function transferRelationships(\n  graph: Graph,\n  sourceIds: string[],\n  targetId: string,\n  options: TransferRelationshipsOptions = {}\n): number {\n  const {\n    excludeKinds = [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n    sourceOnly = false,\n    destinationOnly = false,\n    archiveOriginals = true\n  } = options;\n\n  const sourceIdSet = new Set(sourceIds);\n  const transferred = new Set<string>();\n\n  // Find all relationships involving source entities\n  const toTransfer = graph.getRelationships().filter(r =>\n    (sourceIdSet.has(r.src) || sourceIdSet.has(r.dst)) &&\n    r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    !excludeKinds.includes(r.kind)\n  );\n\n  toTransfer.forEach(rel => {\n    let newSrc = rel.src;\n    let newDst = rel.dst;\n\n    // Determine new endpoints\n    if (sourceIdSet.has(rel.src) && !destinationOnly) {\n      newSrc = targetId;\n    }\n    if (sourceIdSet.has(rel.dst) && !sourceOnly) {\n      newDst = targetId;\n    }\n\n    // Skip if no change (shouldn't happen with proper source filtering)\n    if (newSrc === rel.src && newDst === rel.dst) return;\n\n    // Handle self-loops (both endpoints are being transferred to same target)\n    // Don't create self-referential relationship, but DO archive the original\n    if (newSrc === newDst) {\n      if (archiveOriginals) {\n        archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n      }\n      return;\n    }\n\n    // Avoid duplicates\n    const key = `${newSrc}:${newDst}:${rel.kind}`;\n    if (transferred.has(key)) return;\n\n    // Create new relationship\n    addRelationship(graph, rel.kind, newSrc, newDst);\n    transferred.add(key);\n\n    // Archive original if requested\n    if (archiveOriginals) {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    }\n  });\n\n  return transferred.size;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "sourceIds", "type": "string[]", "optional": false}, {"name": "targetId", "type": "string", "optional": false}, {"name": "options", "type": "TransferRelationshipsOptions", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createPartOfRelationships", "name": "createPartOfRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Create part_of relationships from members to a container entity.\n *\n * @param graph - The world graph\n * @param memberIds - IDs of member entities\n * @param containerId - ID of container entity\n * @returns Number of relationships created\n */\nexport function createPartOfRelationships(\n  graph: Graph,\n  memberIds: string[],\n  containerId: string\n): number {\n  let created = 0;\n\n  memberIds.forEach(memberId => {\n    // Check if relationship already exists\n    const exists = graph.getRelationships().some(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.src === memberId &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    );\n\n    if (!exists) {\n      addRelationship(graph, FRAMEWORK_RELATIONSHIP_KINDS.PART_OF, memberId, containerId);\n      created++;\n    }\n  });\n\n  return created;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "memberIds", "type": "string[]", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getActiveRelationships", "name": "getActiveRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all active relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @param direction - Filter by direction ('src', 'dst', or 'both')\n * @returns Active relationships\n */\nexport function getActiveRelationships(\n  graph: Graph,\n  entityId: string,\n  direction: 'src' | 'dst' | 'both' = 'both'\n): Relationship[] {\n  return graph.getRelationships().filter(r => {\n    if (r.status === FRAMEWORK_STATUS.HISTORICAL) return false;\n\n    switch (direction) {\n      case 'src':\n        return r.src === entityId;\n      case 'dst':\n        return r.dst === entityId;\n      case 'both':\n        return r.src === entityId || r.dst === entityId;\n    }\n  });\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}], "returnType": "Relationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getHistoricalRelationships", "name": "getHistoricalRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all historical relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @returns Historical relationships\n */\nexport function getHistoricalRelationships(\n  graph: Graph,\n  entityId: string\n): Relationship[] {\n  return graph.getRelationships().filter(r =>\n    r.status === FRAMEWORK_STATUS.HISTORICAL &&\n    (r.src === entityId || r.dst === entityId)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Relationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::isHistoricalEntity", "name": "isHistoricalEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity is historical.\n *\n * @param entity - Entity to check\n * @returns True if entity is historical\n */\nexport function isHistoricalEntity(entity: HardState): boolean {\n  return entity.status === FRAMEWORK_STATUS.HISTORICAL;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getPartOfMembers", "name": "getPartOfMembers", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all entities that are part of a container entity.\n *\n * @param graph - The world graph\n * @param containerId - ID of container entity\n * @returns Member entities\n */\nexport function getPartOfMembers(\n  graph: Graph,\n  containerId: string\n): HardState[] {\n  const memberIds = graph.getRelationships()\n    .filter(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    )\n    .map(r => r.src);\n\n  return memberIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::supersedeEntity", "name": "supersedeEntity", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Supersede one entity with another.\n * Creates supersedes relationship, transfers relationships, and archives original.\n *\n * @param graph - The world graph\n * @param oldEntityId - ID of entity being superseded\n * @param newEntityId - ID of new entity\n * @param options - Supersede options\n */\nexport function supersedeEntity(\n  graph: Graph,\n  oldEntityId: string,\n  newEntityId: string,\n  options: SupersedeEntityOptions = {}\n): void {\n  const {\n    archiveSuperseded = true,\n    createSupersedes = true,\n    ...transferOptions\n  } = options;\n\n  // Create supersedes relationship (new supersedes old)\n  if (createSupersedes) {\n    addRelationship(\n      graph,\n      FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n      newEntityId,\n      oldEntityId\n    );\n  }\n\n  // Transfer relationships from old to new\n  transferRelationships(\n    graph,\n    [oldEntityId],\n    newEntityId,\n    {\n      ...transferOptions,\n      excludeKinds: [\n        ...(transferOptions.excludeKinds || []),\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    }\n  );\n\n  // Archive old entity\n  if (archiveSuperseded) {\n    archiveEntity(graph, oldEntityId, {\n      archiveRelationships: false, // Already handled by transfer\n      excludeRelationshipKinds: [\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "oldEntityId", "type": "string", "optional": false}, {"name": "newEntityId", "type": "string", "optional": false}, {"name": "options", "type": "SupersedeEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::buildRelationships", "name": "buildRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Helper function to create a new RelationshipBuilder\n * Usage: buildRelationships().add(...).add(...).build()\n */\nexport function buildRelationships(): RelationshipBuilder {\n  return new RelationshipBuilder();\n}", "parameters": [], "returnType": "RelationshipBuilder", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::initializeCatalyst", "name": "initializeCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Initialize or update catalyst properties for an entity\n * This is a helper for domain code to set up catalyst properties\n * @param entity - The entity to initialize\n * @param canAct - Can this entity perform actions?\n */\nexport function initializeCatalyst(\n  entity: HardState,\n  canAct: boolean\n): void {\n  entity.catalyst = {\n    canAct\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "canAct", "type": "boolean", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::initializeCatalystSmart", "name": "initializeCatalystSmart", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Initialize catalyst properties for entities of actor kinds.\n * All entities of eligible kinds can act - prominence affects action\n * success chance and attempt rate, not eligibility.\n *\n * @param entity - The entity to initialize\n */\nexport function initializeCatalystSmart(entity: HardState): void {\n  // Entity kinds that can act\n  const actorKinds = ['npc', 'faction', 'ability', 'occurrence', 'location', 'artifact', 'rule'];\n  if (!actorKinds.includes(entity.kind)) {\n    return;\n  }\n\n  entity.catalyst = {\n    canAct: true\n  };\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getAgentsByCategory", "name": "getAgentsByCategory", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all entities that can act (have catalyst.canAct = true)\n * @param graph - The world graph\n * @param category - Filter by agent category\n * @returns Array of agent entities\n */\nexport function getAgentsByCategory(\n  graph: Graph,\n  category: 'first-order' | 'second-order' | 'all' = 'all'\n): HardState[] {\n  const agents = graph.getEntities()\n    .filter(e => e.catalyst?.canAct === true);\n\n  if (category === 'all') {\n    return agents;\n  }\n\n  // First-order agents: npc, faction, ability, location (rare)\n  // Second-order agents: occurrence\n  if (category === 'first-order') {\n    return agents.filter(e => e.kind !== FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  } else {\n    return agents.filter(e => e.kind === FRAMEWORK_ENTITY_KINDS.OCCURRENCE);\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "category", "type": "'first-order' | 'second-order' | 'all'", "optional": true}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::canPerformAction", "name": "canPerformAction", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity can perform actions\n * @param entity - The entity to check\n * @returns True if entity can act\n */\nexport function canPerformAction(entity: HardState): boolean {\n  return entity.catalyst?.canAct === true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::recordCatalyst", "name": "recordCatalyst", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Record catalyst attribution on a relationship\n * @param relationship - The relationship to attribute\n * @param catalystId - ID of the agent that caused this\n * @returns The relationship with attribution added\n */\nexport function recordCatalyst(\n  relationship: Relationship,\n  catalystId: string\n): Relationship {\n  return {\n    ...relationship,\n    catalyzedBy: catalystId\n  };\n}", "parameters": [{"name": "relationship", "type": "Relationship", "optional": false}, {"name": "catalystId", "type": "string", "optional": false}], "returnType": "Relationship", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::getCatalyzedEvents", "name": "getCatalyzedEvents", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Get all events (relationships/entities) catalyzed by an entity\n * @param graph - The world graph\n * @param entityId - ID of the catalyst entity\n * @returns Array of relationships and entities caused by this catalyst\n */\nexport function getCatalyzedEvents(\n  graph: Graph,\n  entityId: string\n): (Relationship | HardState)[] {\n  const results: (Relationship | HardState)[] = [];\n\n  // Find relationships catalyzed by this entity\n  graph.getRelationships().forEach(rel => {\n    if (rel.catalyzedBy === entityId) {\n      results.push(rel);\n    }\n  });\n\n  // Find entities catalyzed by this entity (e.g., occurrences triggered by NPCs)\n  graph.forEachEntity(entity => {\n    const triggeredByRel = graph.getEntityRelationships(entity.id, 'src')\n      .find(rel => rel.kind === 'triggered_by' && rel.dst === entityId);\n    if (triggeredByRel) {\n      results.push(entity);\n    }\n  });\n\n  return results;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "(Relationship | HardState)[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::calculateAttemptChance", "name": "calculateAttemptChance", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Calculate action attempt chance based on entity prominence\n * @param entity - The entity attempting action\n * @param baseRate - Base action attempt rate (from system parameters)\n * @returns Probability of action attempt this tick\n */\nexport function calculateAttemptChance(\n  entity: HardState,\n  baseRate: number\n): number {\n  if (!entity.catalyst?.canAct) {\n    return 0;\n  }\n\n  const multiplier = getProminenceMultiplierValue(entity.prominence, 'action_rate');\n  const chance = baseRate * multiplier;\n\n  // Clamp to [0, 1]\n  return Math.max(0, Math.min(1, chance));\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "baseRate", "type": "number", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createConnectionEvolutionSystem", "name": "createConnectionEvolutionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ConnectionEvolutionConfig\r\n */\r\nexport function createConnectionEvolutionSystem(\r\n  config: ConnectionEvolutionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      return applyConnectionEvolution(config, graphView, modifier);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ConnectionEvolutionConfig", "optional": false}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createGraphContagionSystem", "name": "createGraphContagionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a GraphContagionConfig\r\n */\r\nexport function createGraphContagionSystem(\r\n  config: GraphContagionConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Use multi-source mode if configured, otherwise single-source mode\r\n      if (config.multiSource) {\r\n        return applyMultiSourceContagion(config, graphView, modifier);\r\n      } else {\r\n        return applySingleSourceContagion(config, graphView, modifier);\r\n      }\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "GraphContagionConfig", "optional": false}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createThresholdTriggerSystem", "name": "createThresholdTriggerSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a ThresholdTriggerConfig\r\n */\r\nexport function createThresholdTriggerSystem(\r\n  config: ThresholdTriggerConfig\r\n): SimulationSystem {\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      // Find entities matching selection\r\n      const selectionCtx = createSystemContext(graphView);\r\n      let entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      // Apply cooldown filter\r\n      if (config.cooldownTag) {\r\n        entities = entities.filter(e => !hasTag(e.tags, config.cooldownTag!));\r\n      }\r\n\r\n      // Evaluate conditions on each entity\r\n      const matchingEntities = entities.filter(entity =>\r\n        evaluateAllConditions(entity, config.conditions, graphView)\r\n      );\r\n\r\n      if (matchingEntities.length === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: no matches`\r\n        };\r\n      }\r\n\r\n      // Cluster matching entities\r\n      const clusters = clusterEntities(matchingEntities, config, graphView);\r\n\r\n      if (clusters.size === 0) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: clusters too small`\r\n        };\r\n      }\r\n\r\n      // Apply actions\r\n      const { modifications, relationships, relationshipsAdjusted, relationshipsToArchive, pressureChanges, skippedMembers, narrationsByGroup } =\r\n        applyActions(clusters, config, graphView);\r\n\r\n      const skippedInfo = skippedMembers > 0 ? `, ${skippedMembers} skipped (missing vars)` : '';\r\n      return {\r\n        relationshipsAdded: relationships,\r\n        relationshipsAdjusted,\r\n        relationshipsToArchive,\r\n        entitiesModified: modifications as SystemResult['entitiesModified'],\r\n        pressureChanges,\r\n        description: `${config.name}: ${clusters.size} trigger(s), ${modifications.length} entities tagged${skippedInfo}`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined,\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "ThresholdTriggerConfig", "optional": false}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createClusterFormationSystem", "name": "createClusterFormationSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// SYSTEM FACTORY\n// =============================================================================\n\n/**\n * Create a SimulationSystem from a ClusterFormationConfig\n */\nexport function createClusterFormationSystem(\n  config: ClusterFormationConfig\n): SimulationSystem {\n  // Convert declarative criteria to runtime criteria\n  const clusterConfig: ClusterConfig = {\n    minSize: config.clustering.minSize,\n    maxSize: config.clustering.maxSize,\n    criteria: toClusterCriteria(config.clustering.criteria),\n    minimumScore: config.clustering.minimumScore\n  };\n\n  return {\n    id: config.id,\n    name: config.name,\n\n    apply: async (graphView: WorldRuntime, _modifier: number = 1.0): Promise<SystemResult> => {\n      // Check epoch end if required\n      if (config.runAtEpochEnd) {\n        const ticksPerEpoch = graphView.config.ticksPerEpoch || 15;\n        if (graphView.tick % ticksPerEpoch !== 0) {\n          return {\n            relationshipsAdded: [],\n            entitiesModified: [],\n            pressureChanges: {},\n            description: `${config.name}: not epoch end, skipping`\n          };\n        }\n      }\n\n      // Find entities eligible for clustering\n      const selectionCtx = createSystemContext(graphView);\n      let entities = selectEntities(config.selection, selectionCtx);\n\n      // Filter out historical and meta-entities\n      entities = filterClusterableEntities(entities);\n\n      if (entities.length < clusterConfig.minSize) {\n        return {\n          relationshipsAdded: [],\n          entitiesModified: [],\n          pressureChanges: {},\n          description: `${config.name}: not enough entities (${entities.length})`\n        };\n      }\n\n      // Detect clusters\n      const clusters = detectClusters(entities, clusterConfig, graphView);\n\n      const relationshipsAdded: Array<Relationship & { narrativeGroupId?: string }> = [];\n      const entitiesModified: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\n      const metaEntitiesCreated: string[] = [];\n      const factionsCreated: string[] = [];\n      const narrationsByGroup: Record<string, string> = {};\n\n      // Form meta-entities from valid clusters\n      for (const cluster of clusters) {\n        if (cluster.score < clusterConfig.minimumScore) continue;\n\n        // Create the meta-entity partial\n        const metaEntityPartial = await createMetaEntity(cluster.entities, config.metaEntity, graphView);\n\n        // Enter narration context BEFORE creating the entity (narration added after we have the name)\n        const tracker = graphView.mutationTracker;\n        const contextId = `${config.id}:${metaEntitiesCreated.length}`;\n        if (config.narrationTemplate && tracker) {\n          tracker.enterContext('system', contextId);\n        }\n\n        // Now create the entity (will be recorded under the narration context)\n        const metaEntityId = await graphView.addEntity(metaEntityPartial);\n        const metaEntity = graphView.getEntity(metaEntityId)!;\n        metaEntitiesCreated.push(metaEntityId);\n\n        // Generate narration now that we have the full entity with name\n        // and SET IT ON THE CURRENT CONTEXT so the event builder finds it\n        let generatedNarration: string | undefined;\n        if (config.narrationTemplate && tracker) {\n          const entityNames = cluster.entities.map(e => e.name).join(', ');\n          const templateWithReplacements = config.narrationTemplate\n            .replace('{count}', String(cluster.entities.length))\n            .replace('{names}', entityNames);\n          const narrationCtx = createSystemRuleContext({ self: metaEntity });\n          const narrationResult = interpolate(templateWithReplacements, narrationCtx);\n          if (narrationResult.complete) {\n            generatedNarration = narrationResult.text;\n            narrationsByGroup[metaEntityId] = generatedNarration;\n            // Update the context's narration directly\n            const currentContext = tracker.getCurrentContext();\n            if (currentContext) {\n              currentContext.narration = generatedNarration;\n            }\n          }\n        }\n\n        // Get cluster entity IDs\n        const clusterIds = cluster.entities.map(e => e.id);\n\n        // Handle practitioner relationships based on masterSelection config\n        if (config.masterSelection) {\n          // Collect all practitioners of cluster members\n          const allPractitioners: HardState[] = [];\n          const seenIds = new Set<string>();\n          for (const memberId of clusterIds) {\n            const practitioners = graphView.getConnectedEntities(memberId, 'practitioner_of', 'dst');\n            for (const p of practitioners) {\n              if (!seenIds.has(p.id)) {\n                seenIds.add(p.id);\n                allPractitioners.push(p);\n              }\n            }\n          }\n\n          // Select masters using the simplified selection logic\n          const masters = selectMasters(allPractitioners, metaEntity, config.masterSelection);\n\n          // Create practitioner_of relationships only for masters\n          for (const master of masters) {\n            graphView.createRelationship('practitioner_of', master.id, metaEntityId);\n            relationshipsAdded.push({\n              kind: 'practitioner_of',\n              src: master.id,\n              dst: metaEntityId,\n              strength: 1.0,\n              narrativeGroupId: metaEntityId\n            });\n            // Archive the old practitioner_of relationships for this master\n            for (const memberId of clusterIds) {\n              graphView.archiveRelationship(master.id, memberId, 'practitioner_of');\n            }\n          }\n\n          // Find origin location from absorbed abilities' manifests_at relationships\n          const locationCounts = new Map<string, number>();\n          for (const memberId of clusterIds) {\n            const locations = graphView.getConnectedEntities(memberId, 'manifests_at', 'src');\n            for (const loc of locations) {\n              locationCounts.set(loc.id, (locationCounts.get(loc.id) || 0) + 1);\n            }\n          }\n\n          // Create originated_in link to most common location\n          if (locationCounts.size > 0) {\n            const originLocationId = getMajority(locationCounts, '');\n            if (originLocationId) {\n              graphView.createRelationship('originated_in', metaEntityId, originLocationId);\n              relationshipsAdded.push({\n                kind: 'originated_in',\n                src: metaEntityId,\n                dst: originLocationId,\n                strength: 1.0,\n                narrativeGroupId: metaEntityId\n              });\n            }\n          }\n\n          graphView.log('info', `${config.name}: selected ${masters.length} masters from ${allPractitioners.length} practitioners`);\n        } else {\n          // Original behavior: transfer all relationships\n          graphView.transferRelationships(\n            clusterIds,\n            metaEntityId,\n            {\n              excludeKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n              archiveOriginals: true\n            }\n          );\n        }\n\n        // Create subsumes relationships (meta-entity subsumes member)\n        // This makes it explicit that the meta-entity absorbs the cluster members\n        clusterIds.forEach((id, index) => {\n          graphView.createRelationship('subsumes', metaEntityId, id);\n          relationshipsAdded.push({\n            kind: 'subsumes',\n            src: metaEntityId,\n            dst: id,\n            strength: 1.0,\n            // Link first relationship to narration for this cluster\n            narrativeGroupId: index === 0 ? metaEntityId : undefined\n          });\n        });\n\n        // Post-process: create emergent region if configured\n        if (config.postProcess?.createEmergentRegion && metaEntityPartial.coordinates) {\n          const regionLabel = (config.postProcess.emergentRegionLabel || '{name} Region')\n            .replace('{name}', metaEntity.name);\n          const regionDescription = (config.postProcess.emergentRegionDescription || 'A semantic cluster formed around {name}')\n            .replace('{name}', metaEntity.name);\n\n          const regionResult = graphView.createEmergentRegion(\n            config.metaEntity.kind,\n            metaEntityPartial.coordinates,\n            regionLabel,\n            regionDescription,\n            metaEntity.culture,\n            metaEntityId\n          );\n\n          if (regionResult.success && regionResult.region) {\n            graphView.log('info', `Created emergent region \"${regionResult.region.label}\" for meta-entity \"${metaEntity.name}\"`);\n          }\n        }\n\n        // Post-process: create governance faction if configured\n        if (config.postProcess?.createGovernanceFaction) {\n          const { factionId, relationships } = await createGovernanceFaction(\n            graphView,\n            metaEntityId,\n            metaEntity,\n            config.postProcess\n          );\n\n          relationshipsAdded.push(...relationships);\n          if (factionId) {\n            factionsCreated.push(factionId);\n          }\n        }\n\n        // Apply member updates or fall back to archiving\n        if (config.memberUpdates && config.memberUpdates.length > 0) {\n          // Find the status mutation if present\n          const statusMutation = config.memberUpdates.find(\n            m => m.type === 'change_status'\n          ) as { type: 'change_status'; newStatus: string } | undefined;\n\n          const newStatus = statusMutation?.newStatus ?? FRAMEWORK_STATUS.SUBSUMED;\n\n          // Apply status change to each cluster member\n          for (const memberId of clusterIds) {\n            graphView.updateEntityStatus(memberId, newStatus);\n\n            entitiesModified.push({\n              id: memberId,\n              changes: { status: newStatus }\n            });\n          }\n        } else {\n          // Original behavior: archive as historical\n          graphView.archiveEntities(\n            clusterIds,\n            {\n              archiveRelationships: false,\n              excludeRelationshipKinds: [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF]\n            }\n          );\n\n          // Track modifications\n          clusterIds.forEach(id => {\n            entitiesModified.push({\n              id,\n              changes: { status: 'historical' }\n            });\n          });\n        }\n\n        // Exit narration context if we entered one\n        if (config.narrationTemplate && tracker) {\n          tracker.exitContext();\n        }\n      }\n\n      // Pressure changes\n      const pressureChanges = metaEntitiesCreated.length > 0\n        ? (config.postProcess?.pressureChanges ?? { stability: 2 })\n        : {};\n\n      return {\n        relationshipsAdded,\n        entitiesModified,\n        pressureChanges,\n        description: `${config.name}: ${metaEntitiesCreated.length} meta-entities formed` +\n          (factionsCreated.length > 0 ? `, ${factionsCreated.length} factions` : ''),\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\n      };\n    }\n  };\n}", "parameters": [{"name": "config", "type": "ClusterFormationConfig", "optional": false}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createTagDiffusionSystem", "name": "createTagDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a TagDiffusionConfig\r\n */\r\nexport function createTagDiffusionSystem(\r\n  config: TagDiffusionConfig\r\n): SimulationSystem {\r\n  const direction = config.connectionDirection ?? 'both';\r\n  const maxTags = config.maxTags ?? 10;\r\n\r\n  return {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    apply: (graphView: WorldRuntime, modifier: number = 1.0): SystemResult => {\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        if (!rollProbability(config.throttleChance, modifier)) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const modifiedTags = new Map<string, Record<string, boolean | string>>();\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const entityNarrations = new Map<string, { tag: string; type: 'convergence' | 'divergence' }>();\r\n\r\n      // Find entities to evaluate\r\n      const selectionCtx = createSystemContext(graphView);\r\n      const entities = selectEntities(config.selection, selectionCtx);\r\n\r\n      if (entities.length < 2) {\r\n        return {\r\n          relationshipsAdded: [],\r\n          entitiesModified: [],\r\n          pressureChanges: {},\r\n          description: `${config.name}: not enough entities`\r\n        };\r\n      }\r\n\r\n      // Track divergent entities for pressure calculation\r\n      let divergentCount = 0;\r\n\r\n      // === CONVERGENCE: Connected entities gain shared tags ===\r\n      if (config.convergence) {\r\n        const conv = config.convergence;\r\n        const maxShared = conv.maxSharedTags ?? 2;\r\n\r\n        // Compare pairs of entities\r\n        for (let i = 0; i < entities.length; i++) {\r\n          const entity = entities[i];\r\n          const connected = getConnectedEntities(entity, config.connectionKind, direction, graphView);\r\n\r\n          // Filter to only entities in our evaluation set\r\n          const connectedInSet = connected.filter(c =>\r\n            entities.some(e => e.id === c.id)\r\n          );\r\n\r\n          if (connectedInSet.length >= conv.minConnections) {\r\n            // Check shared tags with connected entities\r\n            for (const other of connectedInSet) {\r\n              const sharedCount = countSharedTags(entity, other, conv.tags);\r\n\r\n              if (sharedCount < maxShared) {\r\n                // Roll for convergence\r\n                if (rollProbability(conv.probability, modifier)) {\r\n                  // Pick a tag that neither has\r\n                  const candidateTags = conv.tags.filter(t =>\r\n                    !hasTag(entity.tags, t) && !hasTag(other.tags, t)\r\n                  );\r\n\r\n                  if (candidateTags.length > 0) {\r\n                    const newTag = pickRandom(candidateTags);\r\n                    const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                    if (Object.keys(currentTags).length < maxTags) {\r\n                      currentTags[newTag] = true;\r\n                      modifiedTags.set(entity.id, currentTags);\r\n                      // Track for narration\r\n                      if (!entityNarrations.has(entity.id)) {\r\n                        entityNarrations.set(entity.id, { tag: newTag, type: 'convergence' });\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // === DIVERGENCE: Isolated entities gain unique tags ===\r\n      if (config.divergence) {\r\n        const div = config.divergence;\r\n\r\n        for (const entity of entities) {\r\n          const connectionCount = countConnections(entity, config.connectionKind, direction, graphView);\r\n\r\n          if (connectionCount <= div.maxConnections) {\r\n            // This entity is isolated\r\n            if (rollProbability(div.probability, modifier)) {\r\n              // Pick a divergence tag the entity doesn't have\r\n              const candidateTags = div.tags.filter(t => !hasTag(entity.tags, t));\r\n\r\n              if (candidateTags.length > 0) {\r\n                const newTag = pickRandom(candidateTags);\r\n                const currentTags = modifiedTags.get(entity.id) || { ...entity.tags };\r\n\r\n                if (Object.keys(currentTags).length < maxTags) {\r\n                  currentTags[newTag] = true;\r\n                  modifiedTags.set(entity.id, currentTags);\r\n                  // Track for narration\r\n                  if (!entityNarrations.has(entity.id)) {\r\n                    entityNarrations.set(entity.id, { tag: newTag, type: 'divergence' });\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // Track for pressure calculation\r\n            if (div.tags.some(t => hasTag(entity.tags, t))) {\r\n              divergentCount++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Convert tag modifications to entity modifications and generate narrations\r\n      for (const [entityId, tags] of modifiedTags) {\r\n        const entity = graphView.getEntity(entityId);\r\n        const narrationInfo = entityNarrations.get(entityId);\r\n\r\n        // Generate narration if template is available\r\n        if (entity && narrationInfo) {\r\n          const template = narrationInfo.type === 'convergence'\r\n            ? config.convergence?.narrationTemplate\r\n            : config.divergence?.narrationTemplate;\r\n\r\n          if (template) {\r\n            const narrationCtx = createSystemRuleContext({ self: entity });\r\n            const narrationResult = interpolate(template, narrationCtx);\r\n            if (narrationResult.complete) {\r\n              narrationsByGroup[entityId] = narrationResult.text;\r\n            }\r\n          }\r\n        }\r\n\r\n        modifications.push({\r\n          id: entityId,\r\n          changes: { tags: tags as Record<string, boolean> },\r\n          narrativeGroupId: narrationInfo ? entityId : undefined\r\n        });\r\n      }\r\n\r\n      // Calculate pressure changes\r\n      let pressureChanges: Record<string, number> = {};\r\n\r\n      if (modifications.length > 0 && config.pressureChanges) {\r\n        pressureChanges = { ...config.pressureChanges };\r\n      }\r\n\r\n      // Apply divergence-specific pressure\r\n      if (config.divergencePressure && divergentCount >= config.divergencePressure.minDivergent) {\r\n        pressureChanges[config.divergencePressure.pressureName] =\r\n          (pressureChanges[config.divergencePressure.pressureName] ?? 0) +\r\n          config.divergencePressure.delta * modifier;\r\n      }\r\n\r\n      return {\r\n        relationshipsAdded: [],\r\n        entitiesModified: modifications,\r\n        pressureChanges,\r\n        description: `${config.name}: ${modifications.length} entities affected`,\r\n        narrationsByGroup: Object.keys(narrationsByGroup).length > 0 ? narrationsByGroup : undefined\r\n      };\r\n    }\r\n  };\r\n}", "parameters": [{"name": "config", "type": "TagDiffusionConfig", "optional": false}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createPlaneDiffusionSystem", "name": "createPlaneDiffusionSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM FACTORY\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a PlaneDiffusionConfig\r\n */\r\nexport function createPlaneDiffusionSystem(\r\n  config: PlaneDiffusionConfig\r\n): SimulationSystem<DiffusionState> {\r\n  const diffusionRate = config.diffusion.rate ?? 0.2;\r\n  const sourceRadius = config.diffusion.sourceRadius ?? 1;\r\n  const decayRate = config.diffusion.decayRate ?? 0; // Default to 0\r\n  const falloffType = config.diffusion.falloffType ?? 'absolute';\r\n  const iterationsPerTick = config.diffusion.iterationsPerTick ?? 20; // Default 20 for fast spreading\r\n\r\n  // Validate ranges\r\n  if (diffusionRate < 0 || diffusionRate > 1) {\r\n    throw new Error(`[${config.id}] Diffusion rate must be between 0 and 1, got ${diffusionRate}`);\r\n  }\r\n  if (decayRate < 0 || decayRate > 1) {\r\n    throw new Error(`[${config.id}] Decay rate must be between 0 and 1, got ${decayRate}`);\r\n  }\r\n  if (sourceRadius < 0 || sourceRadius > 50) {\r\n    throw new Error(`[${config.id}] Source radius must be between 0 and 50, got ${sourceRadius}`);\r\n  }\r\n  if (!config.selection?.kind) {\r\n    throw new Error(`[${config.id}] Plane diffusion requires selection.kind to define the semantic plane.`);\r\n  }\r\n\r\n  // Create the system with internal state\r\n  const system: SimulationSystem<DiffusionState> = {\r\n    id: config.id,\r\n    name: config.name,\r\n\r\n    // Internal state - will be initialized by initialize()\r\n    state: undefined,\r\n\r\n    // Initialize the grid on first use\r\n    initialize: function() {\r\n      this.state = {\r\n        grid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        tempGrid: new Float32Array(GRID_SIZE * GRID_SIZE),\r\n        initialized: true,\r\n      };\r\n    },\r\n\r\n    apply: function(graphView: WorldRuntime, _modifier: number = 1.0): SystemResult {\r\n      // Ensure state is initialized (safety check)\r\n      if (!this.state?.initialized) {\r\n        this.initialize!();\r\n      }\r\n      const state = this.state!;\r\n\r\n      // Throttle check\r\n      if (config.throttleChance !== undefined && config.throttleChance < 1.0) {\r\n        // eslint-disable-next-line sonarjs/pseudo-random -- simulation throttle check\r\n        if (Math.random() > config.throttleChance) {\r\n          return {\r\n            relationshipsAdded: [],\r\n            entitiesModified: [],\r\n            pressureChanges: {},\r\n            description: `${config.name}: dormant`,\r\n            details: {\r\n              diffusionSnapshot: {\r\n                grid: Array.from(state.grid),\r\n                gridSize: GRID_SIZE,\r\n                sources: [],\r\n                sinks: [],\r\n                entities: [],\r\n              },\r\n            },\r\n          };\r\n        }\r\n      }\r\n\r\n      const modifications: Array<{ id: string; changes: Partial<HardState>; narrativeGroupId?: string }> = [];\r\n      const narrationsByGroup: Record<string, string> = {};\r\n      const metricCtx = createSystemContext(graphView);\r\n\r\n      const getFalloff = (distance: number, strength: number): number => {\r\n        const maxDistance = falloffType === 'absolute' ? strength : sourceRadius + 1;\r\n        if (maxDistance <= 0) return 0;\r\n        const metric: Metric = {\r\n          type: 'falloff',\r\n          falloffType,\r\n          distance,\r\n          maxDistance,\r\n        };\r\n        return evaluateMetric(metric, metricCtx).value;\r\n      };\r\n\r\n      // Find all entities on the target plane\r\n      const entities = selectEntities(config.selection, metricCtx);\r\n\r\n      // Filter to entities with valid coordinates\r\n      const entitiesWithCoords = entities.filter(hasCoordinates);\r\n\r\n      // Identify sources and sinks\r\n      const sources = entitiesWithCoords.filter(e => hasTag(e.tags, config.sources.tagFilter));\r\n      const sinks = config.sinks\r\n        ? entitiesWithCoords.filter(e => hasTag(e.tags, config.sinks!.tagFilter))\r\n        : [];\r\n\r\n      // =======================================================================\r\n      // STEP 1: Build a mask of fixed boundary cells (only when decay=0)\r\n      // - decay=0: Sources SET values, need Dirichlet boundary (fixed during diffusion)\r\n      // - decay>0: Sources ADD values, no fixed boundary (diffusion happens normally)\r\n      // - Sinks never create fixed cells - they subtract and let diffusion happen\r\n      // =======================================================================\r\n      const fixedCells = new Set<number>();\r\n\r\n      // Only create fixed boundaries when decay=0 (SET mode)\r\n      if (decayRate === 0) {\r\n        for (const source of sources) {\r\n          const gx = coordToGrid(source.coordinates.x);\r\n          const gy = coordToGrid(source.coordinates.y);\r\n          for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n            for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n              const dist = Math.sqrt(dx * dx + dy * dy);\r\n              if (dist <= sourceRadius) {\r\n                const nx = gx + dx;\r\n                const ny = gy + dy;\r\n                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {\r\n                  fixedCells.add(ny * GRID_SIZE + nx);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2a: Sources SET (decay=0) or ADD (decay>0) their values\r\n      // - decay=0: Dirichlet boundary - stable fixed values\r\n      // - decay>0: Injection model - add per tick, decay prevents unbounded growth\r\n      // =======================================================================\r\n      const sourceMode = decayRate > 0 ? 'add' : 'set';\r\n\r\n      for (const source of sources) {\r\n        const gx = coordToGrid(source.coordinates.x);\r\n        const gy = coordToGrid(source.coordinates.y);\r\n        // Note: source strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(source, config.sources.strengthTag, config.sources.defaultStrength);\r\n\r\n        // Set/Add values within source radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const injectionValue = strength * falloff;\r\n\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              if (sourceMode === 'add') {\r\n                // ADD mode: inject on top of existing value\r\n                const currentValue = getGridValue(state.grid, nx, ny);\r\n                setGridValue(state.grid, nx, ny, currentValue + injectionValue);\r\n              } else {\r\n                // SET mode: fixed boundary value\r\n                setGridValue(state.grid, nx, ny, injectionValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 2b: Sinks SUBTRACT from existing values (not SET)\r\n      // This allows sinks in source regions to reduce the field, not overwrite it\r\n      // =======================================================================\r\n      for (const sink of sinks) {\r\n        const gx = coordToGrid(sink.coordinates.x);\r\n        const gy = coordToGrid(sink.coordinates.y);\r\n        // Note: sink strength is NOT scaled by era modifier - it's a domain constant\r\n        const strength = getStrength(sink, config.sinks!.strengthTag, config.sinks!.defaultStrength);\r\n\r\n        // Subtract values within sink radius\r\n        for (let dy = -sourceRadius; dy <= sourceRadius; dy++) {\r\n          for (let dx = -sourceRadius; dx <= sourceRadius; dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= sourceRadius) {\r\n              const falloff = getFalloff(dist, strength);\r\n              const subtractAmount = strength * falloff;\r\n              const nx = gx + dx;\r\n              const ny = gy + dy;\r\n              const currentValue = getGridValue(state.grid, nx, ny);\r\n              setGridValue(state.grid, nx, ny, currentValue - subtractAmount);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3: Apply diffusion (heat equation)\r\n      // Skip source cells (Dirichlet source), edges diffuse normally (Neumann-like)\r\n      // Out-of-bounds neighbors return 0, so edges naturally trend toward 0\r\n      // =======================================================================\r\n      for (let iter = 0; iter < iterationsPerTick; iter++) {\r\n        state.tempGrid.set(state.grid);\r\n\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n\r\n            // Skip source cells - they maintain their set values\r\n            if (fixedCells.has(idx)) {\r\n              continue;\r\n            }\r\n\r\n            const current = getGridValue(state.tempGrid, x, y);\r\n\r\n            // Get 4-connected neighbors (out-of-bounds returns 0)\r\n            const north = getGridValue(state.tempGrid, x, y - 1);\r\n            const south = getGridValue(state.tempGrid, x, y + 1);\r\n            const east = getGridValue(state.tempGrid, x + 1, y);\r\n            const west = getGridValue(state.tempGrid, x - 1, y);\r\n\r\n            // Average of neighbors\r\n            const neighborAvg = (north + south + east + west) / 4;\r\n\r\n            // Diffusion: move toward neighbor average\r\n            const diffused = current + diffusionRate * (neighborAvg - current);\r\n\r\n            setGridValue(state.grid, x, y, diffused);\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 3b: Apply decay ONCE per tick (not per iteration)\r\n      // =======================================================================\r\n      if (decayRate > 0) {\r\n        for (let y = 0; y < GRID_SIZE; y++) {\r\n          for (let x = 0; x < GRID_SIZE; x++) {\r\n            const idx = y * GRID_SIZE + x;\r\n            // Don't decay fixed boundary cells\r\n            if (!fixedCells.has(idx)) {\r\n              const current = getGridValue(state.grid, x, y);\r\n              setGridValue(state.grid, x, y, current * (1 - decayRate));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // =======================================================================\r\n      // STEP 4: Sample grid at entity positions and set tags (CLAMPED OUTPUT)\r\n      // Track significant modifications (new output tags) separately from\r\n      // value tag updates to avoid false positives in the trace.\r\n      // =======================================================================\r\n      let significantModificationCount = 0;\r\n\r\n      for (const entity of entitiesWithCoords) {\r\n        const rawFieldValue = sampleGrid(state.grid, entity.coordinates.x, entity.coordinates.y);\r\n        // Clamp to output range for game space\r\n        const fieldValue = clampToOutput(rawFieldValue);\r\n\r\n        const newTags: Record<string, boolean | string> = { ...entity.tags };\r\n        let tagsChanged = false;\r\n\r\n        // Track which output tags the entity currently has\r\n        const previousOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            previousOutputTags.add(outputTag.tag);\r\n          }\r\n        }\r\n\r\n        // Remove old output tags and value tag\r\n        for (const outputTag of config.outputTags) {\r\n          if (hasTag(entity.tags, outputTag.tag)) {\r\n            delete newTags[outputTag.tag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n        if (config.valueTag) {\r\n          if (config.valueTag in newTags) {\r\n            delete newTags[config.valueTag];\r\n            tagsChanged = true;\r\n          }\r\n        }\r\n\r\n        // Add appropriate output tag based on thresholds (using clamped value)\r\n        // Track if any NEW output tag was added (not previously present)\r\n        let newOutputTagAdded = false;\r\n        let gainedOutputTag: DiffusionOutputTag | undefined;\r\n        const newOutputTags = new Set<string>();\r\n        for (const outputTag of config.outputTags) {\r\n          const minOk = outputTag.minValue === undefined || fieldValue >= outputTag.minValue;\r\n          const maxOk = outputTag.maxValue === undefined || fieldValue < outputTag.maxValue;\r\n\r\n          if (minOk && maxOk) {\r\n            newTags[outputTag.tag] = true;\r\n            newOutputTags.add(outputTag.tag);\r\n            tagsChanged = true;\r\n            // This is a significant change if entity didn't have this tag before\r\n            if (!previousOutputTags.has(outputTag.tag)) {\r\n              newOutputTagAdded = true;\r\n              gainedOutputTag = outputTag;\r\n// ... (truncated)", "parameters": [{"name": "config", "type": "PlaneDiffusionConfig", "optional": false}], "returnType": "SimulationSystem<DiffusionState>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createGrowthSystem", "name": "createGrowthSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "export function createGrowthSystem(\n  config: GrowthSystemConfig,\n  deps: GrowthSystemDependencies\n): GrowthSystem {\n  const state: GrowthState = {\n    epoch: -1,\n    epochTarget: 0,\n    entitiesCreated: 0,\n    templatesApplied: 0,\n    templatesUsed: new Set(),\n    yieldSamples: [],\n    phaseCompleted: false\n  };\n\n  const maxTemplatesPerTick = config.maxTemplatesPerTick ?? 5;\n  const minTemplatesPerTick = config.minTemplatesPerTick ?? 1;\n  const yieldWindow = config.yieldAveragingWindow ?? 30;\n  const maxAttemptsPerTick = config.maxAttemptsPerTick ?? 40;\n\n  function getExpectedYield(): number {\n    if (state.yieldSamples.length === 0) return 1;\n    const avg = state.yieldSamples.reduce((sum, val) => sum + val, 0) / state.yieldSamples.length;\n    // Avoid runaway budgets from unlucky zeros\n    return Math.max(1, avg);\n  }\n\n  function recordPhaseCompletion(graphView: WorldRuntime, reason: GrowthPhaseCompletion['reason']): void {\n    if (state.phaseCompleted) return;\n    if (state.epochTarget <= 0) return;\n    const eraId = state.epochEra?.id ?? deps.getEpochEra().id;\n    if (!eraId) return;\n\n    state.phaseCompleted = true;\n    graphView.growthPhaseHistory.push({\n      epoch: state.epoch,\n      eraId,\n      tick: graphView.tick,\n      reason\n    });\n  }\n\n  async function applyTemplateOnce(\n    template: GrowthTemplate,\n    graphView: WorldRuntime,\n    _era: Era\n  ): Promise<number> {\n    try {\n      // Check applicability\n      if (!template.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n          if (!diag.applicabilityPassed) {\n            graphView.debug('templates', `${template.id} rejected: ${diag.failedRules.join('; ')}`);\n          } else if (diag.selectionCount === 0) {\n            graphView.debug('templates', `${template.id} selection(${diag.selectionStrategy}) returned 0 targets`);\n          }\n        }\n        return 0;\n      }\n\n      const templateTargets = template.findTargets(graphView);\n      if (templateTargets.length === 0) {\n        graphView.debug('selection', `${template.id} found no targets via findTargets()`);\n        return 0;\n      }\n\n      const target = pickRandom(templateTargets);\n\n      const pressureModsBefore = deps.getPendingPressureModifications().length;\n      graphView.setPressureModificationCallback((pressureId, delta, source) => {\n        deps.trackPressureModification(pressureId, delta, source);\n      });\n      graphView.setCurrentSource({ type: 'template', templateId: template.id });\n\n      // LINEAGE: Enter template context for entity/relationship stamping.\n      // All entities and relationships created will have\n      // createdBy = { tick, source: 'template', sourceId: template.id }.\n      // See LINEAGE.md for design details.\n      // NOTE: Context must stay open until AFTER addEntity/createRelationship calls below.\n      deps.mutationTracker?.enterContext('template', template.id);\n\n      let result: import('../engine/types').TemplateResult;\n      try {\n        result = await template.expand(graphView, target);\n      } catch (error) {\n        // LINEAGE: Exit context on expand error\n        deps.mutationTracker?.exitContext();\n        throw error;\n      }\n      graphView.clearCurrentSource();\n\n      // Contract enforcement warnings\n      const allTagsSet = new Set<string>();\n      for (const entity of result.entities) {\n        Object.keys(entity.tags || {}).forEach(tag => allTagsSet.add(tag));\n      }\n      const allTagsToAdd = Array.from(allTagsSet);\n      const tagSaturationCheck = deps.contractEnforcer.checkTagSaturation(graphView, allTagsToAdd);\n      if (tagSaturationCheck.saturated) {\n        deps.emitter.log('warn', `Template ${template.id} would oversaturate tags: ${tagSaturationCheck.oversaturatedTags.join(', ')}`);\n      }\n      const orphanCheck = deps.contractEnforcer.checkTagOrphans(allTagsToAdd);\n      if (orphanCheck.hasOrphans && orphanCheck.orphanTags.length >= 3) {\n        deps.emitter.log('debug', `Template ${template.id} creates unregistered tags: ${orphanCheck.orphanTags.slice(0, 5).join(', ')}`);\n      }\n\n      deps.statisticsCollector.recordTemplateApplication(template.id);\n\n      const createdEntities: HardState[] = [];\n      const newIds: string[] = [];\n\n      for (let i = 0; i < result.entities.length; i++) {\n        const entity = result.entities[i];\n        const placementStrategy = result.placementStrategies?.[i] || 'unknown';\n        const id = await graphView.addEntity(entity, `template:${template.id}`, placementStrategy);\n        newIds.push(id);\n        const ref = graphView.getEntity(id);\n        if (ref) {\n          createdEntities.push(ref);\n        }\n      }\n\n      for (const entity of createdEntities) {\n        initializeCatalystSmart(entity);\n      }\n\n      result.relationships.forEach(rel => {\n        const srcId = rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src;\n        const dstId = rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst;\n\n        if (srcId && dstId) {\n          graphView.createRelationship(rel.kind, srcId, dstId, rel.strength);\n        }\n      });\n\n      // LINEAGE: Exit template context now that entities/relationships are created.\n      // They are now stamped with createdBy = { source: 'template', sourceId: template.id }.\n      deps.mutationTracker?.exitContext();\n\n      for (const entity of createdEntities) {\n        const coverageCheck = deps.contractEnforcer.enforceTagCoverage(entity, graphView);\n        if (coverageCheck.needsAdjustment) {\n          deps.emitter.log('debug', coverageCheck.suggestion || '', { entity: entity.id });\n        }\n        const taxonomyCheck = deps.contractEnforcer.validateTagTaxonomy(entity);\n        if (!taxonomyCheck.valid) {\n          deps.emitter.log('warn', `Entity ${entity.name} has conflicting tags`, { conflicts: taxonomyCheck.conflicts });\n        }\n      }\n\n      // Record creation batch for narrative event generation\n      if (newIds.length > 0) {\n        // Summarize relationships by kind\n        const relationshipCounts = new Map<string, number>();\n        for (const rel of result.relationships) {\n          relationshipCounts.set(rel.kind, (relationshipCounts.get(rel.kind) || 0) + 1);\n        }\n        const relationshipSummary: RelationshipSummary[] = [];\n        for (const [kind, count] of relationshipCounts) {\n          relationshipSummary.push({ kind, count });\n        }\n\n        // Use description from first creation item if available\n        const declTemplate = deps.declarativeTemplates.get(template.id);\n        const rawDescription = declTemplate?.creation?.[0]?.description;\n        // DescriptionSpec can be string or { template, replacements } - extract string if possible\n        const primaryDescription = typeof rawDescription === 'string' ? rawDescription : undefined;\n\n        // Generate narration ONCE here, now that entities have names\n        // result.resolvedVariables contains $target, $enemy, etc. from template expansion\n        let narration: string | undefined;\n        if (declTemplate?.narrationTemplate) {\n          // Start with the resolved variables from template expansion (like $target, $enemy)\n          const variables: Record<string, HardState | HardState[] | undefined> = {\n            ...(result.resolvedVariables || {}),\n          };\n\n          // Add created entities by their entityRef (like $war, $ideology)\n          // Use entityRefToIndex mapping since createChance can skip entities\n          if (result.entityRefToIndex) {\n            for (const [entityRef, idx] of Object.entries(result.entityRefToIndex)) {\n              const index = idx;\n              if (createdEntities[index]) {\n                // Ensure $ prefix for the key\n                const key = entityRef.startsWith('$') ? entityRef : `$${entityRef}`;\n                variables[key] = createdEntities[index];\n              }\n            }\n          }\n\n          const narrationCtx = createGeneratorContext({\n            target,\n            variables,\n          });\n          const narrationResult = interpolate(declTemplate.narrationTemplate, narrationCtx);\n          // Use narration even if not complete - partial narration better than mechanical\n          narration = narrationResult.text;\n          if (!narrationResult.complete) {\n            // Debug: log unresolved tokens (use debug level since partial is expected sometimes)\n            console.debug(`[GrowthSystem] Template ${template.id} narration partial:`, {\n              unresolvedTokens: narrationResult.unresolvedTokens,\n              variableKeys: Object.keys(variables),\n            });\n          }\n        }\n\n        deps.stateChangeTracker.recordCreationBatch(\n          template.id,\n          template.name || template.id,\n          newIds,\n          relationshipSummary,\n          primaryDescription || result.description,\n          narration\n        );\n      }\n\n      const templatePressureMods = deps.getPendingPressureModifications().slice(pressureModsBefore);\n      const pressureChanges: Record<string, number> = {};\n      for (const mod of templatePressureMods) {\n        pressureChanges[mod.pressureId] = (pressureChanges[mod.pressureId] || 0) + mod.delta;\n      }\n\n      const resolvedRelationships = result.relationships.map(rel => ({\n        kind: rel.kind,\n        srcId: rel.src.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.src.split('-')[3])]\n          : rel.src,\n        dstId: rel.dst.startsWith('will-be-assigned-')\n          ? newIds[parseInt(rel.dst.split('-')[3])]\n          : rel.dst,\n        strength: rel.strength\n      }));\n\n      deps.emitter.templateApplication({\n        tick: graphView.tick,\n        epoch: deps.getCurrentEpoch(),\n        templateId: template.id,\n        targetEntityId: target.id,\n        targetEntityName: target.name,\n        targetEntityKind: target.kind,\n        description: result.description,\n        entitiesCreated: createdEntities.map((e, i) => {\n          const placementDebug = result.placementDebugList?.[i];\n          const strategy = result.placementStrategies?.[i] || 'unknown';\n          return {\n            id: e.id,\n            name: e.name,\n            kind: e.kind,\n            subtype: e.subtype,\n            culture: e.culture,\n            prominence: prominenceLabel(e.prominence),\n            tags: e.tags,\n            placementStrategy: strategy,\n            coordinates: e.coordinates,\n            regionId: placementDebug?.regionId ?? e.regionId,\n            allRegionIds: placementDebug?.allRegionIds ?? e.allRegionIds,\n            derivedTags: result.derivedTagsList?.[i],\n            placement: placementDebug ? {\n              anchorType: placementDebug.anchorType,\n              anchorEntity: placementDebug.anchorEntity,\n              anchorCulture: placementDebug.anchorCulture,\n              resolvedVia: placementDebug.resolvedVia,\n              seedRegionsAvailable: placementDebug.seedRegionsAvailable,\n              emergentRegionCreated: placementDebug.emergentRegionCreated\n            } : undefined\n          };\n        }),\n        relationshipsCreated: resolvedRelationships,\n        pressureChanges\n      });\n\n      return result.entities.length;\n    } catch (error) {\n      graphView.clearCurrentSource();\n      const message = error instanceof Error ? error.message : String(error);\n      const templateLabel = template.name ? `${template.name} (${template.id})` : template.id;\n      throw new Error(`Template ${templateLabel} failed: ${message}`);\n    }\n  }\n\n  function buildApplicableTemplates(\n    graphView: WorldRuntime,\n    rejectionReasons: Map<string, string>\n  ): GrowthTemplate[] {\n    return deps.runtimeTemplates.filter(t => {\n      const runCount = deps.templateRunCounts.get(t.id) || 0;\n      if (runCount >= deps.maxRunsPerTemplate) {\n        rejectionReasons.set(t.id, `run_cap: ${runCount}/${deps.maxRunsPerTemplate}`);\n        return false;\n      }\n\n      if (!t.canApply(graphView)) {\n        const declTemplate = deps.declarativeTemplates.get(t.id);\n        if (declTemplate) {\n          const diag = deps.templateInterpreter.diagnoseCanApply(declTemplate, graphView);\n// ... (truncated)", "parameters": [{"name": "config", "type": "GrowthSystemConfig", "optional": false}, {"name": "deps", "type": "GrowthSystemDependencies", "optional": false}], "returnType": "GrowthSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::loadActions", "name": "loadActions", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load declarative actions and convert them to executable actions.\n */\nexport function loadActions(actions: DeclarativeAction[]): ExecutableAction[] {\n  if (!Array.isArray(actions)) {\n    console.warn('loadActions: expected array, got', typeof actions);\n    return [];\n  }\n\n  const executableActions: ExecutableAction[] = [];\n\n  for (const action of actions) {\n    if (!action || !action.id) {\n      console.warn('loadActions: skipping invalid action', action);\n      continue;\n    }\n\n    // Skip disabled actions (default to enabled if not specified)\n    if (action.enabled === false) {\n      continue;\n    }\n\n    try {\n      const executable = createExecutableAction(action);\n      executableActions.push(executable);\n    } catch (error) {\n      console.error(`Failed to create action ${action.id}:`, error);\n    }\n  }\n\n  return executableActions;\n}", "parameters": [{"name": "actions", "type": "DeclarativeAction[]", "optional": false}], "returnType": "ExecutableAction[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createExecutableAction", "name": "createExecutableAction", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// ACTION FACTORY\n// =============================================================================\n\n/**\n * Convert a declarative action to an executable action.\n */\nexport function createExecutableAction(action: DeclarativeAction): ExecutableAction {\n  return {\n    type: action.id,\n    name: action.name,\n    description: action.description,\n    baseSuccessChance: action.probability.baseSuccessChance,\n    baseWeight: action.probability.baseWeight,\n    pressureModifiers: action.probability.pressureModifiers || [],\n    actorConfig: action.actor,\n    actorProminenceDelta: {\n      onSuccess: action.outcome.actorProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.actorProminenceDelta?.onFailure ?? 0,\n    },\n    targetProminenceDelta: {\n      onSuccess: action.outcome.targetProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.targetProminenceDelta?.onFailure ?? 0,\n    },\n    handler: createActionHandler(action)\n  };\n}", "parameters": [{"name": "action", "type": "DeclarativeAction", "optional": false}], "returnType": "ExecutableAction", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::matchesActorConfig", "name": "matchesActorConfig", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Check if an entity matches the actor configuration for an action.\n */\nexport function matchesActorConfig(\n  entity: HardState,\n  actorConfig: ActionActorConfig,\n  graphView: WorldRuntime\n): boolean {\n  const bindings: Record<string, HardState | undefined> = { actor: entity };\n  const ctx = createActionContext(graphView, bindings, entity);\n\n  // Eligibility: actor must appear in selection results (no random picking).\n  const selectionRule = {\n    ...actorConfig.selection,\n    pickStrategy: 'all' as const,\n    maxResults: undefined,\n  };\n\n  const candidates = selectEntities(selectionRule, ctx);\n  if (!candidates.some((candidate) => candidate.id === entity.id)) {\n    return false;\n  }\n\n  // Resolve optional instigator\n  if (actorConfig.instigator) {\n    const instigator = resolveSingleEntity(actorConfig.instigator, ctx);\n    if (!instigator && actorConfig.instigator.required) {\n      return false;\n    }\n    bindings.instigator = instigator;\n  }\n\n  // Evaluate conditions\n  if (actorConfig.conditions && actorConfig.conditions.length > 0) {\n    for (const condition of actorConfig.conditions) {\n      const result = evaluateCondition(condition, ctx, entity);\n      if (!result.passed) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "actorConfig", "type": "ActionActorConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createCoordinateContext", "name": "createCoordinateContext", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// FACTORY FUNCTION\n// =============================================================================\n\n/**\n * Create a CoordinateContext from configuration.\n */\nexport function createCoordinateContext(\n  config: CoordinateContextConfig\n): CoordinateContext {\n  return new CoordinateContext(config);\n}", "parameters": [{"name": "config", "type": "CoordinateContextConfig", "optional": false}], "returnType": "CoordinateContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createTemplateFromDeclarative", "name": "createTemplateFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Creates a GrowthTemplate from a DeclarativeTemplate.\r\n * This allows declarative templates to be used with the existing WorldEngine.\r\n */\r\nexport function createTemplateFromDeclarative(\r\n  template: DeclarativeTemplate,\r\n  interpreter: TemplateInterpreter\r\n): GrowthTemplate {\r\n  return {\r\n    id: template.id,\r\n    name: template.name,\r\n\r\n    canApply: (graphView: WorldRuntime) => {\r\n      return interpreter.canApply(template, graphView);\r\n    },\r\n\r\n    findTargets: (graphView: WorldRuntime) => {\r\n      return interpreter.findTargets(template, graphView);\r\n    },\r\n\r\n    expand: async (graphView: WorldRuntime, target?: HardState) => {\r\n      return interpreter.expand(template, graphView, target);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "template", "type": "DeclarativeTemplate", "optional": false}, {"name": "interpreter", "type": "TemplateInterpreter", "optional": false}], "returnType": "GrowthTemplate", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createPressureFromDeclarative", "name": "createPressureFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\n// PRESSURE INTERPRETER\n// =============================================================================\n\n/**\n * Convert a declarative pressure to a runtime Pressure object\n */\nexport function createPressureFromDeclarative(definition: DeclarativePressure): Pressure {\n  return {\n    id: definition.id,\n    name: definition.name,\n    value: definition.initialValue,\n    homeostasis: definition.homeostasis,\n    contract: definition.contract,\n\n    growth: (graph: Graph): number => {\n      const config = definition.growth;\n      const metricCtx = createMetricContext(graph);\n\n      let total = 0;\n\n      // Add positive feedback\n      for (const factor of config.positiveFeedback) {\n        total += evaluateFactor(factor, metricCtx);\n      }\n\n      // Subtract negative feedback\n      for (const factor of config.negativeFeedback) {\n        total -= evaluateFactor(factor, metricCtx);\n      }\n\n      return total;\n    }\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::loadPressures", "name": "loadPressures", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load all pressures from a PressuresFile\n */\nexport function loadPressures(file: PressuresFile): Pressure[] {\n  return file.pressures.map(createPressureFromDeclarative);\n}", "parameters": [{"name": "file", "type": "PressuresFile", "optional": false}], "returnType": "Pressure[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::loadPressure", "name": "loadPressure", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\n * Load a single pressure from a declarative definition\n */\nexport function loadPressure(definition: DeclarativePressure): Pressure {\n  return createPressureFromDeclarative(definition);\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::createSystemFromDeclarative", "name": "createSystemFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM CREATION\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a declarative configuration.\r\n *\r\n * @param declarative - The declarative system configuration\r\n * @returns A SimulationSystem that can be used by WorldEngine\r\n */\r\nexport function createSystemFromDeclarative(\r\n  declarative: DeclarativeSystem,\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem {\r\n  switch (declarative.systemType) {\r\n    case 'connectionEvolution':\r\n      return createConnectionEvolutionSystem(declarative.config);\r\n\r\n    case 'graphContagion':\r\n      return createGraphContagionSystem(declarative.config);\r\n\r\n    case 'thresholdTrigger':\r\n      return createThresholdTriggerSystem(declarative.config);\r\n\r\n    case 'clusterFormation':\r\n      return createClusterFormationSystem(declarative.config);\r\n\r\n    case 'tagDiffusion':\r\n      return createTagDiffusionSystem(declarative.config);\r\n\r\n    case 'planeDiffusion':\r\n      return createPlaneDiffusionSystem(declarative.config);\r\n\r\n    // Framework systems - create configured instances\r\n    case 'eraSpawner':\r\n      return createEraSpawnerSystem(declarative.config);\r\n\r\n    case 'eraTransition':\r\n      return createEraTransitionSystem(declarative.config);\r\n\r\n    case 'universalCatalyst':\r\n      return createUniversalCatalystSystem(declarative.config);\r\n\r\n    case 'relationshipMaintenance':\r\n      return createRelationshipMaintenanceSystem(declarative.config);\r\n\r\n    case 'growth':\r\n      if (!options?.growthDependencies) {\r\n        throw new Error('Growth system requires engine-level dependencies; pass growthDependencies to createSystemFromDeclarative');\r\n      }\r\n      return createGrowthSystem(declarative.config, options.growthDependencies);\r\n\r\n    default: {\r\n      // TypeScript should catch this, but just in case\r\n      const exhaustive: never = declarative;\r\n      throw new Error(`Unknown system type: ${(exhaustive as DeclarativeSystem).systemType}`);\r\n    }\r\n  }\r\n}", "parameters": [{"name": "declarative", "type": "DeclarativeSystem", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::loadSystems", "name": "loadSystems", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Load multiple systems from declarative configurations.\r\n * Filters out any invalid configs and logs warnings.\r\n *\r\n * @param declaratives - Array of declarative system configurations\r\n * @returns Array of SimulationSystem objects\r\n */\r\nexport function loadSystems(\r\n  declaratives: DeclarativeSystem[],\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem[] {\r\n  if (!Array.isArray(declaratives)) {\r\n    console.warn('loadSystems: expected array, got', typeof declaratives);\r\n    return [];\r\n  }\r\n\r\n  return declaratives\r\n    .filter(d => {\r\n      if (!d || typeof d !== 'object') {\r\n        console.warn('loadSystems: skipping invalid config', d);\r\n        return false;\r\n      }\r\n      if ('enabled' in d && d.enabled === false) {\r\n        return false;\r\n      }\r\n      if (!d.systemType) {\r\n        console.warn('loadSystems: skipping config without systemType', d);\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    .map(d => {\r\n      try {\r\n        return createSystemFromDeclarative(d, options);\r\n      } catch (error) {\r\n        console.error(`Failed to create system from config:`, d, error);\r\n        throw error;\r\n      }\r\n    });\r\n}", "parameters": [{"name": "declaratives", "type": "DeclarativeSystem[]", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/index.ts::isDeclarativeSystem", "name": "isDeclarativeSystem", "kind": "function", "filePath": "apps/lore-weave/lib/index.ts", "sourceCode": "/**\r\n * Check if a value is a valid declarative system configuration.\r\n */\r\nexport function isDeclarativeSystem(value: unknown): value is DeclarativeSystem {\r\n  if (!value || typeof value !== 'object') return false;\r\n  const sys = value as Record<string, unknown>;\r\n  return (\r\n    sys.systemType === 'connectionEvolution' ||\r\n    sys.systemType === 'graphContagion' ||\r\n    sys.systemType === 'thresholdTrigger' ||\r\n    sys.systemType === 'clusterFormation' ||\r\n    sys.systemType === 'tagDiffusion' ||\r\n    sys.systemType === 'planeDiffusion' ||\r\n    sys.systemType === 'eraSpawner' ||\r\n    sys.systemType === 'eraTransition' ||\r\n    sys.systemType === 'universalCatalyst' ||\r\n    sys.systemType === 'relationshipMaintenance' ||\r\n    sys.systemType === 'growth'\r\n  ) && sys.config !== undefined;\r\n}", "parameters": [{"name": "value", "type": "unknown", "optional": false}], "returnType": "value is DeclarativeSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/coordinates/coordinateContext.ts::createCoordinateContext", "name": "createCoordinateContext", "kind": "function", "filePath": "apps/lore-weave/lib/coordinates/coordinateContext.ts", "sourceCode": "// =============================================================================\n// FACTORY FUNCTION\n// =============================================================================\n\n/**\n * Create a CoordinateContext from configuration.\n */\nexport function createCoordinateContext(\n  config: CoordinateContextConfig\n): CoordinateContext {\n  return new CoordinateContext(config);\n}", "parameters": [{"name": "config", "type": "CoordinateContextConfig", "optional": false}], "returnType": "CoordinateContext", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["Point", "Region"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["EntityTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_SUBTYPES"], "category": "external"}, {"source": "@canonry/world-schema", "specifiers": ["AxisBias", "AxisDefinition", "CanonrySchemaSlice", "CultureDefinition", "EntityKindDefinition", "SemanticPlane"], "category": "external"}]}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateId", "name": "generateId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "export function generateId(prefix: string): string {\n  return `${prefix}_${idCounter++}`;\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateEventId", "name": "generateEventId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "/**\n * Generate a globally unique ID for narrative events.\n */\nexport function generateEventId(): string {\n  const cryptoObj = (globalThis as { crypto?: { randomUUID?: () => string } }).crypto;\n  if (cryptoObj?.randomUUID) {\n    return `event_${cryptoObj.randomUUID()}`;\n  }\n  return `event_${Date.now()}_${eventCounter++}`;\n}", "parameters": [], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/core/idGeneration.ts::generateLoreId", "name": "generateLoreId", "kind": "function", "filePath": "apps/lore-weave/lib/core/idGeneration.ts", "sourceCode": "/**\r\n * Generate unique ID for lore records with timestamp and counter\r\n */\r\nexport function generateLoreId(prefix: string): string {\r\n  return `${prefix}_${Date.now()}_${loreRecordCounter++}`;\r\n}", "parameters": [{"name": "prefix", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": []}, {"id": "apps/lore-weave/lib/engine/actionInterpreter.ts::createExecutableAction", "name": "createExecutableAction", "kind": "function", "filePath": "apps/lore-weave/lib/engine/actionInterpreter.ts", "sourceCode": "// =============================================================================\n// ACTION FACTORY\n// =============================================================================\n\n/**\n * Convert a declarative action to an executable action.\n */\nexport function createExecutableAction(action: DeclarativeAction): ExecutableAction {\n  return {\n    type: action.id,\n    name: action.name,\n    description: action.description,\n    baseSuccessChance: action.probability.baseSuccessChance,\n    baseWeight: action.probability.baseWeight,\n    pressureModifiers: action.probability.pressureModifiers || [],\n    actorConfig: action.actor,\n    actorProminenceDelta: {\n      onSuccess: action.outcome.actorProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.actorProminenceDelta?.onFailure ?? 0,\n    },\n    targetProminenceDelta: {\n      onSuccess: action.outcome.targetProminenceDelta?.onSuccess ?? 0,\n      onFailure: action.outcome.targetProminenceDelta?.onFailure ?? 0,\n    },\n    handler: createActionHandler(action)\n  };\n}", "parameters": [{"name": "action", "type": "DeclarativeAction", "optional": false}], "returnType": "ExecutableAction", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "../rules", "specifiers": ["Condition", "RuleContext"], "category": "internal"}, {"source": "../rules", "specifiers": ["Mutation"], "category": "internal"}, {"source": "../rules", "specifiers": ["SelectionRule", "VariableSelectionRule", "VariableDefinitionForResolution"], "category": "internal"}, {"source": "../rules", "specifiers": ["applyPickStrategy", "createActionContext", "evaluateCondition", "prepareMutation", "selectEntities", "selectVariableEntities", "resolveVariablesForEntity"], "category": "internal"}, {"source": "../narrative/narrationTemplate", "specifiers": ["interpolate", "createNarrationContext"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/actionInterpreter.ts::loadActions", "name": "loadActions", "kind": "function", "filePath": "apps/lore-weave/lib/engine/actionInterpreter.ts", "sourceCode": "/**\n * Load declarative actions and convert them to executable actions.\n */\nexport function loadActions(actions: DeclarativeAction[]): ExecutableAction[] {\n  if (!Array.isArray(actions)) {\n    console.warn('loadActions: expected array, got', typeof actions);\n    return [];\n  }\n\n  const executableActions: ExecutableAction[] = [];\n\n  for (const action of actions) {\n    if (!action || !action.id) {\n      console.warn('loadActions: skipping invalid action', action);\n      continue;\n    }\n\n    // Skip disabled actions (default to enabled if not specified)\n    if (action.enabled === false) {\n      continue;\n    }\n\n    try {\n      const executable = createExecutableAction(action);\n      executableActions.push(executable);\n    } catch (error) {\n      console.error(`Failed to create action ${action.id}:`, error);\n    }\n  }\n\n  return executableActions;\n}", "parameters": [{"name": "actions", "type": "DeclarativeAction[]", "optional": false}], "returnType": "ExecutableAction[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "../rules", "specifiers": ["Condition", "RuleContext"], "category": "internal"}, {"source": "../rules", "specifiers": ["Mutation"], "category": "internal"}, {"source": "../rules", "specifiers": ["SelectionRule", "VariableSelectionRule", "VariableDefinitionForResolution"], "category": "internal"}, {"source": "../rules", "specifiers": ["applyPickStrategy", "createActionContext", "evaluateCondition", "prepareMutation", "selectEntities", "selectVariableEntities", "resolveVariablesForEntity"], "category": "internal"}, {"source": "../narrative/narrationTemplate", "specifiers": ["interpolate", "createNarrationContext"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateTemplates", "name": "validateTemplates", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "// =============================================================================\r\n// VALIDATION FUNCTIONS\r\n// =============================================================================\r\n\r\nexport function validateTemplates(templates: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(templates)) {\r\n    errors.push({\r\n      path: 'templates',\r\n      message: 'Expected array',\r\n      value: templates,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  templates.forEach((template, index) => {\r\n    // Skip disabled templates\r\n    if (typeof template === 'object' && template !== null &&\r\n        'enabled' in template && (template as { enabled: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(template) || `[${index}]`;\r\n\r\n    if (!validateGenerator(template)) {\r\n      errors.push(...formatAjvErrors(validateGenerator.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "templates", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validatePressures", "name": "validatePressures", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validatePressures(pressures: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(pressures)) {\r\n    errors.push({\r\n      path: 'pressures',\r\n      message: 'Expected array',\r\n      value: pressures,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  pressures.forEach((pressure, index) => {\r\n    const itemId = getItemId(pressure) || `[${index}]`;\r\n\r\n    if (!validatePressure(pressure)) {\r\n      errors.push(...formatAjvErrors(validatePressure.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "pressures", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateSystems", "name": "validateSystems", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateSystems(systems: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(systems)) {\r\n    errors.push({\r\n      path: 'systems',\r\n      message: 'Expected array',\r\n      value: systems,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  systems.forEach((system, index) => {\r\n    // Skip disabled systems\r\n    if (typeof system === 'object' && system !== null &&\r\n        'enabled' in system && (system as { enabled?: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(system) || `[${index}]`;\r\n\r\n    if (!validateSystem(system)) {\r\n      errors.push(...formatAjvErrors(validateSystem.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "systems", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateEras", "name": "validateEras", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateEras(eras: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(eras)) {\r\n    errors.push({\r\n      path: 'eras',\r\n      message: 'Expected array',\r\n      value: eras,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  eras.forEach((era, index) => {\r\n    const itemId = getItemId(era) || `[${index}]`;\r\n\r\n    if (!validateEra(era)) {\r\n      errors.push(...formatAjvErrors(validateEra.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "eras", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateActions", "name": "validateActions", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function validateActions(actions: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(actions)) {\r\n    errors.push({\r\n      path: 'actions',\r\n      message: 'Expected array',\r\n      value: actions,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  actions.forEach((action, index) => {\r\n    // Skip disabled actions\r\n    if (typeof action === 'object' && action !== null &&\r\n        'enabled' in action && (action as { enabled: unknown }).enabled === false) {\r\n      return;\r\n    }\r\n\r\n    const itemId = getItemId(action) || `[${index}]`;\r\n\r\n    if (!validateAction(action)) {\r\n      errors.push(...formatAjvErrors(validateAction.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "actions", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateEntities", "name": "validateEntities", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "/**\r\n * Validate world entities from simulation output or persisted data.\r\n * Use this when loading saved simulation data from IndexedDB.\r\n */\r\nexport function validateEntities(entities: unknown): SchemaValidationResult {\r\n  const errors: SchemaError[] = [];\r\n  const warnings: SchemaError[] = [];\r\n\r\n  if (!Array.isArray(entities)) {\r\n    errors.push({\r\n      path: 'entities',\r\n      message: 'Expected array',\r\n      value: entities,\r\n      expected: 'array',\r\n    });\r\n    return { valid: false, errors, warnings };\r\n  }\r\n\r\n  entities.forEach((entity, index) => {\r\n    const itemId = getItemId(entity) || `[${index}]`;\r\n\r\n    if (!validateEntity(entity)) {\r\n      errors.push(...formatAjvErrors(validateEntity.errors, itemId));\r\n    }\r\n  });\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n  };\r\n}", "parameters": [{"name": "entities", "type": "unknown", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::validateAllConfigs", "name": "validateAllConfigs", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "/**\r\n * Validate all configuration files at once\r\n */\r\nexport function validateAllConfigs(config: {\r\n  templates?: unknown;\r\n  pressures?: unknown;\r\n  systems?: unknown;\r\n  eras?: unknown;\r\n  actions?: unknown;\r\n  seedEntities?: unknown;\r\n  schema?: {\r\n    cultures?: string[];\r\n    entityKinds?: string[];\r\n    relationshipKinds?: string[];\r\n  };\r\n}): SchemaValidationResult {\r\n  const allErrors: SchemaError[] = [];\r\n  const allWarnings: SchemaError[] = [];\r\n\r\n  if (config.templates !== undefined) {\r\n    const result = validateTemplates(config.templates);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.pressures !== undefined) {\r\n    const result = validatePressures(config.pressures);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.systems !== undefined) {\r\n    const result = validateSystems(config.systems);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.eras !== undefined) {\r\n    const result = validateEras(config.eras);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.actions !== undefined) {\r\n    const result = validateActions(config.actions);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  if (config.seedEntities !== undefined) {\r\n    const result = validateEntities(config.seedEntities);\r\n    allErrors.push(...result.errors);\r\n    allWarnings.push(...result.warnings);\r\n  }\r\n\r\n  return {\r\n    valid: allErrors.length === 0,\r\n    errors: allErrors,\r\n    warnings: allWarnings,\r\n  };\r\n}", "parameters": [{"name": "config", "type": "{\r\n  templates?: unknown;\r\n  pressures?: unknown;\r\n  systems?: unknown;\r\n  eras?: unknown;\r\n  actions?: unknown;\r\n  seedEntities?: unknown;\r\n  schema?: {\r\n    cultures?: string[];\r\n    entityKinds?: string[];\r\n    relationshipKinds?: string[];\r\n  };\r\n}", "optional": false}], "returnType": "SchemaValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/configSchemaValidator.ts::formatValidationResult", "name": "formatValidationResult", "kind": "function", "filePath": "apps/lore-weave/lib/engine/configSchemaValidator.ts", "sourceCode": "export function formatValidationResult(result: SchemaValidationResult): string {\r\n  if (result.valid && result.warnings.length === 0) {\r\n    return 'Configuration is valid.';\r\n  }\r\n\r\n  const lines: string[] = [\r\n    ...formatErrorLines(result.errors),\r\n    ...formatWarningLines(result.warnings),\r\n  ];\r\n\r\n  return lines.join('\\n');\r\n}", "parameters": [{"name": "result", "type": "SchemaValidationResult", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "ajv", "specifiers": ["Ajv", "ErrorObject"], "category": "external"}, {"source": "ajv-formats", "specifiers": ["addFormats"], "category": "external"}, {"source": "../schemas/generator.schema.json", "specifiers": ["generatorSchema"], "category": "internal"}, {"source": "../schemas/pressure.schema.json", "specifiers": ["pressureSchema"], "category": "internal"}, {"source": "../schemas/system.schema.json", "specifiers": ["systemSchema"], "category": "internal"}, {"source": "../schemas/era.schema.json", "specifiers": ["eraSchema"], "category": "internal"}, {"source": "../schemas/action.schema.json", "specifiers": ["actionSchema"], "category": "internal"}, {"source": "../schemas/entity.schema.json", "specifiers": ["entitySchema"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::selectEra", "name": "selectEra", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Select the appropriate era based on the current epoch.\n * Distributes epochs evenly across eras.\n */\nexport function selectEra(epoch: number, eras: Era[], epochsPerEra: number = 2): Era {\n  const eraIndex = Math.floor(epoch / epochsPerEra);\n  return eras[Math.min(eraIndex, eras.length - 1)];\n}", "parameters": [{"name": "epoch", "type": "number", "optional": false}, {"name": "eras", "type": "Era[]", "optional": false}, {"name": "epochsPerEra", "type": "number", "optional": true}], "returnType": "Era", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Era"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::getTemplateWeight", "name": "getTemplateWeight", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Get the era-modified weight for a template.\n * Returns baseWeight * era modifier (defaults to 1.0 if not specified).\n */\nexport function getTemplateWeight(\n  era: Era,\n  templateId: string,\n  baseWeight: number = 1.0\n): number {\n  const modifier = era.templateWeights[templateId] ?? 1.0;\n  return baseWeight * modifier;\n}", "parameters": [{"name": "era", "type": "Era", "optional": false}, {"name": "templateId", "type": "string", "optional": false}, {"name": "baseWeight", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Era"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/eraUtils.ts::getSystemModifier", "name": "getSystemModifier", "kind": "function", "filePath": "apps/lore-weave/lib/engine/eraUtils.ts", "sourceCode": "/**\n * Get the era modifier for a system.\n * Returns baseValue * era modifier (defaults to 1.0 if not specified).\n */\nexport function getSystemModifier(\n  era: Era,\n  systemId: string,\n  baseValue: number = 1.0\n): number {\n  const modifier = era.systemModifiers[systemId] ?? 1.0;\n  return baseValue * modifier;\n}", "parameters": [{"name": "era", "type": "Era", "optional": false}, {"name": "systemId", "type": "string", "optional": false}, {"name": "baseValue", "type": "number", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Era"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::evaluatePressureGrowthWithBreakdown", "name": "evaluatePressureGrowthWithBreakdown", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Evaluate all factors for a pressure and return detailed breakdown\n */\nexport function evaluatePressureGrowthWithBreakdown(\n  definition: DeclarativePressure,\n  graph: Graph\n): {\n  positiveFeedback: FeedbackContribution[];\n  negativeFeedback: FeedbackContribution[];\n  feedbackTotal: number;\n} {\n  const config = definition.growth;\n\n  const positiveFeedback: FeedbackContribution[] = [];\n  const negativeFeedback: FeedbackContribution[] = [];\n  const metricCtx = createMetricContext(graph);\n\n  let total = 0;\n\n  for (const factor of config.positiveFeedback) {\n    const details = evaluateFactorWithDetails(factor, metricCtx);\n    positiveFeedback.push(details);\n    total += details.contribution;\n  }\n\n  for (const factor of config.negativeFeedback) {\n    const details = evaluateFactorWithDetails(factor, metricCtx);\n    negativeFeedback.push(details);\n    total -= details.contribution;\n  }\n\n  return {\n    positiveFeedback,\n    negativeFeedback,\n    feedbackTotal: total\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}, {"name": "graph", "type": "Graph", "optional": false}], "returnType": "{\n  positiveFeedback: FeedbackContribution[];\n  negativeFeedback: FeedbackContribution[];\n  feedbackTotal: number;\n}", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["Pressure", "Graph"], "category": "internal"}, {"source": "./declarativePressureTypes", "specifiers": ["DeclarativePressure", "FeedbackFactor", "PressuresFile"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["describeMetric", "evaluateMetric"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["MetricContext", "MetricResult"], "category": "internal"}, {"source": "../observer/types", "specifiers": ["FeedbackContribution"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::createPressureFromDeclarative", "name": "createPressureFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "// =============================================================================\n// PRESSURE INTERPRETER\n// =============================================================================\n\n/**\n * Convert a declarative pressure to a runtime Pressure object\n */\nexport function createPressureFromDeclarative(definition: DeclarativePressure): Pressure {\n  return {\n    id: definition.id,\n    name: definition.name,\n    value: definition.initialValue,\n    homeostasis: definition.homeostasis,\n    contract: definition.contract,\n\n    growth: (graph: Graph): number => {\n      const config = definition.growth;\n      const metricCtx = createMetricContext(graph);\n\n      let total = 0;\n\n      // Add positive feedback\n      for (const factor of config.positiveFeedback) {\n        total += evaluateFactor(factor, metricCtx);\n      }\n\n      // Subtract negative feedback\n      for (const factor of config.negativeFeedback) {\n        total -= evaluateFactor(factor, metricCtx);\n      }\n\n      return total;\n    }\n  };\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["Pressure", "Graph"], "category": "internal"}, {"source": "./declarativePressureTypes", "specifiers": ["DeclarativePressure", "FeedbackFactor", "PressuresFile"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["describeMetric", "evaluateMetric"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["MetricContext", "MetricResult"], "category": "internal"}, {"source": "../observer/types", "specifiers": ["FeedbackContribution"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::loadPressures", "name": "loadPressures", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Load all pressures from a PressuresFile\n */\nexport function loadPressures(file: PressuresFile): Pressure[] {\n  return file.pressures.map(createPressureFromDeclarative);\n}", "parameters": [{"name": "file", "type": "PressuresFile", "optional": false}], "returnType": "Pressure[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["Pressure", "Graph"], "category": "internal"}, {"source": "./declarativePressureTypes", "specifiers": ["DeclarativePressure", "FeedbackFactor", "PressuresFile"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["describeMetric", "evaluateMetric"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["MetricContext", "MetricResult"], "category": "internal"}, {"source": "../observer/types", "specifiers": ["FeedbackContribution"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/pressureInterpreter.ts::loadPressure", "name": "loadPressure", "kind": "function", "filePath": "apps/lore-weave/lib/engine/pressureInterpreter.ts", "sourceCode": "/**\n * Load a single pressure from a declarative definition\n */\nexport function loadPressure(definition: DeclarativePressure): Pressure {\n  return createPressureFromDeclarative(definition);\n}", "parameters": [{"name": "definition", "type": "DeclarativePressure", "optional": false}], "returnType": "Pressure", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["Pressure", "Graph"], "category": "internal"}, {"source": "./declarativePressureTypes", "specifiers": ["DeclarativePressure", "FeedbackFactor", "PressuresFile"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["describeMetric", "evaluateMetric"], "category": "internal"}, {"source": "../rules/metrics", "specifiers": ["MetricContext", "MetricResult"], "category": "internal"}, {"source": "../observer/types", "specifiers": ["FeedbackContribution"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::createSystemFromDeclarative", "name": "createSystemFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "// =============================================================================\r\n// SYSTEM CREATION\r\n// =============================================================================\r\n\r\n/**\r\n * Create a SimulationSystem from a declarative configuration.\r\n *\r\n * @param declarative - The declarative system configuration\r\n * @returns A SimulationSystem that can be used by WorldEngine\r\n */\r\nexport function createSystemFromDeclarative(\r\n  declarative: DeclarativeSystem,\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem {\r\n  switch (declarative.systemType) {\r\n    case 'connectionEvolution':\r\n      return createConnectionEvolutionSystem(declarative.config);\r\n\r\n    case 'graphContagion':\r\n      return createGraphContagionSystem(declarative.config);\r\n\r\n    case 'thresholdTrigger':\r\n      return createThresholdTriggerSystem(declarative.config);\r\n\r\n    case 'clusterFormation':\r\n      return createClusterFormationSystem(declarative.config);\r\n\r\n    case 'tagDiffusion':\r\n      return createTagDiffusionSystem(declarative.config);\r\n\r\n    case 'planeDiffusion':\r\n      return createPlaneDiffusionSystem(declarative.config);\r\n\r\n    // Framework systems - create configured instances\r\n    case 'eraSpawner':\r\n      return createEraSpawnerSystem(declarative.config);\r\n\r\n    case 'eraTransition':\r\n      return createEraTransitionSystem(declarative.config);\r\n\r\n    case 'universalCatalyst':\r\n      return createUniversalCatalystSystem(declarative.config);\r\n\r\n    case 'relationshipMaintenance':\r\n      return createRelationshipMaintenanceSystem(declarative.config);\r\n\r\n    case 'growth':\r\n      if (!options?.growthDependencies) {\r\n        throw new Error('Growth system requires engine-level dependencies; pass growthDependencies to createSystemFromDeclarative');\r\n      }\r\n      return createGrowthSystem(declarative.config, options.growthDependencies);\r\n\r\n    default: {\r\n      // TypeScript should catch this, but just in case\r\n      const exhaustive: never = declarative;\r\n      throw new Error(`Unknown system type: ${(exhaustive as DeclarativeSystem).systemType}`);\r\n    }\r\n  }\r\n}", "parameters": [{"name": "declarative", "type": "DeclarativeSystem", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["SimulationSystem"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["ProminenceLabel"], "category": "internal"}, {"source": "../systems/connectionEvolution", "specifiers": ["createConnectionEvolutionSystem", "ConnectionEvolutionConfig"], "category": "internal"}, {"source": "../systems/graphContagion", "specifiers": ["createGraphContagionSystem", "GraphContagionConfig"], "category": "internal"}, {"source": "../systems/thresholdTrigger", "specifiers": ["createThresholdTriggerSystem", "ThresholdTriggerConfig"], "category": "internal"}, {"source": "../systems/clusterFormation", "specifiers": ["createClusterFormationSystem", "ClusterFormationConfig"], "category": "internal"}, {"source": "../systems/tagDiffusion", "specifiers": ["createTagDiffusionSystem", "TagDiffusionConfig"], "category": "internal"}, {"source": "../systems/planeDiffusion", "specifiers": ["createPlaneDiffusionSystem", "PlaneDiffusionConfig"], "category": "internal"}, {"source": "../systems/eraSpawner", "specifiers": ["createEraSpawnerSystem"], "category": "internal"}, {"source": "../systems/eraTransition", "specifiers": ["createEraTransitionSystem"], "category": "internal"}, {"source": "../systems/universalCatalyst", "specifiers": ["createUniversalCatalystSystem"], "category": "internal"}, {"source": "../systems/relationshipMaintenance", "specifiers": ["createRelationshipMaintenanceSystem"], "category": "internal"}, {"source": "../systems/growthSystem", "specifiers": ["createGrowthSystem", "GrowthSystemConfig", "GrowthSystemDependencies"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::loadSystems", "name": "loadSystems", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "/**\r\n * Load multiple systems from declarative configurations.\r\n * Filters out any invalid configs and logs warnings.\r\n *\r\n * @param declaratives - Array of declarative system configurations\r\n * @returns Array of SimulationSystem objects\r\n */\r\nexport function loadSystems(\r\n  declaratives: DeclarativeSystem[],\r\n  options?: { growthDependencies?: GrowthSystemDependencies }\r\n): SimulationSystem[] {\r\n  if (!Array.isArray(declaratives)) {\r\n    console.warn('loadSystems: expected array, got', typeof declaratives);\r\n    return [];\r\n  }\r\n\r\n  return declaratives\r\n    .filter(d => {\r\n      if (!d || typeof d !== 'object') {\r\n        console.warn('loadSystems: skipping invalid config', d);\r\n        return false;\r\n      }\r\n      if ('enabled' in d && d.enabled === false) {\r\n        return false;\r\n      }\r\n      if (!d.systemType) {\r\n        console.warn('loadSystems: skipping config without systemType', d);\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    .map(d => {\r\n      try {\r\n        return createSystemFromDeclarative(d, options);\r\n      } catch (error) {\r\n        console.error(`Failed to create system from config:`, d, error);\r\n        throw error;\r\n      }\r\n    });\r\n}", "parameters": [{"name": "declaratives", "type": "DeclarativeSystem[]", "optional": false}, {"name": "options", "type": "{ growthDependencies?: GrowthSystemDependencies }", "optional": true}], "returnType": "SimulationSystem[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["SimulationSystem"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["ProminenceLabel"], "category": "internal"}, {"source": "../systems/connectionEvolution", "specifiers": ["createConnectionEvolutionSystem", "ConnectionEvolutionConfig"], "category": "internal"}, {"source": "../systems/graphContagion", "specifiers": ["createGraphContagionSystem", "GraphContagionConfig"], "category": "internal"}, {"source": "../systems/thresholdTrigger", "specifiers": ["createThresholdTriggerSystem", "ThresholdTriggerConfig"], "category": "internal"}, {"source": "../systems/clusterFormation", "specifiers": ["createClusterFormationSystem", "ClusterFormationConfig"], "category": "internal"}, {"source": "../systems/tagDiffusion", "specifiers": ["createTagDiffusionSystem", "TagDiffusionConfig"], "category": "internal"}, {"source": "../systems/planeDiffusion", "specifiers": ["createPlaneDiffusionSystem", "PlaneDiffusionConfig"], "category": "internal"}, {"source": "../systems/eraSpawner", "specifiers": ["createEraSpawnerSystem"], "category": "internal"}, {"source": "../systems/eraTransition", "specifiers": ["createEraTransitionSystem"], "category": "internal"}, {"source": "../systems/universalCatalyst", "specifiers": ["createUniversalCatalystSystem"], "category": "internal"}, {"source": "../systems/relationshipMaintenance", "specifiers": ["createRelationshipMaintenanceSystem"], "category": "internal"}, {"source": "../systems/growthSystem", "specifiers": ["createGrowthSystem", "GrowthSystemConfig", "GrowthSystemDependencies"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/systemInterpreter.ts::isDeclarativeSystem", "name": "isDeclarativeSystem", "kind": "function", "filePath": "apps/lore-weave/lib/engine/systemInterpreter.ts", "sourceCode": "/**\r\n * Check if a value is a valid declarative system configuration.\r\n */\r\nexport function isDeclarativeSystem(value: unknown): value is DeclarativeSystem {\r\n  if (!value || typeof value !== 'object') return false;\r\n  const sys = value as Record<string, unknown>;\r\n  return (\r\n    sys.systemType === 'connectionEvolution' ||\r\n    sys.systemType === 'graphContagion' ||\r\n    sys.systemType === 'thresholdTrigger' ||\r\n    sys.systemType === 'clusterFormation' ||\r\n    sys.systemType === 'tagDiffusion' ||\r\n    sys.systemType === 'planeDiffusion' ||\r\n    sys.systemType === 'eraSpawner' ||\r\n    sys.systemType === 'eraTransition' ||\r\n    sys.systemType === 'universalCatalyst' ||\r\n    sys.systemType === 'relationshipMaintenance' ||\r\n    sys.systemType === 'growth'\r\n  ) && sys.config !== undefined;\r\n}", "parameters": [{"name": "value", "type": "unknown", "optional": false}], "returnType": "value is DeclarativeSystem", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "./types", "specifiers": ["SimulationSystem"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["ProminenceLabel"], "category": "internal"}, {"source": "../systems/connectionEvolution", "specifiers": ["createConnectionEvolutionSystem", "ConnectionEvolutionConfig"], "category": "internal"}, {"source": "../systems/graphContagion", "specifiers": ["createGraphContagionSystem", "GraphContagionConfig"], "category": "internal"}, {"source": "../systems/thresholdTrigger", "specifiers": ["createThresholdTriggerSystem", "ThresholdTriggerConfig"], "category": "internal"}, {"source": "../systems/clusterFormation", "specifiers": ["createClusterFormationSystem", "ClusterFormationConfig"], "category": "internal"}, {"source": "../systems/tagDiffusion", "specifiers": ["createTagDiffusionSystem", "TagDiffusionConfig"], "category": "internal"}, {"source": "../systems/planeDiffusion", "specifiers": ["createPlaneDiffusionSystem", "PlaneDiffusionConfig"], "category": "internal"}, {"source": "../systems/eraSpawner", "specifiers": ["createEraSpawnerSystem"], "category": "internal"}, {"source": "../systems/eraTransition", "specifiers": ["createEraTransitionSystem"], "category": "internal"}, {"source": "../systems/universalCatalyst", "specifiers": ["createUniversalCatalystSystem"], "category": "internal"}, {"source": "../systems/relationshipMaintenance", "specifiers": ["createRelationshipMaintenanceSystem"], "category": "internal"}, {"source": "../systems/growthSystem", "specifiers": ["createGrowthSystem", "GrowthSystemConfig", "GrowthSystemDependencies"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/templateInterpreter.ts::createTemplateFromDeclarative", "name": "createTemplateFromDeclarative", "kind": "function", "filePath": "apps/lore-weave/lib/engine/templateInterpreter.ts", "sourceCode": "/**\r\n * Creates a GrowthTemplate from a DeclarativeTemplate.\r\n * This allows declarative templates to be used with the existing WorldEngine.\r\n */\r\nexport function createTemplateFromDeclarative(\r\n  template: DeclarativeTemplate,\r\n  interpreter: TemplateInterpreter\r\n): GrowthTemplate {\r\n  return {\r\n    id: template.id,\r\n    name: template.name,\r\n\r\n    canApply: (graphView: WorldRuntime) => {\r\n      return interpreter.canApply(template, graphView);\r\n    },\r\n\r\n    findTargets: (graphView: WorldRuntime) => {\r\n      return interpreter.findTargets(template, graphView);\r\n    },\r\n\r\n    expand: async (graphView: WorldRuntime, target?: HardState) => {\r\n      return interpreter.expand(template, graphView, target);\r\n    }\r\n  };\r\n}", "parameters": [{"name": "template", "type": "DeclarativeTemplate", "optional": false}, {"name": "interpreter", "type": "TemplateInterpreter", "optional": false}], "returnType": "GrowthTemplate", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship", "VariableValue"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "./types", "specifiers": ["TemplateResult", "PlacementDebug"], "category": "internal"}, {"source": "../utils", "specifiers": ["pickRandom"], "category": "internal"}, {"source": "../coordinates/types", "specifiers": ["Point"], "category": "internal"}, {"source": "../rules", "specifiers": ["selectEntities as rulesSelectEntities", "selectVariableEntities as rulesSelectVariableEntities", "resolveSingleVariable", "describeSelectionFilter as rulesDescribeSelectionFilter", "evaluateGraphPath as sharedEvaluateGraphPath", "evaluateCondition as rulesEvaluateCondition", "applySelectionFilters", "applyMutation", "createRuleContext", "prominenceThreshold"], "category": "internal"}, {"source": "../rules", "specifiers": ["EntityResolver", "SelectionTrace"], "category": "internal"}, {"source": "./declarativeTypes", "specifiers": ["DeclarativeTemplate", "ApplicabilityRule", "SelectionRule", "SelectionFilter", "CreationRule", "RelationshipRule", "StateUpdateRule", "VariableDefinition", "SubtypeSpec", "SubtypeCondition", "CultureSpec", "DescriptionSpec", "PlacementSpec", "PlacementAnchor", "CountRange", "RelationshipCondition", "GraphPathAssertion", "ExecutionContext as IExecutionContext", "TemplateVariants", "TemplateVariant", "VariantCondition", "VariantEffects"], "category": "internal"}, {"source": "./types", "specifiers": ["GrowthTemplate"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateConnectedEntities", "name": "validateConnectedEntities", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that all entities have at least one connection (incoming or outgoing)\n */\nexport function validateConnectedEntities(graph: Graph): ValidationResult {\n  const unconnected = graph.getEntities().filter(entity => {\n    const hasOutgoing = graph.getEntityRelationships(entity.id, 'src').length > 0;\n    const hasIncoming = graph.getEntityRelationships(entity.id, 'dst').length > 0;\n\n    return !hasOutgoing && !hasIncoming;\n  });\n\n  const passed = unconnected.length === 0;\n\n  let details = passed\n    ? 'All entities have at least one connection'\n    : `${unconnected.length} entities have no connections:\\n`;\n\n  if (!passed) {\n    // Group by kind for summary\n    const byKind = new Map<string, number>();\n    unconnected.forEach(e => {\n      const key = `${e.kind}:${e.subtype}`;\n      byKind.set(key, (byKind.get(key) || 0) + 1);\n    });\n\n    byKind.forEach((count, kind) => {\n      details += `  - ${kind}: ${count}\\n`;\n    });\n\n    // Add sample entities\n    details += '\\nSample unconnected entities:\\n';\n    unconnected.slice(0, 5).forEach(e => {\n      details += `  - ${e.name} (${e.kind}:${e.subtype}, created tick ${e.createdAt})\\n`;\n    });\n  }\n\n  return {\n    name: 'Connected Entities',\n    passed,\n    failureCount: unconnected.length,\n    details,\n    failedEntities: unconnected\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "ValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["EngineConfig", "Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateNPCStructure", "name": "validateNPCStructure", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that entities have required structural relationships.\n * Uses canonical schema requirements (no hardcoded entity kinds).\n */\nexport function validateNPCStructure(graph: Graph, config: EngineConfig): ValidationResult {\n  const invalidEntities: HardState[] = [];\n  const missingByKindSubtype = new Map<string, Map<string, number>>();\n  const kindsWithRequirements = config.schema.entityKinds.filter(\n    kindDef => kindDef.requiredRelationships && kindDef.requiredRelationships.length > 0\n  );\n\n  if (kindsWithRequirements.length === 0) {\n    return {\n      name: 'Entity Structure',\n      passed: true,\n      failureCount: 0,\n      details: 'No requiredRelationships defined in schema'\n    };\n  }\n\n  // Check all entities against schema requirements\n  for (const entity of graph.getEntities()) {\n    const kindDef = config.schema.entityKinds.find(kind => kind.kind === entity.kind);\n    const required = kindDef?.requiredRelationships;\n    if (!required || required.length === 0) continue;\n\n    const relationships = graph.getEntityRelationships(entity.id, 'both', { includeHistorical: true });\n    const missing = required.filter(rule => !relationships.some(rel => rel.kind === rule.kind));\n\n    if (missing.length > 0) {\n      invalidEntities.push(entity);\n\n      // Track missing relationships by kind:subtype\n      const key = `${entity.kind}:${entity.subtype}`;\n      if (!missingByKindSubtype.has(key)) {\n        missingByKindSubtype.set(key, new Map());\n      }\n      const subtypeMap = missingByKindSubtype.get(key)!;\n\n      missing.forEach(rule => {\n        subtypeMap.set(rule.kind, (subtypeMap.get(rule.kind) || 0) + 1);\n      });\n    }\n  }\n\n  const passed = invalidEntities.length === 0;\n\n  let details = passed\n    ? 'All entities have required relationships'\n    : `${invalidEntities.length} entities missing required relationships:\\n`;\n\n  if (!passed) {\n    // Group by kind:subtype and missing relationships\n    missingByKindSubtype.forEach((relMap, kindSubtype) => {\n      relMap.forEach((count, relKind) => {\n        details += `  - ${kindSubtype}: ${count} (missing ${relKind})\\n`;\n      });\n    });\n  }\n\n  return {\n    name: 'Entity Structure',\n    passed,\n    failureCount: invalidEntities.length,\n    details,\n    failedEntities: invalidEntities\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["EngineConfig", "Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateRelationshipIntegrity", "name": "validateRelationshipIntegrity", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "/**\n * Validate that all relationship references point to existing entities\n */\nexport function validateRelationshipIntegrity(graph: Graph): ValidationResult {\n  const brokenRelationships: string[] = [];\n\n  graph.getRelationships().forEach((rel, index) => {\n    const srcExists = graph.getEntity(rel.src) !== undefined;\n    const dstExists = graph.getEntity(rel.dst) !== undefined;\n\n    if (!srcExists || !dstExists) {\n      const srcName = graph.getEntity(rel.src)?.name || rel.src;\n      const dstName = graph.getEntity(rel.dst)?.name || rel.dst;\n      brokenRelationships.push(\n        `[${index}] ${rel.kind}: ${srcName} \u2192 ${dstName} ` +\n        `(${!srcExists ? 'src missing' : ''} ${!dstExists ? 'dst missing' : ''})`\n      );\n    }\n  });\n\n  const passed = brokenRelationships.length === 0;\n\n  let details = passed\n    ? 'All relationships reference existing entities'\n    : `${brokenRelationships.length} broken relationships:\\n`;\n\n  if (!passed) {\n    brokenRelationships.slice(0, 10).forEach(msg => {\n      details += `  - ${msg}\\n`;\n    });\n    if (brokenRelationships.length > 10) {\n      details += `  ... and ${brokenRelationships.length - 10} more\\n`;\n    }\n  }\n\n  return {\n    name: 'Relationship Integrity',\n    passed,\n    failureCount: brokenRelationships.length,\n    details\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}], "returnType": "ValidationResult", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["EngineConfig", "Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/engine/validators.ts::validateWorld", "name": "validateWorld", "kind": "function", "filePath": "apps/lore-weave/lib/engine/validators.ts", "sourceCode": "// validateLorePresence moved to @illuminator\n\n/**\n * Run all validators and generate a complete report\n */\nexport function validateWorld(graph: Graph, config: EngineConfig): ValidationReport {\n  const results: ValidationResult[] = [\n    validateConnectedEntities(graph),\n    validateNPCStructure(graph, config),\n    validateRelationshipIntegrity(graph)\n    // validateLorePresence moved to @illuminator\n  ];\n\n  const passed = results.filter(r => r.passed).length;\n  const failed = results.filter(r => !r.passed).length;\n\n  return {\n    totalChecks: results.length,\n    passed,\n    failed,\n    results\n  };\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "config", "type": "EngineConfig", "optional": false}], "returnType": "ValidationReport", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["EngineConfig", "Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::calculateSimilarity", "name": "calculateSimilarity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Calculate similarity score between two entities based on criteria\n */\nexport function calculateSimilarity(\n  e1: HardState,\n  e2: HardState,\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime\n): { score: number; matchedCriteria: string[] } {\n  let score = 0;\n  const matchedCriteria: string[] = [];\n\n  for (const criterion of criteria) {\n    let matches = false;\n\n    switch (criterion.type) {\n      case 'shared_relationship': {\n        if (!criterion.relationshipKind) break;\n        const direction = criterion.direction || 'src';\n\n        const e1Related = graphView.getConnectedEntities(e1.id, criterion.relationshipKind, direction);\n        const e2Related = graphView.getConnectedEntities(e2.id, criterion.relationshipKind, direction);\n        const e1RelatedIds = new Set(e1Related.map(r => r.id));\n        matches = e2Related.some(r => e1RelatedIds.has(r.id));\n        break;\n      }\n\n      case 'shared_tags': {\n        const e1Tags = new Set(Object.keys(e1.tags || {}));\n        const e2Tags = new Set(Object.keys(e2.tags || {}));\n        const intersection = Array.from(e1Tags).filter(t => e2Tags.has(t)).length;\n        const union = new Set([...e1Tags, ...e2Tags]).size;\n        const jaccard = union > 0 ? intersection / union : 0;\n        matches = jaccard >= (criterion.threshold || 0.3);\n        break;\n      }\n\n      case 'temporal_proximity': {\n        const timeDiff = Math.abs(e1.createdAt - e2.createdAt);\n        matches = timeDiff <= (criterion.threshold || 30);\n        break;\n      }\n\n      case 'same_subtype': {\n        matches = e1.subtype === e2.subtype;\n        break;\n      }\n\n      case 'same_culture': {\n        matches = e1.culture === e2.culture;\n        break;\n      }\n\n      case 'custom': {\n        if (criterion.predicate) {\n          matches = criterion.predicate(e1, e2, graphView);\n        }\n        break;\n      }\n    }\n\n    if (matches) {\n      score += criterion.weight;\n      matchedCriteria.push(criterion.type);\n    }\n  }\n\n  return { score, matchedCriteria };\n}", "parameters": [{"name": "e1", "type": "HardState", "optional": false}, {"name": "e2", "type": "HardState", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "{ score: number; matchedCriteria: string[] }", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_TAGS"], "category": "external"}, {"source": "../utils", "specifiers": ["hasTag"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::detectClusters", "name": "detectClusters", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "export function detectClusters(\n  entities: HardState[],\n  config: ClusterConfig,\n  graphView: WorldRuntime\n): Cluster[] {\n  if (entities.length < config.minSize) {\n    return [];\n  }\n\n  // Sort by creation time (cluster chronologically related entities)\n  const sorted = [...entities].sort((a, b) => a.createdAt - b.createdAt);\n\n  // Greedy clustering: try to add each entity to an existing cluster or create new one\n  const clusters: Cluster[] = [];\n  const clusterJoinThreshold = config.clusterJoinThreshold ?? 0.7;\n\n  for (const entity of sorted) {\n    const matched = tryAddToExistingCluster(entity, clusters, config, clusterJoinThreshold, graphView);\n    if (!matched) {\n      clusters.push({\n        entities: [entity],\n        score: config.minimumScore,\n        matchedCriteria: []\n      });\n    }\n  }\n\n  // Filter clusters by minimum size and apply maximum size\n  const validClusters = clusters.filter(c => {\n    if (c.entities.length < config.minSize) return false;\n    if (config.maxSize && c.entities.length > config.maxSize) {\n      // Truncate cluster to max size (keep earliest created)\n      c.entities = c.entities.slice(0, config.maxSize);\n    }\n    return true;\n  });\n\n  return validClusters;\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}, {"name": "config", "type": "ClusterConfig", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}], "returnType": "Cluster[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_TAGS"], "category": "external"}, {"source": "../utils", "specifiers": ["hasTag"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::filterClusterableEntities", "name": "filterClusterableEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Filter entities that are eligible for clustering.\n * Excludes historical entities and meta-entities.\n *\n * @param entities - All entities to filter\n * @returns Filtered entities eligible for clustering\n */\nexport function filterClusterableEntities(entities: HardState[]): HardState[] {\n  return entities.filter(e =>\n    e.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    e.status !== FRAMEWORK_STATUS.SUBSUMED &&\n    !hasTag(e.tags, FRAMEWORK_TAGS.META_ENTITY)\n  );\n}", "parameters": [{"name": "entities", "type": "HardState[]", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_TAGS"], "category": "external"}, {"source": "../utils", "specifiers": ["hasTag"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/clusteringUtils.ts::findBestClusterMatch", "name": "findBestClusterMatch", "kind": "function", "filePath": "apps/lore-weave/lib/graph/clusteringUtils.ts", "sourceCode": "/**\n * Find the best cluster match for a new entity.\n * Useful for deciding which existing cluster to add a new entity to.\n *\n * @param entity - Entity to find cluster for\n * @param clusters - Existing clusters\n * @param criteria - Similarity criteria\n * @param graphView - Graph view for relationship queries\n * @param minimumScore - Minimum score to be considered a match\n * @returns Best matching cluster or undefined\n */\nexport function findBestClusterMatch(\n  entity: HardState,\n  clusters: Cluster[],\n  criteria: ClusterCriterion[],\n  graphView: WorldRuntime,\n  minimumScore: number\n): Cluster | undefined {\n  let bestCluster: Cluster | undefined;\n  let bestScore = 0;\n\n  for (const cluster of clusters) {\n    let totalScore = 0;\n    let count = 0;\n\n    for (const member of cluster.entities) {\n      const { score } = calculateSimilarity(entity, member, criteria, graphView);\n      totalScore += score;\n      count++;\n    }\n\n    const avgScore = count > 0 ? totalScore / count : 0;\n\n    if (avgScore >= minimumScore && avgScore > bestScore) {\n      bestCluster = cluster;\n      bestScore = avgScore;\n    }\n  }\n\n  return bestCluster;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}, {"name": "clusters", "type": "Cluster[]", "optional": false}, {"name": "criteria", "type": "ClusterCriterion[]", "optional": false}, {"name": "graphView", "type": "WorldRuntime", "optional": false}, {"name": "minimumScore", "type": "number", "optional": false}], "returnType": "Cluster | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}, {"source": "../runtime/worldRuntime", "specifiers": ["WorldRuntime"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_TAGS"], "category": "external"}, {"source": "../utils", "specifiers": ["hasTag"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::archiveEntity", "name": "archiveEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Mark an entity as historical and optionally archive its relationships.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity to archive\n * @param options - Archival options\n */\nexport function archiveEntity(\n  graph: Graph,\n  entityId: string,\n  options: ArchiveEntityOptions = {}\n): void {\n  const entity = graph.getEntity(entityId);\n  if (!entity) return;\n\n  const {\n    archiveRelationships: shouldArchiveRels = true,\n    excludeRelationshipKinds = [],\n    status = FRAMEWORK_STATUS.HISTORICAL\n  } = options;\n\n  // Mark entity as historical (use updateEntity to trigger mutation tracking)\n  graph.updateEntity(entityId, { status });\n\n  // Archive relationships if requested\n  if (shouldArchiveRels) {\n    const entityRelationships = graph.getRelationships().filter(r =>\n      (r.src === entityId || r.dst === entityId) &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n      !excludeRelationshipKinds.includes(r.kind)\n    );\n\n    entityRelationships.forEach(rel => {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::archiveEntities", "name": "archiveEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Archive multiple entities at once.\n *\n * @param graph - The world graph\n * @param entityIds - IDs of entities to archive\n * @param options - Archival options\n */\nexport function archiveEntities(\n  graph: Graph,\n  entityIds: string[],\n  options: ArchiveEntityOptions = {}\n): void {\n  entityIds.forEach(id => archiveEntity(graph, id, options));\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityIds", "type": "string[]", "optional": false}, {"name": "options", "type": "ArchiveEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::transferRelationships", "name": "transferRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Transfer relationships from source entities to a target entity.\n * Creates new relationships with the target and optionally archives originals.\n *\n * @param graph - The world graph\n * @param sourceIds - IDs of entities to transfer relationships from\n * @param targetId - ID of entity to transfer relationships to\n * @param options - Transfer options\n * @returns Number of relationships transferred\n */\nexport function transferRelationships(\n  graph: Graph,\n  sourceIds: string[],\n  targetId: string,\n  options: TransferRelationshipsOptions = {}\n): number {\n  const {\n    excludeKinds = [FRAMEWORK_RELATIONSHIP_KINDS.PART_OF],\n    sourceOnly = false,\n    destinationOnly = false,\n    archiveOriginals = true\n  } = options;\n\n  const sourceIdSet = new Set(sourceIds);\n  const transferred = new Set<string>();\n\n  // Find all relationships involving source entities\n  const toTransfer = graph.getRelationships().filter(r =>\n    (sourceIdSet.has(r.src) || sourceIdSet.has(r.dst)) &&\n    r.status !== FRAMEWORK_STATUS.HISTORICAL &&\n    !excludeKinds.includes(r.kind)\n  );\n\n  toTransfer.forEach(rel => {\n    let newSrc = rel.src;\n    let newDst = rel.dst;\n\n    // Determine new endpoints\n    if (sourceIdSet.has(rel.src) && !destinationOnly) {\n      newSrc = targetId;\n    }\n    if (sourceIdSet.has(rel.dst) && !sourceOnly) {\n      newDst = targetId;\n    }\n\n    // Skip if no change (shouldn't happen with proper source filtering)\n    if (newSrc === rel.src && newDst === rel.dst) return;\n\n    // Handle self-loops (both endpoints are being transferred to same target)\n    // Don't create self-referential relationship, but DO archive the original\n    if (newSrc === newDst) {\n      if (archiveOriginals) {\n        archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n      }\n      return;\n    }\n\n    // Avoid duplicates\n    const key = `${newSrc}:${newDst}:${rel.kind}`;\n    if (transferred.has(key)) return;\n\n    // Create new relationship\n    addRelationship(graph, rel.kind, newSrc, newDst);\n    transferred.add(key);\n\n    // Archive original if requested\n    if (archiveOriginals) {\n      archiveRelationship(graph, rel.src, rel.dst, rel.kind);\n    }\n  });\n\n  return transferred.size;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "sourceIds", "type": "string[]", "optional": false}, {"name": "targetId", "type": "string", "optional": false}, {"name": "options", "type": "TransferRelationshipsOptions", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::createPartOfRelationships", "name": "createPartOfRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Create part_of relationships from members to a container entity.\n *\n * @param graph - The world graph\n * @param memberIds - IDs of member entities\n * @param containerId - ID of container entity\n * @returns Number of relationships created\n */\nexport function createPartOfRelationships(\n  graph: Graph,\n  memberIds: string[],\n  containerId: string\n): number {\n  let created = 0;\n\n  memberIds.forEach(memberId => {\n    // Check if relationship already exists\n    const exists = graph.getRelationships().some(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.src === memberId &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    );\n\n    if (!exists) {\n      addRelationship(graph, FRAMEWORK_RELATIONSHIP_KINDS.PART_OF, memberId, containerId);\n      created++;\n    }\n  });\n\n  return created;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "memberIds", "type": "string[]", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getActiveRelationships", "name": "getActiveRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all active relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @param direction - Filter by direction ('src', 'dst', or 'both')\n * @returns Active relationships\n */\nexport function getActiveRelationships(\n  graph: Graph,\n  entityId: string,\n  direction: 'src' | 'dst' | 'both' = 'both'\n): Relationship[] {\n  return graph.getRelationships().filter(r => {\n    if (r.status === FRAMEWORK_STATUS.HISTORICAL) return false;\n\n    switch (direction) {\n      case 'src':\n        return r.src === entityId;\n      case 'dst':\n        return r.dst === entityId;\n      case 'both':\n        return r.src === entityId || r.dst === entityId;\n    }\n  });\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}], "returnType": "Relationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getHistoricalRelationships", "name": "getHistoricalRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all historical relationships for an entity.\n *\n * @param graph - The world graph\n * @param entityId - ID of entity\n * @returns Historical relationships\n */\nexport function getHistoricalRelationships(\n  graph: Graph,\n  entityId: string\n): Relationship[] {\n  return graph.getRelationships().filter(r =>\n    r.status === FRAMEWORK_STATUS.HISTORICAL &&\n    (r.src === entityId || r.dst === entityId)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}], "returnType": "Relationship[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::isHistoricalEntity", "name": "isHistoricalEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Check if an entity is historical.\n *\n * @param entity - Entity to check\n * @returns True if entity is historical\n */\nexport function isHistoricalEntity(entity: HardState): boolean {\n  return entity.status === FRAMEWORK_STATUS.HISTORICAL;\n}", "parameters": [{"name": "entity", "type": "HardState", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::getPartOfMembers", "name": "getPartOfMembers", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Get all entities that are part of a container entity.\n *\n * @param graph - The world graph\n * @param containerId - ID of container entity\n * @returns Member entities\n */\nexport function getPartOfMembers(\n  graph: Graph,\n  containerId: string\n): HardState[] {\n  const memberIds = graph.getRelationships()\n    .filter(r =>\n      r.kind === FRAMEWORK_RELATIONSHIP_KINDS.PART_OF &&\n      r.dst === containerId &&\n      r.status !== FRAMEWORK_STATUS.HISTORICAL\n    )\n    .map(r => r.src);\n\n  return memberIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "containerId", "type": "string", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityArchival.ts::supersedeEntity", "name": "supersedeEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityArchival.ts", "sourceCode": "/**\n * Supersede one entity with another.\n * Creates supersedes relationship, transfers relationships, and archives original.\n *\n * @param graph - The world graph\n * @param oldEntityId - ID of entity being superseded\n * @param newEntityId - ID of new entity\n * @param options - Supersede options\n */\nexport function supersedeEntity(\n  graph: Graph,\n  oldEntityId: string,\n  newEntityId: string,\n  options: SupersedeEntityOptions = {}\n): void {\n  const {\n    archiveSuperseded = true,\n    createSupersedes = true,\n    ...transferOptions\n  } = options;\n\n  // Create supersedes relationship (new supersedes old)\n  if (createSupersedes) {\n    addRelationship(\n      graph,\n      FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n      newEntityId,\n      oldEntityId\n    );\n  }\n\n  // Transfer relationships from old to new\n  transferRelationships(\n    graph,\n    [oldEntityId],\n    newEntityId,\n    {\n      ...transferOptions,\n      excludeKinds: [\n        ...(transferOptions.excludeKinds || []),\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    }\n  );\n\n  // Archive old entity\n  if (archiveSuperseded) {\n    archiveEntity(graph, oldEntityId, {\n      archiveRelationships: false, // Already handled by transfer\n      excludeRelationshipKinds: [\n        FRAMEWORK_RELATIONSHIP_KINDS.SUPERSEDES,\n        FRAMEWORK_RELATIONSHIP_KINDS.PART_OF\n      ]\n    });\n  }\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "oldEntityId", "type": "string", "optional": false}, {"name": "newEntityId", "type": "string", "optional": false}, {"name": "options", "type": "SupersedeEntityOptions", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_STATUS", "FRAMEWORK_RELATIONSHIP_KINDS"], "category": "external"}, {"source": "../utils", "specifiers": ["archiveRelationship", "addRelationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityClusterBuilder.ts::buildCluster", "name": "buildCluster", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityClusterBuilder.ts", "sourceCode": "/**\n * Helper function to create a new EntityClusterBuilder\n * Usage: buildCluster().addEntity(...).relate(...).build()\n */\nexport function buildCluster(): EntityClusterBuilder {\n  return new EntityClusterBuilder();\n}", "parameters": [], "returnType": "EntityClusterBuilder", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}, {"source": "../engine/types", "specifiers": ["TemplateResult"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::slugifyName", "name": "slugifyName", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Slugify a name for use in IDs or other contexts\n */\nexport function slugifyName(name: string): string {\n  return name\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '') || 'unknown'; // eslint-disable-line sonarjs/slow-regex -- short slug string, no ReDoS risk\n}", "parameters": [{"name": "name", "type": "string", "optional": false}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "EntityTags"], "category": "internal"}, {"source": "../utils/tagUtils", "specifiers": ["arrayToTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_ENTITY_KINDS", "FRAMEWORK_RELATIONSHIP_KINDS", "FRAMEWORK_RELATIONSHIP_PROPERTIES", "FRAMEWORK_STATUS"], "category": "external"}]}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::generateEntityIdFromName", "name": "generateEntityIdFromName", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Generate a stable entity ID from a name, with optional collision handling.\n */\nexport function generateEntityIdFromName(\n  name: string,\n  hasEntity?: (id: string) => boolean,\n  log?: (message: string, context?: Record<string, unknown>) => void\n): string {\n  const baseId = slugifyName(name);\n  if (!hasEntity) return baseId;\n  if (!hasEntity(baseId)) return baseId;\n\n  let suffix = 2;\n  let candidate = `${baseId}-${suffix}`;\n  while (hasEntity(candidate)) {\n    suffix += 1;\n    candidate = `${baseId}-${suffix}`;\n  }\n\n  log?.(`Entity id collision for \"${name}\". Using \"${candidate}\".`, {\n    name,\n    baseId,\n    resolvedId: candidate\n  });\n\n  return candidate;\n}", "parameters": [{"name": "name", "type": "string", "optional": false}, {"name": "hasEntity", "type": "(id: string) => boolean", "optional": true}, {"name": "log", "type": "(message: string, context?: Record<string, unknown>) => void", "optional": true}], "returnType": "string", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "EntityTags"], "category": "internal"}, {"source": "../utils/tagUtils", "specifiers": ["arrayToTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_ENTITY_KINDS", "FRAMEWORK_RELATIONSHIP_KINDS", "FRAMEWORK_RELATIONSHIP_PROPERTIES", "FRAMEWORK_STATUS"], "category": "external"}]}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::normalizeInitialState", "name": "normalizeInitialState", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "export function normalizeInitialState(entities: RawEntityInput[]): HardState[] {\n  return entities.map((entity, index) => {\n    if (!entity.id) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no id. ` +\n        `Seed entities must include a stable id used by relationships.`\n      );\n    }\n    if (!entity.name) {\n      throw new Error(\n        `normalizeInitialState: entity at index ${index} has no name. ` +\n        `Initial state entities must have names defined in JSON.`\n      );\n    }\n    if (!entity.coordinates) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no coordinates. ` +\n        `Initial state entities must have coordinates defined in JSON.`\n      );\n    }\n    if (!entity.kind) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no kind.`\n      );\n    }\n    if (!entity.subtype) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no subtype.`\n      );\n    }\n    if (!entity.status) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no status.`\n      );\n    }\n    if (!entity.prominence) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no prominence.`\n      );\n    }\n    if (!entity.culture) {\n      throw new Error(\n        `normalizeInitialState: entity \"${entity.name}\" at index ${index} has no culture.`\n      );\n    }\n\n    // Handle both old array format and new KVP format for tags\n    let tags: EntityTags;\n    if (Array.isArray(entity.tags)) {\n      tags = arrayToTags(entity.tags);\n    } else {\n      tags = entity.tags || {};\n    }\n\n    const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n    return {\n      id: entity.id,\n      kind: entity.kind,\n      subtype: entity.subtype,\n      name: entity.name,\n      summary: entity.summary,\n      narrativeHint,\n      description: entity.description || '',\n      status: entity.status,\n      prominence: entity.prominence,\n      culture: entity.culture,\n      tags,\n      createdAt: 0,\n      updatedAt: 0,\n      coordinates: entity.coordinates\n    };\n  });\n}", "parameters": [{"name": "entities", "type": "RawEntityInput[]", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "EntityTags"], "category": "internal"}, {"source": "../utils/tagUtils", "specifiers": ["arrayToTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_ENTITY_KINDS", "FRAMEWORK_RELATIONSHIP_KINDS", "FRAMEWORK_RELATIONSHIP_PROPERTIES", "FRAMEWORK_STATUS"], "category": "external"}]}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::addEntity", "name": "addEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "export async function addEntity(graph: Graph, entity: Partial<HardState>, source?: string, placementStrategy?: string): Promise<string> {\n  validateEntityForAdd(entity);\n\n  const coords = entity.coordinates!;\n  const tags: EntityTags = Array.isArray(entity.tags) ? arrayToTags(entity.tags) : { ...(entity.tags || {}) };\n\n  const entityId = generateEntityIdFromName(entity.name!, id => graph.hasEntity(id));\n\n  // Delegate to Graph.createEntity()\n  // Use validated coords to satisfy TypeScript (already validated above)\n  if (typeof coords.z !== 'number') {\n    throw new Error(\n      `addEntity: coordinates must include numeric z. ` +\n      `Entity kind: ${entity.kind}, name: ${entity.name || 'unnamed'}. ` +\n      `Received: ${JSON.stringify(coords)}.`\n    );\n  }\n  const validCoords = { x: coords.x, y: coords.y, z: coords.z };\n\n  const currentEraEntity = entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA\n    ? graph.findEntities({\n        kind: FRAMEWORK_ENTITY_KINDS.ERA,\n        status: FRAMEWORK_STATUS.CURRENT\n      })[0]\n    : undefined;\n  const explicitEraId = entity.eraId;\n  let resolvedEraId: string | undefined;\n  if (typeof explicitEraId === 'string' && explicitEraId) {\n    resolvedEraId = explicitEraId;\n  } else if (entity.kind === FRAMEWORK_ENTITY_KINDS.ERA) {\n    resolvedEraId = entity.subtype;\n  } else {\n    resolvedEraId = currentEraEntity?.id;\n  }\n\n  const narrativeHint = entity.narrativeHint ?? entity.summary ?? (entity.description ? entity.description : undefined);\n\n  const createdId = await graph.createEntity({\n    id: entityId,\n    kind: entity.kind!,\n    subtype: entity.subtype!,\n    coordinates: validCoords,\n    tags,\n    eraId: resolvedEraId,\n    name: entity.name,\n    description: entity.description,\n    narrativeHint,\n    status: entity.status!,\n    prominence: entity.prominence!,\n    culture: entity.culture!,\n    temporal: entity.temporal,\n    source,\n    placementStrategy\n  });\n\n  // Create CREATED_DURING relationship to current era (unless entity is an era itself)\n  // This is a framework-level temporal relationship distinct from spatial \"originated_in\"\n  if (entity.kind !== FRAMEWORK_ENTITY_KINDS.ERA && currentEraEntity) {\n    graph.addRelationship(\n      FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING,\n      entityId,\n      currentEraEntity.id,\n      FRAMEWORK_RELATIONSHIP_PROPERTIES[FRAMEWORK_RELATIONSHIP_KINDS.CREATED_DURING].defaultStrength\n    );\n  }\n\n  return createdId;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "Partial<HardState>", "optional": false}, {"name": "source", "type": "string", "optional": true}, {"name": "placementStrategy", "type": "string", "optional": true}], "returnType": "Promise<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "EntityTags"], "category": "internal"}, {"source": "../utils/tagUtils", "specifiers": ["arrayToTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_ENTITY_KINDS", "FRAMEWORK_RELATIONSHIP_KINDS", "FRAMEWORK_RELATIONSHIP_PROPERTIES", "FRAMEWORK_STATUS"], "category": "external"}]}, {"id": "apps/lore-weave/lib/graph/entityMutation.ts::updateEntity", "name": "updateEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityMutation.ts", "sourceCode": "/**\n * Update entity in graph\n */\nexport function updateEntity(\n  graph: Graph,\n  entityId: string,\n  changes: Partial<HardState>\n): void {\n  // Use Graph's updateEntity method to modify the actual entity, not a clone\n  graph.updateEntity(entityId, changes);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "changes", "type": "Partial<HardState>", "optional": false}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "EntityTags"], "category": "internal"}, {"source": "../utils/tagUtils", "specifiers": ["arrayToTags"], "category": "internal"}, {"source": "@canonry/world-schema", "specifiers": ["FRAMEWORK_ENTITY_KINDS", "FRAMEWORK_RELATIONSHIP_KINDS", "FRAMEWORK_RELATIONSHIP_PROPERTIES", "FRAMEWORK_STATUS"], "category": "external"}]}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::findEntities", "name": "findEntities", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Find entities matching criteria\r\n */\r\nexport function findEntities(\r\n  graph: Graph,\r\n  criteria: Partial<HardState>\r\n): HardState[] {\r\n  const results: HardState[] = [];\r\n\r\n  graph.forEachEntity(entity => {\r\n    let matches = true;\r\n\r\n    for (const [key, value] of Object.entries(criteria)) {\r\n      if (entity[key as keyof HardState] !== value) {\r\n        matches = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches) {\r\n      results.push(entity);\r\n    }\r\n  });\r\n\r\n  return results;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "criteria", "type": "Partial<HardState>", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getRelated", "name": "getRelated", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Get related entities via relationships\r\n */\r\nexport function getRelated(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipKind?: string,\r\n  direction: 'src' | 'dst' | 'both' = 'both',\r\n  options?: RelationshipQueryOptions\r\n): HardState[] {\r\n  const related: Array<{ entity: HardState; strength: number }> = [];\r\n  const opts = options || {};\r\n\r\n  graph.getRelationships().forEach(rel => {\r\n    if (relationshipKind && rel.kind !== relationshipKind) return;\r\n\r\n    // Strength filtering\r\n    const strength = rel.strength ?? 0.5;\r\n    if (opts.minStrength !== undefined && strength < opts.minStrength) return;\r\n    if (opts.maxStrength !== undefined && strength > opts.maxStrength) return;\r\n\r\n    if ((direction === 'src' || direction === 'both') && rel.src === entityId) {\r\n      const entity = graph.getEntity(rel.dst);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n\r\n    if ((direction === 'dst' || direction === 'both') && rel.dst === entityId) {\r\n      const entity = graph.getEntity(rel.src);\r\n      if (entity) related.push({ entity, strength });\r\n    }\r\n  });\r\n\r\n  // Sort by strength if requested\r\n  if (opts.sortByStrength) {\r\n    related.sort((a, b) => b.strength - a.strength);\r\n  }\r\n\r\n  return related.map(r => r.entity);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": true}, {"name": "direction", "type": "'src' | 'dst' | 'both'", "optional": true}, {"name": "options", "type": "RelationshipQueryOptions", "optional": true}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::hasRelationship", "name": "hasRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "export function hasRelationship(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind?: string\r\n): boolean {\r\n  return graph.getRelationships().some(rel =>\r\n    rel.src === srcId &&\r\n    rel.dst === dstId &&\r\n    (!kind || rel.kind === kind)\r\n  );\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": true}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getConnectionWeight", "name": "getConnectionWeight", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Calculate relationship formation weight based on existing connection count.\r\n * Favors underconnected entities to balance network density and prevent hubs.\r\n */\r\nexport function getConnectionWeight(graph: Graph, entity: HardState): number {\r\n  const connectionCount = graph.getEntityRelationships(entity.id, 'both').length;\r\n\r\n  // Boost isolated/underconnected entities\r\n  if (connectionCount === 0) return 3.0;    // Strongly boost isolated\r\n  if (connectionCount <= 2) return 2.0;     // Boost underconnected (below median)\r\n  if (connectionCount <= 5) return 1.0;     // Normal\r\n  if (connectionCount <= 10) return 0.5;    // Reduce well-connected\r\n  return 0.2;                               // Heavily reduce hubs (15+)\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entity", "type": "HardState", "optional": false}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/entityQueries.ts::getFactionRelationship", "name": "getFactionRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/entityQueries.ts", "sourceCode": "/**\r\n * Determine the relationship between two sets of factions.\r\n */\r\nexport function getFactionRelationship(\r\n  factions1: HardState[],\r\n  factions2: HardState[],\r\n  graph: Graph\r\n): 'allied' | 'enemy' | 'neutral' {\r\n  // Check for warfare/enmity\r\n  const atWar = factions1.some(f1 =>\r\n    factions2.some(f2 =>\r\n      hasRelationship(graph, f1.id, f2.id, 'at_war_with') ||\r\n      hasRelationship(graph, f1.id, f2.id, 'enemy_of')\r\n    )\r\n  );\r\n  if (atWar) return 'enemy';\r\n\r\n  // Check for alliances\r\n  const allied = factions1.some(f1 =>\r\n    factions2.some(f2 => hasRelationship(graph, f1.id, f2.id, 'allied_with'))\r\n  );\r\n  if (allied) return 'allied';\r\n\r\n  return 'neutral';\r\n}", "parameters": [{"name": "factions1", "type": "HardState[]", "optional": false}, {"name": "factions2", "type": "HardState[]", "optional": false}, {"name": "graph", "type": "Graph", "optional": false}], "returnType": "'allied' | 'enemy' | 'neutral'", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getEntitiesByRelationship", "name": "getEntitiesByRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Graph Query Utilities\n *\n * Reusable query patterns for common graph operations.\n * Extracted to reduce code duplication and improve maintainability.\n *\n * @module graphQueries\n */\n\n/**\n * Get all entities related to a given entity by a specific relationship kind\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity to find related entities for\n * @param relationshipKind - Type of relationship to filter by\n * @param direction - Whether the entity is the source or destination\n * @returns Array of related entities\n */\nexport function getEntitiesByRelationship(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction: 'src' | 'dst'\n): HardState[] {\n  const relatedIds = graph.getRelationships()\n    .filter(r => r.kind === relationshipKind && r[direction] === entityId)\n    .map(r => direction === 'src' ? r.dst : r.src);\n\n  return relatedIds\n    .map(id => graph.getEntity(id))\n    .filter((e): e is HardState => e !== undefined);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": false}], "returnType": "HardState[]", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getRelationshipIdSet", "name": "getRelationshipIdSet", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Get all relationship IDs for an entity as a set\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKinds - Array of relationship kinds to include\n * @param direction - Optional direction filter ('src' or 'dst')\n * @returns Set of related entity IDs\n */\nexport function getRelationshipIdSet(\n  graph: Graph,\n  entityId: string,\n  relationshipKinds: string[],\n  direction?: 'src' | 'dst'\n): Set<string> {\n  return new Set(\n    graph.getRelationships()\n      .filter(r => {\n        if (!relationshipKinds.includes(r.kind)) return false;\n        if (!direction) return r.src === entityId || r.dst === entityId;\n        return r[direction] === entityId;\n      })\n      .map(r => r.src === entityId ? r.dst : r.src)\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKinds", "type": "string[]", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": true}], "returnType": "Set<string>", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::countRelationships", "name": "countRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Count relationships of a specific kind for an entity\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKind - Type of relationship to count\n * @param direction - Optional direction filter\n * @returns Count of matching relationships\n */\nexport function countRelationships(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction?: 'src' | 'dst'\n): number {\n  return graph.getRelationships().filter(r => {\n    if (r.kind !== relationshipKind) return false;\n    if (!direction) return r.src === entityId || r.dst === entityId;\n    return r[direction] === entityId;\n  }).length;\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": true}], "returnType": "number", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::findRelationship", "name": "findRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Find single relationship matching criteria\n *\n * @param graph - The graph to query\n * @param entityId - ID of the entity\n * @param relationshipKind - Type of relationship to find\n * @param direction - Direction filter\n * @returns First matching relationship or undefined\n */\nexport function findRelationship(\n  graph: Graph,\n  entityId: string,\n  relationshipKind: string,\n  direction: 'src' | 'dst'\n): Relationship | undefined {\n  return graph.getRelationships().find(r =>\n    r.kind === relationshipKind && r[direction] === entityId\n  );\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipKind", "type": "string", "optional": false}, {"name": "direction", "type": "'src' | 'dst'", "optional": false}], "returnType": "Relationship | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/graphQueries.ts::getRelatedEntity", "name": "getRelatedEntity", "kind": "function", "filePath": "apps/lore-weave/lib/graph/graphQueries.ts", "sourceCode": "/**\n * Get entity at other end of a relationship\n *\n * @param graph - The graph to query\n * @param relationship - The relationship to traverse\n * @param fromEntityId - ID of the starting entity\n * @returns Entity at the other end of the relationship, or undefined\n */\nexport function getRelatedEntity(\n  graph: Graph,\n  relationship: Relationship | undefined,\n  fromEntityId: string\n): HardState | undefined {\n  if (!relationship) return undefined;\n  const targetId = relationship.src === fromEntityId ? relationship.dst : relationship.src;\n  return graph.getEntity(targetId);\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "relationship", "type": "Relationship | undefined", "optional": false}, {"name": "fromEntityId", "type": "string", "optional": false}], "returnType": "HardState | undefined", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}, {"source": "../core/worldTypes", "specifiers": ["HardState", "Relationship"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipBuilder.ts::buildRelationships", "name": "buildRelationships", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipBuilder.ts", "sourceCode": "/**\n * Helper function to create a new RelationshipBuilder\n * Usage: buildRelationships().add(...).add(...).build()\n */\nexport function buildRelationships(): RelationshipBuilder {\n  return new RelationshipBuilder();\n}", "parameters": [], "returnType": "RelationshipBuilder", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["Relationship"], "category": "internal"}, {"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipBuilder.ts::createRelationship", "name": "createRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipBuilder.ts", "sourceCode": "/**\n * Quick helper to create a single relationship\n * @param kind - Relationship type\n * @param src - Source entity ID\n * @param dst - Destination entity ID\n * @param strength - Optional relationship strength\n */\nexport function createRelationship(\n  kind: string,\n  src: string,\n  dst: string,\n  strength: number = 0.5\n): Relationship {\n  return { kind, src, dst, strength };\n}", "parameters": [{"name": "kind", "type": "string", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "Relationship", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../core/worldTypes", "specifiers": ["Relationship"], "category": "internal"}, {"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::addRelationship", "name": "addRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP MUTATION\r\n// ===========================\r\n\r\n/**\r\n * Add a relationship between two entities.\r\n * Distance is ALWAYS computed from Euclidean distance between coordinates.\r\n */\r\nexport function addRelationship(\r\n  graph: Graph,\r\n  kind: string,\r\n  srcId: string,\r\n  dstId: string,\r\n  strength: number = 0.5\r\n): void {\r\n  graph.addRelationship(kind, srcId, dstId, strength);\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "strength", "type": "number", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::archiveRelationship", "name": "archiveRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "/**\r\n * Archive a relationship by marking it as historical.\r\n */\r\nexport function archiveRelationship(\r\n  graph: Graph,\r\n  src: string,\r\n  dst: string,\r\n  kind: string,\r\n  reason?: string\r\n): void {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === src &&\r\n    r.dst === dst &&\r\n    r.kind === kind &&\r\n    r.status !== 'historical'\r\n  );\r\n\r\n  if (rel) {\r\n    const age = graph.tick - (rel.createdAt ?? 0);\r\n    rel.status = 'historical';\r\n    rel.archivedAt = graph.tick;\r\n\r\n    // Record archival for context-based event generation\r\n    graph.mutationTracker?.recordRelationshipArchived({\r\n      srcId: src,\r\n      dstId: dst,\r\n      kind,\r\n      age,\r\n      reason,\r\n    });\r\n  }\r\n\r\n  const srcEntity = graph.getEntity(src);\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  const dstEntity = graph.getEntity(dst);\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "src", "type": "string", "optional": false}, {"name": "dst", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "reason", "type": "string", "optional": true}], "returnType": "void", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::modifyRelationshipStrength", "name": "modifyRelationshipStrength", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "/**\r\n * Modify relationship strength by delta\r\n */\r\nexport function modifyRelationshipStrength(\r\n  graph: Graph,\r\n  srcId: string,\r\n  dstId: string,\r\n  kind: string,\r\n  delta: number\r\n): boolean {\r\n  const rel = graph.getRelationships().find(r =>\r\n    r.src === srcId && r.dst === dstId && r.kind === kind\r\n  );\r\n\r\n  if (!rel) return false;\r\n\r\n  const currentStrength = rel.strength ?? 0.5;\r\n  rel.strength = Math.max(0.0, Math.min(1.0, currentStrength + delta));\r\n\r\n  const srcEntity = graph.getEntity(srcId);\r\n  const dstEntity = graph.getEntity(dstId);\r\n\r\n  if (srcEntity) {\r\n    srcEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  if (dstEntity) {\r\n    dstEntity.updatedAt = graph.tick;\r\n  }\r\n\r\n  return true;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "srcId", "type": "string", "optional": false}, {"name": "dstId", "type": "string", "optional": false}, {"name": "kind", "type": "string", "optional": false}, {"name": "delta", "type": "number", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}, {"id": "apps/lore-weave/lib/graph/relationshipMutation.ts::canFormRelationship", "name": "canFormRelationship", "kind": "function", "filePath": "apps/lore-weave/lib/graph/relationshipMutation.ts", "sourceCode": "// ===========================\r\n// RELATIONSHIP COOLDOWN\r\n// ===========================\r\n\r\n/**\r\n * Check if an entity can form a new relationship based on cooldown.\r\n */\r\nexport function canFormRelationship(\r\n  graph: Graph,\r\n  entityId: string,\r\n  relationshipType: string,\r\n  cooldownTicks: number\r\n): boolean {\r\n  const entityCooldowns = graph.relationshipCooldowns.get(entityId);\r\n  if (!entityCooldowns) return true;\r\n\r\n  const lastFormationTick = entityCooldowns.get(relationshipType);\r\n  if (lastFormationTick === undefined) return true;\r\n\r\n  return (graph.tick - lastFormationTick) >= cooldownTicks;\r\n}", "parameters": [{"name": "graph", "type": "Graph", "optional": false}, {"name": "entityId", "type": "string", "optional": false}, {"name": "relationshipType", "type": "string", "optional": false}, {"name": "cooldownTicks", "type": "number", "optional": false}], "returnType": "boolean", "jsxLeafElements": [], "hookCalls": [], "customHookCalls": [], "imports": [{"source": "../engine/types", "specifiers": ["Graph"], "category": "internal"}]}]