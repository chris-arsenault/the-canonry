[{"id": "packages/shared-components/src/index.js::TagSelector", "name": "TagSelector", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export default function TagSelector({\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [highlightedIndex, setHighlightedIndex] = useState(0);\n  const [hoveredInvalidTag, setHoveredInvalidTag] = useState(null);\n  const hoverTimeoutRef = useRef(null);\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  const tagLookup = useMemo(() => {\n    const lookup = {};\n    tagRegistry.forEach((tagDef) => {\n      lookup[tagDef.tag] = tagDef;\n    });\n    return lookup;\n  }, [tagRegistry]);\n\n  const groupedTags = useMemo(() => {\n    const groups = {};\n    const filtered = tagRegistry.filter((tagDef) => {\n      const normalizedQuery = searchQuery.toLowerCase();\n      const matchesSearch =\n        !searchQuery ||\n        tagDef.tag.toLowerCase().includes(normalizedQuery) ||\n        tagDef.description?.toLowerCase().includes(normalizedQuery);\n      return matchesSearch && !value.includes(tagDef.tag);\n    });\n\n    filtered.forEach((tagDef) => {\n      if (!groups[tagDef.category]) {\n        groups[tagDef.category] = [];\n      }\n      groups[tagDef.category].push(tagDef);\n    });\n\n    return groups;\n  }, [searchQuery, tagRegistry, value]);\n\n  const canCreateTag = useMemo(() => {\n    if (!searchQuery.trim()) return false;\n    const normalized = searchQuery.trim().toLowerCase().replace(/[^a-z0-9-_]/g, '');\n    if (!normalized) return false;\n    if (tagLookup[normalized]) return false;\n    if (value.includes(normalized)) return false;\n    return normalized;\n  }, [searchQuery, tagLookup, value]);\n\n  const flatOptions = useMemo(() => {\n    const result = [];\n    Object.entries(groupedTags).forEach(([_category, tags]) => {\n      tags.forEach((tagDef) => result.push({ type: 'existing', ...tagDef }));\n    });\n    if (canCreateTag) {\n      result.push({ type: 'create', tag: canCreateTag });\n    }\n    return result;\n  }, [groupedTags, canCreateTag]);\n\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (containerRef.current && !containerRef.current.contains(event.target)) {\n        setIsOpen(false);\n        setHoveredInvalidTag(null);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const handleKeyDown = (event) => {\n    if (!isOpen) {\n      if (event.key === 'Enter' || event.key === 'ArrowDown') {\n        event.preventDefault();\n        setIsOpen(true);\n      }\n      return;\n    }\n\n    switch (event.key) {\n      case 'ArrowDown':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.min(index + 1, flatOptions.length - 1));\n        break;\n      case 'ArrowUp':\n        event.preventDefault();\n        setHighlightedIndex((index) => Math.max(index - 1, 0));\n        break;\n      case 'Enter':\n        event.preventDefault();\n        if (!flatOptions[highlightedIndex]) return;\n        if (flatOptions[highlightedIndex].type === 'create') {\n          handleCreateAndSelect(flatOptions[highlightedIndex].tag);\n        } else {\n          handleSelectTag(flatOptions[highlightedIndex].tag);\n        }\n        break;\n      case 'Escape':\n        event.preventDefault();\n        setIsOpen(false);\n        break;\n      case 'Backspace':\n        if (searchQuery === '' && value.length > 0) {\n          handleRemoveTag(value[value.length - 1]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleSelectTag = (tag) => {\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemoveTag = (tag) => {\n    onChange(value.filter((item) => item !== tag));\n  };\n\n  const handleCreateAndSelect = (tag) => {\n    if (onAddToRegistry) {\n      onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n    }\n\n    if (singleSelect) {\n      onChange([tag]);\n      setIsOpen(false);\n    } else if (!value.includes(tag)) {\n      onChange([...value, tag]);\n    }\n\n    setSearchQuery('');\n    inputRef.current?.focus();\n  };\n\n  const handleInvalidTagMouseEnter = (tag) => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n    setHoveredInvalidTag(tag);\n  };\n\n  const handleInvalidTagMouseLeave = () => {\n    hoverTimeoutRef.current = setTimeout(() => {\n      setHoveredInvalidTag(null);\n    }, 150);\n  };\n\n  const handlePopupMouseEnter = () => {\n    if (hoverTimeoutRef.current) {\n      clearTimeout(hoverTimeoutRef.current);\n      hoverTimeoutRef.current = null;\n    }\n  };\n\n  const renderRarityDots = (rarity) => {\n    const count = RARITY_DOTS[rarity] || RARITY_DOTS.common;\n    return (\n      <span className=\"tag-selector-rarity-dots\">\n        {Array.from({ length: count }).map((_, index) => (\n          <span key={index} className={`tag-selector-rarity-dot ${getRarityClass(rarity)}`} />\n        ))}\n      </span>\n    );\n  };\n\n  return (\n    <div ref={containerRef} className=\"tag-selector\">\n      <div\n        className={`tag-selector-input-wrapper ${isOpen ? 'tag-selector-input-wrapper-open' : 'tag-selector-input-wrapper-closed'}`}\n        onClick={() => {\n          setIsOpen(true);\n          inputRef.current?.focus();\n        }}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(event) => {\n          if (event.key === 'Enter' || event.key === ' ') {\n            event.currentTarget.click();\n          }\n        }}\n      >\n        {value.map((tag) => {\n          const tagMeta = tagLookup[tag];\n          const isInvalid = !tagMeta;\n          const categoryClass = isInvalid ? 'tag-selector-category-invalid' : getCategoryClass(tagMeta.category);\n\n          return (\n            <span\n              key={tag}\n              className={`tag-selector-chip ${categoryClass}`}\n              title={isInvalid ? 'Tag not in registry - hover to add' : tagMeta?.description}\n              onMouseEnter={() => isInvalid && onAddToRegistry && handleInvalidTagMouseEnter(tag)}\n              onMouseLeave={() => isInvalid && handleInvalidTagMouseLeave()}\n            >\n              {isInvalid && <span className=\"tag-selector-invalid-warning\">\u26a0</span>}\n              {tag}\n              {tagMeta?.isAxis && <span title=\"Semantic plane axis label\" className=\"tag-selector-axis-indicator\">\u2194</span>}\n              {tagMeta && renderRarityDots(tagMeta.rarity)}\n              <button\n                type=\"button\"\n                className=\"tag-selector-remove-button\"\n                onClick={(event) => {\n                  event.stopPropagation();\n                  handleRemoveTag(tag);\n                }}\n              >\n                \u00d7\n              </button>\n              {isInvalid && hoveredInvalidTag === tag && onAddToRegistry && (\n                <div\n                  className=\"tag-selector-invalid-popup\"\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    onAddToRegistry({ tag, category: 'trait', rarity: 'common', description: '' });\n                    setHoveredInvalidTag(null);\n                  }}\n                  onMouseEnter={handlePopupMouseEnter}\n                  onMouseLeave={() => setHoveredInvalidTag(null)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(event) => {\n                    if (event.key === 'Enter' || event.key === ' ') {\n                      event.currentTarget.click();\n                    }\n                  }}\n                >\n                  + Add to registry\n                </div>\n              )}\n            </span>\n          );\n        })}\n\n        <input\n          ref={inputRef}\n          type=\"text\"\n          className=\"tag-selector-search-input\"\n          value={searchQuery}\n          onChange={(event) => {\n            setSearchQuery(event.target.value);\n            setHighlightedIndex(0);\n          }}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsOpen(true)}\n          placeholder={value.length === 0 ? placeholder : ''}\n        />\n      </div>\n\n      {matchAllEnabled && value.length > 1 && (\n        <div className=\"tag-selector-match-all\">\n          <label className=\"tag-selector-match-all-label\">\n            <input\n              type=\"checkbox\"\n              className=\"tag-selector-match-all-checkbox\"\n              checked={matchAll}\n              onChange={(event) => onMatchAllChange?.(event.target.checked)}\n            />\n            Match all tags (AND)\n          </label>\n          <span className=\"tag-selector-match-all-hint\">\n            {matchAll ? 'Entity must have all tags' : 'Entity must have any tag'}\n          </span>\n        </div>\n      )}\n\n      {isOpen && (\n        <div className=\"tag-selector-dropdown\">\n          {canCreateTag && onAddToRegistry && (\n            <div\n              className={`tag-selector-create-option ${highlightedIndex === flatOptions.length - 1 ? 'tag-selector-create-option-highlighted' : ''}`}\n              onClick={() => handleCreateAndSelect(canCreateTag)}\n              onMouseEnter={() => setHighlightedIndex(flatOptions.length - 1)}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(event) => {\n                if (event.key === 'Enter' || event.key === ' ') {\n                  event.currentTarget.click();\n                }\n              }}\n            >\n// ... (truncated)", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  tagRegistry = [],\n  onAddToRegistry,\n  placeholder = 'Select tags...',\n  matchAllEnabled = false,\n  matchAll = false,\n  onMatchAllChange,\n  singleSelect = false,\n}", "type": "{ value?: any[]; onChange: any; tagRegistry?: any[]; onAddToRegistry: any; placeholder?: string; matchAllEnabled?: boolean; matchAll?: boolean; onMatchAllChange: any; singleSelect?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 4}, {"name": "useRef", "count": 3}, {"name": "useMemo", "count": 4}, {"name": "useEffect", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::NumberInput", "name": "NumberInput", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "input", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 4}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::LocalTextArea", "name": "LocalTextArea", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function LocalTextArea({\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}) {\n  const externalValue = value || '';\n  const [localValue, setLocalValue] = useState(externalValue);\n  // Track focus in state so render can safely choose between local draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalValue);\n    setIsFocused(true);\n  }, [externalValue]);\n\n  // Call onChange on blur if value changed\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n    if (localValue !== externalValue) {\n      onChange(localValue);\n    }\n  }, [externalValue, localValue, onChange]);\n\n  return (\n    <textarea\n      value={isFocused ? localValue : externalValue}\n      onChange={(e) => setLocalValue(e.target.value)}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\n      placeholder={placeholder}\n      rows={rows}\n      {...rest}\n    />\n  );\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}", "type": "{ [x: string]: any; value: any; onChange: any; className?: string; placeholder: any; rows: any; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "textarea", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::CoverageMatrix", "name": "CoverageMatrix", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export default function CoverageMatrix({\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}) {\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n  const [activeFilter, setActiveFilter] = useState(null);\r\n\r\n  // Normalize columns to { id, label } format\r\n  const normalizedColumns = useMemo(() => {\r\n    return columns.map((col) =>\r\n      typeof col === 'string' ? { id: col, label: col } : col\r\n    );\r\n  }, [columns]);\r\n\r\n  // Filter rows by search\r\n  const filteredRows = useMemo(() => {\r\n    let result = rows;\r\n\r\n    if (searchQuery) {\r\n      const query = searchQuery.toLowerCase();\r\n      result = result.filter(\r\n        (row) =>\r\n          row.id.toLowerCase().includes(query) ||\r\n          row.label.toLowerCase().includes(query) ||\r\n          (row.groupLabel && row.groupLabel.toLowerCase().includes(query))\r\n      );\r\n    }\r\n\r\n    if (activeFilter && filterOptions.length > 0) {\r\n      const filterDef = filterOptions.find((f) => f.id === activeFilter);\r\n      if (filterDef?.filter) {\r\n        result = result.filter(filterDef.filter);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }, [rows, searchQuery, activeFilter, filterOptions]);\r\n\r\n  // Group rows if groupByField is specified\r\n  const groupedRows = useMemo(() => {\r\n    if (!groupByField) {\r\n      return { _ungrouped: { label: '', rows: filteredRows } };\r\n    }\r\n\r\n    const groups = {};\r\n    filteredRows.forEach((row) => {\r\n      const groupId = row[groupByField] || '_ungrouped';\r\n      const groupLabel = row.groupLabel || groupId;\r\n      if (!groups[groupId]) {\r\n        groups[groupId] = { label: groupLabel, rows: [] };\r\n      }\r\n      groups[groupId].rows.push(row);\r\n    });\r\n    return groups;\r\n  }, [filteredRows, groupByField]);\r\n\r\n  // Default cell display function\r\n  const defaultGetCellDisplay = (value) => {\r\n    switch (value) {\r\n      case 'primary':\r\n        return { icon: '\u2713', className: 'primary', title: 'Primary' };\r\n      case 'secondary':\r\n        return { icon: '\u25cb', className: 'secondary', title: 'Secondary' };\r\n      case 'both':\r\n        return { icon: '\u25c9', className: 'both', title: 'Both' };\r\n      case 'none':\r\n      default:\r\n        return { icon: '-', className: 'none', title: 'None' };\r\n    }\r\n  };\r\n\r\n  const displayFn = getCellDisplay || defaultGetCellDisplay;\r\n\r\n  return (\r\n    <div className=\"coverage-matrix\">\r\n      {/* Header */}\r\n      <div className=\"cm-header\">\r\n        <h2 className=\"cm-title\">{title}</h2>\r\n        {subtitle && <p className=\"cm-subtitle\">{subtitle}</p>}\r\n      </div>\r\n\r\n      {/* Stats Bar */}\r\n      {stats.length > 0 && (\r\n        <div className=\"cm-stats\">\r\n          {stats.map((stat, idx) => (\r\n            <div key={idx} className={`cm-stat ${stat.variant || ''}`}>\r\n              <span className=\"cm-stat-value\">{stat.value}</span>\r\n              <span className=\"cm-stat-label\">{stat.label}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Toolbar */}\r\n      <div className=\"cm-toolbar\">\r\n        <input\r\n          type=\"text\"\r\n          className=\"cm-search\"\r\n          placeholder={searchPlaceholder}\r\n          value={searchQuery}\r\n          onChange={(e) => setSearchQuery(e.target.value)}\r\n        />\r\n        {filterOptions.length > 0 && (\r\n          <div className=\"cm-filters\">\r\n            {filterOptions.map((filter) => (\r\n              <button\r\n                key={filter.id}\r\n                className={`cm-filter-btn ${activeFilter === filter.id ? 'active' : ''}`}\r\n                onClick={() =>\r\n                  setActiveFilter(activeFilter === filter.id ? null : filter.id)\r\n                }\r\n              >\r\n                {filter.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Matrix Grid */}\r\n      <div className=\"cm-container\">\r\n        {(normalizedColumns.length === 0 || rows.length === 0) && (\r\n          <div className=\"cm-empty\">{emptyMessage}</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length === 0 && (\r\n          <div className=\"cm-empty\">No items match the current filters.</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length > 0 && (\r\n          <table className=\"cm-table\">\r\n            <thead>\r\n              <tr>\r\n                <th className=\"cm-group-col\">Group</th>\r\n                <th className=\"cm-label-col\">Name</th>\r\n                <th className=\"cm-status-col\">Status</th>\r\n                {normalizedColumns.map((col) => (\r\n                  <th\r\n                    key={col.id}\r\n                    className={`cm-data-col ${columnHeaderClass?.(col.id) || ''}`}\r\n                    title={col.label}\r\n                  >\r\n                    {col.label}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {Object.entries(groupedRows).map(([groupId, { label: groupLabel, rows: groupRows }]) =>\r\n                groupRows.map((row, idx) => (\r\n                  <MatrixRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    idx={idx}\r\n                    groupId={groupId}\r\n                    groupLabel={groupLabel}\r\n                    columns={normalizedColumns}\r\n                    getCellValue={getCellValue}\r\n                    displayFn={displayFn}\r\n                    onRowClick={onRowClick}\r\n                    onCellClick={onCellClick}\r\n                  />\r\n                ))\r\n              )}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      {legend.length > 0 && (\r\n        <div className=\"cm-legend\">\r\n          {legend.map((item, idx) => (\r\n            <span key={idx} className=\"cm-legend-item\">\r\n              <span className={`cm-cell-icon sample ${item.className || ''}`}>\r\n                {item.icon}\r\n              </span>\r\n              {item.label}\r\n            </span>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}", "type": "{ rows?: any[]; columns?: any[]; getCellValue: any; getCellDisplay: any; onRowClick: any; onCellClick: any; title?: string; subtitle?: string; stats?: any[]; legend?: any[]; searchPlaceholder?: string; groupByField?: string; columnHeaderClass: any; emptyMessage?: string; filterOptions?: any[]; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h2", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "table", "children": [{"tag": "thead", "children": [{"tag": "tr", "children": [{"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "tbody", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 3}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::IconButton", "name": "IconButton", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::AddCard", "name": "AddCard", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {string} props.label - Button label (default \"Add Item\")\n * @param {string} props.className - Optional CSS class name\n */\nexport function AddCard({ onClick, label = 'Add Item', className = '' }) {\n  return (\n    <div\n      className={`add-card ${className}`.trim()}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <span className=\"add-card-icon\">+</span>\n      <span>{label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ExpandableCard", "name": "ExpandableCard", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::FormGroup", "name": "FormGroup", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::FormRow", "name": "FormRow", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\n * FormRow - Horizontal layout for multiple form groups\n */\nexport function FormRow({ children, className = '' }) {\n  return (\n    <div className={`form-row ${className}`.trim()}>\n      {children}\n    </div>\n  );\n}", "parameters": [{"name": "{ children, className = '' }", "type": "{ children: any; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ChronicleSeedViewer", "name": "ChronicleSeedViewer", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * @typedef {Object} ChronicleRoleAssignment\r\n * @property {string} role\r\n * @property {string} entityId\r\n * @property {string} entityName\r\n * @property {string} entityKind\r\n * @property {boolean} isPrimary\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleTemporalContext\r\n * @property {{ id: string, name: string, summary?: string }} [focalEra]\r\n * @property {[number, number]} [chronicleTickRange]\r\n * @property {string} [temporalScope]\r\n * @property {boolean} [isMultiEra]\r\n * @property {string[]} [touchedEraIds]\r\n * @property {string} [temporalDescription]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleSeedData\r\n * @property {string} narrativeStyleId\r\n * @property {string} [narrativeStyleName]\r\n * @property {string} [entrypointId]\r\n * @property {string} [entrypointName]\r\n * @property {string} [narrativeDirection]\r\n * @property {ChronicleRoleAssignment[]} roleAssignments\r\n * @property {string[]} selectedEventIds\r\n * @property {string[]} selectedRelationshipIds\r\n * @property {ChronicleTemporalContext} [temporalContext]\r\n */\r\n\r\n/**\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames] - Resolved display names for event IDs\r\n * @param {Map<string, string>} [props.relationshipLabels] - Resolved display labels for relationship IDs\r\n */\r\nexport default function ChronicleSeedViewer({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}) {\r\n  const primaryRoles = seed.roleAssignments.filter((r) => r.isPrimary);\r\n  const supportingRoles = seed.roleAssignments.filter((r) => !r.isPrimary);\r\n\r\n  return (\r\n    <div className=\"csv-container\">\r\n      {/* Style & Entry Point */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Generation Settings</div>\r\n        <div className=\"csv-field\">\r\n          <span className=\"csv-field-label\">Style:</span>\r\n          <span className=\"csv-field-value\">{seed.narrativeStyleName || seed.narrativeStyleId}</span>\r\n        </div>\r\n        {seed.entrypointId && (\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Entry Point:</span>\r\n            <span className=\"csv-field-value\">{seed.entrypointName || seed.entrypointId}</span>\r\n          </div>\r\n        )}\r\n        {seed.narrativeDirection && (\r\n          <div className=\"csv-narrative-direction-wrapper\">\r\n            <div className=\"csv-narrative-direction-label\">\r\n              Narrative Direction:\r\n            </div>\r\n            <div\r\n              className=\"csv-narrative-direction-body\"\r\n              title=\"Click to copy\"\r\n              onClick={() => void navigator.clipboard.writeText(seed.narrativeDirection)}\r\n              role=\"button\"\r\n              tabIndex={0}\r\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n            >\r\n              {seed.narrativeDirection}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Role Assignments */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Cast ({seed.roleAssignments.length} entities)</div>\r\n        {seed.roleAssignments.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No roles assigned</div>\r\n        ) : (\r\n          <div className=\"csv-role-list\">\r\n            {primaryRoles.map((role, i) => (\r\n              <div key={`primary-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-primary-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n            {supportingRoles.map((role, i) => (\r\n              <div key={`supporting-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-supporting-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Temporal Context (optional, used by chronicler) */}\r\n      {seed.temporalContext && (\r\n        <div className=\"csv-section\">\r\n          <div className=\"csv-section-title\">Temporal Context</div>\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Focal Era:</span>\r\n            <span className=\"csv-field-value\">\r\n              {seed.temporalContext.focalEra?.name || \"Unknown\"}\r\n            </span>\r\n          </div>\r\n          {seed.temporalContext.focalEra?.summary && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Era Summary:</span>\r\n              <span className=\"csv-field-value\">{seed.temporalContext.focalEra.summary}</span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.temporalDescription && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Scope:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.temporalDescription}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.chronicleTickRange && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Ticks:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.chronicleTickRange[0]}&ndash;\r\n                {seed.temporalContext.chronicleTickRange[1]}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {typeof seed.temporalContext.isMultiEra === \"boolean\" && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Multi-era:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.isMultiEra ? \"Yes\" : \"No\"}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.touchedEraIds?.length ? (\r\n            <div>\r\n              <div className=\"csv-field-label-spaced\">Touched Eras:</div>\r\n              <div className=\"csv-id-list\">\r\n                {seed.temporalContext.touchedEraIds.map((id) => (\r\n                  <span key={id} className=\"csv-id-tag\">\r\n                    {id}\r\n                  </span>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n      )}\r\n\r\n      {/* Selected Events */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Events ({seed.selectedEventIds.length})</div>\r\n        {seed.selectedEventIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No events selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedEventIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {eventNames?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Selected Relationships */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Relationships ({seed.selectedRelationshipIds.length})</div>\r\n        {seed.selectedRelationshipIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No relationships selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedRelationshipIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {relationshipLabels?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::SeedModal", "name": "SeedModal", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * Modal wrapper for use in chronicler wiki pages\r\n *\r\n * @param {Object} props\r\n * @param {boolean} props.isOpen\r\n * @param {Function} props.onClose\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {string} [props.title]\r\n */\r\nexport function SeedModal({\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}) {\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-modal-overlay\"\r\n      onClick={onClose}\r\n      role=\"button\"\r\n      tabIndex={0}\r\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClose(e); }}\r\n    >\r\n      <div\r\n        className=\"csv-modal-dialog\"\r\n        onClick={(e) => e.stopPropagation()}\r\n        role=\"button\"\r\n        tabIndex={0}\r\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n      >\r\n        {/* Header */}\r\n        <div className=\"csv-modal-header\">\r\n          <h3 className=\"csv-modal-title\">{title}</h3>\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-close-button\"\r\n          >\r\n            &times;\r\n          </button>\r\n        </div>\r\n\r\n        {/* Content */}\r\n        <div className=\"csv-modal-body\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n\r\n        {/* Footer */}\r\n        <div className=\"csv-modal-footer\">\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-footer-button\"\r\n          >\r\n            Close\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}", "type": "{ isOpen: boolean; onClose: Function; seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; title?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::ExpandableSeedSection", "name": "ExpandableSeedSection", "kind": "component", "filePath": "packages/shared-components/src/index.js", "sourceCode": "/**\r\n * Expandable wrapper for use in validation UI\r\n *\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {boolean} [props.defaultExpanded]\r\n */\r\nexport function ExpandableSeedSection({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}) {\r\n  const [expanded, setExpanded] = useState(defaultExpanded);\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-expandable-container\"\r\n    >\r\n      <button\r\n        onClick={() => setExpanded(!expanded)}\r\n        className=\"csv-expandable-button\"\r\n      >\r\n        <span>Generation Context</span>\r\n        <span className=\"csv-expandable-meta\">\r\n          {expanded ? \"\\u25BC\" : \"\\u25B6\"} {seed.roleAssignments.length} roles, {seed.selectedEventIds.length}{\" \"}\r\n          events\r\n        </span>\r\n      </button>\r\n      {expanded && (\r\n        <div className=\"csv-expandable-content\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; defaultExpanded?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/index.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "packages/shared-components/src/index.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/AddCard.jsx::AddCard", "name": "AddCard", "kind": "component", "filePath": "packages/shared-components/src/components/AddCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {string} props.label - Button label (default \"Add Item\")\n * @param {string} props.className - Optional CSS class name\n */\nexport function AddCard({ onClick, label = 'Add Item', className = '' }) {\n  return (\n    <div\n      className={`add-card ${className}`.trim()}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <span className=\"add-card-icon\">+</span>\n      <span>{label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/AddItemButton.jsx::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "packages/shared-components/src/components/AddItemButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/CategorySection.jsx::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "packages/shared-components/src/components/CategorySection.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ChipSelect.jsx::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "packages/shared-components/src/components/ChipSelect.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::ExpandableSeedSection", "name": "ExpandableSeedSection", "kind": "component", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * Expandable wrapper for use in validation UI\r\n *\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {boolean} [props.defaultExpanded]\r\n */\r\nexport function ExpandableSeedSection({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}) {\r\n  const [expanded, setExpanded] = useState(defaultExpanded);\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-expandable-container\"\r\n    >\r\n      <button\r\n        onClick={() => setExpanded(!expanded)}\r\n        className=\"csv-expandable-button\"\r\n      >\r\n        <span>Generation Context</span>\r\n        <span className=\"csv-expandable-meta\">\r\n          {expanded ? \"\\u25BC\" : \"\\u25B6\"} {seed.roleAssignments.length} roles, {seed.selectedEventIds.length}{\" \"}\r\n          events\r\n        </span>\r\n      </button>\r\n      {expanded && (\r\n        <div className=\"csv-expandable-content\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; defaultExpanded?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleSeedViewer.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ChronicleSeedViewer.jsx::SeedModal", "name": "SeedModal", "kind": "component", "filePath": "packages/shared-components/src/components/ChronicleSeedViewer.jsx", "sourceCode": "/**\r\n * Modal wrapper for use in chronicler wiki pages\r\n *\r\n * @param {Object} props\r\n * @param {boolean} props.isOpen\r\n * @param {Function} props.onClose\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {string} [props.title]\r\n */\r\nexport function SeedModal({\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}) {\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-modal-overlay\"\r\n      onClick={onClose}\r\n      role=\"button\"\r\n      tabIndex={0}\r\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClose(e); }}\r\n    >\r\n      <div\r\n        className=\"csv-modal-dialog\"\r\n        onClick={(e) => e.stopPropagation()}\r\n        role=\"button\"\r\n        tabIndex={0}\r\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n      >\r\n        {/* Header */}\r\n        <div className=\"csv-modal-header\">\r\n          <h3 className=\"csv-modal-title\">{title}</h3>\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-close-button\"\r\n          >\r\n            &times;\r\n          </button>\r\n        </div>\r\n\r\n        {/* Content */}\r\n        <div className=\"csv-modal-body\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n\r\n        {/* Footer */}\r\n        <div className=\"csv-modal-footer\">\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-footer-button\"\r\n          >\r\n            Close\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}", "type": "{ isOpen: boolean; onClose: Function; seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; title?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}, {"source": "./ChronicleSeedViewer.css", "specifiers": [], "category": "internal"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/EmptyState.jsx::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "packages/shared-components/src/components/EmptyState.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/EnableToggle.jsx::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "packages/shared-components/src/components/EnableToggle.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/EraBadges.jsx::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "packages/shared-components/src/components/EraBadges.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ExpandableCard.jsx::ExpandableCard", "name": "ExpandableCard", "kind": "component", "filePath": "packages/shared-components/src/components/ExpandableCard.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.expanded - Whether the card is expanded\n * @param {Function} props.onToggle - Called when header is clicked. If toggleId is provided, calls onToggle(toggleId).\n * @param {string} [props.toggleId] - Optional ID passed back to onToggle, enabling stable callbacks in list renders\n * @param {React.ReactNode} props.title - Main title content\n * @param {React.ReactNode} [props.subtitle] - Optional subtitle/ID display\n * @param {React.ReactNode} [props.actions] - Right-side header content (badges, summary)\n * @param {React.ReactNode} props.children - Body content (shown when expanded)\n * @param {string} [props.className] - Additional class for the container\n */\nexport function ExpandableCard({\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}) {\n  const handleToggle = useCallback(() => {\n    if (toggleId !== undefined) {\n      onToggle(toggleId);\n    } else {\n      onToggle();\n    }\n  }, [onToggle, toggleId]);\n\n  return (\n    <div className={`expandable-card ${className}`.trim()}>\n      <div className=\"expandable-card-header\" onClick={handleToggle} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleToggle(); }} >\n        <div className=\"expandable-card-left\">\n          <span\n            className={`expand-icon ${expanded ? 'expand-icon-expanded' : 'expand-icon-collapsed'}`}\n          >\n            \u25b6\n          </span>\n          <div className=\"expandable-card-title\">\n            <span className=\"expandable-card-name\">{title}</span>\n            {subtitle && <span className=\"expandable-card-id\">{subtitle}</span>}\n          </div>\n        </div>\n        {actions && <div className=\"expandable-card-actions\">{actions}</div>}\n      </div>\n      {expanded && (\n        <div className=\"expandable-card-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  expanded,\n  onToggle,\n  toggleId,\n  title,\n  subtitle,\n  actions,\n  children,\n  className = '',\n}", "type": "{ expanded: boolean; onToggle: Function; toggleId?: string; title: React.ReactNode; subtitle?: React.ReactNode; actions?: React.ReactNode; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useCallback", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/FormGroup.jsx::FormGroup", "name": "FormGroup", "kind": "component", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.label] - Label text\n * @param {string} [props.htmlFor] - For attribute linking label to input\n * @param {string} [props.hint] - Help text below the input\n * @param {React.ReactNode} props.children - Form control (input, select, etc.)\n * @param {boolean} [props.wide] - If true, spans full width\n * @param {string} [props.className] - Additional class\n */\nexport function FormGroup({\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}) {\n  return (\n    <div className={`form-group ${wide ? 'form-group-wide' : ''} ${className}`.trim()}>\n      {label && (\n        <label className=\"label\" htmlFor={htmlFor}>\n          {label}\n        </label>\n      )}\n      {children}\n      {hint && <div className=\"hint\">{hint}</div>}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  label,\n  htmlFor,\n  hint,\n  children,\n  wide,\n  className = '',\n}", "type": "{ label?: string; htmlFor?: string; hint?: string; children: React.ReactNode; wide?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/FormGroup.jsx::FormRow", "name": "FormRow", "kind": "component", "filePath": "packages/shared-components/src/components/FormGroup.jsx", "sourceCode": "/**\n * FormRow - Horizontal layout for multiple form groups\n */\nexport function FormRow({ children, className = '' }) {\n  return (\n    <div className={`form-row ${className}`.trim()}>\n      {children}\n    </div>\n  );\n}", "parameters": [{"name": "{ children, className = '' }", "type": "{ children: any; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/IconButton.jsx::IconButton", "name": "IconButton", "kind": "component", "filePath": "packages/shared-components/src/components/IconButton.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/InfoBox.jsx::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "packages/shared-components/src/components/InfoBox.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ItemRow.jsx::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "packages/shared-components/src/components/ItemRow.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/LevelSelector.jsx::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "packages/shared-components/src/components/LevelSelector.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/LocalTextArea.jsx::LocalTextArea", "name": "LocalTextArea", "kind": "component", "filePath": "packages/shared-components/src/components/LocalTextArea.jsx", "sourceCode": "export function LocalTextArea({\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}) {\n  const externalValue = value || '';\n  const [localValue, setLocalValue] = useState(externalValue);\n  // Track focus in state so render can safely choose between local draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalValue);\n    setIsFocused(true);\n  }, [externalValue]);\n\n  // Call onChange on blur if value changed\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n    if (localValue !== externalValue) {\n      onChange(localValue);\n    }\n  }, [externalValue, localValue, onChange]);\n\n  return (\n    <textarea\n      value={isFocused ? localValue : externalValue}\n      onChange={(e) => setLocalValue(e.target.value)}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\n      placeholder={placeholder}\n      rows={rows}\n      {...rest}\n    />\n  );\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}", "type": "{ [x: string]: any; value: any; onChange: any; className?: string; placeholder: any; rows: any; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "textarea", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 2}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ModalShell.jsx::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "packages/shared-components/src/components/ModalShell.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "imports": [{"source": "react", "specifiers": ["React", "useRef", "useEffect", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/NumberInput.jsx::NumberInput", "name": "NumberInput", "kind": "component", "filePath": "packages/shared-components/src/components/NumberInput.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "input", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 4}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useCallback"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/PressureChangesEditor.jsx::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "packages/shared-components/src/components/PressureChangesEditor.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ReferenceDropdown.jsx::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/ReferenceDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect", "useId"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/SearchableDropdown.jsx::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/SearchableDropdown.jsx", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [{"source": "react", "specifiers": ["React", "useState", "useMemo", "useRef", "useEffect"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/SectionHeader.jsx::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "packages/shared-components/src/components/SectionHeader.jsx", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/ValidationBadge.jsx::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "packages/shared-components/src/components/ValidationBadge.jsx", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/DetailUsageBadges.jsx", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/badges/index.js::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/index.js", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/badges/index.js::DetailUsageBadges", "name": "DetailUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/index.js", "sourceCode": "/**\n * DetailUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with arrays of referencing items\n *   e.g., { generators: ['gen1', 'gen2'], systems: ['sys1'] }\n * @param {boolean} props.showOrphan - If true, show \"Not used\" when no usage (default: true)\n */\nexport function DetailUsageBadges({ usage = {}, showOrphan = true }) {\n  const badges = [];\n\n  for (const [type, config] of Object.entries(BADGE_CONFIG)) {\n    const items = usage[type];\n    if (items?.length > 0) {\n      const count = items.length;\n      const label = type === 'eras' && count !== 1 ? config.labelPlural : config.label;\n      badges.push(\n        <span\n          key={type}\n          className={`detail-badge ${config.className}`}\n          title={`${config.tooltip}: ${items.join(', ')}`}\n        >\n          {count} {label}\n        </span>\n      );\n    }\n  }\n\n  if (badges.length === 0) {\n    if (showOrphan) {\n      return <span className=\"detail-badge detail-badge-orphan\">Not used</span>;\n    }\n    return null;\n  }\n\n  return <div className=\"detail-badge-container\">{badges}</div>;\n}", "parameters": [{"name": "{ usage = {}, showOrphan = true }", "type": "{ usage: any; showOrphan: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx::ToolUsageBadges", "name": "ToolUsageBadges", "kind": "component", "filePath": "packages/shared-components/src/components/badges/ToolUsageBadges.jsx", "sourceCode": "/**\n * ToolUsageBadges component\n *\n * @param {Object} props\n * @param {Object} props.usage - Object with usage counts by tool\n *   e.g., { nameforge: 3, coherence: 1 }\n * @param {boolean} props.compact - If true, show only icons without labels\n * @param {boolean} props.showZero - If true, show badges even when count is 0\n */\nexport function ToolUsageBadges({ usage = {}, compact = false, showZero = false }) {\n  const badges = Object.entries(usage)\n    .filter(([_type, count]) => showZero || count > 0)\n    .filter(([type]) => BADGE_CONFIG[type]);\n\n  if (badges.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"tool-badge-container\">\n      {badges.map(([type, count]) => {\n        const config = BADGE_CONFIG[type];\n        return (\n          <span\n            key={type}\n            className={`tool-badge ${config.className}`}\n            title={`${config.tooltip}${count > 1 ? ' (' + count + ' uses)' : ''}`}\n          >\n            <span className=\"tool-badge-icon\">{config.icon}</span>\n            {!compact && <span className=\"tool-badge-label\">{config.label}</span>}\n            {count > 1 && <span className=\"tool-badge-count\">&times;{count}</span>}\n          </span>\n        );\n      })}\n    </div>\n  );\n}", "parameters": [{"name": "{ usage = {}, compact = false, showZero = false }", "type": "{ usage: any; compact: boolean; showZero: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [{"source": "react", "specifiers": ["React"], "category": "framework"}, {"source": "prop-types", "specifiers": ["PropTypes"], "category": "external"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/CoverageMatrix/index.js::CoverageMatrix", "name": "CoverageMatrix", "kind": "component", "filePath": "packages/shared-components/src/components/CoverageMatrix/index.js", "sourceCode": "export default function CoverageMatrix({\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}) {\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n  const [activeFilter, setActiveFilter] = useState(null);\r\n\r\n  // Normalize columns to { id, label } format\r\n  const normalizedColumns = useMemo(() => {\r\n    return columns.map((col) =>\r\n      typeof col === 'string' ? { id: col, label: col } : col\r\n    );\r\n  }, [columns]);\r\n\r\n  // Filter rows by search\r\n  const filteredRows = useMemo(() => {\r\n    let result = rows;\r\n\r\n    if (searchQuery) {\r\n      const query = searchQuery.toLowerCase();\r\n      result = result.filter(\r\n        (row) =>\r\n          row.id.toLowerCase().includes(query) ||\r\n          row.label.toLowerCase().includes(query) ||\r\n          (row.groupLabel && row.groupLabel.toLowerCase().includes(query))\r\n      );\r\n    }\r\n\r\n    if (activeFilter && filterOptions.length > 0) {\r\n      const filterDef = filterOptions.find((f) => f.id === activeFilter);\r\n      if (filterDef?.filter) {\r\n        result = result.filter(filterDef.filter);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }, [rows, searchQuery, activeFilter, filterOptions]);\r\n\r\n  // Group rows if groupByField is specified\r\n  const groupedRows = useMemo(() => {\r\n    if (!groupByField) {\r\n      return { _ungrouped: { label: '', rows: filteredRows } };\r\n    }\r\n\r\n    const groups = {};\r\n    filteredRows.forEach((row) => {\r\n      const groupId = row[groupByField] || '_ungrouped';\r\n      const groupLabel = row.groupLabel || groupId;\r\n      if (!groups[groupId]) {\r\n        groups[groupId] = { label: groupLabel, rows: [] };\r\n      }\r\n      groups[groupId].rows.push(row);\r\n    });\r\n    return groups;\r\n  }, [filteredRows, groupByField]);\r\n\r\n  // Default cell display function\r\n  const defaultGetCellDisplay = (value) => {\r\n    switch (value) {\r\n      case 'primary':\r\n        return { icon: '\u2713', className: 'primary', title: 'Primary' };\r\n      case 'secondary':\r\n        return { icon: '\u25cb', className: 'secondary', title: 'Secondary' };\r\n      case 'both':\r\n        return { icon: '\u25c9', className: 'both', title: 'Both' };\r\n      case 'none':\r\n      default:\r\n        return { icon: '-', className: 'none', title: 'None' };\r\n    }\r\n  };\r\n\r\n  const displayFn = getCellDisplay || defaultGetCellDisplay;\r\n\r\n  return (\r\n    <div className=\"coverage-matrix\">\r\n      {/* Header */}\r\n      <div className=\"cm-header\">\r\n        <h2 className=\"cm-title\">{title}</h2>\r\n        {subtitle && <p className=\"cm-subtitle\">{subtitle}</p>}\r\n      </div>\r\n\r\n      {/* Stats Bar */}\r\n      {stats.length > 0 && (\r\n        <div className=\"cm-stats\">\r\n          {stats.map((stat, idx) => (\r\n            <div key={idx} className={`cm-stat ${stat.variant || ''}`}>\r\n              <span className=\"cm-stat-value\">{stat.value}</span>\r\n              <span className=\"cm-stat-label\">{stat.label}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Toolbar */}\r\n      <div className=\"cm-toolbar\">\r\n        <input\r\n          type=\"text\"\r\n          className=\"cm-search\"\r\n          placeholder={searchPlaceholder}\r\n          value={searchQuery}\r\n          onChange={(e) => setSearchQuery(e.target.value)}\r\n        />\r\n        {filterOptions.length > 0 && (\r\n          <div className=\"cm-filters\">\r\n            {filterOptions.map((filter) => (\r\n              <button\r\n                key={filter.id}\r\n                className={`cm-filter-btn ${activeFilter === filter.id ? 'active' : ''}`}\r\n                onClick={() =>\r\n                  setActiveFilter(activeFilter === filter.id ? null : filter.id)\r\n                }\r\n              >\r\n                {filter.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Matrix Grid */}\r\n      <div className=\"cm-container\">\r\n        {(normalizedColumns.length === 0 || rows.length === 0) && (\r\n          <div className=\"cm-empty\">{emptyMessage}</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length === 0 && (\r\n          <div className=\"cm-empty\">No items match the current filters.</div>\r\n        )}\r\n        {normalizedColumns.length > 0 && rows.length > 0 && filteredRows.length > 0 && (\r\n          <table className=\"cm-table\">\r\n            <thead>\r\n              <tr>\r\n                <th className=\"cm-group-col\">Group</th>\r\n                <th className=\"cm-label-col\">Name</th>\r\n                <th className=\"cm-status-col\">Status</th>\r\n                {normalizedColumns.map((col) => (\r\n                  <th\r\n                    key={col.id}\r\n                    className={`cm-data-col ${columnHeaderClass?.(col.id) || ''}`}\r\n                    title={col.label}\r\n                  >\r\n                    {col.label}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {Object.entries(groupedRows).map(([groupId, { label: groupLabel, rows: groupRows }]) =>\r\n                groupRows.map((row, idx) => (\r\n                  <MatrixRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    idx={idx}\r\n                    groupId={groupId}\r\n                    groupLabel={groupLabel}\r\n                    columns={normalizedColumns}\r\n                    getCellValue={getCellValue}\r\n                    displayFn={displayFn}\r\n                    onRowClick={onRowClick}\r\n                    onCellClick={onCellClick}\r\n                  />\r\n                ))\r\n              )}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      {legend.length > 0 && (\r\n        <div className=\"cm-legend\">\r\n          {legend.map((item, idx) => (\r\n            <span key={idx} className=\"cm-legend-item\">\r\n              <span className={`cm-cell-icon sample ${item.className || ''}`}>\r\n                {item.icon}\r\n              </span>\r\n              {item.label}\r\n            </span>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  rows = [],\r\n  columns = [],\r\n  getCellValue,\r\n  getCellDisplay,\r\n  onRowClick,\r\n  onCellClick,\r\n  title = 'Coverage Matrix',\r\n  subtitle = '',\r\n  stats = [],\r\n  legend = [],\r\n  searchPlaceholder = 'Search...',\r\n  groupByField = 'group',\r\n  columnHeaderClass,\r\n  emptyMessage = 'No data to display.',\r\n  filterOptions = [],\r\n}", "type": "{ rows?: any[]; columns?: any[]; getCellValue: any; getCellDisplay: any; onRowClick: any; onCellClick: any; title?: string; subtitle?: string; stats?: any[]; legend?: any[]; searchPlaceholder?: string; groupByField?: string; columnHeaderClass: any; emptyMessage?: string; filterOptions?: any[]; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h2", "children": [], "isMap": false, "isConditional": false}, {"tag": "p", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "table", "children": [{"tag": "thead", "children": [{"tag": "tr", "children": [{"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": false, "isConditional": false}, {"tag": "th", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "tbody", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useMemo", "count": 3}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/hooks/useEditorState.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "packages/shared-components/src/components/hooks/useEditorState.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/hooks/useLocalInputState.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "packages/shared-components/src/components/hooks/useLocalInputState.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "imports": [{"source": "react", "specifiers": ["useState", "useCallback", "useEffect"], "category": "framework"}], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ReferenceDropdown", "name": "ReferenceDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} props.value - Current selected value\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string, meta?: string}>} props.options - Array of options\n * @param {string} [props.placeholder] - Placeholder text for empty selection\n * @param {string} [props.label] - Optional label above the dropdown\n * @param {boolean} [props.searchable] - Enable searchable popover mode (default: false)\n * @param {string} [props.className] - Additional class names\n */\nexport function ReferenceDropdown({\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}) {\n  const generatedId = useId();\n  // Searchable mode state\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  // Close on outside click (searchable mode)\n  useEffect(() => {\n    if (!searchable) return;\n\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [searchable]);\n\n  // Filter options in searchable mode\n  const filteredOptions = useMemo(() => {\n    if (!searchable || !search) return options;\n    const lower = search.toLowerCase();\n    return options.filter(\n      (opt) =>\n        opt.value.toLowerCase().includes(lower) ||\n        opt.label?.toLowerCase().includes(lower)\n    );\n  }, [options, search, searchable]);\n\n  const selectedOption = options.find((opt) => opt.value === value);\n\n  // Simple mode: render a standard <select>\n  if (!searchable) {\n    return (\n      <div className={`form-group ${className}`.trim()}>\n        {label && <label htmlFor={generatedId} className=\"label\">{label}</label>}\n        <select id={generatedId}\n          className=\"select\"\n          value={value || ''}\n          onChange={(e) => onChange(e.target.value || undefined)}\n        >\n          <option value=\"\">{placeholder || 'Select...'}</option>\n          {options.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label || opt.value}\n            </option>\n          ))}\n        </select>\n      </div>\n    );\n  }\n\n  // Searchable mode: render popover with search\n  return (\n    <div className={`form-group ${className}`.trim()}>\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"dropdown-trigger\"\n          onClick={() => setIsOpen(!isOpen)}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          <span className={selectedOption ? '' : 'dropdown-trigger-placeholder'}>\n            {selectedOption?.label ||\n              selectedOption?.value ||\n              placeholder ||\n              'Select...'}\n          </span>\n          <span className=\"dropdown-arrow\">\u25bc</span>\n        </div>\n        {isOpen && (\n          <div className=\"dropdown-menu\">\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n            <div className=\"dropdown-options\">\n              {filteredOptions.length === 0 ? (\n                <div className=\"dropdown-empty\">No options found</div>\n              ) : (\n                filteredOptions.map((opt) => (\n                  <div\n                    key={opt.value}\n                    className={`dropdown-option ${value === opt.value ? 'dropdown-option-selected' : ''}`}\n                    onClick={() => {\n                      onChange(opt.value);\n                      setIsOpen(false);\n                      setSearch('');\n                    }}\n                    role=\"button\"\n                    tabIndex={0}\n                    onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                  >\n                    <span>{opt.label || opt.value}</span>\n                    {opt.meta && (\n                      <span className=\"dropdown-option-meta\">{opt.meta}</span>\n                    )}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  options,\n  placeholder,\n  label,\n  searchable = false,\n  className = '',\n}", "type": "{ value: string; onChange: Function; options: Array<{ value: string; label?: string; meta?: string; }>; placeholder?: string; label?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useId", "count": 1}, {"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ChipSelect", "name": "ChipSelect", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string[]} props.value - Array of selected values\n * @param {Function} props.onChange - Callback when selection changes\n * @param {Array<{value: string, label?: string}>} props.options - Available options\n * @param {string} [props.placeholder] - Placeholder text when empty\n * @param {string} [props.label] - Optional label above the component\n */\nexport function ChipSelect({\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const availableOptions = useMemo(() => {\n    return options.filter(opt => !value.includes(opt.value));\n  }, [options, value]);\n\n  const filteredOptions = useMemo(() => {\n    if (!search) return availableOptions;\n    const lower = search.toLowerCase();\n    return availableOptions.filter(opt =>\n      opt.value.toLowerCase().includes(lower) ||\n      opt.label?.toLowerCase().includes(lower)\n    );\n  }, [availableOptions, search]);\n\n  const handleSelect = (optValue) => {\n    onChange([...value, optValue]);\n    setSearch('');\n    inputRef.current?.focus();\n  };\n\n  const handleRemove = (optValue) => {\n    onChange(value.filter(v => v !== optValue));\n  };\n\n  const getLabel = (val) => {\n    const opt = options.find(o => o.value === val);\n    return opt?.label || val;\n  };\n\n  return (\n    <div className=\"form-group\">\n      {label && <label className=\"label\">{label}</label>}\n      <div ref={containerRef} className=\"dropdown\">\n        <div\n          className=\"chip-container chip-container-input\"\n          onClick={() => {\n            setIsOpen(true);\n            inputRef.current?.focus();\n          }}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n        >\n          {value.map(v => (\n            <span key={v} className=\"chip\">\n              {getLabel(v)}\n              <button\n                type=\"button\"\n                className=\"chip-remove\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemove(v);\n                }}\n              >\n                \u00d7\n              </button>\n            </span>\n          ))}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            placeholder={value.length === 0 ? placeholder : ''}\n            value={search}\n            onChange={(e) => setSearch(e.target.value)}\n            onFocus={() => setIsOpen(true)}\n            className=\"chip-input\"\n          />\n        </div>\n        {isOpen && filteredOptions.length > 0 && (\n          <div className=\"dropdown-menu\">\n            {filteredOptions.map((opt) => (\n              <div\n                key={opt.value}\n                onClick={() => handleSelect(opt.value)}\n                className=\"dropdown-item\"\n                role=\"button\"\n                tabIndex={0}\n                onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n              >\n                {opt.label || opt.value}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = [],\n  onChange,\n  options,\n  placeholder = 'Add...',\n  label,\n}", "type": "{ value: string[]; onChange: Function; options: Array<{ value: string; label?: string; }>; placeholder?: string; label?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 2}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::SearchableDropdown", "name": "SearchableDropdown", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Array<{id: string, name?: string}>} props.items - Items to select from\n * @param {Function} props.onSelect - Called with item ID when selected\n * @param {string} [props.placeholder] - Placeholder text for trigger\n * @param {string} [props.emptyMessage] - Message when no items available\n * @param {string} [props.noMatchMessage] - Message when search has no matches\n * @param {boolean} [props.searchable] - Whether to show search input (default true)\n * @param {string} [props.className] - Additional class names\n */\nexport function SearchableDropdown({\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const handleClickOutside = (e) => {\n      if (containerRef.current && !containerRef.current.contains(e.target)) {\n        setIsOpen(false);\n      }\n    };\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  const filteredItems = useMemo(() => {\n    if (!search) return items;\n    const lower = search.toLowerCase();\n    return items.filter(item =>\n      item.id.toLowerCase().includes(lower) ||\n      item.name?.toLowerCase().includes(lower)\n    );\n  }, [items, search]);\n\n  const handleSelect = (item) => {\n    onSelect(item.id);\n    setIsOpen(false);\n    setSearch('');\n  };\n\n  if (items.length === 0) {\n    return (\n      <div className={`dropdown-trigger dropdown-trigger-disabled ${className}`.trim()}>\n        <span>{emptyMessage}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className={`dropdown ${className}`.trim()}>\n      <div className=\"dropdown-trigger\" onClick={() => setIsOpen(!isOpen)} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <span>{placeholder}</span>\n        <span className=\"dropdown-arrow\">\u25bc</span>\n      </div>\n      {isOpen && (\n        <div className=\"dropdown-menu\">\n          {searchable && (\n            <div className=\"dropdown-search\">\n              <input\n                type=\"text\"\n                className=\"dropdown-search-input\"\n                placeholder=\"Search...\"\n                value={search}\n                onChange={(e) => setSearch(e.target.value)}\n                onClick={(e) => e.stopPropagation()}\n                // eslint-disable-next-line jsx-a11y/no-autofocus\n                autoFocus\n              />\n            </div>\n          )}\n          <div className=\"dropdown-options\">\n            {filteredItems.length === 0 ? (\n              <div className=\"dropdown-empty\">{noMatchMessage}</div>\n            ) : (\n              filteredItems.map((item) => (\n                <div\n                  key={item.id}\n                  className=\"dropdown-option\"\n                  onClick={() => handleSelect(item)}\n                  role=\"button\"\n                  tabIndex={0}\n                  onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                >\n                  {item.name || item.id}\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  items,\n  onSelect,\n  placeholder = 'Select...',\n  emptyMessage = 'No items available',\n  noMatchMessage = 'No matches found',\n  searchable = true,\n  className = '',\n}", "type": "{ items: Array<{ id: string; name?: string; }>; onSelect: Function; placeholder?: string; emptyMessage?: string; noMatchMessage?: string; searchable?: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useRef", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useMemo", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::LevelSelector", "name": "LevelSelector", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {number|string} props.value - Current value\n * @param {Function} props.onChange - Called when value changes\n * @param {Array<{value: number|string, label: string, color: string}>} props.levels - Level definitions\n * @param {boolean} [props.showNumeric] - Show numeric input (default false, only for numeric values)\n * @param {number} [props.min] - Minimum value for numeric input (default 0)\n * @param {number} [props.max] - Maximum value for numeric input (default 10)\n * @param {number} [props.step] - Step for numeric input (default 0.1)\n * @param {string} [props.className] - Additional class names\n */\nexport function LevelSelector({\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}) {\n  const [hoveredLevel, setHoveredLevel] = useState(null);\n\n  // Detect if using numeric or string mode\n  const isNumeric = typeof levels[0]?.value === 'number';\n\n  // Get level index based on value\n  const getLevelIndex = (val) => {\n    if (isNumeric) {\n      for (let i = levels.length - 1; i >= 0; i--) {\n        if (val >= levels[i].value) return i;\n      }\n      return 0;\n    } else {\n      const idx = levels.findIndex(l => l.value === val);\n      return idx >= 0 ? idx : 0;\n    }\n  };\n\n  const levelIndex = getLevelIndex(value);\n  const currentLevel = levels[levelIndex];\n  const hoverLevel = hoveredLevel !== null ? levels[hoveredLevel] : null;\n\n  // Calculate partial fill for each dot (only meaningful for numeric mode)\n  const getPartialFill = (idx) => {\n    if (!isNumeric) {\n      // String mode: full fill up to and including current level\n      return idx <= levelIndex ? 1 : 0;\n    }\n    if (idx < levelIndex) return 1;\n    if (idx > levelIndex) return 0;\n    // Current level - calculate partial based on value position\n    const levelStart = levels[idx].value;\n    const levelEnd = idx < levels.length - 1 ? levels[idx + 1].value : max;\n    const progress = (value - levelStart) / (levelEnd - levelStart);\n    return Math.max(0, Math.min(1, progress));\n  };\n\n  return (\n    <div className={`level-selector ${className}`.trim()}>\n      <div className=\"level-selector-dots\">\n        {levels.map((level, idx) => {\n          const isHovered = hoveredLevel !== null && idx <= hoveredLevel;\n          const fill = getPartialFill(idx);\n          const baseColor = isHovered ? hoverLevel.color : currentLevel.color;\n\n          return (\n            <div\n              key={idx}\n              className={`level-selector-dot ${hoveredLevel === idx ? 'level-selector-dot-active' : ''}`.trim()}\n              onClick={() => onChange(level.value)}\n              onMouseEnter={() => setHoveredLevel(idx)}\n              onMouseLeave={() => setHoveredLevel(null)}\n              title={`${level.label}`}\n              role=\"button\"\n              tabIndex={0}\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n            >\n              <svg className=\"level-selector-dot-fill-svg\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n                <rect\n                  x=\"0\"\n                  y={100 - (fill * 100)}\n                  width=\"100\"\n                  height={fill * 100}\n                  fill={baseColor}\n                />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n      {showNumeric && isNumeric && (\n        <input\n          type=\"number\"\n          className=\"level-selector-input\"\n          value={value}\n          onChange={(e) => {\n            const newVal = parseFloat(e.target.value);\n            if (!isNaN(newVal)) {\n              onChange(Math.max(min, Math.min(max, newVal)));\n            }\n          }}\n          step={step}\n          min={min}\n          max={max}\n        />\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value,\n  onChange,\n  levels,\n  showNumeric = false,\n  min = 0,\n  max = 10,\n  step = 0.1,\n  className = '',\n}", "type": "{ value: number | string; onChange: Function; levels: Array<{ value: number | string; label: string; color: string; }>; showNumeric?: boolean; min?: number; max?: number; step?: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "svg", "children": [{"tag": "rect", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::NumberInput", "name": "NumberInput", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {number|undefined|null} props.value - The numeric value\r\n * @param {Function} props.onChange - Called with the parsed number when valid\r\n * @param {string} [props.className] - CSS class for the input\r\n * @param {number} [props.min] - Minimum value\r\n * @param {number} [props.max] - Maximum value\r\n * @param {number|string} [props.step] - Step value for increment/decrement\r\n * @param {string} [props.placeholder] - Placeholder text\r\n * @param {boolean} [props.allowEmpty] - If true, empty string calls onChange(undefined)\r\n * @param {boolean} [props.integer] - If true, only allow integers\r\n * @param {boolean} [props.disabled] - Disable the input\r\n */\r\nexport function NumberInput({\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}) {\n  const externalDisplayValue = formatValue(value);\n  // Internal string state for editing\n  const [localValue, setLocalValue] = useState(() => externalDisplayValue);\n  // Track focus in state so render can safely choose draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\r\n  const parseValue = useCallback((str) => {\r\n    if (str === '' || str === '-' || str === '.' || str === '-.') {\r\n      return null; // Intermediate state, not a valid number yet\r\n    }\r\n    const parsed = integer ? parseInt(str, 10) : parseFloat(str);\r\n    if (isNaN(parsed)) return null;\r\n    return parsed;\r\n  }, [integer]);\r\n\r\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalDisplayValue);\n    setIsFocused(true);\n  }, [externalDisplayValue]);\n\r\n  const handleChange = useCallback((e) => {\r\n    const newValue = e.target.value;\r\n\r\n    // Allow empty, minus sign, decimal point, or any numeric pattern\r\n    // This regex allows intermediate states like \"-\", \".\", \"-.\", \"1.\", \"-1.\"\r\n    /* eslint-disable sonarjs/slow-regex -- short user input (single number field value) */\r\n    const validPattern = integer\r\n      ? /^-?\\d*$/  // Integer: optional minus, digits only\r\n      : /^-?\\d*\\.?\\d*$/; // Float: optional minus, digits, optional decimal, more digits\r\n    /* eslint-enable sonarjs/slow-regex */\r\n\r\n    if (!validPattern.test(newValue)) {\r\n      return; // Reject invalid characters\r\n    }\r\n\r\n    setLocalValue(newValue);\r\n\r\n    // Try to parse and update parent if it's a complete valid number\r\n    const parsed = parseValue(newValue);\r\n    if (parsed !== null) {\r\n      // Apply min/max constraints\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      onChange(constrained);\r\n    } else if (allowEmpty && newValue === '') {\r\n      onChange(undefined);\r\n    }\r\n  }, [onChange, min, max, allowEmpty, integer, parseValue]);\r\n\r\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n\n    // On blur, ensure the display value matches the actual value\n    const parsed = parseValue(localValue);\n    if (parsed !== null) {\r\n      // Apply constraints and update\r\n      let constrained = parsed;\r\n      if (min !== undefined && constrained < min) constrained = min;\r\n      if (max !== undefined && constrained > max) constrained = max;\r\n      setLocalValue(formatValue(constrained));\r\n      onChange(constrained);\r\n    } else if (allowEmpty && localValue === '') {\r\n      onChange(undefined);\r\n    } else {\r\n      // Revert to the parent's value if local is invalid\r\n      setLocalValue(externalDisplayValue);\n    }\n  }, [allowEmpty, externalDisplayValue, localValue, max, min, onChange, parseValue]);\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode=\"numeric\"\r\n      value={isFocused ? localValue : externalDisplayValue}\n      onChange={handleChange}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\r\n      placeholder={placeholder}\r\n      disabled={disabled}\r\n      {...rest}\r\n    />\r\n  );\r\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'input',\r\n  min,\r\n  max,\r\n  step: _step,\r\n  placeholder,\r\n  allowEmpty = false,\r\n  integer = false,\r\n  disabled = false,\r\n  ...rest\n}", "type": "{ value: number | undefined | null; onChange: Function; className?: string; min?: number; max?: number; step?: number | string; placeholder?: string; allowEmpty?: boolean; integer?: boolean; disabled?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "input", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 4}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::LocalTextArea", "name": "LocalTextArea", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "export function LocalTextArea({\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}) {\n  const externalValue = value || '';\n  const [localValue, setLocalValue] = useState(externalValue);\n  // Track focus in state so render can safely choose between local draft vs external value\n  const [isFocused, setIsFocused] = useState(false);\n\n  const handleFocus = useCallback(() => {\n    setLocalValue(externalValue);\n    setIsFocused(true);\n  }, [externalValue]);\n\n  // Call onChange on blur if value changed\n  const handleBlur = useCallback(() => {\n    setIsFocused(false);\n    if (localValue !== externalValue) {\n      onChange(localValue);\n    }\n  }, [externalValue, localValue, onChange]);\n\n  return (\n    <textarea\n      value={isFocused ? localValue : externalValue}\n      onChange={(e) => setLocalValue(e.target.value)}\r\n      onFocus={handleFocus}\r\n      onBlur={handleBlur}\r\n      className={className}\n      placeholder={placeholder}\n      rows={rows}\n      {...rest}\n    />\n  );\n}", "parameters": [{"name": "{\r\n  value,\r\n  onChange,\r\n  className = 'textarea',\n  placeholder,\n  rows,\n  ...rest\n}", "type": "{ [x: string]: any; value: any; onChange: any; className?: string; placeholder: any; rows: any; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "textarea", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 2}, {"name": "useCallback", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::EnableToggle", "name": "EnableToggle", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {boolean} props.enabled - Current toggle state\n * @param {Function} props.onChange - Callback when toggle changes (receives new value)\n * @param {Function} [props.onClick] - Optional raw click handler (receives event, takes priority)\n * @param {string} [props.label] - Optional label beside the toggle\n * @param {string} [props.className] - Optional additional class names\n */\nexport function EnableToggle({ enabled, onChange, onClick, label, className = '' }) {\n  const handleClick = (e) => {\n    if (onClick) {\n      onClick(e);\n    } else if (onChange) {\n      onChange(!enabled);\n    }\n  };\n\n  return (\n    <div className={`flex items-center gap-lg ${className}`.trim()}>\n      <div\n        onClick={handleClick}\n        className={`toggle ${enabled ? 'toggle-on' : ''}`}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleClick(e); }}\n      >\n        <div className=\"toggle-knob\" />\n      </div>\n      {label && (\n        <span className=\"text-md text-muted\">{label}</span>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ enabled, onChange, onClick, label, className = '' }", "type": "{ enabled: boolean; onChange: Function; onClick?: Function; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::IconButton", "name": "IconButton", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.icon - Icon content (emoji or text)\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {boolean} [props.danger] - Apply danger styling\r\n * @param {string} [props.title] - Tooltip text\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function IconButton({ icon, onClick, danger, title, className = '' }) {\r\n  const classes = [\r\n    'btn-icon',\r\n    danger ? 'btn-icon-danger' : '',\r\n    className,\r\n  ].filter(Boolean).join(' ');\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      className={classes}\r\n      onClick={onClick}\r\n      title={title}\r\n    >\r\n      {icon}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ icon, onClick, danger, title, className = '' }", "type": "{ icon: string; onClick: Function; danger?: boolean; title?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::InfoBox", "name": "InfoBox", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.title] - Optional title for the info box\r\n * @param {React.ReactNode} props.children - Content of the info box\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function InfoBox({ title, children, className = '' }) {\r\n  return (\r\n    <div className={`info-box ${className}`.trim()}>\r\n      {title && <div className=\"info-box-title\">{title}</div>}\r\n      <div className=\"info-box-text\">{children}</div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ title, children, className = '' }", "type": "{ title?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::SectionHeader", "name": "SectionHeader", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.title - Section title\r\n * @param {string} [props.description] - Optional description text\r\n * @param {string} [props.icon] - Optional emoji icon\r\n * @param {string} [props.count] - Optional count badge text (e.g. \"3 active / 5 total\")\r\n * @param {React.ReactNode} [props.actions] - Optional action buttons on the right\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function SectionHeader({\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <>\r\n      <div className={`flex-between mb-lg ${className}`.trim()}>\r\n        <div className=\"section-title mb-0\">\r\n          {icon && <span className=\"section-title-icon\">{icon}</span>}\r\n          {title}\r\n          {count && <span className=\"badge-count\">{count}</span>}\r\n        </div>\r\n        {actions}\r\n      </div>\r\n      {description && <div className=\"section-desc\">{description}</div>}\r\n    </>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  title,\r\n  description,\r\n  icon,\r\n  count,\r\n  actions,\r\n  className = '',\r\n}", "type": "{ title: string; description?: string; icon?: string; count?: string; actions?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::EmptyState", "name": "EmptyState", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} [props.icon] - Emoji icon to display\r\n * @param {string} props.title - Title text\r\n * @param {string} [props.description] - Description text\r\n * @param {React.ReactNode} [props.children] - Additional content (e.g., action button)\r\n * @param {string} [props.className] - Optional additional class names\r\n */\r\nexport function EmptyState({ icon, title, description, children, className = '' }) {\r\n  return (\r\n    <div className={`empty-state ${className}`.trim()}>\r\n      {icon && <div className=\"empty-state-icon\">{icon}</div>}\r\n      <div className=\"empty-state-title\">{title}</div>\r\n      {description && <div className=\"empty-state-desc\">{description}</div>}\r\n      {children}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ icon, title, description, children, className = '' }", "type": "{ icon?: string; title: string; description?: string; children?: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::CategorySection", "name": "CategorySection", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {string} [props.id] - Optional category identifier\n * @param {string} props.icon - Emoji icon for the category\n * @param {string} props.label - Category label\n * @param {Array} props.items - Items in this category\n * @param {boolean} props.expanded - Whether the section is expanded\n * @param {Function} props.onToggleExpand - Callback to toggle expansion\n * @param {boolean} props.allEnabled - Whether all items are enabled\n * @param {Function} props.onToggleAll - Callback to toggle all items\n * @param {Function} props.renderItem - Render function for each item\n * @param {string} [props.gridClassName] - Custom grid class name\n * @param {string} [props.className] - Additional class names\n */\nexport function CategorySection({\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}) {\n  return (\n    <div className={`category-section ${className}`.trim()}>\n      <div className=\"category-header\" onClick={onToggleExpand} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onToggleExpand(e); }} >\n        <span className={`category-expand ${expanded ? 'category-expand-open' : ''}`}>\n          &gt;\n        </span>\n        <span className=\"category-icon\">{icon}</span>\n        <span className=\"category-title\">{label}</span>\n        <span className=\"badge-count\">{items.length}</span>\n        <button\n          className={`btn-toggle-category ${allEnabled ? 'btn-toggle-category-active' : ''}`}\n          onClick={(e) => {\n            e.stopPropagation();\n            onToggleAll();\n          }}\n        >\n          {allEnabled ? 'All On' : 'All Off'}\n        </button>\n      </div>\n      {expanded && (\n        <div className={gridClassName}>\n          {items.map(renderItem)}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  id: _id,\n  icon,\n  label,\n  items,\n  expanded,\n  onToggleExpand,\n  allEnabled,\n  onToggleAll,\n  renderItem,\n  gridClassName = 'list-grid',\n  className = '',\n}", "type": "{ id?: string; icon: string; label: string; items: any[]; expanded: boolean; onToggleExpand: Function; allEnabled: boolean; onToggleAll: Function; renderItem: Function; gridClassName?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::AddCard", "name": "AddCard", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClick - Callback when card is clicked\n * @param {string} props.label - Button label (default \"Add Item\")\n * @param {string} props.className - Optional CSS class name\n */\nexport function AddCard({ onClick, label = 'Add Item', className = '' }) {\n  return (\n    <div\n      className={`add-card ${className}`.trim()}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClick(e); }}\n    >\n      <span className=\"add-card-icon\">+</span>\n      <span>{label}</span>\n    </div>\n  );\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::AddItemButton", "name": "AddItemButton", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Function} props.onClick - Callback when button is clicked\r\n * @param {string} props.label - Button label text (default \"Add Item\")\r\n * @param {string} props.className - Optional CSS class name\r\n */\r\nexport function AddItemButton({ onClick, label = 'Add Item', className = '' }) {\r\n  return (\r\n    <button\r\n      className={`btn-add ${className}`.trim()}\r\n      onClick={onClick}\r\n    >\r\n      + {label}\r\n    </button>\r\n  );\r\n}", "parameters": [{"name": "{ onClick, label = 'Add Item', className = '' }", "type": "{ onClick: Function; label: string; className: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "button", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ModalShell", "name": "ModalShell", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Function} props.onClose - Called when overlay or close button is clicked\n * @param {string} props.icon - Icon to show in header\n * @param {string} props.title - Modal title\n * @param {boolean} [props.disabled] - Whether to show disabled badge\n * @param {Array<{id: string, icon: string, label: string}>} [props.tabs] - Tab definitions (optional)\n * @param {string} [props.activeTab] - Currently active tab ID\n * @param {Function} [props.onTabChange] - Called when tab changes\n * @param {Function} [props.renderTabBadge] - Optional function to render badge for each tab: (tabId) => ReactNode\n * @param {React.ReactNode} [props.sidebarFooter] - Optional content to render at bottom of sidebar\n * @param {React.ReactNode} props.children - Modal content (tab content if tabs provided, otherwise full body)\n * @param {string} [props.className] - Additional class for modal container\n * @param {boolean} [props.preventOverlayClose] - Disable overlay click and Escape key close\n * @param {React.ReactNode} [props.footer] - Optional footer content\n */\nexport function ModalShell({\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}) {\n  const hasTabs = tabs && tabs.length > 0;\n  const mouseDownOnOverlay = useRef(false);\n\n  // Escape key handler\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Escape' && !preventOverlayClose) {\n      onClose();\n    }\n  }, [onClose, preventOverlayClose]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Body scroll lock\n  useEffect(() => {\n    const prev = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => { document.body.style.overflow = prev; };\n  }, []);\n\n  const handleOverlayMouseDown = (e) => {\n    mouseDownOnOverlay.current = e.target === e.currentTarget;\n  };\n\n  const handleOverlayClick = (e) => {\n    if (!preventOverlayClose && mouseDownOnOverlay.current && e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  return (\n    <div className=\"modal-overlay\" onMouseDown={handleOverlayMouseDown} onClick={handleOverlayClick} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") handleOverlayClick(e); }} >\n      <div className={`modal ${className}`.trim()} onClick={(e) => e.stopPropagation()} role=\"button\" tabIndex={0} onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }} >\n        <div className=\"modal-header\">\n          <div className=\"modal-title\">\n            {icon && <span className=\"modal-title-icon\">{icon}</span>}\n            <span>{title}</span>\n            {disabled && <span className=\"badge badge-orphan\">Disabled</span>}\n          </div>\n          <button className=\"btn-close\" onClick={onClose}>\u00d7</button>\n        </div>\n        <div className=\"modal-body\">\n          {hasTabs ? (\n            <>\n              <div className=\"modal-sidebar\">\n                {tabs.map((tab) => (\n                  <button\n                    key={tab.id}\n                    className={`btn-tab ${activeTab === tab.id ? 'btn-tab-active' : ''}`}\n                    onClick={() => onTabChange?.(tab.id)}\n                  >\n                    <span className=\"btn-tab-icon\">{tab.icon}</span>\n                    <span>{tab.label}</span>\n                    {renderTabBadge?.(tab.id)}\n                  </button>\n                ))}\n                {sidebarFooter}\n              </div>\n              <div className=\"modal-content\">{children}</div>\n            </>\n          ) : (\n            children\n          )}\n        </div>\n        {footer && <div className=\"modal-footer\">{footer}</div>}\n      </div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  onClose,\n  icon,\n  title,\n  disabled,\n  tabs,\n  activeTab,\n  onTabChange,\n  renderTabBadge,\n  sidebarFooter,\n  children,\n  className = '',\n  preventOverlayClose = false,\n  footer,\n}", "type": "{ onClose: Function; icon: string; title: string; disabled?: boolean; tabs?: Array<{ id: string; icon: string; label: string; }>; activeTab?: string; onTabChange?: Function; renderTabBadge?: Function; sidebarFooter?: React.ReactNode; children: React.ReactNode; className?: string; preventOverlayClose?: boolean; footer?: React.ReactNode; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": true}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "<>", "children": [{"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useRef", "count": 1}, {"name": "useCallback", "count": 1}, {"name": "useEffect", "count": 2}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ItemRow", "name": "ItemRow", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {string} props.name - Display name\r\n * @param {boolean} [props.muted] - Apply muted styling to name\r\n * @param {Function} [props.onRemove] - Called when remove button clicked\r\n * @param {string} [props.removeTitle] - Tooltip for remove button\r\n * @param {React.ReactNode} props.children - Controls to render between name and remove\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ItemRow({\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}) {\r\n  return (\r\n    <div className={`item-row ${className}`.trim()}>\r\n      <span className={`item-row-name ${muted ? 'item-row-name-muted' : ''}`}>\r\n        {name}\r\n      </span>\r\n      {children}\r\n      {onRemove && (\r\n        <button\r\n          className=\"item-row-remove\"\r\n          onClick={onRemove}\r\n          title={removeTitle}\r\n        >\r\n          \u00d7\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  name,\r\n  muted,\r\n  onRemove,\r\n  removeTitle = 'Remove',\r\n  children,\r\n  className = '',\r\n}", "type": "{ name: string; muted?: boolean; onRemove?: Function; removeTitle?: string; children: React.ReactNode; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::PressureChangesEditor", "name": "PressureChangesEditor", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\n * @param {Object} props\n * @param {Object<string, number>} props.value - Map of pressure ID to delta value\n * @param {Function} props.onChange - Called when values change\n * @param {Array<{id: string, name?: string}>} props.pressures - Available pressure definitions\n * @param {string} [props.label] - Optional custom label (default: \"Pressure Changes\")\n * @param {string} [props.className] - Additional class names\n */\nexport function PressureChangesEditor({\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}) {\n  const entries = Object.entries(value);\n\n  const addPressure = (pressureId) => {\n    if (pressureId && !(pressureId in value)) {\n      onChange({ ...value, [pressureId]: 0 });\n    }\n  };\n\n  const updateDelta = (pressureId, delta) => {\n    onChange({ ...value, [pressureId]: parseInt(delta) || 0 });\n  };\n\n  const removePressure = (pressureId) => {\n    const newValue = { ...value };\n    delete newValue[pressureId];\n    onChange(newValue);\n  };\n\n  const availablePressures = (pressures || []).filter((p) => !(p.id in value));\n\n  return (\n    <div className={`form-group mb-xl ${className}`.trim()}>\n      <label className=\"label\">{label}</label>\n      <div className=\"flex flex-col gap-md\">\n        {entries.map(([pressureId, delta]) => (\n          <div key={pressureId} className=\"item-row\">\n            <span className=\"item-row-name\">{pressureId}</span>\n            <input\n              type=\"number\"\n              className=\"input pressure-changes-delta-input\"\n              value={delta}\n              onChange={(e) => updateDelta(pressureId, e.target.value)}\n            />\n            <button\n              className=\"btn-icon btn-icon-danger\"\n              onClick={() => removePressure(pressureId)}\n            >\n              \u00d7\n            </button>\n          </div>\n        ))}\n      </div>\n      {availablePressures.length > 0 && (\n        <select\n          className=\"select mt-md pressure-changes-add-select\"\n          value=\"\"\n          onChange={(e) => addPressure(e.target.value)}\n        >\n          <option value=\"\">+ Add pressure change...</option>\n          {availablePressures.map((p) => (\n            <option key={p.id} value={p.id}>\n              {p.name || p.id}\n            </option>\n          ))}\n        </select>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{\n  value = {},\n  onChange,\n  pressures,\n  label = 'Pressure Changes',\n  className = '',\n}", "type": "{ value: {    [x: string]: number;}; onChange: Function; pressures: Array<{ id: string; name?: string; }>; label?: string; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "label", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "input", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "select", "children": [{"tag": "option", "children": [], "isMap": false, "isConditional": false}, {"tag": "option", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ErrorBadge", "name": "ErrorBadge", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * Badge for showing error counts\r\n * @param {Object} props\r\n * @param {number} props.count - Number of errors\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function ErrorBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count} error{count !== 1 ? 's' : ''}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::OrphanBadge", "name": "OrphanBadge", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * Badge for showing orphan status (not in any era)\r\n * @param {Object} props\r\n * @param {boolean} props.isOrphan - Whether the item is orphaned\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function OrphanBadge({ isOrphan, className = '' }) {\r\n  if (!isOrphan) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-orphan ${className}`.trim()}>\r\n      Not in any era\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ isOrphan, className = '' }", "type": "{ isOrphan: boolean; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::TabValidationBadge", "name": "TabValidationBadge", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * Badge for showing validation count in tabs\r\n * @param {Object} props\r\n * @param {number} props.count - Number of validation issues\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function TabValidationBadge({ count, className = '' }) {\r\n  if (!count) return null;\r\n  return (\r\n    <span className={`badge badge-validation badge-error ${className}`.trim()}>\r\n      {count}\r\n    </span>\r\n  );\r\n}", "parameters": [{"name": "{ count, className = '' }", "type": "{ count: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "span", "children": [], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::EraBadges", "name": "EraBadges", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @param {Object} props\r\n * @param {Array} props.eras - Array of era objects with id and name\r\n * @param {number} props.maxVisible - Maximum number of badges to show (default 3)\r\n * @param {string} [props.className] - Additional class names\r\n */\r\nexport function EraBadges({ eras = [], maxVisible = 3, className = '' }) {\n  if (!eras.length) return null;\r\n\r\n  const visible = eras.slice(0, maxVisible);\r\n  const remaining = eras.length - maxVisible;\r\n\r\n  return (\r\n    <div className={`chip-container mt-md ${className}`.trim()}>\r\n      {visible.map((era) => (\r\n        <span key={era.id} className=\"badge badge-era\">\n          <span className=\"badge-era-icon\">{ERA_ICON}</span> {era.name || era.id}\n        </span>\n      ))}\n      {remaining > 0 && (\n        <span className=\"badge badge-era badge-era-remaining\">\n          +{remaining} more\n        </span>\n      )}\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{ eras = [], maxVisible = 3, className = '' }", "type": "{ eras: any[]; maxVisible: number; className?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "span", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ChronicleSeedViewer", "name": "ChronicleSeedViewer", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * @typedef {Object} ChronicleRoleAssignment\r\n * @property {string} role\r\n * @property {string} entityId\r\n * @property {string} entityName\r\n * @property {string} entityKind\r\n * @property {boolean} isPrimary\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleTemporalContext\r\n * @property {{ id: string, name: string, summary?: string }} [focalEra]\r\n * @property {[number, number]} [chronicleTickRange]\r\n * @property {string} [temporalScope]\r\n * @property {boolean} [isMultiEra]\r\n * @property {string[]} [touchedEraIds]\r\n * @property {string} [temporalDescription]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ChronicleSeedData\r\n * @property {string} narrativeStyleId\r\n * @property {string} [narrativeStyleName]\r\n * @property {string} [entrypointId]\r\n * @property {string} [entrypointName]\r\n * @property {string} [narrativeDirection]\r\n * @property {ChronicleRoleAssignment[]} roleAssignments\r\n * @property {string[]} selectedEventIds\r\n * @property {string[]} selectedRelationshipIds\r\n * @property {ChronicleTemporalContext} [temporalContext]\r\n */\r\n\r\n/**\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames] - Resolved display names for event IDs\r\n * @param {Map<string, string>} [props.relationshipLabels] - Resolved display labels for relationship IDs\r\n */\r\nexport default function ChronicleSeedViewer({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}) {\r\n  const primaryRoles = seed.roleAssignments.filter((r) => r.isPrimary);\r\n  const supportingRoles = seed.roleAssignments.filter((r) => !r.isPrimary);\r\n\r\n  return (\r\n    <div className=\"csv-container\">\r\n      {/* Style & Entry Point */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Generation Settings</div>\r\n        <div className=\"csv-field\">\r\n          <span className=\"csv-field-label\">Style:</span>\r\n          <span className=\"csv-field-value\">{seed.narrativeStyleName || seed.narrativeStyleId}</span>\r\n        </div>\r\n        {seed.entrypointId && (\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Entry Point:</span>\r\n            <span className=\"csv-field-value\">{seed.entrypointName || seed.entrypointId}</span>\r\n          </div>\r\n        )}\r\n        {seed.narrativeDirection && (\r\n          <div className=\"csv-narrative-direction-wrapper\">\r\n            <div className=\"csv-narrative-direction-label\">\r\n              Narrative Direction:\r\n            </div>\r\n            <div\r\n              className=\"csv-narrative-direction-body\"\r\n              title=\"Click to copy\"\r\n              onClick={() => void navigator.clipboard.writeText(seed.narrativeDirection)}\r\n              role=\"button\"\r\n              tabIndex={0}\r\n              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n            >\r\n              {seed.narrativeDirection}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Role Assignments */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Cast ({seed.roleAssignments.length} entities)</div>\r\n        {seed.roleAssignments.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No roles assigned</div>\r\n        ) : (\r\n          <div className=\"csv-role-list\">\r\n            {primaryRoles.map((role, i) => (\r\n              <div key={`primary-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-primary-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n            {supportingRoles.map((role, i) => (\r\n              <div key={`supporting-${i}`} className=\"csv-role-item\">\r\n                <span className=\"csv-supporting-role-badge\">{role.role}</span>\r\n                <span className=\"csv-entity-name\">{role.entityName}</span>\r\n                <span className=\"csv-entity-kind\">({role.entityKind})</span>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Temporal Context (optional, used by chronicler) */}\r\n      {seed.temporalContext && (\r\n        <div className=\"csv-section\">\r\n          <div className=\"csv-section-title\">Temporal Context</div>\r\n          <div className=\"csv-field\">\r\n            <span className=\"csv-field-label\">Focal Era:</span>\r\n            <span className=\"csv-field-value\">\r\n              {seed.temporalContext.focalEra?.name || \"Unknown\"}\r\n            </span>\r\n          </div>\r\n          {seed.temporalContext.focalEra?.summary && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Era Summary:</span>\r\n              <span className=\"csv-field-value\">{seed.temporalContext.focalEra.summary}</span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.temporalDescription && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Scope:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.temporalDescription}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.chronicleTickRange && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Ticks:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.chronicleTickRange[0]}&ndash;\r\n                {seed.temporalContext.chronicleTickRange[1]}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {typeof seed.temporalContext.isMultiEra === \"boolean\" && (\r\n            <div className=\"csv-field\">\r\n              <span className=\"csv-field-label\">Multi-era:</span>\r\n              <span className=\"csv-field-value\">\r\n                {seed.temporalContext.isMultiEra ? \"Yes\" : \"No\"}\r\n              </span>\r\n            </div>\r\n          )}\r\n          {seed.temporalContext.touchedEraIds?.length ? (\r\n            <div>\r\n              <div className=\"csv-field-label-spaced\">Touched Eras:</div>\r\n              <div className=\"csv-id-list\">\r\n                {seed.temporalContext.touchedEraIds.map((id) => (\r\n                  <span key={id} className=\"csv-id-tag\">\r\n                    {id}\r\n                  </span>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n      )}\r\n\r\n      {/* Selected Events */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Events ({seed.selectedEventIds.length})</div>\r\n        {seed.selectedEventIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No events selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedEventIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {eventNames?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* Selected Relationships */}\r\n      <div className=\"csv-section\">\r\n        <div className=\"csv-section-title\">Relationships ({seed.selectedRelationshipIds.length})</div>\r\n        {seed.selectedRelationshipIds.length === 0 ? (\r\n          <div className=\"csv-empty-state\">No relationships selected</div>\r\n        ) : (\r\n          <div className=\"csv-id-list\">\r\n            {seed.selectedRelationshipIds.map((id, i) => (\r\n              <span key={i} className=\"csv-id-tag\">\r\n                {relationshipLabels?.get(id) || id}\r\n              </span>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "div", "children": [], "isMap": false, "isConditional": false}, {"tag": "div", "children": [], "isMap": false, "isConditional": true}, {"tag": "div", "children": [{"tag": "span", "children": [], "isMap": true, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::SeedModal", "name": "SeedModal", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * Modal wrapper for use in chronicler wiki pages\r\n *\r\n * @param {Object} props\r\n * @param {boolean} props.isOpen\r\n * @param {Function} props.onClose\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {string} [props.title]\r\n */\r\nexport function SeedModal({\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}) {\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-modal-overlay\"\r\n      onClick={onClose}\r\n      role=\"button\"\r\n      tabIndex={0}\r\n      onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") onClose(e); }}\r\n    >\r\n      <div\r\n        className=\"csv-modal-dialog\"\r\n        onClick={(e) => e.stopPropagation()}\r\n        role=\"button\"\r\n        tabIndex={0}\r\n        onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\r\n      >\r\n        {/* Header */}\r\n        <div className=\"csv-modal-header\">\r\n          <h3 className=\"csv-modal-title\">{title}</h3>\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-close-button\"\r\n          >\r\n            &times;\r\n          </button>\r\n        </div>\r\n\r\n        {/* Content */}\r\n        <div className=\"csv-modal-body\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n\r\n        {/* Footer */}\r\n        <div className=\"csv-modal-footer\">\r\n          <button\r\n            onClick={onClose}\r\n            className=\"csv-modal-footer-button\"\r\n          >\r\n            Close\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  isOpen,\r\n  onClose,\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  title = \"Generation Context\",\r\n}", "type": "{ isOpen: boolean; onClose: Function; seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; title?: string; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "div", "children": [{"tag": "div", "children": [{"tag": "h3", "children": [], "isMap": false, "isConditional": false}, {"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "button", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, "hookCalls": [], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::ExpandableSeedSection", "name": "ExpandableSeedSection", "kind": "component", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "/**\r\n * Expandable wrapper for use in validation UI\r\n *\r\n * @param {Object} props\r\n * @param {ChronicleSeedData} props.seed\r\n * @param {Map<string, string>} [props.eventNames]\r\n * @param {Map<string, string>} [props.relationshipLabels]\r\n * @param {boolean} [props.defaultExpanded]\r\n */\r\nexport function ExpandableSeedSection({\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}) {\r\n  const [expanded, setExpanded] = useState(defaultExpanded);\r\n\r\n  return (\r\n    <div\r\n      className=\"csv-expandable-container\"\r\n    >\r\n      <button\r\n        onClick={() => setExpanded(!expanded)}\r\n        className=\"csv-expandable-button\"\r\n      >\r\n        <span>Generation Context</span>\r\n        <span className=\"csv-expandable-meta\">\r\n          {expanded ? \"\\u25BC\" : \"\\u25B6\"} {seed.roleAssignments.length} roles, {seed.selectedEventIds.length}{\" \"}\r\n          events\r\n        </span>\r\n      </button>\r\n      {expanded && (\r\n        <div className=\"csv-expandable-content\">\r\n          <ChronicleSeedViewer\r\n            seed={seed}\r\n            eventNames={eventNames}\r\n            relationshipLabels={relationshipLabels}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}", "parameters": [{"name": "{\r\n  seed,\r\n  eventNames,\r\n  relationshipLabels,\r\n  defaultExpanded = false,\r\n}", "type": "{ seed: ChronicleSeedData; eventNames?: Map<string, string>; relationshipLabels?: Map<string, string>; defaultExpanded?: boolean; }", "optional": false}], "returnType": "any", "jsxTree": {"tag": "div", "children": [{"tag": "button", "children": [{"tag": "span", "children": [], "isMap": false, "isConditional": false}, {"tag": "span", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": false}, {"tag": "div", "children": [{"tag": "ChronicleSeedViewer", "children": [], "isMap": false, "isConditional": false}], "isMap": false, "isConditional": true}], "isMap": false, "isConditional": false}, "hookCalls": [{"name": "useState", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::useLocalInputState", "name": "useLocalInputState", "kind": "hook", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "export function useLocalInputState(externalValue, onUpdate) {\n  const [localValue, setLocalValue] = useState(externalValue || '');\n\n  // Sync local value when external value changes\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- intentional prop->draft sync for controlled inputs\n    setLocalValue(externalValue || '');\n  }, [externalValue]);\n\n  // Call onUpdate if value changed\n  const handleBlur = useCallback(() => {\n    if (localValue !== externalValue) {\n      onUpdate(localValue);\n    }\n  }, [localValue, externalValue, onUpdate]);\n\n  return [localValue, setLocalValue, handleBlur];\n}", "parameters": [{"name": "externalValue", "type": "any", "optional": false}, {"name": "onUpdate", "type": "any", "optional": false}], "returnType": "any[]", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 1}, {"name": "useCallback", "count": 1}], "imports": [], "storeAccess": []}, {"id": "packages/shared-components/src/components/index.js::useEditorState", "name": "useEditorState", "kind": "hook", "filePath": "packages/shared-components/src/components/index.js", "sourceCode": "export function useEditorState(items, onChange, options = {}) {\n  const {\n    idField = 'id',\n    nameField = 'name',\n    createItem,\n    persistKey,\n  } = options;\n\n  const [selectedId, setSelectedId] = useState(() => {\n    const stored = loadStored(persistKey);\n    return typeof stored === 'string' ? stored : null;\n  });\n\n  // Restore selectedId from storage when persistKey changes\n  useEffect(() => {\n    const stored = loadStored(persistKey);\n    // eslint-disable-next-line react-hooks/set-state-in-effect -- restore persisted selection when key changes\n    setSelectedId(typeof stored === 'string' ? stored : null);\n  }, [persistKey]);\n\n  const resolvedIndex = selectedId ? items.findIndex((item) => item[idField] === selectedId) : -1;\n  const selectedIndex = resolvedIndex >= 0 ? resolvedIndex : null;\n\n  // Derive selected item from index\n  const selectedItem = selectedIndex !== null && selectedIndex < items.length\n    ? items[selectedIndex]\n    : null;\n\n  // Persist selectedId to storage\n  useEffect(() => {\n    if (!persistKey) return;\n    if (selectedId) {\n      saveStored(persistKey, selectedId);\n    } else {\n      clearStored(persistKey);\n    }\n  }, [persistKey, selectedId]);\n\n  // Clear invalid selectedId\n  if (selectedId && selectedIndex === null) {\n    setSelectedId(null);\n  }\n\n  // Update the currently selected item\n  const handleItemChange = useCallback((updated) => {\n    if (selectedIndex !== null && selectedIndex < items.length) {\n      const newItems = [...items];\n      newItems[selectedIndex] = updated;\n      onChange(newItems);\n    }\n  }, [items, onChange, selectedIndex]);\n\n  // Toggle the enabled state of an item\n  const handleToggle = useCallback((item) => {\n    const index = items.findIndex((i) => i[idField] === item[idField]);\n    if (index >= 0) {\n      const newItems = [...items];\n      newItems[index] = { ...item, enabled: item.enabled === false ? true : false };\n      onChange(newItems);\n    }\n  }, [items, onChange, idField]);\n\n  // Delete the currently selected item (with confirmation)\n  const handleDelete = useCallback(() => {\n    if (selectedIndex !== null && selectedItem) {\n      const itemName = selectedItem[nameField] || selectedItem[idField];\n      if (confirm(`Delete \"${itemName}\"?`)) {\n        const newItems = [...items];\n        newItems.splice(selectedIndex, 1);\n        onChange(newItems);\n        setSelectedId(null);\n      }\n    }\n  }, [items, onChange, selectedIndex, selectedItem, idField, nameField]);\n\n  // Add a new item (using createItem factory if provided)\n  const handleAdd = useCallback((newItem) => {\n    const itemToAdd = newItem || (createItem ? createItem() : { [idField]: `item_${Date.now()}` });\n    onChange([...items, itemToAdd]);\n    setSelectedId(itemToAdd[idField] || null);\n  }, [items, onChange, createItem, idField]);\n\n  // Select an item by index\n  const handleSelect = useCallback((index) => {\n    const item = items[index];\n    setSelectedId(item ? item[idField] : null);\n  }, [items, idField]);\n\n  // Close the selection (deselect)\n  const handleClose = useCallback(() => {\n    setSelectedId(null);\n  }, []);\n\n  return {\n    selectedIndex,\n    selectedItem,\n    handleItemChange,\n    handleToggle,\n    handleDelete,\n    handleAdd,\n    handleSelect,\n    handleClose,\n  };\n}", "parameters": [{"name": "items", "type": "any", "optional": false}, {"name": "onChange", "type": "any", "optional": false}, {"name": "options", "type": "{}", "optional": true}], "returnType": "{ selectedIndex: any; selectedItem: any; handleItemChange: any; handleToggle: any; handleDelete: any; handleAdd: any; handleSelect: any; handleClose: any; }", "jsxTree": null, "hookCalls": [{"name": "useState", "count": 1}, {"name": "useEffect", "count": 2}, {"name": "useCallback", "count": 6}], "imports": [], "storeAccess": []}]