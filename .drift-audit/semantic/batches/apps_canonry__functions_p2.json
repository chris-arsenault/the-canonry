[{"id": "apps/canonry/webui/src/storage/db.js::createEmptyProject", "name": "createEmptyProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/db.js", "sourceCode": "/**\n * Create a new empty project with default structure.\n */\nexport function createEmptyProject(name = \"New World\") {\n  return {\n    id: `project_${Date.now()}`,\n    name,\n    version: \"1.0\",\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    // Schema (Enumerist)\n    entityKinds: [],\n    relationshipKinds: [],\n    // Cultures (Enumerist + Name Forge + Cosmographer)\n    cultures: [],\n    // Tag Registry (Enumerist)\n    tagRegistry: [],\n    // Axis definitions (Cosmographer)\n    axisDefinitions: [],\n    // UI configuration (Archivist + UI hints)\n    uiConfig: DEFAULT_UI_CONFIG,\n    // Temporal structure (Cosmographer)\n    eras: [],\n    // Simulation config (Coherence Engine)\n    pressures: [],\n    generators: [],\n    systems: [],\n    actions: [],\n    // Seed data (Cosmographer)\n    seedEntities: [],\n    seedRelationships: [],\n    // Distribution targets (Lore Weave)\n    distributionTargets: null,\n    // Simulation (Simulation Workshop) - optional, undefined until configured\n    simulation: undefined,\n  };\n}", "parameters": [{"name": "name", "type": "string", "optional": true}], "returnType": "{ id: string; name: string; version: string; createdAt: string; updatedAt: string; entityKinds: any[]; relationshipKinds: any[]; cultures: any[]; tagRegistry: any[]; axisDefinitions: any[]; uiConfig: { worldIcon: string; prominenceLevels: string[]; prominenceColors: { forgotten: string; marginal: string; recognized: string; renowned: string; mythic: string; }; }; eras: any[]; pressures: any[]; generators: any[]; systems: any[]; actions: any[]; seedEntities: any[]; seedRelationships: any[]; distributionTargets: any; simulation: any; }"}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::importEntities", "name": "importEntities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function importEntities(simulationRunId, entities) {\n  if (!simulationRunId || !Array.isArray(entities) || entities.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(ENTITIES_STORE_NAME)) {\n      throw new Error(\"Illuminator entities store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n\n      for (const entity of entities) {\n        if (!entity?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...entity,\n          simulationRunId: entity.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(entity.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n\n          const merged = mergeDefined(existing, incoming);\n          const incomingEnrichment = incoming.enrichment || {};\n          const existingEnrichment = existing.enrichment || {};\n\n          merged.enrichment = { ...existingEnrichment, ...incomingEnrichment };\n          merged.summary = incoming.summary ?? existing.summary;\n          merged.description = incoming.description ?? existing.description;\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "entities", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/entityStorage.js::getEntityCountForRun", "name": "getEntityCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/entityStorage.js", "sourceCode": "export async function getEntityCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(ENTITIES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(ENTITIES_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count entities\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eraNarrativeStorage.js::getCompletedEraNarrativesForSimulation", "name": "getCompletedEraNarrativesForSimulation", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eraNarrativeStorage.js", "sourceCode": "export async function getCompletedEraNarrativesForSimulation(simulationRunId) {\n  if (!simulationRunId) return [];\n\n  try {\n    const db = await openIlluminatorDb();\n    try {\n      // Check if the store exists (older DB versions may not have it)\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        return [];\n      }\n\n      return await new Promise((resolve, reject) => {\n        const tx = db.transaction(STORE_NAME, \"readonly\");\n        const store = tx.objectStore(STORE_NAME);\n        const index = store.index(\"simulationRunId\");\n        const request = index.getAll(IDBKeyRange.only(simulationRunId));\n\n        request.onsuccess = () => {\n          const allRecords = request.result || [];\n          const projected = allRecords.map(projectForExport).filter(Boolean);\n\n          // Keep only the latest completed narrative per era\n          const byEra = new Map();\n          for (const record of projected) {\n            const existing = byEra.get(record.eraId);\n            if (!existing || record.updatedAt > existing.updatedAt) {\n              byEra.set(record.eraId, record);\n            }\n          }\n\n          resolve(Array.from(byEra.values()));\n        };\n\n        request.onerror = () => reject(request.error || new Error(\"Failed to get era narratives\"));\n      });\n    } finally {\n      db.close();\n    }\n  } catch (err) {\n    console.error(\"[eraNarrativeStorage] Failed to load era narratives:\", err);\n    return [];\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::importNarrativeEvents", "name": "importNarrativeEvents", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function importNarrativeEvents(simulationRunId, events) {\n  if (!simulationRunId || !Array.isArray(events) || events.length === 0) {\n    return { imported: 0, overwritten: 0, skipped: 0 };\n  }\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(EVENTS_STORE_NAME)) {\n      throw new Error(\"Illuminator narrativeEvents store is unavailable.\");\n    }\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n\n      for (const event of events) {\n        if (!event?.id) {\n          skipped += 1;\n          continue;\n        }\n\n        const incoming = {\n          ...event,\n          simulationRunId: event.simulationRunId || simulationRunId,\n        };\n\n        const req = store.get(event.id);\n        req.onsuccess = () => {\n          const existing = req.result || {};\n          if (req.result) overwritten += 1;\n          const merged = mergeDefined(existing, incoming);\n          merged.simulationRunId =\n            incoming.simulationRunId || existing.simulationRunId || simulationRunId;\n          store.put(merged);\n          imported += 1;\n        };\n        req.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}, {"name": "events", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/eventStorage.js::getNarrativeEventCountForRun", "name": "getNarrativeEventCountForRun", "kind": "function", "filePath": "apps/canonry/webui/src/storage/eventStorage.js", "sourceCode": "export async function getNarrativeEventCountForRun(simulationRunId) {\n  if (!simulationRunId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(EVENTS_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(EVENTS_STORE_NAME);\n      const index = store.index(\"simulationRunId\");\n      const request = index.count(simulationRunId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () =>\n        reject(request.error || new Error(\"Failed to count narrative events\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "simulationRunId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::importBundleImageReferences", "name": "importBundleImageReferences", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function importBundleImageReferences({ projectId, imageData, images } = {}) {\n  if (!projectId) return { imported: 0, skipped: 0 };\n  const results = Array.isArray(imageData?.results) ? imageData.results : [];\n  if (results.length === 0) return { imported: 0, skipped: 0 };\n\n  const db = await openIlluminatorDb();\n  let imported = 0;\n  let overwritten = 0;\n  let skipped = 0;\n\n  try {\n    if (!db.objectStoreNames.contains(IMAGES_STORE_NAME)) {\n      throw new Error(\"Illuminator images store is unavailable.\");\n    }\n\n    const now = Date.now();\n\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n\n      for (const entry of results) {\n        const imageId = entry?.imageId;\n        if (!imageId) {\n          skipped += 1;\n          continue;\n        }\n\n        const rawPath = (images && images[imageId]) || entry.localPath;\n        const sourcePath = normalizeSourcePath(rawPath);\n        const mimeType = inferMimeType(sourcePath);\n        const incomingEntityId = entry.entityId || entry.chronicleId || null;\n\n        const getReq = store.get(imageId);\n        getReq.onsuccess = () => {\n          const existing = getReq.result || {};\n          if (getReq.result) overwritten += 1;\n          const merged = {\n            ...existing,\n            imageId,\n            projectId,\n            entityId: incomingEntityId ?? existing.entityId ?? \"chronicle\",\n            entityName: entry.entityName ?? existing.entityName,\n            entityKind: entry.entityKind ?? existing.entityKind,\n            entityCulture: entry.entityCulture ?? existing.entityCulture,\n            originalPrompt: entry.prompt ?? existing.originalPrompt,\n            finalPrompt: entry.prompt ?? existing.finalPrompt,\n            imageType: entry.imageType ?? existing.imageType,\n            chronicleId: entry.chronicleId ?? existing.chronicleId,\n            imageRefId: entry.imageRefId ?? existing.imageRefId,\n            sceneDescription: entry.sceneDescription ?? existing.sceneDescription,\n            generatedAt: existing.generatedAt ?? now,\n            model: existing.model || \"imported\",\n            mimeType: existing.mimeType || mimeType,\n            size: typeof existing.size === \"number\" ? existing.size : 0,\n            savedAt: existing.savedAt ?? now,\n          };\n\n          store.put(merged);\n          imported += 1;\n        };\n        getReq.onerror = () => {\n          skipped += 1;\n        };\n      }\n\n      tx.oncomplete = () => resolve({ imported, overwritten, skipped });\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import image references\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "{ projectId, imageData, images }", "type": "{}", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/imageStorage.js::getImageCountForProject", "name": "getImageCountForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/imageStorage.js", "sourceCode": "export async function getImageCountForProject(projectId) {\n  if (!projectId) return 0;\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(IMAGES_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(IMAGES_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const request = index.count(projectId);\n      request.onsuccess = () => resolve(request.result || 0);\n      request.onerror = () => reject(request.error || new Error(\"Failed to count images\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlots", "name": "getRunSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlots(projectId) {\n  if (!projectId) return {};\n  const records = await idbGetByProject(projectId);\n  return records.reduce((acc, record) => {\n    acc[record.slotIndex] = stripRunRecord(record);\n    return acc;\n  }, {});\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::getRunSlot", "name": "getRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function getRunSlot(projectId, slotIndex) {\n  if (!projectId) return null;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = await idbGet(projectId, normalized);\n  return stripRunRecord(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::saveRunSlot", "name": "saveRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function saveRunSlot(projectId, slotIndex, slotData) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  const record = {\n    projectId,\n    slotIndex: normalized,\n    ...slotData,\n  };\n  await idbSet(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlot", "name": "deleteRunSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlot(projectId, slotIndex) {\n  if (!projectId) return;\n  const normalized = normalizeSlotIndex(slotIndex);\n  await idbDelete(projectId, normalized);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/runStore.js::deleteRunSlotsForProject", "name": "deleteRunSlotsForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/runStore.js", "sourceCode": "export async function deleteRunSlotsForProject(projectId) {\n  if (!projectId) return;\n  await idbDeleteProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::getStaticPagesForProject", "name": "getStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "// ============================================================================\n// Storage Operations\n// ============================================================================\n\n/**\n * Get all static pages for a project (both draft and published)\n */\nexport async function getStaticPagesForProject(projectId) {\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readonly\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n      const index = store.index(\"projectId\");\n      const req = index.getAll(projectId);\n      req.onsuccess = () => {\n        const pages = req.result || [];\n        pages.sort((a, b) => b.updatedAt - a.updatedAt);\n        resolve(pages);\n      };\n      req.onerror = () => reject(req.error || new Error(\"Failed to get static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::importStaticPages", "name": "importStaticPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Import static pages into a project (used during project import)\n * This replaces all existing pages for the project.\n *\n * @param {string} projectId - The project ID to import pages into\n * @param {Array} pages - Array of page objects to import\n * @param {Object} options - Import options\n * @param {boolean} options.preserveIds - If true, use page IDs from import data\n */\nexport async function importStaticPages(projectId, pages, options = {}) {\n  if (!Array.isArray(pages) || pages.length === 0) {\n    return 0;\n  }\n\n  const db = await openIlluminatorDb();\n  const now = Date.now();\n\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      let importedCount = 0;\n\n      for (const pageData of pages) {\n        const page = {\n          pageId: options.preserveIds && pageData.pageId ? pageData.pageId : generatePageId(),\n          projectId,\n          title: pageData.title || \"Untitled\",\n          slug: pageData.slug || generateSlug(pageData.title || \"untitled\"),\n          content: pageData.content || \"\",\n          summary: pageData.summary,\n          status: pageData.status || \"draft\",\n          createdAt: pageData.createdAt || now,\n          updatedAt: pageData.updatedAt || now,\n          linkedEntityIds: extractEntityLinks(pageData.content || \"\"),\n          wordCount: countWords(pageData.content || \"\"),\n        };\n\n        store.put(page);\n        importedCount++;\n      }\n\n      tx.oncomplete = () => resolve(importedCount);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to import static pages\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "string", "optional": false}, {"name": "pages", "type": "any[]", "optional": false}, {"name": "options", "type": "{ preserveIds: boolean; }", "optional": true}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::deleteStaticPagesForProject", "name": "deleteStaticPagesForProject", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Delete all static pages for a project\n */\nexport async function deleteStaticPagesForProject(projectId) {\n  const pages = await getStaticPagesForProject(projectId);\n  if (pages.length === 0) return 0;\n\n  const db = await openIlluminatorDb();\n  try {\n    return await new Promise((resolve, reject) => {\n      const tx = db.transaction(STATIC_PAGE_STORE_NAME, \"readwrite\");\n      const store = tx.objectStore(STATIC_PAGE_STORE_NAME);\n\n      for (const page of pages) {\n        store.delete(page.pageId);\n      }\n\n      tx.oncomplete = () => resolve(pages.length);\n      tx.onerror = () => reject(tx.error || new Error(\"Failed to delete static pages for project\"));\n    });\n  } finally {\n    db.close();\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/staticPageStorage.js::loadAndImportSeedPages", "name": "loadAndImportSeedPages", "kind": "function", "filePath": "apps/canonry/webui/src/storage/staticPageStorage.js", "sourceCode": "/**\n * Load seed pages from staticPages.json and import them\n * Used when reloading defaults\n */\nexport async function loadAndImportSeedPages(projectId, seedPagesUrl) {\n  const url = seedPagesUrl || `${import.meta.env.BASE_URL}default-project/staticPages.json`;\n\n  let seedPages;\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.log(\"No seed pages file found\");\n      return 0;\n    }\n    seedPages = await response.json();\n  } catch (err) {\n    console.log(\"Failed to load seed pages:\", err);\n    return 0;\n  }\n\n  if (!Array.isArray(seedPages) || seedPages.length === 0) {\n    return 0;\n  }\n\n  // Convert seed pages to import format\n  const pagesToImport = seedPages.map((seed) => ({\n    title: seed.title,\n    slug: seed.slug,\n    content: seed.content,\n    summary: seed.summary,\n    status: seed.status || \"published\",\n  }));\n\n  // Clear existing pages and import fresh\n  await deleteStaticPagesForProject(projectId);\n  return importStaticPages(projectId, pagesToImport);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "seedPagesUrl", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadUiState", "name": "loadUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadUiState() {\n  if (!canUseStorage()) return null;\n  try {\n    const raw = localStorage.getItem(UI_STATE_KEY);\n    if (!raw) return null;\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "any"}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveUiState", "name": "saveUiState", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveUiState(state) {\n  if (!canUseStorage()) return;\n  try {\n    localStorage.setItem(UI_STATE_KEY, JSON.stringify(state));\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "state", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/storage/uiState.js::loadLastProjectId", "name": "loadLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function loadLastProjectId() {\n  if (!canUseStorage()) return null;\n  try {\n    return localStorage.getItem(LAST_PROJECT_KEY);\n  } catch {\n    return null;\n  }\n}", "parameters": [], "returnType": "string"}, {"id": "apps/canonry/webui/src/storage/uiState.js::saveLastProjectId", "name": "saveLastProjectId", "kind": "function", "filePath": "apps/canonry/webui/src/storage/uiState.js", "sourceCode": "export function saveLastProjectId(projectId) {\n  if (!canUseStorage()) return;\n  try {\n    if (projectId) {\n      localStorage.setItem(LAST_PROJECT_KEY, projectId);\n    } else {\n      localStorage.removeItem(LAST_PROJECT_KEY);\n    }\n  } catch {\n    // Best-effort only.\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "void"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldStore", "name": "loadWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Public API - Core Store Operations\n// =============================================================================\n\n/**\n * Load all persisted data for a project\n */\nexport async function loadWorldStore(projectId) {\n  if (!projectId) return null;\n  let record = null;\n  try {\n    record = await idbGet(projectId);\n  } catch {\n    // Fall back to localStorage\n    record = lsGet(projectId);\n  }\n  if (!record) record = lsGet(projectId);\n  return normalizeWorldStore(record);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldStore", "name": "saveWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save all data for a project (merges with existing)\n */\nexport async function saveWorldStore(projectId, data) {\n  if (!projectId) return;\n  let existing = null;\n  try {\n    existing = await idbGet(projectId);\n  } catch {\n    existing = null;\n  }\n\n  const merged = { ...(normalizeWorldStore(existing) || { activeSlotIndex: 0 }), ...data };\n  delete merged.projectId;\n  delete merged.slots;\n\n  try {\n    await idbSet(projectId, merged);\n  } catch {\n    const localExisting = normalizeWorldStore(lsGet(projectId)) || { activeSlotIndex: 0 };\n    const localMerged = { ...localExisting, ...data };\n    delete localMerged.slots;\n    lsSet(projectId, localMerged);\n  }\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "data", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearWorldStore", "name": "clearWorldStore", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear all persisted data for a project\n */\nexport async function clearWorldStore(projectId) {\n  if (!projectId) return;\n  try {\n    await idbDelete(projectId);\n  } catch {\n    // Ignore\n  }\n  lsDelete(projectId);\n  await deleteRunSlotsForProject(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlotIndex", "name": "getActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Slot Operations\n// =============================================================================\n\n/**\n * Get the active slot index for a project\n */\nexport async function getActiveSlotIndex(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.activeSlotIndex ?? 0;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::setActiveSlotIndex", "name": "setActiveSlotIndex", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Set the active slot index for a project\n */\nexport async function setActiveSlotIndex(projectId, slotIndex) {\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlots", "name": "getSlots", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get all slots for a project\n */\nexport async function getSlots(projectId) {\n  await loadWorldStore(projectId);\n  return getRunSlots(projectId);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getSlot", "name": "getSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for a specific slot\n */\nexport async function getSlot(projectId, slotIndex) {\n  await loadWorldStore(projectId);\n  return getRunSlot(projectId, slotIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getActiveSlot", "name": "getActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get data for the currently active slot\n */\nexport async function getActiveSlot(projectId) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  return getSlot(projectId, activeIndex);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSlot", "name": "saveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to a specific slot\n */\nexport async function saveSlot(projectId, slotIndex, slotData) {\n  await saveRunSlot(projectId, slotIndex, slotData);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToActiveSlot", "name": "saveToActiveSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save data to the currently active slot (merges with existing slot data)\n */\nexport async function saveToActiveSlot(projectId, slotData) {\n  const activeIndex = await getActiveSlotIndex(projectId);\n  const existingSlot = (await getSlot(projectId, activeIndex)) || {};\n  const updatedSlot = { ...existingSlot, ...slotData };\n  await saveRunSlot(projectId, activeIndex, updatedSlot);\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveToSlot", "name": "saveToSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Move data from scratch (slot 0) to a save slot (1-4)\n * Clears scratch and switches active to the target slot\n */\nexport async function saveToSlot(projectId, targetSlotIndex) {\n  if (targetSlotIndex < 1 || targetSlotIndex > MAX_SAVE_SLOTS) {\n    throw new Error(`Invalid save slot: ${targetSlotIndex}. Must be 1-${MAX_SAVE_SLOTS}`);\n  }\n\n  const scratchData = await getSlot(projectId, 0);\n\n  if (!scratchData || !scratchData.simulationResults) {\n    throw new Error(\"No data in scratch slot to save\");\n  }\n\n  // Generate title if not present\n  const title =\n    scratchData.title && scratchData.title !== \"Scratch\"\n      ? scratchData.title\n      : generateSlotTitle(targetSlotIndex);\n\n  // Move data to target slot\n  await saveRunSlot(projectId, targetSlotIndex, { ...scratchData, title, savedAt: Date.now() });\n  await deleteRunSlot(projectId, 0);\n  await saveWorldStore(projectId, { activeSlotIndex: targetSlotIndex });\n\n  return targetSlotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "targetSlotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSlot", "name": "loadSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load a saved slot by switching active index\n */\nexport async function loadSlot(projectId, slotIndex) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} is empty`);\n  }\n  await saveWorldStore(projectId, { activeSlotIndex: slotIndex });\n  return slotIndex;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::clearSlot", "name": "clearSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Clear a specific slot\n */\nexport async function clearSlot(projectId, slotIndex) {\n  const store = (await loadWorldStore(projectId)) || { activeSlotIndex: 0 };\n  await deleteRunSlot(projectId, slotIndex);\n\n  const slots = await getSlots(projectId);\n\n  // Determine new active slot index\n  let newActiveSlotIndex = store.activeSlotIndex ?? 0;\n  if (newActiveSlotIndex === slotIndex) {\n    // If clearing the active slot:\n    // - If it's slot 0 (scratch), stay on 0 (scratch is conceptually always available)\n    // - Otherwise, switch to scratch (0) or first available slot\n    if (slotIndex === 0) {\n      newActiveSlotIndex = 0;\n    } else {\n      // Find first available slot (prefer scratch if it exists, otherwise first saved slot)\n      const availableSlots = Object.keys(slots)\n        .map(Number)\n        .sort((a, b) => a - b);\n      newActiveSlotIndex = availableSlots.length > 0 ? availableSlots[0] : 0;\n    }\n  }\n\n  await saveWorldStore(projectId, { activeSlotIndex: newActiveSlotIndex });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::updateSlotTitle", "name": "updateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Update the title of a slot\n */\nexport async function updateSlotTitle(projectId, slotIndex, title) {\n  const slot = await getSlot(projectId, slotIndex);\n  if (!slot) {\n    throw new Error(`Slot ${slotIndex} does not exist`);\n  }\n  await saveRunSlot(projectId, slotIndex, { ...slot, title });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "slotIndex", "type": "any", "optional": false}, {"name": "title", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::getNextAvailableSlot", "name": "getNextAvailableSlot", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Get the next available save slot (1-4), or null if all full\n */\nexport async function getNextAvailableSlot(projectId) {\n  const slots = await getSlots(projectId);\n  for (let i = 1; i <= MAX_SAVE_SLOTS; i++) {\n    if (!slots[i]) return i;\n  }\n  return null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<number>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::generateSlotTitle", "name": "generateSlotTitle", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Generate a default title for a slot\n */\nexport function generateSlotTitle(slotIndex, timestamp = Date.now()) {\n  const date = new Date(timestamp);\n  const formatted = date.toLocaleString(\"en-US\", {\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  });\n  return `Run ${slotIndex} - ${formatted}`;\n}", "parameters": [{"name": "slotIndex", "type": "any", "optional": false}, {"name": "timestamp", "type": "number", "optional": true}], "returnType": "string"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveSimulationData", "name": "saveSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "// =============================================================================\n// Convenience methods - operate on active slot\n// =============================================================================\n\n/**\n * Save simulation run data to the active slot\n */\nexport async function saveSimulationData(projectId, { simulationResults, simulationState }) {\n  // Always write new simulations to scratch (slot 0)\n  const existingSlot = (await getSlot(projectId, 0)) || {};\n  const updatedSlot = { ...existingSlot, simulationResults, simulationState };\n  await saveRunSlot(projectId, 0, updatedSlot);\n  await saveWorldStore(projectId, { activeSlotIndex: 0 });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "{ simulationResults, simulationState }", "type": "{ simulationResults: any; simulationState: any; }", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadSimulationData", "name": "loadSimulationData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load simulation run data from the active slot\n */\nexport async function loadSimulationData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return {\n    simulationResults: slot?.simulationResults || null,\n    simulationState: slot?.simulationState || null,\n  };\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<{ simulationResults: any; simulationState: any; }>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldData", "name": "saveWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save world data to the active slot\n */\nexport async function saveWorldData(projectId, worldData) {\n  await saveToActiveSlot(projectId, { worldData });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldData", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldData", "name": "loadWorldData", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load world data from the active slot\n */\nexport async function loadWorldData(projectId) {\n  const slot = await getActiveSlot(projectId);\n  return slot?.worldData || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveWorldContext", "name": "saveWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator world context (shared across slots)\n */\nexport async function saveWorldContext(projectId, worldContext) {\n  await saveWorldStore(projectId, { worldContext });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "worldContext", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadWorldContext", "name": "loadWorldContext", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator world context\n */\nexport async function loadWorldContext(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.worldContext || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEnrichmentConfig", "name": "saveEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator enrichment config (shared across slots)\n */\nexport async function saveEnrichmentConfig(projectId, enrichmentConfig) {\n  await saveWorldStore(projectId, { enrichmentConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "enrichmentConfig", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadEnrichmentConfig", "name": "loadEnrichmentConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator enrichment config\n */\nexport async function loadEnrichmentConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.enrichmentConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveEntityGuidance", "name": "saveEntityGuidance", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save entity guidance (shared across slots)\n */\nexport async function saveEntityGuidance(projectId, entityGuidance) {\n  await saveWorldStore(projectId, { entityGuidance });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "entityGuidance", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveCultureIdentities", "name": "saveCultureIdentities", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save culture identities (shared across slots)\n */\nexport async function saveCultureIdentities(projectId, cultureIdentities) {\n  await saveWorldStore(projectId, { cultureIdentities });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "cultureIdentities", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveStyleSelection", "name": "saveStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save Illuminator style selection (shared across slots)\n */\nexport async function saveStyleSelection(projectId, styleSelection) {\n  await saveWorldStore(projectId, { styleSelection });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "styleSelection", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::saveHistorianConfig", "name": "saveHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Save historian persona config (shared across slots)\n */\nexport async function saveHistorianConfig(projectId, historianConfig) {\n  await saveWorldStore(projectId, { historianConfig });\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}, {"name": "historianConfig", "type": "any", "optional": false}], "returnType": "Promise<void>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadHistorianConfig", "name": "loadHistorianConfig", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load historian persona config\n */\nexport async function loadHistorianConfig(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.historianConfig || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/storage/worldStore.js::loadStyleSelection", "name": "loadStyleSelection", "kind": "function", "filePath": "apps/canonry/webui/src/storage/worldStore.js", "sourceCode": "/**\n * Load Illuminator style selection\n */\nexport async function loadStyleSelection(projectId) {\n  const store = await loadWorldStore(projectId);\n  return store?.styleSelection || null;\n}", "parameters": [{"name": "projectId", "type": "any", "optional": false}], "returnType": "Promise<any>"}, {"id": "apps/canonry/webui/src/stores/useCanonryUiStore.js::selectActiveSection", "name": "selectActiveSection", "kind": "function", "filePath": "apps/canonry/webui/src/stores/useCanonryUiStore.js", "sourceCode": "/** Selector for the computed activeSection */\r\nexport function selectActiveSection(s) {\r\n  return s.activeTab ? (s.activeSectionByTab[s.activeTab] ?? null) : null;\r\n}", "parameters": [{"name": "s", "type": "any", "optional": false}], "returnType": "any"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/CultureEditor.jsx", "sourceCode": "export default function CultureEditor({ cultures, onChange }) {\n  const [expandedCultures, setExpandedCultures] = useState({});\n\n  const getStableKey = (culture) => culture._key || culture.id;\n\n  const toggleCulture = useCallback((stableKey) => {\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addCulture = () => {\n    const stableKey = `culture_${Date.now()}`;\n    const newCulture = {\n      id: stableKey,\n      name: \"New Culture\",\n      description: \"\",\n      color: PRESET_COLORS[cultures.length % PRESET_COLORS.length],\n      _key: stableKey,\n    };\n    onChange([...cultures, newCulture]);\n    setExpandedCultures((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateCulture = (cultureId, updates) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    onChange(cultures.map((c) => (c.id === cultureId ? { ...c, ...updates } : c)));\n  };\n\n  const deleteCulture = (cultureId) => {\n    const existing = cultures.find((c) => c.id === cultureId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this culture?\")) {\n      onChange(cultures.filter((c) => c.id !== cultureId));\n    }\n  };\n\n  const getCultureSummary = (culture) => {\n    const parts = [];\n    if (culture.naming?.domains?.length) parts.push(`${culture.naming.domains.length} domains`);\n    if (culture.axisBiases && Object.keys(culture.axisBiases).length) parts.push(\"axis biases\");\n    return parts.length > 0 ? parts.join(\", \") : \"not configured\";\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addCulture}>\n      + Add Culture\n    </button>\n  );\n\n  const renderCultureTitle = (culture) => (\n    <span className=\"ced-title-wrapper\">\n      <span\n        className=\"ced-color-swatch\"\n        style={{ '--ced-swatch-color': culture.color }}\n      />\n      {culture.name}\n    </span>\n  );\n\n  const renderCultureActions = (culture, isFramework) => (\n    <span className=\"text-muted text-small\">\n      {getCultureSummary(culture)}\n      {isFramework && (\n        <span className=\"badge badge-info ced-framework-badge\">\n          framework\n        </span>\n      )}\n    </span>\n  );\n\n  return (\n    <div className=\"editor-container ced-container\">\n      <SectionHeader\n        title=\"Cultures\"\n        description=\"Define cultural groups with their own naming conventions and placement biases.\"\n        count={cultures.length}\n        actions={renderHeaderActions()}\n      />\n\n      {cultures.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83c\udfad\"\n          title=\"No cultures defined\"\n          description=\"Add one to give your world cultural diversity.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {cultures.map((culture) => {\n            const stableKey = getStableKey(culture);\n            const isExpanded = expandedCultures[stableKey];\n            const isFramework = Boolean(culture.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleCulture}\n                toggleId={stableKey}\n                title={renderCultureTitle(culture)}\n                subtitle={culture.id}\n                actions={renderCultureActions(culture, isFramework)}\n              >\n                {/* Name and ID */}\n                <FormRow>\n                  <FormGroup label=\"Name\">\n                    <input\n                      className=\"input\"\n                      value={culture.name}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { name: e.target.value })}\n                      placeholder=\"Culture name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"ID\">\n                    <input\n                      className=\"input\"\n                      value={culture.id}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newId = e.target.value.toLowerCase().replace(/[^a-z0-9-_]/g, \"\");\n                        if (newId && !cultures.some((c) => c.id === newId && c.id !== culture.id)) {\n                          updateCulture(culture.id, { id: newId });\n                        }\n                      }}\n                      placeholder=\"culture-id\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                <FormRow>\n                  <FormGroup label=\"Description\" wide>\n                    <input\n                      className=\"input\"\n                      value={culture.description || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateCulture(culture.id, { description: e.target.value })}\n                      placeholder=\"Optional description\"\n                    />\n                  </FormGroup>\n                </FormRow>\n\n                {/* Color Selection */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Color</div>\n                  <div className=\"ced-color-row\">\n                    <div\n                      className=\"ced-color-preview\"\n                      style={{ '--ced-preview-color': culture.color }}\n                    />\n                    <div className=\"chip-list\">\n                      {PRESET_COLORS.map((color) => (\n                        <div\n                          key={color}\n                          className={`chip chip-clickable ced-color-chip ${culture.color === color ? \"chip-active\" : \"\"}`}\n                          style={{\n                            '--ced-chip-bg': color,\n                            '--ced-chip-border': culture.color === color ? '#fff' : 'transparent',\n                            '--ced-chip-opacity': isFramework ? 0.6 : 1,\n                            '--ced-chip-pointer': isFramework ? 'none' : 'auto',\n                          }}\n                          onClick={() => updateCulture(culture.id, { color })}\n                          role=\"button\"\n                          tabIndex={0}\n                          onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                        />\n                      ))}\n                    </div>\n                  </div>\n                </div>\n\n                {/* Info about other editors */}\n                <InfoBox title=\"Additional configuration\">\n                  <ul className=\"ced-info-list\">\n                    <li>\n                      <strong>Names tab</strong> \u2014 Configure naming domains, grammars, and profiles\n                    </li>\n                    <li>\n                      <strong>Cosmography tab</strong> \u2014 Configure axis biases and home regions\n                    </li>\n                  </ul>\n                </InfoBox>\n\n                {/* Actions */}\n                <div className=\"danger-zone\">\n                  <div className=\"ced-action-badges\">\n                    {culture.naming && <span className=\"badge\">has naming</span>}\n                    {culture.axisBiases && <span className=\"badge\">has biases</span>}\n                  </div>\n                  <button\n                    className=\"btn btn-danger\"\n                    onClick={() => deleteCulture(culture.id)}\n                    disabled={isFramework}\n                  >\n                    Delete Culture\n                  </button>\n                </div>\n              </ExpandableCard>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}", "parameters": [{"name": "{ cultures, onChange }", "type": "{ cultures: any; onChange: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/EntityKindEditor.jsx", "sourceCode": "export default function EntityKindEditor({\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}) {\n  const [expandedKinds, setExpandedKinds] = useState({});\n  const [newSubtype, setNewSubtype] = useState({});\n  const [newStatus, setNewStatus] = useState({});\n\n  const namingProfileUsage = useMemo(() => computeNamingProfileUsage(namingData), [namingData]);\n\n  const getNamingProfileCount = (kind) => {\n    const specific = namingProfileUsage[kind]?.profiles?.length || 0;\n    const wildcard = namingProfileUsage[\"*\"]?.profiles?.length || 0;\n    return specific + wildcard;\n  };\n\n  const getStableKey = (ek) => ek._key || ek.kind;\n\n  const toggleKind = useCallback((stableKey) => {\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addEntityKind = () => {\n    const stableKey = `kind_${Date.now()}`;\n    const newKind = {\n      kind: stableKey,\n      description: \"New Entity Kind\",\n      subtypes: [],\n      statuses: [{ id: \"active\", name: \"Active\", isTerminal: false }],\n      defaultStatus: \"active\",\n      style: { color: getDefaultKindColor(stableKey, entityKinds.length) },\n      _key: stableKey,\n    };\n    onChange([...entityKinds, newKind]);\n    setExpandedKinds((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateKind = (kindKey, updates) => {\n    const existing = entityKinds.find((k) => k.kind === kindKey);\n    if (existing?.isFramework) return;\n    onChange(entityKinds.map((k) => (k.kind === kindKey ? { ...k, ...updates } : k)));\n  };\n\n  const updateKindStyle = (kindKey, updates) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (!kind) return;\n    updateKind(kindKey, { style: { ...(kind.style || {}), ...updates } });\n  };\n\n  const deleteKind = (kindKey) => {\n    const kind = entityKinds.find((k) => k.kind === kindKey);\n    if (kind?.isFramework) return;\n    if (confirm(\"Delete this entity kind? This cannot be undone.\")) {\n      onChange(entityKinds.filter((k) => k.kind !== kindKey));\n    }\n  };\n\n  const addSubtype = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newSubtype[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const subtype = { id: generateId(name), name };\n    updateKind(kindKey, { subtypes: [...ek.subtypes, subtype] });\n    setNewSubtype((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeSubtype = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { subtypes: ek.subtypes.filter((s) => s.id !== subtypeId) });\n  };\n\n  const addStatus = (kindKey) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const name = newStatus[kindKey]?.trim();\n    if (!name) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    const status = { id: generateId(name), name, isTerminal: false, polarity: \"neutral\" };\n    updateKind(kindKey, { statuses: [...ek.statuses, status] });\n    setNewStatus((prev) => ({ ...prev, [kindKey]: \"\" }));\n  };\n\n  const removeStatus = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, { statuses: ek.statuses.filter((s) => s.id !== statusId) });\n  };\n\n  const toggleStatusTerminal = (kindKey, statusId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, isTerminal: !s.isTerminal } : s\n      ),\n    });\n  };\n\n  const updateStatusPolarity = (kindKey, statusId, polarity) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) => (s.id === statusId ? { ...s, polarity } : s)),\n    });\n  };\n\n  const updateStatusTransitionVerb = (kindKey, statusId, transitionVerb) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      statuses: ek.statuses.map((s) =>\n        s.id === statusId ? { ...s, transitionVerb: transitionVerb || undefined } : s\n      ),\n    });\n  };\n\n  const toggleSubtypeAuthority = (kindKey, subtypeId) => {\n    if (entityKinds.find((k) => k.kind === kindKey)?.isFramework) return;\n    const ek = entityKinds.find((k) => k.kind === kindKey);\n    if (!ek) return;\n    updateKind(kindKey, {\n      subtypes: ek.subtypes.map((s) =>\n        s.id === subtypeId ? { ...s, isAuthority: !s.isAuthority } : s\n      ),\n    });\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addEntityKind}>\n      + Add Entity Kind\n    </button>\n  );\n\n  const renderKindActions = (kind, profileCount, isFramework) => (\n    <>\n      <UsageBadges usage={getEntityKindUsageSummary(schemaUsage, kind.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {profileCount > 0 && (\n        <span\n          className=\"badge badge-warning\"\n          title={`Used in ${profileCount} naming profile group${profileCount !== 1 ? \"s\" : \"\"}`}\n        >\n          \u270e {profileCount}\n        </span>\n      )}\n      <span className=\"text-muted text-small\">\n        {kind.subtypes.length} subtypes, {kind.statuses.length} statuses\n      </span>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container eke-container\">\n      <SectionHeader\n        title=\"Entity Kinds\"\n        description=\"Define the types of entities that exist in your world.\"\n        count={entityKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {entityKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udce6\"\n          title=\"No entity kinds defined\"\n          description=\"Add one to get started.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {entityKinds.map((ek) => {\n            const stableKey = getStableKey(ek);\n            const isExpanded = expandedKinds[stableKey];\n            const profileCount = getNamingProfileCount(ek.kind);\n            const kindColor = ek.style?.color;\n            const isFramework = Boolean(ek.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleKind}\n                toggleId={stableKey}\n                title={ek.description}\n                subtitle={ek.kind}\n                actions={renderKindActions(ek, profileCount, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <FormRow>\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={ek.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateKind(ek.kind, { description: e.target.value })}\n                      placeholder=\"Entity kind display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={ek.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !entityKinds.some((k) => k.kind === newKind && k.kind !== ek.kind)\n                        ) {\n                          updateKind(ek.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"entity_kind_id\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Color\">\n                    <input\n                      className=\"input\"\n                      type=\"color\"\n                      value={kindColor ?? \"#000000\"}\n                      disabled={isFramework}\n                      onChange={(e) => updateKindStyle(ek.kind, { color: e.target.value })}\n                    />\n                    {!kindColor && (\n                      <div className=\"eke-color-missing\">\n                        Color required\n                      </div>\n                    )}\n                  </FormGroup>\n                  <FormGroup\n                    label=\"Category\"\n                    tooltip=\"Abstract category for narrative style recommendations\"\n                  >\n                    <select\n                      className=\"input\"\n                      value={ek.category || \"\"}\n                      disabled={isFramework}\n                      onChange={(e) =>\n                        updateKind(ek.kind, { category: e.target.value || undefined })\n                      }\n                    >\n                      <option value=\"\">-- Not set --</option>\n                      {Object.entries(ENTITY_CATEGORIES).map(([categoryId, categoryInfo]) => (\n                        <option key={categoryId} value={categoryId}>\n                          {categoryInfo.name}\n                        </option>\n                      ))}\n                    </select>\n                  </FormGroup>\n                </FormRow>\n\n                {/* Subtypes */}\n                <div className=\"section\">\n                  <div className=\"section-title\">Subtypes</div>\n                  <div className=\"chip-list\">\n                    {ek.subtypes.map((subtype) => {\n                      const usage = getSubtypeUsage(schemaUsage, ek.kind, subtype.id);\n                      const isUnused = usage.total === 0;\n                      const tooltipParts = [];\n                      if (usage.generators > 0)\n                        tooltipParts.push(\n                          `${usage.generators} generator${usage.generators !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.systems > 0)\n                        tooltipParts.push(\n                          `${usage.systems} system${usage.systems !== 1 ? \"s\" : \"\"}`\n                        );\n                      if (usage.seeds > 0)\n                        tooltipParts.push(`${usage.seeds} seed${usage.seeds !== 1 ? \"s\" : \"\"}`);\n                      const tooltip =\n                        tooltipParts.length > 0\n                          ? tooltipParts.join(\", \")\n                          : \"Not used by any generator, system, or seed\";\n\n                      return (\n                        <div\n                          key={subtype.id}\n                          className={`chip ${isUnused ? \"chip-unused\" : \"\"}`}\n                          title={tooltip}\n                        >\n                          <input\n                            type=\"checkbox\"\n                            checked={subtype.isAuthority || false}\n                            disabled={isFramework}\n                            onChange={() => toggleSubtypeAuthority(ek.kind, subtype.id)}\n                            title=\"Authority subtype (for leadership/succession events)\"\n                          />\n                          <span className=\"chip-content\">\n                            {subtype.name}\n                            {subtype.isAuthority && (\n                              <span className=\"badge badge-warning eke-authority-badge\">\n                                \ud83d\udc51\n// ... (truncated)", "parameters": [{"name": "{\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ entityKinds: any; onChange: any; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/index.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/index.jsx", "sourceCode": "export default function SchemaEditor({\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}) {\n  // Use passed-in activeSection, fallback to entityKinds\n  const currentSection = activeSection || \"entityKinds\";\n  const handleNavigateToRelationship = useCallback(() => {\n    onSectionChange(\"relationshipKinds\");\n  }, [onSectionChange]);\n  const tagRegistryOrEmpty = useMemo(() => project.tagRegistry || [], [project.tagRegistry]);\n\n  const counts = {\n    entityKinds: project.entityKinds.length,\n    relationshipKinds: project.relationshipKinds.length,\n    cultures: project.cultures.length,\n    tagRegistry: (project.tagRegistry || []).length,\n  };\n\n  const renderEditor = () => {\n    switch (currentSection) {\n      case \"entityKinds\":\n        return (\n          <EntityKindEditor\n            entityKinds={project.entityKinds}\n            onChange={onUpdateEntityKinds}\n            schemaUsage={schemaUsage}\n            namingData={namingData}\n          />\n        );\n\n      case \"relationshipKinds\":\n        return (\n          <RelationshipKindEditor\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateRelationshipKinds}\n            schemaUsage={schemaUsage}\n          />\n        );\n\n      case \"relationshipMatrix\":\n        return (\n          <RelationshipKindMatrix\n            relationshipKinds={project.relationshipKinds}\n            entityKinds={project.entityKinds}\n            onNavigateToRelationship={handleNavigateToRelationship}\n          />\n        );\n\n      case \"cultures\":\n        return <CultureEditor cultures={project.cultures} onChange={onUpdateCultures} />;\n\n      case \"tags\":\n        return (\n          <TagRegistryEditor\n            tagRegistry={tagRegistryOrEmpty}\n            entityKinds={project.entityKinds}\n            onChange={onUpdateTagRegistry}\n            tagUsage={tagUsage}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"se-container\">\n      <div className=\"se-sidebar\">\n        <div className=\"se-sidebar-title\">Schema</div>\n        {SECTIONS.map((section) => (\n          <div\n            key={section.id}\n            className={`se-sidebar-item ${section.id === currentSection ? \"se-sidebar-item-active\" : \"se-sidebar-item-inactive\"}`}\n            style={section.id === currentSection ? { '--se-sidebar-active-bg': getAccentGradient(\"enumerist\") } : undefined}\n            onClick={() => onSectionChange(section.id)}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n          >\n            {section.label}\n            {section.countKey && (\n              <span className=\"se-sidebar-count\">{counts[section.countKey]}</span>\n            )}\n          </div>\n        ))}\n      </div>\n      <div className=\"se-main\">{renderEditor()}</div>\n    </div>\n  );\n}", "parameters": [{"name": "{\n  project,\n  activeSection,\n  onSectionChange,\n  onUpdateEntityKinds,\n  onUpdateRelationshipKinds,\n  onUpdateCultures,\n  onUpdateTagRegistry,\n  tagUsage = {},\n  schemaUsage = {},\n  namingData = {},\n}", "type": "{ project: any; activeSection: any; onSectionChange: any; onUpdateEntityKinds: any; onUpdateRelationshipKinds: any; onUpdateCultures: any; onUpdateTagRegistry: any; tagUsage?: {}; schemaUsage?: {}; namingData?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindEditor.jsx", "sourceCode": "export default function RelationshipKindEditor({\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}) {\n  const [expandedRels, setExpandedRels] = useState({});\n\n  const getStableKey = (rel) => rel._key || rel.kind;\n\n  const toggleRel = useCallback((stableKey) => {\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: !prev[stableKey] }));\n  }, []);\n\n  const addRelationship = () => {\n    const stableKey = `rel_${Date.now()}`;\n    const newRel = {\n      kind: stableKey,\n      description: \"New Relationship\",\n      srcKinds: [],\n      dstKinds: [],\n      cullable: true,\n      decayRate: \"medium\",\n      polarity: \"neutral\",\n      _key: stableKey,\n    };\n    onChange([...relationshipKinds, newRel]);\n    setExpandedRels((prev) => ({ ...prev, [stableKey]: true }));\n  };\n\n  const updateRel = (relKind, updates) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    onChange(relationshipKinds.map((r) => (r.kind === relKind ? { ...r, ...updates } : r)));\n  };\n\n  const deleteRel = (relKind) => {\n    const existing = relationshipKinds.find((r) => r.kind === relKind);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this relationship kind?\")) {\n      onChange(relationshipKinds.filter((r) => r.kind !== relKind));\n    }\n  };\n\n  const toggleEntityKind = (relKind, field, entityKindId) => {\n    const rel = relationshipKinds.find((r) => r.kind === relKind);\n    if (!rel || rel.isFramework) return;\n    const current = rel[field] || [];\n    const updated = current.includes(entityKindId)\n      ? current.filter((k) => k !== entityKindId)\n      : [...current, entityKindId];\n    updateRel(relKind, { [field]: updated });\n  };\n\n  const getSummary = (rel) => {\n    const srcNames =\n      rel.srcKinds?.length > 0\n        ? rel.srcKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    const dstNames =\n      rel.dstKinds?.length > 0\n        ? rel.dstKinds\n            .map((k) => entityKinds.find((ek) => ek.kind === k)?.description || k)\n            .slice(0, 2)\n        : [\"Any\"];\n    return { srcNames, dstNames };\n  };\n\n  const renderHeaderActions = () => (\n    <button className=\"btn btn-primary\" onClick={addRelationship}>\n      + Add Relationship\n    </button>\n  );\n\n  const renderRelationshipActions = (rel, srcNames, dstNames, isFramework) => (\n    <>\n      <UsageBadges usage={getRelationshipKindUsageSummary(schemaUsage, rel.kind)} compact />\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {rel.cullable === false && <span className=\"badge badge-info\">protected</span>}\n      <div className=\"text-muted text-small rke-actions-flow\">\n        {srcNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.srcKinds?.length > 2 && <span>+{rel.srcKinds.length - 2}</span>}\n        <span>\u2192</span>\n        {dstNames.map((name, i) => (\n          <span key={i} className=\"badge\">\n            {name}\n          </span>\n        ))}\n        {rel.dstKinds?.length > 2 && <span>+{rel.dstKinds.length - 2}</span>}\n      </div>\n    </>\n  );\n\n  return (\n    <div className=\"editor-container rke-container\">\n      <SectionHeader\n        title=\"Relationship Kinds\"\n        description=\"Define how entities can be connected to each other.\"\n        count={relationshipKinds.length}\n        actions={renderHeaderActions()}\n      />\n\n      {relationshipKinds.length === 0 ? (\n        <EmptyState\n          icon=\"\ud83d\udd17\"\n          title=\"No relationship kinds defined\"\n          description=\"Add one to connect entities.\"\n        />\n      ) : (\n        <div className=\"list-stack\">\n          {relationshipKinds.map((rel) => {\n            const stableKey = getStableKey(rel);\n            const isExpanded = expandedRels[stableKey];\n            const { srcNames, dstNames } = getSummary(rel);\n            const isFramework = Boolean(rel.isFramework);\n\n            return (\n              <ExpandableCard\n                key={stableKey}\n                expanded={isExpanded}\n                onToggle={toggleRel}\n                toggleId={stableKey}\n                title={rel.description}\n                subtitle={rel.kind}\n                actions={renderRelationshipActions(rel, srcNames, dstNames, isFramework)}\n              >\n                {/* Display Name and Kind ID */}\n                <div className=\"rke-name-row\">\n                  <FormGroup label=\"Display Name\">\n                    <input\n                      className=\"input\"\n                      value={rel.description}\n                      disabled={isFramework}\n                      onChange={(e) => updateRel(rel.kind, { description: e.target.value })}\n                      placeholder=\"Relationship display name\"\n                    />\n                  </FormGroup>\n                  <FormGroup label=\"Kind ID\">\n                    <input\n                      className=\"input\"\n                      value={rel.kind}\n                      disabled={isFramework}\n                      onChange={(e) => {\n                        const newKind = e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, \"\");\n                        if (\n                          newKind &&\n                          !relationshipKinds.some((r) => r.kind === newKind && r.kind !== rel.kind)\n                        ) {\n                          updateRel(rel.kind, { kind: newKind });\n                        }\n                      }}\n                      placeholder=\"relationship_kind_id\"\n                    />\n                  </FormGroup>\n                </div>\n\n                {/* Entity Kind Constraints */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-constraint-label\">\n                    Entity Kind Constraints\n                  </div>\n                  {entityKinds.length === 0 ? (\n                    <div className=\"text-muted text-small\">\n                      Define entity kinds first to set constraints.\n                    </div>\n                  ) : (\n                    <div className=\"rke-constraint-row\">\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Source</span>\n                          {rel.srcKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.srcKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"srcKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                      <div className=\"text-dim rke-arrow\">\n                        \u2192\n                      </div>\n                      <div className=\"rke-constraint-col\">\n                        <div className=\"rke-constraint-header\">\n                          <span className=\"text-small text-muted\">Destination</span>\n                          {rel.dstKinds?.length === 0 && (\n                            <span className=\"text-muted text-small\">any</span>\n                          )}\n                        </div>\n                        <div className=\"chip-list rke-chip-list-flush\">\n                          {entityKinds.map((ek) => (\n                            <div\n                              key={ek.kind}\n                              className={`chip chip-clickable ${rel.dstKinds?.includes(ek.kind) ? \"chip-active\" : \"\"} ${isFramework ? \"rke-chip-framework\" : \"\"}`}\n                              onClick={() => toggleEntityKind(rel.kind, \"dstKinds\", ek.kind)}\n                              role=\"button\"\n                              tabIndex={0}\n                              onKeyDown={(e) => { if (e.key === \"Enter\" || e.key === \" \") e.currentTarget.click(); }}\n                            >\n                              {ek.description}\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    </div>\n                  )}\n                </div>\n\n                {/* Maintenance Settings */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-maintenance-label\">\n                    Maintenance Settings\n                  </div>\n                  <div className=\"rke-maintenance-row\">\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Decay</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.decayRate || \"medium\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { decayRate: e.target.value })}\n                      >\n                        <option value=\"none\">None</option>\n                        <option value=\"slow\">Slow</option>\n                        <option value=\"medium\">Medium</option>\n                        <option value=\"fast\">Fast</option>\n                      </select>\n                    </div>\n                    <div className=\"rke-maintenance-field\">\n                      <span className=\"text-small text-muted\">Polarity</span>\n                      <select\n                        className=\"input rke-select-compact\"\n                        value={rel.polarity || \"neutral\"}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { polarity: e.target.value })}\n                        title=\"Affects narrative event types\"\n                      >\n                        <option value=\"positive\">Positive</option>\n                        <option value=\"neutral\">Neutral</option>\n                        <option value=\"negative\">Negative</option>\n                      </select>\n                    </div>\n                    <label className=\"rke-cullable-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={rel.cullable !== false}\n                        disabled={isFramework}\n                        onChange={(e) => updateRel(rel.kind, { cullable: e.target.checked })}\n                        className=\"rke-checkbox\"\n                      />\n                      <span className=\"text-small\">Cullable</span>\n                    </label>\n                  </div>\n                </div>\n\n                {/* Narrative Verbs */}\n                <div className=\"nested-section-compact\">\n                  <div className=\"label rke-verbs-label\">\n                    Narrative Verbs\n                  </div>\n                  <div className=\"text-muted text-small rke-verbs-hint\">\n                    Verbs used in narrative event descriptions when this relationship is formed or\n                    ended.\n                  </div>\n                  <div className=\"rke-verbs-row\">\n                    <FormGroup label=\"Formed\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.formed || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n                          updateRel(rel.kind, {\n                            verbs: { ...rel.verbs, formed: e.target.value },\n                          })\n                        }\n                        placeholder=\"e.g., joined, allied with\"\n                      />\n                    </FormGroup>\n                    <FormGroup label=\"Ended\" className=\"rke-verb-form\">\n                      <input\n                        className=\"input\"\n                        value={rel.verbs?.ended || \"\"}\n                        disabled={isFramework}\n                        onChange={(e) =>\n// ... (truncated)", "parameters": [{"name": "{\n  relationshipKinds,\n  entityKinds,\n  onChange,\n  schemaUsage = {},\n}", "type": "{ relationshipKinds: any; entityKinds: any; onChange: any; schemaUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/RelationshipKindMatrix.jsx", "sourceCode": "export default function RelationshipKindMatrix({\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}) {\n  // Build rows from relationship kinds\n  const rows = useMemo(() => {\n    return relationshipKinds.map((rel) => ({\n      id: rel.kind,\n      label: rel.description || rel.kind,\n      // Store original data for getCellValue\n      srcKinds: rel.srcKinds || [],\n      dstKinds: rel.dstKinds || [],\n      // Status badges\n      statusBadges: getStatusBadges(rel),\n    }));\n  }, [relationshipKinds]);\n\n  // Build columns from entity kinds\n  const columns = useMemo(() => {\n    return entityKinds.map((ek) => ({\n      id: ek.kind,\n      label: ek.description || ek.kind,\n    }));\n  }, [entityKinds]);\n\n  // Calculate coverage stats\n  const stats = useMemo(() => {\n    const totalRels = relationshipKinds.length;\n    const totalEntityKinds = entityKinds.length;\n\n    // Count relationships that have explicit constraints\n    const constrainedRels = relationshipKinds.filter(\n      (r) => r.srcKinds?.length > 0 || r.dstKinds?.length > 0\n    ).length;\n\n    // Count relationships with no constraints (wildcard)\n    const wildcardRels = totalRels - constrainedRels;\n\n    // Find entity kinds that are never used as source or destination\n    const usedAsSource = new Set();\n    const usedAsDestination = new Set();\n    relationshipKinds.forEach((rel) => {\n      (rel.srcKinds || []).forEach((k) => usedAsSource.add(k));\n      (rel.dstKinds || []).forEach((k) => usedAsDestination.add(k));\n    });\n\n    const result = [\n      { label: \"Relationships\", value: totalRels },\n      { label: \"Entity Kinds\", value: totalEntityKinds },\n      { label: \"Constrained\", value: constrainedRels },\n    ];\n\n    if (wildcardRels > 0) {\n      result.push({ label: \"Wildcards\", value: wildcardRels, variant: \"warning\" });\n    }\n\n    return result;\n  }, [relationshipKinds, entityKinds]);\n\n  // Get cell value for a relationship \u00d7 entity kind intersection\n  const getCellValue = useCallback((rowId, columnId, row) => {\n    // Check if explicitly constrained vs wildcard\n    const srcExplicit = row.srcKinds.length > 0 && row.srcKinds.includes(columnId);\n    const dstExplicit = row.dstKinds.length > 0 && row.dstKinds.includes(columnId);\n    const srcWildcard = row.srcKinds.length === 0;\n    const dstWildcard = row.dstKinds.length === 0;\n\n    if (srcExplicit && dstExplicit) return \"both\";\n    if (srcExplicit) return \"primary\"; // explicitly source\n    if (dstExplicit) return \"secondary\"; // explicitly destination\n    if (srcWildcard && dstWildcard) return \"both\"; // wildcard both\n    if (srcWildcard) return \"primary\"; // wildcard source\n    if (dstWildcard) return \"secondary\"; // wildcard destination\n    return \"none\";\n  }, []);\n\n  // Custom cell display for relationship coverage\n  const getCellDisplay = useCallback((value) => {\n    switch (value) {\n      case \"both\":\n        return { icon: \"B\", className: \"both\", title: \"Both source and destination\" };\n      case \"primary\":\n        return { icon: \"S\", className: \"primary\", title: \"Source only\" };\n      case \"secondary\":\n        return { icon: \"D\", className: \"secondary\", title: \"Destination only\" };\n      case \"none\":\n      default:\n        return { icon: \"-\", className: \"none\", title: \"Not allowed\" };\n    }\n  }, []);\n\n  // Handle row click to navigate to relationship\n  const handleRowClick = useCallback(\n    (rowId) => {\n      if (onNavigateToRelationship) {\n        onNavigateToRelationship(rowId);\n      }\n    },\n    [onNavigateToRelationship]\n  );\n\n  // Filter options\n  const filterOptions = useMemo(\n    () => [\n      {\n        id: \"wildcards\",\n        label: \"Wildcards Only\",\n        filter: (row) => row.srcKinds.length === 0 || row.dstKinds.length === 0,\n      },\n      {\n        id: \"constrained\",\n        label: \"Constrained Only\",\n        filter: (row) => row.srcKinds.length > 0 && row.dstKinds.length > 0,\n      },\n    ],\n    []\n  );\n\n  // Legend items\n  const legend = useMemo(\n    () => [\n      { icon: \"S\", className: \"primary\", label: \"Can be source\" },\n      { icon: \"D\", className: \"secondary\", label: \"Can be destination\" },\n      { icon: \"B\", className: \"both\", label: \"Both source and destination\" },\n      { icon: \"-\", className: \"none\", label: \"Not allowed\" },\n    ],\n    []\n  );\n\n  return (\n    <CoverageMatrix\n      rows={rows}\n      columns={columns}\n      getCellValue={getCellValue}\n      getCellDisplay={getCellDisplay}\n      onRowClick={handleRowClick}\n      title=\"Relationship \u00d7 Entity Kind Matrix\"\n      subtitle=\"Shows which entity kinds can participate in each relationship as source (S), destination (D), or both (B). Click a row to navigate to that relationship.\"\n      stats={stats}\n      legend={legend}\n      searchPlaceholder=\"Search relationships...\"\n      groupByField={null}\n      emptyMessage=\"No relationship kinds defined.\"\n      filterOptions={filterOptions}\n    />\n  );\n}", "parameters": [{"name": "{\n  relationshipKinds = [],\n  entityKinds = [],\n  onNavigateToRelationship,\n}", "type": "{ relationshipKinds?: any[]; entityKinds?: any[]; onNavigateToRelationship: any; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}, {"id": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx::default", "name": "default", "kind": "function", "filePath": "apps/canonry/webui/src/components/SchemaEditor/TagRegistryEditor.jsx", "sourceCode": "export default function TagRegistryEditor({\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}) {\n  const [expandedTags, setExpandedTags] = useState({});\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [categoryFilter, setCategoryFilter] = useState(\"all\");\n  const [rarityFilter, setRarityFilter] = useState(\"all\");\n\n  // Compute stats\n  const stats = useMemo(() => {\n    const byCategory = {};\n    const byRarity = {};\n    CATEGORIES.forEach((c) => (byCategory[c] = 0));\n    RARITIES.forEach((r) => (byRarity[r] = 0));\n    tagRegistry.forEach((tag) => {\n      byCategory[tag.category] = (byCategory[tag.category] || 0) + 1;\n      byRarity[tag.rarity] = (byRarity[tag.rarity] || 0) + 1;\n    });\n    return { total: tagRegistry.length, byCategory, byRarity };\n  }, [tagRegistry]);\n\n  // Filter tags\n  const filteredTags = useMemo(() => {\n    return tagRegistry.filter((tag) => {\n      const matchesSearch =\n        !searchQuery ||\n        tag.tag.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        tag.description?.toLowerCase().includes(searchQuery.toLowerCase());\n      const matchesCategory = categoryFilter === \"all\" || tag.category === categoryFilter;\n      const matchesRarity = rarityFilter === \"all\" || tag.rarity === rarityFilter;\n      return matchesSearch && matchesCategory && matchesRarity;\n    });\n  }, [tagRegistry, searchQuery, categoryFilter, rarityFilter]);\n\n  const toggleTag = useCallback((tagId) => {\n    setExpandedTags((prev) => ({ ...prev, [tagId]: !prev[tagId] }));\n  }, []);\n\n  const addTag = () => {\n    const newTag = {\n      tag: `new_tag_${Date.now()}`,\n      category: \"trait\",\n      rarity: \"common\",\n      description: \"New tag description\",\n      usageCount: 0,\n      templates: [],\n      entityKinds: [],\n      minUsage: 1,\n      maxUsage: 50,\n      relatedTags: [],\n      conflictingTags: [],\n    };\n    onChange([newTag, ...tagRegistry]);\n    setExpandedTags((prev) => ({ ...prev, [newTag.tag]: true }));\n  };\n\n  const updateTag = (tagId, updates) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    onChange(tagRegistry.map((t) => (t.tag === tagId ? { ...t, ...updates } : t)));\n  };\n\n  const renderTagTitle = (tag) => <span className=\"tre-monospace\">{tag.tag}</span>;\n\n  const renderTagActions = (tag, catColor, rarColor, isFramework) => (\n    <>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': catColor.bg, '--tre-badge-color': catColor.color }}>\n        {tag.category}\n      </span>\n      <span className=\"badge tre-badge-dynamic\" style={{ '--tre-badge-bg': rarColor.bg, '--tre-badge-color': rarColor.color }}>\n        {tag.rarity}\n      </span>\n      {tag.isAxis && (\n        <span\n          className=\"badge tre-badge-dynamic\"\n          style={{ '--tre-badge-bg': 'rgba(34, 211, 238, 0.2)', '--tre-badge-color': '#22d3ee' }}\n        >\n          \u2194 axis\n        </span>\n      )}\n      {isFramework && <span className=\"badge badge-info\">framework</span>}\n      {tagUsage[tag.tag] && <UsageBadges usage={tagUsage[tag.tag]} compact />}\n      <span className=\"text-muted text-small\">\n        {tag.minUsage || 0}-{tag.maxUsage || \"\u221e\"} | {(tag.entityKinds || []).length} kinds\n      </span>\n    </>\n  );\n\n  const deleteTag = (tagId) => {\n    const existing = tagRegistry.find((t) => t.tag === tagId);\n    if (existing?.isFramework) return;\n    if (confirm(\"Delete this tag? This cannot be undone.\")) {\n      onChange(tagRegistry.filter((t) => t.tag !== tagId));\n    }\n  };\n\n  // Related tags management\n  const removeRelatedTag = (tagId, relatedTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, { relatedTags: (tag.relatedTags || []).filter((r) => r !== relatedTag) });\n  };\n\n  // Conflicting tags management\n  const removeConflictingTag = (tagId, conflictingTag) => {\n    const tag = tagRegistry.find((t) => t.tag === tagId);\n    if (!tag) return;\n    updateTag(tagId, {\n      conflictingTags: (tag.conflictingTags || []).filter((c) => c !== conflictingTag),\n    });\n  };\n\n  const allTagNames = useMemo(() => tagRegistry.map((t) => t.tag), [tagRegistry]);\n\n  const handleTagIdChange = (oldId, newId) => {\n    const updatedRegistry = tagRegistry.map((t) => {\n      if (t.tag === oldId) return { ...t, tag: newId };\n      const updated = { ...t };\n      if (t.relatedTags?.includes(oldId)) {\n        updated.relatedTags = t.relatedTags.map((r) =>\n          r === oldId ? newId : r\n        );\n      }\n      if (t.conflictingTags?.includes(oldId)) {\n        updated.conflictingTags = t.conflictingTags.map((c) =>\n          c === oldId ? newId : c\n        );\n      }\n      return updated;\n    });\n    setExpandedTags((prev) => {\n      const updated = { ...prev };\n      if (updated[oldId]) {\n        updated[newId] = updated[oldId];\n        delete updated[oldId];\n      }\n      return updated;\n    });\n    onChange(updatedRegistry);\n  };\n\n  const handleEntityKindToggle = (tag, ek, isFramework) => {\n    if (isFramework) return;\n    const isSelected = (tag.entityKinds || []).includes(ek.kind);\n    const current = tag.entityKinds || [];\n    const updated = isSelected\n      ? current.filter((k) => k !== ek.kind)\n      : [...current, ek.kind];\n    updateTag(tag.tag, { entityKinds: updated });\n  };\n\n  return (\n    <div className=\"editor-container tre-container\">\n      <SectionHeader\n        title=\"Tag Registry\"\n        description=\"Define tags that categorize entities. Tags provide governance through usage limits, relationships, and conflicts.\"\n      />\n\n      {/* Stats Bar - Compact */}\n      <div className=\"tre-stats-bar\">\n        <span className=\"text-small tre-stat-total\">\n          <strong>{stats.total}</strong> tags\n        </span>\n        {CATEGORIES.filter((cat) => stats.byCategory[cat] > 0).map((cat) => (\n          <span\n            key={cat}\n            className=\"text-small tre-stat-category\"\n            style={{\n              '--tre-stat-bg': CATEGORY_COLORS[cat].bg,\n              '--tre-stat-color': CATEGORY_COLORS[cat].color,\n            }}\n          >\n            {stats.byCategory[cat]} {cat}\n          </span>\n        ))}\n      </div>\n\n      {/* Toolbar */}\n      <div className=\"tre-toolbar\">\n        <input\n          className=\"input tre-search\"\n          type=\"text\"\n          placeholder=\"Search tags...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n        />\n        <select\n          className=\"input\"\n          value={categoryFilter}\n          onChange={(e) => setCategoryFilter(e.target.value)}\n        >\n          <option value=\"all\">All Categories</option>\n          {CATEGORIES.map((cat) => (\n            <option key={cat} value={cat}>\n              {cat}\n            </option>\n          ))}\n        </select>\n        <select\n          className=\"input\"\n          value={rarityFilter}\n          onChange={(e) => setRarityFilter(e.target.value)}\n        >\n          <option value=\"all\">All Rarities</option>\n          {RARITIES.map((r) => (\n            <option key={r} value={r}>\n              {r}\n            </option>\n          ))}\n        </select>\n        <span className=\"text-muted\">\n          {filteredTags.length} of {tagRegistry.length} tags\n        </span>\n        <button className=\"btn btn-primary\" onClick={addTag}>\n          + Add Tag\n        </button>\n      </div>\n\n      {tagRegistry.length === 0 && (\n        <EmptyState icon=\"\ud83c\udff7\ufe0f\" title=\"No tags defined\" description=\"Add one to get started.\" />\n      )}\n      {tagRegistry.length > 0 && filteredTags.length === 0 && (\n        <EmptyState icon=\"\ud83d\udd0d\" title=\"No matches\" description=\"No tags match your filters.\" />\n      )}\n      {filteredTags.length > 0 && (\n        <div className=\"list-stack\">\n          {filteredTags.map((tag) => {\n            const isExpanded = expandedTags[tag.tag];\n            const catColor = CATEGORY_COLORS[tag.category] || CATEGORY_COLORS.trait;\n            const rarColor = RARITY_COLORS[tag.rarity] || RARITY_COLORS.common;\n            const isFramework = Boolean(tag.isFramework);\n\n            return (\n              <ExpandableCard\n                key={tag.tag}\n                expanded={isExpanded}\n                onToggle={toggleTag}\n                toggleId={tag.tag}\n                title={renderTagTitle(tag)}\n                actions={renderTagActions(tag, catColor, rarColor, isFramework)}\n              >\n                {/* Basic Info Row */}\n                <div className=\"tre-basic-row\">\n                  <div className=\"tre-field-id\">\n                    <div className=\"label tre-label-gap\">\n                      Tag ID\n                    </div>\n                    <TagIdInput\n                      value={tag.tag}\n                      allTagIds={allTagNames.filter((t) => t !== tag.tag)}\n                      disabled={isFramework}\n                      onChange={(newId) => handleTagIdChange(tag.tag, newId)}\n                    />\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Category\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.category}\n                      onChange={(e) => updateTag(tag.tag, { category: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {CATEGORIES.map((cat) => (\n                        <option key={cat} value={cat}>\n                          {cat}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div>\n                    <div className=\"label tre-label-gap\">\n                      Rarity\n                    </div>\n                    <select\n                      className=\"input tre-select-compact\"\n                      value={tag.rarity}\n                      onChange={(e) => updateTag(tag.tag, { rarity: e.target.value })}\n                      disabled={isFramework}\n                    >\n                      {RARITIES.map((r) => (\n                        <option key={r} value={r}>\n                          {r}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                  <div className=\"tre-axis-group\">\n                    <label className=\"tre-axis-label\">\n                      <input\n                        type=\"checkbox\"\n                        checked={tag.isAxis || false}\n                        disabled={isFramework}\n                        onChange={(e) => updateTag(tag.tag, { isAxis: e.target.checked })}\n                        className=\"tre-checkbox\"\n                      />\n// ... (truncated)", "parameters": [{"name": "{\n  tagRegistry = [],\n  entityKinds = [],\n  onChange,\n  tagUsage = {},\n}", "type": "{ tagRegistry?: any[]; entityKinds?: any[]; onChange: any; tagUsage?: {}; }", "optional": false}], "returnType": "import(\"/home/tsonu/src/the-canonry/node_modules/.pnpm/@types+react@19.2.14/node_modules/@types/react/jsx-runtime\").JSX.Element"}]